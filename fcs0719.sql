-- MySQL dump 10.13  Distrib 8.0.19, for osx10.15 (x86_64)
--
-- Host: localhost    Database: FlashCardShark
-- ------------------------------------------------------
-- Server version	8.0.19

/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!50503 SET NAMES utf8mb4 */;
/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
/*!40103 SET TIME_ZONE='+00:00' */;
/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;

--
-- Table structure for table `Avatars`
--

DROP TABLE IF EXISTS `Avatars`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `Avatars` (
  `avatar_id` int NOT NULL AUTO_INCREMENT,
  `style` varchar(20) DEFAULT NULL,
  `birthstar` varchar(20) DEFAULT NULL,
  `user_id` int NOT NULL,
  `primary_weapon` int NOT NULL,
  `name` varchar(30) NOT NULL,
  `level` int NOT NULL,
  PRIMARY KEY (`avatar_id`),
  KEY `user_id` (`user_id`),
  KEY `fk_prime_weapon` (`primary_weapon`),
  CONSTRAINT `Avatars_ibfk_1` FOREIGN KEY (`user_id`) REFERENCES `FlashUsers` (`user_id`) ON DELETE CASCADE,
  CONSTRAINT `Avatars_ibfk_2` FOREIGN KEY (`primary_weapon`) REFERENCES `Weapons` (`weapon_id`),
  CONSTRAINT `fk_prime_weapon` FOREIGN KEY (`primary_weapon`) REFERENCES `Weapons` (`weapon_id`) ON DELETE CASCADE
) ENGINE=InnoDB AUTO_INCREMENT=15 DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `Avatars`
--

LOCK TABLES `Avatars` WRITE;
/*!40000 ALTER TABLE `Avatars` DISABLE KEYS */;
/*!40000 ALTER TABLE `Avatars` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `CardSetCards`
--

DROP TABLE IF EXISTS `CardSetCards`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `CardSetCards` (
  `card_id` int NOT NULL,
  `set_id` int NOT NULL,
  PRIMARY KEY (`card_id`,`set_id`),
  KEY `set_id` (`set_id`),
  CONSTRAINT `CardSetCards_ibfk_1` FOREIGN KEY (`card_id`) REFERENCES `FlashCards` (`card_id`) ON DELETE CASCADE,
  CONSTRAINT `CardSetCards_ibfk_2` FOREIGN KEY (`set_id`) REFERENCES `CardSets` (`set_id`) ON DELETE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `CardSetCards`
--

LOCK TABLES `CardSetCards` WRITE;
/*!40000 ALTER TABLE `CardSetCards` DISABLE KEYS */;
INSERT INTO `CardSetCards` VALUES (28,21),(29,21),(30,21),(27,22),(30,22),(32,22),(44,25),(45,25),(46,25),(111,35),(114,35),(310,36),(314,36),(1415,36),(1416,36);
/*!40000 ALTER TABLE `CardSetCards` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `CardSets`
--

DROP TABLE IF EXISTS `CardSets`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `CardSets` (
  `set_id` int NOT NULL AUTO_INCREMENT,
  `setname` varchar(15) NOT NULL,
  `description` varchar(40) DEFAULT NULL,
  PRIMARY KEY (`set_id`)
) ENGINE=InnoDB AUTO_INCREMENT=37 DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `CardSets`
--

LOCK TABLES `CardSets` WRITE;
/*!40000 ALTER TABLE `CardSets` DISABLE KEYS */;
INSERT INTO `CardSets` VALUES (2,'createTEST','none'),(9,'TESTSET','THIS WAS CREATED FOR A TEST RUN'),(10,'asdf','asf'),(11,'asd','d'),(12,'adsf','adsf'),(13,'adf','adf'),(14,'a','aaa'),(15,'f','ff'),(16,'EMEINEM','flip it '),(17,'50 CENT !','IN DA CLUB'),(18,'EMINEM','GO TO SLEEP BITCH'),(19,'SLIM SHADY','INFINITE'),(20,'adsf','asdf'),(21,'dd','ddd'),(22,'fff','fff'),(23,'BIG DOG','BIG BADD JOHN'),(24,'JHONE','adsfasdf'),(25,'asdf','asdf'),(26,'asdf','asdf'),(27,'dd','dd'),(28,'asd','asd'),(29,'',''),(30,'asd','asdf'),(31,'TESTSET','THIS WAS CREATED FOR A TEST RUN'),(32,'asdf','asdf'),(33,'adf','adsf'),(34,'AAAAAAAAA','AAAAAAA'),(35,'TEST001','none'),(36,'TestBinSearch','Know thy cards');
/*!40000 ALTER TABLE `CardSets` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `CardSetUsers`
--

DROP TABLE IF EXISTS `CardSetUsers`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `CardSetUsers` (
  `user_id` int NOT NULL,
  `set_id` int NOT NULL,
  PRIMARY KEY (`user_id`,`set_id`),
  KEY `fk_set` (`set_id`),
  CONSTRAINT `fk_set` FOREIGN KEY (`set_id`) REFERENCES `CardSets` (`set_id`) ON DELETE CASCADE,
  CONSTRAINT `fk_user` FOREIGN KEY (`user_id`) REFERENCES `FlashUsers` (`user_id`) ON DELETE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `CardSetUsers`
--

LOCK TABLES `CardSetUsers` WRITE;
/*!40000 ALTER TABLE `CardSetUsers` DISABLE KEYS */;
INSERT INTO `CardSetUsers` VALUES (1,9),(1,10),(1,11),(1,12),(1,13),(1,14),(1,15),(1,16),(1,17),(1,18),(1,19),(1,20),(1,21),(1,22),(1,23),(1,24),(1,25),(1,26),(1,27),(1,28),(1,29),(1,30),(1,31),(1,32),(1,33),(1,34),(1,35),(1,36);
/*!40000 ALTER TABLE `CardSetUsers` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `FlashCards`
--

DROP TABLE IF EXISTS `FlashCards`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `FlashCards` (
  `card_id` int NOT NULL AUTO_INCREMENT,
  `card` varchar(3000) DEFAULT NULL,
  `answer` varchar(3000) DEFAULT NULL,
  `category` varchar(20) NOT NULL,
  `owner_id` int NOT NULL,
  `collection` varchar(20) DEFAULT NULL,
  PRIMARY KEY (`card_id`),
  KEY `owner_id` (`owner_id`),
  CONSTRAINT `flashcards_ibfk_1` FOREIGN KEY (`owner_id`) REFERENCES `FlashUsers` (`user_id`)
) ENGINE=InnoDB AUTO_INCREMENT=7125 DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `FlashCards`
--

LOCK TABLES `FlashCards` WRITE;
/*!40000 ALTER TABLE `FlashCards` DISABLE KEYS */;
INSERT INTO `FlashCards` VALUES (27,'class A implements AutoCloseable {\n	public void close() {\n		sout(\"A\");\n	}\n}\n\nclass B implements AutoCloseable {\n	public void close() {\n		sout(\"B\");\n	}\n}\n\nclass C {\n	psvm(sa){\n		try(A a = new A(); B b = new B()){\n			throw new RuntimeException();\n		} catch(EXception e) {\n			sout(\"catch\");\n		}\n	}\n}\n\nwhat does it print?','B\nA\ncatch\n\nResources are closed in reverse order from what they are declared.','Exceptions',1,NULL),(28,'public class Suppressed {\n	psvm(sa) {\n		try(One one = new One()) {\n			throw new exception(\"try\");\n		} catch (Exception e) {\n			sout(e.getMessage());\n			\n			for(Throwable t : e.getSuppressed()){\n				sout(\"suppressed:\" + t);\n		}	}\n	}\n}\n\nclass One implements AutoCloseable {\n	public void close() throws IOException {\n		throw new IOException(\"Closing\");\n	}\n}','Try\nsuppressed: java.io.IOException: Closing\n\nafter the exception in the try block gets thrown on line 4, the try with \nresources still calls close() and the catch block catches one \nof the exceptions.\n\nJava adds any excpeittions thrown by close() methods to a suppressed array in the main excpetion. \n\nif no other exception happens in the try block the exceptioon thrown in\nclose() gets treated as the main excpetion  for the catch block. ','Exceptions',1,NULL),(29,'If the catch or Finally block throws an exception NO SUPPRESSION HAPPENS\nthe last exception thrown gets sent to the caller rather than the one from the \ntry- just like before try with resources','got it ','Exceptions',1,NULL),(30,'class Bad implements AutoCloseable {\n	String name;\n	Bad(String n) { name = n; }\n	public void close() throws IOException {\n		throw new IOException(\"Closing -\" +name);\n	}\n}\n\npublic class Suppressed {\n	public static void main(SA) {\n		try(Bad b1 = new Bad(\"1\"); Bad b2 = new Bad(\"2\")) {\n			\n		} catch(Exception e) {\n			sout(e.getMessage());\n			for(Throwable t : e.getSuppressed()) {\n				sout(\"suppressed:\" + t);\n			}\n		}\n	}\n}','Closing - 2\nsuppressed: java.io.IOException: Closing - 1\n\nresources close in the opposite order they are declared\ndd','Exceptions',1,NULL),(31,'Stream classes are used to read and write bytes, and Readers and Writers\nare used to read write Characters....','Since all file IO on the exam is related to characters, if you see a Stream\nlike DataOutputStream the the question is probably about serialization\nor something unrelated to the actual IO objective','Input/Output',1,NULL),(32,'psvm(SA) {\n	try {\n		boolean newFile = false;\n		File file = new File(\"fiileWrite1.txt\");\n		sout(file.exists());\n		newFile = file.createNewFile());\n		sout(newFile);\n		sout(file.exists());\n	} catch (IOException e) {}\n}	','// first time\nfalse\ntrue \ntrue\n\n//second time\ntrue\nfalse\ntrue\n\nexists returns false the first time becasue the file was created as an object\nbut not yet as a physical file. ','Input/Output',1,NULL),(33,'public static void main(String[] args){\n        File newFile = new File(\"/home/maxbisesi/Public/textFile5.txt\");\n        try{\n            System.out.println(newFile.exists());\n            newFile.createNewFile();\n            System.out.println(newFile.exists());\n        } catch(IOException e){\n            \n        }   \n    }','This method returns true if it can find the actual file\n\nfalse\n','Input/Output',1,NULL),(36,'File class key methods ','createNewFile()\ndelete()\nexists()\nisDirectory()\nisfile()\nlist()\nmkdir()\nrenameTo()','Input/Output',1,NULL),(37,'FileWriter class Constructors	','FileWriter(File file)\n\nFileWriter(String filename)','Input/Output',1,NULL),(38,'FileWriter class key methods 	','close()\nflush()\nwrite()','Input/Output',1,NULL),(39,'BufferedWriter class constructors	','BufferedWriter(Writer out)','Input/Output',1,NULL),(40,'BufferedWriter key methods	','close() \nflush()\nnewLine()\nwrite()','Input/Output',1,NULL),(41,'PrintWriter constructors','PrintWriter(File file)\nCreates a new PrintWriter, without automatic line flushing, with the specified file.\n\nPrintWriter(File file, String csn)\nCreates a new PrintWriter, without automatic line flushing, with the specified file and charset.\n\nPrintWriter(OutputStream out)\nCreates a new PrintWriter, without automatic line flushing, from an existing OutputStream.\n\nPrintWriter(OutputStream out, boolean autoFlush)\nCreates a new PrintWriter from an existing OutputStream.\n\nPrintWriter(String fileName)\nCreates a new PrintWriter, without automatic line flushing, with the specified file name.\n\nPrintWriter(String fileName, String csn)\nCreates a new PrintWriter, without automatic line flushing, with the specified file name and charset.\n\nPrintWriter(Writer out)\nCreates a new PrintWriter, without automatic line flushing.\n\nPrintWriter(Writer out, boolean autoFlush)\nCreates a new PrintWriter.','Input/Output',1,NULL),(42,'FileReader key methods 	','read()','Input/Output',1,NULL),(43,'BufferedReader constructors	','Reader','Input/Output',1,NULL),(44,'BufferedReader key methods','read()\nreadLine()','Input/Output',1,NULL),(45,'File file = new file(\"filewriter2.txt\");\nFileWriter fw = new fileWriter(file);\n\nPrintWriter pw = new PrintWriter (fw);\n\npw.println(\"hello\");\npw.println(\"world\"));','filewrite2.txt would contain the text:\n\nhello\nworld','Input/Output',1,NULL),(46,'File file = new File(\"filewrite2.txt\");\nFileReader fr = new FileReader(file);\nBufferedReader br = new BufferedReader(fr);\n\nString data = br.readLine();','','Input/Output',1,NULL),(47,'File file = new File(\"foo\");\n\nif \"foo\" does not exist no actual file is created.\n\nif \"foo\" does exists, the new File object refers to the existing file. ','got it ','Input/Output',1,NULL),(48,'When creating a Path you can seperate out folder and filename as much\nor as little as you want. When you don\'t begin with a root the Path\nis considered a relative path, which means Java looks from the current\ndirectory.\n\nPath p6 = Paths.get(\"tmp\", \"file1.txt\"); // relative path\n\n/ (root)\n	| - - tmp\n		| - file1.txt\n		| - tmp\n			| - file1.txt\n','If this program is run from the root, it is the one in /tmp/file1.txt\n\nif it is run from /tmp it is the one in /tmp/tmp/file1.txt\n\nif the program is run from anywhere else the path refers to a file that doesn\nnot exist. ','Input/Output',1,NULL),(49,'With IO a file doesn\'t exists just because you create a File object.\nIt is the same with Path objects\n\nPath path = Paths.get(\"fileWrite1.txt\");\nsout(Files.exists(path)); // false\nFiles.createFile(path); \nsout(Files.exists(path)); // true','got it ','Input/Output',1,NULL),(50,'create directories one at a time or all at once	......\n\nTHE directory must exist by the time the file is created','Path path1 = Paths.get(\"/java/source\");\nPath path2 = Paths.get(\"/java/source/directory\");\nPath file = Paths.get(\"/java/source/directory/Program.java\");\nFiles.createDirectory(path1);\nFiles.createDirectory(path2);\nFiles.createFile(file);\n\n// all at once\n\nFiles.createDirectories(path2);\nFile.createFile(file);','Input/Output',1,NULL),(51,'Date januaryFirst = new GregorianCalendar(20q3, Calendar.January, 1).getTime();\n\nFile file = new File(\"c:/temp/file\");\nfile.createNewFile();\nfile.setLastModified(januaryFirst.getTime());\nfile.setLastModified(januaryFirst.getTime());\nsout(file.lastModified());\nfile.delete();','13570164000000','Input/Output',1,NULL),(52,'Path path = Paths.get(\"c:/temp/file2\");\nDate januaryFirst = new GregorianCalendar(2013,Calendar.JANUARY, 1).getTime();\nFiles.createFile(path);\nFileTime fileTime = FileTime.fromMillis(januaryFirst.getTime());\nFiles.setLastModifiedTime(path,fileTime);\nsout(Files.getLastModifiedTime(path));\nFiles.delete((path);','2013-01-01T05','Input/Output',1,NULL),(54,'public class Hello {\n    static Thread max ,angela;\n    public static void main(String[] args){\n        angela = new Thread() {\n            public void run(){\n                System.out.println(\"A\");\n                try {\n                    max.sleep(1000);\n                } catch(Exception e){\n                    System.out.println(\"B\");\n                }\n                System.out.println(\"C\");\n                \n            }\n        };\n        \n        max = new Thread() {\n            public void run(){\n                System.out.println(\"D\");\n                try {\n                    angela.wait(); \n                } catch(Exception e){\n                    System.out.println(\"E\");\n                }\n                \n                System.out.println(\"F\");\n            }\n        };\n        \n        max.start();\n        angela.start();   \n    }\n} ','','Input/Output',1,NULL),(55,'How would you get theread permision set of a Path and a File?\n\nFile file = new file(\"test\");\nPath path = Paths.get(\"test\");','file.canRead();\n\nFiles.isReadable(path);','Input/Output',1,NULL),(56,'How would you get write and or execute permision set of a Path and a File?\n\nFile file = new file(\"test\");\nPath path = Paths.get(\"test\");','file.canWrite();\nfile.canExecute();\n\nFiles.isWritable(path);\nFiles.isExecutable(path);','Input/Output',1,NULL),(57,'How do you set the last modified time of a path and file?\n\nFile file = new file(\"test\");\nPath path = Paths.get(\"test\");','file.setLastModifed(timeinMillis);\n\nFileTime ft = FileTime.fromMillis(timeInMillis);\nFiles.setLastModifiedTime(path,ft);','Input/Output',1,NULL),(58,'How would you get write and or execute permision set of a Path and a File?\n\nFile file = new file(\"test\");\nPath path = Paths.get(\"test\");','file.canWrite();\nfile.canExecute();\n\nFiles.isWritable(path);\nFiles.isExecutable(path);\n\nUPDATEEE!','Input/Output',1,NULL),(59,'public class Hello {\n    static Thread max ,angela;\n    public static void main(String[] args){\n        angela = new Thread() {\n            public void run(){\n                System.out.println(\"A\");\n                try {\n                    max.sleep(1000);\n                } catch(Exception e){\n                    System.out.println(\"B\");\n                }\n                System.out.println(\"C\");\n                \n            }\n        };\n        \n        max = new Thread() {\n            public void run(){\n                System.out.println(\"D\");\n                try {\n                    angela.wait(); \n                } catch(Exception e){\n                    System.out.println(\"E\");\n                }\n                \n                System.out.println(\"F\");\n            }\n        };\n        \n        max.start();\n        angela.start();   \n    }\n} ','A C D E F \n\nin an undeterminable order, although thread angela uses the max reference\n.Sleep is static and therefore she puts herself to sleep. This is why\nreferences shouldn\'t be used for static methods. \n\nmax trys to synchronize on angela but he does not own the lock so he therefore\ncannot and throws an IllegalMonitorStateException. \n\n... \n\noh yea update','Input/Output',1,NULL),(60,'How would you construct a PosixFileAttribute object?	','PosixFileAttributes pox = Files.readAttributes(path, PosixFileAttributes.class);\n\nupdate','Input/Output',1,NULL),(61,'How would you set a Unix File\'s permissions in Java?	','Path path = Paths.get(\"/tmp/file2\");\nFiles.createFile(path);\nPosixFileAttributes ps = Files.readAttributes(path, PosixFileAttributes.class);\n\nSet<PosixFilePermission> perms = PosixFilePermission.fromString(\"rw-r--r--\");\n\nFiles.setPosixFilePermissions(path,perms);\n\nsout( ps.permissions() );\n\nTHe output would be:\n\n[OWNER_WRITE, GROUP_READ, OTHERS_READ, OWNER_READ ]','Input/Output',1,NULL),(62,'How to take modified times from one file\nand write new BasicFileAttributes\' last modified times\nlast access time and creation time to another file ... ?','BasicFileAttributes basic = Files.readAttributes(path1, BasicFileAttribute.class );\n\nFileTime at = basic.lastAccessTime();\nFileTime update = basic.lastModifiedTime();\nFileTime now = FileTime.fromMillis(System.currentTimeMiilis() );\n\nPath file = Paths.get(\"/temp/file.txt\");\nFiles.createFile(file);\n\nBasicFileAttributeView view = Files.getBasicFileAttributeView(file, BasicFileAttributeView.class);\n\nview.setTimes(update, at, now);','Input/Output',1,NULL),(63,'BasicFileAttributeView is a...\n\nClass\n\nInterface\n\nAbstract class     ?','... interface\n\nmethods:\n\nString 	name()\nReturns the name of the attribute view.\n\nBasicFileAttributes 	readAttributes()\nReads the basic file attributes as a bulk operation.\n\nvoid 	setTimes(FileTime lastModifiedTime, FileTime lastAccessTime, FileTime createTime)\n\nUpdates any or all of the file\'s last modified time, last access time, and create time attributes.','Input/Output',1,NULL),(64,'interface BasicFileAttributes methods.... ','FileTime 	creationTime()\nReturns the creation time.\n\nObject 	fileKey()\nReturns an object that uniquely identifies the given file, or null if a file key is not available.\n\nboolean 	isDirectory()\nTells whether the file is a directory.\n\nboolean 	isOther()\nTells whether the file is something other than a regular file, directory, or symbolic link.\n\nboolean 	isRegularFile()\nTells whether the file is a regular file with opaque content.\n\nboolean 	isSymbolicLink()\nTells whether the file is a symbolic link.\n\nFileTime 	lastAccessTime()\nReturns the time of last access.\n\nFileTime 	lastModifiedTime()\nReturns the time of last modification.\n\nlong 	size()\nReturns the size of the file (in bytes).','Input/Output',1,NULL),(65,'interface PosixFileAttributes methods','GroupPrincipal 	group()\nReturns the group owner of the file.\n\nUserPrincipal 	owner()\nReturns the owner of the file.\n\nSet<PosixFilePermission> 	permissions()\nReturns the permissions of the file.','Input/Output',1,NULL),(66,'interface PosixFileAttributeView methods ...','String 	name()\nReturns the name of the attribute view.\n\nPosixFileAttributes 	readAttributes()\nReads the basic file attributes as a bulk operation.\n\nvoid 	setGroup(GroupPrincipal group)\nUpdates the file group-owner.\n\nvoid 	setPermissions(Set<PosixFilePermission> perms)\nUpdates the file permissions.','Input/Output',1,NULL),(67,'With DosFileAttributeView you can set what new and different file types ?','DosFileAttributeView has methods...\n\nsetArchive()\nsetHidden()\nsetReadOnly()\nsetSystem()\n\nfor Windows specific files ','Input/Output',1,NULL),(68,'interface DosFileAttributeView methods...','String 	name()\nReturns the name of the attribute view.\n\nDosFileAttributes 	readAttributes()\nReads the basic file attributes as a bulk operation.\n\nvoid 	setArchive(boolean value)\nUpdates the value of the archive attribute.\n\nvoid 	setHidden(boolean value)\nUpdates the value of the hidden attribute.\n\nvoid 	setReadOnly(boolean value)\nUpdates the value of the read-only attribute.\n\nvoid 	setSystem(boolean value)\nUpdates the value of the system attribute.','Input/Output',1,NULL),(69,'read a DosFileAttributes then declare if it is hidden and readonly \nthen set them so without using a DosFileAttributeView...','DosFileAttributes dos = Files.readAttributes(path, DosFileAttributes.class);\n\nsout( dos.isHidden() );\nsout( dos.isReadOnly() );\n\nFiles.setAttribute(path, \"dos:hidden\", true);\nFiles.setAttribute(path, \"dos:readonly\", true);\n\n','Input/Output',1,NULL),(70,'You dont always need a XXXFileAttributeView object in order to change\na files attributes, you can just as easily do so with \"Files\" ...\n	','\n    setAttribute\n\n    public static Path setAttribute(Path path,\n                    String attribute,\n                    Object value,\n                    LinkOption... options)\n                             throws IOException\n\n    Sets the value of a file attribute.\n\n    The attribute parameter identifies the attribute to be set and takes the form:\n\n        [view-name:]attribute-name \n\n    where square brackets [...] delineate an optional component and the character \':\' stands for itself.\n\n    view-name is the name of a FileAttributeView that identifies a set of file attributes. If not specified then it defaults to \"basic\", the name of the file attribute view that identifies the basic set of file attributes common to many file systems. attribute-name is the name of the attribute within the set.\n\n    The options array may be used to indicate how symbolic links are handled for the case that the file is a symbolic link. By default, symbolic links are followed and the file attribute of the final target of the link is set. If the option NOFOLLOW_LINKS is present then symbolic links are not followed.\n\n    Usage Example: Suppose we want to set the DOS \"hidden\" attribute:\n\n        Path path = ...\n        Files.setAttribute(path, \"dos:hidden\", true);\n     \n\n    Parameters:\n        path - the path to the file\n        attribute - the attribute to set\n        value - the attribute value\n        options - options indicating how symbolic links are handled\n    Returns:\n        the path parameter\n    Throws:\n        UnsupportedOperationException - if the attribute view is not available\n        IllegalArgumentException - if the attribute name is not specified, or is not recognized, or the attribute value is of the correct type but has an inappropriate value\n        ClassCastException - if the attribute value is not of the expected type or is a collection containing elements that are not of the expected type\n        IOException - if an I/O error occurs\n        SecurityException - In the case of the default provider, and a security manager is installed, its checkWrite method denies write access to the file. If this method is invoked to set security sensitive attributes then the security manager may be invoked to check for additional permissions.\n\n','Input/Output',1,NULL),(71,'You dont need PosixFileAttributeView to set a file permissions either...','Files.setPosixFilePermissions\n\npublic static Path setPosixFilePermissions(Path path,\n                           Set<PosixFilePermission> perms)\n                                    throws IOException\n\nSets a file\'s POSIX permissions.\n\nThe path parameter is associated with a FileSystem that supports the PosixFileAttributeView. This attribute view provides access to file attributes commonly associated \nwith files on file systems used by operating systems that implement the Portable \nOperating System Interface (POSIX) family of standards.\n\nParameters:\n    path - A file reference that locates the file\n    perms - The new set of permissions\nThrows:\n    UnsupportedOperationException - if the associated file system does not support the PosixFileAttributeView\n    ClassCastException - if the sets contains elements that are not of type PosixFilePermission\n    IOException - if an I/O error occurs\n    SecurityException - In the case of the default provider, and a security manager is installed, it denies RuntimePermission(\"accessUserInformation\") or its checkWrite method denies write access to the file.','Input/Output',1,NULL),(72,'How to set a linux files permisions from a string ?\n	','PosixFileAttributes pos = Files.readAttributes(path, PosixFileAttributes.class);\nSet<PosixFilePermissions> perms = PosixFilePermissions.fromString(\"rw-r--r--:);\n\nFiles.setPosixFilePermissions(path,perms);\n\nsout(pos.group());\nsout(pos.permissions());','Input/Output',1,NULL),(73,'What interface is used to recursively loop through a directory ?	','DirectoryStream<T> \n\nT is the element returned by the iterator. \n\nTHis allows for the convieninet use of a for - each loop to go through a dir.\n\nThe elements returned by the iterator are in no specific order.\n\n List<Path> listSourceFiles(Path dir) throws IOException {\n       List<Path> result = new ArrayList<>();\n       try (DirectoryStream<Path> stream = Files.newDirectoryStream(dir, \"*.{c,h,cpp,hpp,java}\")) {\n           for (Path entry: stream) {\n               result.add(entry);\n           }\n       } catch (DirectoryIteratorException ex) {\n           // I/O error encounted during the iteration, the cause is an IOException\n           throw ex.getCause();\n       }\n       return result;\n   }\n ','Input/Output',1,NULL),(74,'how do you create a new DirectoryStream<T>','\n    Files.newDirectoryStream\n\n    public static DirectoryStream<Path> newDirectoryStream(Path dir)\n                                                    throws IOException\n\n    Opens a directory, returning a DirectoryStream to iterate over all entries in the directory. The elements returned by the directory stream\'s iterator are of type Path, each one representing an entry in the directory. The Path objects are obtained as if by resolving the name of the directory entry against dir.\n\n    When not using the try-with-resources construct, then directory stream\'s close method should be invoked after iteration is completed so as to free any resources held for the open directory.\n\n    When an implementation supports operations on entries in the directory that execute in a race-free manner then the returned directory stream is a SecureDirectoryStream.\n\n    Parameters:\n        dir - the path to the directory\n    Returns:\n        a new and open DirectoryStream object\n    Throws:\n        NotDirectoryException - if the file could not otherwise be opened because it is not a directory (optional specific exception)\n        IOException - if an I/O error occurs\n        SecurityException - In the case of the default provider, and a security manager is installed, the checkRead method is invoked to check read access to the directory.\n\n','Input/Output',1,NULL),(75,'What type of object are returned by directorystreams iterator ? ','Path\n\nThe directory Stream interface is generic, but thats misleading since the \nonly way create a new DirectoryStream is by using File.newDirectoryStream\nwhich returns a Path.','Input/Output',1,NULL),(76,'How would you filter the object returned by a directory Stream ?	','use \nFiles.newDirectoryStream(Path dir, String glob);\n\nthis lets you add a glob in that will compare the string representations \nof their file names agains the given glob.\n\nthis lets you filter your results...\n\n Path dir = ...\n     try (DirectoryStream<Path> stream = Files.newDirectoryStream(dir, \"*.java\")) {\n         :\n     }','Input/Output',1,NULL),(77,'What will be returned by this code...\n\n	Path dir = Paths.get(\"/home/maxbisesi/Documents\");\n        \n	try(DirectoryStream<Path> ds = Files.newDirectoryStream(dir,\"[vx]*\")){\n            sout( );\n        } ','Nothing will not compile, must catch IOException for DirectoryStream','Input/Output',1,NULL),(78,'How many directories at a time can DirectoryStream look at ?','only 1','Input/Output',1,NULL),(79,'Think, DirectorySteam acts like ls in bash.','or ...\nDirectoryStream streams one directory','Input/Output',1,NULL),(80,'What \"Files\" method do you use along with FileVisitor?','public static Path walkFileTree(Path start,\n                FileVisitor<? super Path> visitor)\n                         throws IOException\n\nWalks a file tree.\n\nThis method works as if invoking it were equivalent to evaluating the expression:\n\n     walkFileTree(start, EnumSet.noneOf(FileVisitOption.class), Integer.MAX_VALUE, visitor)\n     \n\nIn other words, it does not follow symbolic links, and visits all levels of the file tree.\n\nParameters:\n    start - the starting file\n    visitor - the file visitor to invoke for each file\nReturns:\n    the starting file\nThrows:\n    SecurityException - If the security manager denies access to the starting file. In the case of the default provider, the checkRead method is invoked to check read access to the directory.\n    IOException - if an I/O error is thrown by a visitor method','Input/Output',1,NULL),(81,'FileVisitor methods return what ?','FileVisitResult','Input/Output',1,NULL),(82,'Enum FileVisitResult elements','CONTINUE\nSKIP_SIBLINGS = continue without visiting the siblings of this file or directory\n\nSKIP_SUBTREE = continue without visiting the entries in this directory\n\nTERMINATE','Input/Output',1,NULL),(83,'SimpleFileVisitor has a protected constructor so It can only be extended','SimpleFileVisitor sf = new SimpleFileVisitor() will not compile','Input/Output',1,NULL),(84,'try(DirectoryStream stream = Files.newDirectoryStream(dir)){\n	sout(\"throw excpetion\");\n	//do stuff\n}\n\nWhats wrong here ?','DirectoryStream throws an IOException. Therefore anytime you use \nDirectoryStream you must catch an IOException\n\ntry(DirectoryStream stream = Files.newDirectoryStream(dir)){\n	sout(\"throw excpetion\");\n	//do stuff\n} catch(IOException e) { \n	log(e);\n}','Input/Output',1,NULL),(85,'try(DirectoryStream stream = Files.newDirectoryStream(dir)){\n\n	for(Path file : stream){\n		sout(file.getFileName());\n	}\n} catch(IOException e ){\n\n}\n\nWhats wrong here ??','If DirectroyStream is not typed it will give Object elements. Therefore\nto use an untyped DirectoryStream you would have to use...\n	\n	for(Object file : stream) {\n	\n	}\n\n... but thats usually not what you want so always do this>>>\n\n	try(DirectoryStream<Path> Stream = Files.newDirectoryStream(dir)){\n\n	} catch(IOExcetpion e) {\n\n	}','Input/Output',1,NULL),(86,'\npublic class CopyCharacters {\n    public static void main(String[] args) throws IOException {\n\n        FileReader inputStream = null;\n        FileWriter outputStream = null;\n\n        try {\n            inputStream = new FileReader(\"xanadu.txt\");\n            outputStream = new FileWriter(\"characteroutput.txt\");\n\n            int c;\n            while ((c = inputStream.read()) != -1) {\n                outputStream.write(c);\n            }\n        } finally {\n            if (inputStream != null) {\n                inputStream.close();\n            }\n            if (outputStream != null) {\n                outputStream.close();\n            }\n        }\n    }\n}\n','All character stream classes are descended from Reader and Writer. \nAs with byte streams, there are character stream classes that specialize in file I/O: FileReader and FileWriter. \nThe CopyCharacters example illustrates these classes.\n\nclose() throws IOException here too','Input/Output',1,NULL),(87,'What has to be done with pretty much ALL IO classes ?','wrap them in Try Block, they all throw IOExceptions ','Input/Output',1,NULL),(88,'What method does BufferedReader have that makes it valuable	','public String readLine()\n                throws IOException\n\nReads a line of text. A line is considered to be terminated by any one of a line feed (\'\\n\'), a carriage return (\'\\r\'), or a carriage return followed immediately by a linefeed.\n\nReturns:\n    A String containing the contents of the line, not including any line-termination characters, or null if the end of the stream has been reached\nThrows:\n    IOException - If an I/O error occurs\n\n\nOther IO classes have read methods that only read in a single character\nBufferedReader has this too. But this method really helps!','Input/Output',1,NULL),(89,'Which IO class swallows exceptions and does not throw them but \nsaid exceptions can be checked using checkerror()','PrintWriter','Input/Output',1,NULL),(90,'Path file = Paths.get(\"/home/dick/bigorsmall.txt\");\nBufferedWriter bw = new BufferedWriter(new FileWriter(file));\n\nbw.write(\"this ones pretty big \");','wont compile you cant construct a FileWriter from a Path not to mention there is an unreported IOException','Input/Output',1,NULL),(91,'Files method:\n\nPath copy(Path src, Path targ, CopyOption...options)','Copy the file from the source to target and return the target.\n\nthrows FileAlreadyExistsException if target fiile already exists, and no\nREPLACE_EXSISTING copy Option is specified. ','Input/Output',1,NULL),(92,'Files method:\n\nPath move(Path src, Path target, CopyOption options)','Moves the file from src to target return target. \n\nthrows:\n\n FileAlreadyExistsException - if the target file exists but cannot be replaced because the REPLACE_EXISTING option is not specified (optional specific exception)\n   \n DirectoryNotEmptyException - the REPLACE_EXISTING option is specified but the file cannot be replaced because it is a non-empty directory (optional specific exception)','Input/Output',1,NULL),(93,'Path p1 = Paths.get(\"/home/One.txt\");\nPath p2 = Paths.get(\"One.txt\");\nPathMatcher matcher = FileSystems.getDefault().getPathMatcher(\"glob:*.txt\");\n\nsout( matcher.matches(p1) );\nsout( matcher.matches(p2) );','false \ntrue\n\nin glob * means match any character excpet a directory boundary\n\n** mathces any character across directory boundaries. \n\nnotice that PathMatcher(\"syntax:pattern\") can take a glob or a regex but you\nmust specify\n\nedit:\nwas previously:\nDefault().getPathMatcher(\"glob: *.txt\");\n\nthere cant be a space after the : or that will mathch...\n\n	Path path = Paths.get(\"one.txt\");\n        PathMatcher matcher = FileSystems.getDefault().getPathMatcher(\"glob: *.txt\");\n        System.out.println(matcher.matches(path));\n\nwould give false unless the space was removed. | Path p1 = Paths.get(\"/home/One.txt\");\nPath p2 = Paths.get(\"One.txt\");\nPathMatcher matcher = FileSystems.getDefault().getPathMatcher(\"glob: *.txt\");\n\nsout( matcher.matches(p1) );\nsout( matcher.matches(p2) );','Input/Output',1,NULL),(94,'in Glob what does * mean ? what about ** ?','* matches any character inside a directory boundary\n** matches any character inside a directory boundary\n\n','Input/Output',1,NULL),(95,'GLOB\n\nwhat does \"?\" mean ?','? matches any single character. ','Input/Output',1,NULL),(96,'public class Hello {\n    public static void main(String[] args) {\n        PathMatcher matcher = FileSystems.getDefault().getPathMatcher(\"glob:**{.pic,.txt}\");\n        Path p1 = Paths.get(\"home/files.txt\");\n        Path p2 = Paths.get(\"documents/pictures/smile.pic\");\n        Path p3 = Paths.get(\"home/dir\");\n        \n        System.out.println(matcher.matches(p1));\n        System.out.println(matcher.matches(p2));\n        System.out.println(matcher.matches(p3));\n    }\n\n}','true\ntrue\nfalse','Input/Output',1,NULL),(97,'public void matches(Path path, String glob){\n	PathMatcher matcher = FileSystems.getDefault().getPathMatcher(glob);\n	sout( matcher.matches(path) );\n}\n\nPath p1 = Paths.get(\"Bert-book\");\nPath p2 = Paths.get(\"Kathy-horse\");\nmatches(p1, \"glob:{Bert*,Kathy*}\");\nmatches(p2, \"glob: {Bert, Kathy}*\");\nmatches(p1, \"glob:{Bert,Kathy}\");','true\ntrue\nfalse','Input/Output',1,NULL),(98,'FileVisitor\n\npublic FileVisitResult visitFileFailed(path file, BasicFileAttributes attrs) {\n\n	// do something\n	return FileVisitResult.CONTINUE;\n	\n}\n','wrong, visitFileFailed takes an IOExcpeption as a parameter\nas well as postVisitDirectory','Input/Output',1,NULL),(99,'FileVisitor: \n\npublic FileVisitResult preVisitDirectory(path file, BasicFileAttributes attrs) {\n\n	// do something\n	return FileVisitResult.CONTINUE;\n	\n}','right, ','Input/Output',1,NULL),(100,'FileVisitor:\n\npublic FileVisitResult visitFileFailed(path file, IOException e) {\n\n	// do something\n	return FileVisitResult.CONTINUE;\n	\n}','right','Input/Output',1,NULL),(101,'FileVisitor:\n\npublic FileVisitResult postVisitDirectory(path file, IOException e) {\n\n	// do something\n	return FileVisitResult.CONTINUE;\n	\n}','right','Input/Output',1,NULL),(102,'Date today = new Date();\n\nDateFormat df = DateFormat.getInstance();\n\nString todayFile = df.format(today);\n\nsout(todayFile);	// this gives 9/8/01 7:46 PM\n\ntodayFile.replaceAll(\" \",\"-\");\n\nsout( todayFile );\n\nwhat prints now ?','9/8/01 7:46 PM \n\nremember that strings are imutable, so even though you called \nreplaceAll on that string you didn\'t assing it to a new sString therefore it\nwas lost.\n\nshould be:\n	String newDate = todayFile.replaceAll(\" \",\"-\");','Strings',1,NULL),(103,'Path p1 = Paths.get(todayFile+\".txt\");\nSystem.out.println(p1);\n        \nBufferedWriter bw = new BufferedWriter(new FileWriter(p1));','wont compile, FileWriter doesn\'t have a Path constructor,\n\nchange p1 to p1.toFile();\n\nFileWriter(File file)\nConstructs a FileWriter object given a File object.\n\nFileWriter(File file, boolean append)\nConstructs a FileWriter object given a File object.\n\nFileWriter(FileDescriptor fd)\nConstructs a FileWriter object associated with a file descriptor.\n\nFileWriter(String fileName)\nConstructs a FileWriter object given a file name.\n\nFileWriter(String fileName, boolean append)\nConstructs a FileWriter object given a file name with a boolean indicating whether or not to append the data written.','Input/Output',1,NULL),(104,'class Eggs {\n	int doX(Long x, Long y){ return 1; }\n	int doX(long...){ return 2; }\n	int doX(Integer x, Integery){ return 3; }\n	int doX(Number n, Number m){ return 4; }\n	public static void main(SA){\n		new Eggs().go();\n	}\n	void go(){\n		short s = 7;\n		sout(doX(s,s) + \" \");\n		sout(doX(7,7));\n	}\n}','4 3 \n\ntwo rules apply to the first doX, you cannot widen and then box in\none step, and var-args are always chosen last. So you cannot widen shorts\nto ints or longs then box them to Integer or Long but you can box short\nto Short then widen that to Number, that takes priority over var args.\n\nthe second doX simmply boxs int to Integer.\n\n\n\n    Assignment contexts allow the use of one of the following:\n\n        an identity conversion (§5.1.1)\n\n        a widening primitive conversion (§5.1.2)\n\n        a widening reference conversion (§5.1.5)\n\n        a boxing conversion (§5.1.7) optionally followed by a widening reference conversion\n\n        an unboxing conversion (§5.1.8) optionally followed by a widening primitive conversion.\n\n\n','General',1,NULL),(105,'What is the first and second argument to Files.walkFileTree()','the first is the directory to start walking at in the form of a Path\n\nthe second is an object of the class that extends SimpleFileVisitor<Path>','Input/Output',1,NULL),(106,'Which Two FileVisitor methods take IOExceptions as parameters	?','visitFileFailed and postVisitDirectory','Input/Output',1,NULL),(107,'Which two FileVisitor methods take BasicFileAttributes as parameters ?','preVisitDirectory and visitFile','Input/Output',1,NULL),(108,'/home\n	- a.txt\n	- emptyChild	\n	- child\n		- b.txt\n		- grandchild\n			- c.txt\n\npublic class PrintDirs extends SimpleFileVisitor<Path> {\n	public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) {\n		sout( \"pre\" + dir);\n		String name = dir.getFileName().toString();\n		\n		if (name.equals(\"child\"))\n			return FileVisitResult.SKIP_SUBTREE;\n		return FileVisitResult.CONTINUE;\n\n	}\n}\n			\n			\n		\n	','now the output is:\n	pre: /home\n	file: /home/a.txt\n	pre: /home/child\n	pre: /home/emptyChild\n	post: /home/emptyChild\n	post: /home\n\npostVisitDirectory is never called if the subtree of the directory is skipped','Input/Output',1,NULL),(109,'postVisitDirectory is never called if the subtree of the directory is skipped','','Input/Output',1,NULL),(111,'public void matches(Path path, String glob){\n	PathMatcher matcher = FileSystems.getDefault().getPathMatcher(glob);\n	sout( matcher.matches(path) );\n}\n\nPath p1 = Paths.get(\"0*b/test/1\");\nPath p2 = Paths.get(\"9\\\\*b/test/1\");\nPath p3 = Paths.get(\"01b/test/1\");\nPath p4 = Paths.get(\"0*b/1\");\n\nString glob = \"[0-9]\\\\*{A*,b}/**/1\");\n\nmatches(p1,glob);\nmatches(p2,glob);\nmatches(p3,glob);\nmatches(p4,glob);\n','true \nfalse\nfalse\nfalse\n\n{A*,b} means A followed by anything or the single character b\n\n/**/ means one or more directories with any name\n\n\\\\* the actuall asterix character \\ escapes the * the second \\ espaces the first \\ ','Input/Output',1,NULL),(112,'What exception if any do FileVisitor methods throw ?','IOException','Input/Output',1,NULL),(113,'glob vs regex: \n\nZero or more of any character, including directory bounndary','glob: **\n\nregex: .*','Input/Output',1,NULL),(114,'regex:\n\n.*','zero or or more of any character including directory boundary','Input/Output',1,NULL),(115,'glob vs regex:\n\nZero or more of any character, not a directory boundary','glob: *\n\nregex: no syntax required','Input/Output',1,NULL),(116,'Glob vs regex:\n\nexcactly one character','glob: ?\n\nregex: .','Input/Output',1,NULL),(117,'glob vs regex:\n\nBegins with cat or dog','glob:\n	{cat, dog}*\n\nregex:\n\n	(cat|dog).*','Input/Output',1,NULL),(118,'(cat|dog).*\n\nglob or regex ?','regex','Input/Output',1,NULL),(119,'You are creating a PathMatcher\n\nPathMatcher matcher = ________._________().__________();','FileSystems.getDefault().getPathMatcher();','Input/Output',1,NULL),(120,'You are creating a WatchService:\n\nWatchService watcher = _____________.__________()._________()','FileSystems.getDefault().newWatchService();','Input/Output',1,NULL),(121,'What do you get from a WatchService to indicate a deletion creation or modification','WatchKey\ntry {\n	WatchKey key;\n	try {\n	key = watcher.take();\n              } catch(interuptedException x) {\n		return;\n	}\n	for(WatchEvent<?> event : key.pollEvents()){\n	//do stuff\n	}','Input/Output',1,NULL),(122,'What are two ways to get a WatchKey ? \nand whats the difference between them ? ','take() will wait and block forever until an event takes place. Will throw\nInteruptedException if interuped without taking an event. \n\npoll() returns null if an event is not imediately available. ','Input/Output',1,NULL),(123,'public class Frodo etends Hobbit {\n	public static void main(SA) { \n		int mygold = 7;\n		sout(countGold(mygold,6));\n	}\n}\nclass Hobbit {\n	int countGold(int x, int y) { return x + y; }\n}','does not compile countGold() cannot be called from a static context','Input/Output',1,NULL),(124,'The contract between equals() and hashCode() is:','1) If two objects are equal, then they must have the same hash code.\n2) If two objects have the same hash code, they may or may not be equal. \n3) If two objects are not equal, they must NOT have the same hashcode\n','OOP',1,NULL),(125,' public static void main(String[] args){\n       Path dir = Paths.get(\"/home/maxbisesi\");\n       try(DirectoryStream<Path> stream = Files.newDirectoryStream(dir,\"*\");){\n            for(Path path : stream){\n               System.out.println(path);\n            }\n        } catch(IOException e){\n            System.out.println(\"SQLException\");\n            System.out.println(e);\n        }\n   }','shows all files and directories in /home/maxbisesi\n\nsqlexception if the path is not a valid path','Input/Output',1,NULL),(126,'public class Hello {\n    synchronized void a() { actBusy(); }\n    static synchronized void b() { actBusy(); }\n    static void actBusy() {\n        try {\n            Thread.sleep(1000);\n            \n        } catch( InterruptedException e){}\n            \n        \n    }\n    public static void main(String[] args) {\n        final Hello x = new Hello();\n        final Hello y = new Hello();\n        \n        Runnable runnable = new Runnable() {\n            public void run() {\n                int option = (int) (Math.random() * 4);\n                switch(option) {\n                    case 0: x.a(); break;\n                    case 1: x.b(); break;\n                    case 2: y.a(); break;\n                    case 3: y.b(); break;\n                }\n            }\n        };\n        \n        Thread t1 = new Thread(runnable);\n        Thread t2 = new Thread(runnable);\n        \n        t1.start();\n        t2.start();\n    \n    }\n\n}  \n\nwhich methods could never be running at the same time ?','x.a() thread1 x.a() in thread2\nx.b() thread1 x.b() in thread2\nx.b() thread1 y.b() in thread2\n\nthe same instance method of the same instance is blocked while a static\nmethod accross all methods is blocked. ','Threads',1,NULL),(127,'Method forwarding relies on Has-a relationships','got it ','OOP',1,NULL),(128,'class Animal implements Burriable {\n    private Integer size;\n    private String name;\n    \n    public Animal(int x, String y){\n        size = x;\n        name = y;\n    }\n    public Animal(){\n        size = 0;\n        name = \"\";\n    }\n\n    public int getSize() {\n        return size;\n    }\n\n    public String getName() {\n        return name;\n    }\n    \n    public void bury(){\n        System.out.println(\"just toss him in there...\");\n    }\n    public void digUp(){\n        System.out.println(\"Hang on this ones still kickin !\");\n    }\n    public void pray(){\n        System.out.println(\"...Lord forgive us for what we have done, hes only been gone for \"+YEARSDEAD+\" years.\");\n    }\n}\n\nclass Dog implements Burriable{\n    private Animal animal;\n    public Dog(Animal a){\n        animal = a;\n    }\n    \n    public void bury(){\n        animal.bury();\n    }\n    public void digUp(){\n        animal.digUp();\n    }\n    public void pray(){\n        animal.pray();\n    }\n    \n    public String yelpForHelp(){\n        return \"ar ar arrr....\";\n    }\n}\n\ninterface Burriable {\n    int YEARSDEAD = 1;\n    void bury();\n    void digUp();\n    void pray();\n}\n\nwhat OOP principle is this ?','method forwarding\n\nan object composition principle that calles methods on an instance variable of an object','OOP',1,NULL),(129,'public class F {\n	private static final F f = new F();\n	public static F c(){\n		return f;\n	}\n\n	public void update(F a) { }\n	\n	public void delete(F a) { }\n\n}\nwhat design pattern is this ? ','The singleton pattern is identifiable bby the static variable for the single instance and the accessor returning it. ','OOP',1,NULL),(130,'public class E {\n	private D d;\n	public void m() {\n		d.m();\n	}\n\n		public static E getInstance() {\n			return new E();\n		}\n}\n\nclass D {\n	public void m() { }\n}\n\nwhat design pattern principle is this ?\n','object composition, you can tell because of the method forwarding. \nSingleton is tempting but the getInstance method here returns a NEW instance\ninstead a single private static one like it should to be singleton. ','OOP',1,NULL),(131,'class A {}\n\nabstract class G {\n	A m() { return n(); }\n	abstract A n();\n}\n\nwhat principle is demostrated','Factory,\n\nClass A is the object we are creating using the factory method. class G\nis the abstract superclass for the factory. Not shown is a class implementing \nclass G that actually creates the object. ','OOP',1,NULL),(132,'which is a benefit of the DAO pattern ?	','Reuse The DAO pattern centralize logic for the data access code making reuse\neasier and allowing you to switch out implementations. ','OOP',1,NULL),(133,'public void print(Path d) throws IOException {\n	try(DirectoryStream<Path> stream = Files.newDirectoryStream(d)){\n		for(Path path: stream){\n			sout( path.getFileName() );\n		}\n	}\n}\n\nwhat files will this display ? ','regular files, hidden files, and subdirectories','Input/Output',1,NULL),(134,'public class Hello {\n    public static void main(String[] dicks) throws IOException{\n      Path src = Paths.get(\"/home/maxbisesi/Documents/copy.txt\");\n      Files.createFile(src);\n      \n      Files.copy(src, Paths.get(\"/home/maxbisesi/Documents/newcopy.txt\"));\n      \n    }\n\n}\n\nwhat happens if this is ran twice and all preivous files dont exist before','The first time the file will be created and copied normally the second time you\nwill get a file already exists excpeiotn','Input/Output',1,NULL),(135,'public class Hello {\n    public static void main(String[] dicks){\n        ArrayList list = new ArrayList();\n        \n        list.add(\"java\");\n        list.add(\"sucks\");\n        \n        String item = list.get(0);\n\n    }\n\n}','Compilation fails, to compile would have to be \n\n	Object item = list.get(0);','Collections',1,NULL),(136,'if(true)\n       int b = 1;\n        ','Will not compile, there is no scope there \n\nif(true){\n	int b = 1;\n} \n	this would though !','General',1,NULL),(137,'public class Hello {\n    public static void main(String[] dicks){\n        Pattern p = Pattern.compile(\"C.*L\");\n        Matcher m = p.matcher(\"CooLooLCuuLooC\");\n        \n        while(m.find())\n            System.out.println(m.group());\n\n    }\n\n}','CooLooLCuuL\n\n* is the greedy quantifier, it takes as much as it can. ','Strings',1,NULL),(138,'If a thread\'s priority is not specified explicitly then it gets\nNORM_PRIORITY\n\nT or F ','False it gets the same priority as the thread that created it ','Threads',1,NULL),(139,'public class Hello {\n    public static void main(String[] dicks){\n        Animal ah2 = new Horse();\n        ah2.eat(\"carrots\");\n    }\n\n}\n\nclass Animal{\n    public void eat(){ }\n}\n\nclass Horse extends Animal {\n    public void eat() { }\n    public void eat(String s ){ } \n}\n    ','Will not compile, method eat in class animal cannot be applied to given types','General',1,NULL),(140,'public class Hello {\n    public static void main(String[] dicks){\n        Animal ah2 = new Horse();\n        ah2.eat();\n    }\n\n}\n\nclass Animal{\n    public void eat(){ System.out.println(\"Animal\"); }\n}\n\nclass Horse extends Animal {\n    public void eat(){ System.out.println(\"Horse\");} \n}\n\n','Horse','General',1,NULL),(141,'public class Hello {\n    public static void main(String[] dicks){\n        Animal ah2 = new Horse();\n        ah2.eat();\n    }\n\n}\n\nclass Animal{\n    public void eat(){ System.out.println(\"Animal\"); }\n}\n\nclass Horse extends Animal {\n    public void eat() throws IOException{ System.out.println(\"Horse\");} \n}','will not compile overriden method \ncannot throw new or broader checked exceptions','General',1,NULL),(142,'public class Hello {\n    public static void main(String[] dicks){\n        Animal ah2 = new Horse();\n        ah2.eat();\n    }\n\n}\n\nclass Animal{\n    public void eat(){ System.out.println(\"Animal\"); }\n}\n\nclass Horse extends Animal {\n    public void eat(int x) throws IOException{ System.out.println(\"Horse\");} \n}','Animal\n\neat in horse is an overload, it still inherits Animals eat()','General',1,NULL),(143,'//assume valid Connection cn, and good database connection\n\nString query = \"Select * from Answer\";\ntry(Statement stmt = cn.createStatement()){\n	ResultSet rs1 = stmt.executeQuery(query);\n	stmt.executeQuery(\"select * from Question\");\n	while(rs1.next(){\n		sout(rs1.getInt(\"fk_question_num\");\n	}\n} catch(SQLException e){\n	\n}','SQLException\n	Statement objects do not support multiple open ResultSets.\n	\n	Only a single ResultSet can be opened from the same statement object\n\n	*if the same statement object is executed more than once the previous\n	ResultSet is closed automatically\n		\n		... and attempting to access a closed RS is a SQLException','JDBC',1,NULL),(144,'','','blank',1,NULL),(145,'try(Connection conn = DriverManager.getConnection(url,user,pw)){\n	String pQuery = \"Select unitPrice From Book Where Title Like ?\";\n\n	PreparedStatement pstmt = conn.prepareStatement(pQuery);\n\n	ResultSet rs = pstmt.executeQuery();\n} catch(SQLException sq) {\n}\n','SQLException , attempting to execute a query without setting a parameter\nresults in an SQLException\n\n	should be>>>\n		\n		pstmt.setString(1,\"dick\");\n\nIndexing starts at 1','JDBC',1,NULL),(146,'public class Hello {\n    public static void main(String[] dicks){\n        try{\n            couldthrow();\n        } catch(IOException | SQLException e){\n            \n        }\n        \n    }\n    \n    public static void couldthrow() throws IOException, SQLException{\n        \n    }\n\n}','compiles and runs just fine ','Exceptions',1,NULL),(147,'public boolean equals(Object o) { \n	if(((Moof)o).getMoofValue() == this.moofValue {\n		return true;\n	} else {\n		return false;\n	}\n}\n\nwhats missing here','instanceof test','Collections',1,NULL),(148,'equals() hashCode() and toString() are all PUBLIC','got it','Collections',1,NULL),(149,'equals() Contract\n\nreflexive	','for any reference value x, x.equals(x) should be true. ','Collections',1,NULL),(150,'equals() contract,\n\nsymmetric','for any reference values x and y, \n\nx.equals(y) shoud be true if and only if \ny.equals(x) returns true. ','Collections',1,NULL),(151,'what are the four tenants of the equals contract ?','reflxive, x.equals(x) is always true\n\nsymetric, x.equals(y) and y.equals(x)\n\ntransitive, if x.equals(y) and y.equals(z) then x.equals(z)\n\nconsistent, x.equals(y) is true no matter how many times you call it\n\nif x is non null, x.equals(null) is always false','Collections',1,NULL),(152,'if two objects are considered equal, their hashcodes...','MUST also be equal.','Collections',1,NULL),(153,'Is it still legal to have a hashcode that always returns the same number ?','Yes just inefficient, all objects will go in the same bucket. The Collection\nwill search through a single big bucket using equal() to find the instance\nits looking for. In that case you defeat the purpose of using a hashed collection. ','Collections',1,NULL),(154,'HashCode contract:\n\n1\n\n2\n\n\n3','When it is invoked on the same object more than once during an execution\nof a java application the hashcode() method must consistently return the \nsame integer \n\nIf two objects are equal according to the equals method, then calling hashchode)( \non each of the objects must produce the same integer\n\nunequal objects can still produce the same hashcodes \n\n*That means that equals and hashCode must work with same attributes somehow','Collections',1,NULL),(155,'x.equals(y) == true\n\nmeans what for hashcode()...','x.hashcode() == y.hashcode()','Collections',1,NULL),(156,'x.hashCode() != y.hashCode()	\n\nmeans what for equals()','x.equals(y) == false\n\nequals() and hashcode are like directions to get to a specific \nelement\n\nhashCode places all the elements in seperate but similiar buckets \nequals() gets the correct ones out.\n\nso if two elemets have different hashCodes they will be in different buckets\nanyway so hashCode is one level of precision and equals() is the next.','Collections',1,NULL),(157,'public static void main(String[] args){\n        Path p = Paths.get(\"/home/maxbisesi/Public/GenDir/genFile.txt\");\n        Path p2 = Paths.get(\"/home/maxbisesi/Public\");\n        \n        System.out.println(p.relativize(p2));\n        System.out.println(p2.relativize(p));  \n}','../..\nGenDir/genFile.txt\n','Input/Output',1,NULL),(158,'Collections:\n\n	Vector\n','a Vector is the same as an ArrayList but Vector methods are synchronized\nfor thread safety. \n\nVector and Hashtable are the two original collections\n\nunless you really need thread safety choose ArrayList over Vector, \nthe synchronized methods give an unecssary performance hit. \n\n','Collections',1,NULL),(159,'Collections:\n\n	LinkedList','is ordered by index position except that the elements are doubly linked to \none another. This linkage gives you new methods for adding and removing\nfrom the beginning or end.\n\nEasy choice for implementing a stack or queue. \n\nmay iterate more slowly than ArrayList but still a good choice when you need\nfast insertion and deletion.\n\nLinkedList supports peek(), poll(), offer(), Queue methods!!','Collections',1,NULL),(160,'Which Interface disallows duplicates','Set','Collections',1,NULL),(161,'Collections:\n	\n	HashSet','unsorted and unordered. Uses the hashcode of the object being inserted\n\nso the more effeicinet your hashcode the more effecient access youll get\n\nUse for a collection with no duplicates where you dont care about the\norder when you iterate through it.','Collections',1,NULL),(162,'Collections:\n\n	LinkedHashSet','\nMaintains a doubly linked list across elelemnts so the insertion order \nis maintained\n\nduplicates are still disallowed. ','Collections',1,NULL),(163,'Collections:\n\n	TreeSet','Sorted\n\nguarentees elements will be in ascending order according to natural order\n\n','Collections',1,NULL),(164,'public class Reader {\n	public void read(Path p, Charset s) {\n		try(BufferedReader r = Files.newBufferedReader(p,s)) {\n			try { r.read(); }\n			catch(IOException f) {\n				r.readLine();\n			}\n		} catch(IOException || NullPointerException e) {\n			r.close();\n		} finally {\n			r.close();\n		}\n	}\n}','compilation fails at the last three lines,\n\n1. multi catch syntax is | not ||\n\n2. objects declared in a try block are only available within the \ntry block so closing r is out of scope','Input/Output',1,NULL),(165,'Collections:\n\n	HashMap','unsorted and unordered Map. \n\nUse When you need a map and you don\'t care\nabout the order when you iterate through. \n\nThe basic map, other maps add a little more overhead. \n\nWhere keys land in the map is based on hashCode() \n\nHashMap allows one null key and multiple null values ','blank',1,NULL),(166,'Collections:\n	\n	Hashtable\n	','Hashtable is the synchronized counterpart to HashMap. \n\nWhile HashMap lets you have a null key and null values\n\nHashtable doesn\'t allow anything thats null!','Collections',1,NULL),(167,'HashMap allows multiple null values','True!\n\nHashtable doesn\'t allow anything null it will throw a npe','Collections',1,NULL),(168,'HashMap allows multiple null keys','FALSE\n\nThat would defeat the purpose of a \"key\"','Collections',1,NULL),(169,'HashMap is sorted','FALSE\n\nunordered and unsorted','Collections',1,NULL),(170,'HashMap is synchronized','FALSE','Collections',1,NULL),(171,'Hashtable is synchronized ','True!','Collections',1,NULL),(172,'Hashtable allows multiple null values and one null key','FALSE, nothing can be null in Hashtable','blank',1,NULL),(173,'public static ArrayList<Animal> staggerSort(ArrayList<? extends Animal> list){\n        Map<String,List<Number>> byCategory = seperateToCategories(list);\n        return null;\n    }\n    \n    static Map<String,List<Number>> seperateToCategories(ArrayList<Animal> list){\n        return null;\n    }','since list is declared as anything that extends Animal you cant be sure that it\nwill be the right type to pass into the next method that taks <Animal>\n\nWill not compile','Generics',1,NULL),(174,'public static void main(String[] args){\n        LinkedHashMap<String,String> lhm = new LinkedHashMap<>();\n        lhm.put(\"big\",\"Country\");\n        lhm.put(\"sweet\",\"Cheeks\");\n        lhm.put(\"big\",\"Bucks\");\n        \n        for(Map.Entry<String,String> entry: lhm.entrySet()){\n            System.out.println(entry.getKey()+\" \"+entry.getValue());\n        }\n        \n    }','big Bucks\nsweet Cheeks\n\nbig Bucks replaced big Country in the map, LinkedHashMaps maintain insertion\norder. \n\nso that mapping was simply replaced but it kept its position','Collections',1,NULL),(175,'class Gutsy {\n	public static void main(String[] args){\n		new Gutsy().go();\n	}\n	void go() throws IOException {\n	String row;\n	try {\n		FileReader fr = new FileReader(\"TestFile.txt\");\n		BufferedReader br = new BufferedReader(fr);\n		while((row = br.readLine() ) != null)\n			sout( row );\n	} catch(IOException e) {\n		sout(\"got io error\");\n	} finally {\n		sout( \"done\" );\n	}\n   }\n}','WNC,\n\ngo() declares that it throws a checked exceptions so it has to be handled\nor thrown in main.\n\nif that would have compiled an IOException would be thrown so it would\nprint got io error done. ','Exceptions',1,NULL),(176,'Given a properly prepared string[] with five elements what is the range \nof possible results that could be returned by Arrays.binarySearch() ? ','-6 through 4','Collections',1,NULL),(177,'TreeMap','sorted Map\n\nsorted by natural order or custom comparison rules.','blank',1,NULL),(178,'List<String> test = new ArrrayList<String>();\nString s = \"hi\";\ntest.add(\"string\");\ntest.add(s);\ntest.add(s+s);\nsout( test.size() );\nsout( test.contains(42) );\nsout( test.contains(\"hihi\") );\ntest.remove(\"hi\");\nsout( test.size() );','3\nfalse\ntrue\n2','Collections',1,NULL),(179,'List myInts = new ArrayList();\n        myInts.add(4);\n        \n        myInts.add(new Integer(4));','These two are the same, the first demonstrates autoboxing. ','blank',1,NULL),(180,'class Boxing2 {\n	static Integer x;\n	psvm(sa) {\n		doStuff(x);\n	}\n\n	static void doStuff(int z) {\n		int z2 = 5;\n		sout( z2 + z );\n	}\n}','NullPointerException','General',1,NULL),(181,'public static void main(String[] dicks){\n        ArrayList<String> list = new ArrayList<>();\n        \n        list.add(\"CZ\");\n        list.add(\"a\");\n        list.add(\"AB\");\n        list.add(\"CE\");\n        list.add(\"CZ\");\n        list.add(\"cz\");\n        list.add(\"BA\");\n        list.add(\"BF\");\n        list.add(\"ABC\");\n        list.add(\"CE\");\n        list.add(\" CE\");\n        list.add(\"A\");\n        list.add(\"ce\");\n        list.add(\"A B\");\n        list.add(\"AA\");\n        list.add(\" Z\");\n        \n        System.out.println(\"unsorted: \"+list);\n        Collections.sort(list);\n        System.out.println(\"sorted: \"+list);','unsorted: [CZ, a, AB, CE, CZ, cz, BA, BF, ABC, CE,  CE, A, ce, A B, AA,  Z]\nsorted: [ CE,  Z, A, A B, AA, AB, ABC, BA, BF, CE, CE, CZ, CZ, a, ce, cz]\n\nspaces come first, as shown by A B and AA. Also capitals come before lowercase','Collections',1,NULL),(182,'public class Hello {\n    public static void main(String[] dicks){\n        List<Horse> stable = new ArrayList<>();\n        \n        for(int x =0; x < 10; x++){\n            stable.add(new Horse());\n        }\n        \n        Collections.sort(stable);\n        \n    }\n\n}\n\nclass Horse {\n    public boolean equals(Horse s){\n        return false;\n    }\n}','Will not compile, Horse does not implement Comparable','Collections',1,NULL),(183,'class Horse implements Comparable<Horse> {\n    public boolean equals(Horse s){\n        return false;\n    }\n    \n    int compareTo(Horse h){\n        \n    }\n    \n    \n}','will not compile, compareTo is public ','Collections',1,NULL),(184,'public class Hello {\n    public static void main(String[] dicks){\n        List<Horse> stable = new ArrayList<>();\n        \n        for(int x =0; x < 10; x++){\n            stable.add(new Horse(\"lucky\"+x));\n        }\n        \n        Collections.sort(stable);\n        \n    }\n\n}\n\nclass Horse implements Comparable<Horse> {\n    String name;\n    \n    public Horse(String x){\n        name = x;\n    }\n    \n    public String getName(){\n        return name;\n    }\n    \n    public boolean equals(Horse s){\n        return false;\n    }\n    \n    public int compareTo(Horse h){\n        return name.compareTo(h.getName());\n        \n    }\n    \n    \n}','compiles fine!','Collections',1,NULL),(185,'When you override equals() you must take an argument of what type ?','Object','Collections',1,NULL),(186,'When you override compareTo() you must take an argument of type?','The type your sorting.\n\n\npublic interface Comparable<T>\n\n...type T','Collections',1,NULL),(187,'class DVDInfo implements Comparable {\n	public int comparteTo(Object o) {\n		DVDInfo d = (DVDInfo) o;\n		return title.compareTo(d.getTitle() );\n	}\n}','This is still legal but painful, genereics make this easier but it will still \ncompile','Collections',1,NULL),(188,'Comparator has _________________\n\nComparable has _________________','compare()\n\ncompareTo()','Collections',1,NULL),(189,'Which soritng interface do you implement to create individual sorting classes\n	','Comparator','Collections',1,NULL),(190,'class Dicksorter implements Comparator<Dicks> {\n	public int compareTo(Dick one) {\n	}\n}','will not compile the method is:\n\n	int compare(T o1, T o2)','Collections',1,NULL),(191,'class DickSorter implements Comparator<Dick> {\n	public int compare(Dick one, Dick two){\n		return one.getSize().compareTo(two.getSize());\n	}\n}','compiles fine, this takes advvantage of integer comparison','Collections',1,NULL),(192,'public class Hello {\n    public static void main(String[] dicks){\n        List<Horse> stable = new ArrayList<>();\n        \n        stable.add(new Horse(\"Honey\"));\n        stable.add(new Horse(\"Mighty Mikey\"));\n        stable.add( new Horse(\"The Fastest Stud in the Mud\"));\n        stable.add( new Horse(\"Churchill\"));\n        \n        Horse[] ranch = stable.toArray();\n\n    }\n\n}','Will not compile\n\ntoArray() in List interface returns an Object[]','Collections',1,NULL),(193,'public class Hello {\n    public static void main(String[] dicks){\n        Horse[] stable = {new Horse(\"Johny\"), new Horse(\"wilfred\"), new Horse(\"Marco\"), new Horse(\"MAx\"), new Horse(\"Billy\") };\n        \n        int x = Arrays.binarySearch(stable,\"Johny\");\n        System.out.println(x);  \n\n    }\n\n}','ClassCastException, \"johny\" cant be turned into a horse\n\nshould be Arrays.binarySearch(stable,new Horse(\"Johny\"));','Collections',1,NULL),(194,'public class Hello {\n    public static void main(String[] dicks){\n        Horse[] stable = {new Horse(\"Johny\"), new Horse(\"wilfred\"), new Horse(\"Marco\"), new Horse(\"MAx\"), new Horse(\"Billy\") };\n        \n        int x = Arrays.binarySearch(stable,new Horse(\"Johny\"));\n        System.out.println(x);  \n\n    }\n\n}    \n\nclass Horse implements Comparable<Horse> {\n    String name;\n    \n    public Horse(String x){\n        name = x;\n    }\n    \n    public String getName(){\n        return name;\n    }\n    \n    public boolean equals(Horse s){\n        return false;\n    }\n    \n    public int compareTo(Horse h){\n        return name.compareTo(h.getName());\n        \n    }\n    \n    \n    ','The results are undefined, the array is not sorted. ','Collections',1,NULL),(195,'public class Hello {\n    public static void main(String[] dicks){\n        Horse[] stable = {new Horse(\"Johny\"), new Horse(\"wilfred\"), new Horse(\"Marco\"), new Horse(\"MAx\"), new Horse(\"Billy\") };\n        \n        \n        int x = Arrays.binarySearch(stable,new Horse(\"Marco\"));\n        System.out.println(x);  \n\n    }\n\n}\n\nclass Horse {\n    String name;\n    \n    public Horse(String x){\n        name = x;\n    }\n    \n    public String getName(){\n        return name;\n    }\n    \n    public boolean equals(Horse s){\n        return false;\n    }\n    \n}','ClassCastException Horse cannot be converted to Comparable\n\nbinarySearch uses comparable to search the Array.\n\nThis search would give inconsistant results anyways because \nthe array was not sorted first. \n\nto fix add this:\n\nclass Horse implements Comparable<Horse> {\n    String name;\n    \n    public Horse(String x){\n        name = x;\n    }\n    \n    public String getName(){\n        return name;\n    }\n    \n    public boolean equals(Horse s){\n        return false;\n    }\n    \n    public int compareTo(Horse s){\n        return name.compareTo(s.getName());\n    }\n    \n}\n\n-if an array is sorted in natrual order it must searched in natural order \n-if it is sorted using a comparator it must be searched using the same comparator.\n','Collections',1,NULL),(196,'public class Hello {\n    public static void main(String[] dicks){\n        Horse[] stable = {new Horse(\"Johny\"), new Horse(\"wilfred\"), new Horse(\"Marco\"), new Horse(\"MAx\"), new Horse(\"Billy\") };\n        int x = Arrays.binarySearch(stable,new Horse(\"Marco\"));\n        System.out.println(x);  \n    }\n}\n\nclass Horse implements Comparable{\n    String name;\n    public Horse(String x){\n        name = x;\n    }\n    public String getName(){\n        return name;\n    }\n    public boolean equals(Horse s){\n        return false;\n    }\n    public int compareTo(Horse h){\n        return name.compareTo(h.getName());  \n    }\n}\n','Will not compile, if the untyped version of Comparable is used then\nthe parameter to compareTo would be Object\n\neither change to Comparable<Horse>\n\nor \n\ncomparTo(Object o) and cast.\n\notherwise, the answer would be 2 remember arrays aren\'t sorted even though\nyour using comparable the elements of an array dont get sorted so the positions are \nwhat index they were defined as !\n\nThis would give undefined results','Collections',1,NULL),(197,'What method is used to search through Arrays and Collections','binarySearch()\n\nreturns the int index of the element being searched.\n\nUnsuccesful searches return an int index that represents the\n insertion point. \n\nThe collection or array must be sorted before you can search it.\n\nif you attempt to search an unsorted array or collection the results of the\nsearch will be unpredictable.\n\nIf it was sorted in natural order it must searched in natural order.\n	do this by NOT sending a Comparator as an argument to the binarySearch() \n\nIf it was sorted with a comparator it must be searched using the same comparator\n\n	\n	','Collections',1,NULL),(198,'class Horse implements Comparable{\n    String name;\n    \n    public Horse(String x){\n        name = x;\n    }\n    \n    public String getName(){\n        return name;\n    }\n    \n    public boolean equals(Horse s){\n        return false;\n    }\n    \n    public int compareTo(Object h){\n        return name.compareTo(h.getName());\n  \n    }','will not compile, need to cast\n\nreturn name.compareTo(((Horse)h).getName());\n\ndoes not compile because h is an Object and Objects dont have a method\ncalled getName. \n\nyou would cast h to a horse. \n\nObject is the right argument type here though because Comparable is a raw type\nif it were Comparable<Horse> the argument would need to be Horse.','Collections',1,NULL),(199,'public class Hello {\n    public static void main(String[] dicks){\n       Animal[] beavers = new Beaver[5];\n       \n       Animal[] animals = {new Beaver(), new Beaver(), new Beaver() };\n       \n       Animal[] ans2 = new Animal[5];\n       ans2[0] = new Beaver();\n\n    }\n}\n\nclass Animal{\n    public Animal(){\n        \n    }\n    \n    public String getName(){\n        return \"d\";\n    }\n}\n\nclass Beaver extends Animal{\n    \n}','these all compile fine, \n\nPolymorphism works with Arrays. ','Collections',1,NULL),(200,'public class Hello {\n    public static void main(String[] dicks){\n       \n        String[] strings = {\"One\",\"Dice\",\"Angela\",\"Bisesi\",\"Franko\"};\n        \n        Arrays.sort(strings);\n        int x = Arrays.binarySearch(strings,\"Dice\");\n        System.out.println(x);  \n        \n        Arrays.sort(strings);\n        \n        System.out.println(Arrays.binarySearch(strings,\"Angela\"));\n    }\n\n}','2\n0','Collections',1,NULL),(201,'class sortBySecondLetter implements Comparator<String> {\n    int compare(String one, String two){\n        \n    }\n}','compare must be public, will not compile','Collections',1,NULL),(202,'class sortBySecondLetter implements Comparator<String> {\n    public int compare(String one, String two){\n        char charone = one.charAt(1);\n        char chartwo = two.charAt(1);\n        \n        return charone.compareTo(chartwo);\n    }\n}','will not compile, char is a primitive so charone cannot be dereferenced here\nchange to Character.','Collections',1,NULL),(203,'public class Hello {\n    public static void main(String[] dicks){\n        sortBySecondLetter sbsl = new sortBySecondLetter();\n        String[] strings = {\"One\",\"Dice\",\"Angela\",\"Bisesi\",\"Franko\"};\n        \n        Arrays.sort(strings,sbsl);\n        \n        System.out.println(strings);\n    }\n\n}','[Ljava.lang.String;@15db9742\n\narrays are not classes','Collections',1,NULL),(204,'String[] sa = {\"one\", \"two\", \"three\", \"four\" };\nList sList = Arrays.asList(sa);\n\nSout( \"size \" + sList.size() );\nsout( \"idx2 \" + sList.get(2) );\n\nsList.set(3,\"six\" );\nsa[1] = \"five\";\n\nfor(String s : sa ){\n	sout( s + \" \");\n}\nsout(\"\\n s1[1] \" + sList.get(1) );','size 4\nidx2 three\none \nfive \nthree \nsix \ns1[1] five','Collections',1,NULL),(205,'public class Hello {\n    public static void main(String[] args){\n        String[] sa = {\"one\", \"two\", \"three\", \"four\" };\n        List sList = Arrays.asList(sa);\n\n        System.out.println( \"size \" + sList.size() );\n        System.out.println( \"idx2 \" + sList.get(2) );\n\n        sList.set(3,\"six\" );\n        sa[1] = \"five\";\n\n        for(String s : sa ){\n            System.out.println( s + \" \");\n        }\n        System.out.println(\"s1[1] \" + sList.get(1) );\n        \n        sList.remove(\"five\");\n        for(String s : sa)\n            System.out.println(s+\" \");\n    }\n\n}','UnsupportedOperationException\n\nThis UnsupportedOperationException comes when you try to perform some operation on collection where its not \nallowed and in your case, When you call Arrays.asList it \ndoes not return a java.util.ArrayList. It returns a java.util.Arrays$ArrayList which is an immutable list. \nYou cannot add to it and you cannot remove from it.\n\nReturns a {@code List} of the objects in the specified array. The size of the {@code List} cannot be modified, i.e. adding and removing are unsupported, but the elements can be set. Setting an element modifies the underlying array.\n\nEDIT\n\nThe type of the resulting list is Arrays.ArrayList, which is a private class inside Arrays.class. Practically speaking,\nit is nothing but a List-view on the array that you\'ve passed with Arrays.asList. With a consequence: if you change the array, the list is changed too. And because an array is not resizeable, \nremove and add operation must be unsupported.\n','Collections',1,NULL),(206,'String[] sa = {\"one\", \"two\", \"three\", \"four\" };\n        List sList = Arrays.asList(sa);\n\n        System.out.println( \"size \" + sList.size() );\n        System.out.println( \"idx2 \" + sList.get(2) );\n\n        sList.set(3,\"six\" );\n        sa[1] = \"five\";\n\n        for(String s : sa ){\n            System.out.println( s + \" \");\n        }\n        System.out.println(\"s1[1] \" + sList.get(1) );\n        \n        sList.set(1, \"FIVE\");\n	sList.set(3,\"SIX);\n        for(String s : sa)\n            System.out.println(s+\" \");','size 4\nidx2 three\none \nfive \nthree \nsix \ns1[1] five\none \nFIVE \nthree \nSIX\n\nThis shows that Arrays and Lists coming from\nArrays.asList() are \"joined at the hip\" changes in one affect \nthe other. This is different from a \"Backed Collection\". Because \nBacked Collections dont go both ways and are only backed for a certain range.','Collections',1,NULL),(207,'public static void main(String[] dicks){\n        String[] sa = {\"one\", \"two\", \"three\", \"four\" };\n        List sList = Arrays.asList(sa);\n\n        System.out.println( \"size \" + sList.size() );\n        System.out.println( \"idx2 \" + sList.get(2) );\n\n        sList.set(3,\"six\" );\n        sa[1] = \"five\";\n\n        for(String s : sa ){\n            System.out.println( s + \" \");\n        }\n        System.out.println(\"s1[1] \" + sList.get(1) );\n        \n        sList.set(1, \"FIVE\");\n        sList.set(3,\"SIX\");\n        sList.add(\"SEVEN\");\n        for(String s : sa)\n            System.out.println(s+\" \");','unsupported operation exception, \n\nList returned by asList is fixed size can only be updated not added to or removed from','Collections',1,NULL),(208,' public static void main(String[] dicks){\n        List<Integer> iL = new ArrayList<Integer>();\n        for(int x=0; x<3; x++){\n                iL.add(x);\n        }\n        Object[] oa = iL.toArray();\n        Integer[] ia2 = new Integer[3];\n        ia2 = iL.toArray(oa);\n    }','will not compile, toArray( T[] a) will return an array of the type you send\nto it. so here an Object[] cannot be assigned to an Integer[].\n\nto fix:\n	change oa to ia2 which will cause toArray to return an Integer[]','Collections',1,NULL),(209,'public static void main(String[] dicks){\n        List<Integer> iL = new ArrayList<Integer>();\n        for(int x=0; x<5; x++){\n                iL.add(x);\n        }\n        Object[] oa = iL.toArray();\n        Integer[] ia2 = new Integer[3];\n        ia2 = iL.toArray(ia2);\n        \n        for(Integer i : ia2){\n            System.out.println(i);\n        }     \n    }','0\n1\n2\n3\n4\n','Collections',1,NULL),(210,'public static void main(String[] dicks){\n        List<Integer> iL = new ArrayList<Integer>();\n        for(int x=0; x<5; x++){\n                iL.add(x);\n        }\n        Object[] oa = iL.toArray();\n        Integer[] ia2 = new Integer[3];\n        ia2 = iL.toArray(ia2);\n        \n        for(Integer i : ia2){\n            System.out.println(i);\n        }\n        \n        iL.add(100);\n        \n        for(Integer i : ia2)\n            System.out.println(i);\n       \n    }','0\n1\n2\n3\n4\n0\n1\n2\n3\n4','Collections',1,NULL),(211,' public static void main(String[] dicks){\n        List<Integer> iL = new ArrayList<Integer>();\n        for(int x=0; x<5; x++){\n                iL.add(x);\n        }\n        Integer[] oa = iL.toArray();     \n    }','will not compile, \n\n.toArray() returns an Object[]','Collections',1,NULL),(212,'class HDTV implements Comparable<HDTV> {\n	private int size;\n	private String brand;\n        private int resolution;\n \n	public HDTV(int size, String brand, int res) {\n		this.size = size;\n		this.brand = brand;\n                this.resolution = res;\n	}\n \n	public int getSize() {\n		return size;\n	}\n        \n        public int getRes() {\n            return resolution;\n        }\n \n	public void setSize(int size) {\n		this.size = size;\n	}\n \n	public String getBrand() {\n		return brand;\n	}\n \n	public void setBrand(String brand) {\n		this.brand = brand;\n	}\n \n	@Override\n	public int compareTo(HDTV tv) {\n \n		if (this.getSize() > tv.getSize())\n			return 1;\n		else if (this.getSize() < tv.getSize())\n			return -1;\n		else\n			return 0;\n	}\n        \n        public String toString(){\n            return brand;\n        }\n}\n\npublic class Hello {\n    public static void main(String[] dicks){\n        compareTVs();\n    }\n    \n     \n    public static void compareTVs() {\n		HDTV tv1 = new HDTV(55, \"Samsung\", 6000);\n		HDTV tv2 = new HDTV(60, \"Sony\", 4500);\n                HDTV tv3 = new HDTV(70, \"MEGATV\", 10000);\n                HDTV tv4 = new HDTV(15,\"kitchenette\", 600);\n\n                HDTV[] array = {tv2, tv1, tv3, tv4 };\n                \n                System.out.println(Arrays.binarySearch(array,new HDTV(700,\"Samsung\",400)));\n                \n	}\n\n}','unpredictable result, the array is not sorted before being searched. ','Collections',1,NULL),(213,'public static void main(String[] dicks){\n        List<HDTV> tvs = new ArrayList<>();\n        HDTV tv1 = new HDTV(55, \"Samsung\", 6000);\n        HDTV tv2 = new HDTV(60, \"Sony\", 4500);\n        HDTV tv3 = new HDTV(70, \"MEGATV\", 10000);\n        HDTV tv4 = new HDTV(15,\"kitchenette\", 600);\n        tvs.addAll(tv1,tv2,tv3,tv4);\n    }','will not compile \n\nArrayList.addAll doesn\'t work like that, it takes another collection\nthen adds all the elements from one to another. ','Collections',1,NULL),(214,'public static void main(String[] dicks){\n        List<HDTV> tvs = new ArrayList<>();\n        \n        HDTV tv1 = new HDTV(55, \"Samsung\", 6000);\n        HDTV tv2 = new HDTV(60, \"Sony\", 4500);\n        HDTV tv3 = new HDTV(70, \"MEGATV\", 10000);\n        HDTV tv4 = new HDTV(15,\"kitchenette\", 600);\n        \n        tvs.add(tv1);\n        tvs.add(tv2);\n        tvs.add(tv3);\n        tvs.add(tv4);\n        \n        Iterator<HDTV> i3 = tvs.iterator();\n        \n        while(i3.hasNext()){\n            HDTV t3 = i3.next();\n            System.out.println(t3.getBrand());\n        }\n        \n        \n    }','Samsung\nSony\nMEGATV\nkitchenette\n\nthis shows proper use of an iterator','Collections',1,NULL),(215,'public static void main(String[] dicks){\n        List<HDTV> tvs = new ArrayList<>();\n        \n        HDTV tv1 = new HDTV(55, \"Samsung\", 6000);\n        HDTV tv2 = new HDTV(60, \"Sony\", 4500);\n        HDTV tv3 = new HDTV(70, \"MEGATV\", 10000);\n        HDTV tv4 = new HDTV(15,\"kitchenette\", 600);\n        \n        tvs.add(tv1);\n        tvs.add(tv2);\n        tvs.add(tv3);\n        tvs.add(tv4);\n        \n        Iterator i3 = tvs.iterator();\n        \n        while(i3.hasNext()){\n            HDTV t3 = i3.next();\n            System.out.println(t3.getBrand());\n        }\n        \n        \n    }','If the iterator isn\'t typed then the elements returned by Iterator will be \nObjects so to make this compile, \n\nyou would have to cast\n\n	(HDTV) i3.next();','Collections',1,NULL),(216,'  public static void main(String[] dicks){\n        List<HDTV> tvs = new ArrayList<>();\n        \n        HDTV tv1 = new HDTV(55, \"Samsung\", 6000);\n        HDTV tv2 = new HDTV(60, \"Sony\", 4500);\n        HDTV tv3 = new HDTV(70, \"MEGATV\", 10000);\n        HDTV tv4 = new HDTV(15,\"kitchenette\", 600);\n        \n        tvs.add(tv1);\n        tvs.add(tv2);\n        tvs.add(tv3);\n        tvs.add(tv4);\n        \n        HDTV[] tv = new HDTV[5];\n        HDTV[] hv = tvs.toArray(tv); //line 1\n        Object[] tvobjs = tvs.toArray(); //line 2\n        \n   \n    }\n\nwhich line would fail if any ?','none fail both of those are fine. ','Collections',1,NULL),(217,'public static void main(String[] dicks){\n      Set s = new HashSet();\n      \n        System.out.println(s.add(4));\n        System.out.println(s.add(9));\n        System.out.println(s.add(5));\n        System.out.println(s.add(\"7\"));\n        System.out.println(s.add(4));\n        \n        for(Object o : s)\n            System.out.println(o);\n\n    }','true\ntrue\ntrue\ntrue\nfalse\n4\n5\n7\n9\n\nSets dont allow duplicates and the iteration order is not predictable','Collections',1,NULL),(218,'public static void main(String[] dicks){\n      Set s = new TreeSet();\n      \n        System.out.println(s.add(4));\n        System.out.println(s.add(9));\n        System.out.println(s.add(5));\n        System.out.println(s.add(\"7\"));\n        System.out.println(s.add(4));\n        \n        for(Object o : s)\n            System.out.println(o);\n\n    }','ClassCastException\n \nTreeSets are sorted and all these elements aren\'t mutually comparabble','Collections',1,NULL),(219,'class Dog {\n    public String name;\n    public Dog(String n) { name = n; }\n    \n    public String toString(){\n        return name;\n    }\n}\n\npublic class Hello {\n\n    public static void main(String[] dicks){\n      Map<Object,Object> map = new HashMap<>();\n      \n      map.put(\"d1\",new Dog(\"Charly\"));\n      map.put(\"d2\", new Dog(\"dumbfuck\"));\n      \n        System.out.println(map.get(\"d1\"));\n    }\n}','Charly,\n\nhere strings are used as keys and they override hashcode() and equals()\nso it can be used ','Collections',1,NULL),(220,'class Dog {\n    public String name;\n    public Dog(String n) { name = n; }\n    \n    public String toString(){\n        return name;\n    }\n\n    public static void main(String[] dicks){\n      Map<Object,Object> map = new HashMap<>();\n      \n      map.put(new Dog(\"Bell\"),\"Big brown lab\");\n      map.put(new Dog(\"Sable\"), \"small schiperkee\");\n      \n        System.out.println(map.get(new Dog(\"Bell\")));\n    }\n\n}\n\n','null \n\nthe map cannot find the values bcause the keys dont have equals or hashcode methods.','Collections',1,NULL),(221,'class Dog {\n    enum Pets{DOG, CAT, SNAKE};\n    public String name;\n    public Dog(String n) { name = n; }\n    \n    public String toString(){\n        return name;\n    }\n\npublic static void main(String[] dicks){\n      \n      Map<Object,Object> map = new HashMap<>();\n      \n      map.put(new Dog(\"Bell\"),\"Big brown lab\");\n      map.put(new Dog(\"Sable\"), \"small schiperkee\");\n      map.put(Pets.CAT, new Dog(\"catdog\"));\n      map.put(\"Dog\", Pets.DOG);\n      \n        System.out.println(map.get(new Dog(\"Bell\")));\n        System.out.println(map.get(Pets.CAT));\n        System.out.println(map.get(\"Dog\"));\n    }\n}','null\ncatdog\nDOG','Collections',1,NULL),(222,'public int hashCode() { return name.length(); }\npublic int hashCode() { return 4; }\n \nwhich will be faster ?\n','both are legal, the first will be slightly better\n\nthe more unique a hashcode the faste retrieval will be. ','Collections',1,NULL),(223,'TreeSet<Integer> tree = new TreeSet<Integer>();\ntree.add(12);\ntree.add(63);\ntree.add(34);\ntree.add(45);\n \nIterator<Integer> iterator = tree.iterator();\nSystem.out.print(\"Tree set data: \");\nwhile (iterator.hasNext()) {\n    System.out.print(iterator.next() + \" \");\n}','12\n34\n45\n63','Collections',1,NULL),(224,'public class Hello {\n    \n    \n    public static void main(String[] dicks){\n      \n      List<Double> grades = new ArrayList<>();\n      grades.addAll(Arrays.asList( new Double[]{ 1.8, 4.6, 2.3, 8.9, 2.2 } ));\n      \n      Collections.sort(grades,new CusSort());\n      \n      System.out.println(grades);\n      \n        System.out.println(Collections.binarySearch(grades,4.2,new CusSort()));\n\n    }\n}\n    \n   class CusSort implements Comparator<Double> {\n       public int compare(Double d1, Double d2){\n           return d1.intValue() == d2.intValue() ? d2.compareTo(d1) : d1.compareTo(d2);\n           \n       }\n   }','[1.8, 2.3, 2.2, 4.6, 8.9]\n-5\n\nthis comparator sorts in ascending order uless they have the same integer\nvalue','Collections',1,NULL),(225,'public class Hello {\n    \n    \n    public static void main(String[] dicks){\n      \n     TreeMap<String, String> map = new TreeMap<>();\n     map.put(\"a\",\"ant\"); map.put(\"b\",\"buffalo\"); map.put(\"h\",\"horse\");\n     \n     SortedMap<String, String> submap;\n     submap = map.subMap(\"b\",\"g\");\n     \n        System.out.println(map+\" \"+submap);\n        \n        map.put(\"b\",\"bat\");\n        \n        submap.put(\"f\",\"fish\");\n        \n        map.put(\"R\", \"raccoon\");\n        // submap.put(\"p\",\"pig\");\n        \n        System.out.println(map+\" \"+submap);\n    }\n}','{a=ant, b=buffalo, h=horse} {b=buffalo}\n{R=raccoon, a=ant, b=bat, f=fish, h=horse} {b=bat, f=fish}','Collections',1,NULL),(226,'public class Hello {\n    \n    \n    public static void main(String[] dicks){\n      \n     TreeMap<String, String> map = new TreeMap<>();\n     map.put(\"a\",\"ant\"); map.put(\"b\",\"buffalo\"); map.put(\"h\",\"horse\");\n     \n     SortedMap<String, String> submap;\n     submap = map.subMap(\"b\",\"g\");\n     \n        System.out.println(map+\" \"+submap);\n        \n        map.put(\"b\",\"bat\");\n        \n        submap.put(\"f\",\"fish\");\n        \n        map.put(\"R\", \"raccoon\");\n        submap.put(\"p\",\"pig\");\n        \n        System.out.println(map+\" \"+submap);\n    }\n}','IllegalArgumnetException\n\np is out of range of the submap as first established with subMap(b g);\n\n','Collections',1,NULL),(227,'public class Hello {\n    \n    \n    public static void main(String[] dicks){\n      \n     TreeMap<String, String> map = new TreeMap<>();\n     map.put(\"a\",\"ant\"); map.put(\"b\",\"buffalo\"); map.put(\"h\",\"horse\"); map.put(\"j\",\"jackle\");\n     \n     TreeMap<String, String> submap;\n     submap = map.subMap(\"b\",\"g\");\n     \n     System.out.println(map+\" \"+submap);\n\n    }\n}','will not compile, submap returns a SortedMap.','Collections',1,NULL),(228,'class TreeMap<k,v> extends  _____________\n implements  ____________','AbstractMap<k,V>\nNavigableMap<K,V>','Collections',1,NULL),(229,'public class Hello {\n    \n    \n    public static void main(String[] dicks){\n      \n     TreeMap<Animal, Integer> map = new TreeMap<>();\n     \n     map.put(new Animal(5,\"Ant\"), 6); map.put(new Animal(3,\"Beee\"),9); map.put(new Animal(25,\"Dog\"),7); map.put(new Animal(20,\"muskrat\"),20);\n     \n     System.out.println(map);\n     \n \n\n    }\n}\n\nclass sortAnimalsAlphabetically implements Comparator<Animal> {\n\n    @Override\n    public int compare(Animal o1, Animal o2) {\n        return o1.getName().compareTo(o2.getName());\n    }\n    \n}\n\nclass Animal implements Comparable<Animal> {\n    private Integer size;\n    private String name;\n    \n    public Animal(int x, String y){\n        size = x;\n        name = y;\n    }\n\n    public int getSize() {\n        return size;\n    }\n\n    public String getName() {\n        return name;\n    }\n    public int compareTo(Animal o){\n        return size.compareTo(o.getSize());\n        \n    }\n    \n    public String toString(){\n        return name;\n    }\n}','{Beee=9, Ant=6, muskrat=20, Dog=7}\n\nwithout a provided comparator TreeMap sorts using Animals comparable\n\nwhich is to rank by size','Collections',1,NULL),(230,'public class Hello {\n    \n    \n    public static void main(String[] dicks){\n      \n     TreeMap<Animal, Integer> map = new TreeMap<>(new sortAnimalsAlphabetically());\n     \n     map.put(new Animal(5,\"Ant\"), 6); map.put(new Animal(3,\"Beee\"),9); map.put(new Animal(25,\"Dog\"),7); map.put(new Animal(20,\"muskrat\"),20);\n     \n     System.out.println(map);\n     \n \n\n    }\n}\n\nclass sortAnimalsAlphabetically implements Comparator<Animal> {\n\n    @Override\n    public int compare(Animal o1, Animal o2) {\n        return o1.getName().compareTo(o2.getName());\n    }\n    \n}\n\nclass Animal implements Comparable<Animal> {\n    private Integer size;\n    private String name;\n    \n    public Animal(int x, String y){\n        size = x;\n        name = y;\n    }\n\n    public int getSize() {\n        return size;\n    }\n\n    public String getName() {\n        return name;\n    }\n    public int compareTo(Animal o){\n        return size.compareTo(o.getSize());\n        \n    }\n    \n    public String toString(){\n        return name;\n    }\n}','{Ant=6, Beee=9, Dog=7, muskrat=20}\n\nsort using comparator','Collections',1,NULL),(231,'public class Hello {\n    \n    \n    public static void main(String[] dicks){\n      \n     TreeMap<Animal, Integer> map = new TreeMap<>();\n     \n     map.put(new Animal(2,\"Ant\"), 6); map.put(new Animal(3,\"Beee\"),9); map.put(new Animal(15,\"Dog\"),7); map.put(new Animal(12,\"muskrat\"),20);\n     \n     SortedMap<Animal,Integer> copymap = map.subMap(map.firstKey(), map.lastKey());\n     \n     copymap.put(new Animal(50,\"Rhino\"), 1);\n     map.put(new Animal(30,\"Wolf\"), 4);\n     System.out.println(map);\n     \n     SortedMap<Animal,Integer> copy1map = copymap.subMap(new Animal(4,\"Worm\"), new Animal(25,\"Dolphin\"));\n     \n     System.out.println(copy1map);\n\n    }\n}\n\nclass sortAnimalsAlphabetically implements Comparator<Animal> {\n\n    @Override\n    public int compare(Animal o1, Animal o2) {\n        return o1.getName().compareTo(o2.getName());\n    }\n    \n}\n\nclass Animal implements Comparable<Animal> {\n    private Integer size;\n    private String name;\n    \n    public Animal(int x, String y){\n        size = x;\n        name = y;\n    }\n\n    public int getSize() {\n        return size;\n    }\n\n    public String getName() {\n        return name;\n    }\n    public int compareTo(Animal o){\n        return size.compareTo(o.getSize());\n        \n    }\n    \n    public String toString(){\n        return name;\n    }\n}','IllegalArgumentException key out of range\n\nyour trying to add a rhino - 50 - to the copied map when the biggest element\nin the orgiinal was a Dog at 15 !','Collections',1,NULL),(232,'public class Hello {\n    \n    \n    public static void main(String[] dicks){\n      \n     TreeMap<Animal, Integer> map = new TreeMap<>();\n     \n     map.put(new Animal(2,\"Ant\"), 6); map.put(new Animal(3,\"Beee\"),9); map.put(new Animal(15,\"Dog\"),7); map.put(new Animal(12,\"muskrat\"),20);\n     \n     SortedMap<Animal,Integer> copymap = map.subMap(map.firstKey(), map.lastKey());\n     \n     map.put(new Animal(50,\"Rhino\"), 1);\n     map.put(new Animal(30,\"Wolf\"), 4);\n     System.out.println(map);\n     \n     SortedMap<Animal,Integer> copy1map = copymap.subMap(new Animal(1,\"Tic\"), new Animal(25,\"Dolphin\"));\n     \n     //System.out.println(copy1map);\n\n    }\n}\n\nclass sortAnimalsAlphabetically implements Comparator<Animal> {\n\n    @Override\n    public int compare(Animal o1, Animal o2) {\n        return o1.getName().compareTo(o2.getName());\n    }\n    \n}\n\nclass Animal implements Comparable<Animal> {\n    private Integer size;\n    private String name;\n    \n    public Animal(int x, String y){\n        size = x;\n        name = y;\n    }\n\n    public int getSize() {\n        return size;\n    }\n\n    public String getName() {\n        return name;\n    }\n    public int compareTo(Animal o){\n        return size.compareTo(o.getSize());\n        \n    }\n    \n    public String toString(){\n        return name;\n    }\n}\n','IllegalArgumentException, fromKey out of range\n\nthe tic your trying to add is too small previously the smallest elemtn was\nan Ant at 2','Collections',1,NULL),(233,'public class Hello {\n    \n    \n    public static void main(String[] dicks){\n      \n     TreeMap<Animal, Integer> map = new TreeMap<>();\n     \n     map.put(new Animal(2,\"Ant\"), 6); map.put(new Animal(3,\"Beee\"),9); map.put(new Animal(15,\"Dog\"),7); map.put(new Animal(12,\"muskrat\"),20);\n     \n     SortedMap<Animal,Integer> copymap = map.subMap(map.firstKey(), map.lastKey());\n        System.out.println(map);\n        System.out.println(copymap);\n     \n     map.put(new Animal(50,\"Rhino\"), 1);\n     map.put(new Animal(30,\"Wolf\"), 4);\n     System.out.println(map);\n     \n     copymap = map.subMap(map.firstKey(), map.lastKey());\n     \n        System.out.println(copymap);\n     \n     //SortedMap<Animal,Integer> copy1map = copymap.subMap(new Animal(7,\"Snake\"), new Animal(40,\"Bear\"));\n     //System.out.println(copy1map);\n\n    }\n}','{Ant=6, Beee=9, muskrat=20, Dog=7}\n{Ant=6, Beee=9, muskrat=20}\n{Ant=6, Beee=9, muskrat=20, Dog=7, Wolf=4, Rhino=1}\n{Ant=6, Beee=9, muskrat=20, Dog=7, Wolf=4}\n\npublic SortedMap<K,V> subMap(K fromKey,\n                    K toKey)\n\nkeys range from fromKey, inclusive, to toKey, exclusive. (If fromKey and toKey are equal, the returned map is empty.)\n The returned map is backed by this map, so changes \nin the returned map are reflected in this map, and vice-versa.\n\nTHE TO KEY IS EXCLUSIVE ','Collections',1,NULL),(234,'public class Hello {\n  public static void main(String[] dicks){\n      \n     TreeMap<Animal, Integer> map = new TreeMap<>();\n     \n     map.put(new Animal(2,\"Ant\"), 6); map.put(new Animal(3,\"Beee\"),9); map.put(new Animal(15,\"Dog\"),7); map.put(new Animal(12,\"muskrat\"),20);\n     \n     SortedMap<Animal,Integer> copymap = map.subMap(map.firstKey(),true, map.lastKey(),true);\n        System.out.println(map);\n        System.out.println(copymap);\n    }\n}\n\nclass Animal implements Comparable<Animal>{\n    private int size;\n    private String name;\n    public Animal(int s, String n){\n        size = s;\n        name = n;\n        \n    }\n    public int getSize(){\n        return size;\n    }\n    public int compareTo(Animal a){\n        int asize = a.getSize();\n        int bsize = this.size;\n        \n        if(asize < bsize)\n            return 1;\n        else if(asize == bsize)\n            return 0;\n        else\n            return -1;\n  \n    }\n    \n    public String toString(){\n        return name;\n    }\n}','{Ant=6, Beee=9, muskrat=20, Dog=7}\n{Ant=6, Beee=9, muskrat=20, Dog=7}\n\noverloaded version of submap indicates if that arg is inclusive \n\nThe map is sorted according to the natural ordering of its keys, or by a Comparator provided at map creation time\nNote that the ordering maintained by a tree map, like any sorted map, and whether or not an explicit comparator is provided, \nmust be consistent with equals if this sorted map is to correctly implement the Map interface. (See Comparable or Comparator for a precise definition of consistent with equals.) \nThis is so because the Map interface is defined in terms of the equals operation, but a sorted map performs all key comparisons using its compareTo (or compare) method, so two keys that are deemed equal by this method are, \nfrom the standpoint of the sorted map, equal.  ','Collections',1,NULL),(235,'public class Hello {\n    \n    \n    public static void main(String[] dicks){\n      \n     TreeMap<Animal, Integer> map = new TreeMap<>();\n     \n     map.put(new Animal(2,\"Ant\"), 6); map.put(new Animal(3,\"Beee\"),9); map.put(new Animal(15,\"Dog\"),7); map.put(new Animal(12,\"muskrat\"),20);\n     \n     SortedMap<Animal,Integer> copymap = map.subMap(map.firstKey(),false, map.lastKey(),true);\n        System.out.println(map);\n        System.out.println(copymap);\n    }\n}','{Ant=6, Beee=9, muskrat=20, Dog=7}\n{Beee=9, muskrat=20, Dog=7}','Collections',1,NULL),(236,'public class Hello {\n    \n    \n    public static void main(String[] dicks){\n      \n     TreeMap<Animal, Integer> map = new TreeMap<>();\n     \n     map.put(new Animal(2,\"Ant\"), 6); map.put(new Animal(3,\"Beee\"),9); map.put(new Animal(15,\"Dog\"),7); map.put(new Animal(12,\"muskrat\"),20);\n     \n     SortedMap<Animal,Integer> copymap = map.subMap(map.firstKey(),false, map.lastKey(),false);\n        System.out.println(map);\n        System.out.println(copymap);\n    }\n}','{Ant=6, Beee=9, muskrat=20, Dog=7}\n{Beee=9, muskrat=20}','Collections',1,NULL),(237,'public class Hello {\n    \n    \n    public static void main(String[] dicks){\n      \n     TreeMap<Animal, Integer> map = new TreeMap<>();\n     \n     map.put(new Animal(2,\"Ant\"), 6); map.put(new Animal(3,\"Beee\"),9); map.put(new Animal(15,\"Dog\"),7); map.put(new Animal(12,\"muskrat\"),20);\n     \n     SortedMap<Animal,Integer> copymap = map.subMap(map.firstKey(),true, map.lastKey(),true);\n     \n        System.out.println(map);\n        System.out.println(copymap);\n     map.put(new Animal(25,\"Wolf\"), 1);\n     //copymap.put(new Animal(22,\"Lynx\"), 0);\n     map.put(new Animal(33,\"Giant sloth\"), 6);\n     //copymap.put(new Animal(30,\"Comodo\"),5);\n     \n        System.out.println(map);\n        System.out.println(copymap);        \n    }\n}','{Ant=6, Beee=9, muskrat=20, Dog=7}\n{Ant=6, Beee=9, muskrat=20, Dog=7}\n{Ant=6, Beee=9, muskrat=20, Dog=7, Wolf=1, Giant sloth=6}\n{Ant=6, Beee=9, muskrat=20, Dog=7}\n\nIf new elements are added to the orginal map that are out of the range\nof the submap then they are not copied over to the sub.\n\nThat submap only exist within the range it was defined. ','Collections',1,NULL),(238,'public class Hello {\n    \n    \n    public static void main(String[] dicks){\n      \n     TreeMap<Animal, Integer> map = new TreeMap<>();\n     \n     map.put(new Animal(2,\"Ant\"), 6); map.put(new Animal(3,\"Beee\"),9); map.put(new Animal(15,\"Dog\"),7); map.put(new Animal(12,\"muskrat\"),20);\n     \n     SortedMap<Animal,Integer> copymap = map.subMap(map.firstKey(),true, map.lastKey(),true);\n     \n        System.out.println(map);\n        System.out.println(copymap);\n     map.put(new Animal(25,\"Wolf\"), 1);\n     copymap.put(new Animal(10,\"Fat Cat\"), 0);\n     map.put(new Animal(33,\"Giant sloth\"), 6);\n     \n        System.out.println(map);\n        System.out.println(copymap);\n    }\n}','{Ant=6, Beee=9, muskrat=20, Dog=7}\n{Ant=6, Beee=9, muskrat=20, Dog=7}\n{Ant=6, Beee=9, Fat Cat=0, muskrat=20, Dog=7, Wolf=1, Giant sloth=6}\n{Ant=6, Beee=9, Fat Cat=0, muskrat=20, Dog=7}','Collections',1,NULL),(239,'public class Hello {\n    \n    \n    public static void main(String[] dicks){\n      \n     TreeMap<Animal, Integer> map = new TreeMap<>();\n     \n     map.put(new Animal(2,\"Ant\"), 6); map.put(new Animal(3,\"Beee\"),9); map.put(new Animal(15,\"Dog\"),7); map.put(new Animal(12,\"muskrat\"),20);\n     map.put(new Animal(25,\"Wolf\"), 1); map.put(new Animal(33,\"Giant sloth\"), 6);\n     map.put(new Animal(35,\"Leapord\"),2); map.put(new Animal(9,\"chipmunk\"),4); map.put(new Animal(46,\"Cave Dweller\"),1);\n     \n        System.out.println(map);\n        \n     SortedMap<Animal,Integer> headmap = map.headMap(new Animal(35,\"Leapord\"));\n     \n        System.out.println(headmap);\n   \n    }\n}','{Ant=6, Beee=9, chipmunk=4, muskrat=20, Dog=7, Wolf=1, Giant sloth=6, Leapord=2, Cave Dweller=1}\n{Ant=6, Beee=9, chipmunk=4, muskrat=20, Dog=7, Wolf=1, Giant sloth=6}','Collections',1,NULL),(240,'public class Hello {\n    \n    \n    public static void main(String[] dicks){\n      \n     TreeMap<Animal, Integer> map = new TreeMap<>();\n     \n     map.put(new Animal(2,\"Ant\"), 6); map.put(new Animal(3,\"Beee\"),9); map.put(new Animal(15,\"Dog\"),7); map.put(new Animal(12,\"muskrat\"),20);\n     map.put(new Animal(25,\"Wolf\"), 1); map.put(new Animal(33,\"Giant sloth\"), 6);\n     map.put(new Animal(35,\"Leapord\"),2); map.put(new Animal(9,\"chipmunk\"),4); map.put(new Animal(46,\"Cave Dweller\"),1);\n     \n        System.out.println(map);\n        \n     SortedMap<Animal,Integer> headmap = map.headMap(new Animal(35,\"Leapord\"),true);\n     \n        System.out.println(headmap);\n   \n    }\n}','{Ant=6, Beee=9, chipmunk=4, muskrat=20, Dog=7, Wolf=1, Giant sloth=6, Leapord=2, Cave Dweller=1}\n{Ant=6, Beee=9, chipmunk=4, muskrat=20, Dog=7, Wolf=1, Giant sloth=6, Leapord=2}','Collections',1,NULL),(241,'public class Hello {\n    \n    \n    public static void main(String[] dicks){\n      \n     TreeMap<Animal, Integer> map = new TreeMap<>();\n     \n     map.put(new Animal(2,\"Ant\"), 6); map.put(new Animal(3,\"Beee\"),9); map.put(new Animal(15,\"Dog\"),7); map.put(new Animal(12,\"muskrat\"),20);\n     map.put(new Animal(25,\"Wolf\"), 1); map.put(new Animal(33,\"Giant sloth\"), 6);\n     map.put(new Animal(35,\"Leapord\"),2); map.put(new Animal(9,\"chipmunk\"),4); map.put(new Animal(46,\"Cave Dweller\"),1);\n     \n        System.out.println(map);\n        \n     SortedMap<Animal,Integer> headmap = map.headMap(new Animal(40,\"Python\"),true);\n     \n        System.out.println(headmap);\n   \n    }\n}','{Ant=6, Beee=9, chipmunk=4, muskrat=20, Dog=7, Wolf=1, Giant sloth=6, Leapord=2, Cave Dweller=1}\n{Ant=6, Beee=9, chipmunk=4, muskrat=20, Dog=7, Wolf=1, Giant sloth=6, Leapord=2}','Collections',1,NULL),(242,'public class Hello {\n    \n    \n    public static void main(String[] dicks){\n      \n     TreeMap<Animal, Integer> map = new TreeMap<>();\n     \n     map.put(new Animal(2,\"Ant\"), 6); map.put(new Animal(3,\"Beee\"),9); map.put(new Animal(15,\"Dog\"),7); map.put(new Animal(12,\"muskrat\"),20);\n     map.put(new Animal(25,\"Wolf\"), 1); map.put(new Animal(33,\"Giant sloth\"), 6);\n     map.put(new Animal(35,\"Leapord\"),2); map.put(new Animal(9,\"chipmunk\"),4); map.put(new Animal(46,\"Cave Dweller\"),1);\n     \n        System.out.println(map);\n        \n     SortedMap<Animal,Integer> headmap = map.headMap(new Animal(40,\"Python\"));\n     \n        System.out.println(headmap);\n   \n    }\n}','{Ant=6, Beee=9, chipmunk=4, muskrat=20, Dog=7, Wolf=1, Giant sloth=6, Leapord=2, Cave Dweller=1}\n{Ant=6, Beee=9, chipmunk=4, muskrat=20, Dog=7, Wolf=1, Giant sloth=6, Leapord=2}','Collections',1,NULL),(243,'try{\n            bw.write(df.format(today));\n            bw.newLine();\n            bw.write(\"Flash Cards \\n\");\n            bw.newLine();\n            \n            for(Card c : cards){\n                bw.write(\"================================================\\n\");\n                bw.write(\"-\"+counter+\"-\\n\");\n                bw.write(\"================================================\\n\");\n                bw.write(c.getCard());\n                bw.newLine();\n                bw.write(\"================================================\\n\");\n                bw.write(c.getAnswer());\n                bw.newLine();\n                bw.write(\"================================================\\n\");\n                counter++;\n            }\n            \n            bw.close();\n	    bw.flush();\n            \n        } catch(IOException e){\n            System.out.println(\"Problem saving cards\");\n            e.printStackTrace(); \n        } ','IOException caused by flushing a closed Bufferedwriter','Collections',1,NULL),(244,'public class Hello {\n    \n    \n    public static void main(String[] dicks){\n      \n     TreeMap<Animal, Integer> map = new TreeMap<>();\n     \n     map.put(new Animal(2,\"Ant\"), 6); map.put(new Animal(3,\"Beee\"),9); map.put(new Animal(15,\"Dog\"),7); map.put(new Animal(12,\"muskrat\"),20);\n     map.put(new Animal(25,\"Wolf\"), 1); map.put(new Animal(33,\"Giant sloth\"), 6);\n     map.put(new Animal(35,\"Leapord\"),2); map.put(new Animal(9,\"chipmunk\"),4); map.put(new Animal(46,\"Cave Dweller\"),1);\n     \n        System.out.println(map);\n        \n     SortedMap<Animal,Integer> headmap = map.headMap(new Animal(40,\"Python\"));\n     \n     System.out.println(headmap);\n        \n     NavigableMap<Animal,Integer> headmapincl = map.headMap(new Animal(34,\"Lynx\"), true);\n     SortedMap<Animal,Integer> headmap_2 = map.headMap(new Animal(30,\"Fox\"), true);\n     \n        System.out.println(headmapincl);\n        \n   \n    }\n}','{Ant=6, Beee=9, chipmunk=4, muskrat=20, Dog=7, Wolf=1, Giant sloth=6, Leapord=2, Cave Dweller=1}\n{Ant=6, Beee=9, chipmunk=4, muskrat=20, Dog=7, Wolf=1, Giant sloth=6, Leapord=2}\n{Ant=6, Beee=9, chipmunk=4, muskrat=20, Dog=7, Wolf=1, Giant sloth=6}','Collections',1,NULL),(245,'public class Hello {\n    \n    \n    public static void main(String[] dicks){\n      \n     TreeMap<Animal, Integer> map = new TreeMap<>();\n     \n     map.put(new Animal(2,\"Ant\"), 6); map.put(new Animal(3,\"Beee\"),9); map.put(new Animal(15,\"Dog\"),7); map.put(new Animal(12,\"muskrat\"),20);\n     map.put(new Animal(25,\"Wolf\"), 1); map.put(new Animal(33,\"Giant sloth\"), 6);\n     map.put(new Animal(35,\"Leapord\"),2); map.put(new Animal(9,\"chipmunk\"),4); map.put(new Animal(46,\"Cave Dweller\"),1);\n     \n        System.out.println(map);\n        \n    SortedMap<Animal,Integer> tailmap = map.tailMap(new Animal(33,\"Giant Sloth\"));\n    \n        System.out.println(tailmap);\n        \n   \n    }\n}','{Ant=6, Beee=9, chipmunk=4, muskrat=20, Dog=7, Wolf=1, Giant sloth=6, Leapord=2, Cave Dweller=1}\n{Giant sloth=6, Leapord=2, Cave Dweller=1}','Collections',1,NULL),(246,'public class Hello {\n    \n    \n    public static void main(String[] dicks){\n      \n     TreeMap<Animal, Integer> map = new TreeMap<>();\n     \n     map.put(new Animal(2,\"Ant\"), 6); map.put(new Animal(3,\"Beee\"),9); map.put(new Animal(15,\"Dog\"),7); map.put(new Animal(12,\"muskrat\"),20);\n     map.put(new Animal(25,\"Wolf\"), 1); map.put(new Animal(33,\"Giant sloth\"), 6);\n     map.put(new Animal(35,\"Leapord\"),2); map.put(new Animal(9,\"chipmunk\"),4); map.put(new Animal(46,\"Cave Dweller\"),1);\n     \n        System.out.println(map);\n        \n    SortedMap<Animal,Integer> tailmap = map.tailMap(new Animal(33,\"Giant Sloth\"),false);\n    \n        System.out.println(tailmap);\n        \n   \n    }\n}','{Ant=6, Beee=9, chipmunk=4, muskrat=20, Dog=7, Wolf=1, Giant sloth=6, Leapord=2, Cave Dweller=1}\n{Leapord=2, Cave Dweller=1}','Collections',1,NULL),(247,' public static void main(String[] dicks){\n      \n     TreeMap<Animal, Integer> map = new TreeMap<>();\n     \n     map.put(new Animal(2,\"Ant\"), 6); map.put(new Animal(3,\"Beee\"),9); map.put(new Animal(15,\"Dog\"),7); map.put(new Animal(12,\"muskrat\"),20);\n     map.put(new Animal(25,\"Wolf\"), 1); map.put(new Animal(33,\"Giant sloth\"), 6);\n     map.put(new Animal(35,\"Leapord\"),2); map.put(new Animal(9,\"chipmunk\"),4); map.put(new Animal(46,\"Cave Dweller\"),1);\n     \n        System.out.println(map);\n        \n     SortedMap<Animal,Integer> tailmap = map.tailMap(new Animal(33,\"Giant Sloth\"),false);\n     \n        System.out.println(tailmap.pollFirtEntry());\n    \n    }\n}','will not compile,\n\npollFirstEntry(),cielingKey,higherKey(), floorKey(), pollLastEntry(),\ndescendingMap()\n\n	are all in TreeMap not interface SortedMap.','Collections',1,NULL),(248,'public class Hello {\n    \n    \n    public static void main(String[] dicks){\n      \n     TreeMap<Animal, Integer> map = new TreeMap<>();\n     \n     map.put(new Animal(2,\"Ant\"), 6); map.put(new Animal(3,\"Beee\"),9); map.put(new Animal(15,\"Dog\"),7); map.put(new Animal(12,\"muskrat\"),20);\n     map.put(new Animal(25,\"Wolf\"), 1); map.put(new Animal(33,\"Giant sloth\"), 6);\n     map.put(new Animal(35,\"Leapord\"),2); map.put(new Animal(9,\"chipmunk\"),4); map.put(new Animal(46,\"Cave Dweller\"),1);\n     \n        System.out.println(map);\n        \n     \n        System.out.println(map.pollFirstEntry());\n        System.out.println(map.pollLastEntry());\n        System.out.println(map.ceilingKey(new Animal(2,\"Ant\")));\n        System.out.println(map.higherKey(new Animal(3,\"Beee\")));\n        System.out.println(map.floorKey(new Animal(46,\"Cave Dweller\")));\n        System.out.println(map.lowerKey(new Animal(35,\"Leapord\")));\n        \n    \n    }\n}','{Ant=6, Beee=9, chipmunk=4, muskrat=20, Dog=7, Wolf=1, Giant sloth=6, Leapord=2, Cave Dweller=1}\nAnt=6\nCave Dweller=1\nBeee\nchipmunk\nLeapord\nGiant sloth','Collections',1,NULL),(249,'\npublic class Hello {\n    public static void main(String[] dicks){\n      \n        PriorityQueue<Animal> q = new PriorityQueue<>();\n        \n        q.add(new Animal(5,\"Sheep\"));\n        q.offer(new Animal(6,\"Goat\"));\n        q.offer(new Animal(10,\"Cow\"));\n        q.offer(new Animal(12,\"Bull\"));\n        q.offer(null);\n        \n        System.out.println(q);\n        \n    \n    }\n}','nullpointerexception, PQ does not allow null elements','Collections',1,NULL),(250,'public class Hello {\n    public static void main(String[] dicks){\n        \n        PriorityQueue<Animal> q = new PriorityQueue<>(5);\n        \n        q.add(new Animal(5,\"Sheep\"));\n        q.offer(new Animal(6,\"Goat\"));\n        q.offer(new Animal(10,\"Cow\"));\n        q.offer(new Animal(12,\"Bull\"));\n        q.offer(new Animal(3,\"Cat\"));\n        q.offer(new Animal(7,\"Sloth\"));\n        \n        for(Animal x : q)\n            System.out.println(x);\n        \n        System.out.println(\"__________________\");\n        \n        for(Animal x : q)\n            System.out.println(q.poll());\n        \n    \n    }\n}','ConcurrentModificationExcpeiton for removing elements from the pq\nwhile iterating over it. ','Collections',1,NULL),(251,'public class Hello {\n    public static void main(String[] dicks){\n        \n        PriorityQueue<Animal> q = new PriorityQueue<>(5);\n        \n        q.add(new Animal(5,\"Sheep\"));\n        q.offer(new Animal(6,\"Goat\"));\n        q.offer(new Animal(10,\"Cow\"));\n        q.offer(new Animal(12,\"Bull\"));\n        q.offer(new Animal(3,\"Cat\"));\n        q.offer(new Animal(7,\"Sloth\"));\n        \n        for(Animal x : q)\n            System.out.println(x);\n        \n        System.out.println(\"__________________\");\n        \n        while(!q.isEmpty())\n            System.out.println(q.poll());\n        \n    \n    }\n}','Cat\nSheep\nSloth\nBull\nGoat\nCow\n__________________\nCat\nSheep\nGoat\nSloth\nCow\nBull\n\nYou need to poll the items from the PriorityQueue one by one. toString doesn\'t do that.\n\nSo instead of your System.out.println(queue); do this:\n\nwhile(!queue.isEmpty()) {\n   System.out.println(queue.poll());\n}\n\nThe reason is that the PriorityQueue is never completely sorted internally, lookup how a heap works for more detail. Polling items from it fixes the heap during the calls, thus it should output the elements in sorted order.','Collections',1,NULL),(252,'public class Hello {\n    public static void main(String[] dicks){\n        \n        PriorityQueue<Animal> q = new PriorityQueue<>(5);\n        \n        q.add(new Animal(5,\"Sheep\"));\n        q.offer(new Animal(6,\"Goat\"));\n        q.offer(new Animal(10,\"Cow\"));\n        q.offer(new Animal(12,\"Bull\"));\n        q.offer(new Animal(3,\"Cat\"));\n        q.offer(new Animal(7,\"Sloth\"));\n        \n        q.offer(\"Sloths\");\n        q.add(\"fake bull\");\n        \n        while(!q.isEmpty())\n            System.out.println(q.poll());\n        \n\n        \n    \n    }\n}','will not compile string cannot be converted to Animal','Collections',1,NULL),(253,'public class Hello {\n    public static void main(String[] dicks){\n        Comparator revSort = Collections.reverseOrder();\n        PriorityQueue<Animal> q = new PriorityQueue<>();\n        \n        q.add(new Animal(5,\"Sheep\"));\n        q.offer(new Animal(6,\"Goat\"));\n        q.offer(new Animal(10,\"Cow\"));\n        q.offer(new Animal(12,\"Bull\"));\n        q.offer(new Animal(3,\"Cat\"));\n        q.offer(new Animal(7,\"Sloth\"));\n        \n        PriorityQueue<Animal> q2 = new PriorityQueue<>(q);\n        \n        Collections.sort(q2,revSort);\n        \n        while(!q.isEmpty())\n            System.out.println(q.poll());\n        \n        while(!q2.isEmpty())\n            System.out.println(q2.poll());\n\n    }\n}','will not compile, Collections.sort will only sort Lists','Collections',1,NULL),(254,'public class Hello {\n    public static void main(String[] dicks){\n        Comparator revSort = Collections.reverseOrder();\n        PriorityQueue<Animal> q = new PriorityQueue<>(revSort);\n        \n        q.add(new Animal(5,\"Sheep\"));\n        q.offer(new Animal(6,\"Goat\"));\n        q.offer(new Animal(10,\"Cow\"));\n        q.offer(new Animal(12,\"Bull\"));\n        q.offer(new Animal(3,\"Cat\"));\n        q.offer(new Animal(7,\"Sloth\"));\n        \n        while(!q.isEmpty()){\n            System.out.println(q.poll());\n        }\n        \n        \n\n    }\n}','Bull\nCow\nSloth\nGoat\nSheep\nCat','Collections',1,NULL),(255,'public class Hello {\n    public static void main(String[] dicks){\n        Comparator revSort = Collections.reverseOrder();\n        PriorityQueue<Animal> q = new PriorityQueue<>(revSort);\n        \n        q.add(new Animal(5,\"Sheep\"));\n        q.offer(new Animal(6,\"Goat\"));\n        q.offer(new Animal(10,\"Cow\"));\n        q.offer(new Animal(12,\"Bull\"));\n        q.offer(new Animal(3,\"Cat\"));\n        q.offer(new Animal(7,\"Sloth\"));\n        \n        System.out.println(q.remove());\n        System.out.println(q.remove(new Animal(7,\"Sloth\")));\n        \n        while(!q.isEmpty()){\n            System.out.println(q.poll());\n        }\n\n    }\n}\n\nclass Animal implements Comparable<Animal> {\n    private Integer size;\n    private String name;\n    \n    public Animal(int x, String y){\n        size = x;\n        name = y;\n    }\n\n    public int getSize() {\n        return size;\n    }\n\n    public String getName() {\n        return name;\n    }\n    public int compareTo(Animal o){\n        return size.compareTo(o.getSize());\n        \n    }\n    \n    public String toString(){\n        return name;\n    }\n}\n','Here animal doesn\'t impleemnt equals and remove uses equals to determine the \nelement to remove','Collections',1,NULL),(256,'public class Hello {\n    public static void main(String[] dicks){\n        Comparator revSort = Collections.reverseOrder();\n        PriorityQueue<Animal> q = new PriorityQueue<>(revSort);\n        \n        q.add(new Animal(5,\"Sheep\"));\n        q.offer(new Animal(6,\"Goat\"));\n        q.offer(new Animal(10,\"Cow\"));\n        q.offer(new Animal(12,\"Bull\"));\n        q.offer(new Animal(3,\"Cat\"));\n        q.offer(new Animal(7,\"Sloth\"));\n        \n        System.out.println(q.remove());\n        System.out.println(q.remove(new Animal(7,\"Sloth\")));\n        System.out.println(\"\");\n        \n        while(!q.isEmpty()){\n            System.out.println(q.poll());\n        }\n    }\n}\n\nclass Animal implements Comparable<Animal> {\n    private Integer size;\n    private String name;\n    \n    public Animal(int x, String y){\n        size = x;\n        name = y;\n    }\n\n    public int getSize() {\n        return size;\n    }\n\n    public String getName() {\n        return name;\n    }\n    public int compareTo(Animal o){\n        return size.compareTo(o.getSize());\n        \n    }\n    \n    public String toString(){\n        return name;\n    }\n    \n    public boolean equals(Object o){\n        if((o instanceof Animal)){\n            if((((Animal)o).getSize() == this.size) && (((Animal)o).getName().equals(name) ))\n                return true;\n            return false;           \n        } \n        return false;\n    }\n}','now with equals remove() works just fine. \n\nBull\ntrue\n\nCow\nGoat\nSheep\nCat\n\nnotice the pq is sorted with a Reverse sort comparator, so the animal class\nimplements Comparable. If it didn\'t implement Comparable it could not be used \nin the PriorityQueue. If it wasn\'t for the equals method the remove(sloth)\ncall would return false and sloth would not be removed. Thus making the \noutput:\n\n	Bull\n	false\n\n	Cow\n	Sloth\n	Goat\n	Sheep\n	Cat\n\nalso notice that it is a queue and therefore removes from the head','Collections',1,NULL),(257,'public class Hello {\n    public static void main(String[] dicks){\n        Map<Integer,String> map = new HashMap<>();\n        \n        map.put(7,\"Biffy\");\n        map.put(5,\"two tone\");\n        map.put(9,\"big slick\");\n        map.put(1,\"funny farm\");\n        map.put(10, \"twice tickled\");\n        \n        List<Integer> list = new ArrayList<>();\n        \n        list.add(7);\n        list.add(5);\n        list.add(9);\n        list.add(1);\n        list.add(10);\n        list.add(16);\n        list.add(14);\n        \n        for(int x : list){\n            System.out.println(map.remove(x));\n        }    \n\n    }\n}','Biffy\ntwo tone\nbig slick\nfunny farm\ntwice tickled\nnull\nnull','Collections',1,NULL),(258,'public class Hello {\n    public static void main(String[] dicks){\n        Map<Integer,String> map = new HashMap<>();\n        \n        map.put(7,\"Biffy\");\n        map.put(5,\"two tone\");\n        map.put(9,\"big slick\");\n        map.put(1,\"funny farm\");\n        map.put(10, \"twice tickled\");\n        \n        List<Integer> list = new ArrayList<>();\n        \n        list.add(7);\n        list.add(5);\n        list.add(9);\n        list.add(1);\n        list.add(10);\n        list.add(16);\n        list.add(14);\n        \n        Set<Integer> set = new HashSet<>();\n        \n        set.add(7);\n        set.add(5);\n        set.add(9);\n        set.add(1);\n        set.add(10);\n        \n        for(int x : list){\n            System.out.println(\"sizes: \"+map.size() +\", \"+ list.size()+\", \"+set.size());\n            System.out.println(map.remove(x));\n            System.out.println(\"set contains?: \"+set.contains(x));\n        }    \n\n    }\n}','sizes: 5, 7, 5\nBiffy\nset contains?: true\nsizes: 4, 7, 5\ntwo tone\nset contains?: true\nsizes: 3, 7, 5\nbig slick\nset contains?: true\nsizes: 2, 7, 5\nfunny farm\nset contains?: true\nsizes: 1, 7, 5\ntwice tickled\nset contains?: true\nsizes: 0, 7, 5\nnull\nset contains?: false\nsizes: 0, 7, 5\nnull\nset contains?: false','Collections',1,NULL),(259,'Spaces sort before characters,\nuppercases sort before the lower,\nyour good to go','','Collections',1,NULL),(260,'public class Hello {\n    public static void main(String[] dicks){\n       HashSet<Animal> set = new HashSet<>();\n       \n       Animal cat = new Animal(3,\"Cat\");\n       Animal dog = new Animal(4,\"Dog\");\n       Animal wolf = new Animal(6,\"Wolf\");\n       Animal coyote = new Animal(5,\"Coyote\");\n       Animal cat2 = new Animal(3,\"Cat\");\n       \n        System.out.println(cat.equals(cat2));\n       \n        System.out.println(set.add(cat));\n        System.out.println(set.add(cat));\n        System.out.println(set.add(dog));\n        System.out.println(set.add(wolf));\n        System.out.println(set.add(coyote));\n        System.out.println(set.add(cat2));\n        \n       \n        System.out.println(set.size());\n        System.out.println(set.remove(cat));\n        System.out.println(set.contains(cat));\n        System.out.println(set.size());\n        \n        \n    \n    }\n}\n\n\nclass Animal {\n    private Integer size;\n    private String name;\n    \n    public Animal(int x, String y){\n        size = x;\n        name = y;\n    }\n\n    public int getSize() {\n        return size;\n    }\n\n    public String getName() {\n        return name;\n    }\n    \n    public String toString(){\n        return name;\n    }\n    \n    public boolean equals(Object o){\n        if((o instanceof Animal)){\n            if((((Animal)o).getSize() == this.size) && (((Animal)o).getName().equals(name) ))\n                return true;\n            return false;           \n        } \n        return false;\n    }\n    \n    //public int hashCode(){ return name.length() + size; }\n        \n}','true\ntrue\nfalse\ntrue\ntrue\ntrue\nfalse\n4\ntrue\nfalse\n3','Collections',1,NULL),(261,'public class Hello {\n    public static void main(String[] dicks){\n       HashSet<Animal> set = new HashSet<>();\n       \n       Animal cat = new Animal(3,\"Cat\");\n       Animal dog = new Animal(4,\"Dog\");\n       Animal wolf = new Animal(6,\"Wolf\");\n       Animal coyote = new Animal(5,\"Coyote\");\n       Animal cat2 = new Animal(3,\"Cat\");\n       \n        System.out.println(cat.equals(cat2));\n       \n        System.out.println(set.add(cat));\n        System.out.println(set.add(cat));\n        System.out.println(set.add(dog));\n        System.out.println(set.add(wolf));\n        System.out.println(set.add(coyote));\n        System.out.println(set.add(cat2));\n        \n       \n        System.out.println(set.size());\n        System.out.println(set.remove(cat));\n        System.out.println(set.contains(cat));\n        System.out.println(set.size());\n        \n        \n    \n    }\n}\n\n\nclass Animal {\n    private Integer size;\n    private String name;\n    \n    public Animal(int x, String y){\n        size = x;\n        name = y;\n    }\n\n    public int getSize() {\n        return size;\n    }\n\n    public String getName() {\n        return name;\n    }\n    \n    public String toString(){\n        return name;\n    }\n    \n    public boolean equals(Object o){\n        if((o instanceof Animal)){\n            if((((Animal)o).getSize() == this.size) && (((Animal)o).getName().equals(name) ))\n                return true;\n            return false;           \n        } \n        return false;\n    }\n    \n    public int hashCode(){ return name.length() + size; }\n        \n}\n','true\ntrue\nfalse\ntrue\ntrue\ntrue\nfalse\n4\ntrue\nfalse\n3\n\nif hashCode() is not overriden then every object will go in its own bucket\ntherefore equals will not be able to differentiate between equal objects because it will have no\nother objects to compare that object to!','Collections',1,NULL),(262,'public class Hello {\n    public static void main(String[] dicks){\n       HashSet<Animal> set = new HashSet<>();\n       \n       Animal cat = new Animal(3,\"Cat\");\n       Animal dog = new Animal(4,\"Dog\");\n       Animal wolf = new Animal(6,\"Wolf\");\n       Animal coyote = new Animal(5,\"Coyote\");\n       Animal cat2 = new Animal(3,\"Cat\");\n       \n        System.out.println(cat.equals(cat2));\n       \n        System.out.println(set.add(cat));\n        System.out.println(set.add(cat));\n        System.out.println(set.add(dog));\n        System.out.println(set.add(wolf));\n        System.out.println(set.add(coyote));\n        System.out.println(set.add(cat2));\n        \n       \n        System.out.println(set.size());\n        System.out.println(set.remove(cat));\n        System.out.println(set.contains(cat));\n        System.out.println(set.size());\n        \n        \n    \n    }\n}\n\n\nclass Animal {\n    private Integer size;\n    private String name;\n    \n    public Animal(int x, String y){\n        size = x;\n        name = y;\n    }\n\n    public int getSize() {\n        return size;\n    }\n\n    public String getName() {\n        return name;\n    }\n    \n    public String toString(){\n        return name;\n    }\n    \n    /**\n    public boolean equals(Object o){\n        if((o instanceof Animal)){\n            if((((Animal)o).getSize() == this.size) && (((Animal)o).getName().equals(name) ))\n                return true;\n            return false;           \n        } \n        return false;\n    } **/\n    \n    public int hashCode(){ return name.length() + size; }\n        \n}\n','false\ntrue\nfalse\ntrue\ntrue\ntrue\ntrue\n5\ntrue\nfalse\n4\n\nif equals is not overriden then only references with the same actual\nobject are considered equal','Collections',1,NULL),(263,'public class Hello {\n    public static void main(String[] dicks){\n       Animal cat = new Animal(3,\"Cat\");\n       Animal dog = new Animal(4,\"Dog\");\n       Animal wolf = new Animal(6,\"Wolf\");\n       Animal coyote = new Animal(5,\"Coyote\");\n       Animal cat2 = new Animal(3,\"Cat\");\n       \n       LinkedHashSet<Animal> lhs = new LinkedHashSet<>();\n       HashSet<Animal> hs = new HashSet<>();\n       \n       lhs.add(cat); lhs.add(dog); lhs.add(wolf); lhs.add(coyote); lhs.add(null);\n       hs.add(cat); hs.add(dog); hs.add(wolf); hs.add(coyote); hs.add(null);\n       \n       for(Animal x : lhs){\n           System.out.print(x.getName()+\" \");\n       }\n \n    }\n}','nullpointerexception\n\nLinkedHashSet and HashSet allow null elements but when you call a method on a null\nyou get an exception','Collections',1,NULL),(264,'public class Hello {\n    public static void main(String[] dicks){\n       Animal cat = new Animal(3,\"Cat\");\n       Animal dog = new Animal(4,\"Dog\");\n       Animal wolf = new Animal(6,\"Wolf\");\n       Animal coyote = new Animal(5,\"Coyote\");\n       Animal cat2 = new Animal(3,\"Cat\");\n       \n       LinkedHashSet<Animal> lhs = new LinkedHashSet<>();\n       HashSet<Animal> hs = new HashSet<>();\n       \n       lhs.add(cat); lhs.add(dog); lhs.add(wolf); lhs.add(coyote);\n       hs.add(cat); hs.add(dog); hs.add(wolf); hs.add(coyote); \n       \n       System.out.println( lhs.add(null) ); \n       System.out.println( hs.add(null) );\n       \n       System.out.println( lhs.add(null) );\n       System.out.println( hs.add(null) );\n        \n\n    }\n}','true\ntrue\nfalse\nfalse\n\nSets allow null elements but they also dont allow duplicates so here \nis will not let you add ANother null','Collections',1,NULL),(265,'public class Hello {\n    public static void main(String[] dicks){\n       Animal cat = new Animal(3,\"Cat\");\n       Animal dog = new Animal(4,\"Dog\");\n       Animal wolf = new Animal(6,\"Wolf\");\n       Animal coyote = new Animal(5,\"Coyote\");\n       Animal cat2 = new Animal(3,\"Cat\");\n       \n       LinkedHashSet<Animal> lhs = new LinkedHashSet<>();\n       HashSet<Animal> hs = new HashSet<>();\n       Hashtable<Animal> ht = new Hashtable<>();\n       \n       lhs.add(cat); lhs.add(dog); lhs.add(wolf); lhs.add(coyote);\n       hs.add(cat); hs.add(dog); hs.add(wolf); hs.add(coyote); \n       \n       System.out.println(lhs.add(null)); \n       System.out.println(hs.add(null));\n       \n       System.out.println(lhs.add(null));\n       System.out.println(hs.add(null));\n        \n\n    }\n}','will not compile,\n\nHashtable is a Map !\n\nrequires two type arguments','Collections',1,NULL),(266,'public class Hello {\n    public static void main(String[] dicks){\n       Animal cat = new Animal(3,\"Cat\");\n       Animal dog = new Animal(4,\"Dog\");\n       Animal wolf = new Animal(6,\"Wolf\");\n       Animal coyote = new Animal(5,\"Coyote\");\n       Animal cat2 = new Animal(3,\"Cat\");\n\n       Hashtable<Integer,Animal> ht = new Hashtable<>();\n\n        System.out.println(ht.put(1,cat));\n        System.out.println(ht.put(2,dog));\n        System.out.println(ht.put(3,wolf));\n        System.out.println(ht.put(4,coyote));\n        System.out.println(ht.put(5, cat2));\n        \n        System.out.println(ht.put(1,cat));\n        System.out.println(ht.put(1,new Animal(3,\"Barn Cat\")));\n        \n        System.out.println(ht.put(2,dog));\n        System.out.println(ht.put(2, new Animal(4,\"Fox\")));\n    }\n}','null\nnull\nnull\nnull\nnull\nCat\nCat\nDog\nDog\n\nput\n\npublic V put(K key,\n    V value)\n\nMaps the specified key to the specified value in this hashtable. \nNeither the key nor the value can be null.\n\nThe value can be retrieved by calling the get\n method with a key that is equal to the original key.\n\nTo successfully store and retrieve objects from a hashtable, \nthe objects used as keys \nmust implement the hashCode method and the equals method. \n\nto know anything about how this code works you need to know if it implements\nequals and hashCode','Collections',1,NULL),(267,'public class Hello {\n    public static void main(String[] dicks){\n       Animal cat = new Animal(3,\"Cat\");\n       Animal dog = new Animal(4,\"Dog\");\n       Animal wolf = new Animal(6,\"Wolf\");\n       Animal coyote = new Animal(5,\"Coyote\");\n       Animal cat2 = new Animal(3,\"Cat\");\n\n       Hashtable<Integer,Animal> ht = new Hashtable<>();\n\n        System.out.println(ht.put(1,cat));\n        System.out.println(ht.put(2,dog));\n        System.out.println(ht.put(3,wolf));\n        System.out.println(ht.put(4,coyote));\n        System.out.println(ht.put(5, cat2));\n        \n        System.out.println(ht.put(1,cat));\n        System.out.println(ht.put(1,new Animal(3,\"Barn Cat\")));\n        \n        System.out.println(ht.size());\n        \n        System.out.println(ht.put(2,dog));\n        System.out.println(ht.put(2, new Animal(4,\"Fox\")));\n    }\n}\n\n\nclass Animal {\n    private Integer size;\n    private String name;\n    \n    public Animal(int x, String y){\n        size = x;\n        name = y;\n    }\n\n    public int getSize() {\n        return size;\n    }\n\n    public String getName() {\n        return name;\n    }\n    \n    public String toString(){\n        return name;\n    }\n    \n    /**\n    public boolean equals(Object o){\n        if((o instanceof Animal)){\n            if((((Animal)o).getSize() == this.size) && (((Animal)o).getName().equals(name) ))\n                return true;\n            return false;           \n        } \n        return false;\n    } **/\n    \n    //public int hashCode(){ return name.length() + size; }\n        \n}\n','null\nnull\nnull\nnull\nnull\nCat\nCat\n5\nDog\nDog','Collections',1,NULL),(268,'public class Hello {\n    public static void main(String[] dicks){\n        Map<String, Integer> map = new HashMap<>();\n        \n        String name = \"Max\";\n        map.put(name,10000000);\n        \n        int total = map.get(\"Max\");\n        \n        (if total == null){\n            System.out.println(\"no money in maxs account\");\n        }\n    }\n}','will not compile int cannot auotbox to null\n\na primitive cannot be null','Collections',1,NULL),(269,'The generics type identifier can be used in class, method, and variable declarations....\n\n','class Foo<t> { }	// a class\nT anInstance;		//an instance variable\nFoo(T aRef) { }	// a constructor argument\nvoid bar(T aRef) { }	// a method argument\nT baz() { }		// a return type\n\nThe compiler will substitute the actual type','Generics',1,NULL),(270,'Which Collection interfaces have a method for removing an element by the object ?','List and Set, With Maps you remove by the key which removes the element','Collections',1,NULL),(271,'public class Hello {\n    public static void main(String[] args){\n        List myList = new ArrayList();\n        myList.add(\"Hoyt\");\n        myList.add(\"JOJO\");\n        myList.add(\"Adam\");\n        \n        String athletename = myList.get(1);\n        System.out.println(athletename+ \" \" + athletename.length());\n    }\n}','Will Not compile\n\nuntyped collections store Objects so you would have to cast to a String. ','Collections',1,NULL),(272,'void takeListOfStrings(List<String> strings) {\n	strings.add(new Integer(42) ); \n}','Will Not compile','Generics',1,NULL),(273,'public List<Dog> getDogList() {\n	List<Dog> dogs = new ArrayList<>();\n	//add dogs to list\n	return dogs;\n}\n\nDog d = getDogList().get(0);','Compiles fine, you know what is coming out of a typed list returned from a method declared with that type','Generics',1,NULL),(274,'public List getDogList() {\n	List dogs = new ArrayList();\n	dogs.add(\"Dicks\");\n	dogs.add(\"Spot\");\n	dogs.add(\"FIdo\");\n	return dogs;\n}\n\npsvm(sa){	\n	List dognames = getDogList();\n	Dog fido = dognames.get(2);\n}\n	','Will not compile','Generics',1,NULL),(275,'psvm(sa){\n	List<Integer> list = new ArrayList<>();\n	list.add(5);\n	list.add(9);\n	list.add(7);\n\n	Integer i = (Integer) list.get(0);\n}','The cast is unecessary but it wont cause any error','Generics',1,NULL),(276,'public class Hello {\n    public static void main(String[] args){\n        List<Integer> myList = new ArrayList<>();\n        \n        myList.add(4);\n        myList.add(6);\n        Adder adder = new Adder();\n        int total = adder.addAll(myList);\n        \n        System.out.println(total);\n        \n    }\n}\n\nclass Adder {\n        int addAll(List list){\n            Iterator it = list.iterator();\n            int total = 0;\n            \n            while(it.hasNext()){\n                int i = ((Integer)it.next()).intValue();\n                total += i;\n            }\n            \n            return total;\n        }\n}','Works fine. ','Generics',1,NULL),(277,'public class Hello {\n    public static void main(String[] args){\n        List myList = new ArrayList();\n        \n        myList.add(4);\n        myList.add(6);\n        myList.add(\"whoops\");\n        Adder adder = new Adder();\n        int total = adder.addAll(myList);\n        \n        System.out.println(total);\n        \n    }\n}\n\nclass Adder {\n        int addAll(List list){\n            Iterator it = list.iterator();\n            int total = 0;\n            \n            while(it.hasNext()){\n                int i = ((Integer)it.next()).intValue();\n                total += i;\n            }\n            \n            return total;\n        }\n}','ClassCastException','Generics',1,NULL),(278,'public class Hello {\n    public static void main(String[] args){\n        List<Integer> myList = new ArrayList<>();\n        \n        myList.add(4);\n        myList.add(6);\n        Inserter is = new Inserter();\n        is.insert(myList);\n        \n    }\n}\n\nclass Inserter {\n        void insert(List list){\n            list.add(new Integer(42));\n            Iterator it = list.iterator();\n            int total = 0;\n            \n            while(it.hasNext()){\n                int i = ((Integer)it.next()).intValue();\n                total += i;\n            }\n\n        }\n}','compiles and runs no problem','Generics',1,NULL),(279,'public class Hello {\n    public static void main(String[] args){\n        List<Integer> myList = new ArrayList<>();\n        \n        myList.add(4);\n        myList.add(6);\n        Inserter is = new Inserter();\n        is.insert(myList);\n        \n    }\n}\n\nclass Inserter {\n        void insert(List list){\n            list.add(\"42\");\n            Iterator it = list.iterator();\n            int total = 0;\n            \n            while(it.hasNext()){\n                int i = ((Integer)it.next()).intValue();\n                total += i;\n            }\n\n        }\n}','ClassCastException\n\nand compiler warning for going into unsafe method','Generics',1,NULL),(280,'public class Hello {\n    public static void main(String[] args){\n        List<Integer> myList = new ArrayList<>();\n        \n        myList.add(4);\n        myList.add(6);\n        Inserter is = new Inserter();\n        is.insert(myList);\n        \n    }\n}\n\nclass Inserter {\n        void insert(List list){\n            list.add(\"42\");\n            Iterator it = list.iterator();\n            int total = 0;\n            \n            while(it.hasNext()){\n                int i = (it.next()).intValue();\n                total += i;\n            }\n\n        }\n}','Will not compile because of .intValue() the list declared in inserter is of type Object','Generics',1,NULL),(281,'public class Hello {\n    public static void main(String[] args){\n        List<Integer> myList = new ArrayList<>();\n        \n        myList.add(4);\n        myList.add(6);\n        Inserter is = new Inserter();\n        is.insert(myList);\n        \n    }\n}\n\nclass Inserter {\n        void insert(List list){\n            list.add(\"42\");           \n        }\n}','comiler warning but compiles and runs just fine, in order to support legacy code this must be allowed. ','Generics',1,NULL),(282,'The compiiler only issues warnings when a typed collection is going into an untyped method and that method\nADDS somethiing. ','','Generics',1,NULL),(283,'\"Type Erasure\"\n','The generic types are removed by the compiler before runtime. The types are just for the compiler the JVM\nhas no idea about types. To the JVM generic code looks the same as pre generic. ','Generics',1,NULL),(284,'List myList = new ArrayList();\n        \nmyList.add(45);\n        \nint x = (Integer) myList.get(0);','cast is required here','Generics',1,NULL),(285,' List<Integer> myList = new ArrayList<>();\n        \n        myList.add(45);\n        \n        int x = myList.get(0);\n        \n        ','cast not necessary here','Generics',1,NULL),(286,'List<Object> myList = new ArrayList<JButton>();\nList<Number> myList = new ArrayList<Integer>();\nList<JButton> myList = new ArrayList<JButton>();\nList<String> myList = new ArrayList<String>();','no\nno\nyes\nyes','Generics',1,NULL),(287,'class Parent { }\nclass Child extends Parent { }\n\npublic class Test {\n	psvm(SA){\n		Parent[] myArray = new Child[4];\n	}\n}','This is ok!\n\nunlike collection types array types can use polymorphism.\n','Generics',1,NULL),(288,'List<Object> myList = new ArrayList<JButton>();	','This not ok ','Generics',1,NULL),(289,'public class AnimalDoctor {\n	public void checkAnimals(ArrayLIst<Animal> list){\n		for(Animal a : animals){\n			a.checkup();\n		}\n	}\n}\n\npsvm(Sa){\n        List<Dog> dogs = new ArrayList<Dog>();\n        dogs.add(new Dog()); dogs.add(new Dog());\n\n        List<Cat> cats = new ArrrayLiist<Cat>();\n        cats.add(new Cat()); cats.add(new Cat());\n\n        AnimalDoctor ad = new AnimalDoctor();\n        ad.checkAnimals(dogs);\n        ad.checkAnimals(cats);\n}\n}','Will not compile\n\nif the method parameter says ArrayList<Animal> then you\ncan only pass in an ArrayList of type <Animal>, \npolymorphism doesn\'t work for generic types','Generics',1,NULL),(290,'Animal[] animals = new Animal[3];\nanimals[0] = new Cat();\nanimals[1] = new Dog();','fine','Generics',1,NULL),(291,'List<Animal> animals = new ArrayList<Animal>();\nanimals.add(new Cat());\nanimals.add(new Dog());\n','fine you can add and instance of a subtype into an array or collection declared with a supertype.\n\nyou can addDogs and Cats to an Animal array or an Animal Collection. ','Generics',1,NULL),(292,'public class Hello {\n    public static void main(String[] args){\n       \n      \n        \n    }\n    \n    public void foo() {\n	Dog[] dogs = { new Dog(), new Dog() };\n	addAnimal(dogs);\n    }\n    \n    public void addAnimal(Animal[] animals) {\n	animals[0] = new Dog();\n        animals[1] = new Cat();\n    }\n}','ok!','Generics',1,NULL),(293,'public class Hello {\n    public static void main(String[] args){\n \n    }\n    \n    public void foo() {\n	Cat[] cats = { new Cat(), new Cat() };\n	addAnimal(cats);\n    }\n    \n    public void addAnimal(Animal[] animals) {\n	animals[0] = new Dog();\n        animals[1] = new Cat();\n    }\n}','ok !\n\nThe compiler thinks its ok to add a Dog to an Animal[] since a Dog can be assigned to an animal reference. B\n\nBut the compiler does not know if you passed in an array of an animal subtype. \n\nThe reason: at runtime the JVM knows the type of the array but not the type of the collection ','Generics',1,NULL),(294,'public class Hello {\n    public static void main(String[] args){\n        List<Animal> animals = new ArrayList<Animal>();\n        animals.add(new Dog());\n        animals.add(new Cat());\n        \n        addAnimal(animals);\n    \n    }\n    public static void addAnimal(List<Animal> animals) {\n	animals.add(new Dog());\n    }\n}','comiles and runs just fine','Generics',1,NULL),(295,'public class Hello {\n    public static void main(String[] args){\n        ArrayList<Animal> animals = new ArrayList<>();\n        animals.add(new Dog());\n        animals.add(new Cat());\n        \n        addAnimal(animals);\n    \n    }\n    public static void addAnimal(List<Animal> animals) {\n	animals.add(new Dog());\n    }\n}','comiles fine','Generics',1,NULL),(296,'public class Hello {\n    public static void main(String[] args){\n        List<Dog> animals = new ArrayList<>();\n        animals.add(new Dog());\n        \n        \n        addAnimal(animals);\n    \n    }\n    public static void addAnimal(List<Animal> animals) {\n	animals.add(new Dog());\n    }\n}','will not compile, ','Generics',1,NULL),(297,'public class Hello {\n    public static void main(String[] args){\n        ArrayList<Dog> animals = new ArrayList<>();\n        animals.add(new Dog());\n        \n        \n        addAnimal(animals);\n    \n    }\n    public static void addAnimal(List<Animal> animals) {\n	animals.add(new Dog());\n    }\n}','will not compile because of ArrayList<Dog> cant be applied to List<Animal>','Generics',1,NULL),(298,'What mechanism is used to tell the compiler \" Hey, I\'m using the collection passed in just to invoke methods \non the elements  and I promise not to ADD anything into the collection\"','<?> wildcard\n\ntells the compiler you can take any generic subtype of the declared argument type because you won\'t\nbe putting anything in the collection. ','Generics',1,NULL),(299,'public class Hello {\n    public static void main(String[] args){\n        ArrayList<Dog> animals = new ArrayList<>();\n        animals.add(new Dog());\n        \n        \n        addAnimal(animals);\n    \n    }\n    public static void addAnimal(List<? extends Animal> animals) {\n	animals.add(new Dog());\n    }\n}','wont compile \n\nadding to a collection is not compatible with ? notation','Generics',1,NULL),(300,'public class Hello {\n    public static void main(String[] args){\n        ArrayList<Dog> animals = new ArrayList<>();\n        animals.add(new Dog());\n        \n        \n        addAnimal(animals);\n    \n    }\n    public static void addAnimal(List<? extends Animal> animals) {\n	for(Animal a : animals){\n            a.makesound();\n        }\n    }\n}','compiles fine!','Generics',1,NULL),(301,'public class Hello {\n    public static void main(String[] args){\n        ArrayList<Dog> animals = new ArrayList<>();\n        animals.add(new Dog());\n        \n        \n        addAnimal(animals);\n    \n    }\n    public static void addAnimal(List<? extends Serializable> animals) {\n	for(Animal a : animals){\n            a.makesound();\n        }\n    }\n}\n\nclass Dog extends Animal{}\nclass Cat extends Animal{}\nclass Animal implements Serializable{\n    public void makesound(){ System.out.println(\"SOUND\"); }\n        \n}','will not compile because of for(Animal a : animals)\n\n	needs to be... \n		for(Serializable a : animals)','Generics',1,NULL),(302,'public class Hello {\n    public static void main(String[] args){\n        ArrayList<Dog> animals = new ArrayList<>();\n        animals.add(new Dog());\n        \n        \n        addAnimal(animals);\n    \n    }\n    public static void addAnimal(List<? extends Serializable> animals) {\n	for(Serializable a : animals){\n            //call method form interface\n        }\n    }\n}\n\nclass Dog extends Animal{}\nclass Cat extends Animal{}\nclass Animal implements Serializable{\n    public void makesound(){ System.out.println(\"SOUND\"); }\n        \n}','compiles fine!','Generics',1,NULL),(303,'What can you use to type a method parameter and still add to the collection','<? super Dog>\n\npublic class Hello {\n    public static void main(String[] args) {     \n\n        List<Animal> animals = new ArrayList<Animal>();\n        animals.add(new Dog());\n        animals.add(new Cat());\n        \n        addAnimal(animals);\n    \n    }\n    \n    public static void addAnimal(List<? super Dog> animals) {\n	animals.add(new Dog());\n    }\n}\n\nWhile you can now accept in List types of <? super Dog> you can still only\nadd type Dog to that list. This is created because its ok to add a Dog to List<Object>\n\n\n','Generics',1,NULL),(304,'public class Hello {\n    public static void main(String[] args){\n        List<Animal> animals = new ArrayList<Animal>();\n        animals.add(new Dog());\n        animals.add(new Animal());\n        \n        addAnimal(animals);\n        \n    \n    }\n    public static void addAnimal(List<? super Dog> animals) {\n	animals.add(new Dog());\n    }\n}','this is fine\n\n\"Hey compiler, please accept any List with a generic type that is of type Dog or a supertype of Dog. \nNothing lower in the inheritance tree can come in, but anything higher than Dog is okay\"\n\nif you pass in a List of type Animal then it\'s perfectly fine to add a Dog to it. If you pass in a list of type Dog\nits still ok to add a Dog to it. if you pass in a list of type Object its still ok. \n\nHowever that doesn\'t give you the freedom to just add anything  you can still\nonly add the type after the super','Generics',1,NULL),(305,'public class Hello {\n    public static void main(String[] args){\n        List<Animal> animals = new ArrayList<Animal>();\n        animals.add(new Dog());\n        animals.add(new Animal());\n        \n        addAnimal(animals);\n        \n    \n    }\n    public static void addAnimal(List<Object> animals) {\n	animals.add(new Dog());\n    }\n}','will not compile incompatible types ','Generics',1,NULL),(306,'','','Generics',1,NULL),(307,'whats the difference between\n\npublic void foo(List<?> list){ }\npublic void foo(List<Object> list) { }','? will mean that any type of list can be passed to this method however nothing will be allowed to be added to it\n\n<Object> will mean that only lists of type Object can be passed to this method and \nyou will be able to add pretty much anything to that list. ','Generics',1,NULL),(308,'public class TestWildcards {\n	psvm(sa) {\n		List<Integer> myList = new ArrayList<Integer>();\n		Bar bar = new Bar();\n		bar.doInsert(MyList);\n	}\n}\n\nclass Bar {\n	void doInsert(List<Object> list) {\n		list.add(new Dog();	\n	}\n}\n\nwhich class fails compilation here ?','class Bar compiles fine\n\nTest is the class that fails. ','Generics',1,NULL),(309,'public class TestWildcards {\n	psvm(sa) {\n		List<Integer> myList = new ArrayList<Integer>();\n		Bar bar = new Bar();\n		bar.doInsert(MyList);\n	}\n}\n\nclass Bar {\n	void doInsert(List<?> list) {\n		list.add(new Dog();	\n	}\n}\n\nwhich class fails compilation here ?','Bar','Generics',1,NULL),(310,'whats the difference between \n\nList<?>\nList<? extends Object>','nothing they are identicle \n\nthey both say I can refer to any type of object. but you wont be able to addd to me. \n\nthis is very differenct from List<Object> ','Generics',1,NULL),(311,'1 List<?> list = new ArrayList<Dog>();\n2 List<? extends Animal> alist = new ArrayList<Dog>();\n3  List<?> foo = new ArrayList<? extends Animal>();\n4 List<? extends Dog> cList = new ArrayList<Integer>();\n5 List<? super Dog> dList = new ArrayList<Animal>();\n6 List<? super Animal elist = new ArrayList<Dog>();\n\n','1 2  and 5 compile ','Generics',1,NULL),(312,'Which interface close() is idempotent ?','AutoCloseable()\nyou can call close() mulitple times and nothing will happen the second time and beyond. \n\nCloseable() is not, something could go wrong the second time','Generics',1,NULL),(313,'declare a generic method:\n\npublic <T> void makeArrayList(T t){ }\n\npublic void makeArrayList(T t) { }\n\npublic void <T> makeArrayList(T t){\n}','public <T> void makeArrayList(T t){ }\n\nYou have to define the type variable BEFORE the return type of the method\n\n','Generics',1,NULL),(314,'public class Hello<T> {\n    public static void main(String[] args){\n        Printer<String> x = Printer.getInstance();\n\n    }\n    public static void addAnimal(List<T> animals) {\n	animals.add(new Dog());\n    }\n    \n    public <G> ArrayList<G> makeArrayList(G g){\n        ArrayList<G> genlist = new ArrayList();\n        genlist.add(g);\n        return genlist;\n        \n    }\n}\n\nclass Printer<T> {\n    private ArrayList<T> joblist = new ArrayList<>();\n    private static Printer instance = null;\n    \n    protected Printer(){\n        \n    }\n    \n    public static Printer getInstance(){\n        if(instance == null){\n            instance = new Printer();\n            return instance;\n        }\n        \n        return instance;\n        \n    }\n    \n    public void addJob(T t){\n        joblist.add(t);\n    }\n}','Will not compile \n\nNon static type variable cannot be referenced from static context. \n\nWhen T is defined for a new class it is appropriate for that instance there forfore static methods of that \nclass wont really know about the individualy typed instances. \n\nSingleton with generics doesn\'t make a whole lot of sense anyway....\n\npublic class SimpleSingleton {\nprivate Map<String, Object> counter = new HashMap<String, Object>();\n\npublic <T> T getInstance(Class<T> clazz) throws IllegalAccessException, InstantiationException {\n    T singleton = (T) counter.get(clazz.getName());\n    if (singleton == null) {\n        singleton = clazz.newInstance();\n        counter.put(clazz.getName(), singleton);\n    }\n    return singleton;\n}\n\n\nalso adding a Dog to an ArrayList typed for T will not compile \n','Generics',1,NULL),(315,'public class Hello<T> {\n    public static void main(String[] args){\n        Printer<String> x = new Printer<>();\n        String y = x.instance;\n        System.out.println(y.length());\n\n    } \n    public <G> ArrayList<G> makeArrayList(G g){\n        ArrayList<G> genlist = new ArrayList();\n        genlist.add(g);\n        return genlist;\n        \n    }\n}\n\nclass Printer<T> {\n    private ArrayList<T> joblist = new ArrayList<>();\n    T instance;\n    \n    public Printer(){\n        \n    }\n    \n    public void addJob(T t){\n        joblist.add(t);\n    }\n    \n    public T getAnewT(){\n        return instance;\n    }\n}','NullPointerException\n\ninstance in class Printer is never intitialized','Generics',1,NULL),(316,'class Printer<T> {\n    private ArrayList<T> joblist = new ArrayList<>();\n    private T instance;\n    \n    public Printer(){\n        \n    }\n    \n    public Printer(T b){\n        T = b;\n    }\n    \n    public void addJob(T t){\n        joblist.add(t);\n    }\n    \n    public T getAnewT(){\n        return instance;\n    }\n}','in the overloaded constructor T should be instance, remember a Type is an Object not an reference varialb.e','Generics',1,NULL),(317,'class Printer<T extends Number> {\n    private ArrayList<T> joblist = new ArrayList<>();\n    private T instance;\n    \n    public Printer(){\n        \n    }\n    \n    public Printer(T b){\n       instance = b;\n    }\n    \n    public void addJob(T t){\n        joblist.add(t);\n    }\n    \n    public T getAnewT(){\n        return instance;\n    }\n}','a Class will be created with a type that extends number','Generics',1,NULL),(318,'class Printer<? extends Number> {\n    private ArrayList<T> joblist = new ArrayList<>();\n    private T instance;\n    \n    public Printer(){\n        \n    }\n    \n    public Printer(T b){\n       instance = b;\n    }\n    \n    public void addJob(T t){\n        joblist.add(t);\n    }\n    \n    public T getAnewT(){\n        return instance;\n    }\n}','will not compile, a type variable is needed here not a wildcard.\n\nWildcards are never used in generic class definitions','Generics',1,NULL),(319,'class Printer<T super Beagle> {\n    private ArrayList<T> joblist = new ArrayList<>();\n    private T instance;\n    \n    public Printer(){\n        \n    }\n    \n    public Printer(T b){\n       instance = b;\n    }\n    \n    public void addJob(T t){\n        joblist.add(t);\n    }\n    \n    public T getAnewT(){\n        return instance;\n    }\n}\n\nclass Animal{}\nclass Dog extends Animal{}\nclass Beagle extends Dog{}','Does not compile,\n\nyou cant use super when defining a generic class','Generics',1,NULL),(320,'class Printer<T extends Animal> {\n    private ArrayList<T> joblist = new ArrayList<>();\n    private T instance;\n    \n    public Printer(){\n        \n    }\n    \n    public Printer(T b){\n       instance = b;\n    }\n    \n    public void addJob(T t){\n        joblist.add(t);\n    }\n    \n    public void makeSound() {\n        instance.makeSound();\n    }\n    \n    public T getAnewT(){\n        return instance;\n    }\n}\n\nclass Animal{public void makeSound(){\n            System.out.println(\"Sound!\");\n}\n}\nclass Dog extends Animal{}\nclass Beagle extends Dog{}','fine,\n\nyou use extends when creating a generic class to specify bounds','Generics',1,NULL),(321,'public class Hello<T> {\n    public static void main(String[] args){\n        \n        Printer<String> x = new Printer<>();\n\n\n    } \n    public <G> ArrayList<G> makeArrayList(G g){\n        ArrayList<G> genlist = new ArrayList();\n        genlist.add(g);\n        return genlist;\n        \n    }\n}\n\nclass Printer<T extends Animal> {\n    private ArrayList<T> joblist = new ArrayList<>();\n    private T instance;\n    \n    public Printer(){\n        \n    }\n    \n    public Printer(T b){\n       instance = b;\n    }\n    \n    public void addJob(T t){\n        joblist.add(t);\n    }\n    \n    public void makeSound() {\n        instance.makeSound();\n    }\n    \n    public T getAnewT(){\n        return instance;\n    }\n}\n\nclass Animal{public void makeSound(){\n            System.out.println(\"Sound!\");\n}\n}\nclass Dog extends Animal{}\nclass Beagle extends Dog{}','will not compile type argument string is not within bound of class Printer','Generics',1,NULL),(322,'public class Hello<T> {\n    public static void main(String[] args){\n\n        ArrayList x = makeArrayList(Dog d);\n        \n        ArrayList c = new ArrayList<String>();\n\n    } \n    public <G> ArrayList<G> makeArrayList(G g){\n        ArrayList<G> genlist = new ArrayList();\n        genlist.add(g);\n        return genlist;\n        \n    }\n}','will not compile because of (Dog d)','Generics',1,NULL),(323,'public class Hello<T> {\n    public static void main(String[] args){\n        \n        Dog d = new Dog();\n        \n        ArrayList x = makeArrayList(d);\n        \n        ArrayList c = new ArrayList<String>();\n\n    } \n    public static <G> ArrayList<G> makeArrayList(G g){\n        ArrayList<G> genlist = new ArrayList();\n        genlist.add(g);\n        return genlist;\n        \n    }\n}','compiles fine.','Generics',1,NULL),(324,'public class Hello<T> {\n    public static void main(String[] args){\n        \n        Dog d = new Dog();\n        \n        ArrayList x = makeArrayList(d);\n        \n        ArrayList c = new ArrayList<String>();\n        c.add(\"quick string\");\n        \n        x.add(new Dog());\n        \n        Dog a = x.get(0);\n        String stringa = c.get(0);\n \n    } \n    public static <G> ArrayList<G> makeArrayList(G g){\n        ArrayList<G> genlist = new ArrayList();\n        genlist.add(g);\n        return genlist;\n        \n    }\n}','neither Dog a nor stringa will compile. The Declared type of the arraylists is non generic so they return objects\n','Generics',1,NULL),(325,'public class Hello<T> {\n    public static void main(String[] args){\n        \n        Dog d = new Dog();\n        \n        ArrayList<Dog> c = makeArrayList(d);\n \n    } \n    public static <G> ArrayList<G> makeArrayList(G g){\n        ArrayList<G> genlist = new ArrayList();\n        genlist.add(g);\n        return genlist;\n        \n    }\n}','compiles fine','Generics',1,NULL),(326,'public class Hello<T> {\n    public static void main(String[] args){\n        \n        Dog d = new Dog();\n        \n        ArrayList<Dog> c = makeArrayList(d);\n        \n        c.add(new Beagle());\n \n    } \n    public static <G extends Animal> ArrayList<G> makeArrayList(G g){\n        ArrayList<G> genlist = new ArrayList();\n        genlist.add(g);\n        return genlist;\n        \n    }\n}\n\n\nclass Animal{public void makeSound(){\n            System.out.println(\"Sound!\");\n}\n}\nclass Dog extends Animal{}\nclass Beagle extends Dog{}','compiles fine','Generics',1,NULL),(327,'public class Hello<T> {\n    public static void main(String[] args){\n        \n        Dog d = new Dog();\n        \n        ArrayList<Dog> c = makeArrayList(d);\n \n    } \n    public static <? extends Animal> ArrayList<?> makeArrayList(? g){\n        ArrayList<?> genlist = new ArrayList();\n        genlist.add(g);\n        return genlist;\n        \n    }\n}','Compilation fails ? wildcard is not valid here you need a type varialbe istead','Generics',1,NULL),(328,'public class Hello<T> {\n    public static void main(String[] args){\n        \n        Dog d = new Dog();\n        \n        ArrayList<?> c = makeArrayList(d);\n \n    } \n    public static <G extends Animal> ArrayList<G> makeArrayList(G g){\n        ArrayList<G> genlist = new ArrayList();\n        genlist.add(g);\n        return genlist;\n        \n    }\n}','compiles fine, \n\nyou can define ArrayLIsts this way, you wont be able to add anything to it though','Generics',1,NULL),(329,'public class Hello<T> {\n    public static void main(String[] args){\n        \n        Dog d = new Dog();\n        \n        ArrayList<?> c = makeArrayList(d);\n        c.add(new Animal());\n    } \n    public static <G extends Animal> ArrayList<G> makeArrayList(G g){\n        ArrayList<G> genlist = new ArrayList();\n        genlist.add(g);\n        return genlist;\n        \n    }\n}','compilation fails','Generics',1,NULL),(330,'public class Hello<T> {\n    public static void main(String[] args){\n        \n        Dog d = new Dog();\n        \n        ArrayList<H extends Beagle> c = makeArrayList(d);\n        \n    } \n    public static <G extends Animal> ArrayList<G> makeArrayList(G g){\n        ArrayList<G> genlist = new ArrayList();\n        genlist.add(g);\n        return genlist;\n        \n    }\n}','does not compile because of H extends Beagle\n\nshould be ? extends Beagle','Generics',1,NULL),(331,'public class Hello<T> {\n    public static void main(String[] args){\n        \n        Dog d = new Dog();\n        \n        ArrayList<? extends Beagle> c = makeArrayList(d);\n        \n    } \n    public static <G extends Animal> ArrayList<G> makeArrayList(G g){\n        ArrayList<G> genlist = new ArrayList();\n        genlist.add(g);\n        return genlist;\n        \n    }\n}\n\n\nclass Animal{public void makeSound(){\n            System.out.println(\"Sound!\");\n}\n}\nclass Dog extends Animal{}\nclass Beagle extends Dog{}','does not compile Beagle is the lowest type and nothing extends it,\n\nthe only type that would be acceptable here is a Beagle','Generics',1,NULL),(332,'public class Hello<T> {\n    public static void main(String[] args){\n        \n        Dog d = new Dog();\n        \n        ArrayList<? extends Animal> c = makeArrayList(d);\n        \n    } \n    public static <G extends Animal> ArrayList<G> makeArrayList(G g){\n        ArrayList<G> genlist = new ArrayList();\n        genlist.add(g);\n        return genlist;\n        \n    }\n}\n\n\nclass Animal{public void makeSound(){\n            System.out.println(\"Sound!\");\n}\n}\nclass Dog extends Animal{}\nclass Beagle extends Dog{}','compiles fine','Generics',1,NULL),(333,'PECS','\n\nPECS (short for \"Producer extends and Consumer super\") can be explained by : Get and Put Principle\nGet And Put Principle (From Java Generics and Collections)\n\nIt states,\n\n    use an extends wildcard when you only get values out of a structure\n    use a super wildcard when you only put values into a structure\n    and don’t use a wildcard when you both get and put.\n\nLet\'s understand it by example:\n\n1. For Extends Wildcard(get values i.e Producer extends)\n\nHere is a method, that takes a collection of numbers, converts each to a double, and sums them up\n\npublic static double sum(Collection<? extends Number> nums) {\n   double s = 0.0;\n   for (Number num : nums) \n      s += num.doubleValue();\n   return s;\n}\n\nLet\'s call the method :\n\nList<Integer>ints = Arrays.asList(1,2,3);\nassert sum(ints) == 6.0;\nList<Double>doubles = Arrays.asList(2.78,3.14);\nassert sum(doubles) == 5.92;\nList<Number>nums = Arrays.<Number>asList(1,2,2.78,3.14);\nassert sum(nums) == 8.92;\n\nSince, sum() method uses extends, all of the following calls are legal. The first two calls would not be legal if extends was not used.\n\nEXCEPTION : You cannot put anything into a type declared with an extends wildcard—except for the value null, which belongs to every reference type:\n\nList<Integer> ints = new ArrayList<Integer>();\nints.add(1);\nints.add(2);\nList<? extends Number> nums = ints;\nnums.add(null);  // ok\nassert nums.toString().equals(\"[1, 2, null]\");\n\n2. For Super Wildcard(put values i.e Consumer super)\n\nHere is a method, that takes a collection of numbers and an int n, and puts the first n integers, starting from zero, into the collection:\n\npublic static void count(Collection<? super Integer> ints, int n) {\n    for (int i = 0; i < n; i++) ints.add(i);\n}\n\nLet\'s call the method :\n\nList<Integer>ints = new ArrayList<Integer>();\ncount(ints, 5);\nassert ints.toString().equals(\"[0, 1, 2, 3, 4]\");\nList<Number>nums = new ArrayList<Number>();\ncount(nums, 5); nums.add(5.0);\nassert nums.toString().equals(\"[0, 1, 2, 3, 4, 5.0]\");\nList<Object>objs = new ArrayList<Object>();\ncount(objs, 5); objs.add(\"five\");\nassert objs.toString().equals(\"[0, 1, 2, 3, 4, five]\");\n\nSince, count() method uses super, all of the following calls are legal: The last two calls would not be legal if super was not used.\n\nEXCEPTION : you cannot get anything out from a type declared with a super wildcard—except for a value of type Object, which is a supertype of every reference type:\n\nList<Object> objs = Arrays.<Object>asList(1,\"two\");\nList<? super Integer> ints = objs;\nString str = \"\";\nfor (Object obj : ints) str += obj.toString();\nassert str.equals(\"1two\");\n\n3. When both Get and Put, don\'t Use wildcard\n\nWhenever you both put values into and get values out of the same structure, you should not use a wildcard.\n\npublic static double sumCount(Collection<Number> nums, int n) {\n   count(nums, n);\n   return sum(nums);\n}\n\n','Generics',1,NULL),(334,'public class Hello<T> {\n    \n    public static void main(String[] args){\n        \n        Dog d = new Dog();\n        \n        ArrayList<? extends Animal> c = new ArrayList<Beagle>();\n        \n        c.add(new Beagle()); // does not compile\n        c.add(new Beagle()); // does not compile\n        \n        Animal a = c.get(0);\n    } ','PECS\n\nproducers extends consumers super','Generics',1,NULL),(335,'public class Hello<T> {\n    \n    public static void main(String[] args){\n        \n        Dog d = new Dog();\n        \n        ArrayList<? super Beagle> c = new ArrayList<Beagle>();\n        \n        c.add(new Beagle());\n        c.add(new Beagle()); \n        \n        Beagle a = c.get(0);\n    } ','does not compile because of Beagle a = c.get(0);','Generics',1,NULL),(336,'public class Hello<T> {\n    \n    public static void main(String[] args){\n        \n        Dog d = new Dog();\n        \n        ArrayList<Dog> c = makeArrayList(d);\n        \n        c.add(new Beagle());\n        c.add(new Beagle()); \n\n    } \n    public static <G extends Animal> ArrayList<G> makeArrayList(G g){\n        ArrayList<G> genlist = new ArrayList<>();\n        genlist.add(g);\n        return genlist;\n        \n    }\n}','compiles fine','Generics',1,NULL),(337,'public class Hello<T> {\n    \n    public static void main(String[] args){\n        \n        Dog d = new Dog();\n        \n        ArrayList<Dog> c = makeArrayList(new Beagle());\n        \n        c.add(new Beagle());\n        c.add(new Beagle()); \n\n    } \n    public static <G extends Animal> ArrayList<G> makeArrayList(G g){\n        ArrayList<G> genlist = new ArrayList<>();\n        genlist.add(g);\n        return genlist;\n        \n    }\n}','compiles fine','Generics',1,NULL),(338,'public class Hello<T> {\n    \n    public static void main(String[] args){\n        \n        Dog d = new Dog();\n        \n        ArrayList<Dog> c = makeArrayList(new Animal());\n        \n        c.add(new Beagle());\n        c.add(new Beagle()); \n\n    } \n    public static <G extends Animal> ArrayList<G> makeArrayList(G g){\n        ArrayList<G> genlist = new ArrayList<>();\n        genlist.add(g);\n        return genlist;\n        \n    }\n}','comilation fails\n\nArrayLIst<Animal> cannot be applied to ArrayList<Dog>','Generics',1,NULL),(339,'\npublic class Hello<T> {\n    \n    public static void main(String[] args){\n        \n        Dog d = new Dog();\n        \n        ArrayList<?> c = makeArrayList(new Animal());\n        \n\n    } \n    public static <G extends Animal> ArrayList<G> makeArrayList(G g){\n        ArrayList<G> genlist = new ArrayList<>();\n        genlist.add(g);\n        return genlist;\n        \n    }\n}','comiles fine','Generics',1,NULL),(340,'public class Test {\n\n    public class A {}\n\n    public class B extends A {}\n\n    public class C extends B {}\n\n    public void testCoVariance(List<? extends B> myBlist) {\n        B b = new B();\n        C c = new C();\n        myBlist.add(b); // does not compile\n        myBlist.add(c); // does not compile\n        A a = myBlist.get(0); \n    }\n\n    public void testContraVariance(List<? super B> myBlist) {\n        B b = new B();\n        C c = new C();\n        myBlist.add(b);\n        myBlist.add(c);\n        A a = myBlist.get(0); // does not compile\n    }\n}','','Generics',1,NULL),(341,'PECS','\n\nJosh Bloch\'s mnemonic PECS is useful here. It stands for:\n\nProducer extends, Consumer super\n\nThis means that when a parameterized type being passed to a method will produce instances of T (they will be retrieved from it in some way), ? extends T should be used, since any instance of a subclass of T is also a T.\n\nWhen a parameterized type being passed to a method will consume instances of T (they will be passed to it to do something), ? super T should be used because an instance of T can legally be passed to any method that accepts some supertype of T. A Comparator<Number> could be used on a Collection<Integer>, for example. ? extends T would not work, because a Comparator<Integer> could not operate on a Collection<Number>.\n\nEdit: To clarify a little more on get/put (produce/consume):\n\npublic T something();\n       ^\n\nThe above is a method that produces T.\n\npublic void something(T t);\n                      ^\n\nThe above is a method that consumes T.\n\n\"Producer extends, Consumer super\" applies to how the method a parameterized object is being passed to is going to be using that object. In the case of Collections.max(), items will be retrieved from the Collection, so it is a producer. Those items will be passed as arguments to the method on Comparator, so it is a consumer.\n','Generics',1,NULL),(342,'/ Source \n       List<Integer> intList = Arrays.asList(1,2,3);\n       List<Double> doubleList = Arrays.asList(2.78,3.14);\n       List<Number> numList = Arrays.asList(1,2,2.78,3.14,5);\n\n       // Destination\n       List<Integer> intList2 = new ArrayList<>();\n       List<Double> doublesList2 = new ArrayList<>();\n       List<Number> numList2 = new ArrayList<>();\n\n        // Works\n        copyElements1(intList,intList2);         // from int to int\n        copyElements1(doubleList,doublesList2);  // from double to double\n\n\n     static <T> void copyElements1(Collection<T> src, Collection<T> dest) {\n        for(T n : src){\n            dest.add(n);\n         }\n      }\n\n\n     // Let\'s try to copy intList to its supertype\n     copyElements1(intList,numList2); // error, method signature just says \"T\"\n                                      // and here the compiler is given \n                                      // two types: Integer and Number, \n                                      // so which one shall it be?\n\n     // PECS to the rescue!\n     copyElements2(intList,numList2);  // possible\n\n\n\n    // copy Integer (? extends T) to its supertype (Number is super of Integer)\n    private static <T> void copyElements2(Collection<? extends T> src, \n                                          Collection<? super T> dest) {\n        for(T n : src){\n            dest.add(n);\n        }\n    }','','Generics',1,NULL),(343,'public class Hello<T> {\n    \n    public static void main(String[] args){\n        ArrayList<Animal> a;\n        ArrayList<Beagle> b;\n        \n        Hello<String> x = new Hello<>();\n        \n        x.copyColl(a,b);\n        \n\n    } \n    public <G> void copyColl(Collection<G> src, Collection<G> dest){\n        \n        for(G n : src)\n            dest.add(n);\n        \n    }\n}','does not compile Collection<G> is given two different types here\n\nalso a and b were not initialized, that is ok to do with instance variables\nbut not locals \n\nyou could say \n\nArrayList<Animal> a = null;\nand same for b;','Generics',1,NULL),(344,'public class Hello<T> {\n    \n    public static void main(String[] args){\n        ArrayList<Dog> a = new ArrayList<>();\n        ArrayList<Dog> b = new ArrayList<>();\n        \n        Hello<String> x = new Hello<>();\n        \n        x.copyColl(a,b);\n        \n\n    } \n    public <G extends Animal> void copyColl(Collection<G> src, Collection<G> dest){\n        \n        for(G n : src)\n            dest.add(n);\n        \n    }\n}','compiles fine','Generics',1,NULL),(345,'public class Hello<T> {\n    \n    public static void main(String[] args){\n        ArrayList<Dog> a = new ArrayList<>();\n        ArrayList<Dog> b = new ArrayList<>();\n        \n        Hello<String> x = new Hello<>();\n        \n        \n        \n        x.copyColl(a,b);\n        \n\n    } \n    public <G extends Animal> void copyColl(Collection<G> src, Collection<? extends G> dest){\n        \n        for(G n : src)\n            dest.add(n);\n        \n    }\n}','does not compile \n\nyou cant add to a collection declared with wildcard extends','Generics',1,NULL),(346,'public class Hello<T> {\n    \n    public static void main(String[] args){\n        ArrayList<Dog> a = new ArrayList<>();\n        ArrayList<Dog> b = new ArrayList<>();\n        \n        Hello<String> x = new Hello<>();\n        \n        \n        \n        x.copyColl(a,b);\n        \n\n    } \n    public <G extends Animal> void copyColl(Collection<G> src, Collection<? super G> dest){\n        \n        for(G n : src)\n            dest.add(n);\n        \n    }\n}','compiles fine','Generics',1,NULL),(347,'public class Hello<T> {\n    \n    public static void main(String[] args){\n        ArrayList<Animal> a = new ArrayList<>();\n        ArrayList<Dog> b = new ArrayList<>();\n        \n        Hello<String> x = new Hello<>();\n        \n        \n        \n        x.copyColl(a,b);\n        \n\n    } \n    public <G extends Animal> void copyColl(Collection<? extends G> src, Collection<? super G> dest){\n        \n        for(G n : src)\n            dest.add(n);\n        \n    }\n}','will not compiile at x.copyColl','Generics',1,NULL),(348,'public class Hello<T> {\n    \n    public static void main(String[] args){\n        ArrayList<Beagle> a = new ArrayList<>();\n        ArrayList<Animal> b = new ArrayList<>();\n        \n        Hello<String> x = new Hello<>();\n        \n        \n        \n        x.copyColl(a,b);\n        \n\n    } \n    public <G extends Animal> void copyColl(Collection<? extends G> src, Collection<? super G> dest){\n        \n        for(G n : src)\n            dest.add(n);\n        \n    }\n}','compiles fine\n\nyou can easily take a beagle and add it to an Animal array','Generics',1,NULL),(349,'','','blank',1,NULL),(350,'','','blank',1,NULL),(351,'','','blank',1,NULL),(352,'','','blank',1,NULL),(353,'','','blank',1,NULL),(354,'public class Visit extends SimpleFileVisitor<Path> {\n\n	//insert here\n\n   public static void main(String[] args) throws Exception {\n	Visit v = new Visit();\n	Files.walkFileTree(Paths.get(\"/mydir\"),v);\n   }\n}\n\nwhat inserted here will print out the provided directory and all \nsubdirectories ?\n\n\n','public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs)\nthrows IOException {\n	sout( dir );\n	return FileVisitResult.CONTINUE;\n}\n\npublic FileVisitResult postVisitDirectory(Path dir, IOException e)\nthrows IOException {\n	sout( dir );\n	return FileVisitResult.CONTINUE;\n}\n\n**VisitFile is called only for Files and not directories','Input/Output',1,NULL),(355,'','','blank',1,NULL),(356,'','','blank',1,NULL),(357,'class Bird {	\n	{ System.out.println(\"b1\"); }	\n	public Bird() { System.out.println(\"b2\"); }\n}\n\nclass Raptor extends Bird {\n	static {System.out.println(\"r1\"); }\n	public Raptor() { System.out.println(\"r2\"); }\n	{ System.out.println(\"r3\"); }\n	static { System.out.println(\"r4\"); }\n}\npublic class Hello extends Raptor {\n\n    public static void main(String[] args) {\n        System.out.println(\"pre \");\n        new Hello();\n        System.out.println(\"hawk\");\n    }\n}\n		','r1\nr4\npre \nb1\nb2\nr3\nr2\nhawk\n\nstatic init blocks run at class loading time. Instance init blocks run after\nthe constructors call to super()','OOP',1,NULL),(358,'public static void makeFileCreatedOnMonday(Path d) throws IOException{\n        BasicFileAttributes ba = Files.readAttributes(d, BasicFileAttributes.class);\n        Calendar c = Calendar.getInstance();\n        //BasicFileAttributeView baView = Files.readAttributeView(d,BasicFileAttributes.class)\n        //BasicFileAttributeView baView = Files.getBasicAttributeView(d,BasicFileAttributes.class);\n        //BasicFileAttributeView baView = Files.getFileAttributeView(d,BasicFileAttributes.class);\n        //BasicFileAttributeView baView = Files.getFileAttributeView(d,BasicFileAttributeView.class);\n        \n	//void setTimes(FileTime lastModifiedTime,FileTime lastAccessTime,FileTime createTime)\n        \n        Date creationDate = new Date(ba.creationTime().toMillis());\n        c.setTime(creationDate);\n        \n        if(c.get(Calendar.DAY_OF_WEEK) == Calendar.MONDAY){\n            baView.setTimes(null,null,null);\n        } else {\n            //other fields are retained\n            c.set(Calendar.DAY_OF_WEEK,Calendar.MONDAY);\n            FileTime newDay = FileTime.fromMillis(c.getTimeInMillis());\n            \n            baView.setTimes(null,null,newDay);\n        }\n        \n    }\n\nHow do you create a FileAttributeView ?','BasicFileAttributeView baView = Files.getFileAttributeView(d,BasicFileAttributeView.class);','Strings',1,NULL),(359,'','','blank',1,NULL),(360,'psvm(SA){\n	List<Integer> list = new ArrayLIst<>();\n	list.add(5); //autoboxing\n	foo( list );\n}\n\nstatic void foo(List alist) {\n	alist.add(new Dog(\"Charly\"));\n}','compiles with warnings \n\nthe problems will arrise down the road when you get that dog out of a supposedly Integer array. ','Generics',1,NULL),(361,'Generic type information does not exist at runtime - it is for compile-time safetly only.\nMixing generics with legacy code can create compiled code that may throw an excecption at runtime. ','','Generics',1,NULL),(362,'polymorphic assingment rules apply everywhere an assignment can be made for generics,\n\nthe following are not allowed:\n	\n	void foo(List<Animal> alist {  }  //cannot take a List<Dog>\n\n	List<Animal> bar() {  }  // cannot return a List<Dog>','','Generics',1,NULL),(363,'class Animal{\n    public void makeSound() throws InterruptedException {\n            System.out.println(\"Sound!\");\n    }\n}\nclass Dog extends Animal{\n    public void makeSound() throws InterruptedException {\n        System.out.println(\"Bark!\");\n        \n    }\n}\nclass BullDog extends Dog{\n    public void makeSound() throws InterruptedException {\n        System.out.println(\"Grumble!\");\n    }\n}','compiles fine','Generics',1,NULL),(364,'class Animal{\n    public void makeSound() throws InterruptedException {\n            System.out.println(\"Sound!\");\n    }\n}\nclass Dog extends Animal{\n    public void makeSound(){\n        System.out.println(\"Bark!\");\n        \n    }\n}\nclass BullDog extends Dog{\n    public void makeSound() throws InterruptedException {\n        System.out.println(\"Grumble!\");\n    }\n}','BullDog does not compile, Dog\'s makeSound chose not to throw the exception but then when BullDog chose \nto override it didn\'t know that Animal used to throw that exception. ','General',1,NULL),(365,'public class Hello<T> {\n    \n    public static void main(String[] args){\n      Hello<?> x = new Hello<>();\n      \n      List<?> readonlylist = x.dogs();\n      List<?> readonlyanimallist = x.animals();\n        \n\n    } \n    public ArrayList<Animal> animals(){\n        ArrayList<Animal> vetlist = new ArrayList<>();\n        vetlist.add(new Animal());\n        vetlist.add(new BullDog());\n        vetlist.add(new BullDog());\n        vetlist.add(new Dog());\n        vetlist.add(new Animal());\n        \n        return vetlist;\n  \n    }\n    \n    public ArrayList<Dog> dogs(){\n        ArrayList<Animal> vetlist = new ArrayList<>();\n        vetlist.add(new Dog());\n        vetlist.add(new BullDog());\n        vetlist.add(new BullDog());\n        vetlist.add(new Dog());\n        vetlist.add(new Dog());\n\n        return vetlist;\n    }','does not compile because you cannot return an Animal list from a method declaring a return statemnt\nof Dog list','Generics',1,NULL),(366,'Wildcard syntax allows a generic method to accept subtypes or supertypes of the declared type\nof the method argument.\n\n	void addD(List<Dog> d) {  } //can take only <Dog>\n	\n	void addD(List<? extends Dog>) { } //take a <Dog> or <Beagle>','','Generics',1,NULL),(367,'The wildcard keyword \'extends\' is used to mean either \" extends \" or \"implements\" \n\nso in <? extends Dog> Dog can be a class or interface. ','','Generics',1,NULL),(368,'When using a wildcard List<? extends Dog>, the collection can be accessed but not modified','','Generics',1,NULL),(369,'When using a wildcard List<?> any generic type can be assigned to the reference, but for access only\nno modifications.','','Generics',1,NULL),(370,'List<Object> refers only to a List<Object>, while List<?> or List<? extends Object> can hold \nany type of object, but for access only. \n\n','','Generics',1,NULL),(371,'The generic type identifier can be used in class, method, and variable declarations:\n\n	class Foo<t> { }\n	T anInstance;\n	Foo(T aRef) { } // a constructor argument\n	void bar(T aRef) {  }	//method argument\n	T baz() { }	//return type','got it ','Generics',1,NULL),(372,'You can declare a generic method using a type not defined in the class:\n	\n	public <T> void makeList(T t) { }\n\n\n    This is not using T as a return type. This method has a void return type, but to use T within the argument you must declare the <T>\n	which happens before the return type. ','','Generics',1,NULL),(373,'psvm(SA){\n	for(int i = 0; i<= 10; i++) {\n		List<Integer> row = new ArrayList<>();\n		for (int j = 0; j<= 10; j++)\n		         row.add(i*j);\n		table.add(row);\n	}\n	for(List<Integer> row : table)\n		sout(row);\n}\n\ndefine table','List<List<Integer>> table = new ArrayList<>();\n\nList<List<Integer>> table = new ArrayList<List<Integer>>();\n\n	not this:\n		List<List<Integer>> superlist1 = new ArrayList<ArrayList<Integer>>();\n\n	.... incompatible types','Generics',1,NULL),(374,'Which statements are true about comparing two instances of the same class \ngiven that equals() and hashCode() have been properly overriden\n\n1 if the equals() returns true, the hashCode() comparison == might return false\n\n2 if the equals() returns false, the hashCode() comparison == might return true\n\n3 if the hashCode() comparison == returns true, the equals() method must return true\n\n4 if the hashCode() comparison == returns true, the equals() method might return true\n\n5 if the hashCode() comparison != returns true, the equals() method might return true','2 is true because often two dissiimilar objects can return the same hashcode value.\n\n4 is true because if the hashCode() comparison == returns true, might or might not be equal. \n\n3 is incorrect because often two dissimilar objects can return the same hashcode value. \n\n1 and 5 are a negation of the equals and hashCode() contract','Generics',1,NULL),(375,'IF TWO OBJECTS ARE EQUAL ACCORDING TO THE EQUALS(OBJECT) METHOD, THE CALLING THE HASHCODE()\nMETHOD ON EACH OF THE TWO OBJECT MUST PRODUCE THE SAME INTEGER RESULT. ','got it\n','Generics',1,NULL),(376,'It is not required that if two object are unequal according to the dquals method, the calling the hashCode()\non each of the two objects must produce distinct integer results. ','','Generics',1,NULL),(377,'public static void before() {\n	Set set = new TreeSet();\n	set.add(\"2\");\n	set.add(3);\n	set.add(\"1);\n	Iterator it = set.iterator();\n		while(it.hasNext() )\n	sout( it.next() );\n}\n','ClassCastException','Generics',1,NULL),(378,'interface Hungry<E> { void munch(E x); }\ninterface Carnivore<E extends Animal> extends Hungry<E> { }\ninterface Herbivore<E extends Plant> extends Hungry<E> { }\nabstract class Plant { }\nabstract class Animal { }\nclass Grass extends Plant { }\nclass Sheep extends Animal implements Herbivore<Sheep> {\n    public void munch (Sheep x){ }\n}\nclass Wolf extends Animal implements Carnivore<Sheep> {\n    public void munch(Sheep x) { }\n}\n\nwhat can you change to make this compile','Change Herbivore interface to\n	\n	 interface Herbivore<E extends Animal> extends Hungry<E> { }','Generics',1,NULL),(379,'interface Hungry<E> { void munch(E x); }\ninterface Carnivore<E extends Animal> extends Hungry<E> { }\ninterface Herbivore<E extends Plant> extends Hungry<E> { }\nabstract class Plant { }\nabstract class Animal { }\nclass Grass extends Plant { }\nclass Sheep extends Animal implements Herbivore<Plant> {\n    public void munch (Sheep x){ }\n}\nclass Wolf extends Animal implements Carnivore<Sheep> {\n    public void munch(Sheep x) { }\n}','Sheep does not compile,\n\n	Sheep is not abstract and does not override abstract method munch(Plant) in Hungry','Generics',1,NULL),(380,'public class Hello<T> {\n  public static void main(String[] args){\n      Sheep bella = new Sheep();\n      \n      bella.munch(new Grass());\n      \n  }\n      \n}\n\ninterface Hungry<E> { void munch(E x); }\ninterface Carnivore<E extends Animal> extends Hungry<E> { }\ninterface Herbivore<E extends Plant> extends Hungry<E> { }\nabstract class Plant { }\nabstract class Animal { }\nclass Grass extends Plant { }\nclass Sheep extends Animal implements Herbivore<Plant> {\n    public void munch (Plant x){ }\n}\nclass Wolf extends Animal implements Carnivore<Sheep> {\n    public void munch(Sheep x) { }\n}','compiles and runs no problem','Generics',1,NULL),(381,'public class Hello<T> {\n\n   public static void main(String[] args){\n\n    Dog d = new Dog();\n\n    ArrayList<? super Beagle> c = makeArrayList(d);\n\n    c.add(new Beagle());\n    c.add(new Beagle());\n    c.add(new Dog());    \n  } \n\n  public static <G extends Animal> ArrayList<G> makeArrayList(G g){\n    ArrayList<G> genlist = new ArrayList<>();\n    genlist.add(g);\n    return genlist;\n\n }\n}\n\n\nclass Animal{public void makeSound(){\n        System.out.println(\"Sound!\");\n }\n}   \n class Dog extends Animal{}\nclass Beagle extends Dog{}','The variable c of type ArrayList<? super Beagle> could possibly hold an instance of \nArrayList<Beagle>, ArrayList<Dog>, ArrayList<Animal>, or ArrayList<Object>.\n If it happened to be set to an ArrayList<Beagle>, it would violate the generic type to add a Dog to it.\n The compiler can\'t track what you actually assign to the ArrayList<? super Beagle> variable over the course of the program, \nso it assumes the worst and prevents the possible type safety violation. ','Generics',1,NULL),(382,'Let\'s test your understanding of generics. Is the following code snippet legal?\n\nList<String> ls = new ArrayList<String>(); // 1\nList<Object> lo = ls; // 2 \n\nLine 1 is certainly legal. The trickier part of the question is line 2. This boils down to the question: is a List of String a List of Object. Most people instinctively answer, \"Sure!\"\n\nWell, take a look at the next few lines:\n\nlo.add(new Object()); // 3\nString s = ls.get(0); // 4: Attempts to assign an Object to a String!\n\nHere we\'ve aliased ls and lo. Accessing ls, a list of String, through the alias lo, we can insert arbitrary objects into it. As a result ls does not hold just Strings anymore, and when we try and get something out of it, we get a rude surprise.\n\nThe Java compiler will prevent this from happening of course. Line 2 will cause a compile time error.\n\nIn general, if Foo is a subtype (subclass or subinterface) of Bar, and G is some generic type declaration, it is not the case that G<Foo> is a subtype of G<Bar>. This is probably the hardest thing you need to learn about generics, because it goes against our deeply held intuitions.\n\nWe should not assume that collections don\'t change. Our instinct may lead us to think of these things as immutable.','For example, if the department of motor vehicles supplies a list of drivers to the census bureau, this seems reasonable. We think that a List<Driver> is a List<Person>, assuming that Driver is a subtype of Person. In fact, what is being passed is a copy of the registry of drivers. Otherwise, the census bureau could add new people who are not drivers into the list, corrupting the DMV\'s records.','Generics',1,NULL),(383,'static void fromArrayToCollection(Object[] a, Collection<?> c) {\n    for (Object o : a) { \n        c.add(o); // compile-time error\n    }\n}\n\nfix this with a generic method....','static <T> void fromArrayToCollection(T[] a, Collection<T> c) {\n    for (T o : a) {\n        c.add(o); // Correct\n    }\n}','Generics',1,NULL),(384,'\n\nNo, a List<Dog> is not a List<Animal>. Consider what you can do with a List<Animal> - you can add any animal to it... including a cat. Now, can you logically add a cat to a litter of puppies? Absolutely not.\n\n// Illegal code - because otherwise life would be Bad\nList<Dog> dogs = new ArrayList<Dog>(); // ArrayList implements List\nList<Animal> animals = dogs; // Awooga awooga\nanimals.add(new Cat());\nDog dog = dogs.get(0); // This should be safe, right?\n\nSuddenly you have a very confused cat.\n\nNow, you can\'t add a Cat to a List<? extends Animal> because you don\'t know it\'s a List<Cat>. \nYou can retrieve a value and know that it will be an Animal, but you can\'t add arbitrary animals. \nThe reverse is true for List<? super Animal> - in that case you can add an Animal to it safely, but you don\'t know anything about what might be retrieved from it, because it could be a List<Object>.\n','','Generics',1,NULL),(385,'public class Hello<T> {\n  public static void main(String[] args){\n      Sheep bella = new Sheep();\n      \n  }\n      \n}\n\ninterface Hungry<E> { void munch(E x); }\ninterface Carnivore<E extends Animal> extends Hungry<E> { }\ninterface Herbivore<Plant> extends Hungry<Plant> { }\nabstract class Plant { }\nabstract class Animal { }\nclass Grass extends Plant { }\nclass Sheep extends Animal implements Herbivore<Grass> {\n    public void munch (Grass x){ }\n}\nclass Wolf extends Animal implements Carnivore<Sheep> {\n    public void munch(Sheep x) { }\n}','compiles fine...\n\nHerbivore<Plant> extends Hungry<Plant> works because the type is a parameter just like the formal \nparameters. So it is not necessary that a subinterface has the same parameters as long as its indicated that\nit does in fact take a type parameter. \n\nIn a nutshell, generics enable types (classes and interfaces) to be parameters when defining classes, interfaces and methods. Much like the more familiar formal parameters used in method declarations, type parameters provide a way for you to re-use the same code with different inputs. The difference is that the inputs to formal parameters are values, while the inputs to type parameters are types.\n\nits the same reason why List<E>, an interface, has to be the same as = new ArrayList<E> but not the \nsame as all other Lists\n\nList<String> list = new ArrayList<String>();\n	\n	ArrayList implements List just like Herbivore extends Hungry.','Generics',1,NULL),(386,'Raw Types\n\nA raw type is the name of a generic class or interface without any type arguments. For example, given the generic Box class:\n\npublic class Box<T> {\n    public void set(T t) { /* ... */ }\n    // ...\n}\n\nTo create a parameterized type of Box<T>, you supply an actual type argument for the formal type parameter T:\n\nBox<Integer> intBox = new Box<>();\n\nIf the actual type argument is omitted, you create a raw type of Box<T>:\n\nBox rawBox = new Box();\n\nTherefore, Box is the raw type of the generic type Box<T>. However, a non-generic class or interface type is not a raw type.\n\nRaw types show up in legacy code because lots of API classes (such as the Collections classes) were not generic prior to JDK 5.0. When using raw types, you essentially get pre-generics behavior — a Box gives you Objects. For backward compatibility, assigning a parameterized type to its raw type is allowed:\n\nBox<String> stringBox = new Box<>();\nBox rawBox = stringBox;               // OK\n\nBut if you assign a raw type to a parameterized type, you get a warning:\n\nBox rawBox = new Box();           // rawBox is a raw type of Box<T>\nBox<Integer> intBox = rawBox;     // warning: unchecked conversion\n\nYou also get a warning if you use a raw type to invoke generic methods defined in the corresponding generic type:\n\nBox<String> stringBox = new Box<>();\nBox rawBox = stringBox;\nrawBox.set(8);  // warning: unchecked invocation to set(T)\n\nThe warning shows that raw types bypass generic type checks, deferring the catch of unsafe code to runtime. Therefore, you should avoid using raw types.','','Generics',1,NULL),(387,'class Driver<E>{\n    \n}\nabstract class Auto{}\nclass Truck extends Auto{}\nclass Car extends Auto{}\n\npublic class Hello<T> {\n  public static void main(String[] args){\n      Driver<Truck> truckdriver = new Driver<>();\n      Driver untypeddriver = truckdriver;\n      \n      List biglist = new ArrayList<String>();\n      \n  }\n      \n}','compiles fine \n\ngeneric typed objects can be assigned to raw types.','Generics',1,NULL),(388,'public class Hello<T> {\n  public static void main(String[] args){\n      \n      List biglist = new ArrayList<String>();\n      \n      biglist.add(8);\n      biglist.add(\"bigdick\");\n      \n  }\n      \n}','compiles fine, raw type reerences that are assinged to typed objects still take objects.','Generics',1,NULL),(389,'public class Hello<T> {\n  public static void main(String[] args){\n      Driver<Truck> truckdriver = new Driver<>();\n      Driver untypeddriver = truckdriver;\n      \n      List biglist = new ArrayList<Driver<Truck>>();\n      \n      biglist.add(8);\n      biglist.add(\"bigdick\");\n      \n  }\n      \n}','compiles fine,  but you can still add anything to biglist','Generics',1,NULL),(390,'public class Hello {\n  public static void main(String[] args){\n      Driver<Truck> truckdriver = new Driver();\n      \n      testmethod(new Driver<Truck>());   \n  }\n  \n  public static void testmethod(Object x){\n      // do something\n  }\n      \n}','fine','Generics',1,NULL),(391,'Generic Classes and Subtyping',' You can subtype a generic class or interface by extending or implementing it. The relationship between the type parameters of one class or interface and the type parameters of another are determined by the extends and implements clauses.\n\nUsing the Collections classes as an example, ArrayList<E> implements List<E>, and List<E> extends Collection<E>. So ArrayList<String> is a subtype of List<String>, which is a subtype of Collection<String>. So long as you do not vary the type argument, the subtyping relationship is preserved between the types.\ndiagram showing a sample collections hierarchy: ArrayList<String> is a subtype of List<String>, which is a subtype of Collection<String>.\nA sample Collections hierarchy\n\nNow imagine we want to define our own list interface, PayloadList, that associates an optional value of generic type P with each element. Its declaration might look like:\n\ninterface PayloadList<E,P> extends List<E> {\n  void setPayload(int index, P val);\n  ...\n}\n\nThe following parameterizations of PayloadList are subtypes of List<String>:\n\n    PayloadList<String,String>\n    PayloadList<String,Integer>\n    PayloadList<String,Exception>\n','Generics',1,NULL),(392,'Generics, Inheritance, and Subtypes',' As you already know, it is possible to assign an object of one type to an object of another type provided that the types are compatible. For example, you can assign an Integer to an Object, since Object is one of Integer\'s supertypes:\n\nObject someObject = new Object();\nInteger someInteger = new Integer(10);\nsomeObject = someInteger;   // OK\n\nIn object-oriented terminology, this is called an \"is a\" relationship. Since an Integer is a kind of Object, the assignment is allowed. But Integer is also a kind of Number, so the following code is valid as well:\n\npublic void someMethod(Number n) { /* ... */ }\n\nsomeMethod(new Integer(10));   // OK\nsomeMethod(new Double(10.1));   // OK\n\nThe same is also true with generics. You can perform a generic type invocation, passing Number as its type argument, and any subsequent invocation of add will be allowed if the argument is compatible with Number:\n\nBox<Number> box = new Box<Number>();\nbox.add(new Integer(10));   // OK\nbox.add(new Double(10.1));  // OK\n\nNow consider the following method:\n\npublic void boxTest(Box<Number> n) { /* ... */ }\n\nWhat type of argument does it accept? By looking at its signature, you can see that it accepts a single argument whose type is Box<Number>. But what does that mean? Are you allowed to pass in Box<Integer> or Box<Double>, as you might expect? The answer is \"no\", because Box<Integer> and Box<Double> are not subtypes of Box<Number>.\n\nThis is a common misunderstanding when it comes to programming with generics, but it is an important concept to learn.\ndiagram showing that Box<Integer> is not a subtype of Box<Number>\nBox<Integer> is not a subtype of Box<Number> even though Integer is a subtype of Number.\nNote: Given two concrete types A and B (for example, Number and Integer), MyClass<A> has no relationship to MyClass<B>, regardless of whether or not A and B are related. The common parent of MyClass<A> and MyClass<B> is Object.','Generics',1,NULL),(393,'List<? extends Integer> intList = new ArrayList<>();\nList<? extends Number>  numList = intList;  // OK. List<? extends Integer> is a subtype of List<? extends Number>','','Generics',1,NULL),(394,'interface Hungry<E> { void munch(E x); }\ninterface Carnivore<E extends Animal> extends Hungry<E> { }\n\ninterface Herbivore<Plant> extends Hungry<Plant> { }\n\n\ninterface Pineavore<Pine> extends Herbivore<Plant> { }\n\n\n\nclass Panda implements Herbivore<Pine>{  \n    void munch(Pine x){\n            System.out.println(\"eat pines\");\n    };\n} \nclass Chamelion implements Herbivore<Flowers>{ \n    public void munch(Flowers x){ } \n}','compilation fails,\n\ninterface methods are implicityl public abstract so when you overid them like munch in Panda you have to say\npublic . ','Generics',1,NULL),(395,'interface Hungry<E> { void munch(E x); }\n\nclass Driver<E> implements Hungry<T>{\n    public void munch(T food){\n        \n    }\n    \n}','will not compile, when you implement a generic interface, you must provide a type similarly you cannot say\nnew Thing<E>();','Generics',1,NULL),(396,'interface Hungry<E> { void munch(E x); }\n\ninterface Herbivore<Grass> extends Hungry<Plant> { }\n\nclass Panda implements Herbivore<Grass>{  \n        public void munch(Grass x){\n            System.out.println(\"eat pines\");\n    };\n} \n\nabstract class Animal { }\nabstract class Plant { }\nclass Grass extends Plant { }','Panda does not compile \n\ndoes not override abstract method munch(Plant) in class Hungry.\n\n	','Generics',1,NULL),(397,'Which collection class allows you to grow or shrink its size and provide indexed access to its elements,\nbut whose methods are not synhcronized ?','ArrayList','Generics',1,NULL),(398,'public static <E extends Number> List<E> process(List<E> nums)\n\n// declare input and output\n\noutput = process(input);\n\n','1 ArrayList<Integer> input = null;\n   List<Integer> output = null;\n\n2 List<Number> input = null;\n    List<Number> output = null\n\n3  List<Integer> input = null\n   List<Integer> output = null;\n\n\nThe return type is List so the output has to be a list it cant be arraylist. \nwhatever the input is thats what the output will be so input and output have to be the same type\nand the type has to be something that extends Number','Generics',1,NULL),(399,'public class Hello {\n  public static void main(String[] args){\n      PriorityQueue<String> pq = new PriorityQueue<String>();\n      pq.add(\"2\");\n      pq.add(\"4\");\n      System.out.println(pq.peek());\n      pq.offer(\"1\");\n      pq.add(\"3\");\n      pq.remove(\"1\");\n      System.out.println(pq.poll());\n      if(pq.remove(\"2\")) System.out.println(pq.poll());\n      System.out.println(pq.poll() + \" \" + pq.peek());\n  }\n   \n}','2\n2\n3 4\n\nfor the sake of the exam add and offer both add to naturally sorted collections \nso here the order becomes the natural order. \n\neven strings get sorted numerically.\n\n','Generics',1,NULL),(400,'public class Hello {\n  public static void main(String[] args){\n      PriorityQueue<String> pq = new PriorityQueue<String>();\n      pq.add(\"2\");\n      pq.add(\"4\");\n\n      pq.offer(\"1\");\n      pq.add(\"3\");\n      \n      pq.add(\"2\");\n      pq.offer(\"5\");\n      \n      pq.add(\"67\");\n      pq.add(\"7\");\n      \n      for(String x : pq)\n          System.out.print(x+\" \");\n      \n      System.out.println(\"\");\n      \n      for(int x = 0; x <8; x++)\n          System.out.print(pq.poll()+\" \");\n\n  }\n   \n}','1 2 2 4 3 5 67 7 \n1 2 2 3 4 5 67 7\n\nString only looks at the first charater so 67 is the same as 6','Generics',1,NULL),(401,'public class Hello {\n  public static void main(String[] args){\n      LinkedHashSet<Turtle> t = new LinkedHashSet<>();\n      t.add(new Turtle(1)); t.add( new Turtle(2)); t.add(new Turtle(1));\n      t.add(new Turtle(1)); t.add( new Turtle(2)); t.add(new Turtle(1));\n      t.add(new Turtle(1)); t.add(new Turtle(1)); t.add(new Turtle(1));\n      t.add(new Turtle(1)); t.add(new Turtle(1)); t.add(new Turtle(1));\n      \n      System.out.println(t.size());\n\n  }\n   \n}\n\ninterface Hungry<E> { void munch(E x); }\nabstract class Animal { }\nabstract class Plant { }\nclass Grass extends Plant { }\n\nclass Turtle {\n    int size;\n    public Turtle(int z){\n        size = z;\n    }\n    \n    public boolean equals(Object o){\n        return (this.size == ((Turtle)o).size);\n    }\n    \n    public int hashCode() { return size/5; }\n}','2\n\nthe size is two when hashCode is implementd this imp. will place all turtles with size 1 in the same bucket\n\nsize() counts the buckets.\n\nif hashCode was not implemented then every entry would go into its own bucket and the size would be\n12\n\n','Generics',1,NULL),(402,'class Grass extends Plant { }\n\npublic class Hello {\n  public static void main(String[] args){\n     TreeSet<Grass> grassset = new TreeSet<>();\n     grassset.add(new Grass());\n\n  }\n   \n}','classcastexception','Generics',1,NULL),(403,'public class GeoCache {\n	public static void main(String[ ]args) {\n		String[] s = {\"map\",\"pen\",\"marble\",\"key\"};\n		Othello o = new Othello();\n		Arrays.sort(s,o);\n		for(String s2: s) sout(s2+\" \");\n		sout( Arrays.binarySearch(s,\"map\");\n	}\n\n	static class Othello implements Comparator<String> {\n		public int compare(String a, String b) { return b.compareTo(a);l }\n	}\n}\n		','The output will contain a -1\n\n\"pen marble map key\" \n\n.binarySearch has to be invoked with the same Comparator that created it. \n	here it doesn\'t know how the array is sorted so it gives insertion point','Collections',1,NULL),(404,'public class ArrayList<E> extends AbstractList<E>\n         implements List<E>, RandomAccess, Cloneable, java.io.Serializable {\n    ...\n    public Iterator<E> iterator() {\n         return new Itr();\n    }\n\n    private class Itr implements Iterator<E> {\n    ...\n    }\n\n    public ListIterator<E> listIterator() {\n         return new ListItr(0);\n    }\n\n    private class ListItr extends Itr implements ListIterator<E> {\n    ...\n    }\n}','One good usage of inner classes that comes into my mind is in java.util.ArrayList that hides its iterators implementations into private inner classes. You can\'t create them except by invoking iterator() or listIterator() on the list object.\n\nThis way the Iterator and ListIterator implementations for ArrayList are grouped with their related class and methods for enhanced readability (the implementations are pretty short), but hidden from others.\n\nThey can\'t be declared static as they need access to their enclosing instance object.','General',1,NULL),(405,'public class Hello {\n    private int secretnum = 7;\n    \n  public static void main(String[] args){\n     Hello h = new Hello();\n     h.createInner();\n\n  }\n  \n  public void createInner(){\n      Hello.Inner a = new Hello.Inner();\n      a.foo(); a.seeOuter();\n  }\n  \n  \n  class Inner {\n      public void seeOuter(){\n          System.out.println(secretnum);\n      }\n      \n      void foo(){\n          System.out.println(\"Foo\");\n      }\n  }\n   \n}','foo 7\n\ncompiles fine, you need the outer classes reference for a regular inner class\n\nthe inner class can be created as such from within the enclosing class. \n\ncould also be Inner a = new Inner();','Inner Classes',1,NULL),(406,'public class Hello {\n    private int secretnum = 7;\n    \n  public static void main(String[] args){\n     Hello h = new Hello();\n     h.createInner();\n\n  }\n  \n  public void createInner(){\n      Hello.Inner a = new Hello.Inner();\n      a.foo(); a.seeOuter();\n  }\n  \n  \n  class Inner {\n      private static int verysecret = 8;\n      \n      public void seeOuter(){\n          System.out.println(secretnum);\n      }\n      \n      void foo(){\n          System.out.println(\"Foo\");\n      }\n  }','WNC,\n\nNo static declarations are allowed in regular inner classes unless they \nare final.\n\nThe creation of a is legal though redundant, it could have been:\n\n	Inner a = new Inner();\n','Inner Classes',1,NULL),(407,'public class Hello {\n    private int secretnum = 7;\n    \n  public static void main(String[] args){\n     Hello h = new Hello();\n     h.createInner();\n\n  }\n  \n  public void createInner(){\n      Hello.Inner a = new Hello.Inner();\n      a.foo(); a.seeOuter();\n  }\n  \n  \n  class Inner {\n      private static final int verysecret = 8;\n      \n      public void seeOuter(){\n          System.out.println(secretnum);\n      }\n      \n      void foo(){\n          System.out.println(\"Foo\");\n      }\n  }\n   \n}','compiles fine, if an inner class is going to have static member it has to be final','Inner Classes',1,NULL),(408,'public class sequence {\n	psvm(sa){\n		ArrayList<String> list = new ArrayList<>();\n		list.add(\"apple\");\n		list.add(\"organe\");\n		list.add(\"plum\");\n		list.add(1,\"carrot\");\n		sout( list );\n	}\n}','apple carrot orange plum\n\nwith arraylist you can add(int index, object elemetn) to a specific index','Collections',1,NULL),(409,'public class Hello {\n    private int secretnum = 7;\n    \n    public static void main(String[] args){\n        Inner in = new Inner();\n\n    }\n  \n     class Inner {\n        private static final int verysecret = 8;\n        void foo(){\n          System.out.println(\"Foo\");\n        } \n  }\n   \n}','will not compile,\n\ninner classes are the same as class instance variables so naturally you cannot access \nthem from a static context. ','Inner Classes',1,NULL),(410,'public class Hello {\n    private int secretnum = 7;\n    \n    public static void main(String[] args){\n        Hello h = new Hello();\n        Hello.Inner in = h.new Inner();\n\n    }\n  \n     class Inner {\n        private static final int verysecret = 8;\n        void foo(){\n          System.out.println(\"Foo\");\n        } \n  }\n   \n}','compiles fine','Inner Classes',1,NULL),(411,'public class Hello {\n    private int secretnum = 7;\n    private static Inner inner;\n    \n    public static void main(String[] args){\n        Hello h = new Hello();\n        Hello.Inner in = h.new Inner();\n        \n        Hello.Inner in2 = h.new Inner();\n        \n        Hello.Inner in3 = new Hello().new Inner();\n        \n        inner = h.new Inner();\n        \n        //Inner a = new Inner(); this would not work\n        \n\n    }\n    \n    public void instancemaker(){\n        Inner a = new Inner();\n        System.out.println(a.verysecret);\n    }\n  \n     class Inner {\n        private static final int verysecret = 8;\n        \n        public void Inner(int x){\n            \n        }\n        void foo(){\n          System.out.println(\"Foo\");\n        } \n  }\n   \n}','When instantiating from a static method You have to provide the Outer class name\n\nthe inner class is just a like an instance member. \n\nbut in the instance method its easy to create the inner class normally. \n\nits the same to create a new inner class in the static method as it is from another class.\n\n\nThis was one is also confusing because it has a mistakenly named method \nthat looks like a constructor. But its not. ','Inner Classes',1,NULL),(412,'public class Hello {\n    private int secretnum = 7;\n    public static void main(String[] args) {}\n    class Inner {  private static final int verysecret = 8; }\n}\n\nclass Dog extends Hello.Inner {}\n\nchange this code so it compiles, and creates a class that extends Hello.Inner','public class Hello {\n    private int secretnum = 7;\n    public static void main(String[] args) {}\n    class Inner {  private static final int verysecret = 8; }\n}\n\nclass Dog extends Hello { class Innerdog extends Inner{ } }','Inner Classes',1,NULL),(413,'public class Hello {\n    private int secretnum = 7;\n    public static void main(String[] args) {}\n    class Inner {  private static final int verysecret = 8; }\n}\n\nclass Dog extends Hello{ class Inner extends Inner { } }\n\nthis is illegal what could make it legal ?','class Dog extends Hello{ class Inner extends Hello.Inner { } }','Inner Classes',1,NULL),(414,'public Iterator<String> iterator() {\n    return new Iterator<String>() {\n\n      private int index;\n\n      public boolean hasNext() {\n        return index < size();\n      }\n\n      public String next() {\n\n        if (hasNext()) {\n          return getToken(index++);\n        }\n        else {\n          throw new NoSuchElementException();\n        }\n      }\n\n      public void remove() {\n        throw new UnsupportedOperationException();\n      }\n\n    };\n  }','good example of an anonymous inner class from opennlp','Inner Classes',1,NULL),(415,'public Iterator<String> iterator() {\n    return new Iterator<String>() {\n\n      private int index;\n\n      public boolean hasNext() {\n        return index < size();\n      }\n\n      public String next() {\n\n        if (hasNext()) {\n          return getToken(index++);\n        }\n        else {\n          throw new NoSuchElementException();\n        }\n      }\n\n      public void remove() {\n        throw new UnsupportedOperationException();\n      }\n\n    };\n  }','good example of anonymous inner class','Inner Classes',1,NULL),(416,'public static Dictionary parseOneEntryPerLine(Reader in) throws IOException {\n    BufferedReader lineReader = new BufferedReader(in);\n\n    Dictionary dictionary = new Dictionary();\n\n    String line;\n\n    while ((line = lineReader.readLine()) != null) {\n      StringTokenizer whiteSpaceTokenizer = new StringTokenizer(line, \" \");\n\n      String[] tokens = new String[whiteSpaceTokenizer.countTokens()];\n\n      if (tokens.length > 0) {\n        int tokenIndex = 0;\n        while (whiteSpaceTokenizer.hasMoreTokens()) {\n          tokens[tokenIndex++] = whiteSpaceTokenizer.nextToken();\n        }\n\n        dictionary.put(new StringList(tokens));\n      }\n    }\n\n    return dictionary;\n  }','fine\ngood example of;\nStringTokenizer\nBufferedReader\n\n','General',1,NULL),(417,'public static Dictionary parseOneEntryPerLine(Reader in)  {\n    BufferedReader lineReader = new BufferedReader(in);\n\n    Dictionary dictionary = new Dictionary();\n\n    String line;\n\n    while ((line = lineReader.readLine()) != null) {\n      StringTokenizer whiteSpaceTokenizer = new StringTokenizer(line, \" \");\n\n      String[] tokens = new String[whiteSpaceTokenizer.countTokens()];\n\n      if (tokens.length > 0) {\n        int tokenIndex = 0;\n        while (whiteSpaceTokenizer.hasMoreTokens()) {\n          tokens[tokenIndex++] = whiteSpaceTokenizer.nextToken();\n        }\n\n        dictionary.put(new StringList(tokens));\n      }\n    }\n\n    return dictionary;\n  }','will not compile \nreadLine() method throws IOException\n\nmust be caught or thrown!','Input/Output',1,NULL),(418,'public class Hello {\n    private int secretnum = 7;\n    public static void main(String[] args) {\n        Map<Integer,String> hellomap = new HashMap();\n        hellomap.put(1,\"Bell\");\n        hellomap.put(3,\"Whistle\");\n        hellomap.put(5,\"Nic\");\n        \n        for(Entry<Integer,String> x : hellomap.entrySet()){\n            System.out.println(x);\n        }\n    \n    }\n    public class Inner {  private static final int verysecret = 8; }\n}','1=Bell\n3=Whistle\n5=Nic\n\ninner classes can have static members only if they are final','Inner Classes',1,NULL),(419,'public class Hello {\n    private final static int SIZE = 25;\n    private int[] array = new int[SIZE];\n    \n    public Hello(){\n        for(int i = 0; i<SIZE; i++){\n            array[i] = i;\n        }\n    }\n    \n    public void printEven(){\n        \n    }\n    \n    interface DSIterator extends java.util.Iterator<Integer> { }\n    \n    private class EvenIterator implements DSIterator{\n        \n    }\n    \n\n    public static void main(String[] args) {\n\n    \n    }\n\n}','EvenIterator will not compile is not abstract and does not impelemnt next() in Iterator()\n\nThis shows that since DSIterator extends Iterator the first concrete class has to be the one to \nimplement the interfaces methods. ','General',1,NULL),(420,'public class Hello {\n    private final static int SIZE = 100;\n    private int[] array = new int[SIZE];\n    \n    public Hello(){\n        for(int i = 0; i<SIZE; i++){\n            array[i] = i;\n        }\n    }\n    \n    public void print(){\n        ThirdIterator it = new ThirdIterator();\n        while(it.hasNext()){\n            System.out.print(it.next() +\" \");\n        }\n        \n    }\n    \n    interface DSIterator extends java.util.Iterator<Integer> { }\n    \n    private class ThirdIterator implements DSIterator{\n        private int nextIndex = 0;\n        \n        public boolean hasNext(){\n            return (nextIndex <= SIZE - 1);\n        }\n        \n        public Integer next(){\n            Integer retValue = Integer.valueOf(array[nextIndex]);\n            \n            nextIndex += 3;\n            return retValue;\n            \n        }\n        \n    }\n    \n\n    public static void main(String[] args) {\n        print();\n    \n    }\n\n}','will not compile print() cannot be called from a static context.','General',1,NULL),(421,'public class Hello {\n    private final static int SIZE = 100;\n    private int[] array = new int[SIZE];\n    \n    public Hello(){\n        for(int i = 0; i<SIZE; i++){\n            array[i] = i;\n        }\n    }\n    \n    public void print(){\n        ThirdIterator it = new ThirdIterator();\n        while(it.hasNext()){\n            Object i = it.next();\n            //System.out.print(it.next() +\" \");\n        }\n        \n    }\n    \n    interface DSIterator extends java.util.Iterator { }\n    \n    private class ThirdIterator implements DSIterator{\n        private int nextIndex = 0;\n        \n        public boolean hasNext(){\n            return (nextIndex <= SIZE - 1);\n        }\n        \n        public Integer next(){\n            Integer retValue = Integer.valueOf(array[nextIndex]);\n            \n            nextIndex += 3;\n            return retValue;\n            \n        }\n        \n    }\n    \n\n    public static void main(String[] args) {\n        Hello h = new Hello();\n        h.print();\n    \n    }\n\n}','0 3 6 9 12 15 18 21 24 27 30 33 36 39 42 45 48 51 54 57 60 63 66 69 72 75 78 81 84 87 90 93 96 99','General',1,NULL),(422,'public class Hello {\n    private final static int SIZE;\n    private int[] array;\n    \n    public Hello(int size){\n        this.SIZE = size;\n        \n        array = new int[SIZE];\n        \n        for(int i = 0; i<SIZE; i++){\n            array[i] = i;\n        }\n    }\n}','if a final variable is static it has be intitialized right away.\n\nWhere a final instance varialbe must be intitialized at some point either in the constructor or upon creation.\n\n','General',1,NULL),(423,'public class Hello {\n    private final int SIZE;\n    private int[] array;\n    \n    public void print(){\n        ThirdIterator it = new ThirdIterator();\n        while(it.hasNext()){\n            Integer i = it.next();\n            //System.out.print(it.next() +\" \");\n        }\n        \n    }\n\n}','Will not compile \n\nfinal variable SIZE is never initialized in default constructor or otherwise and this is a compilererror','General',1,NULL),(424,'public class Hello {\n    private final int SIZE;\n    private int[] array;\n    \n    interface DSIterator extends java.util.Iterator<Integer> { }\n    \n    private class ThirdIterator implements DSIterator{\n        private int nextIndex = 0;\n        public ThirdIterator(){\n            SIZE = 100;\n            for(int ix=0; ix<SIZE; ix++){\n                array[ix] = ix;\n            }\n        }\n        \n        public boolean hasNext(){\n            return (nextIndex <= SIZE - 1);\n        }\n        \n        public Integer next(){\n            Integer retValue = Integer.valueOf(array[nextIndex]);\n            \n            nextIndex += 3;\n            return retValue;\n            \n        }\n        \n    }\n    \n    private static class EveryFourth implements DSIterator{\n        private int nextIndex = 0;\n        private static final int SIZE = 1000;\n        private int[] array = new int[SIZE];\n        \n        public EveryFourth(){\n           for(int i =0; i<100; i++){\n               array[i] = i;\n           }\n        }\n        \n        public boolean hasNext(){\n            return (nextIndex <= SIZE-1);\n        }\n        \n        public Integer next() {\n            Integer retValue = Integer.valueOf(array[nextIndex]);\n            \n            nextIndex += 4;\n            return retValue;\n        }\n    }\n    \n\n    public static void main(String[] args) {\n        EveryFourth a = new EveryFourth();\n        ThirdIterator b = new ThirdIterator();\n        \n    \n    }\n\n}\n\nThere multiple problems here','final Variable SIZE in Hello is not intitialized in constructor \n\ncannot assign a value to final variable SIZE in innerclass ThirdIterator\n\nnon static third iterator class cannot be referenced from static main.\n\n','Inner Classes',1,NULL),(425,'public class Hello {\n    private final int SIZE;\n    private int[] array;\n    \n    public Hello(){\n        ThirdIterator x = new ThirdIterator();\n    }\n    \n    interface DSIterator extends java.util.Iterator<Integer> { }\n    \n    private class ThirdIterator implements DSIterator{\n        private int nextIndex = 0;\n        public ThirdIterator(){\n            SIZE = 100;\n            for(int ix=0; ix<SIZE; ix++){\n                array[ix] = ix;\n            }\n        }\n......\n.........','you cant do this either\nfinal variable SIZE is not instantiated on creation or in the \nconstructor. Even though it is in the ThirdIterator class\nconstructor. that does not work. ','Inner Classes',1,NULL),(426,'public class Hello {\n    private final int SIZE = 100;\n    private int[] array;\n\n    interface DSIterator extends java.util.Iterator<Integer> { }\n    \n    private class ThirdIterator implements DSIterator{\n        private int nextIndex = 0;\n        public ThirdIterator(){\n            for(int ix=0; ix<SIZE; ix++){\n                array[ix] = ix;\n            }\n        }  \n        public boolean hasNext(){\n            return (nextIndex <= SIZE - 1);\n        }\n        public Integer next(){\n            Integer retValue = Integer.valueOf(array[nextIndex]); \n            nextIndex += 3;\n            return retValue;    \n        }\n    }\n    private static class EveryFourth implements DSIterator{\n        private int nextIndex = 0;\n        private static final int SIZE = 1000;\n        private int[] array = new int[SIZE];\n        public EveryFourth(){\n           for(int i =0; i<100; i++){\n               array[i] = i;\n           }\n        }\n        public boolean hasNext(){\n            return (nextIndex <= SIZE-1);\n        }\n        \n        public Integer next() {\n            Integer retValue = Integer.valueOf(array[nextIndex]);\n            \n            nextIndex += 4;\n            return retValue;\n        }\n    }\n    public static void main(String[] args) {\n        EveryFourth a = new EveryFourth();\n        Hello.ThirdIterator b = new Hello().new ThirdIterator();\n    }\n\n}','compiles fine','Inner Classes',1,NULL),(427,'public class Hello {\n    private final int SIZE = 100;\n    private int[] array;\n\n    \n    static interface DSIterator extends java.util.Iterator<Integer> { }\n    \n    private class ThirdIterator implements DSIterator{\n        private int nextIndex = 0;\n        public ThirdIterator(){\n            for(int ix=0; ix<SIZE; ix++){\n                array[ix] = ix;\n            }\n        }\n        \n        public boolean hasNext(){\n            return (nextIndex <= SIZE - 1);\n        }\n        \n     ......','A nested interface declared static is redundant. A nested interface is automatically static. \nstatic can be removed without and affect on semantics. Similar to public on interface methods \nor public final on interface fields. \n\nIt doen\'t change the fact that code without access to Foo wont have access to Foo.Bar interface.\n\nIt is acceptable to use if you excpect it only to be used from the enclosing class\n\npublic class Foo {\n	public interface Bar {\n		void callback();\n	}\n	public static void registerCallback(Bar bar){...}\n}\n//elsewhere\nFoo.registerCallback(new Foo.Bar() {\n	public void callback() {...}\n});','Inner Classes',1,NULL),(428,'public class Hello {\n    private final int SIZE = 100;\n    private int[] array;\n\n    \n    interface DSIterator extends java.util.Iterator<Integer> { }\n    \n    interface Petable {\n        void speak();\n        void wag();\n    }\n    \n    private class ThirdIterator implements DSIterator{\n        private int nextIndex = 0;\n        public ThirdIterator(){\n            for(int ix=0; ix<SIZE; ix++){\n                array[ix] = ix;\n            }\n        }\n        \n        public boolean hasNext(){\n            return (nextIndex <= SIZE - 1);\n        }\n        \n        public Integer next(){\n            Integer retValue = Integer.valueOf(array[nextIndex]);\n            \n            nextIndex += 3;\n            return retValue;\n            \n        }\n        \n    }\n    \n    private static class EveryFourth implements DSIterator{\n        private int nextIndex = 0;\n        private static final int SIZE = 1000;\n        private int[] array = new int[SIZE];\n        \n        public EveryFourth(){\n           for(int i =0; i<100; i++){\n               array[i] = i;\n           }\n        }\n        \n        public boolean hasNext(){\n            return (nextIndex <= SIZE-1);\n        }\n        \n        public Integer next() {\n            Integer retValue = Integer.valueOf(array[nextIndex]);\n            \n            nextIndex += 4;\n            return retValue;\n        }\n    }\n    \n\n    public static void main(String[] args) {\n        \n        EveryFourth a = new EveryFourth();\n        Hello.ThirdIterator b = new Hello().new ThirdIterator();\n        \n    \n    }\n\n}\n\nclass Dog implements Petable {\n    \n    public void bark(){\n        \n    }\n\n    @Override\n    public void speak() {\n        throw new UnsupportedOperationException(\"Not supported yet.\"); //To change body of generated methods, choose Tools | Templates.\n    }\n\n    @Override\n    public void wag() {\n        throw new UnsupportedOperationException(\"Not supported yet.\"); //To change body of generated methods, choose Tools | Templates.\n    }\n    \n}','does not compile without outer reference for inner interface.\n\nshould be:\n\n	class Dog implements Hello.Petable {\n    \n ','Inner Classes',1,NULL),(429,'class MyOuter{\n	private int x = 7;\n\n	class MyInner{\n	public void seeOuter(){\n		sout( x );\n	}\n\n}\n\nclass OCP{\n	public static void main(SA){\n		MyOuter mo = new MyOuter();\n		MYOuter.MyInner inner = mo.new MyInner();\n		inner.seeOuter();\n	}\n}','how to instantiate an inner class object from outside the outter class instance code.','Inner Classes',1,NULL),(430,'psvm(SA){\n	MyOuter.MyInner inner = new MyOuter().new MyInner();\n	inner.seeOuter();\n}','one liner','Inner Classes',1,NULL),(431,'class MyOuter{\n    private int x = 7;\n    public void makeInner() {\n        MyInner in = new MyInner();\n       in.seeOuter();\n   }\n\n    class MyInner {	\n           public void seeOuter {\n	sout( \"Outer x is \" + x );\n	sout(\"Inner class ref is \" + this);\n	sout( \"Outer class ref is \" + MyOuter.this );\n            }\n}\n\n      psvm(sa) {\n	MyOuter.MyInner inner = new MyOuter().new MyInner();\n	inner.seeOuter();\n     }\n}\n		','\n	The rules for an inner class to reference itself or the outer class instance are as follows:\n\n	To reference the inner class instance itself from within the inner class code,\n		use this\n\n	toreference the \"outer this\" from within the inner class code,\n		use MyOuter.this.','Inner Classes',1,NULL),(432,'what member modifiers can be applied to an inner class	','final\nabstract\npublic \nprivate\nprotected\nstatic\nstrictfp','Inner Classes',1,NULL),(433,'class MyOuter2 {\n	private String x = \"Outer2\";\n	void doStuff() {\n	        class MyInner {\n		public void seeOuter() {\n	                               sout(\" outer x is \" + x );\n		}\n	        }\n	\n	MyInner mi = new MyInner(); // THIS LINE MUST COME AFTER THE CLASS\n\n	mi.seeOuter();\n	}\n}\n\n	','How to properly use a method local inner class','Inner Classes',1,NULL),(434,'public class Hello {\n   \n    public static void main(String[] args) {\n        Hello h = new Hello();\n        h.methodlocal();\n    }\n    \n    public void methodlocal(){\n        \n        class WayInner {\n            private int size;\n        \n            public WayInner(int x){ size = x;}\n            public void printDetail(){\n                System.out.println(\"WayInner: \"+ size);\n            }\n        }\n        \n        WayInner a = new WayInner(7);\n        a.printDetail();\n    }\n\n}','WayInner: 7\n\nthe proper way to use a method local inner ','Inner Classes',1,NULL),(435,'public class Hello {\n   \n    public static void main(String[] args) {\n        Hello h = new Hello();\n        h.methodlocal();\n    }\n    \n    public void methodlocal(){\n        int y = 56;\n        \n        class WayInner {\n            public int size;\n        \n            public WayInner(int x){ size = x;}\n            public void printDetail(){\n                System.out.println(\"WayInner: \"+ size);\n            }\n            \n            public void showall(){\n                System.out.println(size+\" \"+y);\n            }\n        }\n        \n        WayInner a = new WayInner(7);\n        a.printDetail();\n        a.showall();\n        \n    }\n\n}','will not compile in java 7. \n\nlocal varialbe cannot be accesed from within inner class. \n\nLocal varialbe exist on the stack and only exist for the lifetime of the method. \n\nwhen the method ends the local varialbes are destroyed, however the inner class object might still live on\n ','Inner Classes',1,NULL),(436,'public class Hello {\n   \n    public static void main(String[] args) {\n        Hello h = new Hello();\n        h.methodlocal();\n    }\n    \n    public void methodlocal(){\n        final int y = 56;\n        \n        class Zombie {\n            public int size;\n        \n            public Zombie(int x){ size = x;}\n            public void mone(){\n                System.out.println(\"ughhhg: \"+ size);\n            }\n            \n            public void accessTheLiving(){\n                System.out.println(\"local var: \"+y);\n            }\n            \n        }\n        \n        Zombie zom = new Zombie(7);\n        \n    }\n\n}','will compile method local inner class can only access local variables if they are marked final.','Inner Classes',1,NULL),(437,'public class Hello {\n   \n    public static void main(String[] args) {\n        Hello h = new Hello();\n        h.methodlocal();\n    }\n    \n    public void methodlocal(){\n        final int y = 56;\n        \n        protected class Zombie {\n            public int size;\n        \n            public Zombie(int x){ size = x;}\n            public void mone(){\n                System.out.println(\"ughhhg: \"+ size);\n            }\n            \n            public void accessTheLiving(){\n                System.out.println(\"local var: \"+y);\n            }\n            \n        }\n        \n        Zombie zom = new Zombie(7);\n        \n    }\n\n}','will not compile method local inner classes cannot be marked public private protected static or transient.','Inner Classes',1,NULL),(438,'public class Hello {\n   \n    public static void main(String[] args) {\n        Hello h = new Hello();\n        h.methodlocal();\n    }\n    \n    public void methodlocal(){\n        final int y = 56;\n        \n        static class Zombie {\n            public int size;\n        \n            public Zombie(int x){ size = x;}\n            public void mone(){\n                System.out.println(\"ughhhg: \"+ size);\n            }\n            \n            public void accessTheLiving(){\n                System.out.println(\"local var: \"+y);\n            }\n            \n        }\n        \n        Zombie zom = new Zombie(7);\n        \n    }\n\n}','will not compile ML inner class cannot be marked static. ','Inner Classes',1,NULL),(439,'public class Hello {\n   \n    public static void main(String[] args) {\n        Hello h = new Hello();\n        h.methodlocal();\n    }\n    \n    public void methodlocal(){\n        final int y = 56;\n        \n        class Zombie {\n            public int size;\n        \n            public Zombie(int x){ size = x;}\n            public static void mone(){\n                System.out.println(\"ughhhg: \"+ size);\n            }\n            \n            public void accessTheLiving(){\n                System.out.println(\"local var: \"+y);\n            }\n            \n        }\n        \n        Zombie zom = new Zombie(7);\n        \n    }\n\n}','will not compile \n\nillegal static declaration in method local inner class. ','Inner Classes',1,NULL),(440,'public class Hello {\n   \n    public static void main(String[] args) {\n        Hello h = new Hello();\n        h.methodlocal();\n    }\n    \n    public void methodlocal(){\n        final int y = 56;\n        \n        \n        class Zombie {\n            public int size;\n            public static int num = 5;\n        \n            public Zombie(int x){ size = x;}\n            public void mone(){\n                System.out.println(\"ughhhg: \"+ size);\n            }\n            \n            public void accessTheLiving(){\n                System.out.println(\"local var: \"+y);\n            }\n            \n        }\n        \n        Zombie zom = new Zombie(7);\n        \n    }\n\n}','will not compile\n\nillegal modifier static is only allowed in constant decalartations. \n\nto compile make num final','Inner Classes',1,NULL),(441,'public class Hello {\n   \n    public static void main(String[] args) {\n        Hello h = new Hello();\n        h.methodlocal();\n    }\n    \n    public void methodlocal(){\n        final int y = 56;\n        \n        \n        class Zombie {\n            public int size;\n            public static final int num = 5;\n        \n            public Zombie(int x){ size = x;}\n            public void mone(){\n                System.out.println(\"ughhhg: \"+ size);\n            }\n            \n            public void accessTheLiving(){\n                System.out.println(\"local var: \"+y);\n            }\n            \n        }\n        \n        Zombie zom = new Zombie(7);\n        \n    }\n\n}','compiles fine.\n\nto use static in an inner class it must be marked final','Inner Classes',1,NULL),(442,'For inner classes \'static\' is only allowed for constant variable declarations. ','','Inner Classes',1,NULL),(443,'public class Hello {\n   \n    public static void main(String[] args) {\n        Hello h = new Hello();\n        h.methodlocal();\n    }\n    \n    public static void methodlocal(){\n        final int y = 56;\n        \n        \n        class Zombie {\n            public int size;\n            public static final int num = 5;\n        \n            public Zombie(int x){ size = x;}\n            public static final void mone(){\n                System.out.println(\"ughhhg: \"+ size);\n            }\n            \n            public void accessTheLiving(){\n                System.out.println(\"local var: \"+y);\n            }\n            \n        }\n        \n        Zombie zom = new Zombie(7);\n        \n    }\n\n}','does not compile, \n\neven if the method is static ML innner class cannot decalre staic unless it is a static final constant. ','Inner Classes',1,NULL),(444,'public class Hello {\n    private String name = \"marco\";\n    private final static String gem = \"Gemini\";\n    private static String west = \"Eunech\";\n   \n    public static void main(String[] args) {\n        Hello h = new Hello();\n        h.methodlocal();\n    }\n    \n    public static void methodlocal(){\n        final int y = 56;\n        //System.out.println(name); //wouldnt compile\n        System.out.println(gem);\n        \n        \n        class Zombie {\n            public int size;\n            public static final int num = 5;\n        \n            public Zombie(int x){ size = x; System.out.println(gem); System.out.println(west); System.out.println(name); }\n            public void mone(){\n                System.out.println(\"ughhhg: \"+ size);\n            }\n            \n            public void accessTheLiving(){\n                System.out.println(\"local var: \"+y);\n            }\n            \n        }\n        \n        Zombie zom = new Zombie(7);\n        \n    }\n\n}','does not compile\n\na MLIC declared in a static method cannot access instance varialbes of the outerclass. \n\nso\n sout(name) does not compile here. \n\nit can however access those static variables, if it was just the statics \nit would print:\n\n	Gemini\n	Gemini\n	Eunech','Inner Classes',1,NULL),(445,'public class Hello {\n    private String name = \"marco\";\n    private final static String gem = \"Gemini\";\n    private static String west = \"Eunech\";\n   \n    public static void main(String[] args) {\n        Hello h = new Hello();\n        h.methodlocal();\n    }\n    \n    public void methodlocal(){\n        final int y = 56;\n        //System.out.println(name); //wouldnt compile\n        System.out.println(gem);\n        \n        \n        class Zombie {\n            public int size;\n            public static final int num = 5;\n        \n            public Zombie(int x){ size = x; System.out.println(gem); System.out.println(west); System.out.println(name); }\n            public void mone(){\n                System.out.println(\"ughhhg: \"+ size);\n            }\n            \n            public void accessTheLiving(){\n                System.out.println(\"local var: \"+y);\n            }\n            \n        }\n        \n        Zombie zom = new Zombie(7);\n        \n    }\n\n}','this compiles fine \nMLIC in a instance method can access both static and instance variables','Inner Classes',1,NULL),(446,'class Horse extends Animal {\n        void buck() { }\n}\n\nclass Animal {\n        void eat() { }\n}\nclass Test {\n        public static void main(String[] atrgs) {\n	Animal h = new Horse();\n	h.eat();\n	h.buck();\n       }\n}	','h.buck() will not compile because you can only call the superclasses methods on a polymorphic reference','Inner Classes',1,NULL),(447,'public class Hello {\n   \n    public static void main(String[] args) {\n        Biggie smalls = new Biggie(){\n            public void getLoot(){\n                System.out.println(\"Gimmie the loot!\");\n            }\n            \n        };\n        \n        smalls.actFly();\n        smalls.getLoot();\n        \n      \n    }\n\n}\n\nclass Biggie {\n    public void actFly(){\n        System.out.println(\"Shit so fly\");\n    }\n    public static void getPaid(){\n        System.out.println(\"Its so easy!\");\n    }\n    public int getFemaleDigits(){\n        return 5556784;\n    }\n}','here smalls.actFly() compiles \n\nhowever, getLoot() is defined in the anonyous subclass so polynorphically it cannot compile.\n\nThe only way to use methods declared in the anonymous subclass is to override methods of \nthe super class where overriding rules still apply. ','Inner Classes',1,NULL),(448,'public class Hello {\n   \n    public static void main(String[] args) {\n        Biggie smalls = new Biggie(){\n            private void getLoot(){\n                System.out.println(\"Gimmie the loot!\");\n            }\n            \n            public void actFly(){\n                System.out.println(\"Still acting fly\");\n            }\n            \n        };\n        \n        smalls.actFly();\n        smalls.actFly();\n    }\n\n}\n\nclass Biggie {\n    public void actFly(){\n        System.out.println(\"Shit so fly\");\n    }\n    public static void getPaid(){\n        System.out.println(\"Its so easy!\");\n    }\n    public int getFemaleDigits(){\n        return 5556784;\n    }\n}','proper override','Inner Classes',1,NULL),(449,'public class Hello {\n   \n    public static void main(String[] args) {\n        Biggie smalls = new Biggie(){\n            private void getLoot(){\n                System.out.println(\"Gimmie the loot!\");\n            }\n            \n            public int actFly(){\n                int x = 66;\n                System.out.println(\"Still acting fly\");\n                return x;\n            }\n            \n        };\n        \n        smalls.actFly();\n        smalls.actFly();\n    }\n\n}\n\nclass Biggie {\n    public void actFly(){\n        System.out.println(\"Shit so fly\");\n    }\n    public static void getPaid(){\n        System.out.println(\"Its so easy!\");\n    }\n    public int getFemaleDigits(){\n        return 5556784;\n    }\n}','will not compile override methods cannot return a different type unless its a subtype','Inner Classes',1,NULL),(450,'public class Hello {\n   \n    public static void main(String[] args) {\n        Biggie smalls = new Biggie(){\n            private void getLoot(){\n                System.out.println(\"Gimmie the loot!\");\n            }\n            \n            public void actFly(){\n                System.out.println(\"Still acting fly\");\n            }\n            \n            public Integer getFemalDigits(){\n                return 5671123;\n            }  \n        };\n        \n        smalls.actFly();\n        smalls.actFly();\n    }\n\n}\n\nclass Biggie {\n    protected void actFly(){\n        System.out.println(\"Shit so fly\");\n    }\n    public static void getPaid(){\n        System.out.println(\"Its so easy!\");\n    }\n    public Number getFemaleDigits(){\n        return 5556784;\n    }\n}','this will compile just fine. \n\nan override method is allowed to have less reestricted access but not more,\n\nan override method must have the same return type or it can return a subclass. ','Inner Classes',1,NULL),(451,'public class Hello {\n   \n    public static void main(String[] args) {\n        Biggie smalls = new Biggie(){\n            private void getLoot(){\n                System.out.println(\"Gimmie the loot!\");\n            }\n            \n            public void actFly(){\n                System.out.println(\"Still acting fly\");\n            }\n            \n            public Integer getFemalDigits(){\n                return 5671123;\n            }  \n            \n            public void getPaid(){\n                System.out.println(\"Boy I get money!\");\n            }\n        };\n        \n        smalls.actFly();\n        smalls.actFly();\n    }\n\n}\n\nclass Biggie {\n    protected void actFly(){\n        System.out.println(\"Shit so fly\");\n    }\n    public static void getPaid(){\n        System.out.println(\"Its so easy!\");\n    }\n    public Number getFemaleDigits(){\n        return 5556784;\n    }\n}','will not compile, \n\nyou cannot override a method marked static. \n\nThe only way you could make this work is by making getPaid in the anonymous\nclass static which would \'hide\' the superclass static method not override it.\n\nunfortuanlytel you cannot put a static method in an anonymous class. \n\n\n\nOver-riding basically supports late binding . Therefore, which method will be called is decided at run time.It is for non-static methods. Hiding is for all other members (static methods , instance members, static members). It is based on the early binding . More clearly , the method or member to be called or used is decided during compile time.\n\nIn your example, the first call , Animal.testClassMethod() is a call to a static method,hence, it is pretty sure as to which method is going to be called.\n\nIn the second call,myAnimal.testInstanceMethod(), it calls a non-static method. It is what you call run-time polymorphism. It is not decided until run time which method is to be called.\n\nFor further clarification, read this.\n','Inner Classes',1,NULL),(452,'public class Hello {\n   \n    public static void main(String[] args) {\n        Biggie smalls = new Biggie(){\n            private void getLoot(){\n                System.out.println(\"Gimmie the loot!\");\n            }\n            \n            public void actFly(){\n                System.out.println(\"Still acting fly\");\n            }\n            \n            public Integer getFemalDigits(){\n                return 5671123;\n            }  \n            \n            public static void getPaid(){\n                System.out.println(\"Boy I get money!\");\n            }\n        };\n        \n        smalls.actFly();\n        smalls.actFly();\n    }\n\n}\n\nclass Biggie {\n    protected void actFly(){\n        System.out.println(\"Shit so fly\");\n    }\n    public static void getPaid(){\n        System.out.println(\"Its so easy!\");\n    }\n    public Number getFemaleDigits(){\n        return 5556784;\n    }\n}','Will not compile\n\nstatic definitions not allowed in inner classes except for constant varaible definintions. ','Inner Classes',1,NULL),(453,'class Biggie {\n    public static int thashitt = 568;\n    protected void actFly(){\n        System.out.println(\"Shit so fly\");\n    }\n    public static void getPaid(){\n        System.out.println(\"Its so easy!\");\n    }\n    public Number getFemaleDigits(){\n        return 5556784;\n    }\n}\n\nclass Benzino extends Biggie{\n    \n    public void printThaShitt(){\n        System.out.println(thashitt);\n    }\n    \n    public static void getPaid(){\n        System.out.println(\"It\'s somewhat difficult\");\n    }\n    \n    public Integer getFemaleDigits(){\n        return null;\n    }\n    \n}','this compiles fine,\n\n','Inner Classes',1,NULL),(454,'public class Hello {\n   \n    public static void main(String[] args) {\n        Biggie smalls = new Biggie(){\n            private void getLoot(){\n                System.out.println(\"Gimmie the loot!\");\n            }\n            \n            public void actFly(){\n                System.out.println(\"Still acting fly\");\n            }\n            \n            public Integer getFemaleDigits(){\n                return 5671123;\n            }  \n\n        };\n        \n        smalls.actFly();\n        System.out.println(smalls.getFemaleDigits());\n        \n        Biggie benz = new Benzino();\n        benz.getPaid();\n    }\n\n}\n\nclass Biggie {\n    public static int thashitt = 568;\n    protected void actFly(){\n        System.out.println(\"Shit so fly\");\n    }\n    public static void getPaid(){\n        System.out.println(\"Its so easy!\");\n    }\n    public Number getFemaleDigits(){\n        return 5556784;\n    }\n}\n\nclass Benzino extends Biggie{\n    \n    public void printThaShitt(){\n        System.out.println(thashitt);\n    }\n    \n    public static void getPaid(){\n        System.out.println(\"It\'s somewhat difficult\");\n    }\n    \n    public Integer getFemaleDigits(){\n        return null;\n    }\n    \n}','Still acting fly\n5671123\nIts so easy!\n\nthe reference smalls is of type anonymous class so its methods are theoverriden methods in the anonymous \nclass\n\nwhen getPaid() is called on benz you are accessing a static method from a reference variable, so \nthe Biggie version is used because thats the type of the reference variable, \n\nstatic methods cannot be overridden but they can be hidden. ','Inner Classes',1,NULL),(455,'public class Hello {\n   \n    public static void main(String[] args) {\n        Biggie smalls = new Biggie(){\n            private void getLoot(){\n                System.out.println(\"Gimmie the loot!\");\n            }\n            \n            public void actFly(){\n                System.out.println(\"Still acting fly\");\n            }\n            \n            public Integer getFemaleDigits(){\n                return 5671123;\n            }  \n\n        };\n        \n        smalls.actFly();\n        System.out.println(smalls.getFemaleDigits());\n        \n        Benzino benz = new Benzino();\n        benz.getPaid();\n    }\n\n}\n\nclass Biggie {\n    public static int thashitt = 568;\n    protected void actFly(){\n        System.out.println(\"Shit so fly\");\n    }\n    public static void getPaid(){\n        System.out.println(\"Its so easy!\");\n    }\n    public Number getFemaleDigits(){\n        return 5556784;\n    }\n}\n\nclass Benzino extends Biggie{\n    \n    public void printThaShitt(){\n        System.out.println(thashitt);\n    }\n    \n    public static void getPaid(){\n        System.out.println(\"It\'s somewhat difficult\");\n    }\n    \n    public Integer getFemaleDigits(){\n        return null;\n    }\n    \n}','Still acting fly\n5671123\nIt\'s somewhat difficult','Inner Classes',1,NULL),(456,'class Popcorn {\n	public void pop(){\n		sout(\"popcorn\");\n	}\n}\n\nclass Food {\n	Popcorn p = new Popcorn() {\n		public void sizzle(){\n			sout(\"anonymouse sizzling popcorn\");\n		}\n\n		public void pop(){\n			sout(\"anonumous popcorn\");\n		}\n	};\n\n	public void popIt(){\n		p.pop();\n		p.sizzle();\n	}\n}','p.pop(); is ok because popcorn has a pop method\n\np.sizzle();  is illegal because popcorn does not have sizzle().\n\n','Inner Classes',1,NULL),(457,'public class Hello {\n   \n    public static void main(String[] args) {\n        Biggie benz = new Benzino();\n        benz.printThaShitt();\n    }\n\n}\n\nclass Biggie {\n    public static int thashitt = 568;\n    protected void actFly(){\n        System.out.println(\"Shit so fly\");\n    }\n    public static void getPaid(){\n        System.out.println(\"Its so easy!\");\n    }\n    public Number getFemaleDigits(){\n        return 5556784;\n    }\n}\n\nclass Benzino extends Biggie{\n    \n    public void printThaShitt(){\n        System.out.println(thashitt);\n        getPaid();\n        super.getPaid();\n        Biggie.getPaid();\n    }\n    \n    public static void getPaid(){\n        System.out.println(\"It\'s somewhat difficult\");\n    }\n    \n    public Integer getFemaleDigits(){\n        return null;\n    }\n    \n}','will not compile class Benzino does not have that method. ','Inner Classes',1,NULL),(458,'public class Hello {\n   \n    public static void main(String[] args) {\n        Benzino benz = new Benzino();\n        benz.printThaShitt();\n    }\n\n}\n\nclass Biggie {\n    public static int thashitt = 568;\n    protected void actFly(){\n        System.out.println(\"Shit so fly\");\n    }\n    public static void getPaid(){\n        System.out.println(\"Its so easy!\");\n    }\n    public Number getFemaleDigits(){\n        return 5556784;\n    }\n}\n\nclass Benzino extends Biggie{\n    \n    public void printThaShitt(){\n        System.out.println(thashitt);\n        getPaid();\n        super.getPaid();\n        Biggie.getPaid();\n    }\n    \n    public static void getPaid(){\n        System.out.println(\"It\'s somewhat difficult\");\n    }\n    \n    public Integer getFemaleDigits(){\n        return null;\n    }\n    \n}\n','568\nIt\'s somewhat difficult\nIts so easy!\nIts so easy!\n\n\ngetPaid() is used plainly as is it calls Benzinos static method, \n\nall the others access the super class. \n\nStatic variables in Java are not inherited, they exist only in the class which declares them; \nhowever, they can be accessed implicitly by referring to an instance or subclass (or subclass instance) of the class which defines the \nstatic variable. \n(Static variable handling is one of the few confusing parts of the Java language, IMHO.)','Inner Classes',1,NULL),(459,'public class Test {\n    public static void foo() {\n        System.out.println(\"Test.foo() called \");\n    }\n    public static void foo(int a) { \n        System.out.println(\"Test.foo(int) called \");\n    }\n    public static void main(String args[])\n    { \n        Test.foo();\n        Test.foo(10);\n    }\n}','this shows that static methods can be overloaded','Inner Classes',1,NULL),(460,'public class Test {\n    public static void foo() {\n        System.out.println(\"Test.foo() called \");\n    }\n    public void foo() { \n        System.out.println(\"Test.foo(int) called \");\n    }\n    public static void main(String args[]) { \n        Test.foo();\n    }\n}','will not compile, you cannot overload based on static keyword alone','Inner Classes',1,NULL),(461,'public class Hello {\n\n   \n    public static void main(String[] args) {\n        Burnable stick = new Burnable(){\n            \n        };\n    }\n\n}\n\ninterface Burnable{\n    int people = 10;\n    void burn();\n    void shakeoff();\n    int unburn();\n    \n}','will not compile, \n\nanonymous class of stick is not abstract and does not overrride interface\nmethods\n\n','Inner Classes',1,NULL),(462,'public class Hello {\n\n   \n    public static void main(String[] args) {\n        Burnable stick = new Burnable(){\n            public void burn(){\n                System.out.println(\"Theres \"+people+\" people here so get the fire going\");\n            }\n            \n        };\n    }\n\n}\n\ninterface Burnable{\n    int people = 10;\n    void burn();\n    void shakeoff();\n    int unburn();\n    \n}','does not compile, \n\nanonymous subclass does not impelement all abstract methods ','Inner Classes',1,NULL),(463,'public class Hello {\n\n    public static void main(String[] args) {\n        \n        Burnable stick = new Burnable(){\n            public void burn(){\n                System.out.println(\"Theres \"+people+\" people here so get the fire going\");\n            }\n            \n            public int unburn(){\n                System.out.println(\"That\'s impossible\");\n                return 0;\n            }\n            \n            public void shakeoff(){\n                System.out.println(\"That was my shoe!\");\n            }\n            \n        };\n    }\n\n}\n\ninterface Burnable{\n    int people = 10;\n    void burn();\n    void shakeoff();\n    int unburn();\n}\n','This type of anonomuous inner class implemtents an interface\n\nThis is the only time you can use new with an interface.\n\nIt compiles because all of the abstract methods are implemented\n\n','Inner Classes',1,NULL),(464,'interface Burnable{\n    int people = 10;\n    void burn();\n    void shakeoff();\n    int unburn();\n    void people(){\n        System.out.println(people+\" \");\n    }\n}','will not compile interfaces are 100% abstract, they can have nothing\nconcrete','Inner Classes',1,NULL),(465,'public class Hello {\n\n    public static void main(String[] args) {\n        \n        Burnable stick = new Burnable(){\n            int people = 8;\n            public void burn(){\n                System.out.println(\"Theres \"+people+\" people here so get the fire going\");\n            }\n            \n            public int unburn(){\n                System.out.println(\"That\'s impossible\");\n                return 0;\n            }\n            \n            public void shakeoff(){\n                System.out.println(\"That was my shoe!\");\n            }\n            \n        };\n        \n        stick.burn();\n    }\n\n}\n\ninterface Burnable{\n    int people = 10;\n    void burn();\n    void shakeoff();\n    int unburn();\n}\n','Theres 8 people here so get the fire going','Inner Classes',1,NULL),(466,'public class Hello {\n\n    public static void main(String[] args) {\n        \n        Burnable stick = new Burnable(){\n            int people = 8;\n            public void burn(){\n                System.out.println(\"Theres \"+people+\" people here so get the fire going\");\n            }\n            \n            public int unburn(){\n                System.out.println(\"That\'s impossible\");\n                return 0;\n            }\n            \n            public void shakeoff(int x){\n                System.out.println(\"That was my shoe!\"+x);\n            }\n            \n            public void shakeoff(){\n                System.out.println(\"its off\");\n            }\n            \n            \n            \n        };\n        \n        stick.burn();\n        stick.shakeoff();\n    }\n\n}\n\ninterface Burnable{\n    int people = 10;\n    void burn();\n    void shakeoff(int z);\n    int unburn();\n}','Will not compile, shakeoff() is overloaded in anonymous subclass. \n\nThe overload is legal using it outside the inner class is not\n\nthat method is an overload it is created in the anonnymous subclass and\ncant be used on the Burnable refernence','Inner Classes',1,NULL),(467,'public class Hello {\n\n    public static void main(String[] args) {\n        Gym.BasketBallCourt bc = new Gym.BasketBallCourt();\n        bc.collectBalls();\n    }\n\n}\n\nclass Gym{\n    public int weights = 8000;\n    public String name = \"Max\'s gym\";\n    public int price = 50;\n    \n    public void pitch(){\n        System.out.println(\"Were the best gym\");\n    }\n    \n    static class BasketBallCourt {\n        private int courts = 2;\n        \n        public void collectBalls(){\n            System.out.println(\"gimmmie all the balls!\");\n        }\n        \n        public int Scoreboard(){\n            return 114;\n        }\n    }\n}','gimmie all the balls!','Inner Classes',1,NULL),(468,'class Gym{\n    public int weights = 8000;\n    public String name = \"Max\'s gym\";\n    public int price = 50;\n    \n    public void pitch(){\n        System.out.println(\"Were the best gym\");\n    }\n    \n    static class BasketBallCourt {\n        private int courts = 2;\n        \n        public void collectBalls(){\n            System.out.println(\"gimmmie all the balls!\");\n        }\n        \n        public void gymPrice(){\n            System.out.println(name+\" \"+price);\n        }\n        \n        public int Scoreboard(){\n            return 114;\n        }\n    }','will not compile, static classes are like static members of the enclosing\nclass they cannot access instance varialbes','Inner Classes',1,NULL),(469,'class Gym{\n    public int weights = 8000;\n    public String name = \"Max\'s gym\";\n    public int price = 50;\n    \n    public void pitch(){\n        System.out.println(\"Were the best gym\");\n    }\n    \n    static class BasketBallCourt {\n        private static int courts = 2;\n        \n        public void collectBalls(){\n            System.out.println(\"gimmmie all the balls!\");\n        }\n        \n        public void gymPrice(){\n            Gym g = new Gym();\n            System.out.println(g.price);\n        }\n        \n        public int Scoreboard(){\n            return 114;\n        }\n    }\n}','This compiles fine static inner classes can have static fields and methods\n','Inner Classes',1,NULL),(470,'public class Hello {\n\n    public static void main(String[] args) {\n        Gym.BasketBallCourt bc = new Gym.BasketBallCourt();\n        bc.collectBalls();\n    }\n\n}\n\nclass Gym{\n    public int weights = 8000;\n    public String name = \"Max\'s gym\";\n    public int price = 50;\n    \n    public void pitch(){\n        BasketBallCourt bc = new BasketBallCourt();\n        System.out.println(\"Were the best gym\");\n        System.out.println(\"Our court is huge too! \"+bc.courts());\n    }\n    \n    static class BasketBallCourt {\n        private static int courts = 2;\n        \n        public static void collectBalls(){\n            System.out.println(\"gimmmie all the balls!\");\n        }\n        public int courts(){\n            return courts;\n        }\n        \n        public void gymPrice(){\n            Gym g = new Gym();\n            System.out.println(g.price);\n        }\n        \n        public int Scoreboard(){\n            return 114;\n        }\n    }\n}','this compiles fine, shows how to properly instantiate static nested clases','Inner Classes',1,NULL),(471,'public class Hello {\n\n    public static void main(String[] args) {\n        Gym.BasketBallCourt bc = new Gym.BasketBallCourt();\n        Gym g = new Gym();\n        \n        Gym.BasketBallCourt bc3 = g.new BasketBallCourt();\n        \n        g.pitch();\n        \n    }\n\n}\n\nclass Gym{\n    public int weights = 8000;\n    public String name = \"Max\'s gym\";\n    public int price = 50;\n    \n    public void pitch(){\n        BasketBallCourt bc = new BasketBallCourt();\n        System.out.println(\"Were the best gym\");\n        System.out.println(\"Our court is huge too! \"+bc.courts());\n    }\n    \n    static class BasketBallCourt {\n        private static int courts = 2;\n        \n        public static void collectBalls(){\n            System.out.println(\"gimmmie all the balls!\");\n        }\n        public int courts(){\n            return courts;\n        }\n        \n        public void gymPrice(){\n            Gym g = new Gym();\n            System.out.println(g.price);\n        }\n        \n        public int Scoreboard(){\n            return 114;\n        }\n    }\n}','will not compile, that is not the right instantiation of a static nested class','Inner Classes',1,NULL),(472,'public class Hello {\n\n    public static void main(String[] args) {\n        Gym.BasketBallCourt bc = new Gym.BasketBallCourt();\n        Gym g = new Gym();\n        \n        Gym.BasketBallCourt bc3 = new Gym.BasketBallCourt();\n        \n        bc3.Scoreboard();\n        \n        Gym.BasketBallCourt.collectBalls();\n        \n    }\n\n}\n\nclass Gym{\n    public int weights = 8000;\n    public String name = \"Max\'s gym\";\n    public int price = 50;\n    \n    public void pitch(){\n        BasketBallCourt bc = new BasketBallCourt();\n        System.out.println(\"Were the best gym\");\n        System.out.println(\"Our court is huge too! \"+bc.courts());\n    }\n    \n    static class BasketBallCourt {\n        private static int courts = 2;\n        \n        public static void collectBalls(){\n            System.out.println(\"gimmmie all the balls!\");\n        }\n        public int courts(){\n            return courts;\n        }\n        \n        public void gymPrice(){\n            Gym g = new Gym();\n            System.out.println(g.price);\n        }\n        \n        public int Scoreboard(){\n            return 114;\n        }\n    }\n}','114\ngimmie all the balls','Inner Classes',1,NULL),(473,'public class Hello {\n\n    public static void main(String[] args) {\n        Gym.BasketBallCourt gbg = new Gym().new BasketBallCourt();\n        System.out.println(gbg.Scoreboard());\n        \n    }\n\n}\n\nclass Gym{\n    public int weights = 8000;\n    public String name = \"Max\'s gym\";\n    public int price = 50;\n    \n    public void pitch(){\n        BasketBallCourt bc = new BasketBallCourt();\n        System.out.println(\"Were the best gym\");\n    }\n    \n    class BasketBallCourt {\n        \n        public void collectBalls(){\n            System.out.println(\"gimmmie all the balls!\");\n        }\n        \n        public void gymPrice(){\n            Gym g = new Gym();\n            System.out.println(g.price);\n        }\n        \n        public int Scoreboard(){\n            return 114;\n        }\n    }\n}','114','Inner Classes',1,NULL),(474,'public class Hello {\n\n    public static void main(String[] args) {\n        Gym.BasketBallCourt gbg = new Gym().new BasketBallCourt();\n        \n    }\n\n}\n\nclass Gym{\n    public int weights = 8000;\n    public String name = \"Max\'s gym\";\n    public int price = 50;\n    \n    public void pitch(){\n        BasketBallCourt bc = new BasketBallCourt();\n        System.out.println(\"Were the best gym\");\n    }\n    \n    private class BasketBallCourt {\n        \n        public void collectBalls(){\n            System.out.println(\"gimmmie all the balls!\");\n        }\n        \n        public void gymPrice(){\n            Gym g = new Gym();\n            System.out.println(g.price);\n        }\n        \n        public int Scoreboard(){\n            return 114;\n        }\n    }\n}','does not compile because of private modifier','Inner Classes',1,NULL),(475,'public class Hello {\n\n    public static void main(String[] args) {\n        Gym.BasketBallCourt gbg = new Gym().new BasketBallCourt();\n        \n    }\n\n}\n\nclass Gym{\n    public int weights = 8000;\n    public String name = \"Max\'s gym\";\n    public int price = 50;\n    \n    public void pitch(){\n        BasketBallCourt bc = new BasketBallCourt();\n        System.out.println(\"Were the best gym\");\n    }\n    \n    protected class BasketBallCourt {\n        \n        public void collectBalls(){\n            System.out.println(\"gimmmie all the balls!\");\n        }\n        \n        public void gymPrice(){\n            Gym g = new Gym();\n            System.out.println(g.price);\n        }\n        \n        public int Scoreboard(){\n            return 114;\n        }\n    }\n}','this compiles fine','Inner Classes',1,NULL),(476,'public class Hello {\n\n    public static void main(String[] args) {\n        LifeTime lt = new LifeTime();\n        lt.showLifeTimesCourt();    \n    }\n\n}\n\nclass Gym{\n    public int weights = 8000;\n    public String name = \"Max\'s gym\";\n    public int price = 50;\n    \n    public void pitch(){\n        BasketBallCourt bc = new BasketBallCourt();\n        System.out.println(\"Were the best gym\");\n    }\n    \n    protected class BasketBallCourt {\n        \n        public void collectBalls(){\n            System.out.println(\"gimmmie all the balls!\");\n        }\n        \n        public void showCourt(){\n            System.out.println(\"oooh ahhh\");\n        }\n        \n        public void gymPrice(){\n            Gym g = new Gym();\n            System.out.println(g.price);\n        }\n        \n        public int Scoreboard(){\n            return 114;\n        }\n    }\n}\n\nclass LifeTime extends Gym{\n    public void showLifeTimesCourt(){\n        BasketBallCourt b = new BasketBallCourt();\n        b.showCourt();\n    }\n}','oooh ahhh\n\nsince inner classes are members of the enclsoing class just like anything else\nthey are inherited too.','Inner Classes',1,NULL),(477,'public class Hello {\n\n    public static void main(String[] args) {\n       LifeTime lt = new LifeTime();\n       Gym.BasketBallCourt bc = lt.new BasketBallCourt();\n       \n    }\n\n}\n\nclass Gym{\n    public int weights = 8000;\n    public String name = \"Max\'s gym\";\n    public int price = 50;\n    \n    public void pitch(){\n        BasketBallCourt bc = new BasketBallCourt();\n        System.out.println(\"Were the best gym\");\n    }\n    \n    protected class BasketBallCourt {\n        \n        public void collectBalls(){\n            System.out.println(\"gimmmie all the balls!\");\n        }\n        \n        public void showCourt(){\n            System.out.println(\"oooh ahhh\");\n        }\n        \n        public void gymPrice(){\n            Gym g = new Gym();\n            System.out.println(g.price);\n        }\n        \n        public int Scoreboard(){\n            return 114;\n        }\n    }\n}\n\nclass LifeTime extends Gym{\n    public void showLifeTimesCourt(){\n        BasketBallCourt b = new BasketBallCourt();\n        b.showCourt();\n    }\n}','this compiles and runs','Inner Classes',1,NULL),(478,'public class Hello {\n\n    public static void main(String[] args) {\n       Gym lt = new Gym();\n       Gym.BasketBallCourt bc = lt.new BasketBallCourt();\n       \n    }\n\n}\n\nclass Gym{\n    public int weights = 8000;\n    public String name = \"Max\'s gym\";\n    public int price = 50;\n    \n    public void pitch(){\n        BasketBallCourt bc = new BasketBallCourt();\n        System.out.println(\"Were the best gym\");\n    }\n    \n    protected class BasketBallCourt {\n        public String name = \"Maxs court\";\n        \n        public void collectBalls(){\n            System.out.println(\"gimmmie all the balls!\");\n        }\n        \n        public void showCourt(){\n            System.out.println(\" \"+name);\n            System.out.println(\"oooh ahhh\");\n        }\n        \n        public void gymPrice(){\n            System.out.println(\" \"+Gym.this.name);\n            System.out.println(Gym.this.price);\n        }\n        \n        public int Scoreboard(){\n            return 114;\n        }\n    }\n}','How to access this reference of outer class','Inner Classes',1,NULL),(479,'public class Hello {\n\n    public static void main(String[] args) {\n       LifeTime lt = new LifeTime();\n       Gym.BasketBallCourt bc = lt.new BasketBallCourt();\n       \n    }\n\n}\n\nclass Gym{\n    public int weights = 8000;\n    public String name = \"Max\'s gym\";\n    public int price = 50;\n    \n    public void pitch(){\n        BasketBallCourt bc = new BasketBallCourt();\n        System.out.println(\"Were the best gym\");\n    }\n    \n    protected class BasketBallCourt {\n        public String name = \"Maxs court\";\n        \n        public void collectBalls(){\n            System.out.println(\"gimmmie all the balls!\");\n        }\n        \n        public void showCourt(){\n            System.out.println(\" \"+name);\n            System.out.println(\"oooh ahhh\");\n        }\n        \n        public void gymPrice(){\n            System.out.println(\" \"+Gym.this.name);\n            System.out.println(Gym.this.price);\n        }\n        \n        public int Scoreboard(){\n            return 114;\n        }\n    }\n}\n\nclass LifeTime extends Gym{\n    public void showLifeTimesCourt(){\n        final int time = 530;\n        class SalesRep{\n            public void appointment(){\n                System.out.println(\"The time of our appointment is: \"+time);\n            }\n            \n        }\n        SalesRep sr = new SalesRep();\n        sr.appointment();\n        BasketBallCourt b = new BasketBallCourt();\n        b.showCourt();\n    }\n}','compiles fine','Inner Classes',1,NULL),(480,'package hello;\n\nimport java.awt.Container;\nimport java.awt.EventQueue;\nimport java.awt.event.ActionEvent;\nimport java.awt.event.InputEvent;\nimport java.awt.event.KeyEvent;\nimport java.io.IOException;\nimport java.io.Serializable;\nimport java.nio.file.DirectoryStream;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Hashtable;\nimport java.util.Iterator;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.NavigableMap;\nimport java.util.PriorityQueue;\nimport java.util.Set;\nimport java.util.SortedMap;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport javax.swing.AbstractAction;\nimport javax.swing.GroupLayout;\nimport javax.swing.InputMap;\nimport javax.swing.JButton;\nimport javax.swing.JComponent;\nimport javax.swing.JFrame;\nimport javax.swing.JPanel;\nimport javax.swing.KeyStroke;\n\npublic class Hello {\n\n    public static void main(String[] args) {\n       LifeTime lt = new LifeTime();\n       Gym.BasketBallCourt bc = lt.new BasketBallCourt();\n       \n    }\n\n}\n\nclass Gym{\n    public int weights = 8000;\n    public String name = \"Max\'s gym\";\n    public int price = 50;\n    \n    public void pitch(){\n        BasketBallCourt bc = new BasketBallCourt();\n        System.out.println(\"Were the best gym\");\n    }\n    \n    protected class BasketBallCourt {\n        public String name = \"Maxs court\";\n        \n        public void collectBalls(){\n            System.out.println(\"gimmmie all the balls!\");\n        }\n        \n        public void showCourt(){\n            System.out.println(\" \"+name);\n            System.out.println(\"oooh ahhh\");\n        }\n        \n        public void gymPrice(){\n            System.out.println(\" \"+Gym.this.name);\n            System.out.println(Gym.this.price);\n        }\n        \n        public int Scoreboard(){\n            return 114;\n        }\n    }\n}\n\nclass LifeTime extends Gym{\n    public void showLifeTimesCourt(){\n        int time = 530;\n        class SalesRep{\n            public void appointment(){\n                System.out.println(\"The time of our appointment is: \"+time);\n            }\n            \n        }\n        SalesRep sr = new SalesRep();\n        sr.appointment();\n        BasketBallCourt b = new BasketBallCourt();\n        b.showCourt();\n    }\n}\n\n\n','compilation fails, non final local variable is access from Method local inner \nclass.','Inner Classes',1,NULL),(481,'class Gym{\n    public int weights = 8000;\n    public String name = \"Max\'s gym\";\n    public int price = 50;\n    \n    public void pitch(){\n        BasketBallCourt bc = new BasketBallCourt();\n        System.out.println(\"Were the best gym\");\n    }\n    \n    protected class BasketBallCourt {\n        public String name = \"Maxs court\";\n        \n        public void collectBalls(){\n            System.out.println(\"gimmmie all the balls!\");\n        }\n        \n        public void showCourt(){\n            System.out.println(\" \"+name);\n            System.out.println(\"oooh ahhh\");\n        }\n        \n        public void gymPrice(){\n            System.out.println(\" \"+Gym.this.name);\n            System.out.println(Gym.this.price);\n        }\n        \n        public int Scoreboard(){\n            return 114;\n        }\n    }\n}\n\nclass LifeTime extends Gym{\n    public void showLifeTimesCourt(){\n        int time = 530;\n        protected class SalesRep{\n            public void appointment(){\n                System.out.println(\"The time of our appointment is: \"+time);\n            }\n            \n        }\n        SalesRep sr = new SalesRep();\n        sr.appointment();\n        BasketBallCourt b = new BasketBallCourt();\n        b.showCourt();\n    }\n}','Method inner classes cannot be declared protected public private or static','Inner Classes',1,NULL),(482,'public class Hello {\n    public static void main(String[] args) {\n       Gym g = new LifeTime() {\n           public void showLifeTimeCourt(){\n               System.out.println(\"LT on meridean\");\n           }\n       };\n    }\n}\n\nclass Gym{\n    public int weights = 8000;\n    public String name = \"Max\'s gym\";\n    public int price = 50;\n    \n    public void pitch(){\n        BasketBallCourt bc = new BasketBallCourt();\n        System.out.println(\"Were the best gym\");\n    }\n    \n    static class BasketBallCourt {\n        public String name = \"Maxs court\";\n        \n        public void collectBalls(){\n            System.out.println(\"gimmmie all the balls!\");\n        }\n        \n        public void showCourt(){\n            System.out.println(\" \"+name);\n            System.out.println(\"oooh ahhh\");\n        }\n        \n        public void gymPrice(){\n\n        }\n        \n        public int Scoreboard(){\n            return 114;\n        }\n    }\n}\n\nclass LifeTime extends Gym{\n    \n    public void showLifeTimesCourt(){\n        final int time = 530;\n        BasketBallCourt bc = new BasketBallCourt();\n        bc.collectBalls();\n    }\n}','This compiles fine, you can create an anonymous inner class with a subclass\nthen assign it to a superclass reference. ','Inner Classes',1,NULL),(483,'public class Hello {\n    public static void main(String[] args) {\n        \n        AquaticLife shark = new Shark(){\n            String unknown = \"unknown species\";\n            public void species(){\n                System.out.println(unknown);\n            }\n        };\n        \n        shark.swim();\n        shark.devourSeal();\n  \n    }\n}\n\nclass AquaticLife{ \n    public void swim(){ \n        System.out.println(\"Bubbles\");\n    }\n     \n    public void useGills(){\n        System.out.println(\"ahhh\");\n    }\n}\n\nclass Shark extends AquaticLife{\n    public void devourSeal(){\n        System.out.println(\"chomp\");\n    }\n    \n    public void swin(){\n        System.out.println(\"Swims up to 60mph\");\n    }\n    public void electricSense(){\n        System.out.println(\"I can feel you in the water\");\n    }\n}','shark.devourSeal() does not compile. \n\nthe anonymous class is declared with a reference type of AquaticLife\nso you can only use methods of that class','Inner Classes',1,NULL),(484,'class AquaticLife{ \n    public void swim(){ \n        System.out.println(\"Bubbles\");\n    }\n     \n    public void useGills(){\n        System.out.println(\"ahhh\");\n    }\n    \n    class BottomFeeder extends AquaticLife {\n        public void useGills(){\n            System.out.println(\"I dont have gills\");\n        }\n    }\n}','an inner class can extend the outlying classs','Inner Classes',1,NULL),(485,'which are true about a method local inner class ?\n\nIt must be marked final\nIt can be marked abstract\nIt can be marked public \nIt can be marked static \nIt can access private members of the enclosing class','It can be abstract,\n	that would mean a concrete class would have to be created in the \n	method so that would probably not be very useful\n\nIt can access private members of the enclosing class\n--------------------------------------------------------\nIt can be marked final but it doesnt\' have to be\n\na method local inner class cannot be marked public, or static','Inner Classes',1,NULL),(486,'public class TestObj {\n	public static void main(SA){\n		Object ob = new Object() {\n			public boolean equals(Object ob){\n				return true;\n			}\n		}\n		sout(ob.equals(\"FRED\");\n	}\n}','Compilation fails with an error at the line where the semicolon should be \nafter the inner class','Inner Classes',1,NULL),(487,'public class HorseTest {\n	public static void main(SA){\n		class Horse {\n			public String name;\n			public Horse(String s) {\n				name = s;\n			}\n		}\n		Object ob = new Horse(\"Zippo\");\n		sout(ob.name);\n	}\n}','compilation fails at sout(ob.name);\n\nif the reference variable is of type Object you can only access members \ndefined class Object','Inner Classes',1,NULL),(488,'public abstract class AbstractTest {\n	public int getNum(){\n		return 45;\n	}\n	public abstract class Bar {\n		public int getNum(){\n			return 38;\n		}\n	}\n	public staic void main(String[] args) {\n		AbstractTest t = new AbstractTest(){\n			public int getNum() {\n				return 22;\n			}\n		};\n		AbstractTest.Bar f = t.new Bar() {\n			public int getNum(){\n				return 57;\n			}\n		};\n		sout(f.getNum() + \" \" + t.getNum() );\n	}\n}','57 22\n\nto create an instance of an inner class you have to create it with an \nouter class reference here AbstractTest is abstract so it had to be\ninstantiated with an anonymous inner class to have a concrete reference\nto tie the new anonymous class of type Bar to. ','Inner Classes',1,NULL),(489,'public class Tour {\n	public static void main(SA){\n		Cathedral c = new Cathedral();\n		// insert code\n		s.go();\n	}\n}\n\nclass Cathedral {\n	class Sanctum {\n		void go() { sout(\"spooky\"); }\n	}\n}\n\nproperly instantiate Sanctume','Cathedral.Sanctum s = c.new Sanctum();\n\nor\n\nCathedral.Sanctum s1 = new Cathedral().new Sanctum();','Inner Classes',1,NULL),(490,'public abstract class Hello {\n    public static void main(String[] args) {\n        new Hello().test();\n        \n    }\n    \n    void test() {\n        class Breaker{ void foo(){ System.out.println(\"Inner\"); } }\n    }\n    \n    class Breaker {\n        void foo(){\n            System.out.println(\"middle\");\n        }\n    }\n}\n\nclass Breaker{\n    void foo(){\n        System.out.println(\"Outer\");\n    }\n    \n}','Will not compile Hello is abstract cannot be instantiated lol ','Inner Classes',1,NULL),(491,'public class Hello {\n    public static void main(String[] args) {\n        new Hello().test();\n        \n    }\n    \n    void test() {\n        new Breaker().foo();\n        class Breaker{ void foo(){ System.out.println(\"Inner\"); } }\n    }\n    \n    class Breaker {\n        void foo(){\n            System.out.println(\"middle\");\n        }\n    }\n}\n\nclass Breaker{\n    void foo(){\n        System.out.println(\"Outer\");\n    }\n    \n}','middle\n\nThe closest scoped class is middle. The inner class is declared after the\ncall to foo() and the Outer class comes after any inner classes','Inner Classes',1,NULL),(492,'public class Hello {\n    public static void main(String[] args) {\n        blue.biteHook();\n        \n        BlueGill blue = new BlueGill(){\n            public void biteHook(){\n                System.out.println(\"Not This Time\");\n            }\n        }\n        \n    }\n    \n    BlueGill bigBlue = new BlueGill(){\n        public int bubble() throws IOException {\n            System.out.println(\"Big Bubbles\");\n            return 5;\n        }\n        \n    };\n}\n\nabstract class Fish {\n    public abstract void swim();\n    private abstract int numberOfFins();\n    \n}\n\nclass BlueGill extends Fish {\n    public void swim(){\n        System.out.println(\"Swims in lakes\");\n    }\n    \n    public void biteHook() throws IOException {\n        System.out.println(\"What the hell\");\n    }\n    \n    public int bubble() throws Exception{\n        System.out.println(\"bubble bubble\");\n        return 2;\n    }\n}','the call to blue in main fails because it is called before the anon class\nis created. \n\nanonymous class bigBlue works fine, you can define anonymous classes as\nmembers \n\nalso anon class blue forgets to end with a ; \n\nabsract classes cannnot have private abstract members, how would they\nbe instantiated ?\n\nbecaue of that BlueGill cannot properly override method numberOfFins()\n\nan overriding method can choose not to throw the same exception or can \nthrow a narrower one. \n','Inner Classes',1,NULL),(493,'public class Hello {\n    public static void main(String[] args) {     \n        BlueGill blue = new BlueGill(){\n            public void biteHook() throws IOException{\n                System.out.println(\"Not This Time\");\n            }\n            public void biteHook(boolean yesno) throws NullPointerException{\n                System.out.println(\"That worm looks so tasty\");\n            }\n            \n        };\n        \n    }\n}\n\nabstract class Fish {\n    public abstract void swim() throws Exception;\n    public abstract int numberOfFins();\n    public static void breathe(){\n        System.out.println(\"ahhh\");\n    }\n    \n    \n}\n\nclass BlueGill extends Fish {\n    public void swim(){\n        breathe();\n        System.out.println(\"Swims in lakes\");\n    }\n    \n    public void biteHook() throws IOException {\n        System.out.println(\"What the hell\");\n    }\n    \n    public int numberOfFins() throws SQLException {\n        return 4;\n    }\n    \n    public int bubble() throws Exception{\n        System.out.println(\"bubble bubble\");\n        return 2;\n    }\n}','numberOfFins() in abstract class Fish does not throw SQLException\n	so the override in BlueGill cannot throw a new Exception.\n\nbiteHook is declared in BlueGill then overriden in the annon class with\nthe same exception so its ok.\n\nthen the anon class does not override the method numberOfFins which was \nnot properly overriden in the abstract class so that makes the anon class\nnot compile. If it had overriden numberOfFins() then it could have compiled\n\nstill though the NOF in BlueGill threw that SQLException so it wont ever compile..','Inner Classes',1,NULL),(494,'public class  Car {\n	class Engine {\n		// insert here\n	}\n	public static void main(SA){\n		new Car().go();\n	}\n	void go() {\n		new Engine();\n	}\n	void drive() { sout(\"hi\"); }\n}\n\n// what can be given at insert here to produce \"hi\" ?\n','{ Car.this.drive(); }\n\nEngine() { Car.this.drive(); }','Inner Classes',1,NULL),(495,'public class City {\n	class Manhattan {\n		void doStuff() throws Exception { sout(\"x \"); }\n	}\n	class Timesquare extends Manhattan {\n		void doStuff throws Exception {  }\n	}\n\n	public static void main(Stringp]] args) throws Exception{\n		new City().go();\n	}\n	void go() throws Exception { new Timesquare().doStuff(); }\n}','no output is produced, the inner classes are valid and the exceptions are \nthrown properly','Inner Classes',1,NULL),(496,'public class Navel {\n	private int size = 7;\n	private static int length = 3;\n	public static void main(String[] args) {\n		new Navel().go();\n	}\n	void go(){\n		int size = 5;\n		sout( new Gazer().adder() );\n	}\n	class Gazer {\n		int adder() { return size * length; }\n	}\n}	','21','Inner Classes',1,NULL),(497,'public class Hello {\n    public static void main(String[] args) {     \n        BlueGill blue = new BlueGill();\n        blue.breathe();\n        blue.swim();\n        \n    }\n}\n\nabstract class Fish {\n    public abstract void swim() throws Exception;\n    public abstract int numberOfFins();\n    public static void breathe(){\n        System.out.println(\"ahhh\");\n    }   \n}\n\nclass BlueGill extends Fish {\n    public void swim(){\n        breathe();     \n        System.out.println(\"Swims in a lake\");\n    }\n    \n    public int numberOfFins(){\n        return 5;    \n    }   \n}','ahhh\nahhh\nSwims in a lake','Inner Classes',1,NULL),(498,'public class Hello {\n    public static void main(String[] args) {     \n        BlueGill blue = new BlueGill();\n        \n        Fish.breathe();\n        \n    }\n}\n\nabstract class Fish {\n    public abstract void swim() throws Exception;\n    public abstract int numberOfFins();\n    public static void breathe(){\n        System.out.println(\"ahhh\");\n    }   \n}\n\nclass BlueGill extends Fish {\n    public void swim(){\n        breathe();     \n        System.out.println(\"Swims in a lake\");\n    }\n    \n    public int numberOfFins(){\n        return 5;    \n    }   \n}','ahhh','Inner Classes',1,NULL),(499,'abstract class Fish {\n    public static int species = 100;\n    public abstract void swim() throws Exception;\n    public abstract int numberOfFins();\n    public static void breathe(){\n        System.out.println(\"ahhh\");\n    }   \n}\n\nclass BlueGill extends Fish {\n    public void swim(){\n        breathe();     \n        System.out.println(species);\n        System.out.println(\"Swims in a lake\");\n    }\n    \n    public int numberOfFins(){\n        return 5;    \n    }   \n}','compiles','Inner Classes',1,NULL),(500,'public class Pockets {\n	public static void main(SA){\n		String[] sa = {\"nickle\",\"button\", \"key\", \"lint\" };\n		Sorter s = new Sorter();\n		for(String s2: sa) sout( s2+\" \" );\n		Arrays.sort(sa,s);\n		sout();\n		for(String s2 : sa) sout( s2+\" \" );\n		\n	}\n	class Sorter implements Comparator<String> {	\n		public int compare(String a, String b) {\n			return b.compareTo(a);\n		}\n	}\n}','compilation fails, \nClass sorter must be delcared static to be used in static methood main. ','Collections',1,NULL),(501,'public class Hello {\n    public static void main(String[] args) {     \n        BlueGill blue = new BlueGill();\n        blue.swim();\n        \n    }\n}\nclass BlueGill extends Fish {\n    public void swim(){\n        breathe();     \n        System.out.println(species);\n        System.out.println(\"Swims in a lake\");\n    }\n    \n    public int numberOfFins(){\n        return 5;    \n    }   \n}\n\nabstract class Fish {\n    public static int species = 100;\n    public abstract void swim() throws Exception;\n    public abstract int numberOfFins();\n    public static void breathe(){\n        System.out.println(\"ahhh\");\n    }   \n}\n   ','ahhh\n100\nSwims in a lake','Inner Classes',1,NULL),(502,'public class Hello {\n    public static void main(String[] args) {     \n        BlueGill blue = new BlueGill();\n        blue.swim();\n        \n    }\n class BlueGill extends Fish {\n    public void swim(){\n        breathe();     \n        System.out.println(species);\n        System.out.println(\"Swims in a lake\");\n    }\n    \n    public int numberOfFins(){\n        return 5;    \n    }   \n}\n}\n\nabstract class Fish {\n    public static int species = 100;\n    public abstract void swim() throws Exception;\n    public abstract int numberOfFins();\n    public static void breathe(){\n        System.out.println(\"ahhh\");\n    }   \n}','will not compile, BlueGill is an inner class therefor must be declared static\nto be used in static method main. ','Inner Classes',1,NULL),(503,'public class Hello {\n    public static void main(String[] args) {     \n        BlueGill blue = new BlueGill();\n        blue.swim();\n        \n    }\n static class BlueGill extends Fish {\n    public void swim(){\n        breathe();     \n        System.out.println(species);\n        System.out.println(\"Swims in a lake\");\n    }\n    \n    public int numberOfFins(){\n        return 5;    \n    }   \n}\n}\n\nabstract class Fish {\n    public static int species = 100;\n    public abstract void swim() throws Exception;\n    public abstract int numberOfFins();\n    public static void breathe(){\n        System.out.println(\"ahhh\");\n    }   \n}','ahhh\n100\nSwims in lake','Inner Classes',1,NULL),(504,'public class Hello {\n    public static void main(String[] args) {     \n        Locker<SchoolSupplies> locker = new Locker<>();\n        locker.stuff.add(new Book(\"AAA\"));\n        locker.stuff.add(new Book(\"BBB\"));\n        \n        System.out.println(locker.getOut(new Book(\"AAA\")));\n        \n    }\n}\n\nclass Locker<T> {\n    ArrayList<T> stuff = new ArrayList<T>();\n    public T getOut(T that){\n        return stuff.get(that);\n    }\n}\n\nabstract class SchoolSupplies{\n    public abstract void use();\n    public abstract int lend();\n    public abstract boolean isCool();\n}\n\nclass Book extends SchoolSupplies{\n    private String name;\n    Book(String n){\n        name = n;\n    }\n    public void use(){\n        System.out.println(\"Read it\");\n    }\n    \n    public int lend(){\n        System.out.println(\"I need back by 4th\");\n        return 4;\n    }\n    \n    public boolean isCool(){\n        return false;\n    }\n}\n\nclass Pen extends SchoolSupplies {\n    public void use(){\n        System.out.println(\"doodle\");\n    }\n    \n    public int lend(){\n        System.out.println(\"just have it\");\n        return null;\n    }\n    \n    public boolean isCool(){\n        return true;\n    }\n}','Arraylist doesn\'t have a method that returns the given object. \n\nalso you cannot return null when the return type is primitive.','Inner Classes',1,NULL),(505,'public class Hello {\n    public static void main(String[] args) {     \n\n        List<Animal> animals = new ArrayList<Animal>();\n        animals.add(new Dog());\n        animals.add(new Cat());\n        \n        addAnimal(animals);\n    \n    }\n    \n    public static void addAnimal(List animals) {\n	animals.add(new Object());\n    }\n}','compiles with a warning','Generics',1,NULL),(506,'public class Hello {\n    public static void main(String[] args) {     \n\n        Animal a = new Animal(6,\"dog\");\n        System.out.println(a.getSize());\n    \n    }\n\n}\n        \nclass Animal implements Comparable<Animal>{\n    private int size;\n    private String name;\n    public Animal(int s, String n){\n        size = s;\n        name = n;\n        \n    }\n    public int getSize(){\n        return size;\n    }\n    public int compareTo(Animal a){\n        int asize = a.getSize();\n        int bsize = this.size;\n        \n        if(asize < bsize)\n            return 1;\n        else if(asize == bsize)\n            return 0;\n        else\n            return -1;\n        \n        \n    }\n    \n    public String toString(){\n        return name;\n    }\n}\n\nclass Dog extends Animal{}\nclass Cat extends Animal{} ','will not compile,\n\ndefault constructors in Dog and Cat do not give proper calls to super()\nanimal non-defautl constructor','General',1,NULL),(507,'public class Hello {\n    public static void main(String[] args) {     \n        List<Spankable> spanklist = new ArrayList<>();\n        spanklist.add(new Doll());\n        spanklist.add(new Doll());\n        \n    }\n    \n    public static void runit(List<? extends Shaveable> sList){\n        for(Spankable s : sList){\n            s.shave();\n        }\n    }\n\n}\n\ninterface Shaveable{\n    public void shave();\n}\n\ninterface Spankable extends Shaveable{\n    public void spank();\n}\n\nclass Doll implements Spankable{\n    public void spank(){\n        System.out.println(\"OW!\");\n    }\n    \n    public void shave(){\n        System.out.println(\"HMMM : O\");\n    }\n}','will not compile,\n\n	should be...\n		for(Shaveable s : sList){\n			...','General',1,NULL),(508,'public class Hello {\n    public static void main(String[] args) {     \n        List<Spankable> spanklist = new ArrayList<>();\n        spanklist.add(new Doll());\n        spanklist.add(new Doll());\n        \n    }\n    \n    public static void runit(List<? extends Shaveable> sList){\n        for(Shaveable s : sList){\n            s.shave();\n        }\n    }\n\n}\n\ninterface Shaveable{\n    public void shave();\n}\n\ninterface Spankable extends Shaveable{\n    public void spank();\n}\n\nclass Doll implements Spankable{\n    public void spank(){\n        System.out.println(\"OW!\");\n    }\n    \n    public void shave(){\n        System.out.println(\"HMMM : O\");\n    }\n}','compiles\n\nhmmm : O\nhmmm : O','General',1,NULL),(509,'public class Hello {\n    public static void main(String[] args) {     \n        List<Spankable> spanklist = new ArrayList<>();\n        spanklist.add(new Doll());\n        spanklist.add(new Doll());\n        \n        runit(spanklist);\n        \n    }\n    \n    public static void runit(List<? extends Spankable> sList){\n        for(Shaveable s : sList){\n            s.shave();\n        }\n    }\n\n}\n\ninterface Shaveable{\n    public void shave();\n}\n\ninterface Spankable extends Shaveable{\n    public void spank();\n}\n\nclass Doll implements Spankable{\n    public void spank(){\n        System.out.println(\"OW!\");\n    }\n    \n    public void shave(){\n        System.out.println(\"HMMM : O\");\n    }\n}','HMMM : O\nHMMM : O\n\n','General',1,NULL),(510,'class Hello {\n    public static void main(String[] args) {     \n        List<Spankable> spanklist = new ArrayList<>();\n        spanklist.add(new Doll());\n        spanklist.add(new Doll());\n        \n        runit(spanklist);\n        \n    }\n    \n    public static void runit(List<? extends Shaveable> sList){\n        for(Shaveable s : sList){\n            s.shave();\n        }\n    }\n\n}\n\ninterface Shaveable{\n    public void shave();\n}\n\ninterface Spankable extends Shaveable{\n    public void spank();\n}\n\nclass Doll implements Spankable{\n    public void spank(){\n        System.out.println(\"OW!\");\n    }\n    \n    public void shave(){\n        System.out.println(\"HMMM : O\");\n    }\n}                     ','HMMM : O\nHMMM : O','General',1,NULL),(511,'class Hello {\n    public static void main(String[] args) {     \n        List<Doll> spanklist = new ArrayList<>();\n        spanklist.add(new Doll());\n        spanklist.add(new Doll());\n        \n        runit(spanklist);\n        \n    }\n    \n    public static void runit(List<? extends Shaveable> sList){\n        for(Shaveable s : sList){\n            s.shave();\n        }\n    }\n\n}\n\ninterface Shaveable{\n    public void shave();\n}\n\ninterface Spankable extends Shaveable{\n    public void spank();\n}\n\nclass Doll implements Spankable{\n    public void spank(){\n        System.out.println(\"OW!\");\n    }\n    \n    public void shave(){\n        System.out.println(\"HMMM : O\");\n    }\n}                  ','HMMM : O\nHMMM : O','General',1,NULL),(512,'class Hello {\n    public static void main(String[] args) {     \n        Path p1 = Paths.get(\"/home/max/tmp\");\n        Path p2 = Paths.get(\"/tmp/google/file.txt\");\n        System.out.println(p1.resolve(p2));\n        \n    }\n\n}','/tmp/google/file.txt','General',1,NULL),(513,'class Hello {\n    public static void main(String[] args) {     \n        Path p1 = Paths.get(\"/home/max/tmp\");\n        Path p2 = Paths.get(\"tmp/google/file.txt\");\n        System.out.println(p1.resolve(p2));\n        \n    }\n\n}','/home/max/tmp/tmp/google/file.txt','Input/Output',1,NULL),(514,'class Hello {\n    public static void main(String[] args) {     \n        Path p1 = Paths.get(\"/home/max/tmp\");\n        Path p2 = Paths.get(\"google/file.txt\");\n        System.out.println(p1.resolve(p2));\n        \n    }\n\n}','/home/max/tmp/google/file.txt','Input/Output',1,NULL),(515,'class Hello {\n    public static void main(String[] args) {     \n        Path p1 = Paths.get(\"/home/max/tmp\");\n        Path p2 = Paths.get(\"file.txt\");\n        System.out.println(p1.resolve(p2));\n        \n    }\n\n}','/home/max/tmp/file.txt','General',1,NULL),(516,'class Hello {\n    public static void main(String[] args) {     \n        Path p1 = Paths.get(\"home/max/tmp\");\n        Path p2 = Paths.get(\"file.txt\");\n        System.out.println(p1.resolve(p2));\n        \n    }\n\n}','home/max/tmp/file.txt','General',1,NULL),(517,'class Hello {\n    public static void main(String[] args) {     \n        Path p1 = Paths.get(\"home/max/tmp/file.txt\");\n        Path p2 = Paths.get(\"file.txt\");\n        System.out.println(p1.resolve(p2));\n        \n    }\n\n}','home/max/tmp/file.txt/file.txt','General',1,NULL),(518,'class Hello {\n    public static void main(String[] args) {     \n        Path p1 = Paths.get(\"\");\n        Path p2 = Paths.get(\"file.txt\");\n        System.out.println(p1.resolve(p2));\n        \n    }\n\n}','file.txt','General',1,NULL),(519,'class Hello {\n    public static void main(String[] args) {     \n        Path p1 = Paths.get(\"home/max/tmp/file.txt\");\n        Path p2 = Paths.get(\"\");\n        System.out.println(p1.resolve(p2));\n        \n    }\n\n}','home/max/tmp/file.txt','General',1,NULL),(520,'class Hello {\n    public static void main(String[] args) {     \n        Path p1 = Paths.get(\"home/max/tmp/file.txt\");\n        Path p2 = Paths.get(\"file.txt\");\n        System.out.println(p2.resolve(p1));\n        \n    }\n\n}','file.txt/home/max/tmp/file.txt','General',1,NULL),(521,'public class Hello<T> {\n    public static void main(String[] args){\n\n        ArrayList<? extends Animal> c = makeArrayList(new Animal(5));\n        \n        Animal max = new Animal(100);\n        Animal bear = new Animal(45);\n        Animal Hippo = new Animal(45);\n        \n        System.out.println(bear.equals(Hippo));    \n    } \n    public static <G extends Animal> ArrayList<G> makeArrayList(G g){\n        ArrayList<G> genlist = new ArrayList();\n        genlist.add(g);\n        return genlist;\n        \n    }\n}\n\nclass Animal{\n    private int size;\n    public Animal(int s){\n        size = s;\n    }\n    public void makeSound(){\n            System.out.println(\"Sound!\");\n            \n    }\n    \n    public int getSize(){\n        return size;\n    }\n\n    public boolean equals(Object o){\n        // equals without instanceof \n        if(((Animal)o).getSize() == this.size){\n            return true;\n        } else {\n            return false;\n        }\n        \n    }\n}\n\nclass Flower {\n    public void pretty(){\n        System.out.println(\"i look so pretty\");\n    }\n}','true\n\nHowever Animal does not have an instanceof test in its boolean so be \ncareful you could get a classcastexception','General',1,NULL),(522,'public class Hello<T> {\n    public static void main(String[] args){\n\n        ArrayList<? extends Animal> c = makeArrayList(new Animal(5));\n        \n        Animal max = new Animal(100);\n        Animal bear = new Animal(45);\n        Animal Hippo = new Animal(45);\n        Flower flower = new Flower();\n        \n        System.out.println(bear.equals(Hippo));  \n        System.out.println(max.equals(flower));\n    } \n    public static <G extends Animal> ArrayList<G> makeArrayList(G g){\n        ArrayList<G> genlist = new ArrayList();\n        genlist.add(g);\n        return genlist;\n        \n    }\n}\n\nclass Animal{\n    private int size;\n    public Animal(int s){\n        size = s;\n    }\n    public void makeSound(){\n            System.out.println(\"Sound!\");\n            \n    }\n    \n    public int getSize(){\n        return size;\n    }\n\n    public boolean equals(Object o){\n        // equals without instanceof \n        if(((Animal)o).getSize() == this.size){\n            return true;\n        } else {\n            return false;\n        }\n        \n    }\n}\n\nclass Flower {\n    public void pretty(){\n        System.out.println(\"i look so pretty\");\n    }\n}','ClassCastException','General',1,NULL),(523,'class Foo {\n    public static void classMethod() {\n        System.out.println(\"classMethod() in Foo\");\n    }\n \n    public void instanceMethod() {\n        System.out.println(\"instanceMethod() in Foo\");\n    }\n}\n \nclass Bar extends Foo {\n    public static void classMethod() {\n        System.out.println(\"classMethod() in Bar\");\n    }\n \n    public void instanceMethod() {\n        System.out.println(\"instanceMethod() in Bar\");\n    }\n}\n  \nclass Test {\n    public static void main(String[] args) {\n        Foo f = new Bar();\n        f.instanceMethod();\n        f.classMethod();\n    }\n}','instanceMethod() in Bar\nclassMethod() in Foo\n\nBriefly, when you override a method, you still get the benefits of run-time polymorphism, and when you hide, you don\'t\n\nWhy do we get instanceMethod from Bar, but classMethod() from Foo? Aren\'t we using the same instance f to access both of these? Yes we are - but since one is overriding and the other is hiding, we see different behavior.\n\nSince instanceMethod() is (drum roll please...) an instance method, in which Bar overrides the method from Foo, at run time the JVM uses the actual class of the instance f to determine which method to run. Although f was declared as a Foo, the actual instance we created was a new Bar(). So at runtime, the JVM finds that f is a Bar instance, and so it calls instanceMethod() in Bar rather than the one in Foo. That\'s how Java normally works for instance methods.\n\nWith classMethod() though. since (ahem) it\'s a class method, the compiler and JVM don\'t expect to need an actual instance to invoke the method. And even if you provide one (which we did: the instance referred to by f) the JVM will never look at it. The compiler will only look at the declared type of the reference, and use that declared type to determine, at compile time, which method to call. Since f is declared as type Foo, the compiler looks at f.classMethod() and decides it means Foo.classMethod. It doesn\'t matter that the instance reffered to by f is actually a Bar - for static methods, the compiler only uses the declared type of the reference. That\'s what we mean when we say a static method does not have run-time polymorphism.\n\nBecause instance methods and class methods have this important difference in behavior, we use different terms - \"overriding\" for instance methods and \"hiding\" for class methods - to distinguish between the two cases. And when we say you can\'t override a static method, what that means is that even if you write code that looks like it\'s overriding a static method (like the first Foo and Bar at the top of this page) - it won\'t behave like an overridden method. ','General',1,NULL),(524,'class Bear extends Animal{\n    private static int ALLBEARSAREBIG = 100;\n    \n    public Bear(){\n        super(ALLBEARSAREBIG);\n        \n    }\n    \n    public static void eat(){\n        System.out.println(\"Eat salmon\");\n    }\n    \n}\n\nclass Animal{\n    private int size;\n    public Animal(int s){\n        size = s;\n    }\n    public static void eat(){\n        System.out.println(\"all animals eat\");\n    }\n    public void makeSound(){\n            System.out.println(\"Sound!\");\n            \n    }\n    \n    public int getSize(){\n        return size;\n    }\n\n    public boolean equals(Object o){\n        // equals without instanceof \n        if(((Animal)o).getSize() == this.size){\n            return true;\n        } else {\n            return false;\n        }\n        \n    }\n}\n\npublic class Hello<T> {\n    public static void main(String[] args){\n        Animal cat = new Animal(5);\n        Animal bear = new Bear();\n        \n        cat.eat();\n        Animal.eat();\n        bear.eat();\n        Bear.eat();\n\n    } \n }','all animals eat\nall animals eat\nall animals eat\nEat salmon\n\nIt is allowed to call a static method of the class on an instance \nvariable, but it is confusing and not recomneded. \n\nstatic variables are not overriden by subclass methods they are hidden\n\nso, at runtime there will be no polymorphism for static methods','General',1,NULL),(525,'public class Hello<T> {\n    public static void main(String[] args){\n        Animal cat = new Animal(5);\n        Animal bear = new Bear();\n        \n        cat.eat();\n        Animal.eat();\n        bear.eat();\n        Bear.eat();\n\n    } \n }\n\nclass Animal{\n    private int size;\n    public Animal(int s){\n        size = s;\n    }\n    public static void eat(){\n        System.out.println(\"all animals eat\");\n    }\n    public void makeSound(){\n            System.out.println(\"Sound!\");\n            \n    }\n    \n    public int getSize(){\n        return size;\n    }\n\n    public boolean equals(Object o){\n        // equals without instanceof \n        if(((Animal)o).getSize() == this.size){\n            return true;\n        } else {\n            return false;\n        }\n        \n    }\n}\n\nclass Bear extends Animal{\n    private static int ALLBEARSAREBIG = 100;\n    \n    public Bear(){\n        super(ALLBEARSAREBIG);\n        \n    }\n    \n    public void eat(){\n        System.out.println(\"Eat salmon\");\n    }\n    \n}','will not compile you cannot override a static method\n\nto fix change eat in Bear to static or do something else with the other class\nand varialbes','General',1,NULL),(526,'public class Hello<T> {\n    public static void main(String[] args){\n        Animal cat = new Animal(5);\n        Animal bear = new Bear();\n        \n        cat.eat();\n        Animal.eat();\n        bear.eat();\n        Bear.eat();\n\n    } \n }\n\nclass Animal{\n    private int size;\n    public Animal(int s){\n        size = s;\n    }\n    public static void eat(){\n        System.out.println(\"all animals eat\");\n    }\n    public void makeSound(){\n            System.out.println(\"Sound!\");\n            \n    }\n    \n    public int getSize(){\n        return size;\n    }\n\n    public boolean equals(Object o){\n        // equals without instanceof \n        if(((Animal)o).getSize() == this.size){\n            return true;\n        } else {\n            return false;\n        }\n        \n    }\n}\n\nclass Bear extends Animal{\n\n    \n    public Bear(){\n        \n    }\n    \n    public static void eat(){\n        System.out.println(\"Eat salmon\");\n    }\n    \n}\n\nclass Flower {\n    public void pretty(){\n        System.out.println(\"i look so pretty\");\n    }\n}','will not compile,\n\ncall to super in Bear defautl constructor does not fit with ANimal int constructor\n\nremeber if you provide a parameterized constructor the implicit defautl one\ngoes away','General',1,NULL),(527,'Path p1 = Paths.get(\"/home/maxbisesi/file.txt\");\n        System.out.println(p1.resolve(null));','Will not compile, reference to resolve is ambiguous. \n\nboth resolve(String) and resolve(Path) match','Input/Output',1,NULL),(528,'public class Hello {\n\n    public static void main(String[] args) {\n        \n        Burnable stick = new Burnable(){\n            int people = 8;\n            public void burn(){\n                System.out.println(\"Theres \"+people+\" people here so get the fire going\");\n            }\n            \n            public int unburn(){\n                System.out.println(\"That\'s impossible\");\n                return 0;\n            }\n            \n            public void shakeoff(int x){\n                System.out.println(\"That was my shoe!\"+x);\n            }\n            \n            public void shakeoff(){\n                \n                this.shakeoff(4);\n                System.out.println(\"its off\");\n            }\n            \n            \n            \n        };\n        \n        stick.burn();\n    }\n\n}\n\ninterface Burnable{\n    int people = 10;\n    void burn();\n    void shakeoff(int z);\n    int unburn();\n}','Compiles fine! you can use the overloaded method within the inner class\n\nTheres 8 people here so get the fire going','Inner Classes',1,NULL),(529,'The thread is the worker and the runnable is the job to be done','','Threads',1,NULL),(530,'Thread Constructors','Thread()\nThread(Runnable target)\nThread(Runnable target, String name)\nThread(String name)','Threads',1,NULL),(531,'When is a thread considered dead?','after the run() is complete','Threads',1,NULL),(532,'Nothing is guarenteed in threading other than Each thread will start and each thread\nwill run to completion. ','It is not guarenteed that the threads will be started in the order that\nthey are declared. Or that they will finish and start at the same time\n\nor that a loop will complete once it has begun.','Threads',1,NULL),(533,'The order in which runnable threads are chosen to run is not guarenteed.','','Threads',1,NULL),(534,'public class Hello {\n    public static void main(String[] dicks){\n       Thread t = new Thread(new FooRunnable());\n       t.start();\n              \n\n    }\n}\n\nclass FooRunnable implements Runnable {\n    public void run(){\n        for(int x = 1; x <= 100; x++){\n            if((x % 10) == 0){\n                System.out.println(\"next 10\");\n            }\n            System.out.println(x+\" \");\n            Thread.sleep(1000); \n            }\n            \n        }\n    }\n}','Will not compile, unreported Exception InteruptedException must be caught\nor thrown. ','Threads',1,NULL),(535,'A thread gets a default priority that is the default priority of the thread of\nexecution that creates it. ','','Threads',1,NULL),(536,'FooRunnable r = new FooRunnable();\nThread t = new Thread(r);\nt.setPriority(8);\nt.start();\n','default thread priority is 5','Threads',1,NULL),(537,'Thread class constants ','Thread.MIN_PRIORITY (1)\nThread.NORM_PRIORITY (5)\nThread.MAX_PRIORITY (10)\n','Threads',1,NULL),(538,'Thread.yeild()','will cause a thread to go from running to runnable, but it might not do\nanything at all. ','Threads',1,NULL),(539,'join() is static','FALSE','Threads',1,NULL),(540,'Thread t = new Thread();\nt.start();\nt.join();','takes the currently running thread(if this were in the main method then that\nwould be the main thread) and joins it onto the end of the thread\nreferenced by t. \n\n','Threads',1,NULL),(541,'public class Hello implements Runnable{\n    private synchronized Account acct = new Account(50);\n    \n    public static void main(String[] dicks){\n       Hello h = new Hello();\n       Thread one = new Thread(h);\n       Thread two = new Thread(h);\n       one.setName(\"Max\");\n       two.setName(\"Angela\");\n       \n       one.start();\n       two.start();\n\n    }\n    \n    public void run(){\n        for(int x = 0; x < 5; x++){\n            makeWithdrawl(10);\n            if(acct.getBalance() < 0){\n                System.out.println(\"account is overdrawn\");\n            }\n        }\n    }\n    \n    private synchronized void makeWithdrawl(int amt){\n        //this operation is not atomic\n        if(acct.getBalance() >= amt){\n            System.out.println(Thread.currentThread().getName()+\" is going to withdraw\");\n            \n            try{\n                Thread.sleep(500);\n            } catch(InterruptedException e){\n                \n            }\n            \n            acct.withdraw(amt);\n            System.out.println(Thread.currentThread().getName() + \" completes the withdraw\");\n        } else {\n            System.out.println(\"insufficinet funds for: \" + Thread.currentThread().getName() );\n        }\n    }\n}','will not compile, only methods or blocks can be synchronized not variables\nor classes','Threads',1,NULL),(542,'If a thread goes to sleeep it holds any locks it has','','Threads',1,NULL),(543,'private JPanel createAddFlashCardPanel() {\n        JPanel jp = new JPanel(new FlowLayout());\n        \n        \n        JTextArea ja = new JTextArea(17,78);\n        ja.setWrapStyleWord(true);\n        JScrollPane question = new JScrollPane(ja);\n        ja.setTabSize(5);\n        ja.setFont(textfont);\n        \n        \n        AbstractDocument doc = (AbstractDocument) ja.getDocument();\n        doc.addDocumentListener(new TextChanger());\n        \n        class TextChanger implements DocumentListener {\n\n        @Override\n        public void insertUpdate(DocumentEvent e) {\n            try{\n                String addedtext = doc.getText(e.getOffset(), e.getLength());\n                System.out.println(addedtext);\n            } catch(BadLocationException blexc){\n                \n            }\n        }\n        @Override\n        public void removeUpdate(DocumentEvent e) {\n            \n        }\n        @Override\n        public void changedUpdate(DocumentEvent e) {\n            \n        }\n       \n    }\n  \n    ','will not compile, method local inner classes must be declared before they \nare used. ','Threads',1,NULL),(544,' private SwingWorker<String, String> worker = new SwingWorker<String, String>() {\n        public String doInBackground() {\n            while (!searchwords.isEmpty()) {\n                String word = searchwords.poll();\n                if(word == null){\n                    continue;\n                }\n                \n                try{\n                    ArrayList<Card> foundcards = Database.searchDatabase(word);\n                } catch (IOException e){\n                    System.out.println(\"problem serarch db\");\n                }\n\n                for (Card c : foundcards) {\n\n                }\n\n            }\n        }','will not compile, foundcards is defined only in the scope of the try{}\n\nto fix \n\nput it above try{ } ','Threads',1,NULL),(545,'public static synchronized int getCount() {\n	return count;\n}\n\nhow to could this method be re made excactly using a synchronized block ?','public static int getCount() {\n	synchronized(MyClass.class) {\n		return count;\n	}\n}\n\n- there is only one copyy of static data you\'re trying to protect so you\nonly need one lock per class to synchronize static methods- a lock for the whole class.\n\nevery class loaded in java has a corresponding instance of java.lang.Class\nrepresenting that Class. It\'s that Class instance used to lock on \nstatic methods. ','Threads',1,NULL),(546,'public class Hello extends Thread {\n   StringBuilder sb;\n    \n    public Hello(StringBuilder stb){\n        sb = stb;\n    }\n   \n    \n    public static void main(String[] dicks){\n        StringBuilder sbmain = new StringBuilder(\"A\");  \n        Hello a = new Hello(sbmain);\n        Hello b = new Hello(sbmain);\n        Hello c = new Hello(sbmain);\n        a.start();\n        b.start();\n        c.start();\n    }\n    \n    public void run(){\n        \n        synchronized(sb){\n            for(int i = 0; i < 100; i++){\n                System.out.println(sb);\n            }\n            sb.append(\"A\");  \n        }\n    }\n}','100x A\n\n100x AA\n\n100x AAA\n\nall these threads synchronize onto the same object','Threads',1,NULL),(547,'public class Hello extends Thread {\n   StringBuilder sb;\n    \n    public Hello(StringBuilder stb){\n        sb = stb;\n    }\n   \n    public static void main(String[] dicks){\n        StringBuilder sbmain = new StringBuilder(\"A\");  \n        Hello a = new Hello(sbmain);\n        Hello b = new Hello(sbmain);\n        Hello c = new Hello(sbmain);\n        a.start();\n        b.start();\n        c.start();\n    }  \n    public void run(){\n            for(int i = 0; i < 1000; i++){\n                System.out.println(i+\" \"+sb);\n            }\n            sb.append(\"A\");   \n    }\n}','un predicatable results - without synch. you cannot be sure what thread will\nwill be executing when. ','Threads',1,NULL),(548,'Threads calling non-static synchronized methods in the same class will only\nblock each other if they\'re invoked using THE SAME INSTANCE. that\'s because theyeach\nlock on this instance, and if they\'re called using two differenct instances,\nthey get two locks, which do not interfere with each other. ','got it','Threads',1,NULL),(549,'Threads calling static synchronized methods in the same class will always \nblock each other- they all lock on the same class instance. ','got it ','Threads',1,NULL),(550,'a static synchronized method and a non-static synhcronized method will not block\neach other, ever. the static method locks on a Class instance, while the non\nstatic locks on this instance. These actions do not interfere with each other.','','Threads',1,NULL),(551,'Generally use synchronization anytime more than one thread is accessing mutable\ndata. Dont worry about local varialbes each thread gets its own copy of those\nTwo threads executing the same method at the same time will use different\ncopiies of local variables.\n	However:\n		do worry about static and non sttaic fields if they contain data that \n		can be changed. ','','Threads',1,NULL),(552,'public class Hello {\n    \n   public static void main (String [] args){\n       Thing thing = new Thing();\n       \n       new Thread(new Accessor(thing),\"Max\").start();\n       new Thread(new Accessor(thing),\"Bart\").start();\n       new Thread(new Accessor(thing),\"Thread C\").start();\n \n   }\n}\n\nclass Accessor implements Runnable{\n    private Thing thisthing;\n    \n    public Accessor(Thing x){\n        thisthing = x;\n    }\n    \n    public void run(){\n        thisthing.setNonstaticField(5);\n        System.out.println(thisthing.getNonstaticField());\n    }\n}\n\nclass Thing {\n    private static int staticField;\n    private int nonstaticField;\n    \n    public static synchronized int getStaticField(){\n        return staticField;\n    }\n    \n    public static synchronized void setStaticField(int x){\n        //use class not this\n        Thing.staticField = x;\n    }\n    \n    public synchronized int getNonstaticField(){\n        return nonstaticField;\n    }\n    \n    public synchronized void setNonstaticField(int y){\n        this.nonstaticField = y;\n    }\n}','5\n5\n5','Threads',1,NULL),(553,'public class Hello {\n    \n   public static void main (String [] args){\n       Thing thing = new Thing();\n       \n       new Thread(new Accessor(thing),\"Max\").start();\n       new Thread(new Accessor(thing),\"Bart\").start();\n       new Thread(new Accessor(thing),\"Thread C\").start();\n \n   }\n}\n\nclass Accessor implements Runnable{\n    private Thing thisthing;\n    \n    public Accessor(Thing x){\n        thisthing = x;\n    }\n    \n    public void run(){\n        for(int i = 1; i <= 10; i++){\n            thisthing.setNonstaticField(i);\n            System.out.println(thisthing.getNonstaticField());\n        }\n    }\n}\n\nclass Thing {\n    private static int staticField;\n    private int nonstaticField;\n    \n    public static synchronized int getStaticField(){\n        return staticField;\n    }\n    \n    public static synchronized void setStaticField(int x){\n        //use class not this\n        Thing.staticField = x;\n    }\n    \n    public synchronized int getNonstaticField(){\n        return nonstaticField;\n    }\n    \n    public synchronized void setNonstaticField(int y){\n        this.nonstaticField = y;\n    }\n}','un predictable results, to make predictable\n\nput loop code inside a synhcronized block that locks onto thisthing!','Threads',1,NULL),(554,'public class Hello {\n    \n   public static void main (String [] args){\n       Thing thing = new Thing();\n       \n       new Thread(new Accessor(thing),\"Max\").start();\n       new Thread(new Accessor(thing),\"Bart\").start();\n       new Thread(new Accessor(thing),\"Thread C\").start();\n \n   }\n}\n\nclass Accessor implements Runnable{\n    private Thing thisthing;\n    \n    public Accessor(Thing x){\n        thisthing = x;\n    }\n    \n    public void run(){\n        synchronized(thisthing){\n            for(int i = 1; i <= 10; i++){\n              thisthing.setNonstaticField(i);\n             System.out.println(thisthing.getNonstaticField());\n         }\n        }\n    }\n}\n\nclass Thing {\n    private static int staticField;\n    private int nonstaticField;\n    \n    public static synchronized int getStaticField(){\n        return staticField;\n    }\n    \n    public static synchronized void setStaticField(int x){\n        //use class not this\n        Thing.staticField = x;\n    }\n    \n    public synchronized int getNonstaticField(){\n        return nonstaticField;\n    }\n    \n    public synchronized void setNonstaticField(int y){\n        this.nonstaticField = y;\n    }\n}','run:\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n','Threads',1,NULL),(555,'class SynchronizedRGB {\n\n    // Values must be between 0 and 255.\n    private int red;\n    private int green;\n    private int blue;\n    private String name;\n\n    private void check(int red,\n                       int green,\n                       int blue) {\n        if (red < 0 || red > 255\n            || green < 0 || green > 255\n            || blue < 0 || blue > 255) {\n            throw new IllegalArgumentException();\n        }\n    }\n\n    public SynchronizedRGB(int red,\n                           int green,\n                           int blue,\n                           String name) {\n        check(red, green, blue);\n        this.red = red;\n        this.green = green;\n        this.blue = blue;\n        this.name = name;\n    }\n\n    public void set(int red,\n                    int green,\n                    int blue,\n                    String name) {\n        check(red, green, blue);\n        synchronized (this) {\n            this.red = red;\n            this.green = green;\n            this.blue = blue;\n            this.name = name;\n        }\n    }\n\n    public synchronized int getRGB() {\n        return ((red << 16) | (green << 8) | blue);\n    }\n\n    public synchronized String getName() {\n        return name;\n    }\n\n    public synchronized void invert() {\n        red = 255 - red;\n        green = 255 - green;\n        blue = 255 - blue;\n        name = \"Inverse of \" + name;\n    }\n}','SynchronizedRGB must be used carefully to avoid being seen in an inconsistent state. Suppose, for example, a thread executes the following code:\n\nSynchronizedRGB color =\n    new SynchronizedRGB(0, 0, 0, \"Pitch Black\");\n...\nint myColorInt = color.getRGB();      //Statement 1\nString myColorName = color.getName(); //Statement 2\n\nIf another thread invokes color.set after Statement 1 but before Statement 2, the value of myColorInt won\'t match the value of myColorName. To avoid this outcome, the two statements must be bound together:\n\nsynchronized (color) {\n    int myColorInt = color.getRGB();\n    String myColorName = color.getName();\n} \n\nThis kind of inconsistency is only possible for mutable objects — it will not be an issue for the immutable version of SynchronizedRGB.','Threads',1,NULL),(556,'public class Hello {\n    \n   public static void main (String [] args){\n       Thing thing = new Thing();\n       \n       new Thread(new Accessor(thing),\"Max\").start();\n       new Thread(new Accessor(thing),\"Bart\").start();\n       new Thread(new Accessor(thing),\"Thread C\").start();\n       new Thread(new staticAccessor(),\"stat Max\").start();\n       new Thread(new staticAccessor(),\"stat bart\").start();\n       new Thread(new staticAccessor(),\"stat c\").start();\n \n   }\n}\n\nclass Accessor implements Runnable{\n    private Thing thisthing;\n    \n    public Accessor(Thing x){\n        thisthing = x;\n    }\n    \n    public void run(){\n        synchronized(thisthing){\n            for(int i = 1; i <= 10; i++){\n              thisthing.setNonstaticField(i);\n             System.out.println(thisthing.getNonstaticField());\n         }\n        }\n    }\n}\n\nclass staticAccessor implements Runnable {\n    \n    public void run(){\n        synchronized(Thing.class){\n            for(int i = 30; i > 10; i--){\n                Thing.setStaticField(i);\n                System.out.println(Thing.getStaticField()+\" \");\n            }\n        }\n    }\n    \n}','run:\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n30 \n29 \n28 \n27 \n26 \n25 \n24 \n23 \n22 \n21 \n20 \n19 \n18 \n17 \n16 \n15 \n14 \n13 \n12 \n11 \n30 \n29 \n28 \n27 \n26 \n25 \n24 \n23 \n22 \n21 \n20 \n19 \n18 \n17 \n16 \n15 \n14 \n13 \n12 \n11 \n30 \n29 \n28 \n27 \n26 \n25 \n24 \n23 \n22 \n21 \n20 \n19 \n18 \n17 \n16 \n15 \n14 \n13 \n12 \n11 \n\n','Threads',1,NULL),(557,'class DeadlockRisk {\n    private static class Resource {\n        public int value;\n    }\n    \n    private Resource resA = new Resource();\n    private Resource resB = new Resource();\n    \n    public int read() {\n        synchronized(resA) { // may deadlock\n            synchronized(resB) {\n                return resB.value + resA.value;\n            }\n        }\n    }\n    \n    public void write(int a, int b){\n        synchronized(resB){//may deadlock\n            synchronized(resA){\n                resA.value = a;\n                resB.value = b;\n            }\n        }\n    }\n}','this class may deadlock','Threads',1,NULL),(558,'wait() notify() and notifyAll() must be called from within a synhcronized\ncontext! A thread can\'t invoke a wait or notify method on an object unless it owns \nthat object\'s lock','','Threads',1,NULL),(559,'public class Hello {\n    \n   public static void main (String [] args){\n       \n       ThreadB b = new ThreadB();\n       b.start();\n       \n       synchronized(b) {\n           try {\n               System.out.println(\"waiting for b to complete...\");\n               b.wait();\n           } catch(InterruptedException e) { }\n           \n           System.out.println(\"Total is \" + b.total);\n       }\n \n   }\n  \n}\n\nclass ThreadB extends Thread {\n       int total;\n       \n       public void run() {\n           synchronized(this) {\n               for(int i = 0; i<100; i++){\n                   total += i;\n               }\n               \n               notify();\n           }\n       }\n   }','run:\nwaiting for b to complete...\nTotal is 4950\n\n','Threads',1,NULL),(560,'public class Hello {\n    \n   public static void main (String [] args){\n       \n       ThreadB b = new ThreadB();\n       b.start();\n       \n       synchronized(this) {\n           try {\n               System.out.println(\"waiting for b to complete...\");\n               b.wait();\n           } catch(InterruptedException e) { }\n           \n           System.out.println(\"Total is \" + b.total);\n       }\n \n   }\n  \n}','will not compile non static variable this cannot be referenced from\na static context. ','Threads',1,NULL),(561,'use notifyAll() to signal all waiting threads,\nnotify() will only signal one unspecified thread.','','Threads',1,NULL),(562,'public class Hello {\n    \n   public static void main (String [] args){\n      \n        Calculator cal = new Calculator();\n        new Reader(cal).start();\n        new Reader(cal).start();\n        new Reader(cal).start();\n\n   }\n  \n}\n\nclass Reader extends Thread {\n    Calculator c;\n    \n    public Reader(Calculator calc) {\n        c = calc;\n    }\n    \n    public void run(){\n        synchronized(c) {\n            try {\n                System.out.println(\"Waiting for calc\");\n                    c.wait();\n            } catch(InterruptedException e){ }\n                \n            System.out.println(\"Total is: \"+ c.total);\n            \n        }\n    }\n}\n\nclass Calculator implements Runnable {\n    int total;\n    \n    public void run() {\n        synchronized(this) {\n            for(int i = 0; i < 100; i++){\n                total += i;\n            }\n            notifyAll();\n        }\n    }\n}','this programm will wait indefinately, \nbecause the calculator was never started so the threads will continuously\nwait for it. ','Threads',1,NULL),(563,'public class Hello {\n    \n   public static void main (String [] args){\n      \n        Calculator cal = new Calculator();\n        new Reader(cal).start();\n        new Reader(cal).start();\n        new Reader(cal).start();\n        new Thread(cal).start();\n\n   }\n  \n}\n\nclass Reader extends Thread {\n    Calculator c;\n    \n    public Reader(Calculator calc) {\n        c = calc;\n    }\n    \n    public void run(){\n        synchronized(c) {\n            try {\n                System.out.println(\"Waiting for calc\");\n                    c.wait();\n            } catch(InterruptedException e){ }\n                \n            System.out.println(\"Total is: \"+ c.total);\n            \n        }\n    }\n}\n\nclass Calculator implements Runnable {\n    int total;\n    \n    public static void run() {\n        synchronized(this) {\n            for(int i = 0; i < 100; i++){\n                total += i;\n            }\n            notifyAll();\n        }\n    }\n}','will not compile, run() in Calculator cannot override run() in Runnable\noverriding method is static','Threads',1,NULL),(564,'public String getSection(){\n	String[] sections = {\"ABD\",\"AfG\",\"HTL\",\"AtL\",\"MAX\",\"AKH\",\"TYU\"};	\n     List<String> sectionList = Collections.asList(sections);\n     Collections.shuffle(sectionList);\n     String ret = sectionList.get(counter);\n	counter++;\n	return ret;\n}','Will not compile Collections.asList() does not exist \n\nyour thinking of Arrays.asList();','Threads',1,NULL),(565,' public String getSection(){\n            String[] sections = {\"ABD\",\"AfG\",\"HTL\",\"AtL\",\"MAX\",\"AKH\",\"TYU\"};\n            ArrayList sectionList = Arrays.asList(sections); \n            Collections.shuffle(sectionList);\n            String ret = sectionList.get(counter);\n            counter++;\n            return ret;\n        }','will not compile, \n\nList<String> coming from Arrays.asList cannot be converted to ArrayList.\n\nTherefore secionList should be a List<String>\n','Threads',1,NULL),(566,'class CodeMaker{\n    private String code = \": \";\n    private static int counter = 0;\n    private String[] sections = {\"ABD\",\"AfG\",\"HTL\",\"AtL\",\"MAX\",\"AKH\",\"TYU\"};\n    \n    \n    class SectionGenerator implements Runnable{\n        //private static int counter = 0; cannot have static members in inner class\n           \n        public String getSection(){\n            \n            synchronized(CodeMaker.class){\n                //sections.size()\n                if(counter < sections.length){\n                    String sec = sections[counter];\n                    counter++;\n                    return sec;\n                }\n            }\n            return null;\n        }\n        \n        public void run() {\n            code += getSection() + \" : \";\n        }\n\n    }\n    \n    public void coder(){\n        for(int i = 0; i < 7; i++){\n            new Thread(new SectionGenerator()).start();\n        }\n        System.out.println(\"code: \"+code);\n    }\n    \n    \n}','It will print an undeterminable series of codes though they will be in order,\n\nthe getSection() method has a block that is synchronized on the CodeMake.class\nobject but that only protects static methods.\n\nso when one thread is synched on CodeMaker.class no other thread can execute \nthat same block of code, here it is no applicable because all the threads \nhave the same block of code. That counter is the same for all threads,\nwhile the sections array is copied across all instances. The array is \nnot mutated in any way though. ','Threads',1,NULL),(567,'class CodeMaker{\n    private String code = \": \";\n    private String[] sections = {\"ABD\",\"AfG\",\"HTL\",\"AtL\",\"MAX\",\"AKH\",\"TYU\"};\n    \n    \n    class SectionGenerator implements Runnable{\n        private static int counter = 0;\n           \n        public String getSection(){\n            \n            synchronized(CodeMaker.class){\n                //sections.size()\n                if(counter < sections.length){\n                    String sec = sections[counter];\n                    counter++;\n                    return sec;\n                }\n            }\n            return null;\n        }\n        \n        public void run() {\n            code += getSection() + \" : \";\n        }\n\n    }\n    \n    public void coder(){\n        for(int i = 0; i <= 7; i++){\n            new Thread(new SectionGenerator()).start();\n        }\n        System.out.println(\"code: \"+code);\n    }\n    \n    \n}','will not compile illegal modifier static in inner class, \n\nto fix you would have to make counter final but that would defeat the\npurpose of having a counter!','Threads',1,NULL),(568,'class CodeMaker{\n    private String code = \": \";\n    private static int counter = 0;\n    private String[] sections = {\"ABD\",\"AfG\",\"HTL\",\"AtL\",\"MAX\",\"AKH\",\"TYU\"};\n    \n    \n    class SectionGenerator implements Runnable{\n           \n        public String getSection(){\n            \n            synchronized(CodeMaker.class){\n                if(counter < sections.size()){\n                    String sec = sections[counter];\n                    counter++;\n                    return sec;\n                }\n            }\n            return null;\n        }\n        \n        public void run() {\n            code += getSection() + \" : \";\n        }\n\n    }\n    \n    public void coder(){\n        for(int i = 0; i <= 7; i++){\n            new Thread(new SectionGenerator()).start();\n        }\n        System.out.println(\"code: \"+code);\n    }\n    \n    \n}','will not compile, an array does not have a size() method \nit has a length attribute','Threads',1,NULL),(569,'class CodeMaker{\n    private String code = \": \";\n    private static int counter = 0;\n    private String[] sections = {\"ABD\",\"AfG\",\"HTL\",\"AtL\",\"MAX\",\"AKH\",\"TYU\"};\n    \n    \n    class SectionGenerator implements Runnable{\n           \n        public String getSection(){\n            \n                if(counter < sections.length){\n                    String sec = sections[counter];\n                    counter++;\n                    return sec;\n                }\n            \n            return null;\n        }\n        \n        public void run() {\n            code += getSection() + \" : \";\n        }\n\n    }\n    \n    public void coder(){\n        for(int i = 0; i <= 7; i++){\n            new Thread(new SectionGenerator()).start();\n        }\n        System.out.println(\"code: \"+code);\n    }\n    \n    \n}','code: : AfG : HTL : AtL : MAX : \ncode: : ABD : AfG : HTL : AtL : MAX : AKH : TYU : \ncode: : ABD : AfG : HTL : AtL : MAX : AKH : TYU :\ncode: : ABD : HTL : AtL : MAX : AKH : TYU : \ncode: : ABD : AfG : HTL : AtL : MAX : AKH : TYU : \n\n...results from a few different runs. Without synchronization you cannot\nbe sure what will print because one thread could come in bewteen execution\nof getSection() and disrupt the results. This however will not change the\norder in which the code are retrieved because no matter \nhow choatic the threads execute there is no code that will\ncause static int counter to decrease or increase more than one. \n','Threads',1,NULL),(570,'class CodeMaker{\n    private String code = \": \";\n    private int counter = 0;\n    private static String[] sections = {\"ABD\",\"AfG\",\"HTL\",\"AtL\",\"MAX\",\"AKH\",\"TYU\"};\n    \n    \n    class SectionGenerator implements Runnable{\n           \n        public String getSection(){\n            \n            synchronized(CodeMaker.class){\n            \n                if(counter < sections.length){\n                    String sec = sections[counter];\n                    counter++;\n                    return sec;\n                }\n                \n                return null;\n                \n            }\n            \n            \n        }\n        \n        public void run() {\n            code += getSection() + \" : \";\n        }\n\n    }\n    \n    public void coder(){\n        for(int i = 0; i <= 7; i++){\n            new Thread(new SectionGenerator()).start();\n        }\n        System.out.println(\"code: \"+code);\n    }\n    \n    \n}\n\npublic class Hello {\n    \n   public static void main (String [] args){\n      new CodeMaker().coder();\n\n   }\n  \n}','This code will not print accurate results as in it will not reliably\nprint all the sections. \n\nThis is becaue the reading of a code and tacking it into the complete \ncode is not an atomic operation. \n\nto uniformly print all the codes you would do this:\n\n	class SectionGenerator implements Runnable{\n\n        public void run() {\n            synchronized(CodeMaker.class){\n            \n                if(counter < sections.length){\n                    String sec = sections[counter];\n                    counter++;\n                    code += sec + \" : \";\n                }\n\n                \n            }\n        }\n\n    }','Threads',1,NULL),(571,'class CodeMaker{\n    private String code = \": \";\n    private int counter = 0;\n    private static String[] sections = {\"ABD\",\"AfG\",\"HTL\",\"AtL\",\"MAX\",\"AKH\",\"TYU\"};\n    \n    \n    class SectionGenerator implements Runnable{\n\n        public void run() {\n            synchronized(CodeMaker.class){\n            \n                if(counter < sections.length){\n                    String sec = sections[counter];\n                    counter++;\n                    code += sec + \" : \";\n                }\n\n                \n            }\n        }\n\n    }\n    \n    public void coder(){\n        for(int i = 0; i <= 7; i++){\n            new Thread(new SectionGenerator()).start();\n        }\n        System.out.println(\"code: \"+code);\n    }\n    \n    \n}\n\npublic class Hello {\n    \n   public static void main (String [] args){\n      new CodeMaker().coder();\n\n   }\n  \n}','will print:\n\ncode: : ABD : AfG : HTL : AtL : MAX : AKH : TYU :\n\nevery time. \n\nin previous questions counter was not static, if that were the case here\nresults would not be predictable. ','Threads',1,NULL),(572,'public class Hello {\n    \n   public static void main (String [] args){\n      new CodeMaker().coder();\n\n   }\n  \n}\n\nclass CodeMaker{\n    private String code = \": \";\n    private int counter = 0;\n    private static String[] sections = {\"ABD\",\"AfG\",\"HTL\",\"AtL\",\"MAX\",\"AKH\",\"TYU\"};\n    \n    \n    class SectionGenerator implements Runnable{\n\n        public void run() {\n            synchronized(CodeMaker.class){\n            \n                if(counter < sections.length){\n                    String sec = sections[counter];\n                    counter++;\n                    code += sec + \" : \";\n                }\n                \n            }\n        }\n\n    }\n    \n    public void coder(){\n        for(int i = 0; i <= 7; i++){\n            new Thread(new SectionGenerator()).start();\n        }\n        System.out.println(\"code: \"+code);\n    }\n    \n    \n}','will produce unpredictable results because counter is not static, so\nits access is not locked by synchronization onto CodeMaker.class\n','Threads',1,NULL),(573,'class statPrinter {\n    private int counter = 0;\n    \n    class Adder implements Runnable {\n        \n        public void run(){\n                //Thread.sleep(1000); with no try\n                counter++;\n                System.out.println(counter + \", Adder +1 \");  \n        }\n    }\n    \n    class Minuser implements Runnable {\n        public void run() {\n                counter--;\n                System.out.println(counter+\", Minuser -1 \");    \n        }\n    }\n    \n    public void test(){\n        for(int i = 0; i < 100; i++){\n            new Thread(new Adder()).start();\n            new Thread(new Minuser()).start();\n            \n        }\n    }\n}','without synchronization here the results will be wildly unpredictable.','Threads',1,NULL),(574,'class statPrinter {\n    private int counter = 0;\n    \n    class Adder implements Runnable {\n        \n        public void run(){\n                Thread.sleep(1000); \n                counter++;\n                System.out.println(counter + \", Adder +1 \");  \n        }\n    }\n    \n    class Minuser implements Runnable {\n        public void run() {\n                Thread.sleep(500);\n                counter--;\n                System.out.println(counter+\", Minuser -1 \");    \n        }\n    }\n    \n    public void test(){\n        for(int i = 0; i < 100; i++){\n            new Thread(new Adder()).start();\n            new Thread(new Minuser()).start();\n            \n        }\n    }\n}','will not compile, unreported interrupt exception coming from \nThread.sleep();\n\nmust wrap in try catch or declare it to be thrown','Threads',1,NULL),(575,'class statPrinter {\n    private int counter = 0;\n    \n    class Adder implements Runnable {\n        \n        public synchronized void run(){\n                counter++;\n                System.out.println(counter + \", Adder +1 \");  \n        }\n    }\n    \n    class Minuser implements Runnable {\n        public synchronized void run() {\n                counter--;\n                System.out.println(counter+\", Minuser -1 \");    \n        }\n    }\n    \n    public void test(){\n        for(int i = 0; i < 100; i++){\n            new Thread(new Adder()).start();\n            new Thread(new Minuser()).start();\n            \n        }\n    }\n}','These results are unpredicatable, \n\nyes run() can be synched, these two methods synchronize on the current\nobject, all that means is that theyre code \n\n	counter++;\n     System.out.println(counter+\", Minuser -1 \"); \n\n	counter--;\n      System.out.println(counter+\", Minuser -1 \"); 	\n\nwill run in order completely without being interrupted by another thread.\n\nhowever that does not stop another thread from jumping the gun and being\nrun twice though!\n\n','Threads',1,NULL),(576,'class statPrinter {\n    private int counter = 0;\n    \n    class Adder implements Runnable {\n        \n        public void run(){\n            synchronized(this){\n                counter++;\n                System.out.println(counter + \", Adder +1 \");  \n            }\n        }\n    }\n    \n    class Minuser implements Runnable {\n        public void run() {\n            synchronized(this){\n                counter--;\n                System.out.println(counter+\", Minuser -1 \");   \n            }\n        }\n    }\n    \n    public void test(){\n        for(int i = 0; i < 100; i++){\n            new Thread(new Adder()).start();\n            new Thread(new Minuser()).start();\n            \n        }\n    }\n}','this will give unpredictable results, \n\npublic void run() {\n            synchronized(this){\n                counter--;\n                System.out.println(counter+\", Minuser -1 \");   \n            }\n        }\n\nis the same as\n\npublic synchronized void run(){\n	...\n}\n\n\nthey both lock onto the current obejct, meaning no other thread can\naccess that object. The variable of concern here though is counter which\nis a variable of the statPrinter object. ','Threads',1,NULL),(577,'class CodeMaker{\n    private String code;\n    private int counter;\n    private static String[] sections;\n    private ArrayList<String> al;\n    \n    public CodeMaker(){\n        code = \": \";\n        counter = 0;\n        sections = {\"ABD\",\"AfG\",\"HTL\",\"AtL\",\"MAX\",\"AKH\",\"TYU\"};\n        al = new ArrayList<>();\n    }\n    \n    \n    class SectionGenerator implements Runnable{\n\n        public void run() {\n            synchronized(CodeMaker.class){\n            \n                if(counter < sections.length){\n                    String sec = sections[counter];\n                    counter++;\n                    code += sec + \" : \";\n                }\n                \n            }\n        }\n\n    }\n    \n    public void coder(){\n        for(int i = 0; i <= 10; i++){\n            new Thread(new SectionGenerator()).start();\n        }\n        System.out.println(\"code: \"+code);\n    }\n    \n    \n}','Will not compile you cannot intitialize an array with shorthand like that.\nBecause, at the time of creation java wants to know excactly how \nmuch memory to allocate when you jsut create the reference you basically\ncreate nothing.\n\nin the constructor you whene you initialize you have to excplicitly\ncreate the memory with the new array using new. \n\nto compile do this:\n	\n	sections = new String[]{\"ABD\",\"AfG\",\"HTL\",\"AtL\",\"MAX\",\"AKH\",\"TYU\"};','Threads',1,NULL),(578,'class CodeMaker{\n    private String code;\n    private int counter;\n    private static String[] sections;\n    private ArrayList<String> al;\n    \n    public synchronized CodeMaker(){\n        code = \": \";\n        counter = 0;\n        sections = new String[]{\"ABD\",\"AfG\",\"HTL\",\"AtL\",\"MAX\",\"AKH\",\"TYU\"};\n        al = new ArrayList<>();\n    }\n    \n    \n    class SectionGenerator implements Runnable{\n\n        public void run() {\n            synchronized(CodeMaker.class){\n            \n                if(counter < sections.length){\n                    String sec = sections[counter];\n                    counter++;\n                    code += sec + \" : \";\n                }\n                \n            }\n        }\n\n    }\n    \n    public void coder(){\n        for(int i = 0; i <= 10; i++){\n            new Thread(new SectionGenerator()).start();\n        }\n        System.out.println(\"code: \"+code);\n    }\n    \n    \n}','will not compile, Constructors cannot be synchronized. ','Threads',1,NULL),(579,'class CodeMaker  extends Thread {\n    private String code;\n    private int counter;\n    private ArrayList<String> al;\n    private char[] letters = {\'A\',\'B\',\'C\',\'D\',\'E\',\'F\',\'G\',\'H\',\'I\'};\n    \n    public CodeMaker(){\n        counter = 0;\n        al = new ArrayList<>();\n    }\n\n    class SectionGenerator implements Runnable{\n        private String sec = \"\";\n        private Random ran;\n\n        public void run() {\n            //tried to use notify outside of synchronized context\n            synchronized(this){\n                int x = ran.nextInt(3);\n                int y = ran.nextInt(3);\n                int z = ran.nextInt(3);\n            \n            \n                sec += letters[x];\n                sec += letters[y];\n                sec += letters[z];\n                notifyAll();\n            }\n        }\n        \n        public synchronized String section(){\n            return sec;\n        }\n\n    }\n    \n    class NumberGenerator implements Runnable{\n        private String number = \"\";\n        private Random ran;\n        \n        public void run(){\n            //tried to use notify outside of synchronized context\n            synchronized(this){\n                int x1 = ran.nextInt(100);\n                int x2 = ran.nextInt(100);\n                int x3 = ran.nextInt(100);\n            \n                number+= x1+\".\"+x2+\".\"+x3;\n                notifyAll();\n            }\n        }\n        \n        public synchronized String Number(){\n            return number;\n        }\n    }\n    \n   public void run(){\n       \n       SectionGenerator sg1 = new SectionGenerator();\n       NumberGenerator ng1 = new NumberGenerator();\n       Thread t1 = new Thread(sg1);\n       Thread t2 = new Thread(ng1);\n       \n       t1.start();\n       t2.start();\n       \n       t1.wait();\n       code += sg1.section();\n       t2.wait();\n       code += ng1.Number();\n       \n       System.out.println(code);\n\n       \n   }\n    \n    \n}\n','will not compile becaue of wait(),\n\nureported exception, interruptedexception, must be caught or thrown\n\n','Threads',1,NULL),(580,'class CodeMaker  extends Thread {\n    private String code;\n    private int counter;\n    private ArrayList<String> al;\n    private char[] letters = {\'A\',\'B\',\'C\',\'D\',\'E\',\'F\',\'G\',\'H\',\'I\'};\n    \n    public CodeMaker(){\n        counter = 0;\n        al = new ArrayList<>();\n    }\n\n    class SectionGenerator implements Runnable{\n        private String sec = \"\";\n        private Random ran;\n\n        public void run() {\n            //tried to use notify outside of synchronized context\n            synchronized(this){\n                int x = ran.nextInt(3);\n                int y = ran.nextInt(3);\n                int z = ran.nextInt(3);\n            \n            \n                sec += letters[x];\n                sec += letters[y];\n                sec += letters[z];\n                notifyAll();\n            }\n        }\n        \n        public synchronized String section(){\n            return sec;\n        }\n\n    }\n    \n    class NumberGenerator implements Runnable{\n        private String number = \"\";\n        private Random ran;\n        \n        public void run(){\n            //tried to use notify outside of synchronized context\n            synchronized(this){\n                int x1 = ran.nextInt(100);\n                int x2 = ran.nextInt(100);\n                int x3 = ran.nextInt(100);\n            \n                number+= x1+\".\"+x2+\".\"+x3;\n                notifyAll();\n            }\n        }\n        \n        public synchronized String Number(){\n            return number;\n        }\n    }\n    \n   public void run() throws InterruptedException {\n       \n       SectionGenerator sg1 = new SectionGenerator();\n       NumberGenerator ng1 = new NumberGenerator();\n       Thread t1 = new Thread(sg1);\n       Thread t2 = new Thread(ng1);\n       \n       t1.start();\n       t2.start();\n       \n       t1.wait();\n       code += sg1.section();\n       t2.wait();\n       code += ng1.Number();\n       \n       System.out.println(code);\n\n       \n   }\n    \n    \n}','will not compile, not a proper override of run(),\n\noverrides cannot throw new or broader checked exceptions','Threads',1,NULL),(581,'public class Hello extends Thread {\n    public static void main(String[] args){\n        new CodeMaker().start();\n    }\n}\n\nclass CodeMaker  extends Thread {\n    private String code;\n    private int counter;\n    private ArrayList<String> al;\n    private char[] letters = {\'A\',\'B\',\'C\',\'D\',\'E\',\'F\',\'G\',\'H\',\'I\'};\n    \n    public CodeMaker(){\n        counter = 0;\n        al = new ArrayList<>();\n    }\n\n    class SectionGenerator implements Runnable{\n        private String sec = \"\";\n        private Random ran;\n\n        public void run() {\n            //tried to use notify outside of synchronized context\n            synchronized(this){\n                int x = ran.nextInt(3);\n                int y = ran.nextInt(3);\n                int z = ran.nextInt(3);\n            \n            \n                sec += letters[x];\n                sec += letters[y];\n                sec += letters[z];\n                notifyAll();\n            }\n        }\n        \n        public synchronized String section(){\n            return sec;\n        }\n\n    }\n    \n    class NumberGenerator implements Runnable{\n        private String number = \"\";\n        private Random ran;\n        \n        public void run(){\n            //tried to use notify outside of synchronized context\n            synchronized(this){\n                int x1 = ran.nextInt(100);\n                int x2 = ran.nextInt(100);\n                int x3 = ran.nextInt(100);\n            \n                number += x1+\".\"+x2+\".\"+x3;\n                notifyAll();\n            }\n        }\n        \n        public synchronized String Number(){\n            return number;\n        }\n    }\n    \n   public synchronized void run(){\n       \n       SectionGenerator sg1 = new SectionGenerator();\n       NumberGenerator ng1 = new NumberGenerator();\n       Thread t1 = new Thread(sg1);\n       Thread t2 = new Thread(ng1);\n       \n       t1.start();\n       t2.start();\n       \n       try{\n        t1.wait();\n        code += sg1.section();\n        t2.wait();\n        code += ng1.Number();\n       } catch(InterruptedException e){\n           \n       }\n       System.out.println(code);\n\n       \n   }\n    \n    \n}','NPE, ran is nevere intitialized. ','Threads',1,NULL),(582,'public class Hello extends Thread {\n    public static void main(String[] args){\n        new CodeMaker().start();\n    }\n}\n\nclass CodeMaker  extends Thread {\n    private String code;\n    private int counter;\n    private ArrayList<String> al;\n    private char[] letters = {\'A\',\'B\',\'C\',\'D\',\'E\',\'F\',\'G\',\'H\',\'I\'};\n    \n    public CodeMaker(){\n        counter = 0;\n        al = new ArrayList<>();\n    }\n\n    class SectionGenerator implements Runnable{\n        private String sec = \"\";\n        private Random ran = new Random();\n\n        public void run() {\n            //tried to use notify outside of synchronized context\n            synchronized(this){\n                int x = ran.nextInt(3);\n                int y = ran.nextInt(3);\n                int z = ran.nextInt(3);\n            \n            \n                sec += letters[x];\n                sec += letters[y];\n                sec += letters[z];\n                notifyAll();\n            }\n        }\n        \n        public synchronized String section(){\n            return sec;\n        }\n\n    }\n    \n    class NumberGenerator implements Runnable{\n        private String number = \"\";\n        private Random ran = new Random();\n        \n        public void run(){\n            //tried to use notify outside of synchronized context\n            synchronized(this){\n                int x1 = ran.nextInt(100);\n                int x2 = ran.nextInt(100);\n                int x3 = ran.nextInt(100);\n            \n                number += x1+\".\"+x2+\".\"+x3;\n                notifyAll();\n            }\n        }\n        \n        public synchronized String Number(){\n            return number;\n        }\n    }\n    \n   public synchronized void run(){\n       \n       SectionGenerator sg1 = new SectionGenerator();\n       NumberGenerator ng1 = new NumberGenerator();\n       Thread t1 = new Thread(sg1);\n       Thread t2 = new Thread(ng1);\n       \n       t1.start();\n       t2.start();\n       \n       try{\n        t1.wait();\n        code += sg1.section();\n        t2.wait();\n        code += ng1.Number();\n       } catch(InterruptedException e){\n           \n       }\n       System.out.println(code);\n\n       \n   }\n    \n    \n}','IllegalMonitorStateException, ','Threads',1,NULL),(583,'public class Hello extends Thread {\n    public static void main(String[] args){\n        \n    }\n    \n    class Operator extends Thread {\n        Machine machine = new Machine();\n        Machine.MachineInstructions job;\n        \n        public void run(){\n            while(true){\n                String shape = getShapeFromUser();\n                job = calculateNewInstructionsFor(shape);\n                \n                machine.addJob(job);\n            }\n        }\n        \n        public Machine.MachineInstructions calculateNewInstructionsFor(String x){\n            // dah duh duu da du\n            return machine.new MachineInstructions();\n        }\n        \n        public String getShapeFromUser(){\n            System.out.println(\"What shape? square ok thanks\");\n            return \"Square\";\n        }\n        \n    }\n    \n    class Machine extends Thread {\n        List<MachineInstructions> joblist = new ArrayList<>(0);\n        \n        public void addJob(MachineInstructions job){\n            synchronized(joblist){\n                joblist.add(job);\n                joblist.notify();\n            }\n        }\n        \n        public void run(){\n            while(true) {\n                synchronized(joblist) {\n                    //wait until at least one job is available\n                    while(joblist.isEmpty()) {\n                        try{\n                            joblist.wait();\n                        } catch(InterruptedException ei){\n                            \n                        }\n                        \n                        //if we get here you know the list is\'nt empty\n                        MachineInstructions inst = joblist.remove(0);\n                        \n                    }\n                }\n            }\n        }\n        \n        \n        static class MachineInstructions {\n            \n        }\n    }\n}','will not compile, static classes are not allowed in inner classes,\n\nonly static final varialbe definitions is allowed.','Threads',1,NULL),(584,'public class Hello extends Thread {\n    public static void main(String[] args){\n        new Operator().start();\n        new Machine().start();\n    }\n    \n    class Operator extends Thread {\n        Machine machine = new Machine();\n        Machine.MachineInstructions job;\n        \n        public void run(){\n            while(true){\n                String shape = getShapeFromUser();\n                job = calculateNewInstructionsFor(shape);\n                \n                machine.addJob(job);\n            }\n        }\n        \n        public Machine.MachineInstructions calculateNewInstructionsFor(String x){\n            // dah duh duu da du\n            return machine.new MachineInstructions(x);\n        }\n        \n        public String getShapeFromUser(){\n            System.out.println(\"What shape? square ok thanks\");\n            return \"Square\";\n        }\n        \n    }\n    \n    class Machine extends Thread {\n        List<MachineInstructions> joblist = new ArrayList<>();\n        \n        public void addJob(MachineInstructions job){\n            synchronized(joblist){\n                joblist.add(job);\n                joblist.notify();\n            }\n        }\n        \n        public void run(){\n            while(true) {\n                synchronized(joblist) {\n                    //wait until at least one job is available\n                    while(joblist.isEmpty()) {\n                        try{\n                            joblist.wait();\n                        } catch(InterruptedException ei){\n                            \n                        }\n                        \n                        //if we get here you know the list is\'nt empty\n                        MachineInstructions inst = joblist.remove(0);\n                        \n                        \n                    }\n                }\n            }\n        }\n        \n        \n        class MachineInstructions {\n            private String shape;\n            \n            public MachinInstructions(String shape){\n                this.shape = shape;\n            }\n            public void produceShape(){\n                System.out.println(\"Here\'s your :\"+shape);\n            }\n            \n        }\n    }\n}','will not compile, non static inner classes cannot be accessed from static\nmain','Threads',1,NULL),(585,'public class Hello extends Thread {\n    Operator op = new Operator();\n    Machine m = new Machine();\n    public static void main(String[] args){\n        op.start();\n        m.start();\n    }\n    \n    class Operator extends Thread {\n        Machine machine = new Machine();\n        Machine.MachineInstructions job;\n        \n        public void run(){\n            while(true){\n                String shape = getShapeFromUser();\n                job = calculateNewInstructionsFor(shape);\n                \n                machine.addJob(job);\n            }\n        }\n        \n        public Machine.MachineInstructions calculateNewInstructionsFor(String x){\n            // dah duh duu da du\n            return machine.new MachineInstructions(x);\n        }\n        \n        public String getShapeFromUser(){\n            System.out.println(\"What shape? square ok thanks\");\n            return \"Square\";\n        }\n        \n    }\n    \n    class Machine extends Thread {\n        List<MachineInstructions> joblist = new ArrayList<>();\n        \n        public void addJob(MachineInstructions job){\n            synchronized(joblist){\n                joblist.add(job);\n                joblist.notify();\n            }\n        }\n        \n        public void run(){\n            while(true) {\n                synchronized(joblist) {\n                    //wait until at least one job is available\n                    while(joblist.isEmpty()) {\n                        try{\n                            joblist.wait();\n                        } catch(InterruptedException ei){\n                            \n                        }\n                        \n                        //if we get here you know the list is\'nt empty\n                        MachineInstructions inst = joblist.remove(0);\n                        \n                        \n                    }\n                }\n            }\n        }\n        \n        \n        class MachineInstructions {\n            private String shape;\n            \n            public MachinInstructions(String shape){\n                this.shape = shape;\n            }\n            public void produceShape(){\n                System.out.println(\"Here\'s your :\"+shape);\n            }\n            \n        }\n    }\n}','will not compile non static instance variable cannot be referenced \nfrom static main','Threads',1,NULL),(586,'public class Hello extends Thread {\n    private static Operator op = new Operator();\n    private static Machine m = new Machine();\n    public static void main(String[] args){\n        op.start();\n        m.start();\n    }\n    \n    class Operator extends Thread {\n        Machine machine = new Machine();\n        Machine.MachineInstructions job;\n        \n        public void run(){\n            while(true){\n                String shape = getShapeFromUser();\n                job = calculateNewInstructionsFor(shape);\n                \n                machine.addJob(job);\n            }\n        }\n        \n        public Machine.MachineInstructions calculateNewInstructionsFor(String x){\n            // dah duh duu da du\n            return machine.new MachineInstructions(x);\n        }\n        \n        public String getShapeFromUser(){\n            System.out.println(\"What shape? square ok thanks\");\n            return \"Square\";\n        }\n        \n    }\n    \n    class Machine extends Thread {\n        List<MachineInstructions> joblist = new ArrayList<>();\n        \n        public void addJob(MachineInstructions job){\n            synchronized(joblist){\n                joblist.add(job);\n                joblist.notify();\n            }\n        }\n        \n        public void run(){\n            while(true) {\n                synchronized(joblist) {\n                    //wait until at least one job is available\n                    while(joblist.isEmpty()) {\n                        try{\n                            joblist.wait();\n                        } catch(InterruptedException ei){\n                            \n                        }\n                        \n                        //if we get here you know the list is\'nt empty\n                        MachineInstructions inst = joblist.remove(0);\n                        \n                        \n                    }\n                }\n            }\n        }\n        \n        \n        class MachineInstructions {\n            private String shape;\n            \n            public MachinInstructions(String shape){\n                this.shape = shape;\n            }\n            public void produceShape(){\n                System.out.println(\"Here\'s your :\"+shape);\n            }\n            \n        }\n    }\n}','will not compile non static variable this cannot be reference from a static\ncontext. \n\nthe inner classes are instance classes so, even though you define \nthe variables as static they have to use this to access the inner class\n\nso it will still not compile','Threads',1,NULL),(587,'public class Hello extends Thread {\n \n    public static void main(String[] args){\n        Hello h = new Hello();\n        h.new Operator().start();\n        h.new Machine().start();\n    }\n    \n    class Operator extends Thread {\n        Machine machine = new Machine();\n        Machine.MachineInstructions job;\n        \n        public void run(){\n            while(true){\n                String shape = getShapeFromUser();\n                job = calculateNewInstructionsFor(shape);\n                \n                machine.addJob(job);\n            }\n        }\n        \n        public Machine.MachineInstructions calculateNewInstructionsFor(String x){\n            // dah duh duu da du\n            return machine.new MachineInstructions(x);\n        }\n        \n        public String getShapeFromUser(){\n            System.out.println(\"What shape? square ok thanks\");\n            return \"Square\";\n        }\n        \n    }\n    \n    class Machine extends Thread {\n        List<MachineInstructions> joblist = new ArrayList<>();\n        \n        public void addJob(MachineInstructions job){\n            synchronized(joblist){\n                joblist.add(job);\n                joblist.notify();\n            }\n        }\n        \n        public void run(){\n            while(true) {\n                synchronized(joblist) {\n                    //wait until at least one job is available\n                    while(joblist.isEmpty()) {\n                        try{\n                            joblist.wait();\n                        } catch(InterruptedException ei){\n                            \n                        }\n                        \n                        //if we get here you know the list is\'nt empty\n                        MachineInstructions inst = joblist.remove(0);\n                        \n                        \n                    }\n                }\n            }\n        }\n        \n        \n        class MachineInstructions {\n            private String shape;\n            \n            public MachineInstructions(String shape){\n                this.shape = shape;\n            }\n            public void produceShape(){\n                System.out.println(\"Here\'s your :\"+shape);\n            }\n            \n        }\n    }\n}','will produce: \n	What shape? square ok thanks\n	What shape? square ok thanks\n	What shape? square ok thanks\n	What shape? square ok thanks\n...ad infinum\n\nThe conintinuos loops are meant to keep checking for new shapes. \n\nnotice that one of the threads is alwasy synched in with the jobslist\n\nthey then use wait and notify to bounce back and forth.','Threads',1,NULL),(588,'public class Hello extends Thread {\n \n    public static void main(String[] args){\n        Hello h = new Hello();\n        h.new Operator().start();\n        h.new Machine().start();\n    }\n    \n    class Operator extends Thread {\n        Machine machine = new Machine();\n        Machine.MachineInstructions job;\n        \n        public void run(){\n            while(true){\n                String shape = getShapeFromUser();\n                job = calculateNewInstructionsFor(shape);\n                \n                machine.addJob(job);\n            }\n        }\n        \n        public Machine.MachineInstructions calculateNewInstructionsFor(String x){\n            // dah duh duu da du\n            return machine.new MachineInstructions(x);\n        }\n        \n        public String getShapeFromUser(){\n            System.out.println(\"What shape? square ok thanks\");\n            return \"Square\";\n        }\n        \n    }\n    \n    class Machine extends Thread {\n        List<MachineInstructions> joblist = new ArrayList<>();\n        \n        public void addJob(MachineInstructions job){\n            synchronized(joblist){\n                joblist.add(job);\n                joblist.notify();\n            }\n        }\n        \n        public void run(){\n            while(true) {\n                    //wait until at least one job is available\n                    while(joblist.isEmpty()) {\n                        try{\n                            joblist.wait();\n                        } catch(InterruptedException ei){\n                            \n                        }\n                        \n                        //if we get here you know the list is\'nt empty\n                        MachineInstructions inst = joblist.remove(0);\n                        \n                        \n                    }\n            }\n        }\n        \n        \n        class MachineInstructions {\n            private String shape;\n            \n            public MachineInstructions(String shape){\n                this.shape = shape;\n            }\n            public void produceShape(){\n                System.out.println(\"Here\'s your :\"+shape);\n            }\n            \n        }\n    }\n}','IllegalMonitorStateException\n\nwait in thread machine is called from outside a synchronized context\n\nyou have to synchronized on an object to wait on it. ','Threads',1,NULL),(589,'public class Hello extends Thread {\n \n    public static void main(String[] args){\n        Hello h = new Hello();\n        h.new Operator().start();\n        h.new Machine().start();\n    }\n    \n    class Operator extends Thread {\n        Machine machine = new Machine();\n        Machine.MachineInstructions job;\n        \n        public void run(){\n            while(true){\n                String shape = getShapeFromUser();\n                job = calculateNewInstructionsFor(shape);\n                \n                machine.addJob(job);\n            }\n        }\n        \n        public Machine.MachineInstructions calculateNewInstructionsFor(String x){\n            // dah duh duu da du\n            return machine.new MachineInstructions(x);\n        }\n        \n        public String getShapeFromUser(){\n            System.out.println(\"What shape? square ok thanks\");\n            return \"Square\";\n        }\n        \n    }\n    \n    class Machine extends Thread {\n        List<MachineInstructions> joblist = new ArrayList<>();\n        \n        public void addJob(MachineInstructions job){\n                joblist.add(job);\n                joblist.notify();\n        }\n        \n        public void run(){\n            while(true) {\n                synchronized(joblist) {\n                    //wait until at least one job is available\n                    while(joblist.isEmpty()) {\n                        try{\n                            joblist.wait();\n                        } catch(InterruptedException ei){\n                            \n                        }\n                        \n                        //if we get here you know the list is\'nt empty\n                        MachineInstructions inst = joblist.remove(0);\n                        \n                        \n                    }\n                }\n            }\n        }\n        \n        \n        class MachineInstructions {\n            private String shape;\n            \n            public MachineInstructions(String shape){\n                this.shape = shape;\n            }\n            public void produceShape(){\n                System.out.println(\"Here\'s your :\"+shape);\n            }\n            \n        }\n    }\n}','IllegalMonitorStateException, \n\nnotify() in addJob is called without being synched with joblist.\n\nyou have to be synched on an object to wait on it or notify it.\n\nRemember you wait and notify objects not threads. ','Threads',1,NULL),(590,'//ignore the answer try to figure out what wrong with this thin\npublic class Hello extends Thread {\n \n    public static void main(String[] args){\n        Hello h = new Hello();\n        h.new Operator().start();\n        h.new Machine().start();\n        new ButterFinger().start();\n    }\n    \n    class Operator extends Thread {\n        Machine machine = new Machine();\n        Machine.MachineInstructions job;\n        \n        public void run(){\n            while(true){\n                String shape = getShapeFromUser();\n                job = calculateNewInstructionsFor(shape);\n                \n                machine.addJob(job);\n            }\n        }\n        \n        public Machine.MachineInstructions calculateNewInstructionsFor(String x){\n            // dah duh duu da du\n            return machine.new MachineInstructions(x);\n        }\n        \n        public String getShapeFromUser(){\n            System.out.println(\"What shape? square ok thanks\");\n            return \"Square\";\n        }\n        \n    }\n    \n    class Machine extends Thread {\n        private List<MachineInstructions> joblist = new ArrayList<>();\n        \n        public void addJob(MachineInstructions job){\n            synchronized(joblist){\n                joblist.add(job);\n                joblist.notifyAll();\n            }\n        }\n        \n        public void run(){\n            while(true) {\n                synchronized(joblist) {\n                    //wait until at least one job is available\n                    while(joblist.isEmpty()) {\n                        try{\n                            joblist.wait();\n                        } catch(InterruptedException ei){\n                            \n                        }\n                        \n                        //if we get here you know the list is\'nt empty\n                        MachineInstructions inst = joblist.remove(0);\n                        \n                        \n                    }\n                }\n            }\n        }\n        \n        \n        class MachineInstructions {\n            private String shape;\n            \n            public MachineInstructions(String shape){\n                this.shape = shape;\n            }\n            public void produceShape(){\n                System.out.println(\"Here\'s your :\"+shape);\n            }\n            \n        }\n    }\n     \n}\n\nclass ButterFinger extends Thread {\n    private Hello h = new Hello();\n    private Hello.Machine machine = h.new Machine();\n    \n        public void run(){\n            while(true){\n                machine.addJob(machine.new MachineInstructions(\"Whoops I fucked up\"));\n            }\n            \n        }\n}','Here butterfingers is unable to get his meaty claws on the same machine \nthe operator is using becasue those two are instance classes created \nin static main, joblist is an instance variable so the one they are \nusing belongs to the instance created in main. \n\nButterFinger created his own seperated machine to fuck with here, good\nso the output will be \n\nWhat shape? square ok thanks\nWhat shape? square ok thanks\nWhat shape? square ok thanks\nWhat shape? square ok thanks     for ever and ever. ','Threads',1,NULL),(591,'public class Hello extends Thread {\n    Operator op = new Operator();\n    Machine m = new Machine();\n \n    public static void main(String[] args){\n       Hello h = new Hello();\n       h.op.start();\n       h.m.start();\n    }\n    \n    class Operator extends Thread {\n        Machine machine = new Machine();\n        Machine.MachineInstructions job;\n        \n        public void run(){\n            while(true){\n                String shape = getShapeFromUser();\n                job = calculateNewInstructionsFor(shape);\n                \n                machine.addJob(job);\n            }\n        }\n        \n        public Machine.MachineInstructions calculateNewInstructionsFor(String x){\n            // dah duh duu da du\n            return machine.new MachineInstructions(x);\n        }\n        \n        public String getShapeFromUser(){\n            System.out.println(\"What shape? square ok thanks\");\n            return \"Square\";\n        }\n        \n    }\n    \n    class Machine extends Thread {\n        private List<MachineInstructions> joblist = new ArrayList<>();\n        \n        public void addJob(MachineInstructions job){\n            synchronized(joblist){\n                joblist.add(job);\n                joblist.notifyAll();\n            }\n        }\n        \n        public void run(){\n            while(true) {\n                synchronized(joblist) {\n                    //wait until at least one job is available\n                    while(joblist.isEmpty()) {\n                        try{\n                            joblist.wait();\n                        } catch(InterruptedException ei){\n                            \n                        }\n                        \n                        //if we get here you know the list is\'nt empty\n                        MachineInstructions inst = joblist.remove(0);\n                        \n                        \n                    }\n                }\n            }\n        }\n        \n        \n        class MachineInstructions {\n            private String shape;\n            \n            public MachineInstructions(String shape){\n                this.shape = shape;\n            }\n            public void produceShape(){\n                System.out.println(\"Here\'s your :\"+shape);\n            }\n            \n        }\n    }\n     \n}\n\nclass ButterFinger extends Thread {\n    private Hello h = new Hello();\n    \n        public void run(){\n            while(true){\n                h.m.addJob(h.m.new MachineInstructions(\"Whoops I fucked up\"));\n            }\n            \n        }\n}','Butterfinger now has the right machine however the main method never\nstarts him so the output is still \n\nwhat shape? square ok thanks\nWhat shape? square ok thanks\nWhat shape? square ok thanks\nWhat shape? square ok thanks    forever...\n\nno,\n\n	Operator and Machine have no way to connect. Operator has its own\n	version of machine and therefore does not connect with the machine\n	thread that was started in main. ','Threads',1,NULL),(592,'public class Hello {\n    public static void main(String[] args){\n        CodeMaker cm = new CodeMaker();\n        \n        for(int i = 0; i<10; i++){\n            cm.start();\n        }\n        \n    }\n}\n\nclass CodeMaker  extends Thread {\n    private String code;\n    private int counter;\n    private ArrayList<String> al;\n    private char[] letters = {\'A\',\'B\',\'C\',\'D\',\'E\',\'F\',\'G\',\'H\',\'I\'};\n    \n    public CodeMaker(){\n        counter = 0;\n        al = new ArrayList<>();\n    }\n\n    class SectionGenerator implements Runnable{\n        private String sec = \"\";\n        private Random ran = new Random();\n\n        public void run() {\n            //tried to use notify outside of synchronized context\n            synchronized(this){\n                int x = ran.nextInt(3);\n                int y = ran.nextInt(3);\n                int z = ran.nextInt(3);\n            \n            \n                sec += letters[x];\n                sec += letters[y];\n                sec += letters[z];\n                notifyAll();\n            }\n        }\n        \n        public synchronized String section(){\n            return sec;\n        }\n\n    }\n    \n    class NumberGenerator implements Runnable{\n        private String number = \"\";\n        private Random ran = new Random();\n        \n        public void run(){\n            //tried to use notify outside of synchronized context\n            synchronized(this){\n                int x1 = ran.nextInt(100);\n                int x2 = ran.nextInt(100);\n                int x3 = ran.nextInt(100);\n            \n                number += x1+\".\"+x2+\".\"+x3;\n                notifyAll();\n            }\n        }\n        \n        public synchronized String Number(){\n            return number;\n        }\n    }\n    \n    \n   public synchronized void run(){\n       \n       SectionGenerator sg1 = new SectionGenerator();\n       NumberGenerator ng1 = new NumberGenerator();\n       Thread t1 = new Thread(sg1);\n       Thread t2 = new Thread(ng1);\n       \n       t1.start();\n       t2.start();\n       \n       try{\n        t1.wait();\n        code += sg1.section();\n        t2.wait();\n        code += ng1.Number();\n       } catch(InterruptedException e){\n           \n       }\n       System.out.println(code);\n   }    ','IllegalMonitorStateException\n\nyou cannot call start() on a thread more than once. ','Threads',1,NULL),(593,'You can call start() on a Thread object only once, otherwise you get an\nIllegalThreadStateException\n\nyou can however create many threads from the same runnable','','Threads',1,NULL),(594,'public class Hello implements Runnable {\n\n    public static void main(String[] args) {\n        Thread t = new Thread(new Hello());\n    }\n    \n    public void run() {\n        System.out.println(\"run once\");\n    }\n}\n\n\nwhat state is this thread in ?\n\n','New State\n\nA thread that is created but not yet started is in the new state and not yet alive','Threads',1,NULL),(595,'Once a thread is started it goes into the runnable state,\n\nThe schedular can move a thread back and forth between the runnable state and \nthe running state. \n\nA running thread may enter a blocked / waiting state by a wait, sleep, or join \ncall\n\na running thread can enter the blocked/ waiting state because it cant acquire the lock \nfor a synchroized block\n\na dead thread cannot be started again.',' got it ? ','Threads',1,NULL),(596,'sleeping is used to delay execution for a period of time and .. \n\nno locks are released when a thread goes to sleep','','Threads',1,NULL),(597,'A sleeping thread is thread is guarenteed to sleep for at least the time specified\nin the argument to sleep() but there is not guarentee is actually return to running\n\nthe sleep mehtod is static so it only affects the currently running thread. ','','Threads',1,NULL),(598,'unless explicitly set a thread\'s priority will have the same priority as the thread\nthat created it. ','','Threads',1,NULL),(599,'when one thread call join() on another thread, the currently running thhread\nwill wait until the thread it joins with has completed. Think of join() as saying\n\n\"Hey thread I want to join on to the end of you. let me know when you\'re done, so \nI can enter the runnable state\"','','Threads',1,NULL),(600,'While only one thread can be accessing synchronized code of a particular\ninstance, multiple threads can still access the same object\'s unsynchronized code.\n\nWhen a thread goes to sleep its locks will be unavailable to other threads.','','Threads',1,NULL),(601,'Object.wait() = add me to your waiting list.','','Threads',1,NULL),(602,'notify() is used to send a signal to onne and onnly one of the threads that \nare waiting, it cannot specify which thread will be notified.','','Threads',1,NULL),(603,'wait() notify() and notifyAll() must called from within a synchronized context\nthe synchronization must be with the object that the thread is calling one of these\nmethhods on !','','Threads',1,NULL),(604,'Runnable target = new MyRunnable();\nThread myThread = new Thread(target);\n\n\npublic class MyRunnable extends Runnable{public void run(){}}\npublic class MyRunnable implements Runnable{public void start{}}\npublic class MyRunnable implements Runnable{public void run(){}}\n','the third one','Threads',1,NULL),(605,'public class Hello extends Thread {\n    public static void main(String[] args){\n       Hello h = new Hello();\n       Thread x = new Thread(h);\n       h.start();\n        \n    }\n    \n    public void run() {\n        for(int i=0; i<3; ++i)\n            System.out.print(i+\"...\");\n    }\n}','0..1..2..','Threads',1,NULL),(606,'public class Hello {\n    public static void main(String[] args){\n       printAll(args);\n        \n    }\n    \n    public static void printAll(String[] lines){\n        for(int i = 0; i<lines.length; i++){\n            System.out.println(lines[i]);\n            Thread.currentThread().sleep(1000);\n        }\n    }\n}\n\nwhat is the result','will not compile .sleep() must be enclosed in a try block to catch its\nInterruptedException','Threads',1,NULL),(607,'you have two private variables a and b. prevent concurrent access problems using\ntheir read() and set(int a, int b){} methods.','public synchronized int read() { return a+b; }\npublic synchronized void set(int a, int b){this.a = a; this.b = b;}\n\npublic int read(){ synchronized(this){ return a+b; } }\npublic void set(int a, int b){synchronized(this){ this.a = a; this.b = b;} }\n\n\n','Threads',1,NULL),(608,'public class WaitTest {\n	public static void main(String[] args){\n		sout(\"1\");\n		synchronized(args){\n			sout(\"2\");\n			try{\n				args.wait();\n			} catch(InterruptedException e) {\n			}\n		}\n		sout(\"3\");\n	}\n}\n\n1. IllegalMonitorStateException\n2. will not compile\n3. 1 2 3\n4. 1 2\n5. fails to compile because of wait() illegalMonitorstatexception','1 2 \n\nIllegalMonitorStateException is unchecked and thrown by trying to wait\nsomething yyou do not own the lock to!','Threads',1,NULL),(609,'the following method is called from thread A on an object B and it is properly synchronized\n\nwait(2000);\n\nafter calling the method when will thread A becoma a canidate to get another \nturn at the CPU ?\n','After object B is notified, or after two seconds. ','Threads',1,NULL),(610,'which are true ?\n\n1 the notifyAll() must be called from a synchronized context\n2 to call wati() an object must own the lock on the thread\n3 the notify() method is defined in class java.lang.thread\n4 when a thread is waiting as a result of wait() it releases its lock\n5 notify() method causes a thread to imeediately release its lock\n6 the difference between notify() and notifyAll() is that notifyAll() notifies\nall waiting threads regardless of the object theyre waiting on','1 4','Threads',1,NULL),(611,'public class Logger {\n	private StringBuilder contents = new StringBuilder();\n	public void log(String mess){\n		contents.append(System.currentTimeMillis());\n		contents.append(\": \");\n		contents.append(Thread.currentThread().getName());\n		contents.append(mess);\n	}\n\n	public String getContents() { return contents.toString(); }\n}\n\nhow can you enxure that instances of this class can be safely used by multiple \nthreads ?\n\nreplace StringBuilder with thread-safe StringBuffer ?','synchronize both log() and getContents()\n\neven though stringbuffer is synchronized internally, append is called \nmultiple times so anythread could get in there in between calls','Threads',1,NULL),(612,'public static synchronized void main(Stirng[] args) throws InterruptedException {\n	Thread t = new Thread();\n	t.start();\n	sout(\"X\");\n	t.wait(10000);\n	sout(\"y\");\n}','IllegalMonitorStateException is thrown because the main thread does not \nhave a lock on t before it decides to wait on it. ','Threads',1,NULL),(613,'class MyThread extends Thread {\n	MyThread() {\n		sout(\"MyThread\");\n	}\n	public void run(){\n		sout(\"bar\");\n	}\n\n	public void run(String s){\n		sout(\"baz\");\n	}\n}\n\npublic class Test {\n	psvm(sa){\n		Thread t = new MyThread(){\n			public void run(){\n				sout(\"foo\");\n			}\n		};\n		t.start();\n	}\n}\n		','MyThread foo','Threads',1,NULL),(614,'public class Hello {\n    public static void main(String[] args){\n       WatchService watchService\n          = FileSystems.getDefault().newWatchService();\n \n        Path path = Paths.get(System.getProperty(\"user.home\"));\n \n        path.register(\n          watchService, \n            StandardWatchEventKinds.ENTRY_CREATE, \n              StandardWatchEventKinds.ENTRY_DELETE, \n                StandardWatchEventKinds.ENTRY_MODIFY);\n \n        WatchKey key;\n        while ((key = watchService.take()) != null) {\n            for (WatchEvent<?> event : key.pollEvents()) {\n                System.out.println(\n                  \"Event kind:\" + event.kind() \n                    + \". File affected: \" + event.context() + \".\");\n            }\n            key.reset();\n        }\n        \n    }\n    \n    \n}','will not compile unreported IOException from newWatchService() and \npath.register()','Input/Output',1,NULL),(615,'public class Hello {\n    public static void main(String[] args) throws IOException{\n       WatchService watchService\n          = FileSystems.getDefault().newWatchService();\n \n        Path path = Paths.get(System.getProperty(\"user.home\"));\n \n        path.register(\n          watchService, \n            StandardWatchEventKinds.ENTRY_CREATE, \n              StandardWatchEventKinds.ENTRY_DELETE, \n                StandardWatchEventKinds.ENTRY_MODIFY);\n \n        WatchKey key;\n        while ((key = watchService.take()) != null) {\n            for (WatchEvent<?> event : key.pollEvents()) {\n                System.out.println(\n                  \"Event kind:\" + event.kind() \n                    + \". File affected: \" + event.context() + \".\");\n            }\n            key.reset();\n        }\n        \n    }\n    \n    \n}','will not compile take() throws an InterruptedException because \nit will wait if there are no events present','Input/Output',1,NULL),(616,'public class Hello {\n    public static void main(String[] args) throws IOException, InterruptedException {\n       WatchService watchService\n          = FileSystems.getDefault().newWatchService();\n \n        Path path = Paths.get(System.getProperty(\"user.home\"));\n \n        path.register(\n          watchService, \n            StandardWatchEventKinds.ENTRY_CREATE, \n              StandardWatchEventKinds.ENTRY_DELETE, \n                StandardWatchEventKinds.ENTRY_MODIFY);\n \n        WatchKey key;\n        while ((key = watchService.take()) != null) {\n            for (WatchEvent<?> event : key.pollEvents()) {\n                System.out.println(\n                  \"Event kind:\" + event.kind() \n                    + \". File affected: \" + event.context() + \".\");\n            }\n            key.reset();\n        }\n        \n    }\n    \n    \n}','compiles fine if you were to delete a file from home directory \nyou would get a notice like this: \n	\n	Event kind:ENTRY_CREATE. File affected: Untitled Document.\n\n','Input/Output',1,NULL),(617,'public class Hello {\n    public static void main(String[] args) throws IOException {\n       WatchService watchService\n          = FileSystems.getDefault().newWatchService();\n \n        Path path = Paths.get(System.getProperty(\"user.home\"));\n \n        path.register(\n          watchService, \n            StandardWatchEventKinds.ENTRY_CREATE, \n              StandardWatchEventKinds.ENTRY_DELETE, \n                StandardWatchEventKinds.ENTRY_MODIFY);\n \n        WatchKey key;\n        while ((key = watchService.poll()) != null) {\n            for (WatchEvent<?> event : key.pollEvents()) {\n                System.out.println(\n                  \"Event kind:\" + event.kind() \n                    + \". File affected: \" + event.context() + \".\");\n            }\n            key.reset();\n        }\n        \n    }\n    \n    \n}','this would run one time, if there were no WatchEvents immediately available\nit would end.\nPoll() gets events and does not wait. \n\n','Input/Output',1,NULL),(618,'Path path = Paths.get(\"/home\");\nWatchService watchService = FileSystems.getDefault().newWatchService();\nWatchKey watchKey = path.register(watchService,ENTRY_CREATE,ENTRY_DELETE,ENTRY_MODIFY);\n\nprivate boolean notDone = true;\nwhile(notDone){\n    try{\n         WatchKey watchKey = watchService.poll(60,TimeUnit.SECONDS);\n         List<WatchEvent.Kind<?>> events = watchKey.pollEvents();\n         for(WatchEvent event : events){\n            ...process the events\n         }\n         if(!watchKey.reset()){\n            ...handle situation no longer valid\n         }\n     }catch(InterruptedException e){\n            Thread.currentThread().interrupt();\n     }','...just a good example','Input/Output',1,NULL),(619,'public class Hello {\n    public static void main(String[] dicks){\n        Thread t1 = new Thread(new Advertiser());\n        Thread t2 = new Thread(new Subleaser());\n    }\n\n}    \n\nclass MessageBoard {\n    private StringBuilder contents = new StringBuilder();\n    \n    public synchronized void postMessage(String s){\n        contents.append(s + \" \");\n    }\n    \n    public synchronized String readBoard(){\n        return contents.toString();\n    }\n    \n    public StringBuilder takeTurnAtBoard(){\n        return contents;\n    }\n}\n\nclass Advertiser implements Runnable{\n    protected MessageBoard mb = new MessageBoard();\n    public void run(){\n        synchronized(mb){\n            mb.postMessage(\"Attention!\");\n            mb.postMessage(\"Platonics\");\n            mb.postMessage(\"Lost Dog! 1000$ reward\");\n            mb.postMessage(\"Sex Change coupon\");\n            \n            System.out.println(mb.readBoard());\n        } \n    }\n}\n\nclass Subleaser{\n    private MessageBoard mb = new MessageBoard();\n    \n    public void run(){\n        synchronized(mb){\n            mb.postMessage(\"1000 a month!\");\n            mb.postMessage(\"two br\");\n            mb.postMessage(\"no dogs allowed!\");\n        }\n    }\n}','will not compile, Subleaser does not implemnet runnable!\n\nAlso the two threads synchronize on their very own messageboards so \nthey have no problem getting access to them and printing their messages.\n\nSecondly Nothing is ever printed from the MessageBoard.','Threads',1,NULL),(620,'public class Hello {\n    public static void main(String[] dicks){\n        Thread t1 = new Thread(new Advertiser(),\"advertiser\");\n        Thread t2 = new Thread(new Subleaser(),\"subleaser\");\n        \n        t1.start();\n        t2.start();\n    }\n\n}    \n\nclass MessageBoard {\n    private StringBuilder contents = new StringBuilder();\n    \n    public synchronized void postMessage(String s){\n        contents.append(s);\n        contents.append(\" \");\n    }\n    \n    public synchronized String readBoard(){\n        return contents.toString();\n    }\n    \n    public StringBuilder takeTurnAtBoard(){\n        return contents;\n    }\n}\n\nclass Advertiser implements Runnable{\n    protected MessageBoard mb = new MessageBoard();\n    public void run(){\n            //Thread.getName() static method cannot be called from non static\n            mb.postMessage(Thread.currentThread().getName()+\" \");\n            mb.postMessage(\"Attention!\");\n            mb.postMessage(\"Platonics\");\n            mb.postMessage(\"Lost Dog! 1000$ reward\");\n            mb.postMessage(\"Sex Change coupon\");\n            \n            System.out.println(mb.readBoard());\n        \n    }\n}\n\nclass Subleaser implements Runnable{\n    private MessageBoard mb = new MessageBoard();\n    \n    public void run(){\n            mb.postMessage(Thread.currentThread().getName()+\" \");\n            mb.postMessage(\"1000 a month!\");\n            mb.postMessage(\"two br\");\n            mb.postMessage(\"no dogs allowed!\");\n            \n            System.out.println(mb.readBoard());\n        }\n}','subleaser  1000 a month! two br no dogs allowed! \nadvertiser  Attention! Platonics Lost Dog! 1000$ reward Sex Change coupon \n\nadvertiser  Attention! Platonics Lost Dog! 1000$ reward Sex Change coupon \nsubleaser  1000 a month! two br no dogs allowed!\n\nthese results can be unpredictable, though the methods are synched\nnothing is stopping another thread from coming in between append calls.\n\nto make the ressults truly predictable synchronized the postmessage calls in a block\non mb','Input/Output',1,NULL),(621,'public class Hello {\n    public static void main(String[] dicks){\n        MessageBoard mb = new MessageBoard();\n        Thread t1 = new Thread(new Advertiser(mb),\"advertiser\");\n        Thread t2 = new Thread(new Subleaser(mb),\"subleaser\");\n        \n        t1.start();\n        t2.start();\n    }\n\n}    \n\nclass MessageBoard {\n    private StringBuilder contents = new StringBuilder();\n    \n    public synchronized void postMessage(String s){\n        contents.append(s);\n        contents.append(\" \");\n    }\n    \n    public synchronized String readBoard(){\n        return contents.toString();\n    }\n    \n    public StringBuilder takeTurnAtBoard(){\n        return contents;\n    }\n}\n\nclass Advertiser implements Runnable{\n    protected MessageBoard mb;\n    \n    public Advertiser(MessageBoard mb){\n        this.mb = mb;\n    }\n    public void run(){\n            //Thread.getName() static method cannot be called from non static\n            mb.postMessage(Thread.currentThread().getName()+\" \");\n            mb.postMessage(\"Attention!\");\n            mb.postMessage(\"Lost Dog! 1000$ reward\");\n            mb.postMessage(\"Sex Change coupon\");\n            \n            System.out.println(mb.readBoard());\n        \n    }\n}\n\nclass Subleaser implements Runnable{\n    private MessageBoard mb;\n    \n    public Subleaser(MessageBoard mb){\n        this.mb = mb;\n    }\n    \n    public void run(){\n            mb.postMessage(Thread.currentThread().getName()+\" \");\n            mb.postMessage(\"two br\");\n            mb.postMessage(\"no dogs allowed!\");\n            mb.postMessage(\"1200$ a month\");\n            \n            System.out.println(mb.readBoard());\n        }\n}\n','these can be quiet unpredictable:\n\n	subleaser  two br no dogs allowed! 1200$ a month advertiser  Attention! Lost Dog! 1000$ reward Sex Change coupon \nsubleaser  two br no dogs allowed! 1200$ a month advertiser  Attention! Lost Dog! 1000$ reward Sex Change coupon \n\nBoth threads are operating on the same instance, that instances objects\nmethods are synchronized but that doesn\'t stop the other thread from coming\ninbetween calls to postMessage()','Input/Output',1,NULL),(622,'public class Hello {\n    public static void main(String[] dicks){\n        MessageBoard mb = new MessageBoard();\n        Thread t1 = new Thread(new Advertiser(mb),\"advertiser\");\n        Thread t2 = new Thread(new Subleaser(mb),\"subleaser\");\n        \n        t1.start();\n        t2.start();\n    }\n\n}    \n\nclass MessageBoard {\n    private StringBuilder contents = new StringBuilder();\n    \n    public synchronized void postMessage(String s){\n        contents.append(s);\n        contents.append(\" \");\n    }\n    \n    public synchronized String readBoard(){\n        return contents.toString();\n    }\n    \n    public StringBuilder takeTurnAtBoard(){\n        return contents;\n    }\n}\n\nclass Advertiser implements Runnable{\n    protected MessageBoard mb;\n    \n    public Advertiser(MessageBoard mb){\n        this.mb = mb;\n    }\n    public void run(){\n        synchronized(mb){\n            //Thread.getName() static method cannot be called from non static\n            mb.postMessage(Thread.currentThread().getName()+\" \");\n            mb.postMessage(\"Attention!\");\n            mb.postMessage(\"Lost Dog! 1000$ reward\");\n            mb.postMessage(\"Sex Change coupon\");\n            \n            System.out.println(mb.readBoard());\n        }\n    }\n}\n\nclass Subleaser implements Runnable{\n    private MessageBoard mb;\n    \n    public Subleaser(MessageBoard mb){\n        this.mb = mb;\n    }\n    \n    public void run(){\n        synchronized(mb){\n            mb.postMessage(Thread.currentThread().getName()+\" \");\n            mb.postMessage(\"two br\");\n            mb.postMessage(\"no dogs allowed!\");\n            mb.postMessage(\"1200$ a month\");\n            \n            System.out.println(mb.readBoard());\n        }\n        }\n        \n}\n','You can be assured that these results will be predictable,\n\nThe synchronized blocks get a hold of the lock so it is just a compettion\nof which thread will lock first. ','Input/Output',1,NULL),(623,'public class Hello {\n    public static void main(String[] dicks) throws InterruptedException {\n        try{\n            WatchService watcher = FileSystems.getDefault().newWatchService();\n            Path home = Paths.get(\"/home/maxbisesi\");\n            home.register(watcher, StandardWatchEventKinds.ENTRY_CREATE,StandardWatchEventKinds.ENTRY_DELETE);\n            \n            WatchKey key;\n            \n            //throws interruptedException \n            while((key = watcher.take()) != null) {\n                for(WatchEvent<?> event : key.pollEvents()){\n                    System.out.println(event.context() + \" \" + event.kind());\n              }\n           }\n        } catch(IOException ei){\n            \n        }    \n    }\n\n}    \n\nI delete foo.txt out of the home directory then go into Documents and delete\nindex.html. What is the result ?','foo.txt ENTRY_DELETE\n\n... Watcher only watches one directory at a time, not subdirectories','Input/Output',1,NULL),(624,'public class Starter implements Runnable {\n	void go(long id) {\n		sout(id);\n	}\n\n	public static void main(String[] args){\n		sout(Thread.currentThread().getId() + \" \");\n		//insert code\n	}\n	public void run() { go(Thread.currentThread().getId()); }\n}\n\n1. new Starter().run();\n2. new Starter().start();\n3. new Thread(new Starter());\n4. new Thread(new Starter()).run();\n5. new Thread(new Starter()).start();','1. 4 4 \n2. does not compile\n3. prints nothign , but starts a new thread\n4. creates a new thread and invokes run() directlyy\n5. creates and starts a new thread. ','Input/Output',1,NULL),(625,'public class Hello implements Runnable {\n    public void run(){\n        System.out.println(\"r1 \");\n        System.out.println(\"r2 \");\n    }\n    public static void main(String[] args){\n        Thread t = new Thread(new Hello());\n        t.start();\n        System.out.println(\"m1 \");\n        t.join();\n        System.out.println(\"m2 \");\n    }\n}','will not commpile, join throws interruptedexception ','Input/Output',1,NULL),(626,'public class Hello implements Runnable {\n    public void run(){\n        System.out.println(\"r1 \");\n        System.out.println(\"r2 \");\n    }\n    public static void main(String[] args){\n        Thread t = new Thread(new Hello());\n        t.start();\n        System.out.println(\"m1 \");\n        try{\n            t.join();\n        } catch(InterruptedException e){\n            \n        }\n        System.out.println(\"m2 \");\n    }\n}','could be:\n\nm1 r1 r2 m2\nr1 m1 r2 m2\nr1 r2 m1 m2\n\njoin throws interruptedexception, it causes main to join onto the end\nof the thread t and wait till its done to continue. ','Input/Output',1,NULL),(627,'public class Hello implements Runnable {\n    Chicks c;\n    public void run(){\n       c.yack(Thread.currentThread().getId());\n    }\n    public static void main(String[] args){\n        new Hello().go();\n       \n    }\n    \n    void go(){\n        c = new Chicks();\n        new Thread(new Hello()).start();\n        new Thread(new Hello()).start();\n    }\n}\n\nclass Chicks {\n    synchronized void yack(long id){\n        for(int x = 1; x <3; x++){\n            System.out.println(id + \" \");\n            Thread.yield();\n        }\n    }\n}','NullpointerException,\n\nthis one is hard to spot but c is initialized in the go method, an \ninstance method. The two threads start their own new instance and go\ndirectly to the run() method, without go() c never gets initialized. \n\nfor this to work c would have to be static. \n','Input/Output',1,NULL),(628,'public class Hello implements Runnable {\n    static Chicks c;\n    public void run(){\n       c.yack(Thread.currentThread().getId());\n    }\n    public static void main(String[] args){\n        new Hello().go();\n       \n    }\n    \n    void go(){\n        c = new Chicks();\n        new Thread(new Hello()).start();\n        new Thread(new Hello()).start();\n    }\n}\n\nclass Chicks {\n    synchronized void yack(long id){\n        for(int x = 1; x <3; x++){\n            System.out.println(id + \" \");\n            Thread.yield();\n        }\n    }\n}','8\n8\n9\n9','Input/Output',1,NULL),(629,'public class Hello implements Runnable {\n    static Chicks c;\n    public void run(){\n       c.yack(Thread.currentThread().getId());\n    }\n    public static void main(String[] args){\n        new Hello().go();\n       \n    }\n    \n    void go(){\n        c = new Chicks();\n        new Thread(new Hello()).start();\n        new Thread(new Hello()).start();\n    }\n}\n\nclass Chicks {\n    static long flag = 0;\n    synchronized void yack(long id){\n        if(flag == 0) flag = id;\n        for(int x = 1; x <3; x++){\n            if(flag == id) System.out.println(\"yada yada \");\n            else System.out.println(\"ehh \");\n        }\n    }\n}','','Input/Output',1,NULL),(630,'public class Hello implements Runnable {\n    public void run(){\n       move(Thread.currentThread().getId());\n    }\n    \n    void move(long id){\n        System.out.println(id + \" \");\n        System.out.println(id + \" \");\n    }\n    public static void main(String[] args){\n        Hello h = new Hello();\n        new Thread(h).start();\n        new Thread(new Hello()).start();\n    }\n}','the output could be 8 9 8 9\n\n..it could be anything really','Input/Output',1,NULL),(631,'public class Hello implements Runnable {\n    public void run(){\n       move(Thread.currentThread().getId());\n    }\n    \n    synchronized void move(long id){\n        System.out.println(id + \" \");\n        System.out.println(id + \" \");\n    }\n    public static void main(String[] args){\n        Hello h = new Hello();\n        new Thread(h).start();\n        new Thread(new Hello()).start();\n    }\n}','the output could be 4 2 4 2\n\nWhile the method is synhcronized it is being invoked by two different\nobjects so they could print in any order still \n\n','Input/Output',1,NULL),(632,'test	','test','Input/Output',1,NULL),(633,'Which method from a CopyOnWriteArrayList will caue a new copy of the internal\narray to be created ?','add  and  remove','Input/Output',1,NULL),(634,'public class Hello {\n    public static void main(String[] args){\n        new ReentrantLockingDemo().go();\n    }\n}\n\nclass ReentrantLockingDemo {\n\n    final Lock lock = new ReentrantLock();\n\n    public void go() {\n\n        Runnable run1 = newRunable();\n        Thread t1 = new Thread(run1, \"Thread1\");\n        System.out.println(run1.hashCode());\n        t1.start();\n\n        Runnable run2 = newRunable();\n        Thread t2 = new Thread(run2, \"Thread2\");\n        System.out.println(run2.hashCode());\n        t2.start();\n\n    }\n\n    private Runnable newRunable() {\n        return new Runnable() {\n            public int hashCode() {\n                return super.hashCode();\n            }\n            public void run() {\n                do {\n                    try {\n                        if (lock.tryLock(500, TimeUnit.MILLISECONDS)) {\n                            try {\n                                System.out.println(\"locked thread \"\n                                        + Thread.currentThread().getName());\n                                Thread.sleep(1000);\n                            } finally {\n                                lock.unlock();\n                                System.out.println(\"unlocked locked thread \"\n                                        + Thread.currentThread().getName());\n                            }\n                            break;\n                        } else {\n                            System.out.println(\"unable to lock thread \"\n                                    + Thread.currentThread().getName()\n                                    + \" will re try again\");\n                        }\n                    } catch (InterruptedException e) {\n                        e.printStackTrace();\n                    }\n                } while (true);\n            }     \n        };\n    }\n\n}','2018699554\n1311053135\nlocked thread Thread1\nunable to lock thread Thread2 will re try again\nunlocked locked thread Thread1\nlocked thread Thread2\nunlocked locked thread Thread2\n\nThe two threads use two different Runnables, but they are both vying for the same\nlock. ','Input/Output',1,NULL),(635,'public class ThreadTest {\n	class InnerRun implements Runnable {\n		public void run() {\n			for(int x = 0; x < 100; x++){\n				try{\n					Thread.sleep(5);\n				} catch(Exception e) {}\n				sout( \"Ren\" );\n			}\n		}\n	}\n\n	class InnerRunTwo implements Runnable {\n		Thread other;\n		public InnerRunTwo(Thread x){ other = x; }\n		public void run() {\n			try{\n				other.join();\n			} catch(Exception e) { }\n			for(int x = 0; x < 100; x++){\n			   try{\n				Thread.sleep(5);\n			   } catch( Exception e) { }\n			   sout( \"stimpy\" );\n			}\n		}	\n	}\nvoid start(){\n	InnerRun ir = new InnerRun();\n	Thread t = new Thread(ir);\n	InnerRunTwo irr = new InnerRunTwo(t);\n	Thread u = new Thread(irr);\n		t.start();	\n		u.start();\n}\npsvm(SA){ ThreadTest tt = new ThreadTest(); tt.start(); }\n}','How a join should be used and implemented. \n\n100 Rens followed by 100 stimpys','Input/Output',1,NULL),(636,'public class Hello {\n    public static void main(String[] args){\n        Data data = new Data();\n        DataThread dt = new DataThread(data);\n        Thread t1 = new Thread(dt);\n        Thread t2 = new Thread(dt);\n        Thread t3 = new Thread(dt);\n        Thread t4 = new Thread(dt);\n        Thread t5 = new Thread(dt);\n        \n        t1.start();\n        t2.start();\n        t3.start();\n        t4.start();\n        t5.start();\n        \n    }\n}\n\nclass Data {\n    public Object lock = new Object();\n    public static Object staticLock = new Object();\n    \n    public synchronized void instanceLocked(){\n        System.out.println(\"Instance locked by: \"+Thread.currentThread().getName());\n    }\n    \n    public static synchronized void classLocked(){\n        System.out.println(\"class locked by: \"+Thread.currentThread().getName());\n        while(true){\n            \n        }\n    }\n}\n\nclass DataThread implements Runnable {\n    private Data data;\n    \n    public DataThread(Data data){\n        this.data = data;\n    }\n    public void run(){\n        synchronized(data.lock){\n            \n            for(int i = 0; i<100; i++){\n                data.instanceLocked();\n                System.out.println(i);\n                \n                try{\n                    Thread.sleep(1000);\n                } catch(InterruptedException e){\n                    \n                }\n            }\n            \n        }\n    }\n    \n}','run:\nInstance locked by: Thread-0\n0\nInstance locked by: Thread-0\n1\nInstance locked by: Thread-0\n2\nInstance locked by: Thread-0\n3\nInstance locked by: Thread-0\n4\nInstance locked by: Thread-0\n5\nInstance locked by: Thread-0\n6\nInstance locked by: Thread-0\n7\nInstance locked by: Thread-0\n8\nInstance locked by: Thread-0\n9\nInstance locked by: Thread-0\n10\nBUILD STOPPED (total time: 10 seconds)\n','Input/Output',1,NULL),(637,'public class Hello {\n    public static void main(String[] args){\n         final Safelock.Friend alphonse =\n            new Safelock.Friend(\"Alphonse\");\n        final Safelock.Friend gaston =\n            new Safelock.Friend(\"Gaston\");\n        new Thread(new Safelock.BowLoop(alphonse, gaston)).start();\n        new Thread(new Safelock.BowLoop(gaston, alphonse)).start();\n    }\n}\n\nclass Safelock {\n    static class Friend {\n        private final String name;\n        private final Lock lock = new ReentrantLock();\n\n        public Friend(String name) {\n            this.name = name;\n        }\n\n        public String getName() {\n            return this.name;\n        }\n\n        public boolean impendingBow(Friend bower) {\n            Boolean myLock = false;\n            Boolean yourLock = false;\n            try {\n                myLock = lock.tryLock();\n                yourLock = bower.lock.tryLock();\n            } finally {\n                if (! (myLock && yourLock)) {\n                    if (myLock) {\n                        lock.unlock();\n                    }\n                    if (yourLock) {\n                        bower.lock.unlock();\n                    }\n                }\n            }\n            return myLock && yourLock;\n        }\n            \n        public void bow(Friend bower) {\n            if (impendingBow(bower)) {\n                try {\n                    System.out.format(\"%s: %s has\"\n                        + \" bowed to me!%n\", \n                        this.name, bower.getName());\n                    bower.bowBack(this);\n                } finally {\n                    lock.unlock();\n                    bower.lock.unlock();\n                }\n            } else {\n                System.out.format(\"%s: %s started\"\n                    + \" to bow to me, but saw that\"\n                    + \" I was already bowing to\"\n                    + \" him.%n\",\n                    this.name, bower.getName());\n            }\n        }\n\n        public void bowBack(Friend bower) {\n            System.out.format(\"%s: %s has\" +\n                \" bowed back to me!%n\",\n                this.name, bower.getName());\n        }\n    }\n\n    static class BowLoop implements Runnable {\n        private Friend bower;\n        private Friend bowee;\n\n        public BowLoop(Friend bower, Friend bowee) {\n            this.bower = bower;\n            this.bowee = bowee;\n        }\n    \n        public void run() {\n            Random random = new Random();\n            for (;;) {\n                try {\n                    Thread.sleep(random.nextInt(10));\n                } catch (InterruptedException e) {}\n                bowee.bow(bower);\n            }\n        }\n    }\n}','Gaston: Alphonse has bowed to me!\nAlphonse: Gaston started to bow to me, but saw that I was already bowing to him.\nAlphonse: Gaston has bowed back to me!\nAlphonse: Gaston has bowed to me!\nGaston: Alphonse has bowed back to me!\nAlphonse: Gaston has bowed to me!\nGaston: Alphonse has bowed back to me!\nGaston: Alphonse has bowed to me!\nAlphonse: Gaston has bowed back to me!\nAlphonse: Gaston has bowed to me!\nGaston: Alphonse has bowed back to me!\nGaston: Alphonse has bowed to me!\nAlphonse: Gaston has bowed back to me!\nAlphonse: Gaston has bowed to me!\nGaston: Alphonse has bowed back to me!\nGaston: Alphonse has bowed to me!\nAlphonse: Gaston has bowed back to me!\nAlphonse: Gaston has bowed to me!\nGaston: Alphonse has bowed back to me!\nGaston: Alphonse has bowed to me!\nAlphonse: Gaston has bowed back to me!\nGaston: Alphonse has bowed to me!\nAlphonse: Gaston has bowed back to me!\nAlphonse: Gaston has bowed to me!\nGaston: Alphonse has bowed back to me!\nAlphonse: Gaston has bowed to me!\nGaston: Alphonse has bowed back to me!\nGaston: Alphonse has bowed to me!\nAlphonse: Gaston has bowed back to me!\nAlphonse: Gaston has bowed to me!\nGaston: Alphonse has bowed back to me!\nGaston: Alphonse started to bow to me, but saw that I was already bowing to him.\nAlphonse: Gaston has bowed to me!\nGaston: Alphonse has bowed back to me!\nAlphonse: Gaston has bowed to me!\nGaston: Alphonse has bowed back to me!','Input/Output',1,NULL),(638,'class BoundedBuffer {\n   final Lock lock = new ReentrantLock();\n   final Condition notFull  = lock.newCondition(); \n   final Condition notEmpty = lock.newCondition(); \n\n   final Object[] items = new Object[100];\n   int putptr, takeptr, count;\n\n   public void put(Object x) throws InterruptedException {\n     lock.lock();\n     try {\n       while (count == items.length)\n         notFull.await();\n       items[putptr] = x;\n       if (++putptr == items.length) putptr = 0;\n       ++count;\n       notEmpty.signal();\n     } finally {\n       lock.unlock();\n     }\n   }\n\n   public Object take() throws InterruptedException {\n     lock.lock();\n     try {\n       while (count == 0)\n         notEmpty.await();\n       Object x = items[takeptr];\n       if (++takeptr == items.length) takeptr = 0;\n       --count;\n       notFull.signal();\n       return x;\n     } finally {\n       lock.unlock();\n     }\n   }\n }','good example of Conditions','Input/Output',1,NULL),(639,'class DataThread implements Runnable {\n    private Data data;\n    private ArrayList listData;\n    \n    public DataThread(Data data){\n        this.data = data;\n    }\n    public void run(){\n            data.lock.lock();\n            try{\n                listData = data.produceData();\n            try{\n               data.done.await();\n            } catch(InterruptedException e){\n                \n            }\n            \n            for(Integer i : listData){\n                System.out.println(i);\n            }\n            } finally {\n                data.lock.unlock();\n            }\n    }\n    \n}','Will not compile, ArrayList listData is a raw type so in the foreach loop\nyou assign them to an Integer, you would have had to cast','Input/Output',1,NULL),(640,'public class Hello {\n    private List<Integer> integers = new ArrayList<>();\n    private ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();\n    \n    public void add(Integer i){\n        rwl.writeLock().lock();\n        try {\n            integers.add(i);\n        } finally {\n            rwl.writeLock().unlock();\n        }\n    }\n    \n    public int findMax() {\n        rwl.readLock().lock();\n        try {\n            return Collections.max(integers);\n        } finally {\n            rwl.readLock().unlock();\n        }\n    }\n    public static void main(String[] args){\n      \n    }\n\n}','With ReentrantReadWriteLock you can grant write access to only one thread, but\nit is possible to allow many threads to be reading at the same time. ','Input/Output',1,NULL),(641,'read-only(immutabel) objects are always thread safe. ','','Input/Output',1,NULL),(642,'Use copy on write collections when...','your data sets remain small and the number of read operations and traversals greatly outnumber\nmodifications to the collection. \n\nCopy on write collections work by copying their internal array of data with\nany mutating operation. This copied array will replace the original read only\narrray. \n\nThis allows it to be safely shared between multiple threads. ','Input/Output',1,NULL),(643,'Just because a collection is thread safe does not make the elements stored within\nthread safe','','Input/Output',1,NULL),(644,'The Iterator for a concurrent collection is weakly consistent; it can return elements \nfrom the point in time the Iterator was created or LATER. This means that \nwhile looping through a concurrent collection, you might observel elements that\nare being inserted by other threads. also you might see only some of the elements\nthat another thread is inserting. ','','Input/Output',1,NULL),(645,'Which concurrent Collections are sorted ?','ConcurrentSkipListMap and ConcurrentSkipListSet \n\n-They require the use of comparable and comparotr to enable ordering. ','Input/Output',1,NULL),(646,'copy on write and concurrent collections are centered on the idea of multiple\nthreads sharing data. \n\nA BlockingQueue is used to exchnage data between two or more threads while causing\nsome of the threads to wait until the point in time when the data can be \ntransfered. ','','Input/Output',1,NULL),(647,'class Hello {\n    public static void main(String[] args) {     \n        Pattern p = Pattern.compile(\"\\\\B\\\\d\\\\B\");\n        Matcher m = p.matcher(\"Th4t\'ll b3 the d4y, on th3 v3ry l6ast d8y\");\n        \n        while(m.find()){\n            System.out.println(m.group());\n        }\n        \n    }\n\n}','4\n4\n3\n6\n8\n\nto indicate that you want a pattern to be surrounded by other similar characteres\nsurround it with non word boundaries. If you did want the character to \nbee alone surround it with word boudaries.','Strings',1,NULL),(648,'BlockingQueue implementations','ArrayBlockingQueue\nLinkedBlockingQueue\nLinkedBlockingQueue\nPriorityBlockingQueue\nDelayQueue\nLinkedTransferQueue\nSynchronousQueue\n','Concurrency',1,NULL),(649,'A blocking collection, depending on the method being called, may cause a thread to block\nuntil another threads calls a corresponding method on the collection. \n\nif you attempt to reemove an element() by calling take() on any BlockingQueue\nthat is empty, the operation will block until another thread inserts an element.\n','','Concurrency',1,NULL),(650,'BlockingQueue method:\n\nadd(E e)','Returns true if object added,\n\nfalse if duplicate objects are not allowed.\n\nThrows IllegalStateException if the queue is bounded and full','Concurrency',1,NULL),(651,'BlockingQueue method:\n\noffer(E e)','returns true if object added, false if the queue is bounded and full','Concurrency',1,NULL),(652,'BlockingQueue method:\n\nput(E e)','returns void.\n\nwill block until space in the queue becomes available if needed ','Concurrency',1,NULL),(653,'offer(E e, long timeout, TimeUnit unit)','returns false if the object was not able to be inserted before the time idicated,\n','Concurrency',1,NULL),(654,'BlockingQueue method:\n\nremove(Object o)','returns true if an equal object was found in the queue and removed; \notherwise returns false.','Concurrency',1,NULL),(655,'BlockingQueue method:\n\npoll(long timeout, TimeUnit unit)','removes the first object in the queue and returns it. \n\nif the timeout expires before an object can be removed becaue the queue is empty\nthen a null will be returned. ','Concurrency',1,NULL),(656,'BlockingQueue method:\n\ntake()','Removes and returns the first object in the queue, blocking if needed until the \nobject becomes available. \n\nonly throws InterruptedException','Concurrency',1,NULL),(657,'BlockingQueue method:\n\npoll()','removes and returns the first object in the queue and returns null if the queue is empty\n','Concurrency',1,NULL),(658,'BlockingQueue method:\n\nelement()','Gets the head of the queue without removing it, Throws a NoSuchElementException\nif the queue is empty. ','Concurrency',1,NULL),(659,'BlockingQueue method:\n\npeek()','gets the head of the queue without removing it, Returns a null if the queue is \nempty. ','Concurrency',1,NULL),(660,'BlockingQueue<Integer> bq = new ArrayBlockingQueue<>(1);\n\ntry{\n	bq.put(34);\n	bq.put(35);\n} catch(InterruptedException e) {}','The second put(35) will block until previous values is removed by another thread.','Concurrency',1,NULL),(661,'SynchronousQueue','...is a speciel type of bounded blocking queue; it has a capacity of \nzero. The first thread to attempt either an insert or remvoe operaion\non a synchronousQueue will block until another thread performs the opposite \noperation. USe this when you need threads to meet up and exchange an object.','Concurrency',1,NULL),(662,'public class Hello {\n    public static void main(String[] args){\n       CopyOnWriteArrayList<Integer> list = new CopyOnWriteArrayList<>();\n       \n       list.add(5);\n       list.add(9);\n       Iterator<Integer> it = list.iterator();\n       \n       list.add(3);\n       \n       while(it.hasNext()){\n           System.out.println(it.next());\n       }\n    }\n}','5\n9\n\nThe iterator was obtained before the 3 was added. As long as the reference to \nthe iterator is maintained it will only provide access to 5 9.\n\nIt is ConcurrentCollections that will remain weakly consistant with the changes\nmade by other threads, This is a copyonwrite array list which is thread safe but\nnot concurrent.','Concurrency',1,NULL),(663,'public class Hello {\n    public static void main(String[] args){\n       CopyOnWriteArrayList<Integer> cowlist = new CopyOnWriteArrayList<>();\n       \n       cowlist.add(5);\n       cowlist.add(9);\n       cowlist.add(4);\n       \n       Iterator<Integer> it = cowlist.iterator();\n       \n       cowlist.remove(2);\n       \n       while(it.hasNext()){\n           System.out.println(it.next());\n       }\n       \n    }\n}','5\n9\n4\n\nThe iterator is obtained before the element at index 2 is removed.','Concurrency',1,NULL),(664,'public class Hello {\n    public static void main(String[] args){\n       CopyOnWriteArrayList<Integer> cowlist = new CopyOnWriteArrayList<>();\n       \n       cowlist.add(5);\n       cowlist.add(9);\n       cowlist.add(4);\n       \n       Iterator<Integer> it = cowlist.iterator();\n       \n       cowlist.remove(5);\n       \n       while(it.hasNext()){\n           System.out.println(it.next());\n       }\n       \n    }\n}','IndexOutofBoundsException \n\nthis can be confusing here the remove(int index) is being used. \n\nto fix do this\n\ncowlist.remove(new Integer(5));','Concurrency',1,NULL),(665,'Which methods from copyonwritearraylist will cause a new copy of the internal\narray to be created\n\nadd\nget\niterator\nremove','add and remove. These are the only methods shown that modify the list','Concurrency',1,NULL),(666,'ArrayBlockingQueue<Integer> abq = new ArrayBlockingQueue<>(10);\n\nwhich operation can block indefinitely\n\nabq.add(1);\nabq.offer(1);\nabq.put(1);\nabq.offer(1,5,TimeUnit.SECONDS);','only put()','Concurrency',1,NULL),(667,'public class Hello implements Runnable {\n    private static ArrayBlockingQueue<Integer> abq = new ArrayBlockingQueue<>(10);\n    public static void main(String[] args){\n       Hello h = new Hello();\n       Thread t1 = new Thread(h);\n       Thread t2 = new Thread(h);\n       Thread t3 = new Thread(h);\n       Thread t4 = new Thread(h);\n       \n       t1.start();\n       t2.start();\n       t3.start();\n       t4.start();\n       \n    }\n    public void run(){\n        for(int i = 0; i<5; i++){\n            abq.add(i);\n        }\n    }\n}','IllegalStateEXception queue is full','Concurrency',1,NULL),(668,'public class Hello implements Runnable {\n    private static ArrayBlockingQueue<Integer> abq = new ArrayBlockingQueue<>(10);\n    public static void main(String[] args){\n       Hello h = new Hello();\n       Thread t1 = new Thread(h);\n       Thread t2 = new Thread(h);\n       Thread t3 = new Thread(h);\n       Thread t4 = new Thread(h);\n       \n       t1.start();\n       t2.start();\n       t3.start();\n       t4.start();\n       \n    }\n    public void run(){\n        for(int i = 0; i<5; i++){\n            System.out.println(abq.add(i));\n        }\n    }\n}','true\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\nException in thread \"Thread-2\" java.lang.IllegalStateException: Queue full\n	at java.util.AbstractQueue.add(AbstractQueue.java:98)\n	at java.util.concurrent.ArrayBlockingQueue.add(ArrayBlockingQueue.java:312)\n	at hello.Hello.run(Hello.java:27)\n	at java.lang.Thread.run(Thread.java:745)\nException in thread \"Thread-3\" java.lang.IllegalStateException: Queue full\n	at java.util.AbstractQueue.add(AbstractQueue.java:98)\n	at java.util.concurrent.ArrayBlockingQueue.add(ArrayBlockingQueue.java:312)\n	at hello.Hello.run(Hello.java:27)\n	at java.lang.Thread.run(Thread.java:745)','Concurrency',1,NULL),(669,'public class Hello implements Runnable {\n    private static ArrayBlockingQueue<Integer> abq = new ArrayBlockingQueue<>(10);\n    public static void main(String[] args){\n       Hello h = new Hello();\n       Thread t1 = new Thread(h);\n       Thread t2 = new Thread(h);\n       Thread t3 = new Thread(h);\n       Thread t4 = new Thread(h);\n       \n       t1.start();\n       t2.start();\n       t3.start();\n       t4.start();\n       \n    }\n    public void run(){\n        for(int i = 0; i<5; i++){\n            System.out.println(abq.offer(i));\n        }\n    }\n}','offer() Inserts the specified element at the tail of this queue if \nit is possible to do so immediately \nwithout exceeding the queue\'s capacity, \nreturning true upon success and false if this queue is full. \nThis method is generally preferable to method add(E), which can fail to insert an element \nonly by throwing an exception.\n\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\nfalse\nfalse\nfalse\nfalse\nfalse\nfalse\nfalse\nfalse\nfalse\nfalse','Concurrency',1,NULL),(670,'public class Hello implements Runnable {\n    private static ArrayBlockingQueue<Integer> abq = new ArrayBlockingQueue<>(10);\n    public static void main(String[] args){\n       Hello h = new Hello();\n       Thread t1 = new Thread(h);\n       Thread t2 = new Thread(h);\n       Thread t3 = new Thread(h);\n       Thread t4 = new Thread(h);\n       \n       t1.start();\n       t2.start();\n       t3.start();\n       t4.start();\n       \n    }\n    public void run(){\n        for(int i = 0; i<5; i++){\n            System.out.println(abq.put(i));\n        }\n    }\n}','will not compile, .put() return void and blocks until space becomes available\n\n\'void\' is not allowed is sout();','Concurrency',1,NULL),(671,'public class Hello implements Runnable {\n    private static ArrayBlockingQueue<Integer> abq = new ArrayBlockingQueue<>(10);\n    public static void main(String[] args){\n       Hello h = new Hello();\n       Thread t1 = new Thread(h);\n       Thread t2 = new Thread(h);\n       Thread t3 = new Thread(h);\n       Thread t4 = new Thread(h);\n       \n       t1.start();\n       t2.start();\n       t3.start();\n       t4.start();\n       \n    }\n    public void run(){\n        for(int i = 0; i<5; i++){\n            abq.put(i);\n        }\n    }\n}','Will not compile,\n\nput will block, therefore it may throw an interruptedException\n\nsurround with try catch','Concurrency',1,NULL),(672,'public class Hello implements Runnable {\n    private static ArrayBlockingQueue<Integer> abq = new ArrayBlockingQueue<>(10);\n    public static void main(String[] args){\n       Hello h = new Hello();\n       Thread t1 = new Thread(h);\n       Thread t2 = new Thread(h);\n       Thread t3 = new Thread(h);\n       Thread t4 = new Thread(h);\n       \n       t1.start();\n       t2.start();\n       t3.start();\n       t4.start();\n       \n    }\n    public void run(){\n        for(int i = 0; i<5; i++){\n            try{\n                abq.put(i);\n            } catch(InterruptedException e){}\n        }\n    }\n}','will run indefinitely, put will block until space becomes available, here \nit will never become available because there is no code removing objects','Concurrency',1,NULL),(673,'public class Hello implements Runnable {\n    private static ArrayBlockingQueue<Integer> abq = new ArrayBlockingQueue<>(10);\n    public static void main(String[] args){\n        for(int i = 0; i<10; i++)\n                abq.add(i);\n  \n       Hello h = new Hello();\n       Thread t1 = new Thread(h);\n       Thread t2 = new Thread(h);\n       Thread t3 = new Thread(h);\n       Thread t4 = new Thread(h);\n       \n       t1.start();\n       t2.start();\n       t3.start();\n       t4.start();\n       \n    }\n    public void run(){\n        for(int i = 0; i<5; i++){\n            System.out.println(Thread.currentThread().getName()+\"removed element: \"+abq.peek());\n        }\n        \n    }\n}','peek() returns the head without removing it. returns null if empty\nThread-0removed element: 0\nThread-0removed element: 0\nThread-0removed element: 0\nThread-0removed element: 0\nThread-0removed element: 0\nThread-2removed element: 0\nThread-2removed element: 0\nThread-2removed element: 0\nThread-2removed element: 0\nThread-2removed element: 0\nThread-3removed element: 0\nThread-3removed element: 0\nThread-3removed element: 0\nThread-3removed element: 0\nThread-3removed element: 0\nThread-1removed element: 0\nThread-1removed element: 0\nThread-1removed element: 0\nThread-1removed element: 0\nThread-1removed element: 0\n','Concurrency',1,NULL),(674,'ArrayBlockingQueue<E>\n\nA bounded blocking queue backed by an array. \nThis queue orders elements FIFO (first-in-first-out). \nThe head of the queue is that element that has been on the queue the longest time. \nThe tail of the queue is that element that has been on the queue the shortest time. \nNew elements are inserted at the tail of the queue, and the queue retrieval operations obtain elements at the head of the queue.\n\nThis is a classic \"bounded buffer\", in which a fixed-sized array holds elements inserted by producers and extracted by consumers. \nOnce created, the capacity cannot be changed. Attempts to put an element into a full queue will result in the operation blocking; \nattempts to take an element from an empty queue will similarly block. ','','Concurrency',1,NULL),(675,'public class Hello {\n    public static void main(String[] args){\n        SynchronousQueue<String> sq = new SynchronousQueue<String>();\n        Thread putThread = new Thread(new PutRunnable<String>(sq, \"One\"), \"PutThread\");\n        putThread.start();\n        Thread takerThread = new Thread(new TakerRunnable<String>(sq), \"TakerThread\");\n        takerThread.start();\n\n    }\n}\n\n class PutRunnable<T> implements Runnable {\n    private T value;\n    private SynchronousQueue<T> syncQ;\n    PutRunnable(SynchronousQueue<T> syncQ, T value) {\n        this.syncQ = syncQ;\n        this.value = value;\n    }\n    public void run() {\n        try {\n            PrintUtils.print(\"Put \" + value);\n            syncQ.put(value);\n            PrintUtils.print(\"Returned from put\");\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n \n}\nclass TakerRunnable<T> implements Runnable {\n    private T value;\n    private SynchronousQueue<T> syncQ;\n    TakerRunnable(SynchronousQueue<T> syncQ) {\n        this.syncQ = syncQ;\n    }\n    public void run() {\n        try {\n            PrintUtils.print(\"Retrieve using take\");\n            value = syncQ.take();\n            PrintUtils.print(\"take() returned \" + value);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n    public T getValue() {\n        return value;\n    }\n}\n\nclass PrintUtils {\n    public static void print(String s) {\n        System.out.println(Thread.currentThread().getName() + \":\" + s);\n    }\n}','PutThread:Put One\nTakerThread:Retrieve using take\nTakerThread:take() returned One\nPutThread:Returned from put\n\nSyncQueue is used to make two threads meet up and hand off an object. \n\nBoth insertion and removal operations will block until the other thread\ndoes the inverse thus making the threads meet and exchange. ','Concurrency',1,NULL),(676,'public class Hello {\n    \n    private static TransferQueue<Integer> tq = new LinkedTransferQueue<>();\n\n    public static void main(String[] args){\n        boolean b1 = tq.add(1); // true if added, IllegalStateException if full\n        \n        try{\n            //both of these throw interruptedExceptions because they block and wait\n            \n            tq.put(2);  //blocks if bounded or full\n        \n            tq.transfer(88); //blocks until element is consumed\n            \n        } catch(InterruptedException e){ }\n        \n        tq.tryTransfer(7); // returns true if consumed by the awaiting thread, or false without adding if there was no awaiting consumer.\n            // does not block therefore does not throw interruptedException\n        \n        try {\n            \n            //will wait the given time, blocking, then will return if not consumed\n            boolean b7 = tq.tryTransfer(99,10,TimeUnit.SECONDS);\n            \n        } catch(InterruptedException e){ }\n\n    }\n    \n    public static void methodsToRetrieve(){\n        Integer i1 = tq.element(); // gets without removing, throws NoSuchElementException if empty\n        \n        Integer i2 = tq.peek(); // gets without removing, null if empty\n        \n        Integer i3 = tq.poll(); //returns and removes the head, null if empty\n        \n        try{\n            Integer i4 = tq.poll(10,TimeUnit.MILLISECONDS); // removes the head, waits the specified time beffore returning null if empty\n        } catch(InterruptedException e) { }\n        \n        Integer i5 = tq.remove(); // removes the head of the queue throws NoSuchElementException if empty\n                \n        try{\n            Integer i6 = tq.take(); //removes the head blocks until an element is ready,\n        } catch(InterruptedException e) { }\n                \n    }','LinkedTranserQueue implements the BlockingQueue, TransferQueue, and Queue interfaces\n\nit is used here to demonstrate all the inserting and removing methods.','Concurrency',1,NULL),(677,'public class Hello {\n    \n    private static TransferQueue<Integer> tq = new LinkedTransferQueue<>(45);\n\n    public static void main(String[] args){\n        boolean b1 = tq.add(1); // true if added, IllegalStateException if full\n        \n        try{\n            //both of these throw interruptedExceptions because they block and wait\n            \n            tq.put(2);  //blocks if bounded or full\n        \n            tq.transfer(88); //blocks until element is consumed\n            \n        } catch(InterruptedException e){ }\n        \n        tq.tryTransfer(7); // returns true if consumed by the awaiting thread, or false without adding if there was no awaiting consumer.\n            // does not block therefore does not throw interruptedException\n        \n        try {\n            \n            //will wait the given time, blocking, then will return if not consumed\n            boolean b7 = tq.tryTransfer(99,10,TimeUnit.SECONDS);\n            \n        } catch(InterruptedException e){ }\n\n    }\n    \n    public static void methodsToRetrieve(){\n        Integer i1 = tq.element(); // gets without removing, throws NoSuchElementException if empty\n        \n        Integer i2 = tq.peek(); // gets without removing, null if empty\n        \n        Integer i3 = tq.poll(); //returns and removes the head, null if empty\n        \n        try{\n            Integer i4 = tq.poll(10,TimeUnit.MILLISECONDS); // removes the head, waits the specified time beffore returning null if empty\n        } catch(InterruptedException e) { }\n        \n        Integer i5 = tq.remove(); // removes the head of the queue throws NoSuchElementException if empty\n                \n        try{\n            Integer i6 = tq.take(); //removes the head blocks until an element is ready,\n        } catch(InterruptedException e) { }\n                \n    }','will not compile, LinkedTransferQueue is not bounded and cannot be supplied with\na size argument','Concurrency',1,NULL),(678,'public class Hello {\n    \n    private static TransferQueue<Integer> tq = new LinkedTransferQueue<>();\n\n    public static void main(String[] args){\n        boolean b1 = tq.add(1); // true if added, IllegalStateException if full\n            \n        tq.put(2);  //blocks if bounded or full\n        \n        tq.transfer(88); //blocks until element is consumed\n        \n        tq.tryTransfer(7); // returns true if consumed by the awaiting thread, or false without adding if there was no awaiting consumer.\n            // does not block therefore does not throw interruptedException\n        \n        try {\n            \n            //will wait the given time, blocking, then will return if not consumed\n            boolean b7 = tq.tryTransfer(99,10,TimeUnit.SECONDS);\n            \n        } catch(InterruptedException e){ }\n\n    }\n    \n    public static void methodsToRetrieve(){\n        Integer i1 = tq.element(); // gets without removing, throws NoSuchElementException if empty\n        \n        Integer i2 = tq.peek(); // gets without removing, null if empty\n        \n        Integer i3 = tq.poll(); //returns and removes the head, null if empty\n        \n        try{\n            Integer i4 = tq.poll(10,TimeUnit.MILLISECONDS); // removes the head, waits the specified time beffore returning null if empty\n        } catch(InterruptedException e) { }\n        \n        Integer i5 = tq.remove(); // removes the head of the queue throws NoSuchElementException if empty\n                \n        try{\n            Integer i6 = tq.take(); //removes the head blocks until an element is ready,\n        } catch(InterruptedException e) { }\n                \n    }','will not compile, put and transfer block and wait, therefore they throw \nInterruptedExceptions','Concurrency',1,NULL),(679,'public class Hello {\n    \n    public static void main(String[] args){\n        Library library = new Library();\n        \n        new Thread(library).start();\n        \n        new Thread(new Renter(library,\"Mike\")).start();\n        new Thread(new Renter(library,\"Max\")).start();\n        new Thread(new Renter(library,\"Priebe\")).start();\n        new Thread(new Renter(library,\"Dom\")).start();\n    }\n}\n\nclass Library implements Runnable{\n    private TransferQueue<Book> shelves = new LinkedTransferQueue<>();\n    \n    public Library() {\n        shelves.add(new Book(\"Topics of Destruction\"));\n        shelves.add(new Book(\"War what is it good for\"));\n        shelves.add(new Book(\"LOTR\"));\n        shelves.add(new Book(\"Manson, the secret life\"));\n    }\n    \n    public void run(){\n        while(true){ }\n    }\n    \n    public Book lend(){\n        \n        try {\n            Book book = shelves.take();\n            System.out.println(\"This ones good try \"+book.getName()+\". Enjoy!\");\n            return book;\n        } catch(InterruptedException e){ }\n        \n        return new Book(\"Free Library Pamphlet on plagarism\");\n    }\n    \n    public void accept(Book book){\n        shelves.offer(book);\n       \n    }\n}\n\nclass Renter implements Runnable {\n    private Library lib;\n    private String name;\n    public Renter(Library lib,String x){\n        name = x;\n        this.lib = lib;\n    }\n    public void run(){\n        while(true){\n            Book book = lib.lend();\n            System.out.println(name+\" chekced out \"+book.getName());\n            try{\n                Thread.sleep(ThreadLocalRandom.current().nextInt(1000,5000));\n            } catch(InterruptedException e) { }\n            \n            System.out.println(name+\": Im done with \"+book.getName()+\" here take it back!\");\n            lib.accept(book);\n        }\n    }\n}\n\n\nclass Book{\n    private String name;\n    public Book(String x ){\n        name = x;\n    }\n    \n    public String getName(){\n        return name;\n    }\n    \n}','This shows the proper use of take() which will block until a book is available,\noffer is also properlyy used becaue it will only add if the queue is not full\nif it is it simply doesn\'t add it and doesn\'t throw an exception or anything.\n\nThis ones good try Topics of Destruction. Enjoy!\nMike chekced out Topics of Destruction\nThis ones good try War what is it good for. Enjoy!\nMax chekced out War what is it good for\nThis ones good try LOTR. Enjoy!\nPriebe chekced out LOTR\nThis ones good try Manson, the secret life. Enjoy!\nDom chekced out Manson, the secret life\nMike: Im done with Topics of Destruction here take it back!\nThis ones good try Topics of Destruction. Enjoy!\nMike chekced out Topics of Destruction\nPriebe: Im done with LOTR here take it back!\nThis ones good try LOTR. Enjoy!\nPriebe chekced out LOTR\nDom: Im done with Manson, the secret life here take it back!\nThis ones good try Manson, the secret life. Enjoy!\nDom chekced out Manson, the secret life\nMike: Im done with Topics of Destruction here take it back!\nThis ones good try Topics of Destruction. Enjoy!\nMike chekced out Topics of Destruction\nMax: Im done with War what is it good for here take it back!\nThis ones good try War what is it good for. Enjoy!\nMax chekced out War what is it good for\nPriebe: Im done with LOTR here take it back!\nThis ones good try LOTR. Enjoy!\nPriebe chekced out LOTR\nMike: Im done with Topics of Destruction here take it back!\nThis ones good try Topics of Destruction. Enjoy!\nMike chekced out Topics of Destruction\nPriebe: Im done with LOTR here take it back!\nThis ones good try LOTR. Enjoy!\nPriebe chekced out LOTR','Concurrency',1,NULL),(680,'public class Hello {\n    \n    public static void main(String[] args){\n        Library library = new Library();\n        \n        new Thread(library).start();\n        \n        new Thread(new Renter(library,\"Mike\")).start();\n        new Thread(new Renter(library,\"Max\")).start();\n        new Thread(new Renter(library,\"Priebe\")).start();\n        new Thread(new Renter(library,\"Dom\")).start();\n    }\n}\n\nclass Library implements Runnable{\n    private TransferQueue<Book> shelves = new LinkedTransferQueue<>();\n    \n    public Library() {\n        shelves.add(new Book(\"Capulets and Montagues, the unknown link\"));\n        shelves.add(new Book(\"War What is it Good For\"));\n        shelves.add(new Book(\"Virtuous Villians\"));\n        shelves.add(new Book(\"Love in the Water\"));\n    }\n    \n    public void run(){\n        while(true){ }\n    }\n    \n    public Book lend(){\n        \n        try {\n            Book book = shelves.element();\n            System.out.println(\"This ones good try \"+book.getName()+\". Enjoy!\");\n            return book;\n        } catch(NoSuchElementException e){System.out.println(\"I\'m sorry sir we dont have that book right now\"); }\n        \n        return new Book(\"Free Library Pamphlet on plagarism\");\n    }\n    \n    public void accept(Book book){\n        shelves.offer(book);\n       \n    }\n}\n\nclass Renter implements Runnable {\n    private Library lib;\n    private String name;\n    public Renter(Library lib,String x){\n        name = x;\n        this.lib = lib;\n    }\n    public void run(){\n        while(true){\n            Book book = lib.lend();\n            System.out.println(name+\" chekced out \"+book.getName());\n            try{\n                Thread.sleep(ThreadLocalRandom.current().nextInt(1000,5000));\n            } catch(InterruptedException e) { }\n            \n            System.out.println(name+\": Im done with \"+book.getName()+\" here take it back!\");\n            lib.accept(book);\n        }\n    }\n}\n\nclass Book{\n    private String name;\n    public Book(String x ){\n        name = x;\n    }\n    \n    public String getName(){\n        return name;\n    }\n    \n}','element() throws NoSuchElementException,\n\n','Concurrency',1,NULL),(681,'public class Hello {\n    \n    public static void main(String[] args){\n        Library library = new Library();\n        \n        new Thread(library).start();\n        \n        new Thread(new Renter(library,\"Mike\")).start();\n        new Thread(new Renter(library,\"Max\")).start();\n        new Thread(new Renter(library,\"Priebe\")).start();\n        new Thread(new Renter(library,\"Dom\")).start();\n    }\n}\n\nclass Library implements Runnable{\n    private TransferQueue<Book> shelves = new LinkedTransferQueue<>();\n    \n    public Library() {\n        shelves.add(new Book(\"Capulets and Montagues, the unknown link\"));\n        shelves.add(new Book(\"War What is it Good For\"));\n        shelves.add(new Book(\"Virtuous Villians\"));\n        shelves.add(new Book(\"Love in the Water\"));\n    }\n    \n    public void run(){\n        while(true){ }\n    }\n    \n    public Book lend(){\n\n            Book book = shelves.peek();\n            System.out.println(\"This ones good try \"+book.getName()+\". Enjoy!\");\n        \n            if(book == null){\n                return new Book(\"Free Library Pamphlet on plagarism\");\n            } else {\n                return book;\n            }\n    }\n    \n    public void accept(Book book){\n        shelves.offer(book);\n       \n    }\n}\n\nclass Renter implements Runnable {\n    private Library lib;\n    private String name;\n    public Renter(Library lib,String x){\n        name = x;\n        this.lib = lib;\n    }\n    public void run(){\n        while(true){\n            Book book = lib.lend();\n            System.out.println(name+\" chekced out \"+book.getName());\n            try{\n                Thread.sleep(ThreadLocalRandom.current().nextInt(1000,5000));\n            } catch(InterruptedException e) { }\n            \n            System.out.println(name+\": Im done with \"+book.getName()+\" here take it back!\");\n            lib.accept(book);\n        }\n    }\n}\n\nclass Book{\n    private String name;\n    public Book(String x ){\n        name = x;\n    }\n    \n    public String getName(){\n        return name;\n    }\n    \n}','The same book keeps getting checked out because peek()\nreturns but does not remove the element\n\nThis ones good try Capulets and Montagues, the unknown link. Enjoy!\nMike chekced out Capulets and Montagues, the unknown link\nThis ones good try Capulets and Montagues, the unknown link. Enjoy!\nMax chekced out Capulets and Montagues, the unknown link\nThis ones good try Capulets and Montagues, the unknown link. Enjoy!\nPriebe chekced out Capulets and Montagues, the unknown link\nThis ones good try Capulets and Montagues, the unknown link. Enjoy!\nDom chekced out Capulets and Montagues, the unknown link\nDom: Im done with Capulets and Montagues, the unknown link here take it back!\nThis ones good try Capulets and Montagues, the unknown link. Enjoy!\nDom chekced out Capulets and Montagues, the unknown link\nMike: Im done with Capulets and Montagues, the unknown link here take it back!\nThis ones good try Capulets and Montagues, the unknown link. Enjoy!\nMike chekced out Capulets and Montagues, the unknown link\nPriebe: Im done with Capulets and Montagues, the unknown link here take it back!\nThis ones good try Capulets and Montagues, the unknown link. Enjoy!\nPriebe chekced out Capulets and Montagues, the unknown link\nMax: Im done with Capulets and Montagues, the unknown link here take it back!\nThis ones good try Capulets and Montagues, the unknown link. Enjoy!\nMax chekced out Capulets and Montagues, the unknown link\nDom: Im done with Capulets and Montagues, the unknown link here take it back!','Concurrency',1,NULL),(682,'public class Hello {\n    \n    public static void main(String[] args){\n        Library library = new Library();\n        \n        new Thread(library).start();\n        \n        new Thread(new Renter(library,\"Mike\")).start();\n        new Thread(new Renter(library,\"Max\")).start();\n        new Thread(new Renter(library,\"Priebe\")).start();\n        new Thread(new Renter(library,\"Dom\")).start();\n    }\n}\n\nclass Library implements Runnable{\n    private TransferQueue<Book> shelves = new LinkedTransferQueue<>();\n    \n    public Library() {\n        shelves.add(new Book(\"Capulets and Montagues, the unknown link\"));\n        shelves.add(new Book(\"War What is it Good For\"));\n        shelves.add(new Book(\"Virtuous Villians\"));\n        shelves.add(new Book(\"Love in the Water\"));\n    }\n    \n    public void run(){\n        while(true){ }\n    }\n    \n    public Book lend(){\n\n            Book book = shelves.poll();\n            System.out.println(\"This ones good try \"+book.getName()+\". Enjoy!\");\n        \n            if(book == null){\n                return new Book(\"Free Library Pamphlet on plagarism\");\n            } else {\n                return book;\n            }\n    }\n    \n    public void accept(Book book){\n        shelves.put(book);\n       \n    }\n}\n\nclass Renter implements Runnable {\n    private Library lib;\n    private String name;\n    public Renter(Library lib,String x){\n        name = x;\n        this.lib = lib;\n    }\n    public void run(){\n        while(true){\n            Book book = lib.lend();\n            System.out.println(name+\" chekced out \"+book.getName());\n            try{\n                Thread.sleep(ThreadLocalRandom.current().nextInt(1000,5000));\n            } catch(InterruptedException e) { }\n            \n            System.out.println(name+\": Im done with \"+book.getName()+\" here take it back!\");\n            lib.accept(book);\n        }\n    }\n}\n\nclass Book{\n    private String name;\n    public Book(String x ){\n        name = x;\n    }\n    \n    public String getName(){\n        return name;\n    }\n    \n}','does not compile, \n\nput() will block if there is no space available therefor it throws an\n\nInterruptedException','Concurrency',1,NULL),(683,'Which BlockingCollection method will block if needed until an object becomes\navailabel','take()','Concurrency',1,NULL),(684,'Which BlockingCollection method throws nosuchelementexception','element()','Concurrency',1,NULL),(685,'Which BlockingQueue method throws an illegalstateexception if the queueu is bounded and full ? ','add()','Concurrency',1,NULL),(686,'Whic BlockingQueue method returns true if it was added and false if \nthe queueu was full but also provides a timeout overloaded option','offer() and offer(e, long timeout, timeunit)','Concurrency',1,NULL),(687,'','','blank',1,NULL),(688,'	String a = \"String\";\n        int b = 4;\n        int c = 3;\n        System.out.println(a+b+c);\n        System.out.println(a+(b+c));\n        System.out.println(\"\" + b + 3);\n        System.out.println(b+3);\n        System.out.println(++b + \"\" + c--);\n        System.out.println(c);','String43\nString7\n43\n7\n53\n2','Strings',1,NULL),(689,'','','blank',1,NULL),(690,'ExecutorService ex = Executors.newCachedThreadPool();','Cached thread pools will create new threads as needed and reuse threads that \nhave become free. Thread that have been idle for 60 seconds are removed.\n\nCan create more threads than system can handle so watch out. ','Executors',1,NULL),(691,'ExecutorService ex = Executors.newFixedThreadPool(4);\n','constructed with an int argument that specifies the number of threads to use\nto execute the tasks. Most common. Prevents system from being overloaded\nwith too many threads. \n\nBase number of threads on some kind of system resource. \n\nuse java.lang.Runtime\n\nRuntime rt = Runtime.getRuntime();\nint cpus = rt.availabeProcessors();','Executors',1,NULL),(692,'How to adust the thread count of a pool at runtime\n\n','ThreadPoolExecutor tpe = (ThreadPoolExecutor) Executors.newFixedThreadPool(4);\ntpe.setCorePoolSize(8);\ntpe.setMaximumPoolSize(8);','Executors',1,NULL),(693,'public class Hello {\n    public static void main(String[] args){\n        ExecutorService ex = Executors.newSingleThreadPool();\n\n        Future<Integer> futint = ex.submit(new FileCounter());\n        \n        System.out.println(\"Do other things while the files are getting counted\");\n        \n        try{\n            int count = futint.get();\n            System.out.println(count);\n            futint.shutdown();\n        }catch(ExecutionException | InterruptedException e){\n            \n        }\n        \n    }\n    \n    \n}\n\nclass FileCounter implements Callable<Integer>{\n    private int fileCount = 0;\n    public Integer call() throws IOException{\n        fileCount = count(Paths.get(\"/home/maxbisesi/Documents\"));\n        return fileCount; \n    }\n    \n    public Integer count(Path d) throws IOException {\n        int count = 0;\n	try(DirectoryStream<Path> stream = Files.newDirectoryStream(d)){\n		for(Path path: stream){\n			count++;\n		}\n	}\n        return count;\n    }\n}','        ExecutorService ex = Executors.newSingleThreadExecutor(); \n\nwil not compile, it is singlethreadexecutor not singlethreadPool\n\n**Also you shutdown the ExecutorService not the Future!','Executors',1,NULL),(694,'Scheduled Thread pool:\n	scheduled after a delay or at repeating intervals\n\npublic class Hello {\n    \n    public static void main(String[] args){\n     ScheduledExecutorService ftses = Executors.newScheduledThreadPool(4);\n     \n     ftses.schedule(r, 5, TimeUnit.SECONDS); //run once after a delay\n     \n     ftses.scheduleAtFixedRate(r, 2,5,TimeUnit.SECONDS); //begin after 2 sec delay and begin again every 5\n     \n     ftses.scheduleWithFixedDelay(r, 2, 5, TimeUnit.SECONDS); //begin after 2 sec delay and again 5 seconds after the last exection\n}','','Executors',1,NULL),(695,'an ExecutorService can take what two kinds of objects ?','Callable and Runnable','Executors',1,NULL),(696,'What is the primary benifit of using a Callable ?','being able to return a result','Executors',1,NULL),(697,'submitting a Callable to an ExecutorService returns a Future reference.\n\nwhat are two possible exceptions that could result ?','InterruptedException and ExecutionException','Executors',1,NULL),(698,'ExecutionException','raised when an exception was thrown during the execution of the callable\'s\ncall()','Executors',1,NULL),(699,'public class Hello {\n    \n    public static void main(String[] args){\n        Callable<Integer> c = new LoopCounter();\n        \n        ExecutorService ex = Executors.newCachedThreadPool();\n        \n        Future<Integer> f = ex.submit(c); //finishes in the future\n        \n        try{\n            Integer v = f.get(); // will block until done\n            System.out.println(\"Ran: \" + v);\n        } catch(InterruptedException | ExecutionException iex){\n            System.out.println(\"Failed\");\n        }\n        \n        for(int i = 0; i<10; i++){\n            System.out.println(\"main: \"+ i);\n        }\n    }\n}\n\nclass LoopCounter implements Callable<Integer> {\n    \n    public Integer call(){\n        int count = ThreadLocalRandom.current().nextInt(1,11);\n        for(int i = 1; i <= count; i++){\n                System.out.println(\"running...\" + i);\n        }\n        return count;\n    }\n}','When a callable task is submitted to an executor the task will go run,\ncalling for its return value will block until it is done so otherwise go on \nwith your program until you are ready to use that result. In this code the rest\nof main is executed only after the future is returned.\nrunning...1\nrunning...2\nrunning...3\nrunning...4\nrunning...5\nrunning...6\nrunning...7\nrunning...8\nrunning...9\nrunning...10\nRan: 10\nmain: 0\nmain: 1\nmain: 2\nmain: 3\nmain: 4\nmain: 5\nmain: 6\nmain: 7\nmain: 8\nmain: 9\n','Executors',1,NULL),(700,'Using Executors takes away the need for synchronization, waiting, joining and \nnotifying','got it ','Executors',1,NULL),(701,'public class Hello {\n    \n    public static void main(String[] args){\n        Callable<Integer> c = new LoopCounter();\n        \n        ExecutorService ex = Executors.newCachedThreadPool();\n        \n        Future<Integer> f = ex.submit(c); //finishes in the future\n        \n        try{\n            Integer v = f.get(); // will block until done\n            System.out.println(\"Ran: \" + v);\n        } catch(InterruptedException | ExecutionException iex){\n            System.out.println(\"Failed\");\n        }\n        \n        for(int i = 0; i<10; i++){\n            System.out.println(\"main: \"+ i);\n        }\n        \n        ex.shutdown();\n    }\n}\n\nclass LoopCounter implements Callable<Integer> {\n    \n    public Integer call(){\n        int count = ThreadLocalRandom.current().nextInt(1,11);\n        for(int i = 1; i <= count; i++){\n                System.out.println(\"running...\" + i);\n        }\n        return count;\n    }\n}','The program will complete normally, without shutdown() it would continue to run,\nit is best to shutdown an executor service in order to free up threads.','Executors',1,NULL),(702,'ExecutorService ex = ...\n//......\n\nex.shutdown(); // no more new tasks but finish existing tasks\n\ntry{\n	boolean term = ex.awaitTermination(2,TimeUnit.SECONDS);\n		//wait two seconds for running tasks to finsish\n} catch(InterruptedException ex) {\n	//did not wait full two seconds\n} finally {\n   if(!ex.isTerminated()) // are all tasks done ?\n   {\n	List<Runnable> unfinished = ex.shutdownNow();\n		// a collection of unfished tasks\n   }\n}','','Executors',1,NULL),(703,'class RandomInitRA extends RecursiveAction {\n    private static final int THRESHOLD = 10000;\n    private int[] data;\n    private int start;\n    private int end;\n    \n    public RandomInitRA(int[] data, int start, int end) {\n        this.data = data;\n        this.start = start;\n        this.end = end;\n    }\n    \n    protected void compute() {\n        if(end - start <= THRESHOLD) {\n            // if this is a manageable amount of work do the task\n            for(int i = start; i<end; i++){\n                data[i] = ThreadLocalRandom.current().nextInt();\n            }\n        } else { //task too big\n            int halfway = ((end - start) / 2) + start;\n            RandomInitRA a1 = new RandomInitRA(data,start,halfway);\n            a1.fork();\n            RandomInitRA a2 = new RandomInitRA(data,halfway,end);\n            a2.compute();\n            a1.join();\n        }\n    }\n}','breaks a big task down into smaller parts\n\n','Executors',1,NULL),(704,'class RandomInitRA extends RecursiveAction {\n    private static final int THRESHOLD = 10000;\n    private int[] data;\n    private int start;\n    private int end;\n    \n    public RandomInitRA(int[] data, int start, int end) {\n        this.data = data;\n        this.start = start;\n        this.end = end;\n    }\n    \n    protected void compute() {\n        if(end - start <= THRESHOLD) {\n            // if this is a manageable amount of work do the task\n            for(int i = start; i<end; i++){\n                data[i] = ThreadLocalRandom.current().nextInt();\n            }\n        } else { //task too big\n            int halfway = ((end - start) / 2) + start;\n            RandomInitRA a1 = new RandomInitRA(data,start,halfway);\n            RandomInitRA a2 = new RandomInitRA(data,halfway,end);\n            invokeAll(a1,a2);\n        }\n    }\n}','use invokeAll instead of the fork join compute, \nRecursiveAction does not reutrn a value so you should not excpect a value\nfrom invoke all. ','Executors',1,NULL),(705,'class RandomInitRA extends RecursiveAction {\n    private static final int THRESHOLD = 10000;\n    private int[] data;\n    private int start;\n    private int end;\n    \n    public RandomInitRA(int[] data, int start, int end) {\n        this.data = data;\n        this.start = start;\n        this.end = end;\n    }\n    \n    protected int compute() {\n        if(end - start <= THRESHOLD) {\n            // if this is a manageable amount of work do the task\n            for(int i = start; i<end; i++){\n                data[i] = ThreadLocalRandom.current().nextInt();\n            }\n        } else { //task too big\n            int halfway = ((end - start) / 2) + start;\n            RandomInitRA a1 = new RandomInitRA(data,start,halfway);\n            RandomInitRA a2 = new RandomInitRA(data,halfway,end);\n            invokeAll(a1,a2);\n        }\n    }\n}','will not compile, return type of compute from RecursiveAction is void as\nRAs do not return values. ','Executors',1,NULL),(706,'public class Hello{\n    public static void main(String[]  args){\n        \n        \n        \n    }\n}\n \nclass RandomInitRA extends RecursiveAction {\n    private static final int THRESHOLD = 10000;\n    private int[] data;\n    private int start;\n    private int end;\n    \n    public RandomInitRA(int[] data, int start, int end) {\n        this.data = data;\n        this.start = start;\n        this.end = end;\n    }\n    \n    protected void compute() {\n        if(end - start <= THRESHOLD) {\n            // if this is a manageable amount of work do the task\n            for(int i = start; i<end; i++){\n                data[i] = ThreadLocalRandom.current().nextInt();\n            }\n        } else { //task too big\n            int halfway = ((end - start) / 2) + start;\n            RandomInitRA a1 = new RandomInitRA(data,start,halfway);\n            RandomInitRA a2 = new RandomInitRA(data,halfway,end);\n            invokeAll(a1,a2);\n        }\n    }\n}\n\n//given that the task of this RA is to fill a big array with random numbers\n// how would you start it in main given int[] data = new int[10_000_000];','int[] data = new int[10_000_000];\nForkJoinPool fjpool = new ForkJoinPool();\nRandomInitRA ra = new RandomInitRA(data,0,data.length);\n        \nfjpool.invoke(ra);','Executors',1,NULL),(707,'public class Hello{\n    public static void main(String[]  args){\n        int[] data = new int[10_000_000];\n        ForkJoinPool fjpool = new ForkJoinPool();\n        RandomInitRA ra = new RandomInitRA(data,0,data.length);\n        \n        fjpool.invokeAll(ra);\n    }\n}\n \nclass RandomInitRA extends RecursiveAction {\n    private static final int THRESHOLD = 10000;\n    private int[] data;\n    private int start;\n    private int end;\n    \n    public RandomInitRA(int[] data, int start, int end) {\n        this.data = data;\n        this.start = start;\n        this.end = end;\n    }\n    \n    protected void compute() {\n        if(end - start <= THRESHOLD) {\n            // if this is a manageable amount of work do the task\n            for(int i = start; i<end; i++){\n                data[i] = ThreadLocalRandom.current().nextInt();\n            }\n        } else { //task too big\n            int halfway = ((end - start) / 2) + start;\n            RandomInitRA a1 = new RandomInitRA(data,start,halfway);\n            RandomInitRA a2 = new RandomInitRA(data,halfway,end);\n            invokeAll(a1,a2);\n        }\n    }\n}','the forkjoinpool method is invoke() not invokeAll()\n\nit should be:\n\n	fjpool.invoke(ra);\n\nThere is an invokeAll() but it takes a collection of callable and returns \na list of futures. \n\nnotice too that it doesn\'t return a value, technically it is of type Void, and\nnull is the only valid type for Void','Executors',1,NULL),(708,'Two subclasses of ForkJoinTask<V>','RecursiveAction RecursiveTask','Executors',1,NULL),(709,'class RandomInitRA extends RecursiveAction {\n    private static final int THRESHOLD = 10000;\n    private int[] data;\n    private int start;\n    private int end;\n    \n    public RandomInitRA(int[] data, int start, int end) {\n        this.data = data;\n        this.start = start;\n        this.end = end;\n    }\n    \n    public void compute() {\n        if(end - start <= THRESHOLD) {\n            // if this is a manageable amount of work do the task\n            for(int i = start; i<end; i++){\n                data[i] = ThreadLocalRandom.current().nextInt();\n            }\n        } else { //task too big\n            int halfway = ((end - start) / 2) + start;\n            RandomInitRA a1 = new RandomInitRA(data,start,halfway);\n            RandomInitRA a2 = new RandomInitRA(data,halfway,end);\n            invokeAll(a1,a2);\n        }\n    }\n}','this will compile \n\nan overriden method CAN have less restrive access, but not more restrictive.\n\ncompute() is protected in abstract class','Executors',1,NULL),(710,'','','Executors',1,NULL),(711,'class RandomInitRA extends RecursiveAction {\n    private static final int THRESHOLD = 10000;\n    private int[] data;\n    private int start;\n    private int end;\n    \n    public RandomInitRA(int[] data, int start, int end) {\n        this.data = data;\n        this.start = start;\n        this.end = end;\n    }\n    \n    private void compute() {\n        if(end - start <= THRESHOLD) {\n            // if this is a manageable amount of work do the task\n            for(int i = start; i<end; i++){\n                data[i] = ThreadLocalRandom.current().nextInt();\n            }\n        } else { //task too big\n            int halfway = ((end - start) / 2) + start;\n            RandomInitRA a1 = new RandomInitRA(data,start,halfway);\n            RandomInitRA a2 = new RandomInitRA(data,halfway,end);\n            invokeAll(a1,a2);\n        }\n    }\n}','will not compile an overriden method CAN have more restrictive access but not \nless. private is less than public.','Executors',1,NULL),(712,'class RandomInitRA extends RecursiveAction {\n    private static final int THRESHOLD = 10000;\n    private int[] data;\n    private int start;\n    private int end;\n    \n    public RandomInitRA(int[] data, int start, int end) {\n        this.data = data;\n        this.start = start;\n        this.end = end;\n    }\n    \n    void compute() {\n        if(end - start <= THRESHOLD) {\n            // if this is a manageable amount of work do the task\n            for(int i = start; i<end; i++){\n                data[i] = ThreadLocalRandom.current().nextInt();\n            }\n        } else { //task too big\n            int halfway = ((end - start) / 2) + start;\n            RandomInitRA a1 = new RandomInitRA(data,start,halfway);\n            RandomInitRA a2 = new RandomInitRA(data,halfway,end);\n            invokeAll(a1,a2);\n        }\n    }\n}','will not compile, an overriden method cannot have more restrictive access\ndefault is more restrictive than protected.','Executors',1,NULL),(713,'class FindMaxPosition extends RecursiveTask<Integer> {\n     private static final int THRESHOLD = 10000;\n    private int[] data;\n    private int start;\n    private int end;\n    \n    public FindMaxPosition(int[] data, int start, int end) {\n        this.data = data;\n        this.start = start;\n        this.end = end;\n    }\n    \n    public Integer compute() {\n        if (end - start <= THRESHOLD){\n            int position = 0;\n            for(int i = start; i < end; i++){\n                 if(data[i] > data[position]) {\n                     position = i;\n                 }\n            }\n            \n            return position;\n        } else { //task is too big, split it\n            int halfway = ((end - start) / 2) + start;\n            FindMaxPosition p1 = new FindMaxPosition(data,start,halfway);\n            p1.fork();\n            FindMaxPosition p2 = new FindMaxPosition(data,start,halfway);\n            int pos2 = p2.compute();\n            int pos1 = p1.join();\n            \n            //these forked tasks found the greatest value in their subsections now compare the two results \n            \n            if(data[pos1] > data[pos2]) {\n                return pos1;\n            } else if(data[pos1] < data[pos2]){\n                return pos2;\n            } else {\n                return pos1 < pos2 ? pos1 : pos2;\n            }\n        }\n        \n    }\n}','RecursiveTask<V> returns a value\n\nfor this particular example you should initialize the array with random \nnumber using RandomInitRecursiveAction that doesn\'t return a result. \n\npublic static void main(String[] args) {\n        int[] bigdata = new int[20000];\n        ForkJoinPool fj = new ForkJoinPool();\n        FindMaxPosition fmp = new FindMaxPosition(bigdata,0,bigdata.length);\n        Integer i = fj.invoke(fmp);\n        \n    }','Executors',1,NULL),(714,'public class Hello{\n    public static void main(String[]  args){\n        int[] data = new int[10_000_000];\n        ForkJoinPool fjpool = new ForkJoinPool();\n        RandomInitRA ra = new RandomInitRA(data,0,data.length);\n        fjpool.invoke(ra);\n        \n        FindMaxPosition task = new FindMaxPosition(data,0,data.length);\n        Integer position = fjpool.invoke(task);\n        System.out.println(\"Bigggest value:;\"+ data[position]);\n    }\n}\n\nclass FindMaxPosition extends RecursiveTask<Integer> {\n     private static final int THRESHOLD = 10000;\n    private int[] data;\n    private int start;\n    private int end;\n    \n    public FindMaxPosition(int[] data, int start, int end) {\n        this.data = data;\n        this.start = start;\n        this.end = end;\n    }\n    \n    public Integer compute() {\n        if (end - start <= THRESHOLD){\n            int position = 0;\n            for(int i = start; i < end; i++){\n                 if(data[i] > data[position]) {\n                     position = i;\n                 }\n            }\n            \n            return position;\n        } else { //task is too big, split it\n            int halfway = ((end - start) / 2) + start;\n            FindMaxPosition p1 = new FindMaxPosition(data,start,halfway);\n            p1.fork();\n            FindMaxPosition p2 = new FindMaxPosition(data,start,halfway);\n            int pos2 = p2.compute();\n            int pos1 = p1.join();\n            \n            //these forked tasks found the greatest value in their subsections now compare the two results \n            \n            if(data[pos1] > data[pos2]) {\n                return pos1;\n            } else if(data[pos1] < data[pos2]){\n                return pos2;\n            } else {\n                return pos1 < pos2 ? pos1 : pos2;\n            }\n        }\n        \n    }\n}\n \nclass RandomInitRA extends RecursiveAction {\n    private static final int THRESHOLD = 10000;\n    private int[] data;\n    private int start;\n    private int end;\n    \n    public RandomInitRA(int[] data, int start, int end) {\n        this.data = data;\n        this.start = start;\n        this.end = end;\n    }\n    \n    protected void compute() {\n        if(end - start <= THRESHOLD) {\n            // if this is a manageable amount of work do the task\n            for(int i = start; i<end; i++){\n                data[i] = ThreadLocalRandom.current().nextInt();\n            }\n        } else { //task too big\n            int halfway = ((end - start) / 2) + start;\n            RandomInitRA a1 = new RandomInitRA(data,start,halfway);\n            RandomInitRA a2 = new RandomInitRA(data,halfway,end);\n            invokeAll(a1,a2);\n        }\n    }\n}','This will create an array of 10000000 elements then, find the biggest value in it\n','Executors',1,NULL),(715,'ConcurrentMap<String,Integer> ages = new ConcurrentHashMap<>();\nages.put(\"John\",23);\n\nWhich method would delete Joh from the map only if his value was still equal \nto 23','ages.remove(\"John\",23);\n\npublic boolean remove(Object key,\n             Object value)\n\nRemoves the entry for a key only if currently mapped to a given value. This is equivalent to\n\n   if (map.containsKey(key) && map.get(key).equals(value)) {\n       map.remove(key);\n       return true;\n   } else return false;\n\nexcept that the action is performed ATOMICALLY.\n\nThere is another remove method that comes from the map Interface...\nthat is the standard remove function.\n\npublic V remove(Object key)\n\nRemoves the key (and its corresponding value) from this map. This method does nothing if the key is not in the map.\n\nSpecified by:\n    remove in interface Map<K,V>\nOverrides:\n    remove in class AbstractMap<K,V>\nParameters:\n    key - the key that needs to be removed\nReturns:\n    the previous value associated with key, or null if there was no mapping for key','Concurrency',1,NULL),(716,'AtomicInteger i = new AtomicInteger();\ntwo methods to atomically increment by 9?','i.addAndGet(9);\ni.getAndAdd(9);','Concurrency',1,NULL),(717,'class LeaderBoard {\n    private ReadWriteLock rwl = new ReentrantReadWriteLock();\n    private List<Integer> highScores = new ArrayList<Integer>();\n    public void addScore(Integer score){\n        Lock lock = rwl.writeLock();\n        lock.lock();\n        \n        try{\n            if(highScores.size() < 10) {\n                highScores.add(score);\n            } else if(highScores.get(highScores.size() - 1) < score) {\n                highScores.set(highScores.size() - 1, score);\n            } else {\n                return;\n            }\n            \n            Collections.sort(highScores,Collections.reverseOrder());\n        } finally{\n            lock.unlock();\n        }\n    }\n    \n    public List getHighScores(){\n        Lock lock = rwl.readLock();\n        lock.lock();\n        try{\n            return Collections.unmodifiableList(highScores);\n        } finally {\n            lock.unlock();\n        }\n    }\n}','only one thread at a time can access the write lock where multiple threads\ncan access the readLock','Concurrency',1,NULL),(718,'public class Hello {\n\n    public static void main(String[] args) {\n       LeaderBoard lb = new LeaderBoard();\n       lb.addScore(56);\n    }\n    \n}\n\nclass LeaderBoard {\n    private ReadWriteLock rwl = new ReentrantReadWriteLock();\n    private List<Integer> highScores = new ArrayList<Integer>();\n    public void addScore(Integer score){\n        Lock lock = rwl.writeLock();\n        \n        try{\n            if(highScores.size() < 10) {\n                highScores.add(score);\n            } else if(highScores.get(highScores.size() - 1) < score) {\n                highScores.set(highScores.size() - 1, score);\n            } else {\n                return;\n            }\n            \n            Collections.sort(highScores,Collections.reverseOrder());\n        } finally{\n            lock.unlock();\n        }\n    }\n    \n    public List getHighScores(){\n        Lock lock = rwl.readLock();\n        lock.lock();\n        try{\n            return Collections.unmodifiableList(highScores);\n        } finally {\n            lock.unlock();\n        }\n    }\n}','IllegalMonitorStateExcetion rwl.writeLock() was not locked before it was unloked\n','Concurrency',1,NULL),(719,'public class Hello {\n\n    public static void main(String[] args) {\n       LeaderBoard lb = new LeaderBoard();\n       lb.addScore(5);\n    }\n    \n}\n\nclass LeaderBoard {\n    private ReadWriteLock rwl = new ReentrantReadWriteLock();\n    private List<Integer> highScores = new ArrayList<Integer>();\n    public void addScore(Integer score){\n        Lock lock = rwl.writeLock();\n        lock.lock();\n        try{\n            if(highScores.size() < 10) {\n                highScores.add(score);\n            } else if(highScores.get(highScores.size() - 1) < score) {\n                highScores.set(highScores.size() - 1, score);\n            } else {\n                return;\n            }\n            \n            Collections.sort(highScores,Collections.reverseOrder());\n        } finally{\n\n        }\n    }\n    \n    public List getHighScores(){\n        Lock lock = rwl.readLock();\n        lock.lock();\n        try{\n            return Collections.unmodifiableList(highScores);\n        } finally {\n            lock.unlock();\n        }\n    }\n}','compiles fine, The writeLock is locked but never unlocked,that will not throw\nan exception.','Concurrency',1,NULL),(720,'public class Hello {\n\n    public static void main(String[] args) {\n       LeaderBoard lb = new LeaderBoard();\n       Player a = new Player(lb);\n       Player b = new Player(lb);\n       Player c = new Player(lb);\n       \n       a.start();\n       b.start();\n       c.start();\n    }\n    \n}\n\nclass LeaderBoard {\n    private ReadWriteLock rwl = new ReentrantReadWriteLock();\n    private List<Integer> highScores = new ArrayList<Integer>();\n    public void addScore(Integer score){\n        Lock lock = rwl.writeLock();\n        lock.lock();\n        try{\n            if(highScores.size() < 10) {\n                highScores.add(score);\n            } else if(highScores.get(highScores.size() - 1) < score) {\n                highScores.set(highScores.size() - 1, score);\n            } else {\n                return;\n            }\n            \n            Collections.sort(highScores,Collections.reverseOrder());\n        } finally{\n            lock.unlock();\n        }\n    }\n    \n    public List getHighScores(){\n        Lock lock = rwl.readLock();\n        lock.lock();\n        try{\n            return Collections.unmodifiableList(highScores);\n        } finally {\n\n        }\n    }\n}\n\nclass Player extends Thread {\n    private LeaderBoard lb;\n    public Player(LeaderBoard x){\n        lb = x;\n        \n    }\n    public void run(){\n        System.out.println(Thread.currentThread().getName()+\" \"+lb.getHighScores());\n        for(int i = 0; i<3; i++){\n            postHighScore();\n        }    \n    }\n    \n    public void postHighScore(){\n        lb.addScore(ThreadLocalRandom.current().nextInt());\n    }\n}\n','Thread-0 []\nThread-2 []\nThread-1 []\n... and will keep running\n\nsince the readlock is never unlocked() in getHighScores() the three threads will\nacquire the read lock but never release it. \n\nThat will prevent any of them from getting the write lock. RRWL allows multiple\nthreads to read at the same time but will wait for an exclusive lock before\nallowing threads to write to it. meaning no other thread can be reading while\nanother thread is writing to the locked object!','Concurrency',1,NULL),(721,'I can\'t seem to determine any difference between InputStreamReader and FileReader besides the way the two are initialized. \nIs there any benefit to using one or the other? \nMost other articles cover FileInputStream vs InputStreamReader, but I am contrasting with FileReader instead. \nSeems to me they both have the same purpose.','\n\nFirst, InputStreamReader can handle all input streams, not just files. Other examples are network connections, classpath resources and ZIP files.\n\nSecond, FileReader does not allow you to specify an encoding and instead uses the plaform default encoding, which makes it pretty much useless as using it will result in corrupted data when the code is run on systems with different platform default encodings.\n\nIn short, forget that FileReader exists.\n','General',1,NULL),(722,'while (scanNumOfLines.hasNextLine())    \n    {\n    NumOfLines ++;\n    scanNumOfLines.nextLine();\n    }\n    System.out.println(\"NumOfLines = \"+NumOfLines);\n\nSo it counts fine, but I want to re-use the scanner for another purpose, but the nextLine has moved to the last line of the file, and I want to reset it back to the first line.\n\n(Instead, I had to use another scanner for the other purpose, and to me this seems less elegant than it should be.)\n\nI\'m sure there must be a scanner method that resets the counter to zero?','-This is impossible to do.\n The reason to not include it, is the wide range of input types it supports. One example is streams. These don\'t store the results after they have been passed on,\n so they don\'t support resetting.\n So the elegant way is to create a new Scanner. \n If you give it many custom settings, create a factory method.\n\n-There is no \"counter\" in the Scanner object. \n Instead think of it as more like a conveyor belt. \n The belt has no knowledge or care about what\'s on it. \n It just keeps spitting things out at you while there are items left on it. \n And once you take them, they\'re gone from it for good.\n','General',1,NULL),(723,'What difference that final makes between the code below. Is there any advantage in declaring the arguments as final.\n\npublic String changeTimezone( Timestamp stamp, Timezone fTz, Timezone toTz){  \n    return ....\n}\n\npublic String changeTimezone(final Timestamp stamp, final Timezone fTz, \n        final Timezone toTz){\n    return ....\n}\n\n','- \n\nAs a formal method parameter is a local variable, you can access them from inner anonymous classes only if they are declared as final.\n\nThis saves you from declaring another local final variable in the method body:\n\n void m(final int param) {\n        new Thread(new Runnable() {\n            public void run() {\n                System.err.println(param);\n            }\n        }).start();\n    }\n\n\n\n\n- final is used here to ensure the two indexes i and j won\'t accidentally be reset by the method. It\'s a handy way to protect against an insidious bug that erroneously changes the value of your parameters. \nGenerally speaking, short methods are a better way to protect from this class of errors,\nbut final parameters can be a useful addition to your coding style.\nNote that final parameters are not considered part of the method signature, and are ignored by the compiler when resolving method calls. Parameters can be declared final (or not) with no influence on how the method is overriden.\n\n-Might be better to use objects rather than primitives for this example, as primitive changes will always only be visible inside the method. \nAnd in the case of objects, you can still change them. You just can\'t point at a new object. In fact now I think about it, final doesn\'t really change anything \ncompared to leaving it out, other than saving a variable declaration with AICs and having the compiler point out accidental modifications of parameters that \nyou didn\'t want to modify for some reason.\n\n\n\nThe final prevents you from assining a new value to the variable, and this can be helpful in catching typos. \nStylistically you might like to keep the parameters received unchanged and assign only to local variables, \nso final would help to enforce that style.\n\npublic int example(final int basicRate){\n    int discountRate;\n\n    discountRate = basicRate - 10;\n    // ... lots of code here \n    if ( isGoldCustomer ) {\n        basicRate--;  // typo, we intended to say discountRate--, final catches this\n    }\n    // ... more code here\n\n    return discountRate;\n}\n\n','General',1,NULL),(724,'abstract class A {\n    public abstract void foo(final String s);\n}\n\nclass B extends A {\n    public void foo(String x){\n        System.out.println(x);\n    }\n}','compiles fine','General',1,NULL),(725,'Executor ex = Executors.newFixedThreadPool(9);\nExecutor ex2 = Executors.newFixedThreadPool();\nExecutor ex3 = Executor.newFixedThreadPool(9);\nExecutor ex4 = Executors.newCachedThreadPool(7);\n\nwhich can compile ?','only the first,\n\nthe only argument constructor for cachedthreadpool takes a threadfactory.\n\na fixed thread pool has to have a size.','Executors',1,NULL),(726,'private Integer executeTask (ExecutorService service, Callable<Integer> task){\n        try{\n            Future<Integer> future = service.submit(task);\n            return future.get();\n        } catch(InterruptedException e){\n            return null;\n        }\n    }','will not compile, unreported exception ExecutionException thrown by .get()','Executors',1,NULL),(727,'private Integer executeTask (ExecutorService service, Callable<Integer> task){\n        try{\n            Future<Integer> future = service.submit(task);\n            return future.get();\n        } catch(ExecutionException e){\n            return null;\n        }\n    }','will not compile, unreported Exeption InterruptedException thrown by .get()\n\nshould be :\n\n	catch(ExecutionException | InterruptedException e){\n            return null;\n        }','Executors',1,NULL),(728,' private Integer executeTask (ExecutorService service, Callable<Integer> task){\n        try{\n            Future<Integer> future = service.submit(task);\n            return future.get();\n        } catch(InterruptedException | ExecutionException e){\n            return null;\n        }\n    }','will execute the submitted task\n\nfuture.get() will block until the activity is done.','Executors',1,NULL),(729,' private Integer executeTask (ExecutorService service, Callable<Integer> task){\n        // insert code \n    }\n\nwhat code could you insert here to execute the task using the service','try{\n	Future<Integer> future = service.submit(task);\n	return future.get();\n} catch(InterruptedException | ExecutionException e){\n   	return null;\n}\n\nor ...\n\ntry{\n	Future<Integer> future = service.submit(task);\n	return future.get();\n} catch(Exception e){\n   	return null;\n}\n\n.get() will block until a result is available','Executors',1,NULL),(730,'A runnable can return a result and throw an exception','FALSE, A Callable<E> can do that a runnable cannot do either of those things.','Executors',1,NULL),(731,'With RecursiveTask subclasses which are true ?\n\n1.fork() and join() should be called on the same task.\n2.fork() and compute() should be called on the same task.\n3.compute() and join() should be called on the same task.\n4.compute() should be called before fork()\n5.fork() should be called before compute()\n6.join() should be called after fork() but before compute()','1 and 5\n\nWhen creating multiple forkjointask instances all tasks except one shuld be forked\nfirst so that they can be picked up by other forkjoin worker threads.\nThe final task should then be executed within the same thread by calling compute()\nbefore calling join on all the forked threads to await their results. \n\ncallin methods in the wrong order will not cause compiler error so care must be taken','Concurrency',1,NULL),(732,'public class Hello {\n\n    public static void main(String[] args) {\n        Fibonacci fibonacci = new Fibonacci(10);\n        ForkJoinPool pool = new ForkJoinPool();\n        System.out.println(pool.invoke(fibonacci));\n    }\n}\n\nclass Fibonacci extends RecursiveTask<Long> {\n    final long n;\n    \n    Fibonacci(long n) {\n        this.n = n;\n    }\n    \n    public Long compute() {\n        if (n<=10) {\n            return do_fibonacci(n);\n        }\n        ForkJoinTask<Long> subTask = new Fibonacci(n-1).fork();\n        return new Fibonacci(n-2).compute() + subTask.join();\n    }\n    \n    static long do_fibonacci(long n) {\n        if ( n<=1 ) return n;\n        return do_fibonacci(n-1) + do_fibonacci(n-2);\n    }\n}','55','Concurrency',1,NULL),(733,'public class Hello {\n\n    public static void main(String[] args) {\n        Fibonacci fibonacci = new Fibonacci(10);\n        ForkJoinPool pool = new ForkJoinPool();\n        System.out.println(pool.invoke(fibonacci));\n    }\n}\n\nclass Fibonacci extends RecursiveTask<Long> {\n    final long n;\n    \n    Fibonacci(long n) {\n        this.n = n;\n    }\n    \n    public Long compute() {\n        if (n<=10) {\n            return do_fibonacci(n);\n        }\n        //ForkJoinTask<Long> subTask = new Fibonacci(n-1).fork();\n        //return new Fibonacci(n-2).compute() + subTask.join();\n        //same as ...\n        ForkJoinTask<Long> f1 = new Fibonacci(n-1);\n        Fibonacci f2 = new Fibonacci(n-2);\n        f1.fork();\n        Long l1 = f2.compute();\n        Long l2 = f1.join();\n        return l1+l2;\n    }\n    \n    static long do_fibonacci(long n) {\n        if ( n<=1 ) return n;\n        return do_fibonacci(n-1) + do_fibonacci(n-2);\n    }\n}','55, join() returns the result of the forked procedure. \n\nfork() and join() should be called on the same, Task','Concurrency',1,NULL),(734,'class Fibonacci extends RecursiveTask<Long> {\n    final long n;\n    \n    Fibonacci(long n) {\n        this.n = n;\n    }\n    \n    public Long compute() {\n        if (n<=10) {\n            return do_fibonacci(n);\n        }\n        //ForkJoinTask<Long> subTask = new Fibonacci(n-1).fork();\n        //return new Fibonacci(n-2).compute() + subTask.join();\n        //same as ...\n        ForkJoinTask<Long> f1 = new Fibonacci(n-1);\n        ForkJoinTask<Long> f2 = new Fibonacci(n-2);\n        f1.fork();\n        Long l1 = f2.compute();\n        Long l2 = f1.join();\n        return l1+l2;\n    }\n    \n    static long do_fibonacci(long n) {\n        if ( n<=1 ) return n;\n        return do_fibonacci(n-1) + do_fibonacci(n-2);\n    }\n}','Polymorphism bites you in the ass here again,\nclass Fibonacci has a compute method not FJT','Concurrency',1,NULL),(735,'public class Hello {\n\n    public static void main(String[] args) {\n        Fibonacci fibonacci = new Fibonacci(10);\n        ForkJoinPool pool = new ForkJoinPool();\n        System.out.println(pool.invoke(fibonacci));\n    }\n}\n\nclass Fibonacci extends RecursiveTask<Long> {\n    final long n;\n    \n    Fibonacci(long n) {\n        this.n = n;\n    }\n    \n    public Long compute() {\n        if (n<=10) {\n            return do_fibonacci(n);\n        }\n        //ForkJoinTask<Long> subTask = new Fibonacci(n-1).fork();\n        //return new Fibonacci(n-2).compute() + subTask.join();\n        //same as ...\n        ForkJoinTask<Long> f1 = new Fibonacci(n-1);\n        Fibonacci<Long> f2 = new Fibonacci(n-2);\n        f1.fork();\n        Long l1 = f2.compute();\n        Long l2 = f1.join();\n        return l1+l2;\n    }\n    \n    static long do_fibonacci(long n) {\n        if ( n<=1 ) return n;\n        return do_fibonacci(n-1) + do_fibonacci(n-2);\n    }\n}','type fibonacci does not take parameters','General',1,NULL),(736,'public class Hello {\n\n    public static void main(String[] args) {\n         Fibonacci fibonacci = new Fibonacci(15);\n         ForkJoinPool pool = new ForkJoinPool();\n         System.out.println(pool.invoke(fibonacci));\n    }\n}\n\n\nclass Fibonacci extends RecursiveTask<Long> {\n    final long n;\n    public static Long[] result = new Long[2];\n    public static int max_num = 1;\n    \n    public static void set_max(int num) {\n        result[0] = new Long(1);\n        result[1] = new Long(1);\n        if ( num > max_num ) {\n            Long[] new_result = new Long[num+1];\n            \n            for (int i=0; i<=max_num; i++) {\n                new_result[i] = result[i];\n            }\n            \n            result = new_result;\n            \n            for (int i=max_num+1; i<=num; i++) {\n                result[i] = new Long(0);\n            }\n            max_num = num;            \n        }\n    }\n    \n    Fibonacci(long n) {\n        this.n = n;\n        if ( n > 1 )\n            set_max((int)n);\n    }\n        \n    public Long compute() {\n        Long ret;\n        if ( result[(int)n].longValue() != 0 ) {\n            return result[(int)n];\n        }\n        if (n<=10) {\n            return do_fibonacci(n);\n        }\n        ForkJoinTask<Long> subTask = new Fibonacci(n-1);\n        ret = new Fibonacci(n-2).compute() + subTask.join();\n        result[(int)n] = new Long(ret);\n        return ret;\n    }\n    \n    static long do_fibonacci(long n) {\n        long ret;\n        if (result[(int)n].longValue() != 0) {\n            ret = result[(int)n].longValue();\n        } else {\n            long ret_n_1 = do_fibonacci(n-1);\n            long ret_n_2 = do_fibonacci(n-2);\n            ret = ret_n_1 + ret_n_2;\n            result[(int)n] = new Long(ret);\n        }\n        return ret;\n    }\n}','this program will never complete subtask is never forked so using join() will \nnever be able to return a result and it will block forever. \n\nto fix \n\nsubtask.fork();\n\n	ForkJoinTask<Long> subTask = new Fibonacci(n-1).fork();\n        ret = new Fibonacci(n-2).compute() + subTask.join();\n        result[(int)n] = new Long(ret);\n        return ret;','General',1,NULL),(737,'public class Hello {\n\n    public static void main(String[] args) {\n         Fibonacci fibonacci = new Fibonacci(15);\n         ForkJoinPool pool = new ForkJoinPool();\n         System.out.println(pool.invoke(fibonacci));\n    }\n}\n\n\nclass Fibonacci extends RecursiveTask<Long> {\n    final long n;\n    public static Long[] result = new Long[2];\n    public static int max_num = 1;\n    \n    public static void set_max(int num) {\n        result[0] = new Long(1);\n        result[1] = new Long(1);\n        if ( num > max_num ) {\n            Long[] new_result = new Long[num+1];\n            \n            for (int i=0; i<=max_num; i++) {\n                new_result[i] = result[i];\n            }\n            \n            result = new_result;\n            \n            for (int i=max_num+1; i<=num; i++) {\n                result[i] = new Long(0);\n            }\n            max_num = num;            \n        }\n    }\n    \n    Fibonacci(long n) {\n        this.n = n;\n        if ( n > 1 )\n            set_max((int)n);\n    }\n        \n    public Long compute() {\n        Long ret;\n        if ( result[(int)n].longValue() != 0 ) {\n            return result[(int)n];\n        }\n        if (n<=10) {\n            return do_fibonacci(n);\n        }\n        ForkJoinTask<Long> subTask = new Fibonacci(n-1);\n        ret = new Fibonacci(n-2).compute() + subTask.join();\n        subTask.fork();\n        result[(int)n] = new Long(ret);\n        return ret;\n    }\n    \n    static long do_fibonacci(long n) {\n        long ret;\n        if (result[(int)n].longValue() != 0) {\n            ret = result[(int)n].longValue();\n        } else {\n            long ret_n_1 = do_fibonacci(n-1);\n            long ret_n_2 = do_fibonacci(n-2);\n            ret = ret_n_1 + ret_n_2;\n            result[(int)n] = new Long(ret);\n        }\n        return ret;\n    }\n}','will wait forever a subtask has to be fork()ed before it can rejoin the \nmain task. ','General',1,NULL),(738,'private final ReentrantReadWriteLock    rwl         = new ReentrantReadWriteLock();\nprotected final Lock                    readLock    = rwl.readLock();\nprotected final Lock                    writeLock   = rwl.writeLock();\nprotected final Condition               hasData     = writeLock.newCondition();\n\n\npublic void write() {\n\n    writeLock.lock();\n    try {\n        // write data\n        // ...\n        if (something_written) {\n            hasData.signalAll();\n        }\n    }\n    finally {\n        writeLock.unlock();\n    }\n}\n\n// replace Object by something else\npublic Object read() throws InterruptedException {\n\n    Object data = tryRead();\n\n    while (data == null) {\n        waitForData();\n        data = tryRead();\n    }\n\n    return data;\n}\n\n// replace Object by something else\nprivate Object tryRead() {\n\n    readLock.lock();\n    try {\n        Object data = null;\n        // read data\n        // ...\n        // if there no data available, return null\n        return data;\n    }\n    finally {\n        readLock.unlock();\n    }\n}\n\nprivate void waitForData() throws InterruptedException {\n\n    writeLock.lock();\n    try {\n        boolean data_available = // check data\n        while (!data_available) {\n            hasData.await(1000L, TimeUnit.MILLISECONDS);\n            data_available = // check data\n        }\n    }\n    finally {\n        writeLock.unlock();\n    }\n}\n','This is the same behavior of your typical ReadWriteLock usage case if there\n is available data for reading. If no data exists, then a reader becomes a\n \"writer\" (in the lock sense) and waits until some data is available. The \ncycle repeats until some available data is returned (or until an interrupt \noccurs).\n\nSince you\'re using a ReadWriteLock, it means you\'re expecting a much \ngreater number of reads than writes and so you chose a lock that minimizes \ncontention between reader threads (the readLock).\n\nThe method waitForData() turns readers into \"writers\" because they lock on\n the writeLock instead, resulting in an increased contention between all\n threads (readers and writers). However, since writes are assumed to be \nmuch rarer than reads, a situation where data keeps toggling fast \nbetween \"available\" and \"unavailable\" is not expected. In other words, \nassuming writes are rare:\n\n    If there is no available data for reading, then virtually all readers\n will typically block in the method waitForData() after some time, and\n will all be notified at the same time when some new data is written.\n\n    If there is some available data for reading, then all readers will\n simply read it without creating any contention among the threads when \nlocking the readLock.\n','Concurrency',1,NULL),(739,'private final ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();\nprotected final Lock readLock = rwl.readLock();\nprotected final Lock writeLock = rwl.writeLock();\nprotected final Condition hasData = writeLock.newCondition();\nprivate HashMap myData = new HashMap(); //example structure to read and write\n\nprivate final ReentrantLock dataArrivalLock = new ReentrantLock();\nprivate final Condition dataArrivalSignal = dataArrivalLock.newCondition();\n\nYour writer method pattern :\n\ntry {\n   writeLock.lock();    \n\n   //...\n   myData.put(\"foo\",\"ffoo\"); //write something !!\n   if( something_written ) {\n      hasData.signalAll();\n   }\n\n}\nfinally {\n   writeLock.unlock();\n}\n  try {\n                //signal other threads that data has been put in\n                dataArrivalLock.lock();\n                dataArrivalSignal.signalAll();\n\n            } finally {\n                dataArrivalLock.unlock();\n            }\n\nYour reader method pattern\n\ntry {\n            boolean gotData = false;\n            while (!gotData) {\n                try {\n                    readLock.lock();\n                    if (myData.size() > 0) {\n                        gotData = true;\n                        //retrieve the data that is written by writer thred!!\n                        myData.get(\"foo\");\n                    }\n                } finally {\n                    readLock.unlock();\n                }\n                if(!gotData) {\n //sleep the reader thread for x milliseconds. x depends on your application requirement\n                  //   Thread.sleep(250);\n                    try {\n                        //instead of Thread.sleep(), use the dataArrivalLock signal to wakeup\n                        dataArrivalLock.lock();\n                        dataArrivalSignal.await();\n                        //based on how the application works a timed wait might be better !!\n                        //dataArrivalSignal.await(250);\n                    } finally {\n                        dataArrivalLock.unlock();\n                    }\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        } ','What this does is force your reader thread to sleep until some data is written by the writer thread .','Concurrency',1,NULL),(740,'class CarRadio extends Thread {\n    \n    public void run(){\n      while(true){  \n        Song nextSong = DJ.spinNextTrack();\n        play(nextSong);\n        try{ Thread.sleep(2000); } catch(InterruptedException e) { }\n      }\n    }\n    public void play(Song song){\n        System.out.println(\"CarRadio: \"+song.getClip());\n    }\n    \n}\n\nclass DJ {\n    private final static LinkedList<Song> queue = new LinkedList<>();\n    private final static ReentrantReadWriteLock queueLock = new ReentrantReadWriteLock();\n    private final static Lock readLock = queueLock.readLock();\n    private final static Lock writeLock = queueLock.writeLock();\n    private final static Condition newSong = writeLock.newCondition();\n    private final static Condition readSong = readLock.newCondition();\n    private final static DJ INSTANCE = new DJ();\n    \n    private DJ(){\n\n    }\n    \n    public static DJ callDJ(){\n        return INSTANCE;\n    }\n\n    public static Song spinNextTrack(){\n        readLock.lock();\n        try{\n            if(queue.isEmpty()){\n                try { newSong.await(); }catch(InterruptedException e) { }\n            }\n            return queue.poll(); \n        } finally {\n            readLock.unlock();\n        }      \n    }\n\n    public static void addToQueue(Song song){\n        writeLock.lock();\n        try{\n            //this lock blocks until acquired\n            //queueLock.writeLock().lock();\n            queue.add(song);\n            newSong.signalAll();\n        } finally{\n            writeLock.unlock();\n        }\n    }\n}\n\nclass ConstantPop extends Thread {\n    private String[] sounds = {\" Lah \", \" La La \", \" Naaahh \", \" YOLO \" };\n    private static int songCounter = 0;\n    \n    public void run(){\n        while(true){\n            Song hotNewSong = studio();\n            DJ.addToQueue(hotNewSong);\n            try { Thread.sleep(2000); } catch(InterruptedException e) { }  \n        }\n    }\n    private Song studio(){\n        StringBuilder sb = new StringBuilder();\n        for(int i = 0; i<=3; i++){\n            sb.append(sounds[ThreadLocalRandom.current().nextInt(0,3)]);\n        }\n        songCounter++;\n        return new Song(\"PopSong.\"+songCounter,sb.toString());\n    }\n}','Read lock does not support Conditions so calling newCondition() will cause \nan UnsupportedOperationException','Concurrency',1,NULL),(741,'Which Collection from java.util.concurrent is best when there are more reads\nthan writes','Copy on write, because they mkae a new copy of the collection for each write.','Concurrency',1,NULL),(742,'ConcurrentSkipListMap and concurrentMap atomic methods','putIfAbsent(K key, V value)\n\nremove(Object key, Object value)\n\nreplace(K key, V value)\n\nreplace(K key, V oldValue, V newValue)','Concurrency',1,NULL),(743,'Factory patter:','a concrete class with static methods is used to create instances of objects \nthat implement an interface.','Concurrency',1,NULL),(744,'what pattern ?\n\npublic interface Vehicle {\n	public void start();\n	public void stop();\n}\n\npublic class Car implements Vehicle {\n	public void start() { }\n	public void stop() { }\n}\n\npublic class CarManufacturer {\n	public static Vehicle getVehicle(String type) {\n		//create an instance of the type passed in\n	}\n}\n\nclass MyClass {\n	psmv(sa) {\n		Vehicle ferrari = CarManufacturer.getVehicle(\"Ferrari\");\n	\n		ferrari.start();\n	}\n}','Factory,\n\nfactory is used to create instances of classes that implement an interface.\nCan be used at runtime to decide which object to create at runtime','Concurrency',1,NULL),(745,'for jdbc 3.0 drivers and earlier you are responsible for loading the class\nusing static forName(). Later driver classes are loaded automatically.','','Concurrency',1,NULL),(746,'public class Hello {\n    public static void main(String[] args){\n        try {\n            Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\");\n            Statement st = conn.createStatement();\n            String query = \"Select * From employees limit 10\";\n            ResultSet rs = st.executeQuery(query);\n            while(rs.next()){\n                System.out.println(rs.getInt(\"emp_no\"));\n                System.out.println(rs.getString(\"first_name\"));\n                System.out.println(rs.getString(\"last_name\"));\n            } \n            \n        } catch(SQLException e){ }\n        \n    }\n}\n','10001\nGeorgi\nFacello\n10002\nBezalel\nSimmel\n10003\nParto\nBamford\n10004\nChirstian\nKoblick\n10005\nKyoichi\nMaliniak\n10006\nAnneke\nPreusig\n10007\nTzvetan\nZielinski\n10008\nSaniya\nKalloufi\n10009\nSumant\nPeac\n10010\nDuangkaew\nPiveteau','Concurrency',1,NULL),(747,'public class Hello {\n    public static void main(String[] args){\n        try {\n            Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\");\n            Statement st = conn.createStatement();\n            String update = \"update employee set emp_no = 11111 where first_name = Georgi\";\n            ResultSet rs = st.executeUpdate(update);\n            while(rs.next()){\n                System.out.println(rs.getInt(\"emp_no\"));\n                System.out.println(rs.getString(\"first_name\"));\n                System.out.println(rs.getString(\"last_name\"));\n            } \n            \n        } catch(SQLException e){ }\n        \n    }\n}','will not compile, executeUPdate returns an int of updated rows.','Concurrency',1,NULL),(748,'what jdbc method would you use when you are unsure of the result of a query\nor update','execute(String sql) \n\nthe return value is true if the result is a result set and false if the \nquery is an update count or no results. \n\n','Concurrency',1,NULL),(749,'public class Hello {\n    public static void main(String[] args){\n        try {\n            Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\");\n            Statement st = conn.createStatement();\n            String update = \"Update employees Set first_name = \'Big John\' where first_name = \'Georgi\'\";\n            boolean b = st.execute(update);\n            System.out.println(b);\n        } catch(SQLException e){System.out.println(\"something went wrong\"); }\n        \n    }\n}','false \n\nexecute returns true if it returns a result set and false for an update count','Concurrency',1,NULL),(750,'public class Hello {\n    public static void main(String[] args){\n        try {\n            Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\");\n            Statement st = conn.createStatement();\n            String update = \"Update employees Set first_name = \'Big John\' where first_name = \'Georgi\'\";\n            boolean b = st.execute(update);\n            if(b){\n                //ResultSet res = update.getResultSet();\n                ResultSet res = st.getResultSet();\n            } else {\n                int numrows = st.getUpdateCount();\n                if(numrows == -1){\n                    System.out.println(\"No Results\");\n                }\n            }\n        } catch(SQLException e){System.out.println(\"something went wrong\"); }\n        \n    }\n}','if getUpdateCount() returns -1 then there were no results.','Concurrency',1,NULL),(751,'public class Hello {\n    public static void main(String[] args){\n        try {\n            Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\");\n            Statement st = conn.createStatement();\n            String update = \"Update employees Set first_name = \'Big John\' where first_name = \'Georgi\'\";\n            boolean b = st.execute(update);\n            if(b){\n                ResultSet res = update.getResultSet();\n            } else {\n                int numrows = st.getUpdateCount();\n                if(numrows == -1){\n                    System.out.println(\"No Results\");\n                }\n            }\n        } catch(SQLException e){System.out.println(\"something went wrong\"); }\n        \n    }\n}','will not compiles, getResultSet is from a statement object','Concurrency',1,NULL),(752,'public class Hello {\n    public static void main(String[] args){\n        try {\n            Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\");\n            Statement st = conn.createStatement();\n            String update = \"Select first_name from employees\";\n            boolean b = st.execute(update);\n            if(b){\n                //ResultSet res = update.getResultSet();\n                ResultSet res = st.getResultSet();\n                System.out.println(res.getString(\"first_name\"));\n            } else {\n                int numrows = st.getUpdateCount();\n                if(numrows == -1){\n                    System.out.println(\"No Results\");\n                }\n            }\n            \n            \n        } catch(SQLException e){System.out.println(\"something went wrong\"); }\n        \n    }\n}','something went wrong\n\nyou have to always call next() before processing a rown from a result set \nthe cursors starts out as before the first row.\n\nIt is a sqlexception to try to get a row when it is before the first row.','Concurrency',1,NULL),(753,'public class Hello {\n    public static void main(String[] args){\n        try {\n            Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\");\n            Statement st = conn.createStatement();\n            String update = \"Select first_name from employees\";\n            boolean b = st.execute(update);\n            if(b){\n                //ResultSet res = update.getResultSet();\n                ResultSet res = st.getResultSet();\n                res.next();\n                System.out.println(res.getString(\"first_name\"));\n            } else {\n                int numrows = st.getUpdateCount();\n                if(numrows == -1){\n                    System.out.println(\"No Results\");\n                }\n            }\n            \n            \n        } catch(SQLException e){System.out.println(\"something went wrong\"); }\n        \n    }\n}\n','Big John','Concurrency',1,NULL),(754,'ublic class Hello {\n    public static void main(String[] args){\n        try {\n            Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\");\n            Statement st = conn.createStatement();\n            String update = \"Select first_name from employees\";\n            boolean b = st.execute(update);\n            if(b){\n                ResultSet res = st.getResultSet();\n                res.next();\n                System.out.println(res.getInt(1));\n                System.out.println(res.getDate(2));\n                System.out.println(res.getString(3));\n                \n            } else {\n                int numrows = st.getUpdateCount();\n                if(numrows == -1){\n                    System.out.println(\"No Results\");\n                }\n            }\n            \n            \n        } catch(SQLException e){System.out.println(e); }\n        \n    }\n}','SQLException invalid value for getInt()\n\nyour sql query only selected the firstnames, there are no other coluns to get\ninfo from. ','JDBC',1,NULL),(755,'public class Hello {\n    public static void main(String[] args){\n        try {\n            Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\");\n            Statement st = conn.createStatement();\n            String update = \"Select * from employees\";\n            boolean b = st.execute(update);\n            if(b){\n                ResultSet res = st.getResultSet();\n                res.next();\n                System.out.println(res.getInt(1));\n                System.out.println(res.getDate(2));\n                System.out.println(res.getString(3));\n                \n            } else {\n                int numrows = st.getUpdateCount();\n                if(numrows == -1){\n                    System.out.println(\"No Results\");\n                }\n            }\n            \n            \n        } catch(SQLException e){System.out.println(e); }\n        \n    }\n}','run:\n10001\n1953-09-02\nBig John\nBUILD SUCCESSFUL (total time: 1 second)\n','JDBC',1,NULL),(756,'public class Hello {\n    public static void main(String[] args){\n        try {\n            Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\");\n            Statement st = conn.createStatement();\n            String update = \"Select * from employees\";\n            boolean b = st.execute(update);\n            if(b){\n                ResultSet res = st.getResultSet();\n                res.next();\n                System.out.println(res.getInt(0));\n                System.out.println(res.getDate(1));\n                System.out.println(res.getString(2));\n                \n            } else {\n                int numrows = st.getUpdateCount();\n                if(numrows == -1){\n                    System.out.println(\"No Results\");\n                }\n            }\n            \n            \n        } catch(SQLException e){System.out.println(e); }\n        \n    }\n}','sql exception index out of range,\n\nindexs range from 1 to the size','JDBC',1,NULL),(757,'public class Hello {\n    public static void main(String[] args){\n        try {\n            Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\");\n            Statement st = conn.createStatement();\n            String update = \"Select * from employees\";\n            boolean b = st.execute(update);\n            if(b){\n                ResultSet res = st.getResultSet();\n                System.out.println(res.getInt(1));\n                System.out.println(res.getDate(2));\n                System.out.println(res.getString(3));\n                \n            } else {\n                int numrows = st.getUpdateCount();\n                if(numrows == -1){\n                    System.out.println(\"No Results\");\n                }\n            }\n            \n            \n        } catch(SQLException e){System.out.println(e); }\n        \n    }\n}\n','sqlexception, next() was not called before processing a result set','JDBC',1,NULL),(758,'java.sql.Date extends java.util.Date\n\nwhats the main difference\n\njava.sql.Date pubDate = rs.getDate(\"PubDate\");','sql Date stores in the form yyyy mm dd','JDBC',1,NULL),(759,'java.sql.Time time = rs.getTime(\"FinishTime\");\n\nwhat form does this kind of Time take ?','\"hh:mm:ss\"','JDBC',1,NULL),(760,'use getObject for a general purpose get()\n\njdbc will return a wrapper for the appropriate sql type.\n\nso a sql int would return integer\n\nObject o = rs.getObject(\"AuthorID\");\nif( o instanceof Integer){\n	//do\n}','','JDBC',1,NULL),(761,'How can you figure out the number of columns in a ResultSet ?','String query = \"  \";\nResultSet res = stmt.executeQuery(query);\nReslutSetMetaData rsmd = rs.getMetaData();\nrs.next();\nint colCount = rsmd.getColumnCount();','JDBC',1,NULL),(762,'public class Hello {\n    public static void main(String[] args){\n        try {\n            Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\");\n            Statement st = conn.createStatement();\n            String q = \"Select * from employees\";\n            \n            ResultSet rs = st.executeQuery(q);\n            ResultSetMetaData rmd = rs.getMetaData();\n            int cols = rmd.getColumnCount();\n            \n            for(int i = 1; i <= cols; i++){\n                System.out.println(rmd.getTableName(i));\n                System.out.println(rmd.getColumnName(i));\n                System.out.println(rmd.getColumnDisplaySize(i));\n            } \n        } catch(SQLException e){System.out.println(e); }\n        \n    }\n}','employees\nemp_no\n11\nemployees\nbirth_date\n10\nemployees\nfirst_name\n14\nemployees\nlast_name\n16\nemployees\ngender\n1\nemployees\nhire_date\n10','JDBC',1,NULL),(763,'public class Hello {\n    public static void main(String[] args){\n        try {\n            Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\");\n            Statement st = conn.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE,ResultSet.CONCUR_READ_ONLY);\n            String q = \"Select * From employees limit 100\";\n            ResultSet rs = st.executeQuery(q);\n            \n            rs.first();\n            System.out.println(\"First entry:\");\n            System.out.println(rs.getString(\"first_name\") + \" \" +rs.getString(\"last_name\"));\n            \n            rs.last();\n            System.out.println(\"Last entry:\");\n            System.out.println(rs.getString(\"first_name\") + \" \" +rs.getString(\"last_name\"));\n            \n            rs.absolute(20);\n            System.out.println(\"row: \"+ rs.getRow());\n            System.out.println(rs.getString(\"first_name\") + \" \" +rs.getString(\"last_name\"));\n            \n            rs.relative(10);\n            System.out.println(\"row: \"+ rs.getRow());\n            System.out.println(rs.getString(\"first_name\") + \" \" +rs.getString(\"last_name\"));  \n        } catch(SQLException e){System.out.println(e); }\n        \n    }\n}','First entry:\nMicheal Boyd\nLast entry:\nKenroku Malabarba\nrow: 20\nKyoichi Maliniak\nrow: 30\nGuoxiang Nooteboom','JDBC',1,NULL),(764,'Once created you cannot change the concurrency or Cursor type of an existing\nstatement object.','true','JDBC',1,NULL),(765,'if cursor or concurrency settings are not supported then the driver will show\na warning and silently revert to default settings. ','','JDBC',1,NULL),(766,'public class Hello {\n    public static void main(String[] args){\n       int a = 8;\n        System.out.println(\"what is b? :\"+a++);\n    }\n}','what is b? :8\n','JDBC',1,NULL),(767,'public class Hello {\n   \n    public static void main(String[] args) {\n        Hello h = new Hello();\n        h.methodlocal();\n    }\n    \n    public void methodlocal(){\n        int y = 56;\n        \n        private class Zombie {\n            public int size;\n        \n            public Zombie(int x){ size = x;}\n            public void mone(){\n                System.out.println(\"ughhhg: \"+ size);\n            }\n            \n            public void accessTheLiving(){\n                System.out.println(\"local var: \"+y);\n            }\n            \n        }\n        \n        Zombie zom = new Zombie(7);\n        \n    }\n\n}','method local inner classes cannot access non final local variables,\n\nalso method local classes are just like local variables they cannot be \n	static private public protected or anything else','JDBC',1,NULL),(768,'public class Hello {\n    public static void main(String[] args){\n        List<Animal> animals = new ArrayList<Animal>();\n        animals.add(new Dog());\n        animals.add(new Animal());\n    }\n    public static void addAnimal(List<Object> animals) {\n	animals.add(new Dog());\n    }\n}\n\nclass Dog extends Animal {}\nclass Animal { }','compiles fine','JDBC',1,NULL),(769,'public class Hello<T> {\n    \n    public static void main(String[] args){\n        ArrayList<Beagle> a = new ArrayList<>();\n        ArrayList<Animal> b = new ArrayList<>();\n        \n        Hello<String> x = new Hello<>();\n        \n        \n        \n        x.copyColl(a,b);\n        \n\n    } \n    public <G extends Being> void copyColl(Collection<? extends G> src, Collection<? super G> dest){\n        \n        for(G n : dest)\n            src.add(n);\n        \n    }\n}\n\nclass Beagle extends Animal { }\nclass Animal extends Being {} \nclass Being { }','will not compile, \n\nfirst you cant add to a collection defined with ? extends. \n\nsecond, since dest is defined with ? super it is saying that that collection\ncan be of any type of super class of G,thouhg you can still add only G. \n\nTherefore the iterator will return objects not Gs.\n\nYou are taking from dest and adding to src. dest is the producer and src is the\nconsumer. Producers extend Consumers Super. ITs backward here. ','Collections',1,NULL),(770,'public class Hello<T> {\n    \n    public static void main(String[] args){\n        ArrayList<RedWolf> a = new ArrayList<>();\n        ArrayList<Animal> b = new ArrayList<>();\n        \n        Hello<String> x = new Hello<>();\n        \n        \n        \n        x.copyColl(a,b);\n        \n\n    } \n    public <G extends Beagle> void copyColl(Collection<? extends G> src, Collection<? super G> dest){\n        \n        for(G g : src)\n            dest.add(g);\n        \n    }\n}\n\n\nclass GoodBeagles extends Beagle { }\nclass Beagle extends Animal { }\nclass Animal extends Being {} \nclass Being { }\nclass Wolf { } \nclass RedWolf{ }','will not compile redwolf does not extend beagle','Collections',1,NULL),(771,'public class Hello {\n    public static void main(String[] dicks){\n         try {\n            Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\");\n            Statement st = conn.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_UPDATABLE);\n            String q = \"Select * from employees\";\n            ResultSet rs = st.executeQuery(q);\n            \n            if(rs.last()){\n               int rowCount = rs.getRow();\n               rs.beforeFirst();\n                System.out.println(rowCount);\n            }\n            \n            \n        } catch(SQLException e){System.out.println(e); }\n    }\n}','shows the number of rows ','Collections',1,NULL),(772,'public class Hello {\n    public static void main(String[] dicks){\n         try {\n            Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\");\n            Statement st = conn.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_UPDATABLE);\n            String q = \"Select * from employees limit 100\";\n            ResultSet rs = st.executeQuery(q);\n            rs.absolute(-10);\n             System.out.println(rs.getRow()); \n        } catch(SQLException e){System.out.println(e); }\n    }\n}','91\n\nif absolute takes a - number it starts from the last row and works backward. \n\nreturns false if the cursor is beyond the lst row or beffore the first','Collections',1,NULL),(773,'public class Hello extends Thread {\n    public static void main(String[] args){\n        try(Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees\", \"root\", \"Basketball12\")){\n            String getAllEmployeeNames = \"select first_name,last_name from employees\";\n            Statement st1 = conn.createStatement();\n            \n            ResultSet empnames = st1.executeQuery(getAllEmployeeNames);\n            \n            empnames.last();\n            \n            System.out.println(empnames.getString(\"first_name\")+\" \"+empnames.getString(\"last_name\"));\n            \n        }catch(SQLException e){\n            System.out.println(e);\n        }\n    }\n}','Sachin Tsukuda','JDBC',1,NULL),(774,'public class Hello {\n    public static void main(String[] dicks){\n         try {\n            Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\");\n            Statement st = conn.createStatement(ResultSet.TYPE_FORWARD_ONLY,ResultSet.CONCUR_UPDATABLE);\n            String q = \"Select * from employees limit 100\";\n            ResultSet rs = st.executeQuery(q);\n            System.out.println(rs.getRow()); \n        } catch(SQLException e){System.out.println(e); }\n    }\n}','0','JDBC',1,NULL),(775,'public class Hello {\n    public static void main(String[] dicks){\n         try {\n            Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\");\n            Statement st = conn.createStatement(ResultSet.TYPE_FORWARD_ONLY,ResultSet.CONCUR_UPDATABLE);\n            String q = \"Select * from employees limit 100\";\n            ResultSet rs = st.executeQuery(q);\n            rs.afterLast();\n            System.out.println(rs.getRow()); \n        } catch(SQLException e){System.out.println(e); }\n    }\n}','also 0','JDBC',1,NULL),(776,'public class Hello {\n    public static void main(String[] dicks){\n         try {\n            Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\");\n            Statement st = conn.createStatement(ResultSet.TYPE_FORWARD_ONLY,ResultSet.CONCUR_UPDATABLE);\n            String q = \"Select * from employees limit 100\";\n            String q2 = \"Select * from salaries limit 100\";\n            ResultSet rs = st.executeQuery(q);\n            rs.afterLast();\n            System.out.println(rs.getRow()); \n            conn.close();\n            rs = st.executeQuery(q2);\n            while(rs.next()){\n                System.out.println(rs.getInt(\"salary\"));\n            }\n        } catch(SQLException e){System.out.println(e); }\n    }\n}','run:\n0\njava.sql.SQLException: No operations allowed after statement closed.\nBUILD SUCCESSFUL (total time: 0 seconds)\n\nit is not an exception to call getRow after the last row or before the first.\nit will simply give zero. \n','JDBC',1,NULL),(777,'public class Hello {\n    public static void main(String[] dicks){\n         try(Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\");\n            Statement st = conn.createStatement(ResultSet.TYPE_FORWARD_ONLY,ResultSet.CONCUR_UPDATABLE);) {\n            String q = \"Select * from employees limit 100\";\n            String q2 = \"Select * from salaries limit 100\";\n            ResultSet rs = st.executeQuery(q);\n            rs.afterLast();\n            System.out.println(rs.getRow()); \n        } catch(SQLException e){System.out.println(e); }\n    }\n}','0','JDBC',1,NULL),(778,'String url = \"   \";\nString user = \"  \";\nString pwd = \"    \";\n\n// insert here\nConnection conn = DriverManaget.getConnection(url,user,pwd);\n\nwhat would you use to load a JDBC 3.0 driver class','Class.forName(\"org.abc.mmmysql.Driver\");','JDBC',1,NULL),(779,'What does it take for a driver to be jdbc 4.0 compliant ?	','Must include a MEAT-INF file, this allows the driver to autoload.\n\nMust provide implementations of Driver, Connection, Statement, ResultSet\ninterfaces\n\nMust support transactions\n\n','JDBC',1,NULL),(780,'What three are availabe through an instance of DatabaseMetaData ?\n\n1 number of columns returned\n2 number of rows returned\n3 name of jdbc driver\n4 default transaciton isolation level\n5 last query used\n6 names of stored procedures\n7 current Savepoint name','3\n4\n6','JDBC',1,NULL),(781,'try {\n	Statement st = conn.createStatement();\n	String query = \"Select * From Author Where LastName Like \'Rand%\'\";\n	Resultset rs = st.executeQuery(query);\n	if(rs == null) {\n		sout( \"no results\" );\n	} else {\n		sout(rs.getString(\"FirstName\");\n	}\n} catch(SQLException se) {\n	sout(\"SQLException\");\n}','SQLException, next() wass not called the cursors starts of pointing to BEFORE\nthe first row. ','JDBC',1,NULL),(782,'public class Hello {\n    public static void main(String[] dicks){\n         try(Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employee?useSSL=false\", \"root\", \"Basketball12\")){\n             String query = \"Update employees set first_name = \'Hefty\' where emp_no = 10001\"; \n             Statement st = conn.createStatement();\n             st.executeQuery(query);\n         } catch(SQLException e){\n             System.out.println(\"SQLException\");\n         }\n    }\n \n}','SQLException\n\nexecuteQuery cannot be used to execute update insrt delete or ddl statements \nor it will throw a sqlexception. \n','JDBC',1,NULL),(783,'try {\n	ResultSet rs = null;\n	try (Statement st = conn.createStatement()) {\n		String query = \"Select * From Customer\";\n		rs = st.executeQuery(query);\n	} catch(SQLException se) {\n		sout(\"Illegal query\");	\n	}\n\n	while (rs.next()) {\n		//process customers \n	}\n} catch(SQLException e) {\n	sout(\"SQLException\");\n}','SQLException\n\ntrying to access a closed ResultSet. ','JDBC',1,NULL),(784,'Statement st = conn.createStatement();\nResultSet rs;\nString query = \"<QUERY HERE>\";\nst.execute(query);\nif ((Rs = st.getResultSet()) != null) {\n	sout(\"Results\");\n}\nif (st.getUpdateCount() > -1) {\n	sout(\"update\");\n}\n\nSelect * from customer\ninsert into ...\nupdate...\ndelete...','these would all produce their indicated rsults, update will produce and update count\neven if no rows are affected','JDBC',1,NULL),(785,'String q = \"update customer set Last_name = ? Where Customer_id = ?\";\ntry {\n	PreparedStatement pt = conn.prepareStatement(q);\n	pt.setString(0,\"Smith\");\n	pt.setString(1,\"5001\");\n	int result = pt.executeUpdate();\n	if(result != 1) sout(\"error\");\n} catch(SQLException e) {\n	sout(\"Exception\");\n}','exception\n\nparameters are numbered starting from 1 not 0.','JDBC',1,NULL),(786,'try {\n	String[] searchPair = {\"%a%\", \"%b%\",\"%c%\",\"%d%\" };\n	String query = \"Sleect ... ? ... ?\";\n	PreparedStatement pt = conn.PrepareStatement(query);\n	for(int i = 0; i < searchPair.length; i+=2) {\n		pt.setString(i+1, searchPAir[i]);\n		pt.setString(i+2, searchPair[i++]);\n		ResultSet rs = pt.executeQuery();\n		while(rs.next()) {\n			sout(\"yes\");\n		}\n	}\n} catch(Sqlexcepiton ee) {\n	sout	(\"SQLException\");\n}\n			','yes yes sqlexception everything is smooth on the first iteration, but \nthe second the preparedstatement index paramenters will be 3 and 4 when there\nare only two parameters, this will cause the exc.','JDBC',1,NULL),(787,'public class Hello {\n    public static void main(String[] dicks){\n         List<?> list = new ArrayList<Dog>();\n         list.add(new Dog());\n         list.add(new Dog());\n         list.add(new Dog());\n    }\n \n}\n\nclass Dog {\n    \n}','Collections of type ? can be assigned to by any type of list but cannot be\nadded to. ','Collections',1,NULL),(789,'public class Hello {\n    public static void main(String[] dicks){\n         List<Dog> Doglist = new ArrayList<Dog>();\n         Doglist.add(new Dog(\"Charly\"));\n         Doglist.add(new Dog(\"Baily\"));\n         Doglist.add(new Dog(\"Wiley\"));\n         \n         ArrayList<?> unmodifiableDogList = Doglist;\n         \n         for(Object d : unmodifiableDogList){\n             System.out.println(d.getName());\n         }\n    }\n \n}\n\nclass Dog {\n    private String name;\n    public Dog(String s ){\n        name = s;\n    }\n    \n    public String getName(){\n        return name;\n    }\n    \n}','althought the base type here is ArrayList Doglist is defined as a list \nso it cannot be assigned to an ArrayList ','Collections',1,NULL),(790,'public class Hello<T> {\n    public static void main(String[] args){\n        \n        Dog d = new Dog();\n        \n        ArrayList x = makeArrayList(d);\n        \n        ArrayList c = new ArrayList<String>();\n        c.add(new Dog());\n        c.add(90);\n\n    } \n    public static <G> ArrayList<G> makeArrayList(G g){\n        ArrayList<G> genlist = new ArrayList();\n        genlist.add(g);\n        return genlist;\n        \n    }\n}\n\nclass Dog {\n    \n}','compiles fine the reference type is still defined as a raw type','Collections',1,NULL),(791,'public class Hello {\n    public static void main(String[] args){\n       File file1 = new File(\"~/Public/TestDir/file1\");\n       File file2 = new File(\"~/Public/TestDir/file2\");\n       File dir = new File(\"~/Public/TestDir\");\n       \n       if(dir.exists() && dir.isDirectory()){\n           file1.createNewFile();\n           file2.createNewFile();\n       } else {\n           dir.mkdir();\n           file1.createNewFile();\n           file2.createNewFile();\n       }\n    } \n}','will not compile, all those methods throw IOExceptions','Input/Output',1,NULL),(792,'public class Hello<T> {\n    \n    public static void main(String[] args){\n        \n        Dog d = new Dog();\n        \n        ArrayList<? extends Dog> c = new ArrayList<Beagle>();\n        Animal a = c.get(0);\n    } \n}\n\nclass Animal{}\nclass Dog extends Animal { }\nclass Beagle extends Dog { }','fine','Generics',1,NULL),(793,'public class Hello<T> {\n    \n    public static void main(String[] args){\n        ArrayList<Animal> a;\n        ArrayList<Beagle> b;\n        \n        Hello<String> x = new Hello<>();\n        \n        x.copyColl(a,b);\n        \n\n    } \n    public <G> void copyColl(Collection<G extends Animal> src, Collection<G> dest){\n        \n        for(G n : src)\n            dest.add(n);\n        \n    }\n}\n\nclass Animal{}\nclass Dog extends Animal { }\nclass Beagle extends Dog { }','will not compile wrong number of type arguments, \nthis is a generic method, \n\nit should be <? extends Animal>','Generics',1,NULL),(794,'public class Hello<T> {\n    \n    public static void main(String[] args) {\n        Cat cat = parse(\"cat\");\n        Dog dog = parse(\"dog\");\n        System.out.println(\"the cat object is a \" + cat);\n        System.out.println(\"the dog object is a \" + dog);\n    }\n\n    private static class Dog {\n        public String toString() { return \"dog\"; }\n    }\n\n    private static class Cat {\n        public String toString() { return \"cat\"; }\n    }\n\n    private static Object untypedParse(String stringToParse) {\n        if(stringToParse.equals(\"dog\")) {\n            return new Dog();\n        } else if(stringToParse.equals(\"cat\")) {\n            return new Cat();\n        } else {\n            throw new RuntimeException(\"not expected\");\n        }\n    }\n\n    public static <T> T parse(String stringToParse) {\n        return (T)untypedParse(stringToParse);\n    }\n\n}','in java 7 and beyond the compiler can infer the type from the return type !','Generics',1,NULL),(795,'//How to fix this\npublic static T fromXml<T>(String xml) {\n  try {\n    JAXBContext context = JAXBContext.newInstance(T.class);\n    Unmarshaller um = context.createUnmarshaller();\n    return (T)um.unmarshal(new StringReader(xml));\n  } catch (JAXBException je) {\n    throw new RuntimeException(\"Error interpreting XML response\", je);\n  }\n}\n\n//Also the call doesn\'t work...\nfromXml<SomeSubObject>(\"<xml/>\");','First it should be: public static <T> T fromXML<T>(String xml)\n\nIn Java, generics are compile-time only data, which are lost at run time. \nSo, if you called a method like that, the JVM would have no way of knowing what T.class was. \nThe normal way to get around this is to pass a class instance object as a parameter to the method, \nlike this:\n\npublic static <T> T fromXml(Class<T> clazz, String xml) {\n  try {\n    JAXBContext context = JAXBContext.newInstance(clazz);\n    Unmarshaller um = context.createUnmarshaller();\n    return (T)um.unmarshal(new StringReader(xml));\n  } catch (JAXBException je) {\n    throw new RuntimeException(\"Error interpreting XML response\", je);\n  }\n}\n\nfromXml(SomeSubObject.class, \"<xml/>\");\n\n','Generics',1,NULL),(796,'public class Hello<T> {\n    \n    public static void main(String[] args){\n        try (Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\")){\n            String prepInsert = \"Insert into employees values(?,\'1962-11-07\',?,?,\'F\',\'1962-11-07\')\";\n            PreparedStatement ps = conn.prepareStatement(prepInsert,ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_UPDATABLE);\n            ps.setInt(1,555);\n            ps.setString(3,\"Angela\");\n            ps.setString(4,\"Horton\");\n            \n            int rowsupdated = ps.executeUpdate();\n            \n            System.out.println(rowsupdated);\n\n        }catch(Exception e){\n            System.out.println(e);\n            \n        }\n        \n    }\n}','java.sql.SQLException: Parameter index out of range (4 > number of parameters, which is 3).','JDBC',1,NULL),(797,'public class Hello<T> {\n    \n    public static void main(String[] args){\n        try (Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\")){\n            String prepInsert = \"Insert into employees values(?,\'1962-11-07\',?,?,\'F\',\'1962-11-07\')\";\n            PreparedStatement ps = conn.prepareStatement(prepInsert,ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_UPDATABLE);\n            ps.setInt(1,556);\n            ps.setString(2,\"Angela\");\n            ps.setString(3,\"Horton2\");\n            \n            int rowsupdated = ps.executeUpdate();\n            System.out.println(rowsupdated);\n            \n            ps.setInt(1,666);\n            ps.setString(2,\"MAX\");\n            ps.setString(3,\"AMILLION\");\n            \n            rowsupdated = ps.executeUpdate();\n            \n            System.out.println(rowsupdated);\n\n        }catch(Exception e){\n            System.out.println(e);\n            \n        }\n        \n    }\n}','1\n1\n\nyou can use a prepared statement multiple times','JDBC',1,NULL),(798,'public class Hello<T> {\n    \n    public static void main(String[] args){\n        try (Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\")){\n            String prepInsert = \"Select * from employees where first_name = ? OR last_name = ?\";\n            PreparedStatement ps = conn.prepareStatement(prepInsert,ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_UPDATABLE);\n            ps.setString(1,\"Georgi\");\n            ps.setString(2,\"Horton\");\n            \n            ResultSet rs = ps.executeQuery();\n            \n            while(rs.next()){\n                System.out.println(rs.getString(\"first_name\")+\" \"+rs.getString(\"emp_no\"));\n            }\n        }catch(Exception e){\n            System.out.println(e);           \n        }\n    }\n}','Angela 555','JDBC',1,NULL),(799,'public class Hello<T> {\n    \n    public static void main(String[] args){\n        try (Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\")){\n            String prepInsert = \"Select * from employees where first_name = ? OR last_name = ?\";\n            PreparedStatement ps = conn.prepareStatement(prepInsert,ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_UPDATABLE);\n            ps.setString(1,\"Georgi\");\n            ps.setString(2,\"Horton\");\n            \n            ResultSet rs = ps.executeQuery(prepInsert);\n            \n            while(rs.next()){\n                System.out.println(rs.getString(\"first_name\")+\" \"+rs.getString(\"emp_no\"));\n            }\n        }catch(Exception e){\n            System.out.println(e);           \n        }\n    }\n}','com.mysql.jdbc.exceptions.jdbc4.MySQLSyntaxErrorException: You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near \'? OR last_name = ?\' at line 1\n\npreparedstatement execute query does not take a String parameter, it already\nknows the query to execute. ','JDBC',1,NULL),(800,'int customerID = 5001;\njava.sql.Date fromDate = ...;\njava.sql.Date toDate = ...;\nString getBooksInDateRange = \"{call getBooksDateRange(?,?,?)}\";\n\nCallableStatement cstmt = conn.prepareCall(getBooksInDateRange,ResultSet.TYPE_SCROLL_INSESNSITIVE,ResultSet.CONCUR_UPDATABLE);\n\ncstmt.setInt(1,customerID);\ncstmt.setDate(2,fromDate);\ncstmt.setDate(3,toDate);\nResultSet rs = cstmt.executeQuery();\n\n\n','calls the stored proceudre getBooksInDateRange','JDBC',1,NULL),(801,'int customerID = 5001;\njava.sql.Date fromDate = ...;\njava.sql.Date toDate = ...;\nString getBooksInDateRange = \"{? =call customerTotal (?)}\";\n\nCallableStatement cstmt = conn.prepareCall(getBooksInDateRange,ResultSet.TYPE_SCROLL_INSESNSITIVE,ResultSet.CONCUR_UPDATABLE);\n\ncstmt.registerOutParameter(1,java.sql.Types.DOUBLE);\n\ncstmt.setInt(2,customerID);\n\ncstmt.execute(); // not returning a resultset\n\nint total = cstmt.getDouble(1);\n','to use a stored procedure you have to register the out parameter \nfirst. As shown here. ','JDBC',1,NULL),(802,'int customerID = 5001;\njava.sql.Date fromDate = ...;\njava.sql.Date toDate = ...;\nString getBooksInDateRange = \"{? =call customerTotal (?)}\";\n\nCallableStatement cstmt = conn.prepareCall(getBooksInDateRange,ResultSet.TYPE_SCROLL_INSESNSITIVE,ResultSet.CONCUR_UPDATABLE);\n\ncstmt.registerOutParameter(1,java.sql.Types.DOUBLE);\n\ncstmt.setInt(2,customerID);\n\ncstmt.execute(getBookInDateRange); // not returning a resultset\n\nint total = cstmt.getDouble(1);\n                                  ','sqlexception execute doesn\'t take a parameter','JDBC',1,NULL),(803,'int customerID = 5001;\nint numberOfOrders;\nCallableStatement ct = conn.prepareCall(\"{call customerOrderCount (?) }\");\nct.setInt(1,customerID);\nct.registerOutParameter(1.java.sql.Types.INTEGER);  // the out\n\nct.execute();\n\nint numberoforders = ct.getInt(1);','registers an INOUT parameter','JDBC',1,NULL),(804,'int customerID = 5001;\nint numberOfOrders;\nCallableStatement ct = conn.prepareCall(\"{call customerOrderCount (?) }\");\nct.setInt(1,customerID);\nct.registerOutParameter(1.java.sql.Types.INTEGER);  // the out\n\nct.executeQuery();\n\nint numberoforders = ct.getInt(1);','storedprocedures is code thta you dont have insight to and if you invoke executeQuery()\non a procedure that doesn\'t return a result set you get a sqlException\n\nso its best to use execute()','JDBC',1,NULL),(805,'int customerID = 5001;\nint numberOfOrders;\nCallableStatement ct = conn.prepareCall(\"{call customerOrderCount (?) }\");\nct.setInt(1,customerID);\nct.registerOutParameter(1.java.sql.Types.INTEGER);  // the out\n\nct.execute();\n\nint numberoforders = ct.getInt(1);\n\nif(ct.getMoreResults()) // returns true if there is a resultset to get. ','','JDBC',1,NULL),(806,'RowSetFactory rsf = RowSetProvider.newFactory();\nJdbcRowSet jrs = rsf.createJdbcRowSet();\n// Provider returns a facotry that will create Rowset objects from\n// the reference implementation\n\n//with the factory it is easy to swap out the implementation\n\nRowSetFactorys rsf2 = RowSetProvider.newFactory(\"com.example.MyRowSetProvider\",null);\nJdbcRowSet jrs = rsf.createJdbcRowSet();','','JDBC',1,NULL),(807,'public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n        try(JdbcRowSet jrs = RowSetProvider.newFactory().createJdbcRowSet()){\n            String query = \"Select * from employees limit 100\";\n            jrs.setCommand(query);\n            jrs.setUrl(url);\n            jrs.setUsername(user);\n            jrs.setPassword(pw);\n            jrs.execute();\n            while(jrs.next()){\n                System.out.println(jrs.getString(\"first_name\") + \" \" + jrs.getString(\"last_name\"));\n            }    \n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n}','prints the first 100 employees\' full names\n\nyou construct a JdbcRowSet from a RowSetProvider.newFactory().createJdbcRowSet();\n\ninstead of statement conncection and resultSet you use RowSet commands\nto set the uname, pw and url. \n\nthen simply execute it. ','JDBC',1,NULL),(808,'public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n        try(JdbcRowSet jrs = RowSetProvider.createJdbcRowSet()){\n            String query = \"Select * from employees limit 100\";\n            jrs.setCommand(query);\n            jrs.setUrl(url);\n            jrs.setUsername(user);\n            jrs.setPassword(pw);\n            jrs.execute();\n            while(jrs.next()){\n                System.out.println(jrs.getString(\"first_name\") + \" \" + jrs.getString(\"last_name\"));\n            }    \n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n}','will not compile the proper way to create a JdbcRowSet is\n\n	JdbcRowSet jrs = RowSetProvider.newFactory().createJdbcRowSet()','JDBC',1,NULL),(809,'public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n            JdbcRowSet jrs = RowSetProvider.newFactory().createJdbcRowSet();\n            String query = \"Select * from employees limit 100\";\n            jrs.setCommand(query);\n            jrs.setUrl(url);\n            jrs.setUsername(user);\n            jrs.setPassword(pw);\n            jrs.execute();\n            while(jrs.next()){\n                System.out.println(jrs.getString(\"first_name\") + \" \" + jrs.getString(\"last_name\"));\n            }    \n    }\n}','Will not compil creating a JdbcRowSet throws an sql exception so it is usually\ncreated in a try() - catch block, \n\nNot to mention every other of those commands throws an sqlexception','JDBC',1,NULL),(810,'public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n        try(JdbcRowSet jrs = RowSetProvider.newFactory().createJdbcRowSet()){\n            String query = \"Select * from employee limit 100\";\n            jrs.setCommand(query);\n            jrs.execute();\n            while(jrs.next()){\n                System.out.println(jrs.getString(\"first_name\") + \" \" + jrs.getString(\"last_name\"));\n            }    \n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n}','NullPointerException, the username and password and url were not set, \n\nIT could Also throw an sqlexception for this,\n\nexecute fills the rowset with data. Just alswyas make sure that data is set.','JDBC',1,NULL),(811,'public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n        try(JdbcRowSet jrs = RowSetProvider.newFactory().createJdbcRowSet()){\n            String query = \"Select * from employees limit 100\";\n            jrs.setCommand(query);\n            jrs.setUrl(url);\n            jrs.setUsername(user);\n            jrs.setPassword(pw);\n            jrs.setType(ResultSet.TYPE_SCROLL_INSENSITIVE);\n            jrs.execute();\n            while(jrs.next()){\n                System.out.println(jrs.getString(\"first_name\") + \" \" + jrs.getString(\"last_name\"));\n            }    \n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n}','RowSet extends Result set so it is a result set\n\nseting the type still uses the resultset types. ','JDBC',1,NULL),(812,'public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n        try(JdbcRowSet jrs = RowSetProvider.newFactory().createJdbcRowSet()){\n            String query = \"Select * from employees limit 100\";\n            jrs.setCommand(query);\n            jrs.setUrl(url);\n            jrs.setUsername(user);\n            jrs.setPassword(pw);\n            jrs.setType(RowSet.TYPE_SCROLL_INSENSITIVE);\n            jrs.execute();\n            while(jrs.next()){\n                System.out.println(jrs.getString(\"first_name\") + \" \" + jrs.getString(\"last_name\"));\n            }    \n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n}','will not compile,\n\nResultSet.TYPE_SCROLL_INSENSITIVE\n\nThose fields are inherited from ResultSet. \n\nFields inherited from interface java.sql.ResultSet\nCONCUR_READ_ONLY, \nCONCUR_UPDATABLE, \nTYPE_FORWARD_ONLY, \nTYPE_SCROLL_INSENSITIVE, \nTYPE_SCROLL_SENSITIVE','JDBC',1,NULL),(813,'public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n        try(JdbcRowSet jrs = RowSetProvider.newFactory().createJdbcRowSet()){\n            String query = \"Update employees set first_name = \'Mike\' where emp_no = 789\";\n            jrs.setCommand(query);\n            jrs.setUrl(url);\n            jrs.setUsername(user);\n            jrs.setPassword(pw);\n            jrs.setType(ResultSet.TYPE_SCROLL_INSENSITIVE);\n            jrs.execute();\n            while(jrs.next()){\n                System.out.println(jrs.getString(\"first_name\") + \" \" + jrs.getString(\"last_name\"));\n            }    \n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n}','SQLException, you cannot Update insert or delete with execute() on a RowSet.\n\nto update the data you just update the data on your JdbcRowSet.\n\nthere are no executeQuery() or executeUpdate methods for RowSets. ','JDBC',1,NULL),(814,'public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n        try(JdbcRowSet jrs = RowSetProvider.newFactory().createJdbcRowSet()){\n            String query = \"Update employees set first_name = \'Mike\' where emp_no = 789\";\n            jrs.setCommand(query);\n            jrs.setUrl(url);\n            jrs.setUsername(user);\n            jrs.setPassword(pw);\n            jrs.setType(ResultSet.TYPE_SCROLL_INSENSITIVE);\n            jrs.executeUpdate();\n            while(jrs.next()){\n                System.out.println(jrs.getString(\"first_name\") + \" \" + jrs.getString(\"last_name\"));\n            }    \n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n}','will not compile there is no executeUpdate() for RowSets,\nbecause you do not update insert or delete in this way. You use the update api.\n\nThis would be a sql exception anyway because you cannot perform update \ninsert or deletes with a sql command and a jdbc rowset.','JDBC',1,NULL),(815,'public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n        try(JdbcRowSet jrs = RowSetProvider.newFactory().createJdbcRowSet()){\n            String query = \"Select * from employees limit 100\";\n            jrs.setCommand(query);\n            jrs.setUrl(url);\n            jrs.setUsername(user);\n            jrs.setPassword(pw);\n            jrs.setType(ResultSet.TYPE_SCROLL_INSENSITIVE);\n            jrs.executeQuery();\n            while(jrs.next()){\n                System.out.println(jrs.getString(\"first_name\") + \" \" + jrs.getString(\"last_name\"));\n            }    \n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n}','will not compiles there is no executeQuery() with Jdbcrowsets. The Command is \nexecute()','JDBC',1,NULL),(816,'How do you execute a query with a JdbcRowSet object ? ','first set the user pw and url with:\n\n	       jrs.setUrl(url);\n            jrs.setUsername(user);\n            jrs.setPassword(pw);\n\nthen set the command: \n		String query = \"Select * from employees limit 100\";\n            jrs.setCommand(query);\n\nthen use the only command to execute:\n\nexecute()','JDBC',1,NULL),(817,'public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n        try(JdbcRowSet jrs = RowSetProvider.newFactory().createJdbcRowSet()){\n            String query = \"Select * from employees limit 100\";\n            jrs.setUrl(url);\n            jrs.setUsername(user);\n            jrs.setPassword(pw);\n            jrs.setType(ResultSet.TYPE_SCROLL_INSENSITIVE);\n            jrs.execute();\n            while(jrs.next()){\n                System.out.println(jrs.getString(\"first_name\") + \" \" + jrs.getString(\"last_name\"));\n            }    \n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n}','NullpointerExeption you never set the command, could be an sqlException too\n\ndont forget to:\n\nsetCommand(query);','JDBC',1,NULL),(818,'public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n        try(JdbcRowSet jrs = RowSetProvider.newFactory().createJdbcRowSet()){\n            String query = \"Select * from employees limit 100\";\n            jrs.setQuery(query);\n            jrs.setUrl(url);\n            jrs.setUsername(user);\n            jrs.setPassword(pw);\n            jrs.execute();\n            while(jrs.next()){\n                System.out.println(jrs.getString(\"first_name\") + \" \" + jrs.getString(\"last_name\"));\n            }    \n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n}','will not copile the method is setCommand not setQuery','JDBC',1,NULL),(819,'You can update data in the database with a resultset but thats not on the \nexam so DONT WORRY ABOUT IT. \n\nyou can do the same with RowSet and that IS on the exam so thats what you shuld focus on','','JDBC',1,NULL),(820,'public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n        try(JdbcRowSet jrs = RowSetProvider.newFactory().createJdbcRowSet()){\n            String query = \"Select * from employees limit 100\";\n            jrs.setCommand(query);\n            jrs.setUrl(url);\n            jrs.setUsername(user);\n            jrs.setPassword(pw);\n            jrs.execute();\n            while(jrs.next()){\n                System.out.println(jrs.getString(\"first_name\") + \" \" + jrs.getString(\"last_name\"));\n            }\n            jrs.last();\n            jrs.updateString(\"first_name\",\"Big Max\");\n            jrs.updateRow();\n            \n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n}','change the last employees first name to \'Big Max\'','JDBC',1,NULL),(821,'public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n        try(JdbcRowSet jrs = RowSetProvider.newFactory().createJdbcRowSet()){\n            String query = \"Select * from employees limit 100\";\n            jrs.setCommand(query);\n            jrs.setUrl(url);\n            jrs.setUsername(user);\n            jrs.setPassword(pw);\n            jrs.execute();\n            \n            jrs.last();\n            jrs.updateString(\"first_name\",\"Big Max\");\n            jrs.updateRow();\n\n            while(jrs.next()){\n                System.out.println(jrs.getString(\"first_name\") + \" \" + jrs.getString(\"last_name\"));\n            }\n            \n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n}','This will print nothing, the cursor is already at the last poisiton so\nthere is not next for jrs to go to to fix add \n\n	jrs.first()\n\njust before the while loop.','JDBC',1,NULL),(822,'public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n        try(JdbcRowSet jrs = RowSetProvider.newFactory().createJdbcRowSet()){\n            String query = \"Select * from employees limit 100\";\n            jrs.setCommand(query);\n            jrs.setUrl(url);\n            jrs.setUsername(user);\n            jrs.setPassword(pw);\n            jrs.execute();\n            \n            jrs.last();\n            jrs.updateString(\"first_name\",\"Big Max\");\n            jrs.updateRow();\n            jrs.first();\n            while(jrs.next()){\n                System.out.println(jrs.getString(\"first_name\") + \" \" + jrs.getString(\"last_name\"));\n            }\n            \n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n}','will show the updated rows ','JDBC',1,NULL),(823,'public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n        try(JdbcRowSet jrs = RowSetProvider.newFactory().createJdbcRowSet()){\n            String query = \"Select * from employees limit 100\";\n            jrs.setCommand(query);\n            jrs.setUrl(url);\n            jrs.setUsername(user);\n            jrs.setPassword(pw);\n            jrs.execute();\n            jrs.first();\n            jrs.updateString(\"first_name\",\"Big Max\");\n            jrs.updateString(\"last_name\",\"Big Dick Bisesi\");\n            jrs.updateRow();\n            System.out.println(jrs.getString(\"first_name\") + \" \" + jrs.getString(\"last_name\"));\n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n}','will update the first row of the RowSet and write teh changes to the database\n\nprints: Big Max Big Dick Bisesi','JDBC',1,NULL),(824,'public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n        try(JdbcRowSet jrs = RowSetProvider.newFactory().createJdbcRowSet()){\n            String query = \"Select * from employees limit 100\";\n            jrs.setCommand(query);\n            jrs.setUrl(url);\n            jrs.setUsername(user);\n            jrs.setPassword(pw);\n            jrs.first();\n            jrs.updateString(\"first_name\",\"Big Max\");\n            jrs.updateString(\"last_name\",\"Big Dick Bisesi\");\n            jrs.updateRow();\n            System.out.println(jrs.getString(\"first_name\") + \" \" + jrs.getString(\"last_name\"));\n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n}','SQLException: Invalid State\n\nexecute() was never used.','JDBC',1,NULL),(825,'public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n        try(JdbcRowSet jrs = RowSetProvider.newFactory().createJdbcRowSet()){\n            String query = \"Select * from employees limit 100\";\n            jrs.setCommand(query);\n            jrs.setUrl(url);\n            jrs.setUsername(user);\n            jrs.setPassword(pw);\n            jrs.execute();\n            jrs.beforeFirst();\n            jrs.updateString(\"first_name\",\"Big Max\");\n            jrs.updateString(\"last_name\",\"Big Dick Bisesi\");\n            jrs.updateRow();\n            System.out.println(jrs.getString(\"first_name\") + \" \" + jrs.getString(\"last_name\"));\n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n}','NullPointerException the cursor is before the first row','JDBC',1,NULL),(826,'public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n        try(JdbcRowSet jrs = RowSetProvider.newFactory().createJdbcRowSet()){\n            String query = \"Select * from employees limit 100\";\n            jrs.setCommand(query);\n            jrs.setUrl(url);\n            jrs.setUsername(user);\n            jrs.setPassword(pw);\n            jrs.execute();\n            jrs.absolute(0);\n            jrs.updateString(\"first_name\",\"Big Max\");\n            jrs.updateString(\"last_name\",\"Big Dick Bisesi\");\n            jrs.updateRow();\n            System.out.println(jrs.getString(\"first_name\") + \" \" + jrs.getString(\"last_name\"));\n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n}','NPE moving to absolute(0) moves to before the first row. \n\nmoving abosolute(-n) starts at the last row and moves the cursor backward','JDBC',1,NULL),(827,'public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n        try(JdbcRowSet jrs = RowSetProvider.newFactory().createJdbcRowSet()){\n            String query = \"Select * from employees limit 100\";\n            jrs.setCommand(query);\n            jrs.setUrl(url);\n            jrs.setUsername(user);\n            jrs.setPassword(pw);\n            jrs.execute();\n            jrs.absolute(5);\n            jrs.updateString(\"first_name\",\"Angela\");\n            jrs.updateString(\"last_name\",\"Big Butt Horton\");\n            jrs.updateRow();\n            System.out.println(jrs.getString(\"first_name\") + \" \" + jrs.getString(\"last_name\"));\n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n}','changes the fifth row in the rowset.\n\nAngela Bit Butt Horton','JDBC',1,NULL),(828,'How to insert a new row into a RowSet ?','jrs.moveToInsertRow();\njrs.updateString(\"first_name\",\"Jonny\");\njrs.udateString...\njrs.updateInt...\njrs.insertRow();\njrs.moveToCurrentRow();','JDBC',1,NULL),(829,'public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n        try(JdbcRowSet jrs = RowSetProvider.newFactory().createJdbcRowSet()){\n            String query = \"Select * from employees limit 100\";\n            jrs.setCommand(query);\n            jrs.setUrl(url);\n            jrs.setUsername(user);\n            jrs.setPassword(pw);\n            \n            jrs.moveToInsertRow();\n            jrs.updateInt(\"emp_no\",12345);\n            jrs.updateString(\"firs_name\",\"Blue\");\n            jrs.updateString(\"last_name\",\"Bella\");\n            jrs.insertRow();\n            \n            //System.out.println(jrs.getString(\"first_name\") + \" \" + jrs.getString(\"last_name\"));\n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n}','sqlexception: invalid state there is no rowset to perforem these changes on \nbecause execute() wasn\'t called.','JDBC',1,NULL),(830,'public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n        try(JdbcRowSet jrs = RowSetProvider.newFactory().createJdbcRowSet()){\n            String query = \"Select * from employees limit 100\";\n            jrs.setCommand(query);\n            jrs.setUrl(url);\n            jrs.setUsername(user);\n            jrs.setPassword(pw);\n            \n            jrs.execute();\n            \n            jrs.moveToInsertRow();\n            jrs.updateInt(\"emp_no\", 789);\n            jrs.updateString(\"first_name\",\"Blue\");\n            jrs.updateString(\"last_name\",\"Bella\");\n            jrs.insertRow();\n            \n            System.out.println(jrs.getString(\"first_name\") + \" \" + jrs.getString(\"last_name\"));\n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n}','Blue Bella this prints the values just inserted in the insert row.','JDBC',1,NULL),(831,'public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n        try(JdbcRowSet jrs = RowSetProvider.newFactory().createJdbcRowSet()){\n            String query = \"Select * from employees limit 100\";\n            jrs.setCommand(query);\n            jrs.setUrl(url);\n            jrs.setUsername(user);\n            jrs.setPassword(pw);\n            jrs.execute();\n            jrs.moveToInsertRow();\n            System.out.println(jrs.getString(\"first_name\") + \" \" + jrs.getString(\"last_name\"));\n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n}','null null','JDBC',1,NULL),(832,'public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n        try(JdbcRowSet jrs = RowSetProvider.newFactory().createJdbcRowSet()){\n            String query = \"Select * from employees limit 100\";\n            jrs.setCommand(query);\n            jrs.setUsername(user);\n            jrs.setPassword(pw);\n            jrs.execute();\n            jrs.moveToInsertRow();\n            System.out.println(jrs.getString(\"first_name\") + \" \" + jrs.getString(\"last_name\"));\n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n}','NPE setURL was left out ','JDBC',1,NULL),(833,'public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n        try(JdbcRowSet jrs = RowSetProvider.newFactory().createJdbcRowSet()){\n            String query = \"Select * from employees limit 100\";\n            jrs.setCommand(query);\n            jrs.setUrl(url);\n            jrs.setUsername(user);\n            jrs.setPassword(pw);\n            jrs.execute();\n            \n            jrs.addRowSetListener(new MyRowSetListener());\n            \n            jrs.moveToInsertRow();\n            jrs.updateInt(\"emp_no\",3);\n            jrs.updateString(\"first_name\",\"Micheal\");\n            jrs.updateString(\"last_name\",\"Boyd\");\n            jrs.insertRow();\n            \n            jrs.moveToCurrentRow();\n            \n            while(jrs.next()){\n                System.out.println(jrs.getString(\"first_name\") + \" \" + jrs.getString(\"last_name\"));\n            }\n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n    \n    class MyRowSetListener implements RowSetListener {\n        \n        public void rowChanged(RowSetEvent event) {\n            if(event.getSource() instanceof RowSet) {\n                try{\n                    ((RowSet) event.getSource()).execute();\n                    //re excute the query every time the rowset is updchanged to update it\n                } catch(SQLException e){\n                    \n                }\n                \n            }\n        }\n        \n        public void cursorMoved(RowSetEvent e) { }\n        public void rowSetChanged(RowSetEvent e){ }\n    }\n}','will not compile non static variable cannot be referenced from static context','JDBC',1,NULL),(834,'\npublic class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n        try(JdbcRowSet jrs = RowSetProvider.newFactory().createJdbcRowSet()){\n            String query = \"Select * from employees limit 100\";\n            jrs.setCommand(query);\n            jrs.setUrl(url);\n            jrs.setUsername(user);\n            jrs.setPassword(pw);\n            jrs.execute();\n            \n            jrs.addRowSetListener(new MyRowSetListener());\n            \n            jrs.moveToInsertRow();\n            jrs.updateInt(\"emp_no\",3);\n            jrs.updateString(\"first_name\",\"Micheal\");\n            jrs.updateString(\"last_name\",\"Boyd\");\n            jrs.insertRow();\n            \n            jrs.moveToCurrentRow();\n            \n            while(jrs.next()){\n                System.out.println(jrs.getString(\"first_name\") + \" \" + jrs.getString(\"last_name\"));\n            }\n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n    \n    static class MyRowSetListener implements RowSetListener {\n        \n        public void rowChanged(RowSetEvent event) {\n            if(event.getSource() instanceof RowSet) {\n                try{\n                    ((RowSet) event.getSource()).execute();\n                    //re excute the query every time the rowset is updchanged to update it\n                } catch(SQLException e){\n                    \n                }\n                \n            }\n        }\n        \n        public void cursorMoved(RowSetEvent e) { }\n        public void rowSetChanged(RowSetEvent e){ }\n    }\n}','create a rowsetlistener','JDBC',1,NULL),(835,'a JdbcRowSet is connected which means its update are actively written to\nthe db, a CachedRowSet and all the rest are disconnected which means they\ncan connect to get the data disconnect change the data then re connect to \nupdate their changes, thats what a cache is.','got it','JDBC',1,NULL),(836,'how do you create a CachedRowSet','CachedRowSet cs = RowSetProvider.newFactory().createCachedRowSet();','JDBC',1,NULL),(837,'\npublic class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n        try(JdbcRowSet jrs = RowSetProvider.newFactory().createJdbcRowSet()){\n            String query = \"Select * from employees limit 100\";\n            jrs.setCommand(query);\n            jrs.setUrl(url);\n            jrs.setUsername(user);\n            jrs.setPassword(pw);\n            jrs.execute();\n            \n            jrs.addRowSetListener(new MyRowSetListener());\n            \n            jrs.moveToInsertRow();\n            jrs.updateInt(\"emp_no\",3);\n            jrs.updateString(\"first_name\",\"Micheal\");\n            jrs.updateString(\"last_name\",\"Boyd\");\n            jrs.insertRow();\n            \n            jrs.moveToCurrentRow();\n            \n            while(jrs.next()){\n                System.out.println(jrs.getString(\"first_name\") + \" \" + jrs.getString(\"last_name\"));\n            }\n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n    \n    static class MyRowSetListener implements RowSetListener {\n        \n        public void rowChanged(RowSetEvent event) {\n            if(event.getSource() instanceof RowSet) {\n                try{\n                    ((RowSet) event.getSource()).execute();\n                    //re excute the query every time the rowset is updchanged to update it\n                } catch(SQLException e){\n                    \n                }\n                \n            }\n        }\n        \n        public void cursorMoved(RowSetEvent e) { }\n        public void rowSetChanged(RowSetEvent e){ }\n    }\n}','will not compile thats not how you create a RowSet. you should add \n\n	createJdbcRowSet();','JDBC',1,NULL),(838,'When your done changing CachedRowSet what do you call?','acceptChanges();','JDBC',1,NULL),(839,'how do you begin a transaction in jdbc ?','Connection conn = DriverManager..\nconn.setAutoCommit(false); // begin transaction','JDBC',1,NULL),(840,'A jdbc transaction includes all of the sQL queries you execute until either ...?','you exlicityly commmit the current transaction\n\nyou excplicityl roll back the current transaction\n\nthere is a failure that forces automatic rollback.','JDBC',1,NULL),(841,'public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n       try(Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\")){\n           conn.setAutoCommit(false);\n           Statement stmt = conn.createStatement();\n           stmt.execute(\"Insert into employees values (601,\'Dixon\',\'Ramey\')\");\n           stmt.execute(\"Insert into employees values (602,\'Alex\',\'Ramey\')\");\n           stmt.execute(\"Insert into employees values (603,\'Kevin\',\'Ramey\')\");\n           \n           conn.commit();\n           \n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n    \n}','start a transacation by setting autoCommit(false), then make sure you commit()\nit otherwise everything you just did will be automatically rolledback. \n\nAs soon you commit() another transaction is started.\n\nThere can only be one transaction at a time. ','JDBC',1,NULL),(842,'public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n       try(Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\")){\n           conn.setAutoCommit(false);\n           Statement stmt = conn.createStatement();\n           stmt.execute(\"Insert into employees values (601,\'Dixon\',\'Ramey\')\");\n           stmt.execute(\"Insert into employees values (602,\'Alex\',\'Ramey\')\");\n           stmt.execute(\"Insert into employees values (603,\'Kevin\',\'Ramey\')\");\n           \n           conn.commit();\n           \n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n            \n            conn.rollback();\n        }\n    }\n    \n}','will not compile, Connection is scoped only within that try block because it is\nin a try with resources, conn in the catch is out of scope. ','JDBC',1,NULL),(843,'public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\");\n  \n        try{   \n        \n            conn.setAutoCommit(false);\n           Statement stmt = conn.createStatement();\n           stmt.execute(\"Insert into employees values (601,\'Dixon\',\'Ramey\')\");\n           stmt.execute(\"Insert into employees values (602,\'Alex\',\'Ramey\')\");\n           stmt.execute(\"Insert into employees values (603,\'Kevin\',\'Ramey\')\");\n           \n           conn.commit();\n           \n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n            \n            conn.rollback();\n        }\n    }\n    \n}','WNC DriverManager.getConnection throws a sqlexception ','JDBC',1,NULL),(844,'public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n       try(Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\")){\n           conn.setAutoCommit(false);\n           Statement stmt = conn.createStatement();\n           int updatecount = 0;\n           \n           updatecount += stmt.executeUpdate(\"Insert into employees values (701,\'Dixon\',\'Ramey\')\");\n           updatecount += stmt.executeUpdate(\"Insert into employees values (702,\'Alex\',\'Ramey\')\");\n           updatecount += stmt.executeUpdate(\"Insert into employees values (703,\'Kevin\',\'Ramey\')\");\n           \n           if(updatecount == 3){\n               System.out.println(\"Transaction complete\");\n                conn.commit();\n           } else {\n               System.out.println(\"Something didn\'t go through\");\n               conn.rollback();\n           }\n\n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n    \n}','if the insertions go as planned then commit the transaction otherwise try again\n','JDBC',1,NULL),(845,'public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n       try(Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\")){\n           Statement stmt = conn.createStatement();\n           int updatecount = 0;\n           \n           updatecount += stmt.executeUpdate(\"Insert into employees values (701,\'Dixon\',\'Ramey\')\");\n           updatecount += stmt.executeUpdate(\"Insert into employees values (702,\'Alex\',\'Ramey\')\");\n           updatecount += stmt.executeUpdate(\"Insert into employees values (703,\'Kevin\',\'Ramey\')\");\n           \n           if(updatecount == 3){\n               System.out.println(\"Transaction complete\");\n                conn.commit();\n           } else {\n               System.out.println(\"Something didn\'t go through\");\n               conn.rollback();\n           }\n\n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n    \n}','sqlexception transaction has not been started. setAutoCommit(false) to start one','JDBC',1,NULL),(846,'public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n       try(Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\")){\n           conn.setAutoCommit(false);\n           Statement stmt = conn.createStatement();\n           int updatecount = 0;\n           \n           updatecount += stmt.executeUpdate(\"Insert into employees values (706,\'Dixon\',\'Ramey\')\");\n           updatecount += stmt.executeUpdate(\"Insert into employees values (707,\'Alex\',\'Ramey\')\");\n           updatecount += stmt.executeUpdate(\"Insert into employees values (708,\'Kevin\',\'Ramey\')\");\n           \n           if(updatecount == 3){\n               System.out.println(\"Transaction complete\");\n                conn.setAutoCommit(true);\n           } else {\n               System.out.println(\"Something didn\'t go through\");\n               conn.rollback();\n           }\n\n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n    \n}','setting autocommit to true will committ any current transaction and turn auto commit back on','JDBC',1,NULL),(847,'JDBC:\n\nYou call setAutoCommit(false) on Statement ojbects ','FALSE ! Connection objects','JDBC',1,NULL),(848,'a savepoint represents a point in the transaction that you can rollback to.\nit is created from a connection object.','','JDBC',1,NULL),(849,'public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n       try(Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\")){\n           conn.setAutoCommit(false);//start a transaction\n           Statement stmt = conn.createStatement();\n           int updatecount = 0;\n           \n           updatecount += stmt.executeUpdate(\"Insert into employees values (710,\'steve\',\'davidson\')\");\n           updatecount += stmt.executeUpdate(\"Insert into employees values (711,\'Alex\',\'The great\')\");\n           updatecount += stmt.executeUpdate(\"Insert into employees values (713,\'baily\',\'Ramey\')\");\n           Savepoint sp1 = conn.setSavepoint();\n           \n           stmt.executeUpdate(\"Insert into employees values(801,\'Whitey\',\'Ford\')\");\n           \n           conn.rollback();\n\n           ResultSet rs = stmt.executeQuery(\"select * from employees where first_name = \\\'Whitey\\\'\");\n           \n           while(rs.next()){\n               System.out.println(rs.getInt(\"emp_no\"));\n           }\n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n    \n}','how to use a savepoint','JDBC',1,NULL),(850,'public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n       try(Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\")){\n          String call = \"{CALL REMOVEBOOKS(?,?)}\";\n          String titleToRemove = null;\n          int maxBooks = 0;\n          CallableStatement cstmt = conn.prepareCall(call);\n          String titles = \"%Hero%\";\n          int numBooksRemoved;\n          cstmt.setInt(0,maxBooks);\n          cstmt.setString(1,titleToRemove);\n          cstmt.registerOutParameter(0,java.sql.Types.INTEGER);\n          cstmt.execute();\n          numBooksRemoved = cstmt.getInt(0); \n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n    \n}','Prepared and Callable statement setXXX() methods number parameters from \n1 not 0. ','JDBC',1,NULL),(851,'public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n       try(Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\")){\n          String call = \"{CALL REMOVEBOOKS(?,?)}\";\n          String titleToRemove = null;\n          int maxBooks = 0;\n          CallableStatement cstmt = conn.prepareCall(call);\n          String titles = \"%Hero%\";\n          int numBooksRemoved;\n          cstmt.setInt(0,maxBooks);\n          cstmt.setString(1,titleToRemove);\n          cstmt.registerOutParameter(0,java.sql.Types.INTEGER);\n          cstmt.executeQuery(query);\n          numBooksRemoved = cstmt.getInt(0); \n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n    \n}','executeQuery() for callable and preparedstatements must not have the query passed\nin as a parameter. \n\nAlso the indexes are numbered incorectly','JDBC',1,NULL),(852,'public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n       try(Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\")){\n          String call = \"{CALL REMOVEBOOKS(?,?)}\";\n          String titleToRemove = null;\n          String query = \"select * from Books\";\n          int maxBooks = 0;\n          CallableStatement cstmt = conn.prepareCall(call);\n          String titles = \"%Hero%\";\n          int numBooksRemoved;\n          cstmt.setInt(1,maxBooks);\n          cstmt.setString(2,titleToRemove);\n          cstmt.registerOutParameter(1,java.sql.Types.INTEGER);\n          cstmt.executeQuery(query);\n          numBooksRemoved = cstmt.getInt(1);\n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n    \n}','sqlexception executeQuery() for callable and prepared statements must not have\nthe query passed in as a parameter ','JDBC',1,NULL),(853,'public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n       try(Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\")){\n          String call = \"{CALL REMOVEBOOKS(?,?)}\";\n          String titleToRemove = null;\n          String query = \"select * from Books\";\n          int maxBooks = 0;\n          CallableStatement cstmt = conn.prepareCall(call);\n          String titles = \"%Hero%\";\n          int numBooksRemoved;\n          cstmt.setInt(1,maxBooks);\n          cstmt.setString(2,titleToRemove);\n          cstmt.execute();\n          cstmt.registerOutParameter(1,java.sql.Types.INTEGER);\n          numBooksRemoved = cstmt.getInt(1);\n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n    \n}','sqlexception for registering the out parameter after the execute call.','JDBC',1,NULL),(854,'public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n       try(Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\")){\n          String call = \"{CALL REMOVEBOOKS(?,?)}\";\n          String titleToRemove = null;\n          String query = \"select * from Books\";\n          int maxBooks = 0;\n          CallableStatement cstmt = conn.prepareCall(call);\n          String titles = \"%Hero%\";\n          int numBooksRemoved;\n          cstmt.setInt(1,maxBooks);\n          cstmt.setString(2,titleToRemove);\n          cstmt.registerOutParameter(1,java.sql.Types.INTEGER);\n          ResultSet rs = cstmt.executeQuery();\n          rs.next();\n          numBooksRemoved = cstmt.getInt(1);\n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n    \n}','this stored proceudre does not return a resultset, so while it will compile\nbcasue executeQuery() will return a ResultSet to rs. cstmt.getInt(1); will throw\na sql exception.','JDBC',1,NULL),(855,'public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n       try(Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\")){\n          String call = \"{CALL REMOVEBOOKS(?,?)}\";\n          String titleToRemove = null;\n          String query = \"select * from Books\";\n          int maxBooks = 0;\n          CallableStatement cstmt = conn.prepareCall(call);\n          String titles = \"%Hero%\";\n          int numBooksRemoved;\n          cstmt.setInt(1,maxBooks);\n          cstmt.setString(2,titleToRemove);\n          cstmt.registerOutParameter(1,java.sql.Types.INTEGER);\n          cstmt.execute();\n          numBooksRemoved = cstmt.getInt(1);\n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }  \n}','this is the way to use a CallableStatement.','JDBC',1,NULL),(856,'try(RowSetFactory rsf = RowSetProvider.newFactory()) {\nRowSet rws = rsf.createRowSet();','Will not compile RowSetFactory does not implement autocloseable','JDBC',1,NULL),(857,'String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n       //try(Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\")){\n        \n        try(CachedRowSet crs = RowSetProvider.newFactory().createCachedRowSet()) {\n            String query = \"Select * From employee\";\n            crs.setCommand(query);\n            crs.setUrl(url);\n            crs.setUsername(user);\n            crs.setPassword(pw);\n            crs.execute();\n            crs.last();\n            crs.updateString(\"last_name\", \"Sullivan\");\n            //database goes offline\n            crs.moveToInsertRow();\n            crs.updateInt(\"ID\",101);\n            crs.updateString(\"first_name\",\"Billy\");\n            crs.updateString(\"last_name\",\"Blue\");\n            crs.insertRow();\n            crs.moveToCurrentRow();\n            crs.absolute(10);\n            crs.deleteRow();\n            //db backonline\n        } catch(SQLException e){\n            System.out.println(e);\n        }','this database will be unchanged. the error here is that acceptChanges() was\nnever called to reconcile the changes made with the in memory version and the\nactual db.\n\nthe database being offline anytime after the execute() is invoked in irrelevent\n','JDBC',1,NULL),(858,'public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n       //try(Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\")){\n        \n        try(CachedRowSet crs = RowSetProvider.newFactory().createCachedRowSet()) {\n            String query = \"Select * From employee\";\n            crs.setCommand(query);\n            crs.setUrl(url);\n            crs.setUsername(user);\n            crs.setPassword(pw);\n            crs.execute();\n            crs.last();\n            crs.updateString(\"last_name\", \"Sullivan\");\n            //database goes offline\n            crs.moveToInsertRow();\n            crs.updateInt(\"ID\",101);\n            crs.updateString(\"first_name\",\"Billy\");\n            crs.updateString(\"last_name\",\"Blue\");\n            crs.moveToCurrentRow();\n            crs.absolute(10);\n            crs.deleteRow();\n            //db backonline\n        } catch(SQLException e){\n            System.out.println(e);\n        }\n    }  \n}\nwhats missing here ?','crs.insertRow();\n\nalso crs.acceptChanges()','JDBC',1,NULL),(859,'public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n       //try(Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\")){\n        \n        try(CachedRowSet crs = RowSetProvider.newFactory().createCachedRowSet()) {\n            String query = \"Select * From employee\";\n            crs.setCommand(query);\n            crs.setUrl(url);\n            crs.setUsername(user);\n            crs.setPassword(pw);\n            crs.last();\n            crs.updateString(\"last_name\", \"Sullivan\");\n            //database goes offline\n            crs.moveToInsertRow();\n            crs.updateInt(\"ID\",101);\n            crs.updateString(\"first_name\",\"Billy\");\n            crs.updateString(\"last_name\",\"Blue\");\n            crs.insertRow();\n            crs.moveToCurrentRow();\n            crs.absolute(10);\n            crs.deleteRow();\n            //db backonline\n        } catch(SQLException e){\n            System.out.println(e);\n        }\n    }  \n}','crs.execute() is missing','JDBC',1,NULL),(860,'public class Hello {\n    public static void main(String[] args){\n        \n        boolean businessrule = true;\n       try(Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\")){\n            String query = \"Inser into ...\";\n            String query2 = \"Updat table...\";\n            \n            Statement st = conn.createStatement();\n            \n            st.executeUpdate(query);\n            st.executeUpdate(query2);\n            \n            if(businessrule){\n                conn.rollback();\n            }\n        } catch(SQLException e){\n            System.out.println(e);\n        }\n    }  \n}','the first two updates are executed, but then a sqlexception is thrown because \na transaction was never started to rollback.\n\nyou would have had to setAutoCommit(false) to start a transaction.\n\nThe first two were automatically commited. ','JDBC',1,NULL),(861,'public class Hello {\n    public static void main(String[] args){\n        \n        boolean businessrule = false;\n       try(Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\")){\n            conn.setAutoCommit(false);\n            String query = \"Inser into ...\";\n            String query2 = \"Updat table...\";\n            \n            Statement st = conn.createStatement();\n            \n            st.executeUpdate(query);\n            st.executeUpdate(query2);\n            \n            if(businessrule){\n                conn.rollback();\n            } else {\n                conn.commit();\n            }\n        } catch(SQLException e){\n            System.out.println(e);\n        }\n    }  \n}','if the business rule remains false then both updates will be comitted.\nsince autocommit is false.','JDBC',1,NULL),(862,'public class Hello {\n    public static void main(String[] args){\n\n       try(Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\")){\n            conn.setAutoCommit(false);\n            String query = \"Inser into ...\";\n            String query2 = \"Updat table...\";\n            Statement st = conn.createStatement();\n            \n            st.executeUpdate(query);\n            \n            Savepoint sp1 = conn.setSavepoint();\n            \n            st.executeUpdate(query2);\n            \n            conn.rollback();\n           \n        } catch(SQLException e){\n            System.out.println(e);\n        }\n    }  \n}','no rows are added at all, the rollback() rolls back to the savepoint but erasing the\nsecond update, but because there is no commit() at all the first update will also be \nrolledback when the try block closes for good becaus autocommitmode was set\nto false. ','JDBC',1,NULL),(863,'public class Hello {\n    public static void main(String[] args){\n        try {\n            Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\");\n            Statement st = conn.createStatement();\n            String q = \"Select * From employees limit 100\";\n            ResultSet rs = st.executeQuery(q);\n            \n            rs.first();\n            System.out.println(\"First entry:\");\n            System.out.println(rs.getString(\"first_name\") + \" \" +rs.getString(\"last_name\"));\n            \n            rs.last();\n            System.out.println(\"Last entry:\");\n            System.out.println(rs.getString(\"first_name\") + \" \" +rs.getString(\"last_name\"));\n            \n            rs.absolute(20);\n            System.out.println(\"row: \"+ rs.getRow());\n            System.out.println(rs.getString(\"first_name\") + \" \" +rs.getString(\"last_name\"));\n            \n            rs.relative(10);\n            System.out.println(\"row: \"+ rs.getRow());\n            System.out.println(rs.getString(\"first_name\") + \" \" +rs.getString(\"last_name\")); \n            \n            String update = \"insert into employees values(09,\'Broden\',\'Chapman\')\";\n            boolean results = st.execute(update);\n            \n            if(!results){\n                System.out.println(\"update executed\");\n            }\n            \n            rs.last();\n            System.out.println(\"new entry row: \"+ rs.getRow());\n            System.out.println(rs.getString(\"first_name\") + \" \" +rs.getString(\"last_name\")); \n\n        } catch(SQLException e){System.out.println(e); }\n        \n    }\n}','First entry:\nMicheal Boyd\nLast entry:\nKenroku Malabarba\nrow: 20\nKyoichi Maliniak\nrow: 30\nGuoxiang Nooteboom\nupdate executed\njava.sql.SQLException: Operation not allowed after ResultSet closed\n\nAfter re executing a statement, all ResultSets tied to that statemnt are \nautomatically closed','JDBC',1,NULL),(864,'public class Hello {\n    public static void main(String[] args){\n        try {\n            Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\");\n            Statement st = conn.createStatement();\n            String q = \"Select * From employees limit 100\";\n            getDBfile();\n            ResultSet rs = st.executeQuery(q);\n            \n            rs.first();\n            System.out.println(\"First entry:\");\n            System.out.println(rs.getString(\"first_name\") + \" \" +rs.getString(\"last_name\"));\n            \n            rs.last();\n            System.out.println(\"Last entry:\");\n            System.out.println(rs.getString(\"first_name\") + \" \" +rs.getString(\"last_name\"));\n            \n            rs.absolute(20);\n            System.out.println(\"row: \"+ rs.getRow());\n            System.out.println(rs.getString(\"first_name\") + \" \" +rs.getString(\"last_name\"));\n            \n            rs.relative(10);\n            System.out.println(\"row: \"+ rs.getRow());\n            System.out.println(rs.getString(\"first_name\") + \" \" +rs.getString(\"last_name\")); \n            \n            String update = \"insert into employees values(09,\'Broden\',\'Chapman\')\";\n            boolean results = st.execute(update);\n            \n            if(!results){\n                System.out.println(\"update executed\");\n            }\n            \n            rs.last();\n            System.out.println(\"new entry row: \"+ rs.getRow());\n            System.out.println(rs.getString(\"first_name\") + \" \" +rs.getString(\"last_name\")); \n\n        } catch(SQLException e | IOException e){System.out.println(e); }\n        \n    }\n    \n    public static void getDBfile() throws IOException { }  \n}','Will not compile, this is not the right syntax for multi - catch\nshould be \n\n	} catch(SQLException | IOException e){  ... }','General',1,NULL),(865,'public class Hello {\n    public static void main(String[] args){\n        try {\n            Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\");\n            PreparedStatement pst = conn.prepareStatement(\"Select * From employees limit 100\");\n            ResultSet rs = pst.executeQuery();\n            \n            java.util.Date d = new java.util.Date();\n\n            rs.first();\n            System.out.println(\"First entry:\");\n            System.out.println(\"Hired today: \"+d);\n            System.out.println(rs.getString(\"first_name\") + \" \" +rs.getString(\"last_name\"));\n            \n            rs.last();\n            System.out.println(\"Last entry:\");\n            System.out.println(rs.getString(\"first_name\") + \" \" +rs.getString(\"last_name\"));\n            \n            rs.absolute(20);\n            System.out.println(\"row: \"+ rs.getRow());\n            System.out.println(rs.getString(\"first_name\") + \" \" +rs.getString(\"last_name\"));\n            \n            rs.relative(10);\n            System.out.println(\"row: \"+ rs.getRow());\n            System.out.println(rs.getString(\"first_name\") + \" \" +rs.getString(\"last_name\")); \n            \n            String update = \"insert into employees values(11,\'Broden\',\'Chapman\')\";\n            boolean results = pst.execute(update);\n            \n            if(!results){\n                System.out.println(\"update executed\");\n            }\n            \n            rs.last();\n            System.out.println(\"new entry row: \"+ rs.getRow());\n            System.out.println(rs.getString(\"first_name\") + \" \" +rs.getString(\"last_name\")); \n\n        } catch(SQLException e){System.out.println(e); }\n        \n    }\n}','First entry:\nHired today: Fri Jul 28 11:29:33 EDT 2017\nMicheal Boyd\nLast entry:\nTuval Kalloufi\nrow: 20\nChirstian Koblick\nrow: 30\nBerni Genin\nupdate executed\njava.sql.SQLException: Operation not allowed after ResultSet closed','JDBC',1,NULL),(866,'public static void main(sa) {\n	//most useless method\n	Date d = new Date();\n	sout( d.getTime() + \" \" );\n}\n\nwhat does this show ?','public long getTime()\n\nReturns the number of milliseconds \nsince January 1, 1970, 00:00:00 GMT represented by this Date object.','Strings',1,NULL),(867,'public class Hello {\n    public static void main(String[] args){\n        try {\n            Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\");\n            PreparedStatement pst = conn.prepareStatement(\"Select * From employees limit 100\");\n            ResultSet rs = pst.executeQuery();\n            \n            Date d = new Date();\n            //Calendar c = Calendar.getInstance();\n            Calendar c = new Calendar();\n            c.setTime(d);\n\n            rs.first();\n            System.out.println(\"First entry:\");\n            System.out.println(\"Hired today: \"+d);\n            System.out.println(\"Start first upcoming monday: \"+firstNextMonday(d));\n            System.out.println(rs.getString(\"first_name\") + \" \" +rs.getString(\"last_name\"));\n            \n            c.add(Calendar.MONTH,-1);\n            Date monthago = c.getTime();\n            rs.last();\n            System.out.println(\"Last entry:\");\n            System.out.println(\"Hired a month ago: \"+monthago);\n            System.out.println(rs.getString(\"first_name\") + \" \" +rs.getString(\"last_name\"));\n            ','WNC, the correct way to create a Calendar is \n\n	Calendar c = Calendar.getInstance();','Strings',1,NULL),(868,'public class Hello {\n    public static void main(String[] args){\n        try {\n            Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\");\n            PreparedStatement pst = conn.prepareStatement(\"Select * From employees limit 100\");\n            ResultSet rs = pst.executeQuery();\n            \n            Date d = new Date();\n            Calendar c = new Calendar();\n            c.setTime(d);\n\n            rs.first();\n            System.out.println(\"First entry:\");\n            System.out.println(\"Hired today: \"+d);\n            System.out.println(\"Start first upcoming monday: \"+firstNextMonday(d));\n            System.out.println(rs.getString(\"first_name\") + \" \" +rs.getString(\"last_name\"));\n            \n            c.add(Calendar.MONTH,-1);\n            Date monthago = c.getTime();\n            rs.last();\n            System.out.println(\"Last entry:\");\n            System.out.println(\"Hired a month ago: \"+monthago);\n            System.out.println(rs.getString(\"first_name\") + \" \" +rs.getString(\"last_name\"));\n        } catch(SQLException e){ }\n        \n    }\n    \n    public static Date firstNextMonday(Date d){\n        Calendar c = Calendar.getInstance();\n        c.setTime(d);\n        \n        while(c.DAY_OF_WEEK != c.MONDAY){\n            //c.add(1,DAY_OF_WEEK);\n            c.add(c.DAY_OF_WEEK,1);\n        }\n        \n        return c.getTime();\n        \n    }\n}','WNC, the corrct ways to create a Calendar is \n\n	Calendar c = Calendar.getInstance();\n\nif that was corrected then this program would print:\n\n	First entry:\n	Hired today: Mon Aug 07 16:39:34 EDT 2017\n\nand keep running forever...\n\n	you were using accesing a static field at c.DAY_OF_WEEK\n	\n	it should be:\n\n	while(c.get(Calendar.DAY_OF_WEEK) != c.MONDAY){\n            //c.add(1,DAY_OF_WEEK);\n            c.add(c.DAY_OF_WEEK,1);\n        }\n\nif today was monday it would print the excact time and day of right now','Strings',1,NULL),(869,'public class Hello {\n    public static void main(String[] args){\n        try {\n            Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\");\n            PreparedStatement pst = conn.prepareStatement(\"Select * From employees where first_name = ?\");\n            ResultSet rs = pst.executeQuery();\n            \n            Date d = new Date();\n            Calendar c = Calendar.getInstance();\n            c.setTime(d);\n            \n            DateFormat dateformat = DateFormat.getInstance();\n\n            rs.first();\n            System.out.println(\"First entry:\");\n            System.out.println(\"Hired today: \"+d);\n            System.out.println(\"Start first upcoming monday: \"+firstNextMonday(d));\n            System.out.println(rs.getString(\"first_name\") + \" \" +rs.getString(\"last_name\"));\n            \n            c.add(Calendar.MONTH,-1);\n            Date monthago = c.getTime();\n            rs.last();\n            System.out.println(\"Last entry:\");\n            System.out.println(\"Hired a month ago: \"+monthago);\n            System.out.println(rs.getString(\"first_name\") + \" \" +rs.getString(\"last_name\"));\n            \n            c.setTime(d);\n            c.add(Calendar.YEAR,-1);\n            c.add(Calendar.MONTH, -6);\n            Date yearandahalf = c.getTime();\n            rs.absolute(20);\n            System.out.println(\"row: \"+ rs.getRow());\n            System.out.println(\"Hired a year and a half ago\"+yearandahalf);\n            System.out.println(rs.getString(\"first_name\") + \" \" +rs.getString(\"last_name\"));\n	} catch(SQLException e) { }\n   }\n}','java.sql.SQLException: No value specified for parameter 1','Strings',1,NULL),(870,'public static void main(String[] args){\n        Date d = new Date();\n        DateFormat df = DateFormat.getInstance();\n        \n        System.out.println(df.format(d));\n        \n    }','7/28/17 12:39 PM','Strings',1,NULL),(871,'public static void main(String[] args){\n\n        Date d = new Date();\n        DateFormat df = DateFormat.getDateInstance();\n        \n        System.out.println(df.format(d));\n        \n    }','Jul 28, 2017','Strings',1,NULL),(872,'What dateformat is this\n\n7/28/17',' public static void main(String[] args){\n        Date d = new Date();\n        DateFormat df = DateFormat.getDateInstance(DateFormat.SHORT);\n        \n        System.out.println(df.format(d));\n        \n    }','Strings',1,NULL),(873,'public static void main(String[] args){\n        Date d = new Date();\n        DateFormat df = DateFormat.getDateInstance(DateFormat.SHORT);\n        \n        String s = df.format(d);\n        \n        Date d2 = df.parse(s);\n    }','will not compile, ParseException must be caught or thrown','Strings',1,NULL),(874,'public static void main(String[] args){\n        Date d = new Date();\n        DateFormat df = DateFormat.getDateInstance(DateFormat.SHORT);\n        \n        String s = df.format(d);\n        \n        try{\n            Date d2 = df.parse(s);\n            System.out.println(\"parsed \"+d2);\n        } catch( ParseException e){\n            \n        }\n    }','parsedFri Jul 28 00:00:00 EDT 2017','Strings',1,NULL),(875,'public static void main(String[] args){\n        Date d = new Date();\n        DateFormat df = new DateFormat(DateFormat.SHORT);\n        \n        String s = df.format(d);\n        \n        try{\n            Date d2 = df.parse(s);\n            System.out.println(\"parsed \"+d2);\n        } catch( ParseException e){\n            \n        }\n    }','WNC dateformat is abstract cannot be instantiated ','Strings',1,NULL),(876,'try {\n            Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\");\n            PreparedStatement pst = conn.prepareStatement(\"Select * From employees limit 100\");\n            ResultSet rs = pst.executeQuery();\n            \n            Date d = new Date();\n            Calendar c = Calendar.getInstance();\n            c.setTime(d);\n            \n            DateFormat dateformat = DateFormat.getInstance();\n            Locale italian = new Locale(\"it\");\n            DateFormat italianformat = DateFormat.getInstance(DateFormat.FULL,italian);\n} catch(SQLException e){ }','The regular DF constructor doesn\'t take a style or Locale.\n\nGet a default date/time \nformatter that uses the SHORT style for both the date and the time.\n\nwith statements preparedstatements callablestatements:\n\n	executeQuery() returns a ResultSet\n	executeUpdate() returns an int\n	execute()  returns a boolean','Strings',1,NULL),(877,'public class Hello {\n    public static void main(String[] args){\n        DateFormat df = DateFormat.getDateInstance(DateFormat.FULL,Locale.KOREA);\n        Date now = new Date();\n        \n        System.out.println(df.format(now));\n        \n        df.setLocale(Locale.US);\n        \n        System.out.println(df.format(now));\n    }\n}','WNC you can only set a DateFormat and NumberFormat can only set\n local at the time of instantiation. There is not method to change locale\nafterward.','Strings',1,NULL),(878,'public class Hello {\n    public static void main(String[] args){\n        Locale loc1 = new Locale(\"pt\",\"BR\");\n        Locale loc2 = new Locale(\"da\",\"DK\");\n        Locale loc3 = new Locale(\"it\", \"IT\");\n        \n        System.out.println(loc1.getDisplayCountry());\n        System.out.println(loc2.getDisplayCountry());\n        System.out.println(loc3.getDisplayCountry());\n        \n        //display the countrys name in that language\n        \n        System.out.println(loc1.getDisplayCountry(loc1));\n        System.out.println(loc2.getDisplayCountry(loc2));\n        System.out.println(loc3.getDisplayCountry(loc3));\n    }\n}','Brazil\nDenmark\nItaly\nBrasil\nDanmark\nItalia','Strings',1,NULL),(879,'public class Hello {\n    public static void main(String[] args){\n        float f1 = 123.43535353f;\n        NumberFormat nf = NumberFormat.getInstance();\n        System.out.println(nf.getMaximumFractionDigits());\n        \n        System.out.println(nf.format(f1));\n        \n    }\n}','3\n123.435','Strings',1,NULL),(880,'public class Hello {\n    public static void main(String[] args){\n        float f1 = 123.43535353f;\n        NumberFormat nf = NumberFormat.getInstance();\n        System.out.println(nf.getMaximumFractionDigits());\n        \n        System.out.println(nf.format(f1));\n        \n        nf.setMaximumFractionDigits(5);\n        \n        System.out.println(nf.format(f1));\n        \n    }\n}','3\n123.435\n123.43536','Strings',1,NULL),(881,'public class Hello {\n    public static void main(String[] args){\n        float f1 = 123.43535353f;\n        NumberFormat nf = NumberFormat.getInstance();\n        \n        try{\n            System.out.println(nf.parse(\"345.3435\"));\n            nf.setParseIntegerOnly(true);\n            System.out.println(nf.parse(\"345.3435\"));\n        } catch(ParseException e){\n            \n        }\n    }\n}','345.3435\n345','Strings',1,NULL),(882,'public class Hello {\n    public static void main(String[] args){\n        float f1 = 123.43535353f;\n        NumberFormat nf = NumberFormat.getInstance();\n        NumberFormat nf2 = NumberFormat.getInstance(Locale.KOREA);\n        NumberFormat nf3 = NumberFormat.getCurrencyInstance();\n        NumberFormat nf4 = NumberFormat.getCurrencyInstance(Locale.KOREA);\n        \n        System.out.println(nf.format(f1));\n        System.out.println(nf2.format(f1));\n        System.out.println(nf3.format(f1));\n        System.out.println(nf4.format(f1));\n\n    }\n}','123.435\n123.435\n$123.44\n?123\n\ncould vary from maching to machine','Strings',1,NULL),(883,'public class Hello {\n    public static void main(String[] args){\n        Pattern p = Pattern.compile(\"ab\");\n        Matcher m = p.matcher(\"abakdnfab kekrls ab\");\n        \n        while(m.find()){\n            System.out.println(m.start());\n        }\n        \n    }\n}','0\n7\n17','Strings',1,NULL),(884,'public class Hello {\n    public static void main(String[] args){\n        Pattern p = Pattern.compile(\"\\\\d\");\n        Matcher m = p.matcher(\"The silly Dog89 ran for miles.56 Like a silly little puppy45\");\n        \n        while(m.find()){\n            System.out.println(m.start());\n        }\n        \n    }\n}','13\n14\n30\n31\n58\n59\n\n\\\\d looks for digits','Strings',1,NULL),(885,'first:\n    public static void main(String[] args){\n        Pattern p = Pattern.compile(\"\\\\d\");\n        Matcher m = p.matcher(\"The silly Dog ran for 89 miles.\");\n        \n        while(m.find()){\n            System.out.println(m.start());\n        }\n        \n    }\nsecond:\n	public static void main(String[] args){\n        Pattern p = Pattern.compile(\"\\\\D\");\n        Matcher m = p.matcher(\"The silly Dog ran for 89 miles.\");\n        \n        while(m.find()){\n            System.out.println(m.start());\n        }\n        \n    }\n','\\\\d looks for digits, \\\\D looks for nondigitis\nfirst:\n22\n23\n\nsecond:\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n24\n25\n26\n27\n28\n29\n30','Strings',1,NULL),(886,'regex metacharacter:\n\n\\s','a whitespace character \\t \\n \\f \\r','Strings',1,NULL),(887,'regex metacharacter:\n\n\\S','non white space','Strings',1,NULL),(888,'regex metacharacter:\n\n\\w word character\n\nmeaning what ?','a-z A-Z digits or _','Strings',1,NULL),(889,'regex metacharacter:\n\n\\W non word character\n\nmeaning what ?','everything besides a-z A-Z _ or digits','Strings',1,NULL),(890,'public static void main(String[] args){\n        Pattern p = Pattern.compile(\"\\\\s\");\n        Matcher m = p.matcher(\"The silly Dog ran for 89 miles.\");\n        \n        while(m.find()){\n            System.out.println(m.start());\n        }\n        \n    }','3\n9\n13\n17\n21\n24\n\nwhitespace characters','Strings',1,NULL),(891,'public static void main(String[] args){\n        Pattern p = Pattern.compile(\"\\\\S\");\n        Matcher m = p.matcher(\"The silly Dog ran for 89 miles.\");\n        \n        while(m.find()){\n            System.out.println(m.start());\n        }\n        \n    }','all the non white spaces:\n0\n1\n2\n4\n5\n6\n7\n8\n10\n11\n12\n14\n15\n16\n18\n19\n20\n22\n23\n25\n26\n27\n28\n29\n30','Strings',1,NULL),(892,'public static void main(String[] args){\n        Pattern p = Pattern.compile(\"\\\\w\");\n        Matcher m = p.matcher(\"The silly Dog ran for 89 miles.\");\n        \n        while(m.find()){\n            System.out.println(m.start());\n        }\n        \n    }','0   all the word characters similiar to \\\\S\n1\n2\n4\n5\n6\n7\n8\n10\n11\n12\n14\n15\n16\n18\n19\n20\n22\n23\n25\n26\n27\n28\n29','Strings',1,NULL),(893,'public static void main(String[] args){\n        Pattern p = Pattern.compile(\"\\\\W\");\n        Matcher m = p.matcher(\"The silly Dog ran for 89 miles.\");\n        \n        while(m.find()){\n            System.out.println(m.start());\n        }\n        \n    }','3  //non word character similar to \\\\S numbers are word characters\n9\n13\n17\n21\n24\n30','Strings',1,NULL),(894,'public class Hello {\n    public static void main(String[] args){\n        Pattern p = Pattern.compile(\"\\\\b\");\n        Matcher m = p.matcher(\"The silly Dog ran for 89 miles.\");\n        \n        while(m.find()){\n            System.out.println(m.start());\n        }\n        \n    }\n}','a word boundary, anytime there is a word character and a non word right next to\neach other.\nThere are invisible non word characters at the end and beginning of a string.\n\n0\n3\n4\n9\n10\n13\n14\n17\n18\n21\n22\n24\n25\n30','Strings',1,NULL),(895,'public class Hello {\n    public static void main(String[] args){\n        Pattern p = Pattern.compile(\"\\\\B\");\n        Matcher m = p.matcher(\"The silly Dog ran for 89 miles.\");\n        \n        while(m.find()){\n            System.out.println(m.start());\n        }\n        \n    }\n}','//non word boundary each of these is a case where there IS NO word boundary\nor two word characters are beside each other or two non words are beside each other\nreturns the position of the second character.\n\n1 \n2\n5\n6\n7\n8\n11\n12\n15\n16\n19\n20\n23\n26\n27\n28\n29\n31','Strings',1,NULL),(896,'public static void main(String[] args){\n        Pattern p = Pattern.compile(\"[soi]\");\n        Matcher m = p.matcher(\"The silly Dog ran for 89 miles.\");\n        \n        while(m.find()){\n            System.out.println(m.start());\n        }\n        \n    }','4\n5\n11\n19\n26\n29','Strings',1,NULL),(897,'public class Hello {\n    public static void main(String[] args){\n        Pattern p = Pattern.compile(\"[a-z]\");\n        Matcher m = p.matcher(\"The silly Dog ran for 89 miles.\");\n        \n        while(m.find()){\n            System.out.println(m.start());\n        }\n        \n    }\n}\n','1\n2\n4\n5\n6\n7\n8\n11\n12\n14\n15\n16\n18\n19\n20\n25\n26\n27\n28\n29','Strings',1,NULL),(898,'public class Hello {\n    public static void main(String[] args){\n        Pattern p = Pattern.compile(\"[a-cA-C]\");\n        Matcher m = p.matcher(\"The silly Dog ran for 89 miles.\");\n        \n        while(m.find()){\n            System.out.println(m.start());\n        }\n        \n    }\n}','15','Strings',1,NULL),(899,'public class Hello {\n    public static void main(String[] args){\n        Pattern p = Pattern.compile(\"a?\");\n        Matcher m = p.matcher(\"The silly Dog ran for at least 89 miles.I am tired he said\");\n        \n        while(m.find()){\n            System.out.println(m.group());\n        }\n        \n    }\n}','// the mistake here is that ? gives you \"ZERO OR ONE\" so if there is no a \nthere that still mathces!\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58','Strings',1,NULL),(900,'creaet a regex that finds a word composed of an \'a\' with any character next to it','public class Hello {\n    public static void main(String[] args){\n        Pattern p = Pattern.compile(\" a.\");\n        Matcher m = p.matcher(\"The silly Dog ran for at least 89 miles.I am tired he said\");\n        \n        while(m.find()){\n            System.out.println(m.start());\n            System.out.println(m.group());\n        }\n        \n    }\n}\n\n21\n at\n41\n am','Strings',1,NULL),(901,'public class Hello {\n    public static void main(String[] args){\n        Pattern p = Pattern.compile(\"a.\");\n        Matcher m = p.matcher(\"The silly Dog ran for at least 89 miles.I am tired he said\");\n        \n        while(m.find()){\n            System.out.println(m.start());\n            System.out.println(m.group());\n        }\n        \n    }\n}\n\n','Without the space at the beginning of the pattern you allow a then any character\nto but up against any other character if you wanted it to just be individual\nwords then you could add a space at the beginning or a whitespce character.\n15\nan\n22\nat\n27\nas\n42\nam\n55\nai','Strings',1,NULL),(902,'public class Hello {\n    public static void main(String[] args){\n        Pattern p = Pattern.compile(\"\\\\sa.\");\n        Matcher m = p.matcher(\"The silly Dog ran for at least 89 miles.I am tired he said\");\n        \n        while(m.find()){\n            System.out.println(m.start());\n            System.out.println(m.group());\n        }\n        \n    }\n}','21\n at\n41\n am','Strings',1,NULL),(903,'public class Hello {\n    public static void main(String[] args){\n        //five letter words\n        Pattern p = Pattern.compile(\"\\\\s.....\\\\s\");\n        Matcher m = p.matcher(\"A regular expression, specified as a string, must first be compiled into an instance of this class\");\n        \n        while(m.find()){\n            System.out.println(m.start());\n            System.out.println(m.group());\n        }\n        \n    }\n}','49\n first ','Strings',1,NULL),(904,'public class Hello {\n    public static void main(String[] dicks){\n      Path src = Paths.get(\"/home/maxbisesi/Documents/allfiles/copy.txt\");\n      Path srcParent = src.getParent();\n      System.out.println(srcParent);\n      \n    }\n\n}','/home/maxbisesi/Documents/allfiles\n\nNone of these methods throw an IOE','Input/Output',1,NULL),(905,' public static void main(String[] args){\n        //five letter words\n        Pattern p = Pattern.compile(\".*xx\");\n        Matcher m = p.matcher(\"yyxxxyxx\");\n        \n        while(m.find()){\n            System.out.println(m.start());\n            System.out.println(m.group());\n		  System.out.println(m.end());\n        }\n        \n      \n    }','0\nyyxxxyxx\n8\n\n* is greedy so it reads then entire source then works backward, until it finds\nthe rightmost match. ','Strings',1,NULL),(906,'public static void main(String[] args){\n        //five letter words\n        Pattern p = Pattern.compile(\".*y\");\n        Matcher m = p.matcher(\"yyxxxyxx\");\n        \n        while(m.find()){\n            System.out.println(m.start());\n            System.out.println(m.group());\n            System.out.println(m.end());\n        }\n        \n      \n    }','0\nyyxxxy\n6\n\ngreedy reads the whole source data first','Strings',1,NULL),(907,' public static void main(String[] args){\n        //five letter words\n        Pattern p = Pattern.compile(\"\\\\d*\");\n        Matcher m = p.matcher(\"yy4xx89xxye90g\");\n        \n        while(m.find()){\n            System.out.println(m.start()+\":_\"+m.group()+\"_\");\n        }\n        \n      \n    }','This pattern says its looking for zero or more digits, \nso at the positions other than 2 5 and 11 it does find 0 digits\n\n0:__\n1:__\n2:_4_\n3:__\n4:__\n5:_89_\n7:__\n8:__\n9:__\n10:__\n11:_90_\n13:__\n14:__\n\n','Strings',1,NULL),(908,'public static void main(String[] args){\n        //five letter words\n        Pattern p = Pattern.compile(\"a?\");\n        Matcher m = p.matcher(\"abaabbbaaabbaaa\");\n        \n        while(m.find()){\n            System.out.println(m.start()+\":_\"+m.group()+\"_:\"+m.end());\n        }\n        \n      \n    }','Greedy will allow zero length matches, proven by the start and end indexs being \nthe same.\n\n0:_a_:1\n1:__:1\n2:_a_:3\n3:_a_:4\n4:__:4\n5:__:5\n6:__:6\n7:_a_:8\n8:_a_:9\n9:_a_:10\n10:__:10\n11:__:11\n12:_a_:13\n13:_a_:14\n14:_a_:15\n15:__:15','Strings',1,NULL),(909,'public class Hello {\n    public static void main(String[] args){\n        String[] tokens = \"hello my darling\".split(\" \");\n        \n        for(String s : tokens){\n            System.out.println(s);\n        }\n    }\n\n}','hello\nmy\ndarling','Strings',1,NULL),(910,'public static void main(String[] args){\n        String[] tokens = \"hello5my5darling\".split(\"\\\\d\");\n        \n        for(String s : tokens){\n            System.out.println(s);\n        }\n    }','hello\nmy\ndarling','Strings',1,NULL),(911,'public static void main(String[] args){\n        String[] tokens = \"bigibhjvu louf kvciy\".split(\"\");\n        \n        for(String s : tokens){\n            System.out.println(s);\n        }\n    }','b\ni\ng\ni\nb\nh\nj\nv\nu\n \nl\no\nu\nf\n \nk\nv\nc\ni\ny','Strings',1,NULL),(912,'what is scanners default delemiter','whitespace','Strings',1,NULL),(913,'public static void main(String[] args){\n        Pattern p = Pattern.compile(\"\\\\d*\");\n        Matcher m = p.matcher(\"ab34ef\");\n        while(m.find()){\n            System.out.print(m.start() + m.group());\n        }\n    }','01234456','Strings',1,NULL),(914,'public static void main(String[] args){\n        Pattern p = Pattern.compile(\"\\\\d*\");\n        Matcher m = p.matcher(\"ab34ef8hk12345\");\n        while(m.find()){\n            System.out.print(m.start() + m.group());\n        }\n    }','0123445687891234514','Strings',1,NULL),(915,'public class Hello {\n    public static void main(String[] args){\n        ResourceBundle rb = ResourceBundle.getBundle(\"NickNames\");\n        System.out.println(rb.getString(\"Max Bisesi\"));\n        \n    }\n}\n\nclass NickNames extends ListResourceBundle {\n    protected Object[][] getContents(){\n        return new Object[][]{{\"hello\",\"from java\"},{\"Max Bisesi\",\"Big Bad Max\"},{\"Garret Gieske\", \"gieske\"}};\n    }\n}','\n\n\n\n\n\n\n\n\n\n\nException in thread \"main\" java.util.MissingResourceException: \nCan\'t find bundle for base name NickNames, locale en_US\n\n\n\n\n\n\n\n\n\n\n\n','Locale',1,NULL),(916,'public static void main(String[] args){\n       Locale initial = Locale.getDefault();\n        System.out.println(initial);\n        \n        Locale.setDefault(Locale.GERMANY);\n        System.out.println(Locale.getDefault());\n        \n    }','en_US\nde_DE','Locale',1,NULL),(917,'two ways to get a ResourceBundle: ?','ResourceBundle.getBundle(basename);\nResourceBundle.getBundle(basename, locale);\n\nfirst uses default locale','Locale',1,NULL),(918,'Java chooses the most specific resource bundle it can while while giving\npreference to java ListResourceBundle','got it !','Locale',1,NULL),(919,'request french canadian resource bundle\n\nLocale loc = new Locale(\"fr\",\"CA\");\nResourceBundle rb = ResourceBundle.getBundle(\"RB\",loc);\n\nhow will java search for that bundle ?','RB_fr_CA.java // a java class mathcing excactly\nRB_fr_CA.properties // then it looks for exectaly matching property files\n\nRB_fr.java\nRB_fr.properites // if it cant find both it will look for the Language\n\n\nRB_en_US.java\nRB_en_US.poperties   // use the default locale instead\n\nRB_en.java\nRB_en.properties   //just llook for the default language\n\nRB.java\nRB.properties    //try default Bundle name','Locale',1,NULL),(920,'What happens if java cant find a resourceBundle','missingresourceexception','Locale',1,NULL),(921,'ResourceBundles can inherit properties from parents\n\nRB_en.properties\n	ride.in=Take a ride in\n\nRB_en_US.properties\n	elevator=elevator\n\nRB_en_UK.properties\n	elevator=lift\n\nLocale locale = new Locale(\"en\",\"UK\");\nResourceBundle rb = ResourceBundle.getBundle(\"RB\",locale);\nsout(rb.getString(\"ride.in\") + rb.getString(\"elevator\"));','Take a ride in the lift','Locale',1,NULL),(922,'public static void main(String[] args){\n      ResourceBundle rb = ResourceBundle.getBundle(\"Flag\",new Locale(\"en_CA\"));\n        System.out.println(rb.getString(\"key\"));\n        \n    }\n\nthere are no resourcebundles loaded','MissingResourceException','Locale',1,NULL),(923,'public static void main(String[] args){\n      ResourceBundle rb = ResourceBundle.getBundle(\"Flag\",new Locale(\"en_CA\"));\n        System.out.println(rb.getString(\"key\"));\n        \n    }\n\ndefault locale is Italian if there is only one resource bundle on the classpath\nhow will java search for that bundle based on the above ?','Flag_en_CA.properties\nFlag_en.java\nFlag_en.properties\nFlag.properties','Locale',1,NULL),(924,'public static void main(String[] args){\n      ResourceBundle rb = ResourceBundle.getBundle(\"Flag\",new Locale(\"en_CA\"));\n        System.out.println(rb.getString(\"key\"));\n        \n    }\n\nwhich will be chosen ?\n\nFlag_fr_CA.properties\nFlag_en.properties\nFlag_CA.properties ','Flag_en.properties\n\nFlag_fr_CA.properties the language does not match\n\nFlag_CA.properties, CA is not a valid lang code','Locale',1,NULL),(925,'public static void main(String[] args){\n      Pattern p = Pattern.compile(\"\\\\b\");\n      Matcher m = p.matcher(\"^23 *$76 bc\");\n      while(m.find()){\n          System.out.println(m.start()+\" \");\n      }\n        \n    }','1 \n3 \n6 \n8 \n9 \n11 \n\n\\\\b says that the number reported is the end of a boundary between a wordcharacter\nand a non word character,\n\nbetween 0 and 1 is a boundary between a word and a non word.\n\nimagine the end and beginning of a string is an invisible non word.\nposition 0 was not returned here because ^ is non word and that against the \ninvisble non word is not a boundary','Locale',1,NULL),(926,'  public static void main(String[] args){\n      Pattern p = Pattern.compile(\"\\\\b\");\n      Matcher m = p.matcher(\"#ab de#\");\n      while(m.find()){\n          System.out.println(m.start()+\" \");\n      }\n        \n    }','1\n3\n4\n6','Locale',1,NULL),(927,' public static void main(String[] args){\n      Pattern p = Pattern.compile(\"\\\\B\");\n      Matcher m = p.matcher(\"#ab de#\");\n      while(m.find()){\n          System.out.println(m.start()+\" \");\n      }\n        \n    }','0 \n2 \n5 \n7\n\nif there is a non word boundary between the last character and \nthe invible end of string non word boundary then start will give \nthe very last character index, where normally it would give the second \nindex of the two characters creating the non word boudary. ','Strings',1,NULL),(928,'public static void main(String[] args){\n      Pattern p = Pattern.compile(\"\\\\b\");\n      Matcher m = p.matcher(\"abci####r\");\n      while(m.find()){\n          System.out.println(m.start()+\" \");\n      }\n        \n    }','0 \n4 \n8 \n9','Locale',1,NULL),(929,'when searched using \\\\b what string would give the result: 2467 ?','something like this ^^rt##r\n\nthe output is determined by the difference between a boundary adn a word boundary\n\n','Strings',1,NULL),(930,'when searched with \\\\B what string could give 1234567 ? ','^^^^^^^\n\nimagine Strings contain non word characters at the beginning and end of\neach string. Here, \\\\B is saying that there is NOT a word boundary between\nthe imaginary non word character that represents the beginning of the string\nand the first ^ symbol because they are both non words.\n\nThen there is NOT a word boundary between the first and subsequent ^ symbols\nbecause they are all non words. ','Locale',1,NULL),(931,'public static void main(String[] args){\n        String[] chunks = \"1 a2 b 3 c4d 5e\".split(\"\\\\d\");\n        \n        for(String s : chunks){\n            System.out.println(\".\"+s+\".\");\n        }\n        \n    }','..\n. a.\n. b .\n. c.\n.d .\n.e.\n\nif the first character in the String is a delimter the first array\nelement will be an empty token','Locale',1,NULL),(932,'if the first character in the String is a delimter the first array\nelement will be an empty token','got it ','Locale',1,NULL),(933,'Train_en_US.properties: train=subway\nTrain_en_UK.properties: train=undergroudn\nTrain_en_.properties: ride = ride;\n\npublic class Choochoo {\n	public static void main(String[] args) {\n		Locale.setDefault(new Locale(\"en\",\"US\"));\n		ResourceBundle rb = \n	ResourceBundle.getBundle(\"Train\",new Locale(\"en\",\"US\"));\n		sout( rb.getString(\"ride\")+\" \"+rb.getString(\"train\"));\n	}\n}\n\nwhich change can you make independently to change the output to \"ride underground\"\n\nchange line 1 to Locale.setDefault(new Locale(\"en\",\"UK));\nAdd train=underground to Train_en.porperties\nchange line5 to new Locale(\"en\",\"UK\"));\nDelete Train_en_US.properties','Changed line5 to new Locale(\"en\",\"UK\")','Locale',1,NULL),(934,'when using StringBuilder if you append past the current capacity it\ncan be automatically increased.\n\nif you insert past it you will receive an exception','go it ','Locale',1,NULL),(935,'public static void main(String[] args){\n        StringBuilder sb = new StringBuilder(8);\n        System.out.println(sb.length() + \" \" + sb + \" \");\n        sb.insert(0,\"abcdef\");\n        sb.append(\"789\");\n        System.out.println(sb.length() + \" \" + sb);   \n    }','0  \n9 abcdef789','Locale',1,NULL),(936,'public static void main(String[] args){\n        StringBuilder sb = new StringBuilder(8);\n        System.out.println(sb.length() + \" \" + sb + \" \");\n        sb.insert(0,\"abcdefghij\");\n        System.out.println(sb.length() + \" \" + sb);   \n    }','0  \n10 abcdefghij\n\nthe string builders capacity has been increased automatically','General',1,NULL),(937,'public class Hello {\n    public static void main(String[] args){\n        ResourceBundle rb = ResourceBundle.getBundle(\"NickNames\",Locale.getDefault());\n        Object ob = rb.getInteger(\"123\");\n        \n    }\n}\n\nclass NickNames extends ListResourceBundle {\n    protected Object[][] getContents(){\n        return new Object[][]{{\"hello\",\"from java\"},{\"Max Bisesi\",\"Big Bad Max\"},{\"Garret Gieske\", \"gieske\"},{\"123\",678}};\n    }\n}','will not compile, there is no method getInteger();','General',1,NULL),(938,'public class Hello {\n    public static void main(String[] args){\n        ResourceBundle rb = ResourceBundle.getBundle(\"Hello.NickNames\",Locale.getDefault());\n        Object ob = rb.getString(\"123\");\n        \n    }\n}\n\nclass NickNames extends ListResourceBundle {\n    protected Object[][] getContents(){\n        return new Object[][]{{\"hello\",\"from java\"},{\"Max Bisesi\",\"Big Bad Max\"},{\"Garret Gieske\", \"gieske\"},{\"123\",678}};\n    }\n}','ClassCastException\n\nyoou can either use getString to get a string or getObject to get anything else\nbut you cannot use getString to get an object','General',1,NULL),(939,'public static void main(Sa) {\n	String s1 = \"abc\";\n	String s2 = s1;\n	s1 += \"d\";\n	sout(s1+\" \"+s2+\" \"+ (s1==s2));\n	\n	StringBuffer sb1 = new StringBuffer(\"abc\");\n	StringBuffer sb2 = sb1;\n	sb1.append(\"d\");\n	sout(sb1+ \" \" + sb2 + \" \" + (sb1==sb2));\n}','abcd abc false\nabcd abcd true\n\nstring objects are immutable references are mutable\n\nSo here, when the s1+=\"d\" executes. The String \"abc\" was once referenced\nby s1 but it not longer is. Now it is referenced by s2. a New String object\nis created abcd and s1 is reassinged to reference that.','General',1,NULL),(940,'public class Hello {\n    public static void main(String[] args){\n       String s = \" maxy \";\n       String x = \" denny \";\n       s.trim();\n       x.trim();\n       String y = s+x;\n       \n        System.out.println(y);\n    }\n}',' maxy  denny \n\nstrings are immutable, when s.trim() is executed a new String is created\nand a reference to it is returned then immediately lost. s and x remain\npointing to the strings \" maxy \" and \" denny \".\n','General',1,NULL),(941,'String s = \"987.123456\";\ndouble d = 987.123456d;\nNumberFormat nf = NumberFormat.getInstance();\nnf.setMaximumFractionDigits(5);\nsout(nf.format(d) + \" \");\ntry {\n	sout(nf.parse(s));\n} catch(ParseException e){ }','987.12346 // rounds doesn\'t truncate\n987.123456 // setMaxFracDigs applies to formating but not parsing','General',1,NULL),(942,'public static void main(String[] args){\n        Pattern p = Pattern.compile(\"\\\\d+\");\n        Matcher m = p.matcher(\"ab2c4d67\");\n        int count = 0;\n        while(m.find()){\n            count++;\n        }\n        System.out.println(count);\n    }','3\n\n\\\\d looks for digits\n\n+ says one or more ','Strings',1,NULL),(943,' public static void main(String[] args){\n        Pattern p = Pattern.compile(\"\\\\w+\");\n        Matcher m = p.matcher(\"ab2c4d67\");\n        int count = 0;\n        while(m.find()){\n            count++;\n        }\n        System.out.println(count);\n    }','this one is confusing but remember + is greedy\n\nits not a series of word characters in this case the whole damn thing is \none word character','Strings',1,NULL),(944,'public static void main(String[] args){\n        Pattern p = Pattern.compile(\"\\\\S+\");\n        Matcher m = p.matcher(\"ab2c4d67\");\n        int count = 0;\n        while(m.find()){\n            count++;\n        }\n        System.out.println(count);\n    }','1\n\nthe whole string is one long non whitespace character and + is greedy\nso it took the whole thing','Strings',1,NULL),(945,' public static void main(String[] args){\n        Pattern p = Pattern.compile(\"\\\\d+\");\n        Matcher m = p.matcher(\"78254467\");\n        int count = 0;\n        while(m.find()){\n            count++;\n        }\n        System.out.println(count);\n    }','1\n\n+ is greedy so this whole number is one big digit, greedy took the whole \nthing','Strings',1,NULL),(946,'public static void main(String[] args){\n        Pattern p = Pattern.compile(\"\\\\W+\");\n        Matcher m = p.matcher(\"$%^&*\");\n        int count = 0;\n        while(m.find()){\n            count++;\n        }\n        System.out.println(count);\n    }','1\n\nthe whole string is one big non word character so the greedy + took the whole\nthing','Strings',1,NULL),(947,'psvm(Sa){\n	String input = \"1 2 a 3 45 6\";	\n	Scanner sc = new Scanner(input);\n	int x = 0;\n	do {\n		x = sc.nextInt();\n		sout(x);	\n	} while(x!=0);\n}','1 2 followed by an exception','General',1,NULL),(948,'Glob rules',' When the syntax is \"glob\" then the String representation of the path is matched using a limited pattern language that resembles regular expressions but with a simpler syntax. For example:\n\n    *.java 	Matches a path that represents a file name ending in .java\n    *.* 	Matches file names containing a dot\n    *.{java,class} 	Matches file names ending with .java or .class\n    foo.? 	Matches file names starting with foo. and a single character extension\n    /home/*/* 	Matches /home/gus/data on UNIX platforms\n    /home/** 	Matches /home/gus and /home/gus/data on UNIX platforms\n    C:\\\\* 	Matches C:\\foo and C:\\bar on the Windows platform (note that the backslash is escaped; as a string literal in the Java Language the pattern would be \"C:\\\\\\\\*\")\n\nThe following rules are used to interpret glob patterns:\n\n    The * character matches zero or more characters of a name component without crossing directory boundaries.\n\n    The ** characters matches zero or more characters crossing directory boundaries.\n\n    The ? character matches exactly one character of a name component.\n\n    The backslash character (\\) is used to escape characters that would otherwise be interpreted as special characters. The expression \\\\ matches a single backslash and \"\\{\" matches a left brace for example.\n\n    The [ ] characters are a bracket expression that match a single character of a name component out of a set of characters. For example, [abc] matches \"a\", \"b\", or \"c\". The hyphen (-) may be used to specify a range so [a-z] specifies a range that matches from \"a\" to \"z\" (inclusive). These forms can be mixed so [abce-g] matches \"a\", \"b\", \"c\", \"e\", \"f\" or \"g\". If the character after the [ is a ! then it is used for negation so [!a-c] matches any character except \"a\", \"b\", or \"c\".\n\n    Within a bracket expression the *, ? and \\ characters match themselves. The (-) character matches itself if it is the first character within the brackets, or the first character after the ! if negating.\n\n    The { } characters are a group of subpatterns, where the group matches if any subpattern in the group matches. The \",\" character is used to separate the subpatterns. Groups cannot be nested.\n\n    Leading period/dot characters in file name are treated as regular characters in match operations. For example, the \"*\" glob pattern matches file name \".login\". The Files.isHidden(java.nio.file.Path) method may be used to test whether a file is considered hidden.\n\n    All other characters match themselves in an implementation dependent manner. This includes characters representing any name-separators.\n\n    The matching of root components is highly implementation-dependent and is not specified.\n\nWhen the syntax is \"regex\" then the pattern component is a regular expression as defined by the Pattern class.\n\nFor both the glob and regex syntaxes, the matching details, such as whether the matching is case sensitive, are implementation-dependent and therefore not specified.','Strings',1,NULL),(949,'public class Hello {\n    public static void main(String[] args) {\n        PathMatcher matcher = FileSystems.getDefault().getPathMatcher(\"*\");\n        Path p1 = Paths.get(\"One.java\");\n        \n        System.out.println(matcher.matches(p1));\n\n    }\n\n}','Exception in thread \"main\" java.lang.IllegalArgumentException\n\ngetPathMatcher() argument must take the form:\n\n	syntax:pattern\n\nspecify glob or regex ','Strings',1,NULL),(950,'public class Hello {\n    public static void main(String[] args) {\n        PathMatcher matcher = FileSystems.getDefault().getPathMatcher(\"glob: *\");\n        Path p1 = Paths.get(\"One.java\");\n        \n        System.out.println(matcher.matches(p1));\n\n    }\n\n}','false, \nthe space after \'glob:\' matters. \n\nto give expected behavior take that space away.','Strings',1,NULL),(951,'public class Hello {\n    public static void main(String[] args) {\n        PathMatcher matcher = FileSystems.getDefault().getPathMatcher(\"glob:*\");\n        Path p1 = Paths.get(\"One.java\");\n        \n        System.out.println(matcher.matches(p1));\n\n    }\n\n}','true,\n\nin glob * means any string inside directory bounds','Strings',1,NULL),(952,'public class Hello {\n    public static void main(String[] args) {\n        PathMatcher matcher = FileSystems.getDefault().getPathMatcher(\"glob:\");\n        Path p1 = Paths.get(\"One.java\");\n        Path p2 = Paths.get(\"/home/Files/two.txt\");\n        Path p3 = Paths.get(\"/home/Pictures/amy1.pic\");\n        \n        System.out.println(matcher.matches(p1));\n        System.out.println(matcher.matches(p2));\n        System.out.println(matcher.matches(p3));\n\n    }\n\n}\ncreate a glob to match each of these paths','p1 could be:\n\"glob:*\" \"glob:**\" \"glob:*.{java,class}\" \"glob:One.????\"\n\n ','Strings',1,NULL),(953,'public class Hello {\n    public static void main(String[] args) {\n        PathMatcher matcher = FileSystems.getDefault().getPathMatcher(\"glob:*{*txt,*pic,/dir}\");\n        Path p1 = Paths.get(\"files.*txt\");\n        Path p2 = Paths.get(\"pictures.*pic\");\n        Path p3 = Paths.get(\"home/dir\");\n        \n        System.out.println(matcher.matches(p1));\n        System.out.println(matcher.matches(p2));\n        System.out.println(matcher.matches(p3));\n    }\n\n}','true\ntrue\ntrue\n\nin a bracketed expression * ? and / match themselves\n\n* matches anything within a directory boundary','Strings',1,NULL),(954,'public class Hello {\n    public static void main(String[] args) {\n        PathMatcher matcher = FileSystems.getDefault().getPathMatcher(\"glob:*{*txt,*pic,/dir}\");\n        Path p1 = Paths.get(\"home/files.*txt\");\n        Path p2 = Paths.get(\"documents/pictures.*pic\");\n        Path p3 = Paths.get(\"home/dir\");\n        \n        System.out.println(matcher.matches(p1));\n        System.out.println(matcher.matches(p2));\n        System.out.println(matcher.matches(p3));\n    }\n\n}','false \nfalse\ntrue\n\n* doesn\'t work accross directory bounds ','Strings',1,NULL),(955,'public class Hello {\n    public static void main(String[] args) {\n        PathMatcher matcher = FileSystems.getPathMatcher(\"glob:*{*txt,*pic,/dir}\");\n        Path p1 = Paths.get(\"home/files.*txt\");\n        Path p2 = Paths.get(\"documents/pictures.*pic\");\n        Path p3 = Paths.get(\"home/dir\");\n        \n        System.out.println(matcher.matches(p1));\n        System.out.println(matcher.matches(p2));\n        System.out.println(matcher.matches(p3));\n    }\n\n}','will not compile the proper syntax is:\n\n	FileSystems.getDefault().getPathMatcher()','Strings',1,NULL),(956,'public class Hello {\n    public static void main(String[] args) {\n        PathMatcher matcher = FileSystems.getDefault().getPathMatcher(\"regex:.*\");\n        Path p1 = Paths.get(\"home/files.*txt\");\n        Path p2 = Paths.get(\"documents/pictures.*pic\");\n        Path p3 = Paths.get(\"home/dir\");\n        \n        System.out.println(matcher.matches(p1));\n        System.out.println(matcher.matches(p2));\n        System.out.println(matcher.matches(p3));\n    }\n\n}','you can also do this to use regex instead of glob.\n\nhere they would all say \'true\'','Strings',1,NULL),(957,'public class Hello {\n	private int size = 7;\n	private static int length = 3;\n	public static void main(String[] args) {\n		new Hello().go();\n	}\n	void go(){\n		int size = 5;\n                 System.out.println(new Gazer().adder());\n                 \n                 class Gazer {\n                     private int size = 6;\n                      int adder() { return size * length; }\n                }\n	}\n	\n}','will not compile, \n\nGazer is declared after it is used in a method,thats not allowed move it to before','Strings',1,NULL),(958,'public class Hello {\n	private int size = 7;\n	private static int length = 3;\n	public static void main(String[] args) {\n		new Hello().go();\n	}\n	void go(){\n		int size = 5;\n                class Gazer {\n                      int adder() { return size * length; }\n                }\n                 System.out.println(new Gazer().adder());\n	}\n}','WNC,  \n\nlocal variable size is accessed from within inner class needs to be final,\n\n\n	','Strings',1,NULL),(959,'public class Hello {\n	private int size = 7;\n	private static int length = 3;\n	public static void main(String[] args) {\n		new Hello().go();\n	}\n	void go(){\n                class Gazer {\n                      int adder() { return size * length; }\n                }\n                 System.out.println(new Gazer().adder());\n	}\n}','21\n\nnothing wrong here, instances can access statics just not the other way around!','Inner Classes',1,NULL),(960,'public class Hello<T> {\n    \n    public static void main(String[] args){\n        \n        Dog d = new Dog();\n        \n        ArrayList<?> c = makeArrayList(new Animal());\n        \n\n    } \n    public static <G super Dog> ArrayList<G> makeArrayList(G g){\n        ArrayList<G> genlist = new ArrayList<>();\n        genlist.add(g);\n        return genlist;\n        \n    }\n}\n\nclass Animal{}\nclass Dog extends Animal{}','WNC\n\nsuper to bound a named type parameter (e.g. <S super T>) as opposed to a wildcard (e.g. <? super T>) is ILLEGAL simply because even if it\'s allowed, it wouldn\'t do what you\'d hoped it would do, because since Object is the ultimate super of all reference types, and everything is an Object, in effect there is no bound.\n\nIn your specific example, since any array of reference type is an Object[] (by Java array covariance), it can therefore be used as an argument to <S super T> S[] toArray(S[] a) (if such bound is legal) at compile-time, and it wouldn\'t prevent ArrayStoreException at run-time.\n\nWhat you\'re trying to propose is that given:\n\nList<Integer> integerList;\n\nand given this hypothetical super bound on toArray:\n\n<S super T> S[] toArray(S[] a) // hypothetical! currently illegal in Java\n\nthe compiler should only allow the following to compile:\n\nintegerList.toArray(new Integer[0]) // works fine!\nintegerList.toArray(new Number[0])  // works fine!\nintegerList.toArray(new Object[0])  // works fine!\n\nand no other array type arguments (since Integer only has those 3 types as super). That is, you\'re trying to prevent this from compiling:\n\nintegerList.toArray(new String[0])  // trying to prevent this from compiling\n\nbecause, by your argument, String is not a super of Integer. However, Object is a super of Integer, and a String[] is an Object[], so the compiler still would let the above compile, even if hypothetically you can do <S super T>!\n\nSo the following would still compile (just as the way they are right now), and ArrayStoreException at run-time could not be prevented by any compile-time checking using generic type bounds:\n\nintegerList.toArray(new String[0])  // compiles fine!\n// throws ArrayStoreException at run-time\n\nGenerics and arrays don\'t mix, and this is one of the many places where it shows.\nA non-array example\n\nAgain, let\'s say that you have this generic method declaration:\n\n<T super Integer> void add(T number) // hypothetical! currently illegal in Java\n\nAnd you have these variable declarations:\n\nInteger anInteger\nNumber aNumber\nObject anObject\nString aString\n\nYour intention with <T super Integer> (if it\'s legal) is that it should allow add(anInteger), and add(aNumber), and of course add(anObject), but NOT add(aString). Well, String is an Object, so add(aString) would still compile anyway.','Generics',1,NULL),(961,'package xcom;\npublic class Stuff{\n	public static int MY_COSTANT = 5;\n	public static int dosStuff(int x) { return (x++)*x; }\n}\n\nimport static xcom.Stuff;\nimport static java.lang.System;\nclass User {\n	public static void mian(SA){\n		new User().go()\n	}\n	void go(){\n			out.println(doStuff(MY_CONSTANT);\n	}\n}','will not compile to import a static member an import sattemten must say \nimport static wiht either a wildcard or excplicity the member to be imported','General',1,NULL),(962,'public class Hello {\n    \n    public static void main(String[] args){\n        Path file = Paths.get(\"~/Public/Data\");\n        FileSearcher fs = new FileSearcher(file,\"\\\\b\\\\W\\\\w+\");\n        ExecutorService es = Executors.newCachedThreadPool();\n        HashMap<Integer,String> searchresults = es.submit(fs);\n        System.out.println(\"We\'re wating on your search results\");\n        Future<HashMap<Integer,String>> futuresearch;\n        \n        try{\n            //HashMap<Integer,String> searchresults = futuresearch.get();\n            searchresults = futuresearch.get();\n            if(searchresults == null){\n                System.out.println(\"There were no results bro\");\n                System.exit(0);\n            }\n            \n        }catch(ExecutionException | InterruptedException e){\n            \n        }\n    }\n}\n\nclass FileSearcher implements Callable<HashMap<Integer,String>> {\n    private Path fileToLoad;\n    private String regex;\n    public FileSearcher(Path file,String reg){\n        fileToLoad = file;\n        regex = reg;\n    }\n    \n    public HashMap<Integer,String> call() throws IOException{\n        int linenum = 0;\n        HashMap<Integer,String> map = new HashMap<>();\n        BufferedReader br = new BufferedReader(new FileReader(fileToLoad.toFile()));\n        Pattern p = Pattern.compile(regex);\n        Matcher m;\n        String line;\n        while((line = br.readLine()) != null){\n            map.put(++linenum,line);\n        }\n        return map;\n    }\n}','WNC,\n\nsubmitting a Callable to an ExecutorService gets you a Future of the type \nreturned by the call(), then you get that result from the future with \nget() wich can block.','Executors',1,NULL),(963,'class Nearly {\n	String value;\n	public Nearly(String v) { value = v; }\n	public int hashCode() { return 1; }\n	public boolean equals(Nearly n){\n		if(value.charAt(0) == n.value.charAt(0)) return true;\n		return false;\n	}\n	psvm(sa){	\n		Nearly n1 = new Nearly(\"aaa\");\n		Nearly n2 = new Nearly(\"aaa\");\n		String s = \"-\";\n		if(n1.equals(n2)) s += \"1\";\n		if(n1 == n2) s += \"2\";\n		Set<Nearly> set = new HashSet<Nearly>();\n		set.add(n1);	\n		set.add(n2);\n		sout( s + set.size() );\n	}\n}','-12\n\nNearly does not properly override equals(Object o).\n\nSo by nearly\'s wrongly implemented equals() they are equal so you get -1\n\nbut Set knows the true equals to use and here it cant find it so it uses\nthe default equal which states that all objects are different and allows in\ntwo identicle objects. ','OOP',1,NULL),(964,'x = 0;\nif(x1.hashCode() != x2.hashCode() ) x = x +1;\nif(x3.equals(x4) == false) x = x + 10;\nif(x5.equals(x6) == true) x = x + 100;\nif(x7.hashCode() == x8.hashCode() ) x = x + 1000;\nsout( \"x = \" + x);\n\nif the output is x = 1111 what has to always be true ?\n\nx2.equals(x1) == true\nx3.hashCode() != x4.hashCode()\nx5.hashCode() == x6.hashCode()\nx8.equals(x7) == true','x5.hashCode() == x6.hashCode()\n\nif the hashcode values are not equal the two objects must not be equal\n\nif equals() is not true there is not guarentee of results from hashcode\n\nhashcode will often return equals values even if the two objects are not equal','OOP',1,NULL),(965,'if the hashcode values are not equal the two objects must not be equal','got it','OOP',1,NULL),(966,'import static statements must import explicitly the members ','','OOP',1,NULL),(967,'class Sortof {\n	String name;\n	int bal;\n	String code;\n	short rate;\n	public int hashCode() {\n		return (code.length() * bal);\n	}\n	public boolean equals(Object o){\n		//insert here\n	}\n}\n\nhow can you fullfill the equals and hashcode contracts for this class ?\n','return ((Sortof)o).code.length * ((Sortof)o).bal == this.code.length * this.bal;\n\nreturn ((Sortof)o).code.length * ((Sortof)o).bal * ((Sortof)o).rate == this.code.length * this.bal * this.rate;\n\n\nthe equals algorithm must be at least as precise as hashcode at determining\nwhat is \"meaningfully equivalent\" ','OOP',1,NULL),(968,'public class Hello{\n    public static void main(String[] args){\n        Bango b1 = new Bango();\n        Bango b2 = new Bongo();\n        Bango b3 = new Bingo();\n        \n        Bongo b4 = b2;\n        Bongo b5 = (Bongo)b2;\n        Bango b6 = b3;\n        Bango b7 = (Bango) b3;\n        Bingo b8 = b3;\n        Bingo b9 = (Bingo) b3;\n        Bango b10 = (Bongo) b3;\n    \n    }\n}\n\nclass Bango { }\nclass Bongo extends Bango { }\nclass Bingo extends Bongo { }\n\nwhich wont compile ? ','b4 and b8','OOP',1,NULL),(969,'class Clojure extends FP {\n	boolean typed;\n	public static void main(String[] args){\n		Clojure c = new Clojure();\n		c.monad();\n	}\n	void mondad() {\n		sout(\"foo\");\n	}\n}\n\nclass FP {\n	String name = \"basic\";\n	protected FP(String s){ name = s; }\n}','WILL NOT COMPILE','OOP',1,NULL),(970,'class AlternateFuel {\n	int getRating() { return 42; }\n	static int getRating2() { return 43; }\n}\nclass Bio extends AlternateFuel {\n	psvm(){\n		new Bio().go();\n		sout( super.getRating2() );\n	}\n	void go() {\n		sout( super.getRating() );\n	}\n}','Will not compile only instance methods can be overriden and calls to super \nare only for obverridne methods. ','OOP',1,NULL),(971,'class Alpha { int over = 1; }\nclass Beta extends Alpha { int over = 2; }\nclass Gamma extends Beta {\n	int over = 3;\n	public static void main(SA){\n		new Gamma().go();\n	}\n\n	void go() {	\n		Beta b = new Gamma();\n		Alpha a = new Gamma();\n		sout( super.over+\" \"+b.over+\" \"+a.over );\n	}\n}','2 2 1\n\ninstance variables are not overriden, the variable used is related to \nthe reference type. \n\nsuper can be used to access super class instance variables','OOP',1,NULL),(972,'class Programmer {\n	Programmer debug(){ return this; }\n}\n\nclass SCJP extends Programmer {\n	//insert here\n}\n\nProgrammer debug() { return this; }\nSCJP debug() { return this; }\n\nint debug(int x) { return 1; }\nObject debug(String s){ return this; }','two legal overrides, one a covariant return\n\ntwo legal overloads ','OOP',1,NULL),(973,'class Programmer {\n	Programmer debug(){ return this; }\n}\n\nclass SCJP extends Programmer {\n	Object debug(String s){ return this; }\n}\n\n','legal overload\n\nif it were just:\n\nObject debug() that would be an overload and that would not compile because overloads cannot change the return type, unless it is a subclass. \n\noverloads can return a different return type,\n\n','OOP',1,NULL),(974,'public class Hello{\n    public static void main(String[] args){\n        Short s = null;\n        \n        boolean b = (s instanceof String);\n    \n    }\n}','WNC, they have to be in the same inheritance tree','OOP',1,NULL),(975,'Class Dog follows the equals and hashcode contract, x and y are reference variable\nto two Dog objects which are true?\n\nif x.equals(y) is true then x.hashCode() == y.hashCode() may be false\n','false\n\nif two objects are equal, their hashCodes must be equal\n\nif two objects are not equal, their hashCodes must not be equal. ','OOP',1,NULL),(976,'join() throws InterruptedException','got it','Threads',1,NULL),(977,'public class Hello{\n    public static void main(String[] args){\n        Pattern p = Pattern.compile(\"\\\\W\");\n        Matcher m = p.matcher(\"565757 43353535\");\n        \n        while(m.find()){\n            System.out.println(m.start());\n        }\n        \n    }\n}','6','Strings',1,NULL),(978,'YOU CANT USE SUPER WHEN DEFINING A GENERIC CLASS','got it','Generics',1,NULL),(979,'class E implements Closeable { public void close() throws Exception {}}','WNC close() throws IOEXception, cannot throw new or broader checked exceptions','Collections',1,NULL),(980,'What methods are defined in the thread class ?','start() and run()','Threads',1,NULL),(981,'Both wait() and notify() must be called from a synchronized context\n\nthe wait() method is overloaded to accept a duration','got it','Threads',1,NULL),(982,'if a class has synchronized code multiple threads can still access the unsynchronized\ncode\n\nwhen a thread invokes wait() it releases its locks','got it','Threads',1,NULL),(983,'class Widget { }\nclass WidgetMaker extends Thread {\n    List<Widget> finishedWidget = new ArrayList<Widget>();\n    public void run(){\n        try{\n            while(true){\n                Thread.sleep(2000);\n                Widget w = new Widget();\n                \n                //insert something\n                \n            }\n        } catch(InterruptedException e){ }\n    }\n    \n    public Widget waitForWidget() {\n        synchronized(finishedWidget) {\n            if(finishedWidget.size() == 0){\n                try{\n                    finishedWidget.wait();\n                } catch(InterruptedException e){ }\n            }\n            return finishedWidget.remove(0);\n        }\n    }\n}\n\npublic class Hello extends Thread{\n    private WidgetMaker maker;\n    public Hello(String name, WidgetMaker me){\n        super(name);\n        this.maker = me;\n    }\n    \n    public void run(){\n        Widget w = maker.waitForWidget();\n        System.out.println(getName() + \"got a widget\");\n    }\n   \n    public static void main(String[] args) {\n       WidgetMaker maker = new WidgetMaker();\n       maker.start();\n       new Hello(\"lenny\",maker).start();\n       new Hello(\"Moe\",maker).start();\n       new Hello(\"Ben\",maker).start();\n    }\n}\n\nif each user should get its own widget which no other user is using what should\nyuou put in //insert here ? \n\nsynchronized(finishedWidget){\n	finshedWidget.add(w);\n	finishedWidget.notify();\n}\n\nor \n\nsynchronized(finishedWidget){\n	finshedWidget.add(w);\n	finishedWidget.notifyAll();\n}','notifyAll() would be a mistake since only one waiting thread can have \na widget. \n\nnotify() is better \n\nif they are all notified only one would get the new widget but the others \nwould probably throw an exception since they try to get a widgeth without\ndouble checking if one is available','Threads',1,NULL),(984,'public class Hello extends Thread{\n    private String name;\n    public Hello(String name){ this.name = name; }\n    public void write() {\n        System.out.println(name);\n        System.out.println(name);\n    }\n    public static void main(String[] args) {\n        new Hello(\"X\").start();\n        new Hello(\"Y\").start(); \n    }\n}\n\nyou want to guarentee that output is XXYY or YYXX how can you do this ?\n\n\npublic synchronized void run() { write(); }\npublic void run(){ synchronized(this){ write(); } }','NO, \nThese two run() method lock onto an instance of Hello but there are two \ndifferent instances so that wont prevent thme from running at the same time.\n\nyou can do...\n\n	public void run(){ synchronized(Letters.class){write();} }\n	\n	or\n	\n	public void run(){ synchronized(System.out){ write(); } }\n\nnow they wont run at the same time as they go for the same locks','Threads',1,NULL),(985,'class Calculator {\n    private AtomicInteger i = new AtomicInteger();\n    public void add(int val){\n        int old = i.get();\n        int newval = old + val;\n        System.out.println(i.compareAndSet(old,newval));   //LINE A\n    }\n    public int getValue() {\n        return i.get();\n    }\n}','This class is thread safe \n\nline a would always print true if a lock were used befor int old','Concurrency',1,NULL),(986,'public class Hello {\n    ExecutorService service = Executors.newFixedThreadPool(8);\n    \n        public void runAsynchronously(Asynchronous object){\n            Future<?> result = service.submit(object);\n        }\n        \n }\n\nwhat is a valid declaration of Asynchronous ?\n','class Asynchronous implements Runnable\nclass Asynchronous implements Callable<String>\n\nif the object sent to submit is a Runnable, the submit method will return\nan instance of Future whos get method will return null\n\notherwise Futures get method will return a type of the Type of class of Callable','Concurrency',1,NULL),(987,'ExecutorService method:\n\nsubmit\n\nFuture<?> submit(Runnable task)\n\nSubmits a Runnable task for execution and returns a Future representing that task. \nThe Future\'s get method will return null upon successful completion.','got it','Concurrency',1,NULL),(988,'public class Hello {\n\n    private static ExecutorService service = Executors.newFixedThreadPool(8);\n\n    public static void runAsynchronously(Asynchronous object) {\n        Future<?> result = service.submit(object);\n        try{\n            System.out.println(result.get());\n        } catch(InterruptedException | ExecutionException e){ }\n    }\n\n    public static void main(String[] args) {\n        runAsynchronously(new Asynchronous());\n    }\n\n}\n\nclass Asynchronous implements Runnable {\n\n    public void run() {\n        System.out.println(\"executing a runnable\");\n    }\n}','executing a runnable\nnull','Concurrency',1,NULL),(989,'public class Hello {\n    private Lock lock = new ReentrantLock();\n    private int value = 0;\n    public void increment(){\n        lock.lock();\n        value++;\n        lock.unlock();\n    }\n    public void decrement(){\n        lock.lock();\n        value--;\n        lock.unlock();\n    }\n    public int getValue(){\n        return value;\n    }\n    public static void main(String[] args){\n        \n    }    \n}\n\nis this class thread safe ?','yes,\n\nyou could also use Atomic integer with getAndIncrement and getAndDecrement\ninstead of value and the lock ','Concurrency',1,NULL),(990,'public static void main(SA) { \n	int[] myData = new int[10000000];\n	ForkJoin fj = new ForkJoin();\n\n	MyRecursiveInitClass action = new MyRecursiveInitClass(x,y,mydata);\n\n	fj.submit(action);\n\n	doStuff(myData);\n}\n\n','WNC fj should be a ForkJoinPool and use ivoke instead of submit','Concurrency',1,NULL),(991,'A ForkJoinPool implements Executor and ExecutorService\n\nextends AbstractExecutorService','true got it','Concurrency',1,NULL),(992,'ForkJoinPool is a ExecutorService\n\nthe implementation of the compute() in ForkJoinTask the fork method should \nalways be be called before the join() or the invokeAll()\n\ninvoke() from class ForkJoinPool only accpts as parameters istances of \nForkJoinTask \n\nif the algorithim does not have to return a value you should extends RecursiveAction\nnot RecursiveTask\n\nForkJoinPool is a ExecutorService so it can be usd to process a Callable\nvia the submit method.','got it','Concurrency',1,NULL),(993,'public class ConcurrentModification {\nList<Integer> list = new CopyOnWriteArrayList<>();\n\npublic void work(){\n	Iterator<Integer> iter = list.iterator();\n	while(it.hasNext()){\n		it.next();\n		list.add(100);\n	}\n	sout( list.size() );\n	}\n}','200 is printed this does not throw a ConcurrentModificationException because\na CopyOnWriteArrayList allows modifications while being iterated.\n\n\n\n','Concurrency',1,NULL),(994,'public class Hello implements Runnable {\n    private static ArrayBlockingQueue<Integer> abq = new ArrayBlockingQueue<>(10);\n    public static void main(String[] args){\n       Hello h = new Hello();\n       Thread t1 = new Thread(h);\n       Thread t2 = new Thread(h);\n       Thread t3 = new Thread(h);\n       Thread t4 = new Thread(h);\n       \n       t1.start();\n       t2.start();\n       t3.start();\n       t4.start();\n       \n    }\n    public void run(){\n        for(int i = 0; i<5; i++){\n            System.out.println(Thread.currentThread().getName()+\"removed element: \"+abq.peek());\n        }\n        \n    }\n}','Thread-1removed element: null\nThread-1removed element: null\nThread-1removed element: null\nThread-1removed element: null\nThread-1removed element: null\nThread-0removed element: null\nThread-0removed element: null\nThread-0removed element: null\nThread-0removed element: null\nThread-0removed element: null\nThread-2removed element: null\nThread-3removed element: null\nThread-2removed element: null\nThread-3removed element: null\nThread-2removed element: null\nThread-3removed element: null\nThread-2removed element: null\nThread-3removed element: null\nThread-2removed element: null\nThread-3removed element: null\n\npeek() returns null if empty','Concurrency',1,NULL),(995,'ArrayBlockingQueue\n\n\npeek() returns null if empty','got it ','Concurrency',1,NULL),(996,'peek() and poll() in interface Queue return null if empty','got it ','General',1,NULL),(997,'public class Hello {\n    enum A { A };\n    public static void main(String[] args) {\n        enum B{ B };\n    }\n}\nenum C{ C }','WNC enum types must not be local','General',1,NULL),(998,'enums cant be local to a method ','\n\nEnums are static nested classes because they define static member variables \n(the enum values), and this is disallowed for inner classes: \nhttp://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.1.3\n\nUpdate: I was looking through the JLS (java language specification) for\n more detail on the restrictions of static nested classes, and didn\'t find \nit (although it\'s probably there, hidden under a different topic). From a \npure implementation perspective, there\'s no reason that this couldn\'t be \ndone. \n\nAs a comment: if your methods are large enough that they require their own \nenums, then it\'s a strong sign that you need refactoring.\n','General',1,NULL),(999,'public class Hello extends Flipper {\n    public static void main(String[] args) {\n        \n    }\n    public void flip(){System.out.println(\"hello\");}\n}\nclass Flipper {\n    public final void flip() { System.out.println(\"flip\"); }\n}','WNC cannot override final methods','General',1,NULL),(1000,'public class Hello{\n    static String s = \"-\";\n    \n    public static void main(String[] args) {\n        go();\n        System.out.println(s);\n    }\n    { go(); }\n    static { go(); }\n    static void go(){ s+=\"s\"; }\n}','-ss\n\n{ go() } is an instance block, so it is not called until instantiation, which never happens here. ','OOP',1,NULL),(1001,'public class Hello{\n    \n    public static void main(String[] args) {\n       Bigger.Faster bf = Bigger.Faster.HIGHER;\n    }\n   \n}\nclass Bigger {\n    enum Faster { HIGHER,  LONGER };\n}','compiles fine how to use an enum','General',1,NULL),(1002,'public class Hello{\n    \n    public static void main(String[] args) {\n        System.out.println(Bulbs.ON);\n    }\n   \n}\nenum Bulbs{ ON(\"Bright\"), OFF(\"Dim\") };','WNC,\n\nthe constants are declared with String constructors so the default constructor\nwont do. ','General',1,NULL),(1003,'public class Hello{\n    \n    public static void main(String[] args) {\n        System.out.println(Bulbs.ON);\n    }\n   \n}\nenum Bulbs{ \n    ON(\"Bright\"), OFF(\"Dim\");\n    \n    String name;\n\n    Bulbs(String x){ name = x; }\n};','how to contruct a string argumnet enum constant','General',1,NULL),(1004,'public class Hello{\n    \n    public static void main(String[] args) {\n        System.out.println(Bulbs.ON);\n    }\n   \n}\nenum Bulbs{ \n    ON(\"Bright\"), OFF(\"Dim\");\n    \n    String name;\n\n    public Bulbs(String x){ name = x; }\n};','WNC enum constructos cannot be public or protected.\n\nThe constructor for an enum type must be package-private or private access.\'\n It automatically creates the constants that are defined at the beginning \nof the enum body. You cannot invoke an enum constructor yourself. \n\nThink of Enums as a class with a finite number of instances. \nThere can never be any different instances beside the ones you initially\n declare.\n\nThus, you cannot have a public or protected constructor, because that would\n allow more instances to be created.','General',1,NULL),(1005,'public class Hello extends B{\n    void m1() { System.out.println(\"c-m1\"); }\n    void m2() { }\n    \n    public static void main(String[] args) {\n        new Hello().go();\n        new Hello().m1();\n        new Hello().m2();\n    }\n    \n    void go(){ super.m1(); }\n    Hello(){ System.out.println(\"C \"); }\n}\nabstract class B {\n    void m1() { System.out.println(\"b-m1\");}\n    abstract void m2();\n    B() { System.out.println(\"B \");}\n    \n}','B \nC \nb-m1\nB \nC \nc-m1\nB \nC \n\nabstract classes can have constructors, when a subclass constructor is called\nit calls its super first.\n\n','General',1,NULL),(1006,'class Top {\n    { System.out.println(\"A\"); }\n    public Top(){ System.out.println(\"B\"); }\n    public Top(String s){ System.out.println(\"C\"); }\n}\n\nclass Middle extends Top {\n    {System.out.println(\"D\");}\n    public Middle(){ System.out.println(\"E\"); }\n    public Middle(String z){System.out.println(\"F\"); }\n}\npublic class Hello extends Middle{\n   {System.out.println(\"G\");}\n   public Hello(){ System.out.println(\"H\");}\n   public Hello(String x){ System.out.println(\"Z\");}\n    public static void main(String[] args) {\n      new Hello();\n    }\n}','A\nB\nD\nE\nG\nH','OOP',1,NULL),(1007,'DateFormat f3 = DateFormat.getDateInstance(DateFormat.SHORT);\nDateFormat f4 = DateFormat.getDateInstance(DateFormat.SHORT);\n\nif f3 == f4 always returns true, DateFormat is a factory\nif f3 == f4 always returns false, DateFormat is a factory','You can tell that DateFormat is not a singleton because it takes a parameter\n','OOP',1,NULL),(1008,'A factory can have a public constructor\n\na factory can reate a new object each time you call it ','','OOP',1,NULL),(1009,'overriding requires the use of IS A relationship','','OOP',1,NULL),(1010,'IS A relationships always rely on inheritance\n\nIS A relationships always require at least two class types\n\nPolymorphism always relies on IS A relationships','','OOP',1,NULL),(1011,'BioDiesel b4 = new BioDiesel(new Viscosity());','tight coupling','OOP',1,NULL),(1012,'DAO implementation must implements an interface,\n\nincreases cohesion by seperating data access code from the object representing\nthe data','Got it','OOP',1,NULL),(1013,'what is this an example of:\n\ninterface B { void c(); }\n\nclass A implements B {\n	private B;\n\n	public A(B b){ this.b = b; }\n\n	public void c(){ b.c(); }\n\n	public void d(){ }\n}','object composition, method delegation','OOP',1,NULL),(1014,'public class Stadium { \n	private static final Stadium i = new Stadium();\n	public static Stadium newStadium() {\n		return i;\n	}\n	private Stadium() { }\n}','singleton\nthough not good with the nameing convention, should be getInstance()','OOP',1,NULL),(1015,'interface Box{\n    void pack();\n    void seal();\n}\n\ninterface Mailer {\n    void addPostage();\n    void ship();\n}\n\nclass GiftBox implements Box{\n    public void pack(){ }\n    public void seal() { }\n}\n\nclass MailerBox implements Box,Mailer {\n    private Box box;\n    public MailerBox(Box box){\n        this.box = box;\n    }\n    public void pack(){ box.pack(); }\n    public void seal(){ box.seal(); }\n    public void addPostage(){\n        System.out.println(\"post\");\n    }\n    public void ship(){\n        System.out.println(\"Put in a box\");\n    }\n}','object composition','OOP',1,NULL),(1016,'public interface BookDao {\n	Collection<Book> findAllBooks();\n	Book findBookByIsbn(Book book);\n	void create(Book book);	\n	void delet(Book book);\n	void update(Book book);\n}\n\npublic class inMemoryDao implements BookDao { }\n\n','Daos should immplement an interface so that is is easy to swap out database\nimplementations','OOP',1,NULL),(1017,'loose coupling is desirable, classes are well encapulated minimize reference\nto each other and limit the breadth of API use','got it ','OOP',1,NULL),(1018,'Object compositoin takes advantage of ISA HASA and polymorphism','got it','OOP',1,NULL),(1019,'a Factory creates any subclass of an interface or abstract class\nFactoy is an abstract class\nThe Factory method return type is an interface or abstract class\nreturns subclasses of the target subect','got it ','OOP',1,NULL),(1020,'You want the factory class to be an abstract class so that\nyou can implement some concrete code if necesarry. ','','OOP',1,NULL),(1021,'class A() { }\n\nabstract class G {\n	A m() { return n(); }\n	abstract A n();\n}\n\nwhich design pattern ?','Factory, A is the object we are creating and G is the abstract super class\nfor the factory what is not shown is the subclass that impleents the factory. ','OOP',1,NULL),(1022,'class Hello{\n    public static void main(String[] args) {\n        Queue<String> x = new PriorityQueue<>();\n        x.add(\"one\");\n        x.add(\"two\");\n        x.add(\"thread\");\n        System.out.println(x.poll());\n    }\n}','one, \n\nQueue\n\nQueue is a ordered collection of items.\n\nItems are deleted at one end called ‘front’ end of the queue.\n\nItems are inserted at other end called ‘rear’ of the queue.\n\nThe first item inserted is the first to be removed (FIFO).\n\nStack\n\nStack is a collection of items.\n\nIt allows access to only one data item: the last item inserted.\n\nItems are inserted & deleted at one end called ‘Top of the stack’.\n\nIt is a dynamic & constantly changing object.\n\nAll the data items are put on top of the stack and taken off the top\n\nThis structure of accessing is known as Last in First out structure (LIFO)','Generics',1,NULL),(1023,'class Hello{\n    public static void main(String[] args) {\n        TreeSet<String> x = new TreeSet<>();\n        x.add(\"one\");\n        x.add(\"two\");\n        x.add(\"thread\");\n        System.out.println(x.poll());\n    }\n}','WNC, TreeSet does not implement Queue so it does not have poll()','Collections',1,NULL),(1024,'class A {   \n      private void methodA() {System.out.println(\"Hello, I am A!\");}   \n      public static void main(String[] args) {   \n        A a = new A();   \n        a.methodA(); }   \n} ','A private member can be access via a reference variable from within the object\nthat private was declared.  \n\nMethods, Variables and Constructors that are declared private can only be \naccessed within the declared class itself.\n\n','General',1,NULL),(1025,'class Hello{\n    private Set<Integer> numbers = new TreeSet<Integer>();\n    public Hello(int...nums){\n        for(int n: nums){\n            numbers.add(n);\n        }\n    }\n    public Hello negate(){\n        Hello negatives = new Hello();\n        for(int n : numbers){\n            negatives.numbers.add(-n);\n        }\n        return negatives;\n    }\n    public void show(){\n        for(int n : numbers){\n            System.out.println(n+\" \");\n        }\n    }\n    public static void main(String[] args) {\n        new Hello(1,3,-5).negate().show();\n    }\n}','-3 -1 5\n\nit doesnt matter what order the numbers are added to the set, it is a treeset\n\nthe negate() creates a new set withc negated values they are then put into \nincreasing order','General',1,NULL),(1026,'public static void main(String[] args) {\n        \n        Comparator<Integer> cmp = new Comparator<Integer>() {\n            public int compare(Integer n1, Integer n2){\n                return n2.compareTo(n1);\n            }\n        };\n        \n        PriorityQueue pq = new PriorityQueue<Integer>(100,cmp);\n        pq.addAll(Arrays.asList(16,8,42,15,4,23));\n        System.out.println(pq.poll());\n}','42,\n\n100 is the initial capacity.\n\nThis sorts in reverse order. ','Collections',1,NULL),(1027,'public static void main(String[] args) {\n        Map<Integer,String> lat = new HashMap<>();\n        lat.put(60,\"Sea\");\n        lat.put(66,\"circle\");\n        System.out.println(lat.put(62,\"island\"));\n        System.out.println(lat.put(60,\"ocean\"));\n        lat.put(65,\"island\");\n        System.out.println(lat.size() + \" \");\n        System.out.println(lat.containsValue(\"sea\") + \" \");\n}','Sea\n4 \nfalse\n\nput returns the value previously associated with the key, or null if there\nwas nothing with it previously. ','Collections',1,NULL),(1028,'public <S extends CharSequence> S foo(S s){\n	//return s;\n	//return (Object) s;\n	//return s.toString();\n	//return new StringBuilder(s);\n	//return (S) new StringBUilder(s);\n	//return null\n}\n\nwhich compile?','only return s and return null, \n\nalthough String and StringBuilder are both subtypes of charsequence they are\nnot necesarrily subtypes of whatever is passed in ','Collections',1,NULL),(1029,'TreeSet map = new TreeSet();\nmap.add(\"one\");\nmap.add(\"two\");\nmap.add(\"three\");\nmap.add(\"four\")\nmap.add(\"one\");\nIterator it = map.iterator();\nwhile(it.hasNext()){\n	sout(	it.next() + \" \" );\n}','four one three two\n\nTreeSet assures no duplicate entries, it will return elements in natrual\norder for strings thats alphebetical. ','Collections',1,NULL),(1030,'class Hello{\n   public static void main(String[] args){\n       Queue<String> q = new LinkedList<String>();\n       q.add(\"V\");\n       q.add(\"Wallace\");\n       q.add(\"Duncan\");\n       showAll(q);\n   }\n   \n   public static void showAll(Queue q) {\n       q.add(new Integer(42));\n       while(!q.isEmpty()){\n           System.out.println(q.remove()+ \" \");\n       }\n   }\n}','V \nWallace \nDuncan \n42 \n\nqueue is a FIFO \n\na compiler warning will be produced but it will still compile and run without\nexception ','Collections',1,NULL),(1031,'public static void main(String[] args){\n       TreeSet<Number> tree = new TreeSet<Number>();\n       tree.add(108);\n       //tree.add(3.14);\n       //tree.add(\"42\");\n       //tree.add(Integer.valueOf(\"-1\");\n       //tree.add(null);\n       //tree.add(new Long(123));\n       //tree.add(0XCAFE);\n       \n   }\n\nwhich will compile and run ?','only Integer.valueOf(\"-1\") and 0xCAFE\n\nThis TreeSet will allow only numbers but the numbers must be mutually comparable\nthe 108 is an integer so anything added afterward must be an integer.\n\n0xCAFE is a valid hex literal for an int. \n\n3.14 is a double. ','Collections',1,NULL),(1032,'public static void main(String[] args){\n       TreeSet<Number> tree = new TreeSet<Number>();\n       tree.add(108);\n       tree.add(3.14);\n       //tree.add(\"42\");\n       tree.add(Integer.valueOf(\"-1\"));\n       tree.add(null);\n       tree.add(new Long(123));\n       tree.add(0XCAFE);\n       \n   }','ClassCastExcepiton','Collections',1,NULL),(1033,'diamond operator cannot be used with anonymous classes','Internally, a Java compiler operates over a richer set of types than those \nthat can be written down explicitly in a Java program. The compiler-internal\n types which cannot be written in a Java program are called non-denotable\n types. Non-denotable types can occur as the result of the inference used\n by diamond. Therefore, using diamond with anonymous inner classes is not \nsupported since doing so in general would require extensions to the class \nfile signature attribute to represent non-denotable types, a de facto JVM \nchange. It is feasible that future platform versions could allow use of \ndiamond when creating an anonymous inner class as long as the inferred type \nwas denotable.','General',1,NULL),(1034,'What collection would be best to implement a stack that does not have \nthe overhead of synchronized methods ?','LinkedList\n\nallows duplicates and has methods apporopriate for pushing and popping from the\nstack addFirst() getFirst()','Collections',1,NULL),(1035,'public static void main(String[] args){\n       String[] s = { \"inch\", \"foot\", \"yard\", \"rod\", \"meter\" };\n       List list = Arrays.asList(s);\n       list.set(4,\"chain\");\n       System.out.println(s[4]);\n       s[2] = \"meter\";\n       System.out.println(\" \" + list.get(2));\n   }','chain meter','Collections',1,NULL),(1036,'public static void main(String[] args){\n       String[] s = { \"inch\", \"foot\", \"yard\", \"rod\" };\n       List list = Arrays.asList(s);\n       list.set(4,\"chain\");\n       System.out.println(s[4]);\n       s[2] = \"meter\";\n       System.out.println(\" \" + list.get(2));\n   }','ArrayIndexOutofBoundsException you are refereing to place 4 when there is \nonly 3 indexs 0-3','Collections',1,NULL),(1037,' public static void main(String[] args){\n       String[] s = { \"inch\", \"foot\", \"yard\", \"rod\", \"meter\" };\n       List list = Arrays.asList(s);\n       list.set(4,\"chain\");\n       System.out.println(s[4]);\n       s[2] = \"meter\";\n       System.out.println(\" \" + list.get(2));\n       list.add(9);\n   }','UnsupportedOerationException,\n\nwhen you use asList the list and array becomes bound at the hip. so changes\nin one refect in the other,\n\nyou can only reset indexes though you cannot make any new addition or removals\nto the list, and you cant add or remove from an array anyway.','Collections',1,NULL),(1038,'class BackLister {\n    public static <T> List<T> backwards(List<T> input)\n    {\n        List<T> output = new LinkedList<T>();\n        for(T t : input)\n            output.add(0,t);\n        return output;\n    }\n}','compiles fine. ','Collections',1,NULL),(1039,'class BackLister {\n    //insert here \n    {\n        List<T> output = new LinkedList<T>();\n        for(T t : input)\n            output.add(0,t);\n        return output;\n    }\n}\n\npublic static <T> List<T> backwards(List<T> iput)\npublic static <T> List<T> backwards(List<? extends T> input)\npublic static <? super T> List<T> backwards(List<T> input)\npublic static <? extends T> List<T> backwards(List<T> input)\npublic static <T> List<? extends T> backwards(List<T> input)\npublic static <T> List<T> backwards(List<? super T> input)\npublic static <T> List<? super T> backwards(List<T> input)\n\nwhich compile and run without error ?\n','public static <T> List<T> backwards(List<T> iput)\n	- a standard way to create a generic method\n\npublic static <T> List<T> backwards(List<? extends T> input)\n	-this says to the compile \" I want to be allowed to pass\n		in lsits of subtypes of the declared type but only\n		to invoke methods on the elements.\n\npublic static <T> List<? super T> backwards(List<T> input)\npublic static <T> List<? extends T> backwards(List<T> input)\n\n\npublic static <T> List<T> backwards(List<? super T> input)\n\n	this will nto compile because if the input can containt any super type\nof T then those elements couldn\'t be added to a collection of type T','Collections',1,NULL),(1040,'class Hello{\n   public static void main(String[] args){\n       ArrayList<Integer> ints = new ArrayList<>();\n       ints.add(9);\n       ints.add(8);\n       ints.add(7);\n   }\n\n    public static <T> List<T> backwards(List<? super T> input)\n    {\n        List<T> output = new LinkedList<T>();\n        for(T t : input)\n            output.add(0,t);\n        return output;\n    }\n}','WNC,\n\nif the input can contain any super type of T then those elements couldn\'t be\nadded to a collection of type T.','Collections',1,NULL),(1041,'public static <? extends T> List<T> backwards(List<T> input)','WILL NEVER COPMPILE\n\ncannot use wildcards in the type declaration','Collections',1,NULL),(1042,'public static <? super T> List<T> backwards(List<T> input)','WILL NEVER COMPILE\n\ncannot use wildcards in the type variable delcaraiotn','Collections',1,NULL),(1043,'CANNOT USE ? WILDCARDS IN THE TYPE VARIABLE DECLARATION OF THE GENERIC METHOD','got it ','Collections',1,NULL),(1044,'class Hello<G>{\n   public static void main(String[] args){\n       ArrayList<G> ints = new ArrayList<>();\n   }\n\n    public static <T> List<T> backwards(List<? super T> input)\n    {\n        ArrayList<G> ints = new ArrayList<>();\n        List<T> output = new LinkedList<T>();\n        for(T t : input)\n            output.add(0,t);\n        return output;\n    }\n}\n','WNC,\n\nnon static type variable G cannot be used in static context','Collections',1,NULL),(1045,'class Hello<G>{\n   public static void main(String[] args){\n       \n   }\n\n    public static <T extends G> List<T> backwards(List<T> input)\n    {\n        List<T> output = new LinkedList<T>();\n        for(T t : input)\n            output.add(0,t);\n        return output;\n    }\n}','WNC non static type variable G cannot be referenced from a static context','Collections',1,NULL),(1046,'This is the first part of PECS i.e. PE (Producer extends). To more relate it to real life terms, let’s use an analogy of a basket of fruits (i.e. collection of fruits). When we pick a fruit from basket, then we want to be sure that we are taking out only fruit only and nothing else; so that we can write generic code like this:\n\nFruit get = fruits.get(0);\n\nIn above case, we need to declare the collection of fruits as List<? extends Fruit>. e.g.\nclass Fruit {\n   @Override\n   public String toString() {\n      return \"I am a Fruit !!\";\n   }\n}\n \nclass Apple extends Fruit {\n   @Override\n   public String toString() {\n      return \"I am an Apple !!\";\n   }\n}\n \npublic class GenericsExamples\n{\n   public static void main(String[] args)\n   {\n      //List of apples\n      List<Apple> apples = new ArrayList<Apple>();\n      apples.add(new Apple());\n       \n      //We can assign a list of apples to a basket of fruits;\n      //because apple is subtype of fruit \n      List<? extends Fruit> basket = apples;\n       \n      //Here we know that in basket there is nothing but fruit only\n      for (Fruit fruit : basket)\n      {\n         System.out.println(fruit);\n      }\n       \n      //basket.add(new Apple()); //Compile time error\n      //basket.add(new Fruit()); //Compile time error\n   }\n}','','Collections',1,NULL),(1047,'a producer will extend the type being used because it will possibly contain\nsubtypes, it is a producer therefore you shouldn\'t have to nor want to\nadd anything else to it. so <? extends G> is for producers nothing will be\nadded to this collection','','Collections',1,NULL),(1048,'class Fruit {\n   @Override\n   public String toString() {\n      return \"I am a Fruit !!\";\n   }\n}\n \nclass Apple extends Fruit {\n   @Override\n   public String toString() {\n      return \"I am an Apple !!\";\n   }\n}\n \nclass AsianApple extends Apple {\n   @Override\n   public String toString() {\n      return \"I am an AsianApple !!\";\n   }\n}\n \npublic class GenericsExamples\n{\n   public static void main(String[] args)\n   {\n      //List of apples\n      List<Apple> apples = new ArrayList<Apple>();\n      apples.add(new Apple());\n       \n      //We can assign a list of apples to a basket of apples\n      List<? super Apple> basket = apples;\n       \n      basket.add(new Apple());      //Successful\n      basket.add(new AsianApple()); //Successful\n      basket.add(new Fruit());      //Compile time error\n   }\n}\n\nWe are able to add apple and even Asian apple inside basket, but we are not\n able to add Fruit (super type of apple) to basket. Why?\n\nReason is that basket is a reference to a List of something that is a \nsupertype of Apple. Again, we cannot know which supertype it is, but we\n know that Apple and any of its subtypes (which are subtype of Fruit) can \nbe added to be without problem (you can always add a subtype in collection \nof supertype). So, now we can add any type of Apple inside basket.\n\nproducers use super','','Collections',1,NULL),(1049,'class Hello{\n   public static void main(String[] args){\n       new Hello().go();\n   }\n   void go() throws IOException {\n       String row;\n       try {\n          FileReader fr = new FileReader(\"TestFile.txt\");\n          BufferedReader br = new BufferedReader(fr);\n          while((row = br.readLine()) != null)\n               System.out.println(row);\n       } catch(IOException e){\n           System.out.println(\"IOERROR\");\n       } finally {\n           System.out.println(\"done\");    \n       }\n   }\n}','WNC though it is not thrown go() declares that it throws an excpetion so it \nshould be handled by main','Exceptions',1,NULL),(1050,'class Party {\n    static class Rain extends Exception { }\n    static class Thunderstorm extends Rain{ }\n    public void eat() {\n        try {\n            bbq();\n        } catch(Rain | Thunderstorm e){\n            \n        }\n    }\n    private void bbq() throws Rain, Thunderstorm{ }\n}','multi catch may not contain exception types that are in the same heirarchy','Exceptions',1,NULL),(1051,'class Hello{\n   public static int y;\n   public static void main(String[] args){\n       int t = 2;\n       assert t < 4 : bar(7);\n       assert t > 1 : foo(8);\n       System.out.println(\"done\");\n   }\n    public static int foo(int x) {\n        System.out.println(\"foo \");\n        return y = x;\n    }\n    public static int bar(int z) {\n        System.out.println(\"bar \");\n        return y = z;\n    }\n}','done\n\nboth assert statements are true so the methods are never called','Exceptions',1,NULL),(1052,'class Hello{\n    static class A implements AutoCloseable {\n        public void close() throws Exception {\n            throw new Exception(\"catch\");\n        }\n    }\n    \n    private static void method() throws Exception {\n        try(A a = new A()) {\n            throw new Exception(\"try\");\n        } finally {\n            throw new Exception(\"finally\");\n        }\n    }\n\n   public static void main(String[] args){\n       try {\n           method();\n       } catch(Exception e) {\n           System.out.println(e.getMessage());\n           System.out.println(e.getSuppressed()[0]);\n       }\n   }\n\n}','finally\nException in thread \"main\" java.lang.ArrayIndexOutOfBoundsException: 0\n	at hello.Hello.main(Hello.java:53)\n/home/maxbisesi/.cache/netbeans/8.1/executor-snippets/run.xml:53: Java returned: 1\n\n\nTHe other two excpeitons weren\'t suppressed they were forgotten when \nfinally threw a new exception. \n\nso getSuppressed() cant find anything and throws the indexOB exception.','Exceptions',1,NULL),(1053,'%[arg_index][flags][width][.precision]conversion char\n\nflags\n-=-=-=-=-=-\n- left justify\n+ include a sign\n0 pad argument with zeros\n, use locale specific grouping serperators\n( Enclose negative numbers in parentheses\n\nconversion chars\n-=-=-=-=-=-=-=-=-=-\nb boolean\nc char\nd integer\nf floating point\ns string','got it','Strings',1,NULL),(1054,'Barring booleans, if your conversion character doesn\'t match your argument type,\nan exception will be thrown','got it','Strings',1,NULL),(1055,'private static void method() throws Exception {\n        int a = 831;\n        int b = 7566;\n        int c = 317;\n        System.out.printf(\">%1$(7d< \\n\",c);\n        System.out.printf(\">%0,7d< \\n\",a);\n        System.out.printf(\">%+-7d< \\n\",b);\n    }','>    317< \n>0000831< \n>+7566  < \n\n','Strings',1,NULL),(1056,'format flags:\n\n,','use locale specific seperators','Strings',1,NULL),(1057,'format flags:\n\n(','Encolose negative numbers in paranethes','Strings',1,NULL),(1058,'format flags:\n\n0','Pad this argument with zeroes','Strings',1,NULL),(1059,'format flags:\n\n+','Include a sign with this argument','Strings',1,NULL),(1060,'format flags:\n\n-','left justify this argument','Strings',1,NULL),(1061,'format conversion chararcters:\n\nb\nc\nd\nf\ns','boolean\ncharacter\ninteger\nfloating point\nstring','Strings',1,NULL),(1062,'private static void method() throws Exception {\n        int a = 831;\n        String s = \"The world is not enough\";\n        boolean yea = true;\n        \n        System.out.printf(\"%1$s, and there is no tomorrow\",s);\n    }','The world is not enough, and there is no tomorrow\n\neverything after the conversion character is printed as is','Strings',1,NULL),(1063,'private static void method() throws Exception {\n        int a = 831;\n        String s = \"The world is not enough\";\n        boolean yea = true;\n        \n        System.out.printf(\"%1$s, and there is no tomorrow\",a);\n    }','831, and there is no tomorrow','Strings',1,NULL),(1064,'private static void method() throws Exception {\n        int a = 831;\n        String s = \"The world is not enough\";\n        boolean yea = true;\n        \n        System.out.printf(\"%1$s, and there is no tomorrow\",a);\n    }','831, and there is no tomorrow','Strings',1,NULL),(1065,'private static void method() throws Exception {\n        int a = 831;\n        String s = \"The world is not enough\";\n        boolean yea = true;\n        \n        System.out.printf(\"%1$s, and there is no tomorrow\",a);\n    }','831, and there is no tomorrow','Strings',1,NULL),(1066,'private static void method() throws Exception {\n        int a = 831;\n        String s = \"The world is not enough\";\n        boolean yea = true;\n        \n        System.out.printf(\"%1$s, and there is no tomorrow\",a);\n    }','831, and there is no tomorrow','Strings',1,NULL),(1067,'private static void method() throws Exception {\n        int a = 831;\n        String s = \"The world is not enough\";\n        boolean yea = true;\n        \n        System.out.printf(\"%1$s, and there is no tomorrow\",a);\n    }','831, and there is no tomorrow','Strings',1,NULL),(1068,'private static void method() throws Exception {\n        int a = 831;\n        String s = \"The world is not enough\";\n        boolean yea = true;\n        \n        System.out.printf(\"%1$s, and there is no tomorrow\",a);\n    }','831, and there is no tomorrow','Strings',1,NULL),(1069,'private static void method() throws Exception {\n        int a = 831;\n        String s = \"The world is not enough\";\n        boolean yea = true;\n        \n        System.out.printf(\"%1$s, and there is no tomorrow\",a);\n    }','831, and there is no tomorrow','Strings',1,NULL),(1070,'private static void method() throws Exception {\n        int a = 831;\n        String s = \"The world is not enough\";\n        boolean yea = true;\n        \n        System.out.printf(\"%1$s, and there is no tomorrow\",a);\n    }','831, and there is no tomorrow','Strings',1,NULL),(1071,'private static void method() throws Exception {\n        int a = 831;\n        String s = \"The world is not enough\";\n        boolean yea = true;\n        \n        System.out.printf(\"%1$s, and there is no tomorrow\",a);\n    }','831, and there is no tomorrow','Strings',1,NULL),(1072,'private static void method() throws Exception {\n        int a = 831;\n        String s = \"The world is not enough\";\n        boolean yea = true;\n        \n        System.out.printf(\"%1$s, and there is no tomorrow\",a);\n    }','831, and there is no tomorrowa','Strings',1,NULL),(1073,'private static void method() throws Exception {\n        int a = 831;\n        String s = \"The world is not enough\";\n        boolean yea = true;\n        \n        System.out.printf(\"%1$s, and there is no tomorrow\",a);\n    }','831, and there is no tomorrowa','Strings',1,NULL),(1074,'private static void method() throws Exception {\n        int a = 831;\n        String s = \"The world is not enough\";\n        boolean yea = true;\n        \n        System.out.printf(\"%1$s, and there is no tomorrow\",a);\n    }','831, and there is no tomorrowa','Strings',1,NULL),(1075,'private static void method() throws Exception {\n        int a = 831;\n        String s = \"The world is not enough\";\n        boolean yea = true;\n        \n        System.out.printf(\"%1$s, and there is no tomorrow\",a);\n    }','831, and there is no tomorrowa','Strings',1,NULL),(1076,'private static void method() throws Exception {\n        int a = 831;\n        String s = \"The world is not enough\";\n        boolean yea = true;\n        \n        System.out.printf(\"%1$s, and there is no tomorrow\",a);\n    }','831, and there is no tomorrowa','Strings',1,NULL),(1077,'private static void method() throws Exception {\n        int a = 831;\n        String s = \"The world is not enough\";\n        boolean yea = true;\n        \n        System.out.printf(\"%1$s, and there is no tomorrow\",a);\n    }','831, and there is no tomorrowa','Strings',1,NULL),(1078,'private static void method() throws Exception {\n        int a = 831;\n        String s = \"The world is not enough\";\n        boolean yea = true;\n        \n        System.out.printf(\"%1$s, and there is no tomorrow\",a);\n    }','831, and there is no tomorrowa','Strings',1,NULL),(1079,'private static void method() throws Exception {\n        int a = 831;\n        String s = \"The world is not enough\";\n        boolean yea = true;\n        \n        System.out.printf(\"%1$s, and there is no tomorrow\",a);\n    }','831, and there is no tomorrowa','Strings',1,NULL),(1080,'public static void main(String[] args){\n        int count = 0;\n            for (int ch = \'a\'; ch <= \'z\'; ch++) {\n            System.out.printf(\"      %1$4c%1$4x\", ch);\n            if (++count % 6 == 0) {\n                 System.out.printf(\"%n\");\n             }\n        System.out.printf(\"      %1$4c%<4x\", ch);\n        }\n\n   }','         a  61         a  61         b  62         b  62         c  63         c  63         d  64         d  64         e  65         e  65         f  66\n         f  66         g  67         g  67         h  68         h  68         i  69         i  69         j  6a         j  6a         k  6b         k  6b         l  6c\n         l  6c         m  6d         m  6d         n  6e         n  6e         o  6f         o  6f         p  70         p  70         q  71         q  71         r  72\n         r  72         s  73         s  73         t  74         t  74         u  75         u  75         v  76         v  76         w  77         w  77         x  78\n         x  78         y  79         y  79         z  7a         z  7','Strings',1,NULL),(1081,'public static void main( String args[] )\n   { \n      char character = \'A\';\n      String string = \"This is also a string\";\n      Integer integer = 1234;  // initialize integer (autoboxing)\n\n      System.out.printf( \"%c\\n\", character );\n      System.out.printf( \"%s\\n\", \"This is a string\" );\n      System.out.printf( \"%s\\n\", string );\n      System.out.printf( \"%S\\n\", string );\n      System.out.printf( \"%s\\n\", integer ); // implicit call to toString\n   }','A\nThis is a string\nThis is also a string\nTHIS IS ALSO A STRING\n1234','Strings',1,NULL),(1082,'public static void main( String args[] ) \n   {\n      Object test = null;\n      System.out.printf( \"%b\\n\", false );\n      System.out.printf( \"%b\\n\", true );\n      System.out.printf( \"%b\\n\", \"Test\" );\n      System.out.printf( \"%B\\n\", test );\n      System.out.printf( \"Hashcode of \\\"hello\\\" is %h\\n\", \"hello\" );\n      System.out.printf( \"Hashcode of \\\"Hello\\\" is %h\\n\", \"Hello\" );\n      System.out.printf( \"Hashcode of null is %H\\n\", test );\n      System.out.printf( \"Printing a %% in a format string\\n\" );\n      System.out.printf( \"Printing a new line %nnext line starts here\" );\n   }','false\ntrue\ntrue\nFALSE\nHashcode of \"hello\" is 5e918d2\nHashcode of \"Hello\" is 42628b2\nHashcode of null is NULL\nPrinting a % in a format string\nPrinting a new line \nnext line starts here','Strings',1,NULL),(1083,'public static void main(String[] args){\n        int count = 0;\n        String s = \" true\";\n        boolean yea = true;\n        boolean nah = false;\n        System.out.printf(\"use boolean to convert non-boolean\\n count:%b \\n s:%b \\n yea:%b \\n nah:%b \",count,s,yea,nah);\n   }','a boolean conversion character will convert anything non boolean to \"true\"\nand a false to boolean to \"false\"','Strings',1,NULL),(1084,'public static void main(String[] args){\n        int count = 0;\n        String s = \" true\";\n        boolean yea = true;\n        boolean nah = false;\n        System.out.printf(\"use string to convert non-boolean\\n count:%s \\n s:%s \\n yea:%s \\n nah:%s \",count,s,yea,nah);\n   }','use string to convert non-boolean\n count:0 \n s: true \n yea:true \n nah:false','Strings',1,NULL),(1085,'At least five wide 	\n\nprintf(\"\'%5d\'\", 10); 	\'   10\'\n\nAt least five-wide, left-justified 	\n\nprintf(\"\'%-5d\'\", 10); 	\'10   \'\n\nAt least five-wide, zero-filled 	\n\nprintf(\"\'%05d\'\", 10); 	\'00010\'\n\nAt least five-wide, with a plus sign 	\n\nprintf(\"\'%+5d\'\", 10); 	\'  +10\'\n\nFive-wide, plus sign, left-justified 	\n\nprintf(\"\'%-+5d\'\", 10); 	\'+10  \'','got it ','Strings',1,NULL),(1086,'The %3d specifier is used with integers, and means a minimum width of three\n spaces, which, by default, will be right-justified:\n\nprintf(\"%3d\", 0); 	0\nprintf(\"%3d\", 123456789); 	123456789\nprintf(\"%3d\", -10); 	-10\nprintf(\"%3d\", -123456789); 	-123456789','got it','Strings',1,NULL),(1087,'To left-justify integer output with printf, just add a minus sign (-) after\n the % symbol, like this:\n\nprintf(\"%-3d\", 0); 	0\nprintf(\"%-3d\", 123456789); 	123456789\nprintf(\"%-3d\", -10); 	-10\nprintf(\"%-3d\", -123456789); 	-123456789','got it','Strings',1,NULL),(1088,'As a summary of printf integer formatting, here’s a little collection of \ninteger formatting examples. Several different options are shown, including\n a minimum width specification, left-justified, zero-filled, and also a \nplus sign for positive numbers.\n\nAt least five wide 	printf(\"\'%5d\'\", 10); 	\'   10\'\nAt least five-wide, left-justified 	printf(\"\'%-5d\'\", 10); 	\'10   \'\nAt least five-wide, zero-filled 	printf(\"\'%05d\'\", 10); 	\'00010\'\nAt least five-wide, with a plus sign 	printf(\"\'%+5d\'\", 10); 	\'  +10\'\nFive-wide, plus sign, left-justified 	printf(\"\'%-+5d\'\", 10); 	\'+10  \'','got it','Strings',1,NULL),(1089,'A simple string 	printf(\"\'%s\'\", \"Hello\"); 	\'Hello\'\nA string with a minimum length 	printf(\"\'%10s\'\", \"Hello\"); 	\'     Hello\'\nMinimum length, left-justified 	printf(\"\'%-10s\'\", \"Hello\"); 	\'Hello     \'','got it','Strings',1,NULL),(1090,'Print one position after the decimal 	\n\nprintf(\"\'%.1f\'\", 10.3456); 	\'10.3\'\n\nTwo positions after the decimal 	\n\nprintf(\"\'%.2f\'\", 10.3456); 	\'10.35\'\n\nEight-wide, two positions after the decimal 	\n\nprintf(\"\'%8.2f\'\", 10.3456); 	\'   10.35\'\n\nEight-wide, four positions after the decimal 	\n\nprintf(\"\'%8.4f\'\", 10.3456); 	\' 10.3456\'\n\nEight-wide, two positions after the decimal, zero-filled 	\n\nprintf(\"\'%08.2f\'\", 10.3456); 	\'00010.35\'\n\nEight-wide, two positions after the decimal, left-justified 	\n\nprintf(\"\'%-8.2f\'\", 10.3456); 	\'10.35   \'\n\nPrinting a much larger number with that same format 	\n\nprintf(\"\'%-8.2f\'\", 101234567.3456); 	\'101234567.35\'','got it if the argument is larger than the width, it will be extended','Strings',1,NULL),(1091,'public static void main(String[] args){\n        int count = 0;\n        String s = \" true\";\n        boolean yea = true;\n        boolean nah = false;\n        System.out.printf(\"%1$(4s\",s);\n   }','Exception in thread \"main\" java.util.FormatFlagsConversionMismatchException: Conversion = s, Flags = (\n\nfor using flags that dont apply to strings','Strings',1,NULL),(1092,'public static void main(String[] args){\n        int count = 0;\n        String s = \" true\";\n        boolean yea = true;\n        boolean nah = false;\n        System.out.printf(\"%1$0s\",s);\n   }','Exception in thread \"main\" java.util.FormatFlagsConversionMismatchException:\n Conversion = s, Flags = 0','Strings',1,NULL),(1093,'public static void main(String[] args){\n        int count = -34;\n        String s = \" true\";\n        boolean yea = true;\n        boolean nah = false;\n        System.out.printf(\"%1$0(3d\",count);\n   }','(34)\n\nit goes like this:\n\narg_index flags width precision conversion character\n\nso here the fomat string means index 1, pad with zeroes, \nwidth of three, enclose negatives in zero, convert from an int','Strings',1,NULL),(1094,'public static void main(String[] args){\n        double count = -34.45;\n        String s = \" true\";\n        boolean yea = true;\n        boolean nah = false;\n        System.out.printf(\"%1$0(3d\",count);\n   }','Exception in thread \"main\" java.util.IllegalFormatConversionException:\n d != java.lang.Double','Strings',1,NULL),(1095,'public static void main(String[] args){\n        double count = -34.45;\n        String s = \" true\";\n        boolean yea = true;\n        boolean nah = false;\n        System.out.printf(\"%1$0(3f\",count);\n   }','(34.450000)','Strings',1,NULL),(1096,'public static ArrayList<Card> findCardsWithNoCategory(ArrayList<? extends Card> list){\n        ArrayList<? super Card> cards = new ArrayList<Card>();\n        \n        for(Card c : list){\n            if(c.getCategory().equals(\"\") || c.getCategory().equals(\" \")){\n                cards.add(c);\n            }\n        }\n        \n        return cards;\n        \n    }','\nWNC\ncant return <? super Cards> when return type is <Card>','Generics',1,NULL),(1097,'DirectoryStream dm = ...\n\nFileSystem.getDefault().getDirectoryStream(Path p, String glob);\n\nFiles.getDefault().newDirectoryStream(File f, String regex);\n\nFiles.getDefault().newDirectoryStream(Path p, String glob);\n\nFiles.newDirectoryStream(Path p, String glob);\n\nFiles.getDirectoryStream(Files f, String regex);\n\n','Files.newDirectoryStream(Path p, String glob)\n\nDirectoryStream only uses glob\n\nso you dont have to say \"glob: *\"\n\nif you do it wont match anything','Input/Output',1,NULL),(1098,'DirectoryStream dm = ...\n\nFileSystem.getDefault().getDirectoryStream(Path p, String glob);\n\nFiles.getDefault().newDirectoryStream(File f, String regex);\n\nFiles.getDefault().newDirectoryStream(Path p, String glob);\n\nFiles.newDirectoryStream(Path p, String glob);\n\nFiles.getDirectoryStream(Files f, String regex);\n\n','Files.newDirectoryStream(Path p, String glob)\n\nDirectoryStream only uses glob\n\nso you dont have to say \"glob: *\"\n\nif you do it wont match anything','Input/Output',1,NULL),(1099,'DirectoryStream dm = ...\n\nFileSystem.getDefault().getDirectoryStream(Path p, String glob);\n\nFiles.getDefault().newDirectoryStream(File f, String regex);\n\nFiles.getDefault().newDirectoryStream(Path p, String glob);\n\nFiles.newDirectoryStream(Path p, String glob);\n\nFiles.getDirectoryStream(Files f, String regex);\n\n','Files.newDirectoryStream(Path p, String glob)\n\nDirectoryStream only uses glob\n\nso you dont have to say \"glob: *\"\n\nif you do it wont match anything','Input/Output',1,NULL),(1100,'DirectoryStream dm = ...\n\nFileSystem.getDefault().getDirectoryStream(Path p, String glob);\n\nFiles.getDefault().newDirectoryStream(File f, String regex);\n\nFiles.getDefault().newDirectoryStream(Path p, String glob);\n\nFiles.newDirectoryStream(Path p, String glob);\n\nFiles.getDirectoryStream(Files f, String regex);','Files.newDirectoryStream(Path p, String glob)\n\nDirectoryStream only uses glob\n\nso you dont have to say \"glob: *\"\n\nif you do it wont match anything','Input/Output',1,NULL),(1101,'try(DirectoryStream<Path> dm = Files.newDirectoryStream(home,\"glob:*\")){\n           for(Path path:dm){\n               System.out.println(path);\n           }\n           \n       } catch(IOException e){ System.out.println(e); }','comiles but will not match anything,\nDirectoryStream only takes globs so when you say glob: it trys to match a file\nlike that. ','Input/Output',1,NULL),(1102,'PathMatcher pm = ...\n\nFiles.getDefault().getPathMatcher(\"glob:file?.*\");\nFileSystems.getDefault().getPathMatcher(Path dir,\"TextFile?.*\");\nFileSystems.getPathMatcher(\"regex:TextFile?.*\");\nFiles.newPathMatcher(File file, String glob);\n\n','FileSystems.getDefault().getPathMatcher(\"glob:TextFile?.*\");\n\nthe argument to getPathMatcher is (String syntaxandpatter)\n\nso that means it supports glob or regex.\n\nsyntax:pattern\n\nglob:*.txt\nregex:.*{.txt}\n\n*Dont put a space after the : that wll be included in the pattern','Input/Output',1,NULL),(1103,'public static void main(String[] args){\n       \n       Path file = Paths.get(\"/home/maxbisesi/Public/Data/InnerDir/emptyFile.txt\");\n       try{\n           Files.createFile(file);\n           System.out.println(\"File created\");\n           Path dir = Paths.get(\"/home/maxbisesi/Public/Data/InnerDir\");\n           Files.delete(dir);\n       } catch(IOException e){\n           System.out.println(e);\n       }\n       \n            \n   }','DirectoryNotEmptyException\n\nFiles.delete cannot delete a directory thats not empty','Input/Output',1,NULL),(1104,' public static void main(String[] args){\n       	// imagine InnerDir contains one text file\n           File file = new File(\"/home/maxbisesi/Public/Data/InnerDir\");\n           file.mkdir();\n           System.out.println(\"File created\");\n           file.renameTo(new File(\"/home/maxbisesi/Public/Data/MaxsDir\"));\n           System.out.println(file);\n\n            \n   }','File created\n/home/maxbisesi/Public/Data/InnerDir\n\nyou can rename a File dir even if it is not empty','Input/Output',1,NULL),(1105,'public class Hello {\n    public static void main(String[] args){\n        ExecutorService ex = Executors.newSingleThreadExecutor(); \n        Future<Integer> futint = ex.submit(new FileCounter());\n        \n        System.out.println(\"Do other things while the files are getting counted\");\n        \n        try{\n            int count = futint.get();\n            System.out.println(count);\n            //ex.shutdown();\n        }catch(ExecutionException | InterruptedException e){\n            \n        }\n        \n    }\n    \n    \n}\n\nclass FileCounter implements Callable<Integer>{\n    private int fileCount = 0;\n    public Integer call() throws IOException{\n        fileCount = count(Paths.get(\"/home/maxbisesi/Documents\"));\n        return fileCount; \n    }\n    \n    public Integer count(Path d) throws IOException {\n        int count = 0;\n	try(DirectoryStream<Path> stream = Files.newDirectoryStream(d)){\n		for(Path path: stream){\n			count++;\n		}\n	}\n        return count;\n    }\n}\nwhat will happen ? ','it will print its two messages then continue to run,\n\nwithout shutdown() the executor doesn\'t know when to stop. ','Executors',1,NULL),(1106,'ExecutorService ex = \n//..\nex.shutdown(); // no more new task but finish the currently executing ones\n\ntry {\n	boolean term = ex.awaitTermination(2,TimeUnit.SECONDS);\n} catch(InterruptedException e){\n	//did not wait the full 2 seconds\n} finally {\n	if(!ex.isTerminated()) // are all tasks done ?\n	{\n		List<Runnable> unfinished = ex.shutdownNow();\n		//a collection of unfinished tasks\n	}\n}','got it \n\nshutdownNow() will call Thread.interrupt() in an attemtpt to terminate any \nunfinished tasks.','Executors',1,NULL),(1107,'public class Hello {\n    public static void main(String[] args){\n        try {\n            Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\");\n            PreparedStatement pst = conn.prepareStatement(\"Select * From employees limit 100\");\n            ResultSet rs = pst.executeQuery();\n            \n            Date d = new Date();\n            Calendar c = Calendar.getInstance();\n            c.setTime(d);\n\n            rs.first();\n            System.out.println(\"First entry:\");\n            System.out.println(\"Hired today: \"+d);\n            System.out.println(\"Start first upcoming monday: \"+firstNextMonday(d));\n            System.out.println(rs.getString(\"first_name\") + \" \" +rs.getString(\"last_name\"));\n            \n            c.add(Calendar.MONTH,-1);\n            Date monthago = c.getTime();\n            rs.last();\n            System.out.println(\"Last entry:\");\n            System.out.println(\"Hired a month ago: \"+monthago);\n            System.out.println(rs.getString(\"first_name\") + \" \" +rs.getString(\"last_name\"));\n        } catch(SQLException e){ }\n        \n    }\n    \n    public static Date firstNextMonday(Date d){\n        Calendar c = Calendar.getInstance();\n        c.setTime(d);\n        \n        while(c.get(Calendar.DAY_OF_WEEK) != c.MONDAY){\n            //c.add(1,DAY_OF_WEEK);\n            c.add(c.DAY_OF_WEEK,1);\n        }\n        \n        return c.getTime();\n        \n    }\n}','First entry:\nHired today: Mon Aug 07 16:43:51 EDT 2017\nStart first upcoming monday: Mon Aug 07 16:43:51 EDT 2017\nMicheal Boyd\nLast entry:\nHired a month ago: Fri Jul 07 16:43:51 EDT 2017\nVishv Zockler\n','Executors',1,NULL),(1108,'create a fixed thread pool...\n\nExecutor ex = ExecutorService.newFixedThreadPool(4);\nExecutor ex = Executor.newFixedThreadPool(4);\nExecutorService = ExecutorService.newFixedThreadPool(4);\nExecutorService = Executors.newFixedThreadExecutor(4);','ExecutorService ex = Executors.newFixedThreadPool(4);\n\nits none of those\nTEST!!','Executors',1,NULL),(1109,'public class Hello {\n\n    private static ArrayBlockingQueue<String> abq = new ArrayBlockingQueue<>(20);\n\n    public static void main(String[] args) {\n        //ExecutorService ex = ExecutorService.newFixedThreadPool(4);\n        ExecutorService ex = Executors.newFixedThreadPool(4);\n        Future<?> fut = ex.submit(new FileLister());\n        try{\n            System.out.println(fut.get()); // will print null\n        } catch(ExecutionException | InterruptedException e){ }\n        \n        for(String file : abq){\n            System.out.println(file+\" \");\n        }\n\n    }\n\n    static class FileLister implements Runnable {\n        public void run() {\n            Path home = Paths.get(\"/home/maxbisesi\");\n            try (DirectoryStream<Path> stream = Files.newDirectoryStream(home)) {\n                for (Path path : stream) {\n                    boolean added = false;\n                    added = abq.offer(path.toString());\n                    System.out.println(\"added: \"+added);\n\n                    if (!added) {\n                        System.out.println(\"queue is full offer will not add anymore\");\n                    }\n                }\n            } catch (IOException e) { }\n        }\n    }\n}','added: true\nadded: true\nadded: true\nadded: true\nadded: true\nadded: true\nadded: true\nadded: true\nadded: true\nadded: true\nadded: true\nadded: true\nadded: true\nadded: true\nadded: true\nadded: true\nadded: true\nadded: true\nadded: true\nadded: true\nadded: false\nqueue is full offer will not add anymore\nadded: false\nqueue is full offer will not add anymore\nadded: false\nqueue is full offer will not add anymore\nadded: false\nqueue is full offer will not add anymore\nadded: false\nqueue is full offer will not add anymore\nadded: false\nqueue is full offer will not add anymore\nadded: false\nqueue is full offer will not add anymore\nadded: false\nqueue is full offer will not add anymore\nadded: false\nqueue is full offer will not add anymore\nadded: false\nqueue is full offer will not add anymore\nadded: false\nqueue is full offer will not add anymore\nadded: false\nqueue is full offer will not add anymore\nadded: false\nqueue is full offer will not add anymore\nadded: false\nqueue is full offer will not add anymore\nnull\n/home/maxbisesi/.config \n/home/maxbisesi/.nano \n/home/maxbisesi/Desktop \n/home/maxbisesi/.bash_history \n/home/maxbisesi/Templates \n/home/maxbisesi/examples.desktop \n/home/maxbisesi/.bashrc \n/home/maxbisesi/.gnupg \n/home/maxbisesi/.java \n/home/maxbisesi/.xsession-errors \n/home/maxbisesi/.local \n/home/maxbisesi/.dmrc \n/home/maxbisesi/.Xauthority \n/home/maxbisesi/.ICEauthority \n/home/maxbisesi/Music \n/home/maxbisesi/qb_aug6.sql \n/home/maxbisesi/Documents \n/home/maxbisesi/NetBeansProjects \n/home/maxbisesi/.netbeans \n/home/maxbisesi/Downloads ','Concurrency',1,NULL),(1110,'public class Hello {\n    public static void main(String[] dicks){\n        PriorityQueue<Animal> q = new PriorityQueue<>();\n        \n        q.add(new Animal(5,\"Sheep\"));\n        q.offer(new Animal(6,\"Goat\"));\n        q.offer(new Animal(10,\"Cow\"));\n        q.offer(new Animal(12,\"Bull\"));\n        q.offer(new Animal(3,\"Cat\"));\n        q.offer(new Animal(7,\"Sloth\"));\n        \n        System.out.println(q.remove());\n        System.out.println(q.remove(new Animal(7,\"Sloth\")));\n        \n        while(!q.isEmpty()){\n            System.out.println(q.poll());\n        }\n    }\n}\n\nclass Animal implements Comparable<Animal> {\n    private Integer size;\n    private String name;\n    \n    public Animal(int x, String y){\n        size = x;\n        name = y;\n    }\n    public Animal(){\n        size = 0;\n        name = \"\";\n    }\n\n    public int getSize() {\n        return size;\n    }\n\n    public String getName() {\n        return name;\n    }\n    \n    public String toString(){\n        return name;\n    }\n    \n    public int compareTo(Animal o){\n        return size.compareTo(o.getSize());\n        \n    }\n    \n        \n    public boolean equals(Object o){\n        if((o instanceof Animal)){\n            if((((Animal)o).getSize() == this.size) && (((Animal)o).getName().equals(name) ))\n                return true;\n            return false;           \n        } \n        return false;\n    }\n\n}','Cat\ntrue\nSheep\nGoat\nCow\nBull\n\nqueues remove from the head, here remove() returns the object removed,\nthe remove(E e) return true or false, the eleemnts are sorted according to\ntheir compareTo which orders in ascending order by size. ','Collections',1,NULL),(1111,'public static void main(String[] args){\n        try{\n            Path p = Paths.get(\"/home/maxbisesi/Public/GenDir/genFile.txt\");\n            Files.createFile(p);\n        } catch(IOException e){System.out.println(e);}\n        \n        \n    }\n\nGenDir directory does not exist. ','java.nio.file.NoSuchFileException: /home/maxbisesi/Public/GenDir/genFile.txt\n\nthe directory must exist before a file is created in it. ','Input/Output',1,NULL),(1112,' public void addFlashCard(Card c) {\n        try{\n            jrs.moveToInsertRow();\n            jrs.updateString(\"answer\",c.getAnswer());\n            jrs.updateString(\"card\",c.getCard());\n            jrs.updateString(\"category\",c.getCategory());\n            jrs.updateRow();\n            \n            System.out.printf(\"Flash Card added: today: %1$03d \\n last added:\\n %2$s \\n category:%3$s\",todaysCount,c.getCard(),c.getCategory());\n            todaysCount++;\n        } catch(SQLException e){\n            System.out.println(\"something went wrong adding flashcards to rowset\");\n            System.out.println(e);\n        }\n    }','It should be jrs.insertRow(), the docs say that updateRow cannot be called\nwhile on the insert row. \n\nThis will not work, will throw a SQLException','JDBC',1,NULL),(1113,'public class Hello {\n\n    public static void main(String[] args) {\n        new Hello().printDateTime(Paths.get(\"/home/maxbisesi\"));\n    }\n\n    public void printDateTime(Path d) {\n        DateFormat df = DateFormat.getDateInstance(DateFormat.LONG);\n        DateFormat dftime = DateFormat.getTimeInstance(DateFormat.SHORT);\n        try {\n            BasicFileAttributes ba = Files.readAttributes(d, BasicFileAttributes.class);\n            String creationDate = df.format(ba.creationTime().toMillis());\n            String lastAccessedDate = df.format(ba.lastAccessTime().toMillis());\n            String lastModifiedDate = df.format(ba.lastModifiedTime().toMillis());\n\n            String creationTime = dftime.format(ba.creationTime().toMillis());\n            String lastAccessedTime = dftime.format(ba.lastAccessTime().toMillis());\n            String lastModifiedTime = dftime.format(ba.lastModifiedTime().toMillis());\n\n            System.out.println(ba.isDirectory());\n\n            System.out.println(\"last modified: \" + lastModifiedDate + \" at: \" + lastModifiedTime);\n            System.out.println(\"last accessed: \" + lastAccessedDate + \" at: \" + lastAccessedTime);\n            System.out.println(\"created: \" + creationDate + \" at: \" + creationTime);\n\n        } catch (IOException e) { System.out.println(e);}\n\n    }\n}','true\nlast modified: August 8, 2017 at: 12:14 PM\nlast accessed: August 8, 2017 at: 3:58 PM\ncreated: August 8, 2017 at: 12:14 PM','Strings',1,NULL),(1114,'public class Hello {\n\n    public static void main(String[] args) {\n        Path home = Paths.get(\"/home/maxbisesi\");\n        Files.walkFileTree(home,new FileInfoPrinter());\n    }\n\n    public void printDateTime(Path d) {\n        DateFormat df = DateFormat.getDateInstance(DateFormat.LONG);\n        DateFormat dftime = DateFormat.getTimeInstance(DateFormat.SHORT);\n        try {\n            BasicFileAttributes ba = Files.readAttributes(d, BasicFileAttributes.class);\n            String creationDate = df.format(ba.creationTime().toMillis());\n            String lastAccessedDate = df.format(ba.lastAccessTime().toMillis());\n            String lastModifiedDate = df.format(ba.lastModifiedTime().toMillis());\n\n            String creationTime = dftime.format(ba.creationTime().toMillis());\n            String lastAccessedTime = dftime.format(ba.lastAccessTime().toMillis());\n            String lastModifiedTime = dftime.format(ba.lastModifiedTime().toMillis());\n\n            System.out.println(\"directory: \" + ba.isDirectory());\n\n            System.out.println(\"last modified: \" + lastModifiedDate + \" at: \" + lastModifiedTime);\n            System.out.println(\"last accessed: \" + lastAccessedDate + \" at: \" + lastAccessedTime);\n            System.out.println(\"created: \" + creationDate + \" at: \" + creationTime);\n\n        } catch (IOException e) {\n            System.out.println(e);\n        }\n\n    }\n\n    class FileInfoPrinter extends SimpleFileVisitor<Path> {\n\n        public FileVisitResult preVisitDirectory(Path file, BasicFileAttributes attrs) {\n            System.out.print(file);\n            printDateTime(file);\n            return FileVisitResult.CONTINUE;\n        }\n\n    }\n}','WNC unreported IOException at Files.walkFileTree()\n\nnon static inner class FileInfoPrinter cant be access from static context','Strings',1,NULL),(1115,'public static void main(String[] args) {\n        Path home = Paths.get(\"/home/maxbisesi\");\n        System.out.println(home.getFileName());\n    }\n}','maxbisesi\n\ngetFileName() is different from getName(int index)\n\nkeep in mind that getFileName() and getName return a Path','Input/Output',1,NULL),(1116,'public class Hello {\n\n    public static void main(String[] args) {\n        Path home = Paths.get(\"/home/maxbisesi\");\n        Hello h = new Hello();\n        Hello.FileInfoPrinter fip = h.new FileInfoPrinter();\n        try{\n            Files.walkFileTree(home,fip);\n        }catch(IOException e){ }\n    }\n\n    public static void printDateTime(Path d) {\n        DateFormat df = DateFormat.getDateInstance(DateFormat.LONG);\n        DateFormat dftime = DateFormat.getTimeInstance(DateFormat.SHORT);\n        try {\n            BasicFileAttributes ba = Files.readAttributes(d, BasicFileAttributes.class);\n            String creationDate = df.format(ba.creationTime().toMillis());\n            String lastAccessedDate = df.format(ba.lastAccessTime().toMillis());\n            String lastModifiedDate = df.format(ba.lastModifiedTime().toMillis());\n\n            String creationTime = dftime.format(ba.creationTime().toMillis());\n            String lastAccessedTime = dftime.format(ba.lastAccessTime().toMillis());\n            String lastModifiedTime = dftime.format(ba.lastModifiedTime().toMillis());\n\n            System.out.println(\"directory: \" + ba.isDirectory());\n            System.out.println(\"\");\n            System.out.println(\"last modified: \" + lastModifiedDate + \" at: \" + lastModifiedTime);\n            System.out.println(\"last accessed: \" + lastAccessedDate + \" at: \" + lastAccessedTime);\n            System.out.println(\"created: \" + creationDate + \" at: \" + creationTime);\n            System.out.println(\"\");\n\n        } catch (IOException e) {\n            System.out.println(e);\n        }\n\n    }\n\n    class FileInfoPrinter extends SimpleFileVisitor<Path> {\n        private Pattern p = Pattern.compile(\"\\\\..*\");\n        private Matcher hidden;\n        \n\n        public FileVisitResult preVisitDirectory(Path file, BasicFileAttributes attrs) {\n            hidden = p.matcher(file.getFileName().toString());\n            if(hidden.find()){\n                return FileVisitResult.SKIP_SUBTREE;\n            }\n            System.out.print(file);\n            System.out.println(\"\");\n            printDateTime(file);\n            return FileVisitResult.CONTINUE;\n        }\n\n    }\n}','This will print out the contents of the home directory but skipping hidden files\nthat begin with a . like .config.\n\nremember that FileVisitor goes down as deep as it can before returning back up the\ntree.\n\nand files and directories at the same level can get visited in any order. \n\n\n/home/maxbisesi\ndirectory: true\n\nlast modified: August 8, 2017 at: 12:14 PM\nlast accessed: August 8, 2017 at: 3:58 PM\ncreated: August 8, 2017 at: 12:14 PM\n\n/home/maxbisesi/Desktop\ndirectory: true\n\nlast modified: July 21, 2017 at: 9:15 AM\nlast accessed: August 9, 2017 at: 11:33 AM\ncreated: July 21, 2017 at: 9:15 AM\n\n/home/maxbisesi/Templates\ndirectory: true\n\nlast modified: July 21, 2017 at: 9:15 AM\nlast accessed: August 9, 2017 at: 11:33 AM\ncreated: July 21, 2017 at: 9:15 AM\n\n/home/maxbisesi/Music\ndirectory: true\n\nlast modified: July 21, 2017 at: 9:15 AM\nlast accessed: August 9, 2017 at: 11:33 AM\ncreated: July 21, 2017 at: 9:15 AM\n\n/home/maxbisesi/Documents\ndirectory: true\n\nlast modified: July 24, 2017 at: 9:51 AM\nlast accessed: August 9, 2017 at: 11:33 AM\ncreated: July 24, 2017 at: 9:51 AM\n\n/home/maxbisesi/Documents/Code\ndirectory: true\n\nlast modified: August 8, 2017 at: 11:59 AM\nlast accessed: August 8, 2017 at: 11:59 AM\ncreated: August 8, 2017 at: 11:59 AM\n\n/home/maxbisesi/Documents/resumes\ndirectory: true\n\nlast modified: July 24, 2017 at: 9:51 AM\nlast accessed: August 9, 2017 at: 11:33 AM\ncreated: July 24, 2017 at: 9:51 AM\n\n/home/maxbisesi/NetBeansProjects\ndirectory: true\n\nlast modified: July 29, 2017 at: 12:03 PM\nlast accessed: August 9, 2017 at: 11:33 AM\ncreated: July 29, 2017 at: 12:03 PM\n\n/home/maxbisesi/NetBeansProjects/SourceManager\ndirectory: true\n\nlast modified: July 22, 2017 at: 2:52 PM\nlast accessed: August 8, 2017 at: 3:09 PM\ncreated: July 22, 2017 at: 2:52 PM\n\n/home/maxbisesi/NetBeansProjects/SourceManager/dist\ndirectory: true\n\nlast modified: July 22, 2017 at: 2:52 PM\nlast accessed: August 9, 2017 at: 11:33 AM\ncreated: July 22, 2017 at: 2:52 PM\n\n/home/maxbisesi/NetBeansProjects/SourceManager/nbproject\ndirectory: true\n\nlast modified: July 22, 2017 at: 12:35 PM\nlast accessed: August 8, 2017 at: 3:09 PM\ncreated: July 22, 2017 at: 12:35 PM\n','Input/Output',1,NULL),(1117,'public class Hello {\n\n    public static void main(String[] args) {\n        Path home = Paths.get(\"/home/maxbisesi\");\n        Hello h = new Hello();\n        Hello.FileInfoPrinter fip = h.new FileInfoPrinter();\n        try{\n            Files.walkFileTree(home,fip);\n        }catch(IOException e){ }\n    }\n\n    public static void printDateTime(Path d) {\n        DateFormat df = DateFormat.getDateInstance(DateFormat.LONG);\n        DateFormat dftime = DateFormat.getTimeInstance(DateFormat.SHORT);\n        try {\n            //BasicFileAttributes ba = Files.readAttributes(d, BasicFileAttributes.class);\n            BasicFileAttributes ba = new BasicFileAttributes(d, BasicFileAttributes.class);\n            String creationDate = df.format(ba.creationTime().toMillis());\n            String lastAccessedDate = df.format(ba.lastAccessTime().toMillis());\n            String lastModifiedDate = df.format(ba.lastModifiedTime().toMillis());\n\n            String creationTime = dftime.format(ba.creationTime().toMillis());\n            String lastAccessedTime = dftime.format(ba.lastAccessTime().toMillis());\n            String lastModifiedTime = dftime.format(ba.lastModifiedTime().toMillis());\n\n            System.out.println(\"directory: \" + ba.isDirectory());\n            System.out.println(\"\");\n            System.out.println(\"last modified: \" + lastModifiedDate + \" at: \" + lastModifiedTime);\n            System.out.println(\"last accessed: \" + lastAccessedDate + \" at: \" + lastAccessedTime);\n            System.out.println(\"created: \" + creationDate + \" at: \" + creationTime);\n            System.out.println(\"\");\n\n        } catch (IOException e) {\n            System.out.println(e);\n        }\n\n    }\n\n    class FileInfoPrinter extends SimpleFileVisitor<Path> {\n        private Pattern p = Pattern.compile(\"\\\\..*\");\n        private Matcher hidden;\n        \n\n        public FileVisitResult preVisitDirectory(Path file, BasicFileAttributes attrs) {\n            hidden = p.matcher(file.getFileName().toString());\n            if(hidden.find()){\n                return FileVisitResult.SKIP_SUBTREE;\n            }\n            System.out.print(file);\n            System.out.println(\"\");\n            printDateTime(file);\n            return FileVisitResult.CONTINUE;\n        }\n\n    }\n}','BasicFileAttributes is absract cannot be instantiated.\n\nshould be:\n\n	BasicFileAttributes ba = Files.readAttributes(path,BasicFileAttributes.class);','Input/Output',1,NULL),(1118,'class FileInfoPrinter extends SimpleFileVisitor<Path> {\n        private Pattern p = Pattern.compile(\"\\\\..*\");\n        private Matcher hidden;\n        \n\n        public FileVisitResult preVisitDirectory(Path file, BasicFileAttributes attrs){\n            hidden = p.matcher(file.getFileName().toString());\n            if(hidden.find()){\n                return FileVisitResult.SKIP_SUBTREE;\n            }\n            //makeFileCreatedOnMonday(file);\n            System.out.print(file);\n            System.out.println(\"\");\n            printDateTime(file);\n            return FileVisitResult.CONTINUE;\n        }\n        \n        public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\n            makeFileCreatedOnMonday(file);\n            return FileVisitResult.CONTINUE;\n        }\n\n    }','FileVisitor method throw IOExceptions,\n\nbut in overrides if you choose not to declare an exception that is ok, demonstrated\nhere. ','Input/Output',1,NULL),(1119,'class DateAsker implements Runnable {\n    private final int priority;\n    \n    public DateAsker(){\n        priority = ThreadLocalRandom.current().nextInt(0,5);\n    }\n    \n    \n    public void run(){\n        DateGiver dg = DateGiver.heyyou();\n        BlockingQueue<Date> bq = dg.availability();\n        Calendar c = Calendar.getInstance();\n        \n        try{\n            if(priority >= 4){\n                \n                Date next = bq.take();// blocks until available\n                c.setTime(next);\n                c.add(Calendar.DAY_OF_WEEK,2);\n                bq.put(c.getTime()); // returns void blocks until spac is available\n                \n            } else if(priority < 4 && priority >= 3){\n                \n                Date next = bq.poll(2000,TimeUnit.SECONDS);\n                c.setTime(next);\n                //c.add(Calendar.WEEK_IN_MONTH,2);\n                c.add(Calendar.WEEK_OF_MONTH,2);\n                bq.offer(c.getTime()); // returns true if object was added. false if the queeu is bouned and full  \n\n            } else {\n                Date next = bq.element();// gets the head of the queue without removing it. Throws NoSuchElementException if queue is empty\n                c.roll(Calendar.DAY_OF_MONTH,6);\n                c.roll(Calendar.HOUR_OF_DAY,20);\n                c.set(Calendar.MONTH,Calendar.JANUARY);\n                \n                bq.add(c.getTime()); // throws IllegalStateException if queue is bounded and full.\n                        \n            }\n        } catch(InterruptedException e){\n            \n        }\n\n        \n        \n    }\n}','got it','Concurrency',1,NULL),(1120,'class DateGiver implements Runnable {\n    private BlockingQueue<Date> dates = new ArrayBlockingQueue<>(25);\n    private static final DateGiver INSTANCE = new DateGiver();\n    \n    private DateGiver(){\n        \n    }\n    \n    public static DateGiver heyyou(){\n        return INSTANCE;\n    }\n\n    public void run(){\n        try{\n            Date d = new Date();\n            Calendar c = Calendar.getInstance();\n            c.setTime(d);\n            while(dates.peek() != null){\n                c.add(Calendar.DAY_OF_MONTH, 1);\n                dates.put(c.getTime());\n            }\n        }catch(InterruptedException e){\n            System.out.println(\"Sorry I got interrupted\");\n        }\n        \n    }\n    \n    public BlockingQueue<Date> availability(){\n        return dates;\n    }\n}\n\nwhat design pattern is this ?','Singelton','OOP',1,NULL),(1121,'class DateGiver implements Runnable {\n    private BlockingQueue<Date> dates = new ArrayBlockingQueue<>(25);\n    private static final DateGiver INSTANCE = new DateGiver();\n    \n    private DateGiver(){\n        \n    }\n    \n    public DateGiver heyyou(){\n        return INSTANCE;\n    }\n\n    public void run(){\n        try{\n            Date d = new Date();\n            Calendar c = Calendar.getInstance();\n            c.setTime(d);\n            while(dates.peek() != null){\n                c.add(Calendar.DAY_OF_MONTH, 1);\n                dates.put(c.getTime());\n            }\n        }catch(InterruptedException e){\n            System.out.println(\"Sorry I got interrupted\");\n        }\n        \n    }\n    \n    public BlockingQueue<Date> availability(){\n        return dates;\n    }\n}\n\nWhat is missing from making this pattern singelton ? ','The instance getting method needs to be static. ','OOP',1,NULL),(1122,'class DateGiver implements Runnable {\n    private BlockingQueue<Date> dates = new ArrayBlockingQueue<>();\n    private static final DateGiver INSTANCE = new DateGiver();\n    \n    private DateGiver(){\n        \n    }\n    \n    public static DateGiver heyyou(){\n        return INSTANCE;\n    }\n\n    public void run(){\n        try{\n            Date d = new Date();\n            Calendar c = Calendar.getInstance();\n            c.setTime(d);\n            while(dates.peek() != null){\n                c.add(Calendar.DAY_OF_MONTH, 1);\n                dates.put(c.getTime());\n            }\n        }catch(InterruptedException e){\n            System.out.println(\"Sorry I got interrupted\");\n        }\n        \n    }\n    \n    public BlockingQueue<Date> availability(){\n        return dates;\n    }\n}','WNC, an ArrayBlockingQueue is bounded and needs to be created \nwith an initial capacity.\n\n','OOP',1,NULL),(1123,'Which concurrent collection is Optionally bounded ?','LinkedBlockingQueue','Concurrency',1,NULL),(1124,'public class Hello {\n\n    public static void main(String[] args) {\n        \n        Burnable stick = new Burnable(){\n            public void burn(){\n                System.out.println(\"Theres \"+people+\" people here so get the fire going\");\n            }\n            \n            public int unburn(){\n                System.out.println(\"That\'s impossible\");\n                return 0;\n            }\n            \n            public void shakeoff(){\n                System.out.println(\"That was my shoe!\");\n            }\n            \n            public void lookwhosHere(){\n                people++;\n                System.out.println(\"hey now theres \"+people+\" here.\");\n            }\n            \n        };\n    }\n\n}\n\ninterface Burnable{\n    int people = 10;\n    void burn();\n    void shakeoff();\n    int unburn();\n}','WNC cannot assign a value to final variable people. \n\ninterface variables are implicity constants. ','Concurrency',1,NULL),(1125,'public class Hello<T> {\n    \n    public static void main(String[] args){\n        \n        Dog d = new Dog();\n        \n        ArrayList<? extends Dog> c = new ArrayList<Beagle>();\n        \n        Beagle a = c.get(0);\n    } \n}\n\nclass Animal{}\nclass Dog extends Animal { }\nclass Beagle extends Dog { }\nclass Marly extends Beagle{ }','WNC you cannot guarentee that c wont be pointing to a list<Dog> so \nyou cannot assign what is coming out to a Beagle reference. It could be \nAnimal or Dog.','Concurrency',1,NULL),(1126,'static <T> void doSomething(List<? super T> list1, List<? extends T> list2) { }\n\ndoSomething(new ArrayList<Object>(), new ArrayList<String>());\n\nWould T type evaluate as Object or String?\n','T does not bind to a specific class here. \n\n\nThis call does not bind T to a specific class. Java does not need to know the exact T because of type erasure implementation of the generics. As long as the types that you pass are consistent with the declaration, the code should compile; in your case, lists of Object and String are consistent with the declaration.\n\nLet\'s expand your code a little so that we could force binding of T to a specific type. Perhaps the easiest way to do it is to pass Class<T>, like this:\n\nstatic <T> void doSomething(List<? super T> list1, List<? extends T> list2, Class<T> cl) {\n    System.out.println(cl);\n}\n\nNow let us try calling doSomething with String.class and with Object.class:\n\ndoSomething(new ArrayList<Object>(), new ArrayList<String>(), Object.class);\ndoSomething(new ArrayList<Object>(), new ArrayList<String>(), String.class);\n\nBoth calls successfully compile, producing the output\n\nclass java.lang.Object\nclass java.lang.String','Generics',1,NULL),(1127,'public class WildcardFixed {\n\n    void foo(List<?> i) {\n        fooHelper(i);\n    }\n\n\n    // Helper method created so that the wildcard can be captured\n    // through type inference.\n    private <T> void fooHelper(List<T> l) {\n        l.set(0, l.get(0));\n    }\n\n}','helper methods can be used to capture the wildcard','Generics',1,NULL),(1128,'public class Hello {\n    \n    public static void main(String[] args){\n        ArrayList<Object> dogs = new ArrayList<>();\n        ArrayList<Object> marlies = new ArrayList<>();\n        \n        copy(dogs,marlies);\n    } \n    \n     public static <T> void copy(List<? super T> dest, List<? extends T> src) {\n         for(T t : src){\n             dest.add(t);\n         }\n    }  \n}\n\nclass Animal{}\nclass Dog extends Animal { }\nclass Beagle extends Dog { }\nclass Marly extends Beagle{ }','Compiles fine, any thing coming out of src should be able to be added to dest. \n','Generics',1,NULL),(1129,'public class Hello {\n    \n    public static void main(String[] args){\n        ArrayList<Marly> dogs = new ArrayList<>();\n        ArrayList<Animal> marlies = new ArrayList<>();\n        \n        copy(marlies, dogs);\n    } \n    \n     public static <T> void copy(List<? super T> dest, List<? extends T> src) {\n         for(T t : src){\n             dest.add(t);\n         }\n    }  \n}\n\nclass Animal{}\nclass Dog extends Animal { }\nclass Beagle extends Dog { }\nclass Marly extends Beagle{ }','compiles, anything coming the source has to be of type that is safe to be added\nto the dest. ','Generics',1,NULL),(1130,'public class Hello {\n  public static void main(String[] args){\n      LinkedHashSet<Turtle> t = new LinkedHashSet<>();\n      t.add(new Turtle(1)); t.add( new Turtle(2)); t.add(new Turtle(1));\n      t.add(new Turtle(1)); t.add( new Turtle(2)); t.add(new Turtle(1));\n      t.add(new Turtle(1)); t.add(new Turtle(1)); t.add(new Turtle(1));\n      t.add(new Turtle(1)); t.add(new Turtle(1)); t.add(new Turtle(1));\n      \n      System.out.println(t.size());\n      for(Turtle x : t){\n          System.out.println(x);\n      }\n\n  }\n   \n}\n\ninterface Hungry<E> { void munch(E x); }\nabstract class Animal { }\nabstract class Plant { }\nclass Grass extends Plant { }\n\nclass Turtle {\n    int size;\n    String name;\n    public Turtle(int z){\n        size = z;\n        name = \"Turtle \"+size;\n    }\n    \n    public boolean equals(Object o){\n        return (this.size == ((Turtle)o).size);\n    }\n    \n    public String toString(){\n        return name;\n    }\n    \n    //public int hashCode() { return size/5; }\n}','12\nTurtle 1\nTurtle 2\nTurtle 1\nTurtle 1\nTurtle 2\nTurtle 1\nTurtle 1\nTurtle 1\nTurtle 1\nTurtle 1\nTurtle 1\nTurtle 1\n\nwhile it\'s true that Set don\'t allow duplicates it disallows them by using the \nequals method it can only use equals to among elements in the same bucket. So Because\nturtle didn\'t implement hashCode() all the elements went into seperate buckets\nand there was nothing to compare against.','Collections',1,NULL),(1131,'public class Hello<T> {\n    public static void main(String[] args){\n        Animal cat = new Animal(5);\n        Animal bear = new Bear();\n        \n        cat.eat();\n        Animal.eat();\n        bear.eat();\n        Bear.eat();\n\n    } \n }\n\nclass Animal{\n    private int size;\n    public Animal(int s){\n        size = s;\n    }\n    public static void eat(){\n        System.out.println(\"all animals eat\");\n    }\n    public void makeSound(){\n            System.out.println(\"Sound!\");\n            \n    }\n    \n    public int getSize(){\n        return size;\n    }\n\n    public boolean equals(Object o){\n        // equals without instanceof \n        if(((Animal)o).getSize() == this.size){\n            return true;\n        } else {\n            return false;\n        }\n        \n    }\n}\n\nclass Bear extends Animal{\n    private static int ALLBEARSAREBIG = 100;\n    \n    public Bear(){\n        super(ALLBEARSAREBIG);\n        \n    }\n    \n    public static void eat(){\n        System.out.println(\"Eat salmon\");\n    }\n    \n}','all animals eat\nall animals eat\nall animals eat\nEat salmon','OOP',1,NULL),(1132,'class Hello {\n    public static void main(String[] args) {     \n        Path p1 = Paths.get(\"/home/max/tmp/\");\n        Path p2 = Paths.get(\"/tmp/google/file.txt\");\n        Path p3 = Paths.get(\"tmp/google/file.txt\");\n        System.out.println(p1.resolve(p2));\n        System.out.println(p1.relativize(p2));\n        System.out.println(p1.resolve(p3));\n        System.out.println(p1.relativize(p3));\n        \n    }\n\n}','/tmp/google/file.txt\n../../../tmp/google/file.txt\n/home/max/tmp/tmp/google/file.txt\nException in thread \"main\" java.lang.IllegalArgumentException: \'other\' is different type of Path\n\nif other is an abolute path resolve returns the other, p2 is  an absolute \npath.\n\na relative path cannot be contructed if only one of the paths have a root \ncomponent. ','Input/Output',1,NULL),(1133,'If one path is absolute and the other is relative relativize will throw \nan Illegal argument Exception.\n\nBoth have to be either relative or absolute. \n\n	Path p1 = Paths.get(\"/home/maxbisesi\");\n        Path p2 = Paths.get(\"Documents/Code\");\n        \n        System.out.println(p1.relativize(p2));\n        System.out.println(p1.resolve(p2));','got it\n\nrelativize: IllegalArgumentException\nresolve: /home/maxbisesi/Documents/Code','Input/Output',1,NULL),(1134,'If the other path is absolute relativize will return the other \n\n    \n        Path p1 = Paths.get(\"/home/max/tmp/\");\n        Path p2 = Paths.get(\"/tmp/google/file.txt\");\n\n        System.out.println(p1.resolve(p2));\n\n	/tmp/google/file.txt','got it','Input/Output',1,NULL),(1135,'class Hello {\n    public static void main(String[] args) {     \n        Path p1 = Paths.get(\"/home/max/tmp/\");\n        Path p2 = Paths.get(\"/tmp/google/file.txt\");\n        Path p3 = Paths.get(\"tmp/google/file.txt\");\n        Path p4 = Paths.get(\"src/dist/all\");\n        System.out.println(p1.resolve(p2));\n        System.out.println(p1.relativize(p2));\n        System.out.println(p1.resolve(p3));\n        System.out.println(p2.resolve(p3));\n        System.out.println(p3.relativize(p4));\n        \n    }\n\n}','/tmp/google/file.txt\n../../../tmp/google/file.txt\n/home/max/tmp/tmp/google/file.txt\n/tmp/google/file.txt/tmp/google/file.txt\n../../../src/dist/all','Input/Output',1,NULL),(1136,'Matcher.end() gives the position after the last character. \n\n	Pattern p = Pattern.compile(\".*y\");\n        Matcher m = p.matcher(\"yyxxxyxx\");\n						 012345678\n        \n        while(m.find()){\n            System.out.println(m.start());\n            System.out.println(m.group());\n            System.out.println(m.end());\n        }\n\nm.end() is 6','got it ','Strings',1,NULL),(1137,'public class Hello{\n    public static void main(String[] args){\n        Bango b1 = new Bango();\n        Bango b2 = new Bongo();\n        Bango b3 = new Bingo();\n        \n        Bongo b4 = b2;\n        Bongo b5 = (Bongo)b1;\n        Bango b6 = b3;\n        Bango b7 = (Bango) b3;\n        Bingo b8 = (Bingo)b1;\n        Bingo b9 = (Bingo) b3;\n        Bango b10 = (Bongo) b3;\n    \n    }\n}\n\nclass Bango { }\nclass Bongo extends Bango { }\nclass Bingo extends Bongo { }\n\nwhich throw a ClassCastException ?','b5 and b8\n\nA class Cast will result from trying to downcast. ','Strings',1,NULL),(1138,'public class Hello {\n    private String name = \"marco\";\n    private final static String gem = \"Gemini\";\n    private static String west = \"Eunech\";\n   \n    public static void main(String[] args) {\n        Hello h = new Hello();\n        h.methodlocal();\n    }\n    \n    public static void methodlocal(){\n        final int y = 56;\n        //System.out.println(name); //wouldnt compile\n        System.out.println(gem);\n        \n        \n        class Zombie {\n            public int size;\n            public static final int num = 5;\n        \n            public Zombie(int x){ size = x; System.out.println(gem); System.out.println(west);} //System.out.println(name); }\n            public void mone(){\n                System.out.println(\"ughhhg: \"+ size);\n            }\n            \n            public void accessTheLiving(){\n                System.out.println(\"local var: \"+y);\n            }\n            \n        }\n        \n        Zombie zom = new Zombie(7);\n        \n    }\n\n}','Gemini\nGemini\nEunech','Inner Classes',1,NULL),(1139,'public class Hello<T> {\n    public static void main(String[] args){\n\n        ArrayList<? extends Animal> c = makeArrayList(new Animal(5));\n        \n        \n    } \n    public static <G extends Animal> ArrayList<G> makeArrayList(G g){\n        ArrayList<G> genlist = new ArrayList();\n        \n        Animal max = new Animal(100);\n        Animal bear = new Animal(45);\n        Animal Hippo = new Animal(45);\n        \n        genlist.add(max); \n        genlist.add(bear);\n        genlist.add(Hippo);\n        return genlist;\n        \n    }\n}','Will not compile, at compile time the compiler does not know what type G is\ngoing to be even though its runtime type will be right, this can still not be\nallowed to compile. ','Generics',1,NULL),(1140,'public class Hello {\n    public static void main(String[] args){\n\n        ArrayList<? extends Animal> c = makeArrayList(new Animal());\n        ArrayList<? extends Animal> b = makeArrayList(new Dog());\n        \n        \n    } \n    public static <G extends Animal> ArrayList<G> makeArrayList(G g){\n        ArrayList<G> genlist = new ArrayList();\n        genlist.add(g);\n        \n        return genlist;\n        \n    }\n}\n\nclass Dog extends Animal{}\nclass Beagle extends Dog { }\nclass Animal{}','Compiles','Generics',1,NULL),(1141,'public class Hello {\n    public static void main(String[] args){\n\n        ArrayList<? extends Animal> c = makeArrayList(new Animal());\n        ArrayList<? extends Animal> b = makeArrayList(new Dog());\n        ArrayList<? super Dog> a = makeArrayList(new Beagle());\n        \n        \n    } \n    public static <G extends Animal> ArrayList<G> makeArrayList(G g){\n        ArrayList<G> genlist = new ArrayList();\n        genlist.add(g);\n        \n        return genlist;\n        \n    }\n}\n\nclass Dog extends Animal{}\nclass Beagle extends Dog { }\nclass Animal{}','Will not compile, \n\nhere makeArrayList is only bounded by the INPUT the output is pretty straightforward\nit is excactly type G. Which is Below Dog in the Heirarchy so a Beagle \nList could not be applied to a ? super Dog list. ','Generics',1,NULL),(1142,'public class Hello {\n    public static void main(String[] args){\n\n        ArrayList<? extends Animal> c = makeArrayList(new Animal());\n        ArrayList<? extends Animal> b = makeArrayList(new Dog());\n        ArrayList<? super Beagle> a = makeArrayList(new Beagle());\n        \n        \n    } \n    public static <G extends Animal> ArrayList<G> makeArrayList(G g){\n        ArrayList<G> genlist = new ArrayList();\n        genlist.add(g);\n        \n        return genlist;\n        \n    }\n}\n\nclass Dog extends Animal{}\nclass Beagle extends Dog { }\nclass Animal{}','This will compile.','Generics',1,NULL),(1143,'public class Hello {\n    public static void main(String[] args){\n        Printer<String> x = Printer.getInstance();\n\n    }\n    public static <T> void addAnimal(List<T> animals) {\n	animals.add(new Dog());\n    }\n    \n    public <G> ArrayList<G> makeArrayList(G g){\n        ArrayList<G> genlist = new ArrayList();\n        genlist.add(g);\n        return genlist;\n        \n    }\n}\n\nclass Dog{ }','Will not compile, cannot add Dog to ArrayList typed for T ','Generics',1,NULL),(1144,'public class Hello {\n    \n    public static void main(String[] args){\n        Path file = Paths.get(\"/home/maxbisesi/Public/Data/sumOftwointsinarray.txt\");\n        FileSearcher fs = new FileSearcher(file,\"\\\\b\\\\w\\\\w\\\\w\\\\b\");\n        ExecutorService es = Executors.newCachedThreadPool();\n        System.out.println(\"We\'re wating on your search results\");\n        Future<HashMap<Integer,String>> futuresearch = es.submit(fs);\n        \n        try{\n            HashMap<Integer,String> searchresults;\n            searchresults = futuresearch.get();\n            HashMap<Integer,String> moreresults = futuresearch.get();\n            \n            if(searchresults == null){\n                System.out.println(\"There were no results bro\");\n                System.exit(0);\n            }\n            for(Map.Entry<Integer,String> entry : searchresults.entrySet()){\n                System.out.println(entry.getKey()+\" \"+entry.getValue()+\"\\n\");\n            }\n            \n        }catch(ExecutionException | InterruptedException e){\n            System.out.println(e);\n        }\n    }\n}\n\nclass FileSearcher implements Callable<HashMap<Integer,String>> {\n    private Path fileToLoad;\n    private String regex;\n    public FileSearcher(Path file,String reg){\n        fileToLoad = file;\n        regex = reg;\n    }\n    \n    public HashMap<Integer,String> call() throws IOException{\n        int linenum = 0;\n        HashMap<Integer,String> map = new HashMap<>();\n        BufferedReader br = new BufferedReader(new FileReader(fileToLoad.toFile()));\n        Pattern p = Pattern.compile(regex);\n        Matcher m;\n        String line;\n        while((line = br.readLine()) != null){\n            map.put(++linenum,line);\n        }\n        return map;\n    }\n}\n\nWhat are the flaws here ? ','First if you dont shutdown an executorService it will keep running and the \nprogram will never end.\n\nSecond the regex patter created is never applied to the lines coming in.','General',1,NULL),(1145,'public class Hello {\n    \n    public static void main(String[] args){\n        String in = \"1 a 10 . 100 1000\";\n        Scanner s = new Scanner(in);\n        int accum\n        = 0;\n        for (int x = 0; x < 4; x++) {\n        accum += s.nextInt();\n        }\n        System.out.println(accum);\n    }\n}','Exception in thread \"main\" java.util.InputMismatchException\n\nfor trying to read a string in as an int thats an exception','Strings',1,NULL),(1146,'public static void main(String[] args) {\n            int x = 7;\n            assert (x == 6) ? \"x == 6\" : \"x != 6\";\n        }\n    }','Will not compile, String cannot be converted to boolean.\n\nthe additional info in an assert statement must be a string. ','Exceptions',1,NULL),(1147,'public class Hello {\n\n    public static void main(String[] args) {\n        try {\n            new Hello().go();\n        } catch (Exception e) {\n            System.out.println(e);\n        }\n    }\n\n    synchronized void go() throws InterruptedException {\n        Thread t1 = new Thread();\n        t1.start();\n        System.out.print(\"1 \");\n        t1.wait(5000);\n        System.out.print(\"2 \");\n    }\n}','IllegalMonitorStateException\n\nthe method go() is synchronized, that means it will lock onto to the currently\nexecuting object. which Here is this, or the \'new Hello()\'\n\na new Thread is started and then waited on but thats not allowed because go\nis synchronized onto the current object.\n\nit should be:\n\n	Thread t1 = new Thread();\n        t1.start();\n        synchronized(t1){\n            System.out.print(\"1 \");\n            t1.wait(5000);\n            System.out.print(\"2 \");\n        }\n        \n        System.out.println(\"All done, main thread\");','Threads',1,NULL),(1148,'public class Hello {\n\n    public static void main(String[] args) {\n        try {\n            new Hello().go();\n        } catch (Exception e) {\n            System.out.println(e);\n        }\n    }\n\n    synchronized void go() throws InterruptedException {\n        Thread t1 = new Thread();\n        t1.start();\n        synchronized(t1){\n            System.out.print(\"1 \");\n            t1.wait(5000);\n            System.out.print(\"2 \");\n        }\n        \n        System.out.println(\"All done, main thread\");\n    }\n}','1 2 All done, main thread','Threads',1,NULL),(1149,'class Printer<? extends Animal> {\n    private ArrayList<T> joblist = new ArrayList<>();\n    private T instance;\n    \n    public Printer(){\n        \n    }\n    \n    public Printer(T b){\n       instance = b;\n    }\n    \n    public void addJob(T t){\n        joblist.add(t);\n    }\n    \n    public void makeSound() {\n        instance.makeSound();\n    }\n    \n    public T getAnewT(){\n        return instance;\n    }\n}\n\nclass Animal{public void makeSound(){\n            System.out.println(\"Sound!\");\n}\n}\nclass Dog extends Animal{}\nclass Beagle extends Dog{}','WNC, \n\nyou cannot use a wildcard when creating a Generic class. ','Generics',1,NULL),(1150,' public static void main(String[] args) {\n        String s = null;\n        if(s instanceof String){ System.out.println(\"It Worked\"); } \n        else { System.out.println(\"No\"); }\n \n    }','If a reference is null it is not an instance of anything. ','General',1,NULL),(1151,'int[] nums = new int[4];\nif(nums instanceof Obejct){\n	sout( \"true\");\n}','true arrays are always objects any array of any type or primitive.','General',1,NULL),(1152,' public static void main(String[] args) {\n        List<Object> strlist = new ArrayList<>();\n        ArrayList<String> arraylst = new ArrayList<>();\n        ArrayList<Object> oblist = new ArrayList<>();\n        \n        if(arraylst instanceof strlist){\n            System.out.println(\"it worked!\");\n        } else{\n            System.out.println(\"no\");\n        }\n\n \n    }','WNC you do not use instanceof to compare two references ','General',1,NULL),(1153,' public static void main(String[] args) {\n        List<Object> strlist = new ArrayList<>();\n        ArrayList<String> arraylst = new ArrayList<>();\n        ArrayList<Object> oblist = new ArrayList<>();\n        \n        if(arraylst instanceof List<String>){\n            System.out.println(\"it worked!\");\n        } else{\n            System.out.println(\"no\");\n        }\n\n \n    }','WNC, instanceof cannot test generic types. Generics are a compile time feature','General',1,NULL),(1154,'public static void main(String[] args) {\n        Path p1 = Paths.get(\"/home/maxbisesi/Public/Data/TextFile1.txt\");\n        \n        System.out.println(p1.getName(0));\n        System.out.println(p1.getName(1));\n        System.out.println(p1.getName(2));\n        System.out.println(p1.getName(3));\n        System.out.println(p1.getName(4));\n    }','home\nmaxbisesi\nPublic\nData\nTextFile1.txt','Input/Output',1,NULL),(1155,'public static void main(String[] args) {\n        Path p1 = Paths.get(\"/home/maxbisesi/Public/Data/TextFile1.txt\");\n        System.out.println(p1.getNameCount());\n        System.out.println(p1.getName(5));\n    }','5\nIllegalArgumentException\n\nwith getName() the element that is the closest to the root directory, has an\nindex of 0. \n\nthrows an IllegalArgumentException if the index is greater than the number \nof elements. ','Input/Output',1,NULL),(1156,'public static void main(String[] args) {\n        Path p1 = Paths.get(\"/home/maxbisesi/Public/Data/TextFile1.txt\");\n        Path p2 = Paths.get(\"maxbisesi/Public/Data\");\n        System.out.println(p1.getRoot());\n        System.out.println(p2.getRoot());\n        \n    }','/\nnull\n\nReturns the root component of this path as a Path object, or null if this \npath does not have a root component.','Input/Output',1,NULL),(1157,'public static void main(String[] args) {\n        Path p1 = Paths.get(\"/home/maxbisesi/Public/Data/TextFile1.txt\");\n        Path p2 = Paths.get(\"maxbisesi/Public/Data\");\n        String root = p1.getRoot();        \n    }','WNC,\n\ngetRoot() getName() subPath() resolve() relativize() toAbsolute() \n\nall return Path objects','Input/Output',1,NULL),(1158,'public static void main(String[] args) {\n\n        Path p1 = Paths.get(\"/home/maxbisesi/Public/Data/TextFile1.txt\");\n        Path p2 = Paths.get(\"maxbisesi/Public/Data\");\n        \n        boolean ab = p1.isAbsolute();\n        boolean ab2 = p2.isAbsolute();\n        \n        System.out.println(ab);\n        System.out.println(ab2);\n        \n    }','true\nfalse','Input/Output',1,NULL),(1159,' public static void main(String[] args) {\n\n        Path p1 = Paths.get(\"/home/maxbisesi/Public/Data/TextFile1.txt\");\n        \n        Path parent = p1.getParent();\n        \n        System.out.println(parent);\n        \n    }','/home/maxbisesi/Public/Data','Input/Output',1,NULL),(1160,' public static void main(String[] args) {\n\n        Path p1 = Paths.get(\"/home/maxbisesi/Public/Data/TextFile1.txt\");\n        Path p2 = Paths.get(\"maxbisesi/Public/Data\");\n        Path p3 = Paths.get(\"maxbisesi\");\n        \n        Path parent = p1.getParent();\n        Path parent2 = p3.getParent();\n        \n        System.out.println(parent);\n        System.out.println(parent2);\n        \n    }','/home/maxbisesi/Public/Data\nnull\n\ngetParent() \n	returns the paths parent or null if the path does not have a parent','Input/Output',1,NULL),(1161,'Path methods getName() and subPath() all use zero based indexs ','true\n\nthe element that is closest to the root directory in the heirarchy has an\nindex of zero. ','Input/Output',1,NULL),(1162,'public static void main(String[] args) {\n\n        Path p1 = Paths.get(\"/home/maxbisesi/Public/Data/TextFile1.txt\");\n        Path p2 = Paths.get(\"maxbisesi/Public/Data\");\n        \n        Path sub = p1.subpath(1,3); \n        \n        System.out.println(sub);\n        \n    }','maxbisesi/Public','Input/Output',1,NULL),(1163,'public static void main(String[] args) {\n\n        Path p1 = Paths.get(\"/home/maxbisesi/Public/Data/TextFile1.txt\");\n        Path p2 = Paths.get(\"maxbisesi/Public/Data\");\n        \n        Path sub = p1.subpath(0,3); \n        \n        System.out.println(sub);\n        \n    }','home/maxbisesi/Public','Input/Output',1,NULL),(1164,'public static void main(String[] args) {\n\n        Path p1 = Paths.get(\"/home/maxbisesi/Public/Data/TextFile1.txt\");\n        Path p2 = Paths.get(\"maxbisesi/Public/Data\");\n        \n        Path sub = p1.subpath(2,5); \n        \n        System.out.println(sub);\n        \n    }','Public/Data/TextFile1.txt\n\n    beginIndex - the index of the first element, inclusive\n    endIndex - the index of the last element, exclusive','Input/Output',1,NULL),(1165,'Path subpath(int beginIndex,int endIndex)\n\n    beginIndex - the index of the first element, inclusive\n    endIndex - the index of the last element, exclusive','learn it','Input/Output',1,NULL),(1166,'public static void main(String[] args) {\n\n        Path p1 = Paths.get(\"/home/maxbisesi/Public/Data/TextFile1.txt\");\n        Path p2 = Paths.get(\"maxbisesi/Public/Data\");\n        \n        Path sub = p1.subpath(2,6); \n        \n        System.out.println(sub);\n        \n    }','IllegalArgumentException\n\nonly 5 elemetns\n\n    beginIndex - the index of the first element, inclusive\n    endIndex - the index of the last element, exclusive','Input/Output',1,NULL),(1167,'public void scrambleFile(Path file) {\n        \n        FileReader inputStream = null;\n        FileWriter outputStream = null;\n\n        try {\n            inputStream = new FileReader(file.toFile());\n            Path fileToWrite = Paths.get(file.getParent().toString(),\"ScrambledFile\"+filecount+\".txt\");\n            outputStream = new FileWriter(fileToWrite.toString());\n\n            int c;\n            while((c = inputStream.read()) != -1){\n                Character a = key.get((char)c);\n                if(a == null){\n                    continue;\n                } else {\n                    outputStream.write((int)a);\n                }\n                \n            }\n            \n            inputStream.close();\n            outputStream.close();\n\n        } catch(IOException e){\n            System.out.println(e);\n        } \n        \n        filecount++;\n    }','will read characters from the first file encode them and put them in the\nnext. ','Input/Output',1,NULL),(1168,'public static void main(String[] args) {\n        double count = -34.45;\n        String s = \" true\";\n        boolean yea = true;\n        boolean nah = false;\n        System.out.printf(\"%1$0(f\",count);\n        \n    }','MissingFormatWidthException\n\nwith - and 0 the width is required.','Input/Output',1,NULL),(1169,'java.util.formatter\n\nthe flags - and 0 require you to specify the width','got it ','Strings',1,NULL),(1170,'what flags in java.util.formatter require you to specify the width ?','- and 0 ','Strings',1,NULL),(1171,'public class Hello extends Thread {\n    public static void main(String[] args){\n        new CodeMaker().start();\n    }\n}\n\nclass CodeMaker  extends Thread {\n    private String code;\n    private int counter;\n    private ArrayList<String> al;\n    private char[] letters = {\'A\',\'B\',\'C\',\'D\',\'E\',\'F\',\'G\',\'H\',\'I\'};\n    \n    public CodeMaker(){\n        counter = 0;\n        al = new ArrayList<>();\n    }\n\n    class SectionGenerator implements Runnable{\n        private String sec = \"\";\n        private Random ran = new Random();\n\n        public void run() {\n            //tried to use notify outside of synchronized context\n            synchronized(this){\n                int x = ran.nextInt(3);\n                int y = ran.nextInt(3);\n                int z = ran.nextInt(3);\n            \n            \n                sec += letters[x];\n                sec += letters[y];\n                sec += letters[z];\n                notifyAll();\n            }\n        }\n        \n        public synchronized String section(){\n            return sec;\n        }\n\n    }\n    \n    class NumberGenerator implements Runnable{\n        private String number = \"\";\n        private Random ran = new Random();\n        \n        public void run(){\n            //tried to use notify outside of synchronized context\n            synchronized(this){\n                int x1 = ran.nextInt(100);\n                int x2 = ran.nextInt(100);\n                int x3 = ran.nextInt(100);\n            \n                number += x1+\".\"+x2+\".\"+x3;\n                notifyAll();\n            }\n        }\n        \n        public synchronized String Number(){\n            return number;\n        }\n    }\n    \n   public synchronized void run(){\n       \n       SectionGenerator sg1 = new SectionGenerator();\n       NumberGenerator ng1 = new NumberGenerator();\n       Thread t1 = new Thread(sg1);\n       Thread t2 = new Thread(ng1);\n       \n       t1.start();\n       t2.start();\n       \n       try{\n        t1.wait();\n        code += sg1.section();\n        t2.wait();\n        code += ng1.Number();\n       } catch(InterruptedException e){\n           \n       }\n       System.out.println(code);\n\n       \n   }\n    \n    \n}\n','IllegalMonitorStateException,\n\nthe running thread was not synchronized onto t1, \nyou must be synchronized onto an object to wait on it.','Threads',1,NULL),(1172,'public class Hello extends Thread {\n    public static void main(String[] args){\n        try(Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees\", \"root\", \"Basketball12\")){\n            String getAllEmployeeNames = \"select first_name,last_name from employees\";\n            Statement st1 = conn.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.TYPE_READ_ONLY);\n            \n            ResultSet empnames = st1.executeQuery(getAllEmployeeNames);\n            \n            empnames.last();\n            \n            System.out.println(empnames.getString(\"first_name\")+\" \"+empnames.getString(\"last_name\"));\n            \n        }catch(SQLException e){\n            System.out.println(e);\n        }\n    }\n}','its CONCUR_READ_ONLY not TYPE_READ_ONLY','JDBC',1,NULL),(1173,'public static void main(String[] args){\n        try(Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees\", \"root\", \"Basketball12\")){\n            String getAllEmployeeNames = \"select first_name,last_name from employees\";\n            Statement st1 = conn.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);\n            \n            ResultSet empnames = st1.executeQuery(getAllEmployeeNames);\n            \n            empnames.absolute(34);\n            System.out.println(empnames.getString(\"first_name\")+\" \"+empnames.getString(\"last_name\"));\n            empnames.previous();\n            System.out.println(empnames.getString(\"first_name\")+\" \"+empnames.getString(\"last_name\"));\n            empnames.deleteRow();\n            System.out.println(empnames.getString(\"first_name\")+\" \"+empnames.getString(\"last_name\"));\n            \n        }catch(SQLException e){\n            System.out.println(e);\n        }\n    }','Cristinel Bouloucos\nKazuhito Cappelletti\n\ncom.mysql.jdbc.NotUpdatable: Result Set not updatable.This result set must \ncome from a statement that was created with a result set type of \nResultSet.CONCUR_UPDATABLE, the query must select only one table, can not \nuse functions and must select all primary keys from that table. See the \nJDBC 2.1 API Specification, section 5.6 for more details.This result set \nmust come from a statement that was created with a result set type of \nResultSet.CONCUR_UPDATABLE, the query must select only one table, can not \nuse functions and must select all primary keys from that table. See the\n JDBC 2.1 API Specification, section 5.6 for more details.','JDBC',1,NULL),(1174,'public class Hello {\n    public static void main(String[] args){\n        try(Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees\", \"root\", \"Basketball12\")){\n            String getAllEmployeeNames = \"select emp_no,first_name,last_name from employees\";\n            Statement st1 = conn.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_UPDATABLE);\n            \n            ResultSet empnames = st1.executeQuery(getAllEmployeeNames);\n            \n            empnames.absolute(34);\n            System.out.println(empnames.getString(\"first_name\")+\" \"+empnames.getString(\"last_name\"));\n            empnames.previous();\n            System.out.println(empnames.getString(\"first_name\")+\" \"+empnames.getString(\"last_name\"));\n            empnames.deleteRow();\n            System.out.println(empnames.getString(\"first_name\")+\" \"+empnames.getString(\"last_name\"));\n            \n        }catch(SQLException e){\n            System.out.println(e);\n        }\n    }\n}','CONCUR_UPDATABLE lets you delete rows. It will save those changes to the underlying db','JDBC',1,NULL),(1175,'public class Hello {\n    public static void main(String[] args){\n        try(Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees\", \"root\", \"Basketball12\")){\n            String getAllEmployeeNames = \"select emp_no,first_name,last_name from employees\";\n            Statement st1 = conn.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE,ResultSet.CONCUR_UPDATABLE);\n            \n            ResultSet empnames = st1.executeQuery(getAllEmployeeNames);\n            \n            empnames.absolute(40);\n            System.out.println(empnames.getString(\"first_name\")+\" \"+empnames.getString(\"last_name\"));\n            empnames.next();\n            System.out.println(empnames.getString(\"first_name\")+\" \"+empnames.getString(\"last_name\"));\n            empnames.next();\n            System.out.println(empnames.getString(\"first_name\")+\" \"+empnames.getString(\"last_name\"));\n\n            empnames.next();\n            System.out.println(empnames.getString(\"first_name\")+\" \"+empnames.getString(\"last_name\"));\n            empnames.updateString(\"first_name\",\"BIG MAX\");\n            empnames.updateRow();\n            System.out.println(empnames.getString(\"first_name\")+\" \"+empnames.getString(\"last_name\"));\n            \n            \n        }catch(SQLException e){\n            System.out.println(e);\n        }\n    }\n}','SCROLL SENSITIVE will show what chagnes you have made. ','JDBC',1,NULL),(1176,'Arrays/Collections must be sorted before being searched. Otherwise results\nwill be unpredictable','','Collections',1,NULL),(1177,'public static void main(String[] args) {\n	String s1 = \"abc\";\n	String s2 = s1;\n	System.out.println(s1+\"d\");\n	System.out.println(s1+\" \"+s2+\" \"+ (s1==s2));\n	\n	StringBuffer sb1 = new StringBuffer(\"abc\");\n	StringBuffer sb2 = sb1;\n	sb1.append(\"d\");\n	System.out.println(sb1+ \" \" + sb2 + \" \" + (sb1==sb2));\n    }','abcd\nabc abc true\nabcd abcd true\n\nstrings are immutable','Strings',1,NULL),(1178,'public static void main(String[] args) throws IOException {\n       File file1 = new File(\"/home/maxbisesi/Public/TestDir/file1\");\n       File file2 = new File(\"/home/maxbisesi/Public/TestDir/file2\");\n       File dir = new File(\"/home/maxbisesi/Public/TestDir\");\n       \n       if(dir.exists() && dir.isDirectory()){\n           file1.createNewFile();\n           file2.createNewFile();\n       } else {\n           dir.mkdir();\n           file1.createNewFile();\n           file2.createNewFile();\n       }\n    } ','builds the directory structure, throwing IOE if necessary','Input/Output',1,NULL),(1179,'public class Hello {\n    public static void main(String[] args){\n        \n    }\n    \n    interface Handeler{\n        void handle();\n    }\n}\n\nclass Adder implements Hello.Handeler {\n        public void handle(){\n            System.out.println(\"I got this.\");\n        }\n}','all inner interfaces are implicitly static','OOP',1,NULL),(1180,'All variables in an interface are implicitly static','got it','OOP',1,NULL),(1181,'interface varialbes are implicitly static and final','got it ','OOP',1,NULL),(1182,'interface hungry{\n    static void milk();\n}','does not compile in java 7','OOP',1,NULL),(1183,'public static void main(String[] args) {\n        String s1 = \"hi\";\n        String s2 = new String(\"hi\");\n        String s3 = \"hi\";\n        \n        if(s1 == s2){\n            System.out.println(\"A\");\n        } else{\n            System.out.println(\"B\");\n        }\n        \n        if(s1 == s3){\n            System.out.println(\"C\");\n        } else {\n            System.out.println(\"D\");\n        }\n        \n        \n    }','B\nC\n\nthe jvm keeps a constant string pool. With strings == checks the similarity\nof the objects themselves.','Strings',1,NULL),(1184,'public static void main(String[] args) {\n        String s1 = \"hi\";\n        String s3 = \"hi\";\n        \n        System.out.println((s1 == s3));\n        \n        \n    }','true\nThe jvm keeps a pool of Strings and == compares the actuall strings ','Strings',1,NULL),(1185,'public class Hello {\n    \n\n    public static void main(String[] args) {\n        Point2D p = new Point2D(10,20);\n        System.out.println(p);\n    }\n    \n}\n\nclass Point2D {\n    private int x,y;\n    \n    public Point2D(int x, int y){\n        x=x;\n    }\n    \n    public String toString(){\n        return x+\",\"+y;\n    }\n}','0,0\n\nx=x only reassigns the passed parameter not the member. \n\nyou must use this.x = x;','OOP',1,NULL),(1186,'public class Hello {\n    \n\n    public static void main(String[] args) {\n        Integer i = 10;\n        Integer j = 11;\n        Integer k = ++i;\n        System.out.println(\"k==j: \"+(k==j));\n        System.out.println(\"k.equals(j): \"+(k.equals(j)));\n    }\n    \n}','k==j: true\nk.equals(j): true\n\nInteger objects are immutable just like strings are. \n\nIf there is an Integer object for a value already exists java will not \ncreate a new object. \n\ntwo integer objects are equal no matter if you use == or equals. Because object \nvalues are all imutable. ','OOP',1,NULL),(1187,'public static void main(String []args) {\n            int []arr1 = {1, 2, 3, 4, 5};\n            int []arr2 = {1, 2, 3, 4, 5};\n            System.out.println(\"arr1 == arr2 is \" + (arr1 == arr2));\n            System.out.println(\"arr1.equals(arr2) is \" + arr1.equals(arr2));\n\n            System.out.println(\"Arrays.equals(arr1, arr2) is \" +java.util.Arrays.equals(arr1, arr2));\n}','false\nfalse \ntrue\n\narray objects dont have an equals method. There\'s is inherited from the \nObject class. \n\nThe two objects are not equal themselves they are both seperate.\n\nArrays class has various methods for testing equality of arrays. ','OOP',1,NULL),(1189,'public class Hello {\n\n        public static void main(String []args) {\n                foo(10);\n        }\n        public static void foo(Integer i) { System.out.println(\"foo(Integer)\"); }\n        public static void foo(short i) { System.out.println(\"foo(short)\"); }\n        public static void foo(long i) { System.out.println(\"foo(long)\"); }\n        public static void foo(int ... i) { System.out.println(\"foo(int ...)\"); }\n}','foo(long)\n\nfor an integer literal the jvm matches in the following order:\n\n	int, long,Integer, int...\n\n','OOP',1,NULL),(1190,'public class Hello {\n\n        public static void main(String []args) {\n                foo(null);\n        }\n        public static void foo(Integer i) { System.out.println(\"foo(Integer)\"); }\n        public static void foo(short i) { System.out.println(\"foo(short)\"); }\n        public static void foo(long i) { System.out.println(\"foo(long)\"); }\n        public static void foo(int ... i) { System.out.println(\"foo(int ...)\"); }\n}','WNC reference to foo is ambiguous','OOP',1,NULL),(1191,'enum Cards{ A,B,C,D };\npublic class Hello {\n\n        public static void main(String []args) {\n                for(Cards card: Cards.values()){\n                    System.out.println(card +\" \");\n                }\n        }\n\n}','A\nB\nC\nD\n\nhow to iterate through an enum. \n\nuse values()','General',1,NULL),(1192,'abstract class AbstractBook {\n    public String name;\n}\n\ninterface sleepy{\n    public String name = \"undefined\";\n}\n\nclass Book extends AbstractBook implements sleepy{\n    public Book(String name){\n        this.name = name;\n    }\n            \n}\npublic class Hello {\n\n        public static void main(String []args) {\n           AbstractBook ab = new Book(\"Diamonds\");\n            System.out.println(ab.name);\n        }\n\n}','WNC,\n\nreference to name is ambiguous','General',1,NULL),(1193,'public class Hello {\n\n    public static void main(String []args) {\n        Deque<Integer> deque = new ArrayDeque<>();\n        deque.addAll(Arrays.asList(1, 2, 3, 4, 5));\n        System.out.println(\"The removed element is: \" + deque.remove());\n    }\n}','the removed element is 1\n\nDeque is a double ended queue. \n\ncan be added and removed from the head or tail. ','General',1,NULL),(1194,'Dequeue methods:\n\n           First Element (Head) 	             Last Element (Tail)\n\n	Throws exception 	Special value 	Throws exception 	Special value\nInsert: 	addFirst(e) 	offerFirst(e) 	addLast(e) 	offerLast(e)\nRemove:	removeFirst() 	pollFirst() 	removeLast() 	pollLast()\nExamine: 	getFirst() 	peekFirst() 	getLast() 	peekLast()','got it ','Collections',1,NULL),(1195,'a LinkedList is a Dequeue','true','Collections',1,NULL),(1196,' public static void main(String []args) {\n        Deque<Integer> d = new ArrayDeque<>(5);\n        d.add(5);\n        d.add(1);\n        d.add(7);\n        d.add(1);\n        d.add(3); \n        d.add(9);\n        \n        System.out.println(d.getFirst());\n        System.out.println(d.getLast());\n        System.out.println(d.pollFirst());\n        System.out.println(d.pollLast());\n        System.out.println(d.removeFirst());\n        System.out.println(d.removeLast());\n    }','5\n9\n5\n9\n1\n3\n\n','Collections',1,NULL),(1197,'Dequeu whats the difference between pollFirst and removeFirst','remove throws an exception if the queue is empty','Collections',1,NULL),(1198,'public class Hello {\n\n    public static void main(String []args) {\n        Deque<Integer> d = new ArrayDeque<>(5);\n        d.add(1);\n        d.add(2);\n        d.add(3);\n        d.add(4);\n        d.add(5); \n        d.add(6);\n        \n        for(int i = 0; i < 10; i++){\n            System.out.println(d.removeLast());\n        }\n    }\n}','6\n5\n4\n3\n2\n1\nException in thread \"main\" java.util.NoSuchElementException\n\nremove throws an exception if queue is empty','Collections',1,NULL),(1199,'public class Hello {\n\n    public static void main(String []args) {\n        Deque<Integer> d = new ArrayDeque<>(5);\n        d.add(1);\n        d.add(2);\n        d.add(3);\n        d.add(4);\n        d.add(5); \n        d.add(6);\n        \n        for(int i = 0; i < 10; i++){\n            System.out.println(d.pollLast());\n        }\n    }\n}','6\n5\n4\n3\n2\n1\nnull\nnull\nnull\nnull\n\npoll returns null if empty','Collections',1,NULL),(1200,'public static void main(String []args) {\n        Deque<Integer> d = new ArrayDeque<>(5);\n        d.add(1);\n        d.add(2);\n        d.add(3);\n        d.add(4);\n        d.add(5); \n        d.add(6);\n        \n        for(int i = 0; i < 10; i++){\n            System.out.println(d.element());\n        }\n    }','1\n1\n1\n1\n1\n1\n1\n element retrrieves but does not remove the head, similar to peek() only \nelement throws an exception if dequeu is empty','Collections',1,NULL),(1201,'which dequeue methods throw exceptions if the queue is empty ? \n','getFirst getLast element removeFirst removeLast remove\n\nremove and removeFirst are equivalent','Collections',1,NULL),(1202,'A dequeue is FIFO therefore the methods that add and addLast are\nequivalent\n\nwhere the ones that remove and removeFirst are equivalent. ','cool','Collections',1,NULL),(1203,'public static void main(String []args) {\n\n            String pattern = \"a*b+c{3}\";\n            String []strings = { \"abc\", \"abbccc\", \"aabbcc\", \"aaabbbccc\" };\n            for(String str : strings) {\n                System.out.print(Pattern.matches(pattern, str) + \" \");\n            }\n    }','false true false true','Strings',1,NULL),(1204,' public static void main(String []args) {\n\n            String pattern = \"a*b+c+\";\n            String []strings = { \"abc\", \"abbccc\", \"aabbcc\", \"aaabbbccc\" };\n            for(String str : strings) {\n                System.out.print(Pattern.matches(pattern, str) + \" \");\n            }\n    }','true true  true true\n\n+ one or more \n* zero or more','Strings',1,NULL),(1205,'class InvalidKeyException extends IllegalArgumentException{ }\n\nclass New {\n    public void foo() throws InvalidKeyException{ }\n}\npublic class Hello extends New {\n\n    public static void main(String []args) {\n        new Hello().foo();\n    }\n    \n    public void foo(){\n        throw new InvalidKeyException();\n    }\n        \n}','will compile and throw InvalidKeyException,\n\nfirst an overriden method does not have to throw an excpeiton if its super does\n\nsecond IllegalArgumentException is a runtime exception anyway so it does \nnot have to be declared thrown. ','Exceptions',1,NULL),(1206,'public static void main(String []args) {\n        \n        try {\n            int i = 10/0; // LINE A\n            System.out.print(\"after throw -> \");\n        } catch(ArithmeticException ae) {\n            System.out.print(\"in catch -> \");\n            return;\n        } finally {\n            System.out.print(\"in finally -> \");\n        }\n            System.out.print(\"after everything\");\n    }','in catch -> in finally->\n\nreturn means the function will return but finally will still be executed first.\n\n','Exceptions',1,NULL),(1207,'public static void main(String []args) {\n	try {\n		assert false;\n	} catch(RuntimeException re) {\n		System.out.println(\"RuntimeException\");\n	} catch(Exception e) {\n		System.out.println(\"Exception\");\n	} catch(Error e) {\n		// LINE A\n		System.out.println(\"Error\" + e);\n	} catch(Throwable t) {\n		System.out.println(\"Throwable\");\n	}\n}\n\njava -ea Hello','Error + e \n\nyou should never catch an assertion error but if you were to It would be\ncaught by \'Error\'','Exceptions',1,NULL),(1208,'public class Hello {\n\n    public static void main(String[] args) {\n        String[] fileList = {\"/file1.txt\", \"/subdir/file2.txt\", \"/file3.txt\"};\n        for (String file : fileList) {\n            try {\n                new File(file).mkdirs();\n            } catch (Exception e) {\n                System.out.println(\"file creation failed\");\n                System.exit(-1);\n            }\n        }\n   }\n}','creates all the files and directories','Input/Output',1,NULL),(1209,'public class Hello {\n\n    public static void main(String[] args) {\n      String names = \"<bob> romeo. Allen> ^ Clark\";\n      Set<String> words = new TreeSet<>();\n      try(Scanner tokenizer = new Scanner(names)){\n          tokenizer.useDelimiter(\"\\\\W\");\n          while(tokenizer.hasNext()){\n              String word = tokenizer.next();\n              if(!word.trim().equals(\"\")){\n                  words.add(word);\n              }\n          }\n          for(String word : words){\n              System.out.println(word);\n          }\n      }\n   }\n}','Allen\nClark\nbob\nromeo\n\nthis shows that TreeSets sort there elements. And Capitols sort before lowers','Strings',1,NULL),(1210,'Path wordpadPath = Paths.get(\"C:\\\\Program Files\\\\Windows NT\\\\Accessories\\\\wordpad.exe\");\nSystem.out.println(wordpadPath.subpath(beginIndex, endIndex));\n \nWhat are the values of the integer values beginIndex and endIndex in this program that will result in this code\nsegment printing the string “Program Files” as output?\n\na) beginIndex = 1 and endIndex = 2\nb) beginIndex = 0 and endIndex = 1\nc) beginIndex = 1 and endIndex = 1\nd) beginIndex = 4 and endIndex = 16','0 1 \n\nwith subpath the element closest to the root is 0, the ending index is exclusive','Input/Output',1,NULL),(1211,'Which one of the following options is a correct way to create a watch service for watching a directory for\nchanges?\n\nWatchService watch = FileSystems.getDefault().newWatchable();\nWatchService watcher = FileSystems.getDefault().newWatchService();\nWatchService dirWatcher = FileSystems.getDefault().newDirectoryWatchService();\nWatchService fileWatcher = FileSystems.getNewFileWatchService();\nWatchService fileDirWatcher = WatchService.getNewFileDirectoryWatchService();','cool','Input/Output',1,NULL),(1212,'a) Objects of type Statement can handle IN, OUT, and INOUT parameters.\nb) PreparedStatement is used for executing stored procedures.\nc) You can get an instance of PreparedStatement by calling prepareStatement() method in the Connection\ninterface.\nd) CallableStatement extends the PreparedStatement class; PreparedStatement in turn extends the Statement\nclass.\ne) The interface Statement and its derived interfaces implement the AutoCloseable interface, hence it can be used\nwith try-with-resources statement.','c e \n\nd is wrong because CallabeStatement PreparedStatement, and Statement \nare not classes they are interfaces.\n','JDBC',1,NULL),(1213,'// assume that connection is successfully established to the database\nconnection.setAutoCommit(true);\nStatement statement = connection.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE,\nResultSet.CONCUR_UPDATABLE);\nresultSet = statement.executeQuery(\"SELECT * FROM TempSensor\");\n \n// assume that the initial value of temp is \"0\" in the table\n \nresultSet.moveToInsertRow();\nresultSet.updateString(\"temp\", \"100\");\nresultSet.insertRow();\nSavepoint firstSavepoint = connection.setSavepoint();\n \nresultSet.moveToInsertRow();\nresultSet.updateString(\"temp\", \"200\");\nresultSet.insertRow();\nSavepoint secondSavepoint = connection.setSavepoint();\n \nresultSet.moveToInsertRow();\nresultSet.updateString(\"temp\", \"300\");\nresultSet.insertRow();\nSavepoint thirdSavepoint = connection.setSavepoint();\n \nconnection.rollback(secondSavepoint);\nconnection.commit();','sqlexception autocommit is true. \n\nyou cannot set a savepoint, rollback, or commit with autocommit on','JDBC',1,NULL),(1214,'class Worker extends Thread {\n    public void run() {\n        System.out.println(Thread.currentThread().getName());\n    }\n}\n \nclass Hello {\n    public static void main(String []args) throws InterruptedException {\n        Thread.currentThread().setName(\"Master \");\n        Thread worker = new Worker();\n        worker.setName(\"Worker \");\n        worker.start();\n        Thread.currentThread().join();\n        System.out.println(Thread.currentThread().getName());\n    }\n}','worker\n\nthen hangs...\n\nwhen the current thread joins onto itself to terminate it never does because\nit is waiting for itslef.','Threads',1,NULL),(1215,'class Hello {\n    public static void main(String []args) throws InterruptedException {\n        List list = Arrays.asList(10,5,10,20);\n        System.out.println(list);\n        System.out.println(new HashSet(list));\n        System.out.println(new TreeSet(list));\n        System.out.println(new ConcurrentSkipListSet(list));\n    }\n}','[10, 5, 10, 20]\n[20, 5, 10]\n[5, 10, 20]\n[5, 10, 20]\n\nconcurrentSkipListSet is sorted.','Collections',1,NULL),(1216,'Assume that you’ve the following resource bundles in your classpath:\nResourceBundle.properties\nResourceBundle_ar.properties\nResourceBundle_en.properties\nResourceBundle_it.properties\nResourceBundle_it_IT_Rome.properties\n \nAlso assume that the default locale is English (US), where the language code is en and country code is US. Which\none of these five bundles will be loaded for the call\nloadResourceBundle(\"ResourceBundle\", new Locale(\"fr\", \"CA\", \"\"));?\n \na) ResourceBundle.properties\nb) ResourceBundle_ar.properties\nc) ResourceBundle_en.properties\nd) ResourceBundle_it.properties\ne) ResourceBundle_it_IT_Rome.properties','c\n\nsince java cant find \n	ResourceBundle_fr_CA.properties\n	ResourceBundle_fr.properties\n\njava will search for canidate locales for teh base bundle named ResourceBundle and \na default locale\n\n	ResourceBundle_en_US.properties\n	ResourceBundle_en.properties','Locale',1,NULL),(1217,'public static void main(String []args) throws InterruptedException {\n        int i = 012;\n        int a = 10.0l;\n        int b = 10.0f;\n        int c = 10.0;\n    }','only i will compile.\n\nputting a 0 in front of the numbers indicates that it is an octal which can \nbe applied to ints. ','General',1,NULL),(1218,' public static void main(String []args) throws InterruptedException {\n        byte b = 100;\n        int i = 3456;\n        short s = 400;\n        long l = 6000;\n        float f = 356.0f;\n        double d = 45000.0;\n        \n        //commented assingments do not compile\n        i = b;\n        // b = i;\n        i = s;\n        //s = i;\n        l = i;\n        //i = l;\n        f = i;\n        //i = f;\n        f = l;\n        //l = f;\n        d = f;\n        //f = d;\n        d = s;\n        l = s;\n        l = b;\n        d = i;\n        f = s;\n        l = b;  \n    }','ok','General',1,NULL),(1219,'public static void main(String []args){\n        Boolean b = null;\n        System.out.println(b ? true: false);\n                \n    }','NPE','General',1,NULL),(1220,'class Point {\n        private int x = 0, y;\n        public Point(int x, int y) {\n        this.x = x;\n        this.y = y;\n    }\n        // DEFAULT_CTOR\n}\n\na) public Point() {\n	this(0, 0);\n	super();\n}\n \nb) public Point() {\n	super();\n	this(0, 0);\n}\n \nc) private Point() {\n	this(0, 0);\n}\n \nd) public Point() {\n	this();\n}\n \ne) public Point() {\n	this(x, 0);\n}\n\n\nWhich one of the following definitions of the Point constructor can be replaced without compiler\nerrors in place of the comment DEFAULT_CTOR?',' private Point() {\n	this(0, 0);\n}\n\nyou cannot call super and this. super or this should be the first calls \nin a constructor. ','General',1,NULL),(1221,'interface EnumBase { }\n \nenum AnEnum implements EnumBase {ONLY_MEM;}\n \nclass Hello {\n    public static void main(String []args) {\n        if(AnEnum.ONLY_MEM instanceof AnEnum) {\n            System.out.println(\"yes, instance of AnEnum\");\n        }\n        if(AnEnum.ONLY_MEM instanceof EnumBase) {\n            System.out.println(\"yes, instance of EnumBase\");\n        }\n        if(AnEnum.ONLY_MEM instanceof Enum) {\n            System.out.println(\"yes, instance of Enum\");\n        }\n    }\n}','yes, instance of AnEnum\nyes, instance of EnumBase\nyes, instance of Enum\n\n\nyes, instance of AnEnum\nyes, instance of EnumBase\nyes, instance of Enum\n\nAn enumeration can implement an interface (but cannot extend a class, or cannot be\na base class).\nEach enumeration constant is an object of its enumeration type. An enumeration\nautomatically extends the abstract class java.util.Enum. Hence, all the three instanceof\nchecks succeed.','General',1,NULL),(1222,'enums can implement an interface,\n\ncannot extend a class, they already implicitly extend Enum class\n\nno class can extend an enum\n\nenum constants are objects of its class','ok','General',1,NULL),(1223,'Which of the following statements are true with respect to enums? \n\na) An enum can have private constructor.\nb) An enum can have public constructor.\nc) An enum can have public methods and fields.\nd) An enum can implement an interface.\ne) An enum can extend a class.','a) Enum can have private constructor.\nc) Enum can have public methods and fields.\nd) Enum can implement an interface.','General',1,NULL),(1224,'enums cannot have public or protected constructors \n\nwhy ?','Think of Enums as a class with a finite number of instances. \nThere can never be any different instances beside the ones you initially \ndeclare.\n\nThus, you cannot have a public or protected constructor, because that\n would allow more instances to be created.','General',1,NULL),(1225,'interface EnumBase { }\n \nenum AnEnum implements EnumBase {\n    ONLY_MEM;\n    private AnEnum(){\n        \n    }\n}','compiles','General',1,NULL),(1226,'interface EnumBase { }\n \nenum AnEnum implements EnumBase {\n    ONLY_MEM;\n    public AnEnum(){\n        \n    }\n}','WNC','General',1,NULL),(1227,'interface EnumBase { }\n \nenum AnEnum implements EnumBase {\n    ONLY_MEM;\n     AnEnum(){\n        \n    }\n}','compiles','General',1,NULL),(1228,'interface EnumBase { }\n \nenum AnEnum implements EnumBase {\n    ONLY_MEM;\n    protected AnEnum(){\n        \n    }\n}','WNC','General',1,NULL),(1229,'	class ClassA {}\n	interface InterfaceB {}\n	class ClassC {}\n\n	class Test extends ClassA implements InterfaceB {\n		String msg;\n		ClassC classC;\n	}\n\na) Class Test is related with ClassA with a has-a relationship.\nb) Class Test is related to ClassC with a composition relationship.\nc) Class Test is related with String with an is-a relationship.\nd) Class ClassA is related with InterfaceB with an is-a relationship.','b)\nClass Test is related with ClassC with a composition relationship.\nWhen a class inherits from another class, they share an is-a relationship. On the other\nhand, if a class uses another class (by declaring an instance of another class), then the first\nclass has a has-a relationship with the used class.','General',1,NULL),(1230,'a) j  ava.text.Format is the abstract base class that supports formatting of locale sensitive\ninformation such as date, time, and currency\n\nb) j  ava.text.CustomTimeFormat allows you to define custom patterns for processing\ntime for specific locales.\n\nc) j  ava.text.NumberFormat derives from the java.text.Format class; it is the base\nclass for processing numbers, currency, etc. in a locale sensitive way.\n\nd) j  ava.text.DateFormat derives from the java.text.Format class; it is the base class\nfor processing date and time information based on locale.','a) java.text.Format is the abstract base class that supports formatting of locale sensitive\ninformation such as date, time, and currency\nc) java.text.NumberFormat derives from java.text.Format class; it is the base class for\nprocessing numbers, currency, etc. in a locale sensitive way.\nd) java.text.DateFormat derives from java.text.Format class; it is the base class for\nprocessing date and time information based on locale.\nClass java.text.SimpleDateForma','General',1,NULL),(1231,'Which of the following classes in the java.util.concurrent.atomic package inherit from\njava.lang.Number? (Select all that apply).\na) AtomicBoolean\nb) AtomicInteger\nc) AtomicLong\nd) AtomicFloat\ne) AtomicDouble','b) AtomicInteger\nc) AtomicLong\n\nClasses AtomicInteger and AtomicLong extend Number class.\nAtomicBoolean does not extend java.lang.Number. Classes named as AtomicFloat or\nAtomicDouble do not exist in the java.util.concurrent.atomic package.','General',1,NULL),(1232,'class Student{\n    public Student(int r) {\n    rollNo = r;\n    }\n\n    int rollNo;\n    public int hashCode(){\n        return rollNo;\n    }\n}\n\nclass Hello {\n        public static void main(String[] args){\n            HashSet<Student> students = new HashSet<>();\n            students.add(new Student(5));\n            Student s10 = new Student(10);\n            students.add(s10);\n            System.out.println(students.contains(new Student(10)));\n            System.out.println(students.contains(s10));\n        }\n}','false \ntrue\n\nthe newly created object is not part of the student set so it will show false.\n\ns10 however is the excact object added. Since equals is not overriden, this \ncollection can only identify equal objects using the unoverriden equals()\nfrom object which says that two objects are equal only if they are the excact\nsame reference variable which in this case is true..','Collections',1,NULL),(1233,'a) The Executor interface declares a single method execute(Runnable command) that\nexecutes the given command at sometime in the future.\nb) The Callable interface declares a single method call() that computes a result.\nc) The Exchanger class provides a “synchronization point at which threads can pair and\nswap elements within pairs”.\nd) The TimeUnit enumeration represents time duration and is useful for specifying\ntiming parameters in concurrent programs.','all four\n\nExecutor is an interface with a single method execute(Runnable r).\n\nWith Executor you create your own implementation to determine how you want threads\nto execute tasks. \n\nExecutor implementations in .concurrent package implement ExecutorService\nwhich is more complete\n\nExecutorService interface extends Executor. \n\nExecutors provides basic concrete implementations of these interfaces. ','Collections',1,NULL),(1234,'Executor is an interface with a single method execute(Runnable r).\n\nWith Executor you create your own implementation to determine how you want threads\nto execute tasks. \n\nExecutor implementations in .concurrent package implement ExecutorService\nwhich is more complete\n\nExecutorService interface extends Executor. \n\nExecutors provides basic concrete implementations of these interfaces. ','ok','Executors',1,NULL),(1235,'public class JabRefExecutorService implements Executor {\n\n    public static final JabRefExecutorService INSTANCE = new JabRefExecutorService();\n    private static final Log LOGGER = LogFactory.getLog(JabRefExecutorService.class);\n    private final ExecutorService executorService = Executors.newCachedThreadPool(r -> {\n        Thread thread = new Thread(r);\n        thread.setName(\"JabRef CachedThreadPool\");\n        thread.setUncaughtExceptionHandler(new FallbackExceptionHandler());\n        return thread;\n\n    });\n    private final ExecutorService lowPriorityExecutorService = Executors.newCachedThreadPool(r -> {\n        Thread thread = new Thread(r);\n        thread.setName(\"JabRef LowPriorityCachedThreadPool\");\n        thread.setUncaughtExceptionHandler(new FallbackExceptionHandler());\n        return thread;\n    });\n    private final Timer timer = new Timer(\"timer\", true);\n    private Thread remoteThread;\n\n    private JabRefExecutorService() { }\n\n    @Override\n    public void execute(Runnable command) {\n        if (command == null) {\n            LOGGER.debug(\"Received null as command for execution\");\n            return;\n        }\n\n        executorService.execute(command);\n    }','executor and singleton','Executors',1,NULL),(1236,'class Hello {\n        public static void main(String[] args){\n            List<String> coaches = Arrays.asList(\"Joe\",\"Dean\",\"Will\",\"Aaron\");\n            System.out.println(coaches.remove(\"Joe\"));\n        }\n}','Arrays.asList returns an unmodifiable list. you cannot add or remove from it','Collections',1,NULL),(1237,'class Hello {\n        public static void main(String[] args){\n            List<String> coaches = Arrays.asList(\"Joe\",\"Dean\",\"Will\",\"Aaron\");\n            //System.out.println(coaches.remove(\"Joe\"));\n            coaches.add(\"Reese\");\n        }\n}','Arrays.asList returns an unmodifiable list. you cannot add to it or remove from\nit. \n\n','Collections',1,NULL),(1238,'Arrays.asList returns an umodifiable list you cannot add to it or remove\nfrom it or you will get an unsupportedoperationexception. ','ok','Collections',1,NULL),(1239,'class Hello {\n        public static void main(String[] args){\n            List<String> coaches = Arrays.asList(\"Joe\",\"Dean\",\"Will\",\"Aaron\");\n            //System.out.println(coaches.remove(\"Joe\"));\n            coaches.set(0,\"Dan\");\n        }\n}','compiles fine. ','Collections',1,NULL),(1240,'class Test {\n	public static void main(String []args) {\n		String s = new String(\"5\");\n		System.out.println(1+10+s+1+10);\n	}\n}\n \na) 11511\nb) 1105110\nc) 115110\nd) 27','115110\nThe string concatenation operator works as follows: if both the operands are numbers,\nit performs the addition; otherwise it concats the arguments by calling the toString()\nmethod if needed. It evaluates from left to right. Hence, the expression in the program\nresults in the string 115110.','Strings',1,NULL),(1241,'The string concatenation operator works as follows: if both the operands are numbers,\nit performs the addition; otherwise it concats the arguments by calling the toString()\nmethod if needed. It evaluates from left to right. ','wow ','Strings',1,NULL),(1242,'class Test {\n	public static void main(String []args) {\n		String s = new String(\"5\");\n		System.out.println(1.0+10.5+s+(1.0+10.5));\n	}\n}\n \na) 11.5511.5\nb) 11.551.010.5\nc) 1.010.551.010.5\nd) 11.55(1.010.5)\ne) 11.55(11.5)','a\n\nwith + if the expression is in () it evaluates first. + if the left arg\nis a string both will become strings.\n\nif the two are numbers then addition will be performed. ','Strings',1,NULL),(1243,'class Printf {\n	public static void main(String []args) {\n		System.out.printf(\"%3.4s %n\", \"hello world\");\n		System.out.printf(\"%05d\", 123);\n	}\n}','hell\n00123\n\nIn first printf() method, %3.4s indicates that you want to print the first four characters\nof a string. In the second printf() method call, %05d indicates that you wanted to print\na minimum five digits of an integer. If the number does not have enough digits, then the\nnumber will be preceded by leading zeroes.\n\n\nYou can also use String.format(\"%3.3s\", \"abcdefgh\"). \nThe first digit is the minimum length (the string will be left \npadded if it\'s shorter), the second digit is the maxiumum length \nand the string will be truncated if it\'s longer. So\n\nSystem.out.printf(\"%3.3s%3.3s\", \"abcdefgh\", \"a\");\n\nwill produce\n\n\'abc  a\'','Strings',1,NULL),(1244,'NumberFormatException is a runtime exception','ok','General',1,NULL),(1245,'class Test {\npublic static void main(String []args) {\nint a = 7, b = 10;\nSystem.out.printf(\"no:%2$s and %1$s\", a, b);\nSystem.out.printf(\"\\nno:2$s and 1$s\", a, b);\n}\n}','no:10 and 7\nno:2$s and 1$s\n\nThe format specifier string %$s indicates that you want to re-order the input values.\nA number (integer) sandwiched between a % and a $ symbol is used to re-order the\ninput values; the number indicates which input variable you want to put here. In %2$s\nit indicates that you want to put the second argument. Similarly, %1$s indicates that you\nwant to put the first argument.','General',1,NULL),(1246,'class Test {\npublic static void main(String[] s) {\nString quote = \"aba*abaa**aabaa***\";\nString [] words = quote.split(\"a\\\\**\", 10);\nfor (String word : words) {\nSystem.out.println(word);\n}\n}\n}','\nb\nb\nb','Strings',1,NULL),(1247,'class Test {\n	public static void main(String[] args) {\n		String str1 = \"xxzz\";\n		String str2 = \"xyz\";\n		String str3 = \"yzz\";\n		Pattern pattern = Pattern.compile(\"(xx)*y?z{1,}\");\n		Matcher matcher = pattern.matcher(str1);\n		System.out.println(matcher.matches());\n		System.out.println(pattern.matcher(str2).matches());\n		System.out.println(\n		Pattern.compile(\"(xx)*y?z{1,}\").\n		matcher(str3).matches());\n	}\n}','in regex ? indicates 0 or 1','Strings',1,NULL),(1248,'class Test {\n	public static void main(String[] args) {\n\n	String str =\"Suneetha N.=9876543210, Pratish Patil=9898989898\";\n\n	Pattern pattern =Pattern.compile(\"(\\\\w+)(\\\\s\\\\w+)(=)(\\\\d{10})\");\n\n	Matcher matcher = pattern.matcher(str);\n\n	String newStr = matcher.replaceAll(\"$4:$2,$1\");\n	System.out.println(newStr);\n}\n}\n ','Suneetha N.=9876543210, 9898989898: Patil,Pratish\n\n\n\npublic String replaceAll(String replacement)\n\nReplaces every subsequence of the input sequence that matches the pattern \nwith the given replacement string.\n\nThis method first resets this matcher. It then scans the input sequence \nlooking for matches of the pattern. Characters that are not part of any\n match are appended directly to the result string; each match is replaced \nin the result by the replacement string. The replacement string may contain references to captured subsequences as in the appendReplacement method.\n\nNote that backslashes (\\) and dollar signs ($) in the replacement string \nmay cause the results to be different than if it were being treated as a \nliteral replacement string. Dollar signs may be treated as references to\n captured subsequences as described above, and backslashes are used to \nescape literal characters in the replacement string.\n\nGiven the regular expression a*b, the input \"aabfooaabfooabfoob\", and \nthe replacement string \"-\", an invocation of this method on a matcher \nfor that expression would yield the string \"-foo-foo-foo-\".\n\nInvoking this method changes this matcher\'s state. If the matcher is\n to be used in further matching operations then it should first be\n reset. ','Strings',1,NULL),(1249,'if a final variable is static it has be intitialized right away.','ok ','OOP',1,NULL),(1250,'public static void main(String[] args) {\n\n            Set<String> set = new TreeSet<String>();\n            set.add(\"S\");\n            set.add(\"R\");\n            Iterator<String> iter = set.iterator();\n            set.add(\"P\");\n            set.add(\"Q\");\n            while(iter.hasNext()) {\n                System.out.print(iter.next() + \" \");\n            }\n    }','concurrent modification exception\n\nTreeSets iterator: \n\n	The iterators returned by this class\'s iterator method are fail-fast: \nif the set is modified at any time after the iterator is created, in any \nway except through the iterator\'s own remove method, the iterator will\n throw a ConcurrentModificationException.','Collections',1,NULL),(1251,'public class Hello extends Thread {\n\n    public static void main(String[] args) {\n\n         ResourceBundle resBundle = ResourceBundle.getBundle(\"ResourceBundle\", new Locale(\"it\", \"IT\", \"\"));\n         System.out.println(resBundle.getObject(new Integer(1).toString()));\n    }\n        \n     \n}\n\nclass ResourceBundle_it_IT extends ListResourceBundle {\n\n    public Object[][] getContents() {\n        return contents;\n    }\n    static final Object[][] contents = {\n        {\"1\", \"Uno\"},\n        {\"2\", \"Duo\"},\n        {\"3\", \"Trie\"},};\n}','how to correctly load an rb','Locale',1,NULL),(1252,'public static void main(String[] args) {\n\n            Set<String> set = new CopyOnWriteArraySet<String>();\n            set.add(\"2\");\n            set.add(\"1\");\n            Iterator<String> iter = set.iterator();\n            set.add(\"3\");\n            set.add(\"-1\");\n            while(iter.hasNext()) {\n                System.out.print(iter.next() + \" \");\n            }\n    }','CopyOnWrite Collections will allow concurrent modification','Collections',1,NULL),(1253,'ResourceBundle resBundle = ResourceBundle.getBundle(\"hello.ResourceBundle\", new Locale(\"it\", \"IT\", \"\"));\n            System.out.println(resBundle.getObject(new Integer(1).toString()));','the proper name of a resource bundle has its package in front. ','Locale',1,NULL),(1254,'public class Hello extends Thread {\n    Set<String> set = new CopyOnWriteArraySet<String>();\n    \n    public Hello(){\n        set.add(\"2\");\n        set.add(\"1\");\n        set.add(\"3\");\n        set.add(\"-1\");\n    }\n\n    public static void main(String[] args) {\n        //Thread t1 = new ConcAdder();\n        Hello h = new Hello();\n        Hello.ConcAdder ca = h.new ConcAdder();\n        ca.start();\n        \n        Hello.ConcIter ci = h.new ConcIter();\n        ci.start();\n\n    }\n    \n    class ConcAdder extends Thread{\n        private String[] letters = {\"A\",\"B\",\"C\",\"D\"};\n        public void run(){\n            while(true){\n                try{\n                    sleep(1000);\n                    int a = ThreadLocalRandom.current().nextInt(0,3);\n                    set.add(letters[a]);\n                } catch(InterruptedException e){\n                    \n                }\n            }\n            \n        }\n    }\n    \n    class ConcIter extends Thread {\n        public void run(){\n            while(true){\n                Iterator<String> it = set.iterator();\n\n                while(it.hasNext()){\n                    System.out.println(it.next());\n                }\n                \n                try{\n                    sleep(1000);\n                } catch(InterruptedException e){ }\n            }\n        }\n        \n    }    \n}\n','One Thread continously interates throgh the set while the other continusly adds\nnew things to it. \n\nThis is allowed with a COWSet. \n\nThough if the Iterator is obtained then an element is added that iterator\nwill not change it will print the elements that were in the set at the time\nof Instantiation of the iterator. ','Concurrency',1,NULL),(1255,'\npublic interface Iterable<T>\n\nImplementing this interface allows an object to be the target of the\n \"foreach\" statement.\n\n\nIterator<E> is an interface too	','ok','General',1,NULL),(1256,'public class Hello extends Thread {\n    Set<String> set = new CopyOnWriteArraySet<String>();\n    \n    public Hello(){\n        set.add(\"2\");\n        set.add(\"1\");\n        set.add(\"3\");\n        set.add(\"-1\");\n    }\n\n    public static void main(String[] args) {\n        //Thread t1 = new ConcAdder();\n        Hello h = new Hello();\n        Hello.ConcAdder ca = h.new ConcAdder();\n        ca.start();\n        \n        Hello.ConcIter ci = h.new ConcIter();\n        ci.start();\n\n    }\n    \n    class ConcAdder extends Thread{\n        private String[] letters = {\"A\",\"B\",\"C\",\"D\"};\n        public void run(){\n            while(true){\n                    int a = ThreadLocalRandom.current().nextInt(0,3);\n                    set.add(letters[a]);\n            }\n            \n        }\n    }\n    \n    class ConcIter extends Thread {\n        public void run(){\n            while(true){\n                Iterator<String> it = set.iterator();\n\n                while(it.hasNext()){\n                    System.out.println(it.next());\n                }\n                \n                it.remove();\n            }\n        }\n        \n    }    \n}','2\nException in thread \"Thread-2\" java.lang.UnsupportedOperationException\n1\n3\n-1\n\nYou cannot mutate the collection with Iterator methods when using \na COW colleciton. \n\nThe collection is only thread safe because it copies its entire internal array\nevery time something is added or removed. \n\nSo when an iterator is obtained it gives one copy of the immutable internal\narray. You cannot mutate an array which gives the unsupportedOperation excepiton.','Concurrency',1,NULL),(1257,'public class Hello extends Thread {\n    Set<String> set = new TreeSet<String>();\n    \n    public Hello(){\n        set.add(\"2\");\n        set.add(\"1\");\n        set.add(\"3\");\n        set.add(\"-1\");\n    }\n\n    public static void main(String[] args) {\n        //Thread t1 = new ConcAdder();\n        Hello h = new Hello();\n        Hello.ConcAdder ca = h.new ConcAdder();\n        ca.start();\n        \n        Hello.ConcIter ci = h.new ConcIter();\n        ci.start();\n\n    }\n    \n    class ConcAdder extends Thread{\n        private String[] letters = {\"A\",\"B\",\"C\",\"D\"};\n        public void run(){\n            while(true){\n                    int a = ThreadLocalRandom.current().nextInt(0,3);\n                    set.add(letters[a]);\n            }\n            \n        }\n    }\n    \n    class ConcIter extends Thread {\n        public void run(){\n            while(true){\n                Iterator<String> it = set.iterator();\n\n                while(it.hasNext()){\n                    System.out.println(it.next());\n                }\n                \n                //it.remove();\n            }\n        }\n        \n    }    \n}','-1\nException in thread \"Thread-2\" java.util.ConcurrentModificationException\n\nTreeSet iterator is fail fast','Concurrency',1,NULL),(1258,'public abstract class Hello extends Base  {\n    public static void main(String[] yea){\n        Base b = new Base();\n        b.print();\n    }\n}\n\nclass Base{\n    public void print(){\n        System.out.println(\"Base print\");\n    }\n}','Base print\nan abstract class can extend a concrete class. ','OOP',1,NULL),(1259,'class Hello {\n\n    static <E> E cast(Object item) {\n        return (E) item;\n    }\n\n    public static void main(String[] args) {\n        Object o1 = 10;\n        int i = 10;\n        Integer anInteger = 10;\n\n        Integer i1 = cast(i);\n        Integer i2 = cast(10);\n        Integer i3 = cast(anInteger);\n        Integer i4 = cast(o1);\n\n        System.out.printf(\"i1 = %d, i2 = %d, i3 = %d, i4 = %d\", i1, i2, i3, i4);\n    }\n}','i1 = 10, i2 = 10, i3 = 10, i4 = 10\nunchecked cast warning too.\n\nE becomes whatever you are assigning the variable to','OOP',1,NULL),(1260,'class Hello {\n\n    static <E> E cast(Object item) {\n        return (E) item;\n    }\n\n    public static void main(String[] args) {\n        Object o1 = 10;\n        int i = 10;\n        Integer anInteger = 10;\n\n        String i4 = cast(o1);\n\n        System.out.printf(i4);\n    }\n}','Exception in thread \"main\" java.lang.ClassCastException: \njava.lang.Integer cannot be cast to java.lang.String','Generics',1,NULL),(1261,'class Hello {\n\n    static <E> E cast(Sculptable item) {\n        return (E) item;\n    }\n\n    public static void main(String[] args) {\n       Clay c = new Clay();\n       Rock r = cast(c);\n    }\n}\n\ninterface Sculptable{ }\nclass Rock{}\nclass Clay extends Rock implements Sculptable{}','compiles fine','Generics',1,NULL),(1262,'class Hello {\n\n\n    public static void main(String[] args) {\n        Vehicle[] v = new Car[4];\n        v[0] = new Vehicle();\n        v[1] = new Car();\n        v[2] = new Toyota();\n        \n        System.out.println(v.length);\n    }\n    \n}\n\nclass Vehicle{}\nclass Car extends Vehicle{}\nclass Toyota extends Car{}','ArrayStoreException.\n\nThe compiler sees a Vehicle[] and car vehicle object being assigned to it.\n\nhowever the JVM sees a Car[] because the JVM deals with polymorphism. \nand a Vehicle object cannot be added to a Car[]','Generics',1,NULL),(1263,'class Hello {\n\n\n    public static void main(String[] args) {\n        Vehicle[] v = new Car[4];\n        //v[0] = new Vehicle();\n        v[1] = new Car();\n        v[2] = new Toyota();\n        \n        System.out.println(v.length);\n    }\n    \n}\n\nclass Vehicle{}\nclass Car extends Vehicle{}\nclass Toyota extends Car{}','4','Generics',1,NULL),(1264,'class Point { int x, y; }\nclass ColoredPoint extends Point { int color; }\nclass Test {\n    public static void main(String[] args) {\n        ColoredPoint[] cpa = new ColoredPoint[10];\n        Point[] pa = cpa;\n        System.out.println(pa[1] == null);\n        try {\n            pa[0] = new Point();\n        } catch (ArrayStoreException e) {\n            System.out.println(e);\n        }\n    }\n}','true\njava.lang.ArrayStoreException: Point\n\nThe variable pa has type Point[] and the variable cpa has as its value a \nreference to an object of type ColoredPoint[]. A ColoredPoint can be \nassigned to a Point; therefore, the value of cpa can be assigned to pa.\n\nA reference to this array pa, for example, testing whether pa[1] is null, \nwill not result in a run-time type error. This is because the element of\n the array of type ColoredPoint[] is a ColoredPoint, and every ColoredPoint\n can stand in for a Point, since Point is the superclass of ColoredPoint.\n\nOn the other hand, an assignment to the array pa can result in a run-time \nerror. At compile time, an assignment to an element of pa is checked to \nmake sure that the value assigned is a Point. But since pa holds a \nreference to an array of ColoredPoint, the assignment is valid only if \nthe type of the value assigned at run time is, more specifically, a \nColoredPoint.\n\nThe Java Virtual Machine checks for such a situation at run time to \nensure that the assignment is valid; if not, an ArrayStoreException is\nthrown. ','Generics',1,NULL),(1265,'public static void main(String[] args) {\n\n        List<Integer> list = new ArrayList<Integer>();\n        list.add(new Integer(2));\n        list.add(1);\n        list.add(5);\n        list.add(9);\n        list.add(6);\n\n        System.out.println(list.remove(2));\n        System.out.println(list);\n        System.out.println(list.remove(new Integer(9)));\n        System.out.println(list);\n\n\n    }','5\n[2, 1, 9, 6]\ntrue\n[2, 1, 6]','Collections',1,NULL),(1266,'public static void main(String[] args) {\n        String talk = \"Pick a little, talk a little, pick a little, talk a little, cheep cheep cheep, talk a lot, pick a little more\";\n        String eat = talk.replaceAll(\"talk\", \"eat\").replace(\"cheep\", \"burp\");\n        System.out.println(eat);\n    }','Pick a little, eat a little, pick a little, eat a little, burp burp burp, eat a lot, pick a little more.\n\nBoth replaceAll() and replace() methods replace all occurrences of the substring from\nthe given string. The difference between them is that replaceAll() takes regex as the\nfirst argument and replacement string as the second argument. The replace() method\ntakes CharSequence as both the arguments (note that String implements CharSequence\ninterface).','Strings',1,NULL),(1267,'replace(char oldChar, char newChar)\nReturns a new string resulting from replacing all occurrences of oldChar in this string with newChar.\n\nString 	replace(CharSequence target, CharSequence replacement)\nReplaces each substring of this string that matches the literal target sequence with the specified literal replacement sequence.\n\nString 	replaceAll(String regex, String replacement)\nReplaces each substring of this string that matches the given regular expression with the given replacement.\n\nString 	replaceFirst(String regex, String replacement)\nReplaces the first substring of this string that matches the given regular expression with the given replacement.','ok','Strings',1,NULL),(1268,'public static void main(String[] args) {\n        String talk = \"For 30 days and 30 nights, we battled the wind, the cold, the despair.\";\n        String rep = talk.replaceAll(\"\\\\d+\", \"4\");\n        System.out.println(rep);\n    }','For 4 days and 4 nights, we battled the wind, the cold, the despair.','Strings',1,NULL),(1269,'public static void main(String[] args) {\n        String talk = \"For 30 days and 30 nights, we battled the wind, the cold, the despair.\";\n        String rep = talk.replace(\"\\\\d+\", \"4\");\n        System.out.println(rep);\n    }','For 30 days and 30 nights, we battled the wind, the cold, the despair.\n\nreplace takes a charsequence as a first arg not regex','Strings',1,NULL),(1270,'public static void main(String []args) {\n        Class c1 = new ArrayList<String>().getClass();\n        // LINE A\n        Class c2 = ArrayList.class;\n        // LINE B\n        System.out.println(c1 == c2);\n    }','true\n\ntype erasure will make ArrayList raw and ArrayList<String> the same type of class\n','General',1,NULL),(1271,'class Hello {\n\n    private static void overload(Object o){ System.out.println(\"A\"); }\n    private static  void overload(double[] d){ System.out.println(\"B\"); }\n    private static void overload(){ System.out.println(\"C\"); }\n    \n    public static void main(String []args) {\n        overload(null);\n    }\n}','When executed, the program prints the following: B\n\nThe overload resolution matches to the most specific overload. When the argument null is\npassed, there are two candidates, Overload(Object) and Overload(double[]), and of these\ntwo, Overload(double[]) is the most specific overload, so the compiler resolves to calling\nthat method.\n\nOne method or constructor is less specific than another if it can accept \nany parameters passed to the other \n\nn our program, both constructors are accessible and applicable. \nThe constructor Confusing(Object) accepts any parameter passed to\n Confusing(double[]), so Confusing(Object) is less specific. \n(Every double array is an Object, but not every Object is a double array.)\n The most specific constructor is therefore Confusing(double[]), \nwhich explains the program\'s output.','General',1,NULL),(1272,'class Hello extends Super {\n    public Hello(){\n        member = \"HI\";\n    }\n    public void foo(){\n        System.out.println(\"in Hello foo \"+ member.toLowerCase());\n    }\n    private String member;\n    \n    public static void main(String []args) {\n        Super s = new Hello();\n        s.foo();\n        \n    }\n}\n\nclass Super{\n    public Super(){\n        foo();\n    }\n    \n    public void foo(){\n        System.out.println(\"Super foo\");\n    }\n}','NPE\n\n When the superclass constructor is called it calls the subclass foo()\nnot its own, resulting in an NPE.','General',1,NULL),(1273,'// class PQR in mock package\npackage mock;\n \npublic class PQR {\n	public static void foo() {\n		System.out.println(\"foo\");\n	}\n}\n \n// class XYZ in mock package\npackage mock;\nimport static mock.*;\n \npublic class XYZ {\n	public static PQR pqr;\n}\n \n// class StatImport\nimport static mock.XYZ.*;\n \nclass StatImport {\n	public static void main(String []args) {\n		// STMT\n	}\n}','pqr.foo();\n\n  In this program, the member pqr is imported statically. So, the foo() method can be accessed by\nqualifying it as pqr.foo(). Note that foo() itself is not imported statically, so it cannot be invoked directly\nin this program.','General',1,NULL),(1274,'psvm(String[] args){\n	String st = null;\n	sout( st.valueOf(10) );\n}','This program will print 10 in the console.\nThe valueOf(int) method is a static method in String that returns the String\nrepresentation of the integer value that is passed as its argument. Since calling a static\nmethod does not require dereferencing the reference variable on which it is called, this\nprogram does not throw a NullPointerException.\n\nshows the danger of using references to access static methods. ','Strings',1,NULL),(1275,'When using multi-catch, the catch block parameter is final and cannot \nhave a new value assigned to it in the catch block.\n\ntry{\n\n} catch(SQLException | IOException e){\n	\n	e = new IOException();\n}\n\n// this shows why thats illegal, your not sure which exception type \nwill come through.\n//updated 2','try{\n\n}catch(Exception1 | Exception2 e) {\n\n	e = new Exception1();\n}\n\nTHIS WOULD FAIL COMPILATION\n\n','Exceptions',1,NULL),(1276,'To compile old code that may use \'assert\' as an identifier, \nadd 1.3. This will tell the compiler to treat the word \'assert\' as an identifier.\n\n1.4 will use \'assert\' as a keyword	','javac -source 1.3 OldCode.java\n\njavac -source 1.4 NewCode.java','Exceptions',1,NULL),(1277,'Disable assertions at runtime		','java -da com.maxbisesi.Test\n\njava -disableassertions com.maxbisesi.Test','Exceptions',1,NULL),(1278,'Dont use assert expressions that can cause side effects...','This is a bad idea...\n\npublic void doStuff(){\n	assert (modifyThings());\n	//continue\n}\n\npublic boolean modifyThings() {\n	y = x++;\n	return true;\n}','Exceptions',1,NULL),(1279,'You cant use the variable name multiple times in a multi-catch. \nThe following wont compile...\n\ncatch(Exception1 e1 | Exception2 e2){\n\n}','Fails compilation','Exceptions',1,NULL),(1280,'With Multi catch order does NOT matter...		','the following are equivalent:\n\ncatch(SQLException | IOException e)\n\ncatch(IOException | SQLException e)','Exceptions',1,NULL),(1281,'With Multi-Catch you have to make sure a given excpetion can only\nmatch one type...\n\ncatch(IOException | SQLException e)\n\nthese two are different types.','The following will not compile...\n\ncatch(FileNotFoundException | IOException e)\n\nsince FILNOTFOUND is a subclass of IOException we could have just\nwrtten that in the first place..\n\ncatch(IOException)','Exceptions',1,NULL),(1282,'Legal or illegal...\n\ntry {\n	//do something\n} catch(IOException e){\n	\n	e = new IOException();\n}','This is legal but it is not good practice. It is illegal to reasign the value\nof a multi-catch parameter. \n\ntry {\n	\n} catch(SQLException | IOException e){\n\n	e = new IOException();\n}\n\n^^WILL NOT COMPILE\n','Exceptions',1,NULL),(1283,'public void couldthrow() throws SQLException, IOException { }\n\npublic void rethrow() throws SQLException, IOException {\n	try{\n		couldthrow();\n	} catch(Exception e){ \n		e = new IOException();\n		throw e;\n	}\n}	','Will not compile, it is legal to reassign the parameter here. But it is illegal\nto throw e. The method declares that it throws SQL and IO so throwing a \ngeneral exception is unreported. \n\nif the signature was throws Exception then everything would be fine\n\nException as a genreal','Exceptions',1,NULL),(1284,'legal or illegal\n\ntry {\n\n}','Illegal, regular trys have to have a catch or a finally\n\ntry-with can be used by themselves','Exceptions',1,NULL),(1285,'try(String s = \"hi\") {}','does not compile. \nto be declared in a try with the method has to implement auto closeable or\ncloseable','Exceptions',1,NULL),(1286,'Path p = Paths.get(\"/home/maxbisesi\");\n      try(BufferedReader br = new BufferedReader(new FileReader(p.toFile())), BufferedWriter bw = new BufferedWriter(new FileWriter(p.toFile()))){\n          \n      } catch(IOException e){\n          \n      }','will not compile,\nThe declared resources use a commma , not a semi colon ;\n\nshould be:\n\ntry(Resource r = new Resource(); ...','Exceptions',1,NULL),(1287,'Class A implements AutoCloseable { \n	public void close() throws Exception {}\n}	','ok, AutoCloseable interface allows throwing any Exception','Exceptions',1,NULL),(1288,'class B implements AutoCloseable { public void close() {}}\nclass C implements AutoCloseable { public void close() throws IOException {}}','ok sublcasses or implenting methods can throw a subclass of excpetion\nor none at all.\n\nAutoCloseable\'s  close throws an Exception','Exceptions',1,NULL),(1289,'class D implements Closeable { public void close() throws Exception{}}','ILLEGAL- Closeable only allows IOExceptions or subclasses','Exceptions',1,NULL),(1290,'class E implements Closeable { public void close() throws IOException {}}','ok Closeable allows throwing IOExceptions\n\nvoid close() throws IOException','Collections',1,NULL),(1291,'idempotent','you can call close() multiple times all day and nothing will happen the second time and beyond. \nwill not blow up. ','Exceptions',1,NULL),(1292,'AutoCloseable\'s close() is idempotent	','nothing bad will happen if you call close() more than one time. ','Exceptions',1,NULL),(1293,'Closeable\'s close() is not idempotent','might blow up if called more than once','Exceptions',1,NULL),(1294,'class A implements AutoCloseable {\n	public void close() {\n		sout(\"A\");\n	}\n}\n\nclass B implements AutoCloseable {\n	public void close() {\n		sout(\"B\");\n	}\n}\n\nclass C {\n	psvm(sa){\n		try(A a = new A(); B b = new B()){\n			throw new RuntimeException();\n		} catch(EXception e) {\n			sout(\"catch\");\n		}\n	}\n}\n\nwhat does it print?','B\nA\ncatch\n\nResources are closed in reverse order from what they are declared.','Exceptions',1,NULL),(1295,'public class Suppressed {\n	psvm(sa) {\n		try(One one = new One()) {\n			throw new exception(\"try\");\n		} catch (Exception e) {\n			sout(e.getMessage());\n			\n			for(Throwable t : e.getSuppressed()){\n				sout(\"suppressed:\" + t);\n		}	}\n	}\n}\n\nclass One implements AutoCloseable {\n	public void close() throws IOException {\n		throw new IOException(\"Closing\");\n	}\n}','Try\nsuppressed: java.io.IOException: Closing\n\nafter the exception in the try block gets thrown on line 4, the try with \nresources still calls close() and the catch block catches one \nof the exceptions.\n\nJava adds any excpeittions thrown by close() methods to a suppressed array in the main excpetion. \n\nif no other exception happens in the try block the exceptioon thrown in\nclose() gets treated as the main excpetion  for the catch block. ','Exceptions',1,NULL),(1296,'If the catch or Finally block throws an exception NO SUPPRESSION HAPPENS\nthe last exception thrown gets sent to the caller rather than the one from the \ntry- just like before try with resources','got it ','Exceptions',1,NULL),(1297,'class Bad implements AutoCloseable {\n	String name;\n	Bad(String n) { name = n; }\n	public void close() throws IOException {\n		throw new IOException(\"Closing -\" +name);\n	}\n}\n\npublic class Suppressed {\n	public static void main(SA) {\n		try(Bad b1 = new Bad(\"1\"); Bad b2 = new Bad(\"2\")) {\n			\n		} catch(Exception e) {\n			sout(e.getMessage());\n			for(Throwable t : e.getSuppressed()) {\n				sout(\"suppressed:\" + t);\n			}\n		}\n	}\n}','Closing - 2\nsuppressed: java.io.IOException: Closing - 1\n\nresources close in the opposite order they are declared','Exceptions',1,NULL),(1298,'Stream classes are used to read and write bytes, and Readers and Writers\nare used to read write Characters....','Since all file IO on the exam is related to characters, if you see a Stream\nlike DataOutputStream the the question is probably about serialization\nor something unrelated to the actual IO objective','Input/Output',1,NULL),(1299,'psvm(SA) {\n	try {\n		boolean newFile = false;\n		File file = new File(\"fiileWrite1.txt\");\n		sout(file.exists());\n		newFile = file.createNewFile());\n		sout(newFile);\n		sout(file.exists());\n	} catch (IOException e) {}\n}	','// first time\nfalse\ntrue \ntrue\n\n//second time\ntrue\nfalse\ntrue\n\nexists returns false the first time becasue the file was created as an object\nbut not yet as a physical file. ','Input/Output',1,NULL),(1300,'public static void main(String[] args){\n        File newFile = new File(\"/home/maxbisesi/Public/textFile5.txt\");\n        try{\n            System.out.println(newFile.exists());\n            newFile.createNewFile();\n            System.out.println(newFile.exists());\n        } catch(IOException e){\n            \n        }   \n    }','This method returns true if it can find the actual file\n\nfalse\ntrue\n\n	the first time it is run','Input/Output',1,NULL),(1301,'File method: \ntry {\n	createNewFile();\n} catch(IOException e) { } ','true if the named file does not exist and was successfully created; false if the named file already exists\n','Input/Output',1,NULL),(1302,'File class Constructors	','File(File parent, String child)\nCreates a new File instance from a parent abstract pathname and a child pathname string.\n\nFile(String pathname)\nCreates a new File instance by converting the given pathname string into an abstract pathname.\n\nFile(String parent, String child)\nCreates a new File instance from a parent pathname string and a child pathname string.','Input/Output',1,NULL),(1303,'File class key methods ','createNewFile()\ndelete()\nexists()\nisDirectory()\nisfile()\nlist()\nmkdir()\nrenameTo()','Input/Output',1,NULL),(1304,'FileWriter class Constructors	','FileWriter(File file)\n\nFileWriter(String filename)','Input/Output',1,NULL),(1305,'FileWriter class key methods 	','close()\nflush()\nwrite()','Input/Output',1,NULL),(1306,'BufferedWriter class constructors	','BufferedWriter(Writer out)','Input/Output',1,NULL),(1307,'BufferedWriter key methods	','close() \nflush()\nnewLine()\nwrite()','Input/Output',1,NULL),(1308,'PrintWriter constructors','PrintWriter(File file)\nCreates a new PrintWriter, without automatic line flushing, with the specified file.\n\nPrintWriter(File file, String csn)\nCreates a new PrintWriter, without automatic line flushing, with the specified file and charset.\n\nPrintWriter(OutputStream out)\nCreates a new PrintWriter, without automatic line flushing, from an existing OutputStream.\n\nPrintWriter(OutputStream out, boolean autoFlush)\nCreates a new PrintWriter from an existing OutputStream.\n\nPrintWriter(String fileName)\nCreates a new PrintWriter, without automatic line flushing, with the specified file name.\n\nPrintWriter(String fileName, String csn)\nCreates a new PrintWriter, without automatic line flushing, with the specified file name and charset.\n\nPrintWriter(Writer out)\nCreates a new PrintWriter, without automatic line flushing.\n\nPrintWriter(Writer out, boolean autoFlush)\nCreates a new PrintWriter.','Input/Output',1,NULL),(1309,'FileReader key methods 	','read()','Input/Output',1,NULL),(1310,'BufferedReader constructors	','Reader','Input/Output',1,NULL),(1311,'BufferedReader key methods','read()\nreadLine()','Input/Output',1,NULL),(1312,'File file = new file(\"filewriter2.txt\");\nFileWriter fw = new fileWriter(file);\n\nPrintWriter pw = new PrintWriter (fw);\n\npw.println(\"hello\");\npw.println(\"world\"));','filewrite2.txt would contain the text:\n\nhello\nworld','Input/Output',1,NULL),(1313,'File file = new File(\"filewrite2.txt\");\nFileReader fr = new FileReader(file);\nBufferedReader br = new BufferedReader(fr);\n\nString data = br.readLine();','','Input/Output',1,NULL),(1314,'File file = new File(\"foo\");\n\nif \"foo\" does not exist no actual file is created.\n\nif \"foo\" does exists, the new File object refers to the existing file. ','got it ','Input/Output',1,NULL),(1315,'readers dont have flush methods','io','Input/Output',1,NULL),(1316,'Console.readPassword() returns...','a char[]','Input/Output',1,NULL),(1317,'Path Method:\n\nPath getName(int index)','Returns the path element corresponding to the specified index.\n\nthe 0th element is the one closest to the root.','Input/Output',1,NULL),(1318,'Path Method:\n\nString getFileName()','returns the filename or the last element of the sequence of name elements\n\nor..\n\nReturns the name of the file or directory denoted by this path as a Path object. The file name is the farthest element from the root in the directory hierarchy.','Input/Output',1,NULL),(1319,'public class Hello {\n    public static void main(String[] dicks) throws IOException{\n      Path src = Paths.get(\"/home/maxbisesi/Documents/copy.txt\");\n\n      System.out.println(src.getNameCount());\n      \n    }\n\n}','4','Input/Output',1,NULL),(1320,'\npublic class Hello {\n    public static void main(String[] dicks) throws IOException{\n      Path src = Paths.get(\"/home/maxbisesi/Documents/copy.txt\");\n      Path srcParent = src.getParent();\n      System.out.println(srcParent);\n      \n    }\n\n}','\n/home/maxbisesi/Documents','Input/Output',1,NULL),(1321,'Path Method:\n\nPath getRoot()		','retunrs the root of thsi path, or null if this path does not have a root.','Input/Output',1,NULL),(1322,'Path Method:\n\nPath subpath(int beginindex, int endIndex)','returns a ssubsequence of this path NOT INCLUDING ROOT. \n\nbeginning INCLUSIVE\n\nending EXCLUSIVE','Input/Output',1,NULL),(1323,'Path extends from Iterable<Path>	','that means it can be iterated through in a for loop!','Input/Output',1,NULL),(1324,'int spaces = 1;\nPath myPath = Paths.get(\"tmp\", \"dir1\", \"dir2\", \"dir3\", \"file.txt\");\n\nfor(Path subpath : myPath){\n	sout( subpath + \"//\" );\n}','tmp/dir1/dir2/dir3/file.txt','Input/Output',1,NULL),(1325,'Path method:\n\nPath normalize()	','returns a path that is this path with redundant name elements eliminated\n\n. can be ignored\n\n.. followed by a directory can be removed as redundant','Input/Output',1,NULL),(1326,'Paths.get(\"/a/./b/./c\").normalize();\n','/a/b/c','Input/Output',1,NULL),(1327,'Paths.get(\".classpath\").normalize();','.classpath','Input/Output',1,NULL),(1328,'Paths.get(\"/a/b/c/..\").normalize()','/a/b','Input/Output',1,NULL),(1329,'Paths.get(\"../a/b/c\").normalize()','../a/b/c\n\nThe two dots do say go up one directory, but since there is\'nt a directory\nbefore it Path cant simplify it.','Input/Output',1,NULL),(1330,'Path dir = Paths.get(\"/home/java\");\nPath file = Paths.get(\"models/Model.pdf\");\nPath result = dir.resolve(file);\n\nsout( result );\n	','/home/java/models/Model.pdf\n\npath1.resolve(path2) should be read as \"resolve path2 within path1s directory\n','Input/Output',1,NULL),(1331,'class Hello {\n    public static void main(String[] args) {     \n        Path p1 = Paths.get(\"/home/max/tmp\");\n        Path p2 = Paths.get(\"/google\");\n        System.out.println(p1.resolve(p2));\n        \n    }\n\n}','/google\n\nResolve the given path against this path.\n\nIf the other parameter is an absolute path then this method trivially returns other.\n If other is an empty path then this method trivially returns this path.\n Otherwise this method considers this path to be a directory and resolves\n the given path against this path. In the simplest case, the given path does not have a root component, \nin which case this method joins the given path to this path \nand returns a resulting path that ends with the given path.','Input/Output',1,NULL),(1332,'Path absolute = Paths.get(\"/home/java\");\nPath relative = Paths.get(\"dir\");\nPath file = Paths.get(\"Model.pdf\");\n\nsout( absolute.resolve(relative) );\nsout( asolute.resolve(file) );\nsout( relative.resolve(file) );\nsout( relative.resolve(absolute) ); // BAD\nsout( file.resolve(absolute) ); //BAD\nsout( file.resolve(relative) ); //BAD','/home/java/dir\n/home/java/Model.pdf\n/dir/Model.pdf\n/home/java\n/home/java\nModel.pdf/dir\n\nThe first three do what you would exprect. They add the paramenter\nto resolve to the provided path object. The fourth and fifth try to resolve\nan absolute path within the context of something else. The problem is \nthat an aboluste path doesnt\'t depend on other directories it is absolute.\n','Input/Output',1,NULL),(1333,'Be carefule with questions that come in two flavors. one with a Path parameter\nand the other with a String parameter such as resolve()...\n\nPath path = Paths.get(\"/usr/bin/zip\");\npath.resolve(null);','Thhe compilere cannot decide here so it will not compile','Input/Output',1,NULL),(1334,'Which Path method is used to combine two paths and set one in another?','resolve()','Input/Output',1,NULL),(1335,'Which Path method is used to describe how to gret from one path to \nthe other	','relativize()','Input/Output',1,NULL),(1336,'Path dir = Paths.get(\"/home/java\");\nPath music = Paths.get(\"/home/java/country/Swift.mp3\");\nPath mp3 = dir.reltivize(music);\n\nsout( mp3 );','country/Swift.mp3\n\n\njava recognized that the /home/java part is the same and returned a path of\njust the remainder.\n\npath1.relativize(path2) should be read as \"give me a path shows how to get from\npath1 to path2\"','Input/Output',1,NULL),(1337,'\"give me a path shows how to get from\npath1 to path2\"','.relativize()','Input/Output',1,NULL),(1338,'Path absolute1 = Paths.get(\"/home/java\");\nPath absolute2 = Paths.get(\"/usr/local\");\nPath absolute3 = Paths.get(\"/home/java/temp/music.mp3\");\nPath relative1 = Paths.get(\"temp\");\nPath relative2 = Paths.get(\"temp/music.pdf\");\n\nsout( absolute1.relativize(absolute3) );\nsout( absolute3.relativize(absolute1) );\nsout( absolute1.relativize(absolute2) );\nsout( relative1.relativize(relative2) );\nsout( absolute1.relativize(relative1) ); //BAD','temp/music.mp3\n\n../..\n\n../../usr/local\n\nmusic.pdf\n\nExcpetion in main thread IllegalArgumentExcpetion\n\n	','Input/Output',1,NULL),(1339,'relativeize()','Path relativize(Path other)\n\nConstructs a relative path between this path and a given path.\n\nRelativization is the inverse of resolution. This method attempts to construct a relative path that when resolved against this path, yields a path that locates the same file as the given path. For example, on UNIX, if this path is \"/a/b\" and the given path is \"/a/b/c/d\" then the resulting relative path would be \"c/d\". Where this path and the given path do not have a root component, then a relative path can be constructed. A relative path cannot be constructed if only one of the paths have a root component. Where both paths have a root component then it is implementation dependent if a relative path can be constructed. If this path and the given path are equal then an empty path is returned.\n\nFor any two normalized paths p and q, where q does not have a root component,\n\n    p.relativize(p.resolve(q)).equals(q) \n\nWhen symbolic links are supported, then whether the resulting path, when resolved against this path, yields a path that can be used to locate the same file as other is implementation dependent. For example, if this path is \"/a/b\" and the given path is \"/a/x\" then the resulting relative path may be \"../x\". If \"b\" is a symbolic link then is implementation dependent if \"a/b/../x\" would locate the same file as \"/a/x\".\n\nParameters:\n    other - the path to relativize against this path\nReturns:\n    the resulting relative path, or an empty path if both paths are equal\nThrows:\n    IllegalArgumentException - if other is not a Path that can be relativized against this path','Input/Output',1,NULL),(1340,'When creating a Path you can seperate out folder and filename as much\nor as little as you want. When you don\'t begin with a root the Path\nis considered a relative path, which means Java looks from the current\ndirectory.\n\nPath p6 = Paths.get(\"tmp\", \"file1.txt\"); // relative path\n\n/ (root)\n	| - - tmp\n		| - file1.txt\n		| - tmp\n			| - file1.txt\n','If this program is run from the root, it is the one in /tmp/file1.txt\n\nif it is run from /tmp it is the one in /tmp/tmp/file1.txt\n\nif the program is run from anywhere else the path refers to a file that doesn\nnot exist. ','Input/Output',1,NULL),(1341,'With IO a file doesn\'t exists just because you create a File object.\nIt is the same with Path objects\n\nPath path = Paths.get(\"fileWrite1.txt\");\nsout(Files.exists(path)); // false\nFiles.createFile(path); \nsout(Files.exists(path)); // true','got it ','Input/Output',1,NULL),(1342,'create directories one at a time or all at once	......\n\nTHE directory must exist by the time the file is created','Path path1 = Paths.get(\"/java/source\");\nPath path2 = Paths.get(\"/java/source/directory\");\nPath file = Paths.get(\"/java/source/directory/Program.java\");\nFiles.createDirectory(path1);\nFiles.createDirectory(path2);\nFiles.createFile(file);\n\n// all at once\n\nFiles.createDirectories(path2);\nFile.createFile(file);','Input/Output',1,NULL),(1343,'Date januaryFirst = new GregorianCalendar(20q3, Calendar.January, 1).getTime();\n\nFile file = new File(\"c:/temp/file\");\nfile.createNewFile();\nfile.setLastModified(januaryFirst.getTime());\nfile.setLastModified(januaryFirst.getTime());\nsout(file.lastModified());\nfile.delete();','13570164000000','Input/Output',1,NULL),(1344,'Path path = Paths.get(\"c:/temp/file2\");\nDate januaryFirst = new GregorianCalendar(2013,Calendar.JANUARY, 1).getTime();\nFiles.createFile(path);\nFileTime fileTime = FileTime.fromMillis(januaryFirst.getTime());\nFiles.setLastModifiedTime(path,fileTime);\nsout(Files.getLastModifiedTime(path));\nFiles.delete((path);','2013-01-01T05','Input/Output',1,NULL),(1345,'How would you get the last modified date/time of a Path and a File?\n\nFile file = new file(\"test\");\nPath path = Paths.get(\"test\");','\nfile.lastModified();\n\nFiles.getLastModifiedTime(path);','Input/Output',1,NULL),(1346,'public class Hello {\n    static Thread max ,angela;\n    public static void main(String[] args){\n        angela = new Thread() {\n            public void run(){\n                System.out.println(\"A\");\n                try {\n                    max.sleep(1000);\n                } catch(Exception e){\n                    System.out.println(\"B\");\n                }\n                System.out.println(\"C\");\n                \n            }\n        };\n        \n        max = new Thread() {\n            public void run(){\n                System.out.println(\"D\");\n                try {\n                    angela.wait(); \n                } catch(Exception e){\n                    System.out.println(\"E\");\n                }\n                \n                System.out.println(\"F\");\n            }\n        };\n        \n        max.start();\n        angela.start();   \n    }\n} ','A C D E F \n\nin an undeterminable order, although thread angela uses the max reference\n.Sleep is static and therefore she puts herself to sleep. This is why\nreferences shouldn\'t be used for static methods. \n\nmax trys to synchronize on angela but he does not own the lock so he therefore\ncannot and throws an IllegalMonitorStateException. \n\n... ','Input/Output',1,NULL),(1347,'How would you get theread permision set of a Path and a File?\n\nFile file = new file(\"test\");\nPath path = Paths.get(\"test\");','file.canRead();\n\nFiles.isReadable(path);','Input/Output',1,NULL),(1348,'How would you get write and or execute permision set of a Path and a File?\n\nFile file = new file(\"test\");\nPath path = Paths.get(\"test\");','file.canWrite();\nfile.canExecute();\n\nFiles.isWritable(path);\nFiles.isExecutable(path);','Input/Output',1,NULL),(1349,'How do you set the last modified time of a path and file?\n\nFile file = new file(\"test\");\nPath path = Paths.get(\"test\");','file.setLastModifed(timeinMillis);\n\nFileTime ft = FileTime.fromMillis(timeInMillis);\nFiles.setLastModifiedTime(path,ft);','Input/Output',1,NULL),(1350,'BasicFileAttributes basic = Files.readAttributes(path, BasicFileAttributes.class);\n\nhow would you list the creation time, last access time, and last Modified time?	\n','basic.creationTime();\nbasic.lastAccessTime();\nbasick.lastModifiedTime();\n\nbasic.isDirectory();\n\n','Input/Output',1,NULL),(1351,'Three big things about BasicFileAttributes and BasicFileAttributeView...','1. BasicFileAttributes is PLURAL, BasicFileAttributeVIew is SINGULAR\n\n2. BasicFIleAttributeView basView = Files.getFileAttributeView(   );   \n\n	BasicFileAtttributes bas = FIles.readAttributes(   );\n\n3. You can ONLY update attributes in BasicFileAttributeView, \n	\n	VIEW IS FOR UPDATING','Input/Output',1,NULL),(1352,'How would you construct a PosixFileAttribute object?	','PosixFileAttributes pox = Files.readAttributes(path, PosixFileAttributes.class);\n','Input/Output',1,NULL),(1353,'How would you set a Unix File\'s permissions in Java?	','Path path = Paths.get(\"/tmp/file2\");\nFiles.createFile(path);\nPosixFileAttributes ps = Files.readAttributes(path, PosixFileAttributes.class);\n\nSet<PosixFilePermission> perms = PosixFilePermission.fromString(\"rw-r--r--\");\n\nFiles.setPosixFilePermissions(path,perms);\n\nsout( ps.permissions() );\n\nTHe output would be:\n\n[OWNER_WRITE, GROUP_READ, OTHERS_READ, OWNER_READ ]','Input/Output',1,NULL),(1354,'How to take modified times from one file\nand write new BasicFileAttributes\' last modified times\nlast access time and creation time to another file ... ?','BasicFileAttributes basic = Files.readAttributes(path1, BasicFileAttribute.class );\n\nFileTime at = basic.lastAccessTime();\nFileTime update = basic.lastModifiedTime();\nFileTime now = FileTime.fromMillis(System.currentTimeMiilis() );\n\nPath file = Paths.get(\"/temp/file.txt\");\nFiles.createFile(file);\n\nBasicFileAttributeView view = Files.getBasicFileAttributeView(file, BasicFileAttributeView.class);\n\nview.setTimes(update, at, now);','Input/Output',1,NULL),(1355,'BasicFileAttributeView is a...\n\nClass\n\nInterface\n\nAbstract class     ?','... interface\n\nmethods:\n\nString 	name()\nReturns the name of the attribute view.\n\nBasicFileAttributes 	readAttributes()\nReads the basic file attributes as a bulk operation.\n\nvoid 	setTimes(FileTime lastModifiedTime, FileTime lastAccessTime, FileTime createTime)\n\nUpdates any or all of the file\'s last modified time, last access time, and create time attributes.','Input/Output',1,NULL),(1356,'interface BasicFileAttributes methods.... ','FileTime 	creationTime()\nReturns the creation time.\n\nObject 	fileKey()\nReturns an object that uniquely identifies the given file, or null if a file key is not available.\n\nboolean 	isDirectory()\nTells whether the file is a directory.\n\nboolean 	isOther()\nTells whether the file is something other than a regular file, directory, or symbolic link.\n\nboolean 	isRegularFile()\nTells whether the file is a regular file with opaque content.\n\nboolean 	isSymbolicLink()\nTells whether the file is a symbolic link.\n\nFileTime 	lastAccessTime()\nReturns the time of last access.\n\nFileTime 	lastModifiedTime()\nReturns the time of last modification.\n\nlong 	size()\nReturns the size of the file (in bytes).','Input/Output',1,NULL),(1357,'interface PosixFileAttributes methods','GroupPrincipal 	group()\nReturns the group owner of the file.\n\nUserPrincipal 	owner()\nReturns the owner of the file.\n\nSet<PosixFilePermission> 	permissions()\nReturns the permissions of the file.','Input/Output',1,NULL),(1358,'interface PosixFileAttributeView methods ...','String 	name()\nReturns the name of the attribute view.\n\nPosixFileAttributes 	readAttributes()\nReads the basic file attributes as a bulk operation.\n\nvoid 	setGroup(GroupPrincipal group)\nUpdates the file group-owner.\n\nvoid 	setPermissions(Set<PosixFilePermission> perms)\nUpdates the file permissions.','Input/Output',1,NULL),(1359,'With DosFileAttributeView you can set what new and different file types ?','DosFileAttributeView has methods...\n\nsetArchive()\nsetHidden()\nsetReadOnly()\nsetSystem()\n\nfor Windows specific files ','Input/Output',1,NULL),(1360,'interface DosFileAttributeView methods...','String 	name()\nReturns the name of the attribute view.\n\nDosFileAttributes 	readAttributes()\nReads the basic file attributes as a bulk operation.\n\nvoid 	setArchive(boolean value)\nUpdates the value of the archive attribute.\n\nvoid 	setHidden(boolean value)\nUpdates the value of the hidden attribute.\n\nvoid 	setReadOnly(boolean value)\nUpdates the value of the read-only attribute.\n\nvoid 	setSystem(boolean value)\nUpdates the value of the system attribute.','Input/Output',1,NULL),(1361,'read a DosFileAttributes then declare if it is hidden and readonly \nthen set them so without using a DosFileAttributeView...','DosFileAttributes dos = Files.readAttributes(path, DosFileAttributes.class);\n\nsout( dos.isHidden() );\nsout( dos.isReadOnly() );\n\nFiles.setAttribute(path, \"dos:hidden\", true);\nFiles.setAttribute(path, \"dos:readonly\", true);\n\n','Input/Output',1,NULL),(1362,'You dont always need a XXXFileAttributeView object in order to change\na files attributes, you can just as easily do so with \"Files\" ...\n	','\n    setAttribute\n\n    public static Path setAttribute(Path path,\n                    String attribute,\n                    Object value,\n                    LinkOption... options)\n                             throws IOException\n\n    Sets the value of a file attribute.\n\n    The attribute parameter identifies the attribute to be set and takes the form:\n\n        [view-name:]attribute-name \n\n    where square brackets [...] delineate an optional component and the character \':\' stands for itself.\n\n    view-name is the name of a FileAttributeView that identifies a set of file attributes. If not specified then it defaults to \"basic\", the name of the file attribute view that identifies the basic set of file attributes common to many file systems. attribute-name is the name of the attribute within the set.\n\n    The options array may be used to indicate how symbolic links are handled for the case that the file is a symbolic link. By default, symbolic links are followed and the file attribute of the final target of the link is set. If the option NOFOLLOW_LINKS is present then symbolic links are not followed.\n\n    Usage Example: Suppose we want to set the DOS \"hidden\" attribute:\n\n        Path path = ...\n        Files.setAttribute(path, \"dos:hidden\", true);\n     \n\n    Parameters:\n        path - the path to the file\n        attribute - the attribute to set\n        value - the attribute value\n        options - options indicating how symbolic links are handled\n    Returns:\n        the path parameter\n    Throws:\n        UnsupportedOperationException - if the attribute view is not available\n        IllegalArgumentException - if the attribute name is not specified, or is not recognized, or the attribute value is of the correct type but has an inappropriate value\n        ClassCastException - if the attribute value is not of the expected type or is a collection containing elements that are not of the expected type\n        IOException - if an I/O error occurs\n        SecurityException - In the case of the default provider, and a security manager is installed, its checkWrite method denies write access to the file. If this method is invoked to set security sensitive attributes then the security manager may be invoked to check for additional permissions.\n\n','Input/Output',1,NULL),(1363,'You dont need PosixFileAttributeView to set a file permissions either...','Files.setPosixFilePermissions\n\npublic static Path setPosixFilePermissions(Path path,\n                           Set<PosixFilePermission> perms)\n                                    throws IOException\n\nSets a file\'s POSIX permissions.\n\nThe path parameter is associated with a FileSystem that supports the PosixFileAttributeView. This attribute view provides access to file attributes commonly associated \nwith files on file systems used by operating systems that implement the Portable \nOperating System Interface (POSIX) family of standards.\n\nParameters:\n    path - A file reference that locates the file\n    perms - The new set of permissions\nThrows:\n    UnsupportedOperationException - if the associated file system does not support the PosixFileAttributeView\n    ClassCastException - if the sets contains elements that are not of type PosixFilePermission\n    IOException - if an I/O error occurs\n    SecurityException - In the case of the default provider, and a security manager is installed, it denies RuntimePermission(\"accessUserInformation\") or its checkWrite method denies write access to the file.','Input/Output',1,NULL),(1364,'How to set a linux files permisions from a string ?\n	','PosixFileAttributes pos = Files.readAttributes(path, PosixFileAttributes.class);\nSet<PosixFilePermissions> perms = PosixFilePermissions.fromString(\"rw-r--r--:);\n\nFiles.setPosixFilePermissions(path,perms);\n\nsout(pos.group());\nsout(pos.permissions());','Input/Output',1,NULL),(1365,'What interface is used to recursively loop through a directory ?	','DirectoryStream<T> \n\nT is the element returned by the iterator. \n\nTHis allows for the convieninet use of a for - each loop to go through a dir.\n\nThe elements returned by the iterator are in no specific order.\n\n List<Path> listSourceFiles(Path dir) throws IOException {\n       List<Path> result = new ArrayList<>();\n       try (DirectoryStream<Path> stream = Files.newDirectoryStream(dir, \"*.{c,h,cpp,hpp,java}\")) {\n           for (Path entry: stream) {\n               result.add(entry);\n           }\n       } catch (DirectoryIteratorException ex) {\n           // I/O error encounted during the iteration, the cause is an IOException\n           throw ex.getCause();\n       }\n       return result;\n   }\n ','Input/Output',1,NULL),(1366,'how do you create a new DirectoryStream<T>','\n    Files.newDirectoryStream\n\n    public static DirectoryStream<Path> newDirectoryStream(Path dir)\n                                                    throws IOException\n\n    Opens a directory, returning a DirectoryStream to iterate over all entries in the directory. The elements returned by the directory stream\'s iterator are of type Path, each one representing an entry in the directory. The Path objects are obtained as if by resolving the name of the directory entry against dir.\n\n    When not using the try-with-resources construct, then directory stream\'s close method should be invoked after iteration is completed so as to free any resources held for the open directory.\n\n    When an implementation supports operations on entries in the directory that execute in a race-free manner then the returned directory stream is a SecureDirectoryStream.\n\n    Parameters:\n        dir - the path to the directory\n    Returns:\n        a new and open DirectoryStream object\n    Throws:\n        NotDirectoryException - if the file could not otherwise be opened because it is not a directory (optional specific exception)\n        IOException - if an I/O error occurs\n        SecurityException - In the case of the default provider, and a security manager is installed, the checkRead method is invoked to check read access to the directory.\n\n','Input/Output',1,NULL),(1367,'What type of object are returned by directorystreams iterator ? ','Path\n\nThe directory Stream interface is generic, but thats misleading since the \nonly way create a new DirectoryStream is by using File.newDirectoryStream\nwhich returns a Path.','Input/Output',1,NULL),(1368,'How would you filter the object returned by a directory Stream ?	','use \nFiles.newDirectoryStream(Path dir, String glob);\n\nthis lets you add a glob in that will compare the string representations \nof their file names agains the given glob.\n\nthis lets you filter your results...\n\n Path dir = ...\n     try (DirectoryStream<Path> stream = Files.newDirectoryStream(dir, \"*.java\")) {\n         :\n     }','Input/Output',1,NULL),(1369,'What will be returned by this code...\n\n	Path dir = Paths.get(\"/home/maxbisesi/Documents\");\n        \n	try(DirectoryStream<Path> ds = Files.newDirectoryStream(dir,\"[vx]*\")){\n            sout( );\n        } ','Nothing will not compile, must catch IOException for DirectoryStream','Input/Output',1,NULL),(1370,'How many directories at a time can DirectoryStream look at ?','only 1','Input/Output',1,NULL),(1371,'Think, DirectorySteam acts like ls in bash.','or ...\nDirectoryStream streams one directory','Input/Output',1,NULL),(1372,'What \"Files\" method do you use along with FileVisitor?','public static Path walkFileTree(Path start,\n                FileVisitor<? super Path> visitor)\n                         throws IOException\n\nWalks a file tree.\n\nThis method works as if invoking it were equivalent to evaluating the expression:\n\n     walkFileTree(start, EnumSet.noneOf(FileVisitOption.class), Integer.MAX_VALUE, visitor)\n     \n\nIn other words, it does not follow symbolic links, and visits all levels of the file tree.\n\nParameters:\n    start - the starting file\n    visitor - the file visitor to invoke for each file\nReturns:\n    the starting file\nThrows:\n    SecurityException - If the security manager denies access to the starting file. In the case of the default provider, the checkRead method is invoked to check read access to the directory.\n    IOException - if an I/O error is thrown by a visitor method','Input/Output',1,NULL),(1373,'FileVisitor methods return what ?','FileVisitResult','Input/Output',1,NULL),(1374,'Enum FileVisitResult elements','CONTINUE\nSKIP_SIBLINGS = continue without visiting the siblings of this file or directory\n\nSKIP_SUBTREE = continue without visiting the entries in this directory\n\nTERMINATE','Input/Output',1,NULL),(1375,'SimpleFileVisitor has a protected constructor so It can only be extended','SimpleFileVisitor sf = new SimpleFileVisitor() will not compile','Input/Output',1,NULL),(1376,'try(DirectoryStream stream = Files.newDirectoryStream(dir)){\n	sout(\"throw excpetion\");\n	//do stuff\n}\n\nWhats wrong here ?','DirectoryStream throws an IOException. Therefore anytime you use \nDirectoryStream you must catch an IOException\n\ntry(DirectoryStream stream = Files.newDirectoryStream(dir)){\n	sout(\"throw excpetion\");\n	//do stuff\n} catch(IOException e) { \n	log(e);\n}','Input/Output',1,NULL),(1377,'try(DirectoryStream stream = Files.newDirectoryStream(dir)){\n\n	for(Path file : stream){\n		sout(file.getFileName());\n	}\n} catch(IOException e ){\n\n}\n\nWhats wrong here ??','If DirectroyStream is not typed it will give Object elements. Therefore\nto use an untyped DirectoryStream you would have to use...\n	\n	for(Object file : stream) {\n	\n	}\n\n... but thats usually not what you want so always do this>>>\n\n	try(DirectoryStream<Path> Stream = Files.newDirectoryStream(dir)){\n\n	} catch(IOExcetpion e) {\n\n	}','Input/Output',1,NULL),(1378,'\npublic class CopyCharacters {\n    public static void main(String[] args) throws IOException {\n\n        FileReader inputStream = null;\n        FileWriter outputStream = null;\n\n        try {\n            inputStream = new FileReader(\"xanadu.txt\");\n            outputStream = new FileWriter(\"characteroutput.txt\");\n\n            int c;\n            while ((c = inputStream.read()) != -1) {\n                outputStream.write(c);\n            }\n        } finally {\n            if (inputStream != null) {\n                inputStream.close();\n            }\n            if (outputStream != null) {\n                outputStream.close();\n            }\n        }\n    }\n}\n','All character stream classes are descended from Reader and Writer. \nAs with byte streams, there are character stream classes that specialize in file I/O: FileReader and FileWriter. \nThe CopyCharacters example illustrates these classes.\n\nclose() throws IOException here too','Input/Output',1,NULL),(1379,'What has to be done with pretty much ALL IO classes ?','wrap them in Try Block, they all throw IOExceptions ','Input/Output',1,NULL),(1380,'What method does BufferedReader have that makes it valuable	','public String readLine()\n                throws IOException\n\nReads a line of text. A line is considered to be terminated by any one of a line feed (\'\\n\'), a carriage return (\'\\r\'), or a carriage return followed immediately by a linefeed.\n\nReturns:\n    A String containing the contents of the line, not including any line-termination characters, or null if the end of the stream has been reached\nThrows:\n    IOException - If an I/O error occurs\n\n\nOther IO classes have read methods that only read in a single character\nBufferedReader has this too. But this method really helps!','Input/Output',1,NULL),(1381,'Which IO class swallows exceptions and does not throw them but \nsaid exceptions can be checked using checkerror()','PrintWriter','Input/Output',1,NULL),(1382,'Path file = Paths.get(\"/home/dick/bigorsmall.txt\");\nBufferedWriter bw = new BufferedWriter(new FileWriter(file));\n\nbw.write(\"this ones pretty big \");','wont compile you cant construct a FileWriter from a Path not to mention there is an unreported IOException','Input/Output',1,NULL),(1383,'Files method:\n\nPath copy(Path src, Path targ, CopyOption...options)','Copy the file from the source to target and return the target.\n\nthrows FileAlreadyExistsException if target fiile already exists, and no\nREPLACE_EXSISTING copy Option is specified. ','Input/Output',1,NULL),(1384,'Files method:\n\nPath move(Path src, Path target, CopyOption options)','Moves the file from src to target return target. \n\nthrows:\n\n FileAlreadyExistsException - if the target file exists but cannot be replaced because the REPLACE_EXISTING option is not specified (optional specific exception)\n   \n DirectoryNotEmptyException - the REPLACE_EXISTING option is specified but the file cannot be replaced because it is a non-empty directory (optional specific exception)','Input/Output',1,NULL),(1385,'Path p1 = Paths.get(\"/home/One.txt\");\nPath p2 = Paths.get(\"One.txt\");\nPathMatcher matcher = FileSystems.getDefault().getPathMatcher(\"glob:*.txt\");\n\nsout( matcher.matches(p1) );\nsout( matcher.matches(p2) );','false \ntrue\n\nin glob * means match any character excpet a directory boundary\n\n** mathces any character across directory boundaries. \n\nnotice that PathMatcher(\"syntax:pattern\") can take a glob or a regex but you\nmust specify\n\nedit:\nwas previously:\nDefault().getPathMatcher(\"glob: *.txt\");\n\nthere cant be a space after the : or that will mathch...\n\n	Path path = Paths.get(\"one.txt\");\n        PathMatcher matcher = FileSystems.getDefault().getPathMatcher(\"glob: *.txt\");\n        System.out.println(matcher.matches(path));\n\nwould give false unless the space was removed. | Path p1 = Paths.get(\"/home/One.txt\");\nPath p2 = Paths.get(\"One.txt\");\nPathMatcher matcher = FileSystems.getDefault().getPathMatcher(\"glob: *.txt\");\n\nsout( matcher.matches(p1) );\nsout( matcher.matches(p2) );','Input/Output',1,NULL),(1386,'in Glob what does * mean ? what about ** ?','* matches any character inside a directory boundary\n** matches any character inside a directory boundary\n\n','Input/Output',1,NULL),(1387,'GLOB\n\nwhat does \"?\" mean ?','? matches any single character. ','Input/Output',1,NULL),(1388,'public class Hello {\n    public static void main(String[] args) {\n        PathMatcher matcher = FileSystems.getDefault().getPathMatcher(\"glob:**{.pic,.txt}\");\n        Path p1 = Paths.get(\"home/files.txt\");\n        Path p2 = Paths.get(\"documents/pictures/smile.pic\");\n        Path p3 = Paths.get(\"home/dir\");\n        \n        System.out.println(matcher.matches(p1));\n        System.out.println(matcher.matches(p2));\n        System.out.println(matcher.matches(p3));\n    }\n\n}','true\ntrue\nfalse','Input/Output',1,NULL),(1389,'public void matches(Path path, String glob){\n	PathMatcher matcher = FileSystems.getDefault().getPathMatcher(glob);\n	sout( matcher.matches(path) );\n}\n\nPath p1 = Paths.get(\"Bert-book\");\nPath p2 = Paths.get(\"Kathy-horse\");\nmatches(p1, \"glob:{Bert*,Kathy*}\");\nmatches(p2, \"glob: {Bert, Kathy}*\");\nmatches(p1, \"glob:{Bert,Kathy}\");','true\ntrue\nfalse','Input/Output',1,NULL),(1390,'FileVisitor\n\npublic FileVisitResult visitFileFailed(path file, BasicFileAttributes attrs) {\n\n	// do something\n	return FileVisitResult.CONTINUE;\n	\n}\n','wrong, visitFileFailed takes an IOExcpeption as a parameter\nas well as postVisitDirectory','Input/Output',1,NULL),(1391,'FileVisitor: \n\npublic FileVisitResult preVisitDirectory(path file, BasicFileAttributes attrs) {\n\n	// do something\n	return FileVisitResult.CONTINUE;\n	\n}','right, ','Input/Output',1,NULL),(1392,'FileVisitor:\n\npublic FileVisitResult visitFileFailed(path file, IOException e) {\n\n	// do something\n	return FileVisitResult.CONTINUE;\n	\n}','right','Input/Output',1,NULL),(1393,'FileVisitor:\n\npublic FileVisitResult postVisitDirectory(path file, IOException e) {\n\n	// do something\n	return FileVisitResult.CONTINUE;\n	\n}','right','Input/Output',1,NULL),(1394,'Date today = new Date();\n\nDateFormat df = DateFormat.getInstance();\n\nString todayFile = df.format(today);\n\nsout(todayFile);	// this gives 9/8/01 7:46 PM\n\ntodayFile.replaceAll(\" \",\"-\");\n\nsout( todayFile );\n\nwhat prints now ?','9/8/01 7:46 PM \n\nremember that strings are imutable, so even though you called \nreplaceAll on that string you didn\'t assing it to a new sString therefore it\nwas lost.\n\nshould be:\n	String newDate = todayFile.replaceAll(\" \",\"-\");','Strings',1,NULL),(1395,'Path p1 = Paths.get(todayFile+\".txt\");\nSystem.out.println(p1);\n        \nBufferedWriter bw = new BufferedWriter(new FileWriter(p1));','wont compile, FileWriter doesn\'t have a Path constructor,\n\nchange p1 to p1.toFile();\n\nFileWriter(File file)\nConstructs a FileWriter object given a File object.\n\nFileWriter(File file, boolean append)\nConstructs a FileWriter object given a File object.\n\nFileWriter(FileDescriptor fd)\nConstructs a FileWriter object associated with a file descriptor.\n\nFileWriter(String fileName)\nConstructs a FileWriter object given a file name.\n\nFileWriter(String fileName, boolean append)\nConstructs a FileWriter object given a file name with a boolean indicating whether or not to append the data written.','Input/Output',1,NULL),(1396,'class Eggs {\n	int doX(Long x, Long y){ return 1; }\n	int doX(long...){ return 2; }\n	int doX(Integer x, Integery){ return 3; }\n	int doX(Number n, Number m){ return 4; }\n	public static void main(SA){\n		new Eggs().go();\n	}\n	void go(){\n		short s = 7;\n		sout(doX(s,s) + \" \");\n		sout(doX(7,7));\n	}\n}','4 3 \n\ntwo rules apply to the first doX, you cannot widen and then box in\none step, and var-args are always chosen last. So you cannot widen shorts\nto ints or longs then box them to Integer or Long but you can box short\nto Short then widen that to Number, that takes priority over var args.\n\nthe second doX simmply boxs int to Integer.\n\n\n\n    Assignment contexts allow the use of one of the following:\n\n        an identity conversion (§5.1.1)\n\n        a widening primitive conversion (§5.1.2)\n\n        a widening reference conversion (§5.1.5)\n\n        a boxing conversion (§5.1.7) optionally followed by a widening reference conversion\n\n        an unboxing conversion (§5.1.8) optionally followed by a widening primitive conversion.\n\n\n','General',1,NULL),(1397,'What is the first and second argument to Files.walkFileTree()','the first is the directory to start walking at in the form of a Path\n\nthe second is an object of the class that extends SimpleFileVisitor<Path>','Input/Output',1,NULL),(1398,'Which Two FileVisitor methods take IOExceptions as parameters	?','visitFileFailed and postVisitDirectory','Input/Output',1,NULL),(1399,'Which two FileVisitor methods take BasicFileAttributes as parameters ?','preVisitDirectory and visitFile','Input/Output',1,NULL),(1400,'/home\n	- a.txt\n	- emptyChild	\n	- child\n		- b.txt\n		- grandchild\n			- c.txt\n\npublic class PrintDirs extends SimpleFileVisitor<Path> {\n	public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) {\n		sout( \"pre\" + dir);\n		String name = dir.getFileName().toString();\n		\n		if (name.equals(\"child\"))\n			return FileVisitResult.SKIP_SUBTREE;\n		return FileVisitResult.CONTINUE;\n\n	}\n}\n			\n			\n		\n	','now the output is:\n	pre: /home\n	file: /home/a.txt\n	pre: /home/child\n	pre: /home/emptyChild\n	post: /home/emptyChild\n	post: /home\n\npostVisitDirectory is never called if the subtree of the directory is skipped','Input/Output',1,NULL),(1401,'postVisitDirectory is never called if the subtree of the directory is skipped','','Input/Output',1,NULL),(1402,'/home\n	- a.txt\n	- emptyChild	\n	- child\n		b.txt\n		grandchild\n		c.txt\n\n\" assume you have FileVisitor method from previous flashcards where the\npre post and file are printed before printing the path of that dir or file \"\n\npublic FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) {\n	sout( \"pre: \" + dir);\n	String name = dir.getFileName().toString();\n	\n	if (name.equals(\"grandchild\"))\n		return FileVisitResult.SKIP_SUBTREE;\n	if ( name.equals(\"emptychild\")\n		return FileVisitResult.SKIP_SIBLINGS;\n	return FileVisitResult.CONTINUE;','assuming child is encountered beffore emptyChild, the output is: \n\npre: /home\nfile: /home/a.txt\npre: /home/child\nfile: /home/child/b.txt\npre: /home/child/grandchild\npost: /home/child\npre: /home/emptyChild\npost: /home\n\nyou skip the grandchld subtree so you dont see the postVisitDirectory call\n\nchild is a sibling but it was encountered before emptychild so it was not skipped','Input/Output',1,NULL),(1403,'public void matches(Path path, String glob){\n	PathMatcher matcher = FileSystems.getDefault().getPathMatcher(glob);\n	sout( matcher.matches(path) );\n}\n\nPath p1 = Paths.get(\"0*b/test/1\");\nPath p2 = Paths.get(\"9\\\\*b/test/1\");\nPath p3 = Paths.get(\"01b/test/1\");\nPath p4 = Paths.get(\"0*b/1\");\n\nString glob = \"[0-9]\\\\*{A*,b}/**/1\");\n\nmatches(p1,glob);\nmatches(p2,glob);\nmatches(p3,glob);\nmatches(p4,glob);\n','true \nfalse\nfalse\nfalse\n\n{A*,b} means A followed by anything or the single character b\n\n/**/ means one or more directories with any name\n\n\\\\* the actuall asterix character \\ escapes the * the second \\ espaces the first \\ ','Input/Output',1,NULL),(1404,'What exception if any do FileVisitor methods throw ?','IOException','Input/Output',1,NULL),(1405,'glob vs regex: \n\nZero or more of any character, including directory bounndary','glob: **\n\nregex: .*','Input/Output',1,NULL),(1406,'regex:\n\n.*','zero or or more of any character including directory boundary','Input/Output',1,NULL),(1407,'glob vs regex:\n\nZero or more of any character, not a directory boundary','glob: *\n\nregex: no syntax required','Input/Output',1,NULL),(1408,'Glob vs regex:\n\nexcactly one character','glob: ?\n\nregex: .','Input/Output',1,NULL),(1409,'glob vs regex:\n\nBegins with cat or dog','glob:\n	{cat, dog}*\n\nregex:\n\n	(cat|dog).*','Input/Output',1,NULL),(1410,'(cat|dog).*\n\nglob or regex ?','regex','Input/Output',1,NULL),(1411,'You are creating a PathMatcher\n\nPathMatcher matcher = ________._________().__________();','FileSystems.getDefault().getPathMatcher();','Input/Output',1,NULL),(1412,'You are creating a WatchService:\n\nWatchService watcher = _____________.__________()._________()','FileSystems.getDefault().newWatchService();','Input/Output',1,NULL),(1413,'What do you get from a WatchService to indicate a deletion creation or modification','WatchKey\ntry {\n	WatchKey key;\n	try {\n	key = watcher.take();\n              } catch(interuptedException x) {\n		return;\n	}\n	for(WatchEvent<?> event : key.pollEvents()){\n	//do stuff\n	}','Input/Output',1,NULL),(1414,'What are two ways to get a WatchKey ? \nand whats the difference between them ? ','take() will wait and block forever until an event takes place. Will throw\nInteruptedException if interuped without taking an event. \n\npoll() returns null if an event is not imediately available. ','Input/Output',1,NULL),(1415,'public class Frodo etends Hobbit {\n	public static void main(SA) { \n		int mygold = 7;\n		sout(countGold(mygold,6));\n	}\n}\nclass Hobbit {\n	int countGold(int x, int y) { return x + y; }\n}','does not compile countGold() cannot be called from a static context','Input/Output',1,NULL),(1416,'The contract between equals() and hashCode() is:','1) If two objects are equal, then they must have the same hash code.\n2) If two objects have the same hash code, they may or may not be equal. \n3) If two objects are not equal, they must NOT have the same hashcode\n','OOP',1,NULL),(1417,' public static void main(String[] args){\n       Path dir = Paths.get(\"/home/maxbisesi\");\n       try(DirectoryStream<Path> stream = Files.newDirectoryStream(dir,\"*\");){\n            for(Path path : stream){\n               System.out.println(path);\n            }\n        } catch(IOException e){\n            System.out.println(\"SQLException\");\n            System.out.println(e);\n        }\n   }','shows all files and directories in /home/maxbisesi\n\nsqlexception if the path is not a valid path','Input/Output',1,NULL),(1418,'public class Hello {\n    synchronized void a() { actBusy(); }\n    static synchronized void b() { actBusy(); }\n    static void actBusy() {\n        try {\n            Thread.sleep(1000);\n            \n        } catch( InterruptedException e){}\n            \n        \n    }\n    public static void main(String[] args) {\n        final Hello x = new Hello();\n        final Hello y = new Hello();\n        \n        Runnable runnable = new Runnable() {\n            public void run() {\n                int option = (int) (Math.random() * 4);\n                switch(option) {\n                    case 0: x.a(); break;\n                    case 1: x.b(); break;\n                    case 2: y.a(); break;\n                    case 3: y.b(); break;\n                }\n            }\n        };\n        \n        Thread t1 = new Thread(runnable);\n        Thread t2 = new Thread(runnable);\n        \n        t1.start();\n        t2.start();\n    \n    }\n\n}  \n\nwhich methods could never be running at the same time ?','x.a() thread1 x.a() in thread2\nx.b() thread1 x.b() in thread2\nx.b() thread1 y.b() in thread2\n\nthe same instance method of the same instance is blocked while a static\nmethod accross all methods is blocked. ','Threads',1,NULL),(1419,'Method forwarding relies on Has-a relationships','got it ','OOP',1,NULL),(1420,'class Animal implements Burriable {\n    private Integer size;\n    private String name;\n    \n    public Animal(int x, String y){\n        size = x;\n        name = y;\n    }\n    public Animal(){\n        size = 0;\n        name = \"\";\n    }\n\n    public int getSize() {\n        return size;\n    }\n\n    public String getName() {\n        return name;\n    }\n    \n    public void bury(){\n        System.out.println(\"just toss him in there...\");\n    }\n    public void digUp(){\n        System.out.println(\"Hang on this ones still kickin !\");\n    }\n    public void pray(){\n        System.out.println(\"...Lord forgive us for what we have done, hes only been gone for \"+YEARSDEAD+\" years.\");\n    }\n}\n\nclass Dog implements Burriable{\n    private Animal animal;\n    public Dog(Animal a){\n        animal = a;\n    }\n    \n    public void bury(){\n        animal.bury();\n    }\n    public void digUp(){\n        animal.digUp();\n    }\n    public void pray(){\n        animal.pray();\n    }\n    \n    public String yelpForHelp(){\n        return \"ar ar arrr....\";\n    }\n}\n\ninterface Burriable {\n    int YEARSDEAD = 1;\n    void bury();\n    void digUp();\n    void pray();\n}\n\nwhat OOP principle is this ?','method forwarding\n\nan object composition principle that calles methods on an instance variable of an object','OOP',1,NULL),(1421,'public class F {\n	private static final F f = new F();\n	public static F c(){\n		return f;\n	}\n\n	public void update(F a) { }\n	\n	public void delete(F a) { }\n\n}\nwhat design pattern is this ? ','The singleton pattern is identifiable bby the static variable for the single instance and the accessor returning it. ','OOP',1,NULL),(1422,'public class E {\n	private D d;\n	public void m() {\n		d.m();\n	}\n\n		public static E getInstance() {\n			return new E();\n		}\n}\n\nclass D {\n	public void m() { }\n}\n\nwhat design pattern principle is this ?\n','object composition, you can tell because of the method forwarding. \nSingleton is tempting but the getInstance method here returns a NEW instance\ninstead a single private static one like it should to be singleton. ','OOP',1,NULL),(1423,'class A {}\n\nabstract class G {\n	A m() { return n(); }\n	abstract A n();\n}\n\nwhat principle is demostrated','Factory,\n\nClass A is the object we are creating using the factory method. class G\nis the abstract superclass for the factory. Not shown is a class implementing \nclass G that actually creates the object. ','OOP',1,NULL),(1424,'which is a benefit of the DAO pattern ?	','Reuse The DAO pattern centralize logic for the data access code making reuse\neasier and allowing you to switch out implementations. ','OOP',1,NULL),(1425,'public void print(Path d) throws IOException {\n	try(DirectoryStream<Path> stream = Files.newDirectoryStream(d)){\n		for(Path path: stream){\n			sout( path.getFileName() );\n		}\n	}\n}\n\nwhat files will this display ? ','regular files, hidden files, and subdirectories','Input/Output',1,NULL),(1426,'public class Hello {\n    public static void main(String[] dicks) throws IOException{\n      Path src = Paths.get(\"/home/maxbisesi/Documents/copy.txt\");\n      Files.createFile(src);\n      \n      Files.copy(src, Paths.get(\"/home/maxbisesi/Documents/newcopy.txt\"));\n      \n    }\n\n}\n\nwhat happens if this is ran twice and all preivous files dont exist before','The first time the file will be created and copied normally the second time you\nwill get a file already exists excpeiotn','Input/Output',1,NULL),(1427,'public class Hello {\n    public static void main(String[] dicks){\n        ArrayList list = new ArrayList();\n        \n        list.add(\"java\");\n        list.add(\"sucks\");\n        \n        String item = list.get(0);\n\n    }\n\n}','Compilation fails, to compile would have to be \n\n	Object item = list.get(0);','Collections',1,NULL),(1428,'if(true)\n       int b = 1;\n        ','Will not compile, there is no scope there \n\nif(true){\n	int b = 1;\n} \n	this would though !','General',1,NULL),(1429,'public class Hello {\n    public static void main(String[] dicks){\n        Pattern p = Pattern.compile(\"C.*L\");\n        Matcher m = p.matcher(\"CooLooLCuuLooC\");\n        \n        while(m.find())\n            System.out.println(m.group());\n\n    }\n\n}','CooLooLCuuL\n\n* is the greedy quantifier, it takes as much as it can. ','Strings',1,NULL),(1430,'If a thread\'s priority is not specified explicitly then it gets\nNORM_PRIORITY\n\nT or F ','False it gets the same priority as the thread that created it ','Threads',1,NULL),(1431,'public class Hello {\n    public static void main(String[] dicks){\n        Animal ah2 = new Horse();\n        ah2.eat(\"carrots\");\n    }\n\n}\n\nclass Animal{\n    public void eat(){ }\n}\n\nclass Horse extends Animal {\n    public void eat() { }\n    public void eat(String s ){ } \n}\n    ','Will not compile, method eat in class animal cannot be applied to given types','General',1,NULL),(1432,'public class Hello {\n    public static void main(String[] dicks){\n        Animal ah2 = new Horse();\n        ah2.eat();\n    }\n\n}\n\nclass Animal{\n    public void eat(){ System.out.println(\"Animal\"); }\n}\n\nclass Horse extends Animal {\n    public void eat(){ System.out.println(\"Horse\");} \n}\n\n','Horse','General',1,NULL),(1433,'public class Hello {\n    public static void main(String[] dicks){\n        Animal ah2 = new Horse();\n        ah2.eat();\n    }\n\n}\n\nclass Animal{\n    public void eat(){ System.out.println(\"Animal\"); }\n}\n\nclass Horse extends Animal {\n    public void eat() throws IOException{ System.out.println(\"Horse\");} \n}','will not compile overriden method \ncannot throw new or broader checked exceptions','General',1,NULL),(1434,'public class Hello {\n    public static void main(String[] dicks){\n        Animal ah2 = new Horse();\n        ah2.eat();\n    }\n\n}\n\nclass Animal{\n    public void eat(){ System.out.println(\"Animal\"); }\n}\n\nclass Horse extends Animal {\n    public void eat(int x) throws IOException{ System.out.println(\"Horse\");} \n}','Animal\n\neat in horse is an overload, it still inherits Animals eat()','General',1,NULL),(1435,'//assume valid Connection cn, and good database connection\n\nString query = \"Select * from Answer\";\ntry(Statement stmt = cn.createStatement()){\n	ResultSet rs1 = stmt.executeQuery(query);\n	stmt.executeQuery(\"select * from Question\");\n	while(rs1.next(){\n		sout(rs1.getInt(\"fk_question_num\");\n	}\n} catch(SQLException e){\n	\n}','SQLException\n	Statement objects do not support multiple open ResultSets.\n	\n	Only a single ResultSet can be opened from the same statement object\n\n	*if the same statement object is executed more than once the previous\n	ResultSet is closed automatically\n		\n		... and attempting to access a closed RS is a SQLException','JDBC',1,NULL),(1436,'','','blank',1,NULL),(1437,'try(Connection conn = DriverManager.getConnection(url,user,pw)){\n	String pQuery = \"Select unitPrice From Book Where Title Like ?\";\n\n	PreparedStatement pstmt = conn.prepareStatement(pQuery);\n\n	ResultSet rs = pstmt.executeQuery();\n} catch(SQLException sq) {\n}\n','SQLException , attempting to execute a query without setting a parameter\nresults in an SQLException\n\n	should be>>>\n		\n		pstmt.setString(1,\"dick\");\n\nIndexing starts at 1','JDBC',1,NULL),(1438,'public class Hello {\n    public static void main(String[] dicks){\n        try{\n            couldthrow();\n        } catch(IOException | SQLException e){\n            \n        }\n        \n    }\n    \n    public static void couldthrow() throws IOException, SQLException{\n        \n    }\n\n}','compiles and runs just fine ','Exceptions',1,NULL),(1439,'public boolean equals(Object o) { \n	if(((Moof)o).getMoofValue() == this.moofValue {\n		return true;\n	} else {\n		return false;\n	}\n}\n\nwhats missing here','instanceof test','Collections',1,NULL),(1440,'equals() hashCode() and toString() are all PUBLIC','got it','Collections',1,NULL),(1441,'equals() Contract\n\nreflexive	','for any reference value x, x.equals(x) should be true. ','Collections',1,NULL),(1442,'equals() contract,\n\nsymmetric','for any reference values x and y, \n\nx.equals(y) shoud be true if and only if \ny.equals(x) returns true. ','Collections',1,NULL),(1443,'what are the four tenants of the equals contract ?','reflxive, x.equals(x) is always true\n\nsymetric, x.equals(y) and y.equals(x)\n\ntransitive, if x.equals(y) and y.equals(z) then x.equals(z)\n\nconsistent, x.equals(y) is true no matter how many times you call it\n\nif x is non null, x.equals(null) is always false','Collections',1,NULL),(1444,'if two objects are considered equal, their hashcodes...','MUST also be equal.','Collections',1,NULL),(1445,'Is it still legal to have a hashcode that always returns the same number ?','Yes just inefficient, all objects will go in the same bucket. The Collection\nwill search through a single big bucket using equal() to find the instance\nits looking for. In that case you defeat the purpose of using a hashed collection. ','Collections',1,NULL),(1446,'HashCode contract:\n\n1\n\n2\n\n\n3','When it is invoked on the same object more than once during an execution\nof a java application the hashcode() method must consistently return the \nsame integer \n\nIf two objects are equal according to the equals method, then calling hashchode)( \non each of the objects must produce the same integer\n\nunequal objects can still produce the same hashcodes \n\n*That means that equals and hashCode must work with same attributes somehow','Collections',1,NULL),(1447,'x.equals(y) == true\n\nmeans what for hashcode()...','x.hashcode() == y.hashcode()','Collections',1,NULL),(1448,'x.hashCode() != y.hashCode()	\n\nmeans what for equals()','x.equals(y) == false\n\nequals() and hashcode are like directions to get to a specific \nelement\n\nhashCode places all the elements in seperate but similiar buckets \nequals() gets the correct ones out.\n\nso if two elemets have different hashCodes they will be in different buckets\nanyway so hashCode is one level of precision and equals() is the next.','Collections',1,NULL),(1449,'public static void main(String[] args){\n        Path p = Paths.get(\"/home/maxbisesi/Public/GenDir/genFile.txt\");\n        Path p2 = Paths.get(\"/home/maxbisesi/Public\");\n        \n        System.out.println(p.relativize(p2));\n        System.out.println(p2.relativize(p));  \n}','../..\nGenDir/genFile.txt\n','Input/Output',1,NULL),(1450,'Collections:\n\n	Vector\n','a Vector is the same as an ArrayList but Vector methods are synchronized\nfor thread safety. \n\nVector and Hashtable are the two original collections\n\nunless you really need thread safety choose ArrayList over Vector, \nthe synchronized methods give an unecssary performance hit. \n\n','Collections',1,NULL),(1451,'Collections:\n\n	LinkedList','is ordered by index position except that the elements are doubly linked to \none another. This linkage gives you new methods for adding and removing\nfrom the beginning or end.\n\nEasy choice for implementing a stack or queue. \n\nmay iterate more slowly than ArrayList but still a good choice when you need\nfast insertion and deletion.\n\nLinkedList supports peek(), poll(), offer(), Queue methods!!','Collections',1,NULL),(1452,'Which Interface disallows duplicates','Set','Collections',1,NULL),(1453,'Collections:\n	\n	HashSet','unsorted and unordered. Uses the hashcode of the object being inserted\n\nso the more effeicinet your hashcode the more effecient access youll get\n\nUse for a collection with no duplicates where you dont care about the\norder when you iterate through it.','Collections',1,NULL),(1454,'Collections:\n\n	LinkedHashSet','\nMaintains a doubly linked list across elelemnts so the insertion order \nis maintained\n\nduplicates are still disallowed. ','Collections',1,NULL),(1455,'Collections:\n\n	TreeSet','Sorted\n\nguarentees elements will be in ascending order according to natural order\n\n','Collections',1,NULL),(1456,'public class Reader {\n	public void read(Path p, Charset s) {\n		try(BufferedReader r = Files.newBufferedReader(p,s)) {\n			try { r.read(); }\n			catch(IOException f) {\n				r.readLine();\n			}\n		} catch(IOException || NullPointerException e) {\n			r.close();\n		} finally {\n			r.close();\n		}\n	}\n}','compilation fails at the last three lines,\n\n1. multi catch syntax is | not ||\n\n2. objects declared in a try block are only available within the \ntry block so closing r is out of scope','Input/Output',1,NULL),(1457,'Collections:\n\n	HashMap','unsorted and unordered Map. \n\nUse When you need a map and you don\'t care\nabout the order when you iterate through. \n\nThe basic map, other maps add a little more overhead. \n\nWhere keys land in the map is based on hashCode() \n\nHashMap allows one null key and multiple null values ','blank',1,NULL),(1458,'Collections:\n	\n	Hashtable\n	','Hashtable is the synchronized counterpart to HashMap. \n\nWhile HashMap lets you have a null key and null values\n\nHashtable doesn\'t allow anything thats null!','Collections',1,NULL),(1459,'HashMap allows multiple null values','True!\n\nHashtable doesn\'t allow anything null it will throw a npe','Collections',1,NULL),(1460,'HashMap allows multiple null keys','FALSE\n\nThat would defeat the purpose of a \"key\"','Collections',1,NULL),(1461,'HashMap is sorted','FALSE\n\nunordered and unsorted','Collections',1,NULL),(1462,'HashMap is synchronized','FALSE','Collections',1,NULL),(1463,'Hashtable is synchronized ','True!','Collections',1,NULL),(1464,'Hashtable allows multiple null values and one null key','FALSE, nothing can be null in Hashtable','blank',1,NULL),(1465,'public static ArrayList<Animal> staggerSort(ArrayList<? extends Animal> list){\n        Map<String,List<Number>> byCategory = seperateToCategories(list);\n        return null;\n    }\n    \n    static Map<String,List<Number>> seperateToCategories(ArrayList<Animal> list){\n        return null;\n    }','since list is declared as anything that extends Animal you cant be sure that it\nwill be the right type to pass into the next method that taks <Animal>\n\nWill not compile','Generics',1,NULL),(1466,'public static void main(String[] args){\n        LinkedHashMap<String,String> lhm = new LinkedHashMap<>();\n        lhm.put(\"big\",\"Country\");\n        lhm.put(\"sweet\",\"Cheeks\");\n        lhm.put(\"big\",\"Bucks\");\n        \n        for(Map.Entry<String,String> entry: lhm.entrySet()){\n            System.out.println(entry.getKey()+\" \"+entry.getValue());\n        }\n        \n    }','big Bucks\nsweet Cheeks\n\nbig Bucks replaced big Country in the map, LinkedHashMaps maintain insertion\norder. \n\nso that mapping was simply replaced but it kept its position','Collections',1,NULL),(1467,'class Gutsy {\n	public static void main(String[] args){\n		new Gutsy().go();\n	}\n	void go() throws IOException {\n	String row;\n	try {\n		FileReader fr = new FileReader(\"TestFile.txt\");\n		BufferedReader br = new BufferedReader(fr);\n		while((row = br.readLine() ) != null)\n			sout( row );\n	} catch(IOException e) {\n		sout(\"got io error\");\n	} finally {\n		sout( \"done\" );\n	}\n   }\n}','WNC,\n\ngo() declares that it throws a checked exceptions so it has to be handled\nor thrown in main.\n\nif that would have compiled an IOException would be thrown so it would\nprint got io error done. ','Exceptions',1,NULL),(1468,'Given a properly prepared string[] with five elements what is the range \nof possible results that could be returned by Arrays.binarySearch() ? ','-6 through 4','Collections',1,NULL),(1469,'TreeMap','sorted Map\n\nsorted by natural order or custom comparison rules.','blank',1,NULL),(1470,'List<String> test = new ArrrayList<String>();\nString s = \"hi\";\ntest.add(\"string\");\ntest.add(s);\ntest.add(s+s);\nsout( test.size() );\nsout( test.contains(42) );\nsout( test.contains(\"hihi\") );\ntest.remove(\"hi\");\nsout( test.size() );','3\nfalse\ntrue\n2','Collections',1,NULL),(1471,'List myInts = new ArrayList();\n        myInts.add(4);\n        \n        myInts.add(new Integer(4));','These two are the same, the first demonstrates autoboxing. ','blank',1,NULL),(1472,'class Boxing2 {\n	static Integer x;\n	psvm(sa) {\n		doStuff(x);\n	}\n\n	static void doStuff(int z) {\n		int z2 = 5;\n		sout( z2 + z );\n	}\n}','NullPointerException','General',1,NULL),(1473,'public static void main(String[] dicks){\n        ArrayList<String> list = new ArrayList<>();\n        \n        list.add(\"CZ\");\n        list.add(\"a\");\n        list.add(\"AB\");\n        list.add(\"CE\");\n        list.add(\"CZ\");\n        list.add(\"cz\");\n        list.add(\"BA\");\n        list.add(\"BF\");\n        list.add(\"ABC\");\n        list.add(\"CE\");\n        list.add(\" CE\");\n        list.add(\"A\");\n        list.add(\"ce\");\n        list.add(\"A B\");\n        list.add(\"AA\");\n        list.add(\" Z\");\n        \n        System.out.println(\"unsorted: \"+list);\n        Collections.sort(list);\n        System.out.println(\"sorted: \"+list);','unsorted: [CZ, a, AB, CE, CZ, cz, BA, BF, ABC, CE,  CE, A, ce, A B, AA,  Z]\nsorted: [ CE,  Z, A, A B, AA, AB, ABC, BA, BF, CE, CE, CZ, CZ, a, ce, cz]\n\nspaces come first, as shown by A B and AA. Also capitals come before lowercase','Collections',1,NULL),(1474,'public class Hello {\n    public static void main(String[] dicks){\n        List<Horse> stable = new ArrayList<>();\n        \n        for(int x =0; x < 10; x++){\n            stable.add(new Horse());\n        }\n        \n        Collections.sort(stable);\n        \n    }\n\n}\n\nclass Horse {\n    public boolean equals(Horse s){\n        return false;\n    }\n}','Will not compile, Horse does not implement Comparable','Collections',1,NULL),(1475,'class Horse implements Comparable<Horse> {\n    public boolean equals(Horse s){\n        return false;\n    }\n    \n    int compareTo(Horse h){\n        \n    }\n    \n    \n}','will not compile, compareTo is public ','Collections',1,NULL),(1476,'public class Hello {\n    public static void main(String[] dicks){\n        List<Horse> stable = new ArrayList<>();\n        \n        for(int x =0; x < 10; x++){\n            stable.add(new Horse(\"lucky\"+x));\n        }\n        \n        Collections.sort(stable);\n        \n    }\n\n}\n\nclass Horse implements Comparable<Horse> {\n    String name;\n    \n    public Horse(String x){\n        name = x;\n    }\n    \n    public String getName(){\n        return name;\n    }\n    \n    public boolean equals(Horse s){\n        return false;\n    }\n    \n    public int compareTo(Horse h){\n        return name.compareTo(h.getName());\n        \n    }\n    \n    \n}','compiles fine!','Collections',1,NULL),(1477,'When you override equals() you must take an argument of what type ?','Object','Collections',1,NULL),(1478,'When you override compareTo() you must take an argument of type?','The type your sorting.\n\n\npublic interface Comparable<T>\n\n...type T','Collections',1,NULL),(1479,'class DVDInfo implements Comparable {\n	public int comparteTo(Object o) {\n		DVDInfo d = (DVDInfo) o;\n		return title.compareTo(d.getTitle() );\n	}\n}','This is still legal but painful, genereics make this easier but it will still \ncompile','Collections',1,NULL),(1480,'Comparator has _________________\n\nComparable has _________________','compare()\n\ncompareTo()','Collections',1,NULL),(1481,'Which soritng interface do you implement to create individual sorting classes\n	','Comparator','Collections',1,NULL),(1482,'class Dicksorter implements Comparator<Dicks> {\n	public int compareTo(Dick one) {\n	}\n}','will not compile the method is:\n\n	int compare(T o1, T o2)','Collections',1,NULL),(1483,'class DickSorter implements Comparator<Dick> {\n	public int compare(Dick one, Dick two){\n		return one.getSize().compareTo(two.getSize());\n	}\n}','compiles fine, this takes advvantage of integer comparison','Collections',1,NULL),(1484,'public class Hello {\n    public static void main(String[] dicks){\n        List<Horse> stable = new ArrayList<>();\n        \n        stable.add(new Horse(\"Honey\"));\n        stable.add(new Horse(\"Mighty Mikey\"));\n        stable.add( new Horse(\"The Fastest Stud in the Mud\"));\n        stable.add( new Horse(\"Churchill\"));\n        \n        Horse[] ranch = stable.toArray();\n\n    }\n\n}','Will not compile\n\ntoArray() in List interface returns an Object[]','Collections',1,NULL),(1485,'public class Hello {\n    public static void main(String[] dicks){\n        Horse[] stable = {new Horse(\"Johny\"), new Horse(\"wilfred\"), new Horse(\"Marco\"), new Horse(\"MAx\"), new Horse(\"Billy\") };\n        \n        int x = Arrays.binarySearch(stable,\"Johny\");\n        System.out.println(x);  \n\n    }\n\n}','ClassCastException, \"johny\" cant be turned into a horse\n\nshould be Arrays.binarySearch(stable,new Horse(\"Johny\"));','Collections',1,NULL),(1486,'public class Hello {\n    public static void main(String[] dicks){\n        Horse[] stable = {new Horse(\"Johny\"), new Horse(\"wilfred\"), new Horse(\"Marco\"), new Horse(\"MAx\"), new Horse(\"Billy\") };\n        \n        int x = Arrays.binarySearch(stable,new Horse(\"Johny\"));\n        System.out.println(x);  \n\n    }\n\n}    \n\nclass Horse implements Comparable<Horse> {\n    String name;\n    \n    public Horse(String x){\n        name = x;\n    }\n    \n    public String getName(){\n        return name;\n    }\n    \n    public boolean equals(Horse s){\n        return false;\n    }\n    \n    public int compareTo(Horse h){\n        return name.compareTo(h.getName());\n        \n    }\n    \n    \n    ','The results are undefined, the array is not sorted. ','Collections',1,NULL),(1487,'public class Hello {\n    public static void main(String[] dicks){\n        Horse[] stable = {new Horse(\"Johny\"), new Horse(\"wilfred\"), new Horse(\"Marco\"), new Horse(\"MAx\"), new Horse(\"Billy\") };\n        \n        \n        int x = Arrays.binarySearch(stable,new Horse(\"Marco\"));\n        System.out.println(x);  \n\n    }\n\n}\n\nclass Horse {\n    String name;\n    \n    public Horse(String x){\n        name = x;\n    }\n    \n    public String getName(){\n        return name;\n    }\n    \n    public boolean equals(Horse s){\n        return false;\n    }\n    \n}','ClassCastException Horse cannot be converted to Comparable\n\nbinarySearch uses comparable to search the Array.\n\nThis search would give inconsistant results anyways because \nthe array was not sorted first. \n\nto fix add this:\n\nclass Horse implements Comparable<Horse> {\n    String name;\n    \n    public Horse(String x){\n        name = x;\n    }\n    \n    public String getName(){\n        return name;\n    }\n    \n    public boolean equals(Horse s){\n        return false;\n    }\n    \n    public int compareTo(Horse s){\n        return name.compareTo(s.getName());\n    }\n    \n}\n\n-if an array is sorted in natrual order it must searched in natural order \n-if it is sorted using a comparator it must be searched using the same comparator.\n','Collections',1,NULL),(1488,'public class Hello {\n    public static void main(String[] dicks){\n        Horse[] stable = {new Horse(\"Johny\"), new Horse(\"wilfred\"), new Horse(\"Marco\"), new Horse(\"MAx\"), new Horse(\"Billy\") };\n        int x = Arrays.binarySearch(stable,new Horse(\"Marco\"));\n        System.out.println(x);  \n    }\n}\n\nclass Horse implements Comparable{\n    String name;\n    public Horse(String x){\n        name = x;\n    }\n    public String getName(){\n        return name;\n    }\n    public boolean equals(Horse s){\n        return false;\n    }\n    public int compareTo(Horse h){\n        return name.compareTo(h.getName());  \n    }\n}\n','Will not compile, if the untyped version of Comparable is used then\nthe parameter to compareTo would be Object\n\neither change to Comparable<Horse>\n\nor \n\ncomparTo(Object o) and cast.\n\notherwise, the answer would be 2 remember arrays aren\'t sorted even though\nyour using comparable the elements of an array dont get sorted so the positions are \nwhat index they were defined as !\n\nThis would give undefined results','Collections',1,NULL),(1489,'What method is used to search through Arrays and Collections','binarySearch()\n\nreturns the int index of the element being searched.\n\nUnsuccesful searches return an int index that represents the\n insertion point. \n\nThe collection or array must be sorted before you can search it.\n\nif you attempt to search an unsorted array or collection the results of the\nsearch will be unpredictable.\n\nIf it was sorted in natural order it must searched in natural order.\n	do this by NOT sending a Comparator as an argument to the binarySearch() \n\nIf it was sorted with a comparator it must be searched using the same comparator\n\n	\n	','Collections',1,NULL),(1490,'class Horse implements Comparable{\n    String name;\n    \n    public Horse(String x){\n        name = x;\n    }\n    \n    public String getName(){\n        return name;\n    }\n    \n    public boolean equals(Horse s){\n        return false;\n    }\n    \n    public int compareTo(Object h){\n        return name.compareTo(h.getName());\n  \n    }','will not compile, need to cast\n\nreturn name.compareTo(((Horse)h).getName());\n\ndoes not compile because h is an Object and Objects dont have a method\ncalled getName. \n\nyou would cast h to a horse. \n\nObject is the right argument type here though because Comparable is a raw type\nif it were Comparable<Horse> the argument would need to be Horse.','Collections',1,NULL),(1491,'public class Hello {\n    public static void main(String[] dicks){\n       Animal[] beavers = new Beaver[5];\n       \n       Animal[] animals = {new Beaver(), new Beaver(), new Beaver() };\n       \n       Animal[] ans2 = new Animal[5];\n       ans2[0] = new Beaver();\n\n    }\n}\n\nclass Animal{\n    public Animal(){\n        \n    }\n    \n    public String getName(){\n        return \"d\";\n    }\n}\n\nclass Beaver extends Animal{\n    \n}','these all compile fine, \n\nPolymorphism works with Arrays. ','Collections',1,NULL),(1492,'public class Hello {\n    public static void main(String[] dicks){\n       \n        String[] strings = {\"One\",\"Dice\",\"Angela\",\"Bisesi\",\"Franko\"};\n        \n        Arrays.sort(strings);\n        int x = Arrays.binarySearch(strings,\"Dice\");\n        System.out.println(x);  \n        \n        Arrays.sort(strings);\n        \n        System.out.println(Arrays.binarySearch(strings,\"Angela\"));\n    }\n\n}','2\n0','Collections',1,NULL),(1493,'class sortBySecondLetter implements Comparator<String> {\n    int compare(String one, String two){\n        \n    }\n}','compare must be public, will not compile','Collections',1,NULL),(1494,'class sortBySecondLetter implements Comparator<String> {\n    public int compare(String one, String two){\n        char charone = one.charAt(1);\n        char chartwo = two.charAt(1);\n        \n        return charone.compareTo(chartwo);\n    }\n}','will not compile, char is a primitive so charone cannot be dereferenced here\nchange to Character.','Collections',1,NULL),(1495,'public class Hello {\n    public static void main(String[] dicks){\n        sortBySecondLetter sbsl = new sortBySecondLetter();\n        String[] strings = {\"One\",\"Dice\",\"Angela\",\"Bisesi\",\"Franko\"};\n        \n        Arrays.sort(strings,sbsl);\n        \n        System.out.println(strings);\n    }\n\n}','[Ljava.lang.String;@15db9742\n\narrays are not classes','Collections',1,NULL),(1496,'String[] sa = {\"one\", \"two\", \"three\", \"four\" };\nList sList = Arrays.asList(sa);\n\nSout( \"size \" + sList.size() );\nsout( \"idx2 \" + sList.get(2) );\n\nsList.set(3,\"six\" );\nsa[1] = \"five\";\n\nfor(String s : sa ){\n	sout( s + \" \");\n}\nsout(\"\\n s1[1] \" + sList.get(1) );','size 4\nidx2 three\none \nfive \nthree \nsix \ns1[1] five','Collections',1,NULL),(1497,'public class Hello {\n    public static void main(String[] args){\n        String[] sa = {\"one\", \"two\", \"three\", \"four\" };\n        List sList = Arrays.asList(sa);\n\n        System.out.println( \"size \" + sList.size() );\n        System.out.println( \"idx2 \" + sList.get(2) );\n\n        sList.set(3,\"six\" );\n        sa[1] = \"five\";\n\n        for(String s : sa ){\n            System.out.println( s + \" \");\n        }\n        System.out.println(\"s1[1] \" + sList.get(1) );\n        \n        sList.remove(\"five\");\n        for(String s : sa)\n            System.out.println(s+\" \");\n    }\n\n}','UnsupportedOperationException\n\nThis UnsupportedOperationException comes when you try to perform some operation on collection where its not \nallowed and in your case, When you call Arrays.asList it \ndoes not return a java.util.ArrayList. It returns a java.util.Arrays$ArrayList which is an immutable list. \nYou cannot add to it and you cannot remove from it.\n\nReturns a {@code List} of the objects in the specified array. The size of the {@code List} cannot be modified, i.e. adding and removing are unsupported, but the elements can be set. Setting an element modifies the underlying array.\n\nEDIT\n\nThe type of the resulting list is Arrays.ArrayList, which is a private class inside Arrays.class. Practically speaking,\nit is nothing but a List-view on the array that you\'ve passed with Arrays.asList. With a consequence: if you change the array, the list is changed too. And because an array is not resizeable, \nremove and add operation must be unsupported.\n','Collections',1,NULL),(1498,'String[] sa = {\"one\", \"two\", \"three\", \"four\" };\n        List sList = Arrays.asList(sa);\n\n        System.out.println( \"size \" + sList.size() );\n        System.out.println( \"idx2 \" + sList.get(2) );\n\n        sList.set(3,\"six\" );\n        sa[1] = \"five\";\n\n        for(String s : sa ){\n            System.out.println( s + \" \");\n        }\n        System.out.println(\"s1[1] \" + sList.get(1) );\n        \n        sList.set(1, \"FIVE\");\n	sList.set(3,\"SIX);\n        for(String s : sa)\n            System.out.println(s+\" \");','size 4\nidx2 three\none \nfive \nthree \nsix \ns1[1] five\none \nFIVE \nthree \nSIX\n\nThis shows that Arrays and Lists coming from\nArrays.asList() are \"joined at the hip\" changes in one affect \nthe other. This is different from a \"Backed Collection\". Because \nBacked Collections dont go both ways and are only backed for a certain range.','Collections',1,NULL),(1499,'public static void main(String[] dicks){\n        String[] sa = {\"one\", \"two\", \"three\", \"four\" };\n        List sList = Arrays.asList(sa);\n\n        System.out.println( \"size \" + sList.size() );\n        System.out.println( \"idx2 \" + sList.get(2) );\n\n        sList.set(3,\"six\" );\n        sa[1] = \"five\";\n\n        for(String s : sa ){\n            System.out.println( s + \" \");\n        }\n        System.out.println(\"s1[1] \" + sList.get(1) );\n        \n        sList.set(1, \"FIVE\");\n        sList.set(3,\"SIX\");\n        sList.add(\"SEVEN\");\n        for(String s : sa)\n            System.out.println(s+\" \");','unsupported operation exception, \n\nList returned by asList is fixed size can only be updated not added to or removed from','Collections',1,NULL),(1500,' public static void main(String[] dicks){\n        List<Integer> iL = new ArrayList<Integer>();\n        for(int x=0; x<3; x++){\n                iL.add(x);\n        }\n        Object[] oa = iL.toArray();\n        Integer[] ia2 = new Integer[3];\n        ia2 = iL.toArray(oa);\n    }','will not compile, toArray( T[] a) will return an array of the type you send\nto it. so here an Object[] cannot be assigned to an Integer[].\n\nto fix:\n	change oa to ia2 which will cause toArray to return an Integer[]','Collections',1,NULL),(1501,'public static void main(String[] dicks){\n        List<Integer> iL = new ArrayList<Integer>();\n        for(int x=0; x<5; x++){\n                iL.add(x);\n        }\n        Object[] oa = iL.toArray();\n        Integer[] ia2 = new Integer[3];\n        ia2 = iL.toArray(ia2);\n        \n        for(Integer i : ia2){\n            System.out.println(i);\n        }     \n    }','0\n1\n2\n3\n4\n','Collections',1,NULL),(1502,'public static void main(String[] dicks){\n        List<Integer> iL = new ArrayList<Integer>();\n        for(int x=0; x<5; x++){\n                iL.add(x);\n        }\n        Object[] oa = iL.toArray();\n        Integer[] ia2 = new Integer[3];\n        ia2 = iL.toArray(ia2);\n        \n        for(Integer i : ia2){\n            System.out.println(i);\n        }\n        \n        iL.add(100);\n        \n        for(Integer i : ia2)\n            System.out.println(i);\n       \n    }','0\n1\n2\n3\n4\n0\n1\n2\n3\n4','Collections',1,NULL),(1503,' public static void main(String[] dicks){\n        List<Integer> iL = new ArrayList<Integer>();\n        for(int x=0; x<5; x++){\n                iL.add(x);\n        }\n        Integer[] oa = iL.toArray();     \n    }','will not compile, \n\n.toArray() returns an Object[]','Collections',1,NULL),(1504,'class HDTV implements Comparable<HDTV> {\n	private int size;\n	private String brand;\n        private int resolution;\n \n	public HDTV(int size, String brand, int res) {\n		this.size = size;\n		this.brand = brand;\n                this.resolution = res;\n	}\n \n	public int getSize() {\n		return size;\n	}\n        \n        public int getRes() {\n            return resolution;\n        }\n \n	public void setSize(int size) {\n		this.size = size;\n	}\n \n	public String getBrand() {\n		return brand;\n	}\n \n	public void setBrand(String brand) {\n		this.brand = brand;\n	}\n \n	@Override\n	public int compareTo(HDTV tv) {\n \n		if (this.getSize() > tv.getSize())\n			return 1;\n		else if (this.getSize() < tv.getSize())\n			return -1;\n		else\n			return 0;\n	}\n        \n        public String toString(){\n            return brand;\n        }\n}\n\npublic class Hello {\n    public static void main(String[] dicks){\n        compareTVs();\n    }\n    \n     \n    public static void compareTVs() {\n		HDTV tv1 = new HDTV(55, \"Samsung\", 6000);\n		HDTV tv2 = new HDTV(60, \"Sony\", 4500);\n                HDTV tv3 = new HDTV(70, \"MEGATV\", 10000);\n                HDTV tv4 = new HDTV(15,\"kitchenette\", 600);\n\n                HDTV[] array = {tv2, tv1, tv3, tv4 };\n                \n                System.out.println(Arrays.binarySearch(array,new HDTV(700,\"Samsung\",400)));\n                \n	}\n\n}','unpredictable result, the array is not sorted before being searched. ','Collections',1,NULL),(1505,'public static void main(String[] dicks){\n        List<HDTV> tvs = new ArrayList<>();\n        HDTV tv1 = new HDTV(55, \"Samsung\", 6000);\n        HDTV tv2 = new HDTV(60, \"Sony\", 4500);\n        HDTV tv3 = new HDTV(70, \"MEGATV\", 10000);\n        HDTV tv4 = new HDTV(15,\"kitchenette\", 600);\n        tvs.addAll(tv1,tv2,tv3,tv4);\n    }','will not compile \n\nArrayList.addAll doesn\'t work like that, it takes another collection\nthen adds all the elements from one to another. ','Collections',1,NULL),(1506,'public static void main(String[] dicks){\n        List<HDTV> tvs = new ArrayList<>();\n        \n        HDTV tv1 = new HDTV(55, \"Samsung\", 6000);\n        HDTV tv2 = new HDTV(60, \"Sony\", 4500);\n        HDTV tv3 = new HDTV(70, \"MEGATV\", 10000);\n        HDTV tv4 = new HDTV(15,\"kitchenette\", 600);\n        \n        tvs.add(tv1);\n        tvs.add(tv2);\n        tvs.add(tv3);\n        tvs.add(tv4);\n        \n        Iterator<HDTV> i3 = tvs.iterator();\n        \n        while(i3.hasNext()){\n            HDTV t3 = i3.next();\n            System.out.println(t3.getBrand());\n        }\n        \n        \n    }','Samsung\nSony\nMEGATV\nkitchenette\n\nthis shows proper use of an iterator','Collections',1,NULL),(1507,'public static void main(String[] dicks){\n        List<HDTV> tvs = new ArrayList<>();\n        \n        HDTV tv1 = new HDTV(55, \"Samsung\", 6000);\n        HDTV tv2 = new HDTV(60, \"Sony\", 4500);\n        HDTV tv3 = new HDTV(70, \"MEGATV\", 10000);\n        HDTV tv4 = new HDTV(15,\"kitchenette\", 600);\n        \n        tvs.add(tv1);\n        tvs.add(tv2);\n        tvs.add(tv3);\n        tvs.add(tv4);\n        \n        Iterator i3 = tvs.iterator();\n        \n        while(i3.hasNext()){\n            HDTV t3 = i3.next();\n            System.out.println(t3.getBrand());\n        }\n        \n        \n    }','If the iterator isn\'t typed then the elements returned by Iterator will be \nObjects so to make this compile, \n\nyou would have to cast\n\n	(HDTV) i3.next();','Collections',1,NULL),(1508,'  public static void main(String[] dicks){\n        List<HDTV> tvs = new ArrayList<>();\n        \n        HDTV tv1 = new HDTV(55, \"Samsung\", 6000);\n        HDTV tv2 = new HDTV(60, \"Sony\", 4500);\n        HDTV tv3 = new HDTV(70, \"MEGATV\", 10000);\n        HDTV tv4 = new HDTV(15,\"kitchenette\", 600);\n        \n        tvs.add(tv1);\n        tvs.add(tv2);\n        tvs.add(tv3);\n        tvs.add(tv4);\n        \n        HDTV[] tv = new HDTV[5];\n        HDTV[] hv = tvs.toArray(tv); //line 1\n        Object[] tvobjs = tvs.toArray(); //line 2\n        \n   \n    }\n\nwhich line would fail if any ?','none fail both of those are fine. ','Collections',1,NULL),(1509,'public static void main(String[] dicks){\n      Set s = new HashSet();\n      \n        System.out.println(s.add(4));\n        System.out.println(s.add(9));\n        System.out.println(s.add(5));\n        System.out.println(s.add(\"7\"));\n        System.out.println(s.add(4));\n        \n        for(Object o : s)\n            System.out.println(o);\n\n    }','true\ntrue\ntrue\ntrue\nfalse\n4\n5\n7\n9\n\nSets dont allow duplicates and the iteration order is not predictable','Collections',1,NULL),(1510,'public static void main(String[] dicks){\n      Set s = new TreeSet();\n      \n        System.out.println(s.add(4));\n        System.out.println(s.add(9));\n        System.out.println(s.add(5));\n        System.out.println(s.add(\"7\"));\n        System.out.println(s.add(4));\n        \n        for(Object o : s)\n            System.out.println(o);\n\n    }','ClassCastException\n \nTreeSets are sorted and all these elements aren\'t mutually comparabble','Collections',1,NULL),(1511,'class Dog {\n    public String name;\n    public Dog(String n) { name = n; }\n    \n    public String toString(){\n        return name;\n    }\n}\n\npublic class Hello {\n\n    public static void main(String[] dicks){\n      Map<Object,Object> map = new HashMap<>();\n      \n      map.put(\"d1\",new Dog(\"Charly\"));\n      map.put(\"d2\", new Dog(\"dumbfuck\"));\n      \n        System.out.println(map.get(\"d1\"));\n    }\n}','Charly,\n\nhere strings are used as keys and they override hashcode() and equals()\nso it can be used ','Collections',1,NULL),(1512,'class Dog {\n    public String name;\n    public Dog(String n) { name = n; }\n    \n    public String toString(){\n        return name;\n    }\n\n    public static void main(String[] dicks){\n      Map<Object,Object> map = new HashMap<>();\n      \n      map.put(new Dog(\"Bell\"),\"Big brown lab\");\n      map.put(new Dog(\"Sable\"), \"small schiperkee\");\n      \n        System.out.println(map.get(new Dog(\"Bell\")));\n    }\n\n}\n\n','null \n\nthe map cannot find the values bcause the keys dont have equals or hashcode methods.','Collections',1,NULL),(1513,'class Dog {\n    enum Pets{DOG, CAT, SNAKE};\n    public String name;\n    public Dog(String n) { name = n; }\n    \n    public String toString(){\n        return name;\n    }\n\npublic static void main(String[] dicks){\n      \n      Map<Object,Object> map = new HashMap<>();\n      \n      map.put(new Dog(\"Bell\"),\"Big brown lab\");\n      map.put(new Dog(\"Sable\"), \"small schiperkee\");\n      map.put(Pets.CAT, new Dog(\"catdog\"));\n      map.put(\"Dog\", Pets.DOG);\n      \n        System.out.println(map.get(new Dog(\"Bell\")));\n        System.out.println(map.get(Pets.CAT));\n        System.out.println(map.get(\"Dog\"));\n    }\n}','null\ncatdog\nDOG','Collections',1,NULL),(1514,'public int hashCode() { return name.length(); }\npublic int hashCode() { return 4; }\n \nwhich will be faster ?\n','both are legal, the first will be slightly better\n\nthe more unique a hashcode the faste retrieval will be. ','Collections',1,NULL),(1515,'TreeSet<Integer> tree = new TreeSet<Integer>();\ntree.add(12);\ntree.add(63);\ntree.add(34);\ntree.add(45);\n \nIterator<Integer> iterator = tree.iterator();\nSystem.out.print(\"Tree set data: \");\nwhile (iterator.hasNext()) {\n    System.out.print(iterator.next() + \" \");\n}','12\n34\n45\n63','Collections',1,NULL),(1516,'public class Hello {\n    \n    \n    public static void main(String[] dicks){\n      \n      List<Double> grades = new ArrayList<>();\n      grades.addAll(Arrays.asList( new Double[]{ 1.8, 4.6, 2.3, 8.9, 2.2 } ));\n      \n      Collections.sort(grades,new CusSort());\n      \n      System.out.println(grades);\n      \n        System.out.println(Collections.binarySearch(grades,4.2,new CusSort()));\n\n    }\n}\n    \n   class CusSort implements Comparator<Double> {\n       public int compare(Double d1, Double d2){\n           return d1.intValue() == d2.intValue() ? d2.compareTo(d1) : d1.compareTo(d2);\n           \n       }\n   }','[1.8, 2.3, 2.2, 4.6, 8.9]\n-5\n\nthis comparator sorts in ascending order uless they have the same integer\nvalue','Collections',1,NULL),(1517,'public class Hello {\n    \n    \n    public static void main(String[] dicks){\n      \n     TreeMap<String, String> map = new TreeMap<>();\n     map.put(\"a\",\"ant\"); map.put(\"b\",\"buffalo\"); map.put(\"h\",\"horse\");\n     \n     SortedMap<String, String> submap;\n     submap = map.subMap(\"b\",\"g\");\n     \n        System.out.println(map+\" \"+submap);\n        \n        map.put(\"b\",\"bat\");\n        \n        submap.put(\"f\",\"fish\");\n        \n        map.put(\"R\", \"raccoon\");\n        // submap.put(\"p\",\"pig\");\n        \n        System.out.println(map+\" \"+submap);\n    }\n}','{a=ant, b=buffalo, h=horse} {b=buffalo}\n{R=raccoon, a=ant, b=bat, f=fish, h=horse} {b=bat, f=fish}','Collections',1,NULL),(1518,'public class Hello {\n    \n    \n    public static void main(String[] dicks){\n      \n     TreeMap<String, String> map = new TreeMap<>();\n     map.put(\"a\",\"ant\"); map.put(\"b\",\"buffalo\"); map.put(\"h\",\"horse\");\n     \n     SortedMap<String, String> submap;\n     submap = map.subMap(\"b\",\"g\");\n     \n        System.out.println(map+\" \"+submap);\n        \n        map.put(\"b\",\"bat\");\n        \n        submap.put(\"f\",\"fish\");\n        \n        map.put(\"R\", \"raccoon\");\n        submap.put(\"p\",\"pig\");\n        \n        System.out.println(map+\" \"+submap);\n    }\n}','IllegalArgumnetException\n\np is out of range of the submap as first established with subMap(b g);\n\n','Collections',1,NULL),(1519,'public class Hello {\n    \n    \n    public static void main(String[] dicks){\n      \n     TreeMap<String, String> map = new TreeMap<>();\n     map.put(\"a\",\"ant\"); map.put(\"b\",\"buffalo\"); map.put(\"h\",\"horse\"); map.put(\"j\",\"jackle\");\n     \n     TreeMap<String, String> submap;\n     submap = map.subMap(\"b\",\"g\");\n     \n     System.out.println(map+\" \"+submap);\n\n    }\n}','will not compile, submap returns a SortedMap.','Collections',1,NULL),(1520,'class TreeMap<k,v> extends  _____________\n implements  ____________','AbstractMap<k,V>\nNavigableMap<K,V>','Collections',1,NULL),(1521,'public class Hello {\n    \n    \n    public static void main(String[] dicks){\n      \n     TreeMap<Animal, Integer> map = new TreeMap<>();\n     \n     map.put(new Animal(5,\"Ant\"), 6); map.put(new Animal(3,\"Beee\"),9); map.put(new Animal(25,\"Dog\"),7); map.put(new Animal(20,\"muskrat\"),20);\n     \n     System.out.println(map);\n     \n \n\n    }\n}\n\nclass sortAnimalsAlphabetically implements Comparator<Animal> {\n\n    @Override\n    public int compare(Animal o1, Animal o2) {\n        return o1.getName().compareTo(o2.getName());\n    }\n    \n}\n\nclass Animal implements Comparable<Animal> {\n    private Integer size;\n    private String name;\n    \n    public Animal(int x, String y){\n        size = x;\n        name = y;\n    }\n\n    public int getSize() {\n        return size;\n    }\n\n    public String getName() {\n        return name;\n    }\n    public int compareTo(Animal o){\n        return size.compareTo(o.getSize());\n        \n    }\n    \n    public String toString(){\n        return name;\n    }\n}','{Beee=9, Ant=6, muskrat=20, Dog=7}\n\nwithout a provided comparator TreeMap sorts using Animals comparable\n\nwhich is to rank by size','Collections',1,NULL),(1522,'public class Hello {\n    \n    \n    public static void main(String[] dicks){\n      \n     TreeMap<Animal, Integer> map = new TreeMap<>(new sortAnimalsAlphabetically());\n     \n     map.put(new Animal(5,\"Ant\"), 6); map.put(new Animal(3,\"Beee\"),9); map.put(new Animal(25,\"Dog\"),7); map.put(new Animal(20,\"muskrat\"),20);\n     \n     System.out.println(map);\n     \n \n\n    }\n}\n\nclass sortAnimalsAlphabetically implements Comparator<Animal> {\n\n    @Override\n    public int compare(Animal o1, Animal o2) {\n        return o1.getName().compareTo(o2.getName());\n    }\n    \n}\n\nclass Animal implements Comparable<Animal> {\n    private Integer size;\n    private String name;\n    \n    public Animal(int x, String y){\n        size = x;\n        name = y;\n    }\n\n    public int getSize() {\n        return size;\n    }\n\n    public String getName() {\n        return name;\n    }\n    public int compareTo(Animal o){\n        return size.compareTo(o.getSize());\n        \n    }\n    \n    public String toString(){\n        return name;\n    }\n}','{Ant=6, Beee=9, Dog=7, muskrat=20}\n\nsort using comparator','Collections',1,NULL),(1523,'public class Hello {\n    \n    \n    public static void main(String[] dicks){\n      \n     TreeMap<Animal, Integer> map = new TreeMap<>();\n     \n     map.put(new Animal(2,\"Ant\"), 6); map.put(new Animal(3,\"Beee\"),9); map.put(new Animal(15,\"Dog\"),7); map.put(new Animal(12,\"muskrat\"),20);\n     \n     SortedMap<Animal,Integer> copymap = map.subMap(map.firstKey(), map.lastKey());\n     \n     copymap.put(new Animal(50,\"Rhino\"), 1);\n     map.put(new Animal(30,\"Wolf\"), 4);\n     System.out.println(map);\n     \n     SortedMap<Animal,Integer> copy1map = copymap.subMap(new Animal(4,\"Worm\"), new Animal(25,\"Dolphin\"));\n     \n     System.out.println(copy1map);\n\n    }\n}\n\nclass sortAnimalsAlphabetically implements Comparator<Animal> {\n\n    @Override\n    public int compare(Animal o1, Animal o2) {\n        return o1.getName().compareTo(o2.getName());\n    }\n    \n}\n\nclass Animal implements Comparable<Animal> {\n    private Integer size;\n    private String name;\n    \n    public Animal(int x, String y){\n        size = x;\n        name = y;\n    }\n\n    public int getSize() {\n        return size;\n    }\n\n    public String getName() {\n        return name;\n    }\n    public int compareTo(Animal o){\n        return size.compareTo(o.getSize());\n        \n    }\n    \n    public String toString(){\n        return name;\n    }\n}','IllegalArgumentException key out of range\n\nyour trying to add a rhino - 50 - to the copied map when the biggest element\nin the orgiinal was a Dog at 15 !','Collections',1,NULL),(1524,'public class Hello {\n    \n    \n    public static void main(String[] dicks){\n      \n     TreeMap<Animal, Integer> map = new TreeMap<>();\n     \n     map.put(new Animal(2,\"Ant\"), 6); map.put(new Animal(3,\"Beee\"),9); map.put(new Animal(15,\"Dog\"),7); map.put(new Animal(12,\"muskrat\"),20);\n     \n     SortedMap<Animal,Integer> copymap = map.subMap(map.firstKey(), map.lastKey());\n     \n     map.put(new Animal(50,\"Rhino\"), 1);\n     map.put(new Animal(30,\"Wolf\"), 4);\n     System.out.println(map);\n     \n     SortedMap<Animal,Integer> copy1map = copymap.subMap(new Animal(1,\"Tic\"), new Animal(25,\"Dolphin\"));\n     \n     //System.out.println(copy1map);\n\n    }\n}\n\nclass sortAnimalsAlphabetically implements Comparator<Animal> {\n\n    @Override\n    public int compare(Animal o1, Animal o2) {\n        return o1.getName().compareTo(o2.getName());\n    }\n    \n}\n\nclass Animal implements Comparable<Animal> {\n    private Integer size;\n    private String name;\n    \n    public Animal(int x, String y){\n        size = x;\n        name = y;\n    }\n\n    public int getSize() {\n        return size;\n    }\n\n    public String getName() {\n        return name;\n    }\n    public int compareTo(Animal o){\n        return size.compareTo(o.getSize());\n        \n    }\n    \n    public String toString(){\n        return name;\n    }\n}\n','IllegalArgumentException, fromKey out of range\n\nthe tic your trying to add is too small previously the smallest elemtn was\nan Ant at 2','Collections',1,NULL),(1525,'public class Hello {\n    \n    \n    public static void main(String[] dicks){\n      \n     TreeMap<Animal, Integer> map = new TreeMap<>();\n     \n     map.put(new Animal(2,\"Ant\"), 6); map.put(new Animal(3,\"Beee\"),9); map.put(new Animal(15,\"Dog\"),7); map.put(new Animal(12,\"muskrat\"),20);\n     \n     SortedMap<Animal,Integer> copymap = map.subMap(map.firstKey(), map.lastKey());\n        System.out.println(map);\n        System.out.println(copymap);\n     \n     map.put(new Animal(50,\"Rhino\"), 1);\n     map.put(new Animal(30,\"Wolf\"), 4);\n     System.out.println(map);\n     \n     copymap = map.subMap(map.firstKey(), map.lastKey());\n     \n        System.out.println(copymap);\n     \n     //SortedMap<Animal,Integer> copy1map = copymap.subMap(new Animal(7,\"Snake\"), new Animal(40,\"Bear\"));\n     //System.out.println(copy1map);\n\n    }\n}','{Ant=6, Beee=9, muskrat=20, Dog=7}\n{Ant=6, Beee=9, muskrat=20}\n{Ant=6, Beee=9, muskrat=20, Dog=7, Wolf=4, Rhino=1}\n{Ant=6, Beee=9, muskrat=20, Dog=7, Wolf=4}\n\npublic SortedMap<K,V> subMap(K fromKey,\n                    K toKey)\n\nkeys range from fromKey, inclusive, to toKey, exclusive. (If fromKey and toKey are equal, the returned map is empty.)\n The returned map is backed by this map, so changes \nin the returned map are reflected in this map, and vice-versa.\n\nTHE TO KEY IS EXCLUSIVE ','Collections',1,NULL),(1526,'public class Hello {\n  public static void main(String[] dicks){\n      \n     TreeMap<Animal, Integer> map = new TreeMap<>();\n     \n     map.put(new Animal(2,\"Ant\"), 6); map.put(new Animal(3,\"Beee\"),9); map.put(new Animal(15,\"Dog\"),7); map.put(new Animal(12,\"muskrat\"),20);\n     \n     SortedMap<Animal,Integer> copymap = map.subMap(map.firstKey(),true, map.lastKey(),true);\n        System.out.println(map);\n        System.out.println(copymap);\n    }\n}\n\nclass Animal implements Comparable<Animal>{\n    private int size;\n    private String name;\n    public Animal(int s, String n){\n        size = s;\n        name = n;\n        \n    }\n    public int getSize(){\n        return size;\n    }\n    public int compareTo(Animal a){\n        int asize = a.getSize();\n        int bsize = this.size;\n        \n        if(asize < bsize)\n            return 1;\n        else if(asize == bsize)\n            return 0;\n        else\n            return -1;\n  \n    }\n    \n    public String toString(){\n        return name;\n    }\n}','{Ant=6, Beee=9, muskrat=20, Dog=7}\n{Ant=6, Beee=9, muskrat=20, Dog=7}\n\noverloaded version of submap indicates if that arg is inclusive \n\nThe map is sorted according to the natural ordering of its keys, or by a Comparator provided at map creation time\nNote that the ordering maintained by a tree map, like any sorted map, and whether or not an explicit comparator is provided, \nmust be consistent with equals if this sorted map is to correctly implement the Map interface. (See Comparable or Comparator for a precise definition of consistent with equals.) \nThis is so because the Map interface is defined in terms of the equals operation, but a sorted map performs all key comparisons using its compareTo (or compare) method, so two keys that are deemed equal by this method are, \nfrom the standpoint of the sorted map, equal.  ','Collections',1,NULL),(1527,'public class Hello {\n    \n    \n    public static void main(String[] dicks){\n      \n     TreeMap<Animal, Integer> map = new TreeMap<>();\n     \n     map.put(new Animal(2,\"Ant\"), 6); map.put(new Animal(3,\"Beee\"),9); map.put(new Animal(15,\"Dog\"),7); map.put(new Animal(12,\"muskrat\"),20);\n     \n     SortedMap<Animal,Integer> copymap = map.subMap(map.firstKey(),false, map.lastKey(),true);\n        System.out.println(map);\n        System.out.println(copymap);\n    }\n}','{Ant=6, Beee=9, muskrat=20, Dog=7}\n{Beee=9, muskrat=20, Dog=7}','Collections',1,NULL),(1528,'public class Hello {\n    \n    \n    public static void main(String[] dicks){\n      \n     TreeMap<Animal, Integer> map = new TreeMap<>();\n     \n     map.put(new Animal(2,\"Ant\"), 6); map.put(new Animal(3,\"Beee\"),9); map.put(new Animal(15,\"Dog\"),7); map.put(new Animal(12,\"muskrat\"),20);\n     \n     SortedMap<Animal,Integer> copymap = map.subMap(map.firstKey(),false, map.lastKey(),false);\n        System.out.println(map);\n        System.out.println(copymap);\n    }\n}','{Ant=6, Beee=9, muskrat=20, Dog=7}\n{Beee=9, muskrat=20}','Collections',1,NULL),(1529,'public class Hello {\n    \n    \n    public static void main(String[] dicks){\n      \n     TreeMap<Animal, Integer> map = new TreeMap<>();\n     \n     map.put(new Animal(2,\"Ant\"), 6); map.put(new Animal(3,\"Beee\"),9); map.put(new Animal(15,\"Dog\"),7); map.put(new Animal(12,\"muskrat\"),20);\n     \n     SortedMap<Animal,Integer> copymap = map.subMap(map.firstKey(),true, map.lastKey(),true);\n     \n        System.out.println(map);\n        System.out.println(copymap);\n     map.put(new Animal(25,\"Wolf\"), 1);\n     //copymap.put(new Animal(22,\"Lynx\"), 0);\n     map.put(new Animal(33,\"Giant sloth\"), 6);\n     //copymap.put(new Animal(30,\"Comodo\"),5);\n     \n        System.out.println(map);\n        System.out.println(copymap);        \n    }\n}','{Ant=6, Beee=9, muskrat=20, Dog=7}\n{Ant=6, Beee=9, muskrat=20, Dog=7}\n{Ant=6, Beee=9, muskrat=20, Dog=7, Wolf=1, Giant sloth=6}\n{Ant=6, Beee=9, muskrat=20, Dog=7}\n\nIf new elements are added to the orginal map that are out of the range\nof the submap then they are not copied over to the sub.\n\nThat submap only exist within the range it was defined. ','Collections',1,NULL),(1530,'public class Hello {\n    \n    \n    public static void main(String[] dicks){\n      \n     TreeMap<Animal, Integer> map = new TreeMap<>();\n     \n     map.put(new Animal(2,\"Ant\"), 6); map.put(new Animal(3,\"Beee\"),9); map.put(new Animal(15,\"Dog\"),7); map.put(new Animal(12,\"muskrat\"),20);\n     \n     SortedMap<Animal,Integer> copymap = map.subMap(map.firstKey(),true, map.lastKey(),true);\n     \n        System.out.println(map);\n        System.out.println(copymap);\n     map.put(new Animal(25,\"Wolf\"), 1);\n     copymap.put(new Animal(10,\"Fat Cat\"), 0);\n     map.put(new Animal(33,\"Giant sloth\"), 6);\n     \n        System.out.println(map);\n        System.out.println(copymap);\n    }\n}','{Ant=6, Beee=9, muskrat=20, Dog=7}\n{Ant=6, Beee=9, muskrat=20, Dog=7}\n{Ant=6, Beee=9, Fat Cat=0, muskrat=20, Dog=7, Wolf=1, Giant sloth=6}\n{Ant=6, Beee=9, Fat Cat=0, muskrat=20, Dog=7}','Collections',1,NULL),(1531,'public class Hello {\n    \n    \n    public static void main(String[] dicks){\n      \n     TreeMap<Animal, Integer> map = new TreeMap<>();\n     \n     map.put(new Animal(2,\"Ant\"), 6); map.put(new Animal(3,\"Beee\"),9); map.put(new Animal(15,\"Dog\"),7); map.put(new Animal(12,\"muskrat\"),20);\n     map.put(new Animal(25,\"Wolf\"), 1); map.put(new Animal(33,\"Giant sloth\"), 6);\n     map.put(new Animal(35,\"Leapord\"),2); map.put(new Animal(9,\"chipmunk\"),4); map.put(new Animal(46,\"Cave Dweller\"),1);\n     \n        System.out.println(map);\n        \n     SortedMap<Animal,Integer> headmap = map.headMap(new Animal(35,\"Leapord\"));\n     \n        System.out.println(headmap);\n   \n    }\n}','{Ant=6, Beee=9, chipmunk=4, muskrat=20, Dog=7, Wolf=1, Giant sloth=6, Leapord=2, Cave Dweller=1}\n{Ant=6, Beee=9, chipmunk=4, muskrat=20, Dog=7, Wolf=1, Giant sloth=6}','Collections',1,NULL),(1532,'public class Hello {\n    \n    \n    public static void main(String[] dicks){\n      \n     TreeMap<Animal, Integer> map = new TreeMap<>();\n     \n     map.put(new Animal(2,\"Ant\"), 6); map.put(new Animal(3,\"Beee\"),9); map.put(new Animal(15,\"Dog\"),7); map.put(new Animal(12,\"muskrat\"),20);\n     map.put(new Animal(25,\"Wolf\"), 1); map.put(new Animal(33,\"Giant sloth\"), 6);\n     map.put(new Animal(35,\"Leapord\"),2); map.put(new Animal(9,\"chipmunk\"),4); map.put(new Animal(46,\"Cave Dweller\"),1);\n     \n        System.out.println(map);\n        \n     SortedMap<Animal,Integer> headmap = map.headMap(new Animal(35,\"Leapord\"),true);\n     \n        System.out.println(headmap);\n   \n    }\n}','{Ant=6, Beee=9, chipmunk=4, muskrat=20, Dog=7, Wolf=1, Giant sloth=6, Leapord=2, Cave Dweller=1}\n{Ant=6, Beee=9, chipmunk=4, muskrat=20, Dog=7, Wolf=1, Giant sloth=6, Leapord=2}','Collections',1,NULL),(1533,'public class Hello {\n    \n    \n    public static void main(String[] dicks){\n      \n     TreeMap<Animal, Integer> map = new TreeMap<>();\n     \n     map.put(new Animal(2,\"Ant\"), 6); map.put(new Animal(3,\"Beee\"),9); map.put(new Animal(15,\"Dog\"),7); map.put(new Animal(12,\"muskrat\"),20);\n     map.put(new Animal(25,\"Wolf\"), 1); map.put(new Animal(33,\"Giant sloth\"), 6);\n     map.put(new Animal(35,\"Leapord\"),2); map.put(new Animal(9,\"chipmunk\"),4); map.put(new Animal(46,\"Cave Dweller\"),1);\n     \n        System.out.println(map);\n        \n     SortedMap<Animal,Integer> headmap = map.headMap(new Animal(40,\"Python\"),true);\n     \n        System.out.println(headmap);\n   \n    }\n}','{Ant=6, Beee=9, chipmunk=4, muskrat=20, Dog=7, Wolf=1, Giant sloth=6, Leapord=2, Cave Dweller=1}\n{Ant=6, Beee=9, chipmunk=4, muskrat=20, Dog=7, Wolf=1, Giant sloth=6, Leapord=2}','Collections',1,NULL),(1534,'public class Hello {\n    \n    \n    public static void main(String[] dicks){\n      \n     TreeMap<Animal, Integer> map = new TreeMap<>();\n     \n     map.put(new Animal(2,\"Ant\"), 6); map.put(new Animal(3,\"Beee\"),9); map.put(new Animal(15,\"Dog\"),7); map.put(new Animal(12,\"muskrat\"),20);\n     map.put(new Animal(25,\"Wolf\"), 1); map.put(new Animal(33,\"Giant sloth\"), 6);\n     map.put(new Animal(35,\"Leapord\"),2); map.put(new Animal(9,\"chipmunk\"),4); map.put(new Animal(46,\"Cave Dweller\"),1);\n     \n        System.out.println(map);\n        \n     SortedMap<Animal,Integer> headmap = map.headMap(new Animal(40,\"Python\"));\n     \n        System.out.println(headmap);\n   \n    }\n}','{Ant=6, Beee=9, chipmunk=4, muskrat=20, Dog=7, Wolf=1, Giant sloth=6, Leapord=2, Cave Dweller=1}\n{Ant=6, Beee=9, chipmunk=4, muskrat=20, Dog=7, Wolf=1, Giant sloth=6, Leapord=2}','Collections',1,NULL),(1535,'try{\n            bw.write(df.format(today));\n            bw.newLine();\n            bw.write(\"Flash Cards \\n\");\n            bw.newLine();\n            \n            for(Card c : cards){\n                bw.write(\"================================================\\n\");\n                bw.write(\"-\"+counter+\"-\\n\");\n                bw.write(\"================================================\\n\");\n                bw.write(c.getCard());\n                bw.newLine();\n                bw.write(\"================================================\\n\");\n                bw.write(c.getAnswer());\n                bw.newLine();\n                bw.write(\"================================================\\n\");\n                counter++;\n            }\n            \n            bw.close();\n	    bw.flush();\n            \n        } catch(IOException e){\n            System.out.println(\"Problem saving cards\");\n            e.printStackTrace(); \n        } ','IOException caused by flushing a closed Bufferedwriter','Collections',1,NULL),(1536,'public class Hello {\n    \n    \n    public static void main(String[] dicks){\n      \n     TreeMap<Animal, Integer> map = new TreeMap<>();\n     \n     map.put(new Animal(2,\"Ant\"), 6); map.put(new Animal(3,\"Beee\"),9); map.put(new Animal(15,\"Dog\"),7); map.put(new Animal(12,\"muskrat\"),20);\n     map.put(new Animal(25,\"Wolf\"), 1); map.put(new Animal(33,\"Giant sloth\"), 6);\n     map.put(new Animal(35,\"Leapord\"),2); map.put(new Animal(9,\"chipmunk\"),4); map.put(new Animal(46,\"Cave Dweller\"),1);\n     \n        System.out.println(map);\n        \n     SortedMap<Animal,Integer> headmap = map.headMap(new Animal(40,\"Python\"));\n     \n     System.out.println(headmap);\n        \n     NavigableMap<Animal,Integer> headmapincl = map.headMap(new Animal(34,\"Lynx\"), true);\n     SortedMap<Animal,Integer> headmap_2 = map.headMap(new Animal(30,\"Fox\"), true);\n     \n        System.out.println(headmapincl);\n        \n   \n    }\n}','{Ant=6, Beee=9, chipmunk=4, muskrat=20, Dog=7, Wolf=1, Giant sloth=6, Leapord=2, Cave Dweller=1}\n{Ant=6, Beee=9, chipmunk=4, muskrat=20, Dog=7, Wolf=1, Giant sloth=6, Leapord=2}\n{Ant=6, Beee=9, chipmunk=4, muskrat=20, Dog=7, Wolf=1, Giant sloth=6}','Collections',1,NULL),(1537,'public class Hello {\n    \n    \n    public static void main(String[] dicks){\n      \n     TreeMap<Animal, Integer> map = new TreeMap<>();\n     \n     map.put(new Animal(2,\"Ant\"), 6); map.put(new Animal(3,\"Beee\"),9); map.put(new Animal(15,\"Dog\"),7); map.put(new Animal(12,\"muskrat\"),20);\n     map.put(new Animal(25,\"Wolf\"), 1); map.put(new Animal(33,\"Giant sloth\"), 6);\n     map.put(new Animal(35,\"Leapord\"),2); map.put(new Animal(9,\"chipmunk\"),4); map.put(new Animal(46,\"Cave Dweller\"),1);\n     \n        System.out.println(map);\n        \n    SortedMap<Animal,Integer> tailmap = map.tailMap(new Animal(33,\"Giant Sloth\"));\n    \n        System.out.println(tailmap);\n        \n   \n    }\n}','{Ant=6, Beee=9, chipmunk=4, muskrat=20, Dog=7, Wolf=1, Giant sloth=6, Leapord=2, Cave Dweller=1}\n{Giant sloth=6, Leapord=2, Cave Dweller=1}','Collections',1,NULL),(1538,'public class Hello {\n    \n    \n    public static void main(String[] dicks){\n      \n     TreeMap<Animal, Integer> map = new TreeMap<>();\n     \n     map.put(new Animal(2,\"Ant\"), 6); map.put(new Animal(3,\"Beee\"),9); map.put(new Animal(15,\"Dog\"),7); map.put(new Animal(12,\"muskrat\"),20);\n     map.put(new Animal(25,\"Wolf\"), 1); map.put(new Animal(33,\"Giant sloth\"), 6);\n     map.put(new Animal(35,\"Leapord\"),2); map.put(new Animal(9,\"chipmunk\"),4); map.put(new Animal(46,\"Cave Dweller\"),1);\n     \n        System.out.println(map);\n        \n    SortedMap<Animal,Integer> tailmap = map.tailMap(new Animal(33,\"Giant Sloth\"),false);\n    \n        System.out.println(tailmap);\n        \n   \n    }\n}','{Ant=6, Beee=9, chipmunk=4, muskrat=20, Dog=7, Wolf=1, Giant sloth=6, Leapord=2, Cave Dweller=1}\n{Leapord=2, Cave Dweller=1}','Collections',1,NULL),(1539,' public static void main(String[] dicks){\n      \n     TreeMap<Animal, Integer> map = new TreeMap<>();\n     \n     map.put(new Animal(2,\"Ant\"), 6); map.put(new Animal(3,\"Beee\"),9); map.put(new Animal(15,\"Dog\"),7); map.put(new Animal(12,\"muskrat\"),20);\n     map.put(new Animal(25,\"Wolf\"), 1); map.put(new Animal(33,\"Giant sloth\"), 6);\n     map.put(new Animal(35,\"Leapord\"),2); map.put(new Animal(9,\"chipmunk\"),4); map.put(new Animal(46,\"Cave Dweller\"),1);\n     \n        System.out.println(map);\n        \n     SortedMap<Animal,Integer> tailmap = map.tailMap(new Animal(33,\"Giant Sloth\"),false);\n     \n        System.out.println(tailmap.pollFirtEntry());\n    \n    }\n}','will not compile,\n\npollFirstEntry(),cielingKey,higherKey(), floorKey(), pollLastEntry(),\ndescendingMap()\n\n	are all in TreeMap not interface SortedMap.','Collections',1,NULL),(1540,'public class Hello {\n    \n    \n    public static void main(String[] dicks){\n      \n     TreeMap<Animal, Integer> map = new TreeMap<>();\n     \n     map.put(new Animal(2,\"Ant\"), 6); map.put(new Animal(3,\"Beee\"),9); map.put(new Animal(15,\"Dog\"),7); map.put(new Animal(12,\"muskrat\"),20);\n     map.put(new Animal(25,\"Wolf\"), 1); map.put(new Animal(33,\"Giant sloth\"), 6);\n     map.put(new Animal(35,\"Leapord\"),2); map.put(new Animal(9,\"chipmunk\"),4); map.put(new Animal(46,\"Cave Dweller\"),1);\n     \n        System.out.println(map);\n        \n     \n        System.out.println(map.pollFirstEntry());\n        System.out.println(map.pollLastEntry());\n        System.out.println(map.ceilingKey(new Animal(2,\"Ant\")));\n        System.out.println(map.higherKey(new Animal(3,\"Beee\")));\n        System.out.println(map.floorKey(new Animal(46,\"Cave Dweller\")));\n        System.out.println(map.lowerKey(new Animal(35,\"Leapord\")));\n        \n    \n    }\n}','{Ant=6, Beee=9, chipmunk=4, muskrat=20, Dog=7, Wolf=1, Giant sloth=6, Leapord=2, Cave Dweller=1}\nAnt=6\nCave Dweller=1\nBeee\nchipmunk\nLeapord\nGiant sloth','Collections',1,NULL),(1541,'\npublic class Hello {\n    public static void main(String[] dicks){\n      \n        PriorityQueue<Animal> q = new PriorityQueue<>();\n        \n        q.add(new Animal(5,\"Sheep\"));\n        q.offer(new Animal(6,\"Goat\"));\n        q.offer(new Animal(10,\"Cow\"));\n        q.offer(new Animal(12,\"Bull\"));\n        q.offer(null);\n        \n        System.out.println(q);\n        \n    \n    }\n}','nullpointerexception, PQ does not allow null elements','Collections',1,NULL),(1542,'public class Hello {\n    public static void main(String[] dicks){\n        \n        PriorityQueue<Animal> q = new PriorityQueue<>(5);\n        \n        q.add(new Animal(5,\"Sheep\"));\n        q.offer(new Animal(6,\"Goat\"));\n        q.offer(new Animal(10,\"Cow\"));\n        q.offer(new Animal(12,\"Bull\"));\n        q.offer(new Animal(3,\"Cat\"));\n        q.offer(new Animal(7,\"Sloth\"));\n        \n        for(Animal x : q)\n            System.out.println(x);\n        \n        System.out.println(\"__________________\");\n        \n        for(Animal x : q)\n            System.out.println(q.poll());\n        \n    \n    }\n}','ConcurrentModificationExcpeiton for removing elements from the pq\nwhile iterating over it. ','Collections',1,NULL),(1543,'public class Hello {\n    public static void main(String[] dicks){\n        \n        PriorityQueue<Animal> q = new PriorityQueue<>(5);\n        \n        q.add(new Animal(5,\"Sheep\"));\n        q.offer(new Animal(6,\"Goat\"));\n        q.offer(new Animal(10,\"Cow\"));\n        q.offer(new Animal(12,\"Bull\"));\n        q.offer(new Animal(3,\"Cat\"));\n        q.offer(new Animal(7,\"Sloth\"));\n        \n        for(Animal x : q)\n            System.out.println(x);\n        \n        System.out.println(\"__________________\");\n        \n        while(!q.isEmpty())\n            System.out.println(q.poll());\n        \n    \n    }\n}','Cat\nSheep\nSloth\nBull\nGoat\nCow\n__________________\nCat\nSheep\nGoat\nSloth\nCow\nBull\n\nYou need to poll the items from the PriorityQueue one by one. toString doesn\'t do that.\n\nSo instead of your System.out.println(queue); do this:\n\nwhile(!queue.isEmpty()) {\n   System.out.println(queue.poll());\n}\n\nThe reason is that the PriorityQueue is never completely sorted internally, lookup how a heap works for more detail. Polling items from it fixes the heap during the calls, thus it should output the elements in sorted order.','Collections',1,NULL),(1544,'public class Hello {\n    public static void main(String[] dicks){\n        \n        PriorityQueue<Animal> q = new PriorityQueue<>(5);\n        \n        q.add(new Animal(5,\"Sheep\"));\n        q.offer(new Animal(6,\"Goat\"));\n        q.offer(new Animal(10,\"Cow\"));\n        q.offer(new Animal(12,\"Bull\"));\n        q.offer(new Animal(3,\"Cat\"));\n        q.offer(new Animal(7,\"Sloth\"));\n        \n        q.offer(\"Sloths\");\n        q.add(\"fake bull\");\n        \n        while(!q.isEmpty())\n            System.out.println(q.poll());\n        \n\n        \n    \n    }\n}','will not compile string cannot be converted to Animal','Collections',1,NULL),(1545,'public class Hello {\n    public static void main(String[] dicks){\n        Comparator revSort = Collections.reverseOrder();\n        PriorityQueue<Animal> q = new PriorityQueue<>();\n        \n        q.add(new Animal(5,\"Sheep\"));\n        q.offer(new Animal(6,\"Goat\"));\n        q.offer(new Animal(10,\"Cow\"));\n        q.offer(new Animal(12,\"Bull\"));\n        q.offer(new Animal(3,\"Cat\"));\n        q.offer(new Animal(7,\"Sloth\"));\n        \n        PriorityQueue<Animal> q2 = new PriorityQueue<>(q);\n        \n        Collections.sort(q2,revSort);\n        \n        while(!q.isEmpty())\n            System.out.println(q.poll());\n        \n        while(!q2.isEmpty())\n            System.out.println(q2.poll());\n\n    }\n}','will not compile, Collections.sort will only sort Lists','Collections',1,NULL),(1546,'public class Hello {\n    public static void main(String[] dicks){\n        Comparator revSort = Collections.reverseOrder();\n        PriorityQueue<Animal> q = new PriorityQueue<>(revSort);\n        \n        q.add(new Animal(5,\"Sheep\"));\n        q.offer(new Animal(6,\"Goat\"));\n        q.offer(new Animal(10,\"Cow\"));\n        q.offer(new Animal(12,\"Bull\"));\n        q.offer(new Animal(3,\"Cat\"));\n        q.offer(new Animal(7,\"Sloth\"));\n        \n        while(!q.isEmpty()){\n            System.out.println(q.poll());\n        }\n        \n        \n\n    }\n}','Bull\nCow\nSloth\nGoat\nSheep\nCat','Collections',1,NULL),(1547,'public class Hello {\n    public static void main(String[] dicks){\n        Comparator revSort = Collections.reverseOrder();\n        PriorityQueue<Animal> q = new PriorityQueue<>(revSort);\n        \n        q.add(new Animal(5,\"Sheep\"));\n        q.offer(new Animal(6,\"Goat\"));\n        q.offer(new Animal(10,\"Cow\"));\n        q.offer(new Animal(12,\"Bull\"));\n        q.offer(new Animal(3,\"Cat\"));\n        q.offer(new Animal(7,\"Sloth\"));\n        \n        System.out.println(q.remove());\n        System.out.println(q.remove(new Animal(7,\"Sloth\")));\n        \n        while(!q.isEmpty()){\n            System.out.println(q.poll());\n        }\n\n    }\n}\n\nclass Animal implements Comparable<Animal> {\n    private Integer size;\n    private String name;\n    \n    public Animal(int x, String y){\n        size = x;\n        name = y;\n    }\n\n    public int getSize() {\n        return size;\n    }\n\n    public String getName() {\n        return name;\n    }\n    public int compareTo(Animal o){\n        return size.compareTo(o.getSize());\n        \n    }\n    \n    public String toString(){\n        return name;\n    }\n}\n','Here animal doesn\'t impleemnt equals and remove uses equals to determine the \nelement to remove','Collections',1,NULL),(1548,'public class Hello {\n    public static void main(String[] dicks){\n        Comparator revSort = Collections.reverseOrder();\n        PriorityQueue<Animal> q = new PriorityQueue<>(revSort);\n        \n        q.add(new Animal(5,\"Sheep\"));\n        q.offer(new Animal(6,\"Goat\"));\n        q.offer(new Animal(10,\"Cow\"));\n        q.offer(new Animal(12,\"Bull\"));\n        q.offer(new Animal(3,\"Cat\"));\n        q.offer(new Animal(7,\"Sloth\"));\n        \n        System.out.println(q.remove());\n        System.out.println(q.remove(new Animal(7,\"Sloth\")));\n        System.out.println(\"\");\n        \n        while(!q.isEmpty()){\n            System.out.println(q.poll());\n        }\n    }\n}\n\nclass Animal implements Comparable<Animal> {\n    private Integer size;\n    private String name;\n    \n    public Animal(int x, String y){\n        size = x;\n        name = y;\n    }\n\n    public int getSize() {\n        return size;\n    }\n\n    public String getName() {\n        return name;\n    }\n    public int compareTo(Animal o){\n        return size.compareTo(o.getSize());\n        \n    }\n    \n    public String toString(){\n        return name;\n    }\n    \n    public boolean equals(Object o){\n        if((o instanceof Animal)){\n            if((((Animal)o).getSize() == this.size) && (((Animal)o).getName().equals(name) ))\n                return true;\n            return false;           \n        } \n        return false;\n    }\n}','now with equals remove() works just fine. \n\nBull\ntrue\n\nCow\nGoat\nSheep\nCat\n\nnotice the pq is sorted with a Reverse sort comparator, so the animal class\nimplements Comparable. If it didn\'t implement Comparable it could not be used \nin the PriorityQueue. If it wasn\'t for the equals method the remove(sloth)\ncall would return false and sloth would not be removed. Thus making the \noutput:\n\n	Bull\n	false\n\n	Cow\n	Sloth\n	Goat\n	Sheep\n	Cat\n\nalso notice that it is a queue and therefore removes from the head','Collections',1,NULL),(1549,'public class Hello {\n    public static void main(String[] dicks){\n        Map<Integer,String> map = new HashMap<>();\n        \n        map.put(7,\"Biffy\");\n        map.put(5,\"two tone\");\n        map.put(9,\"big slick\");\n        map.put(1,\"funny farm\");\n        map.put(10, \"twice tickled\");\n        \n        List<Integer> list = new ArrayList<>();\n        \n        list.add(7);\n        list.add(5);\n        list.add(9);\n        list.add(1);\n        list.add(10);\n        list.add(16);\n        list.add(14);\n        \n        for(int x : list){\n            System.out.println(map.remove(x));\n        }    \n\n    }\n}','Biffy\ntwo tone\nbig slick\nfunny farm\ntwice tickled\nnull\nnull','Collections',1,NULL),(1550,'public class Hello {\n    public static void main(String[] dicks){\n        Map<Integer,String> map = new HashMap<>();\n        \n        map.put(7,\"Biffy\");\n        map.put(5,\"two tone\");\n        map.put(9,\"big slick\");\n        map.put(1,\"funny farm\");\n        map.put(10, \"twice tickled\");\n        \n        List<Integer> list = new ArrayList<>();\n        \n        list.add(7);\n        list.add(5);\n        list.add(9);\n        list.add(1);\n        list.add(10);\n        list.add(16);\n        list.add(14);\n        \n        Set<Integer> set = new HashSet<>();\n        \n        set.add(7);\n        set.add(5);\n        set.add(9);\n        set.add(1);\n        set.add(10);\n        \n        for(int x : list){\n            System.out.println(\"sizes: \"+map.size() +\", \"+ list.size()+\", \"+set.size());\n            System.out.println(map.remove(x));\n            System.out.println(\"set contains?: \"+set.contains(x));\n        }    \n\n    }\n}','sizes: 5, 7, 5\nBiffy\nset contains?: true\nsizes: 4, 7, 5\ntwo tone\nset contains?: true\nsizes: 3, 7, 5\nbig slick\nset contains?: true\nsizes: 2, 7, 5\nfunny farm\nset contains?: true\nsizes: 1, 7, 5\ntwice tickled\nset contains?: true\nsizes: 0, 7, 5\nnull\nset contains?: false\nsizes: 0, 7, 5\nnull\nset contains?: false','Collections',1,NULL),(1551,'Spaces sort before characters,\nuppercases sort before the lower,\nyour good to go','','Collections',1,NULL),(1552,'public class Hello {\n    public static void main(String[] dicks){\n       HashSet<Animal> set = new HashSet<>();\n       \n       Animal cat = new Animal(3,\"Cat\");\n       Animal dog = new Animal(4,\"Dog\");\n       Animal wolf = new Animal(6,\"Wolf\");\n       Animal coyote = new Animal(5,\"Coyote\");\n       Animal cat2 = new Animal(3,\"Cat\");\n       \n        System.out.println(cat.equals(cat2));\n       \n        System.out.println(set.add(cat));\n        System.out.println(set.add(cat));\n        System.out.println(set.add(dog));\n        System.out.println(set.add(wolf));\n        System.out.println(set.add(coyote));\n        System.out.println(set.add(cat2));\n        \n       \n        System.out.println(set.size());\n        System.out.println(set.remove(cat));\n        System.out.println(set.contains(cat));\n        System.out.println(set.size());\n        \n        \n    \n    }\n}\n\n\nclass Animal {\n    private Integer size;\n    private String name;\n    \n    public Animal(int x, String y){\n        size = x;\n        name = y;\n    }\n\n    public int getSize() {\n        return size;\n    }\n\n    public String getName() {\n        return name;\n    }\n    \n    public String toString(){\n        return name;\n    }\n    \n    public boolean equals(Object o){\n        if((o instanceof Animal)){\n            if((((Animal)o).getSize() == this.size) && (((Animal)o).getName().equals(name) ))\n                return true;\n            return false;           \n        } \n        return false;\n    }\n    \n    //public int hashCode(){ return name.length() + size; }\n        \n}','true\ntrue\nfalse\ntrue\ntrue\ntrue\nfalse\n4\ntrue\nfalse\n3','Collections',1,NULL),(1553,'public class Hello {\n    public static void main(String[] dicks){\n       HashSet<Animal> set = new HashSet<>();\n       \n       Animal cat = new Animal(3,\"Cat\");\n       Animal dog = new Animal(4,\"Dog\");\n       Animal wolf = new Animal(6,\"Wolf\");\n       Animal coyote = new Animal(5,\"Coyote\");\n       Animal cat2 = new Animal(3,\"Cat\");\n       \n        System.out.println(cat.equals(cat2));\n       \n        System.out.println(set.add(cat));\n        System.out.println(set.add(cat));\n        System.out.println(set.add(dog));\n        System.out.println(set.add(wolf));\n        System.out.println(set.add(coyote));\n        System.out.println(set.add(cat2));\n        \n       \n        System.out.println(set.size());\n        System.out.println(set.remove(cat));\n        System.out.println(set.contains(cat));\n        System.out.println(set.size());\n        \n        \n    \n    }\n}\n\n\nclass Animal {\n    private Integer size;\n    private String name;\n    \n    public Animal(int x, String y){\n        size = x;\n        name = y;\n    }\n\n    public int getSize() {\n        return size;\n    }\n\n    public String getName() {\n        return name;\n    }\n    \n    public String toString(){\n        return name;\n    }\n    \n    public boolean equals(Object o){\n        if((o instanceof Animal)){\n            if((((Animal)o).getSize() == this.size) && (((Animal)o).getName().equals(name) ))\n                return true;\n            return false;           \n        } \n        return false;\n    }\n    \n    public int hashCode(){ return name.length() + size; }\n        \n}\n','true\ntrue\nfalse\ntrue\ntrue\ntrue\nfalse\n4\ntrue\nfalse\n3\n\nif hashCode() is not overriden then every object will go in its own bucket\ntherefore equals will not be able to differentiate between equal objects because it will have no\nother objects to compare that object to!','Collections',1,NULL),(1554,'public class Hello {\n    public static void main(String[] dicks){\n       HashSet<Animal> set = new HashSet<>();\n       \n       Animal cat = new Animal(3,\"Cat\");\n       Animal dog = new Animal(4,\"Dog\");\n       Animal wolf = new Animal(6,\"Wolf\");\n       Animal coyote = new Animal(5,\"Coyote\");\n       Animal cat2 = new Animal(3,\"Cat\");\n       \n        System.out.println(cat.equals(cat2));\n       \n        System.out.println(set.add(cat));\n        System.out.println(set.add(cat));\n        System.out.println(set.add(dog));\n        System.out.println(set.add(wolf));\n        System.out.println(set.add(coyote));\n        System.out.println(set.add(cat2));\n        \n       \n        System.out.println(set.size());\n        System.out.println(set.remove(cat));\n        System.out.println(set.contains(cat));\n        System.out.println(set.size());\n        \n        \n    \n    }\n}\n\n\nclass Animal {\n    private Integer size;\n    private String name;\n    \n    public Animal(int x, String y){\n        size = x;\n        name = y;\n    }\n\n    public int getSize() {\n        return size;\n    }\n\n    public String getName() {\n        return name;\n    }\n    \n    public String toString(){\n        return name;\n    }\n    \n    /**\n    public boolean equals(Object o){\n        if((o instanceof Animal)){\n            if((((Animal)o).getSize() == this.size) && (((Animal)o).getName().equals(name) ))\n                return true;\n            return false;           \n        } \n        return false;\n    } **/\n    \n    public int hashCode(){ return name.length() + size; }\n        \n}\n','false\ntrue\nfalse\ntrue\ntrue\ntrue\ntrue\n5\ntrue\nfalse\n4\n\nif equals is not overriden then only references with the same actual\nobject are considered equal','Collections',1,NULL),(1555,'public class Hello {\n    public static void main(String[] dicks){\n       Animal cat = new Animal(3,\"Cat\");\n       Animal dog = new Animal(4,\"Dog\");\n       Animal wolf = new Animal(6,\"Wolf\");\n       Animal coyote = new Animal(5,\"Coyote\");\n       Animal cat2 = new Animal(3,\"Cat\");\n       \n       LinkedHashSet<Animal> lhs = new LinkedHashSet<>();\n       HashSet<Animal> hs = new HashSet<>();\n       \n       lhs.add(cat); lhs.add(dog); lhs.add(wolf); lhs.add(coyote); lhs.add(null);\n       hs.add(cat); hs.add(dog); hs.add(wolf); hs.add(coyote); hs.add(null);\n       \n       for(Animal x : lhs){\n           System.out.print(x.getName()+\" \");\n       }\n \n    }\n}','nullpointerexception\n\nLinkedHashSet and HashSet allow null elements but when you call a method on a null\nyou get an exception','Collections',1,NULL),(1556,'public class Hello {\n    public static void main(String[] dicks){\n       Animal cat = new Animal(3,\"Cat\");\n       Animal dog = new Animal(4,\"Dog\");\n       Animal wolf = new Animal(6,\"Wolf\");\n       Animal coyote = new Animal(5,\"Coyote\");\n       Animal cat2 = new Animal(3,\"Cat\");\n       \n       LinkedHashSet<Animal> lhs = new LinkedHashSet<>();\n       HashSet<Animal> hs = new HashSet<>();\n       \n       lhs.add(cat); lhs.add(dog); lhs.add(wolf); lhs.add(coyote);\n       hs.add(cat); hs.add(dog); hs.add(wolf); hs.add(coyote); \n       \n       System.out.println( lhs.add(null) ); \n       System.out.println( hs.add(null) );\n       \n       System.out.println( lhs.add(null) );\n       System.out.println( hs.add(null) );\n        \n\n    }\n}','true\ntrue\nfalse\nfalse\n\nSets allow null elements but they also dont allow duplicates so here \nis will not let you add ANother null','Collections',1,NULL),(1557,'public class Hello {\n    public static void main(String[] dicks){\n       Animal cat = new Animal(3,\"Cat\");\n       Animal dog = new Animal(4,\"Dog\");\n       Animal wolf = new Animal(6,\"Wolf\");\n       Animal coyote = new Animal(5,\"Coyote\");\n       Animal cat2 = new Animal(3,\"Cat\");\n       \n       LinkedHashSet<Animal> lhs = new LinkedHashSet<>();\n       HashSet<Animal> hs = new HashSet<>();\n       Hashtable<Animal> ht = new Hashtable<>();\n       \n       lhs.add(cat); lhs.add(dog); lhs.add(wolf); lhs.add(coyote);\n       hs.add(cat); hs.add(dog); hs.add(wolf); hs.add(coyote); \n       \n       System.out.println(lhs.add(null)); \n       System.out.println(hs.add(null));\n       \n       System.out.println(lhs.add(null));\n       System.out.println(hs.add(null));\n        \n\n    }\n}','will not compile,\n\nHashtable is a Map !\n\nrequires two type arguments','Collections',1,NULL),(1558,'public class Hello {\n    public static void main(String[] dicks){\n       Animal cat = new Animal(3,\"Cat\");\n       Animal dog = new Animal(4,\"Dog\");\n       Animal wolf = new Animal(6,\"Wolf\");\n       Animal coyote = new Animal(5,\"Coyote\");\n       Animal cat2 = new Animal(3,\"Cat\");\n\n       Hashtable<Integer,Animal> ht = new Hashtable<>();\n\n        System.out.println(ht.put(1,cat));\n        System.out.println(ht.put(2,dog));\n        System.out.println(ht.put(3,wolf));\n        System.out.println(ht.put(4,coyote));\n        System.out.println(ht.put(5, cat2));\n        \n        System.out.println(ht.put(1,cat));\n        System.out.println(ht.put(1,new Animal(3,\"Barn Cat\")));\n        \n        System.out.println(ht.put(2,dog));\n        System.out.println(ht.put(2, new Animal(4,\"Fox\")));\n    }\n}','null\nnull\nnull\nnull\nnull\nCat\nCat\nDog\nDog\n\nput\n\npublic V put(K key,\n    V value)\n\nMaps the specified key to the specified value in this hashtable. \nNeither the key nor the value can be null.\n\nThe value can be retrieved by calling the get\n method with a key that is equal to the original key.\n\nTo successfully store and retrieve objects from a hashtable, \nthe objects used as keys \nmust implement the hashCode method and the equals method. \n\nto know anything about how this code works you need to know if it implements\nequals and hashCode','Collections',1,NULL),(1559,'public class Hello {\n    public static void main(String[] dicks){\n       Animal cat = new Animal(3,\"Cat\");\n       Animal dog = new Animal(4,\"Dog\");\n       Animal wolf = new Animal(6,\"Wolf\");\n       Animal coyote = new Animal(5,\"Coyote\");\n       Animal cat2 = new Animal(3,\"Cat\");\n\n       Hashtable<Integer,Animal> ht = new Hashtable<>();\n\n        System.out.println(ht.put(1,cat));\n        System.out.println(ht.put(2,dog));\n        System.out.println(ht.put(3,wolf));\n        System.out.println(ht.put(4,coyote));\n        System.out.println(ht.put(5, cat2));\n        \n        System.out.println(ht.put(1,cat));\n        System.out.println(ht.put(1,new Animal(3,\"Barn Cat\")));\n        \n        System.out.println(ht.size());\n        \n        System.out.println(ht.put(2,dog));\n        System.out.println(ht.put(2, new Animal(4,\"Fox\")));\n    }\n}\n\n\nclass Animal {\n    private Integer size;\n    private String name;\n    \n    public Animal(int x, String y){\n        size = x;\n        name = y;\n    }\n\n    public int getSize() {\n        return size;\n    }\n\n    public String getName() {\n        return name;\n    }\n    \n    public String toString(){\n        return name;\n    }\n    \n    /**\n    public boolean equals(Object o){\n        if((o instanceof Animal)){\n            if((((Animal)o).getSize() == this.size) && (((Animal)o).getName().equals(name) ))\n                return true;\n            return false;           \n        } \n        return false;\n    } **/\n    \n    //public int hashCode(){ return name.length() + size; }\n        \n}\n','null\nnull\nnull\nnull\nnull\nCat\nCat\n5\nDog\nDog','Collections',1,NULL),(1560,'public class Hello {\n    public static void main(String[] dicks){\n        Map<String, Integer> map = new HashMap<>();\n        \n        String name = \"Max\";\n        map.put(name,10000000);\n        \n        int total = map.get(\"Max\");\n        \n        (if total == null){\n            System.out.println(\"no money in maxs account\");\n        }\n    }\n}','will not compile int cannot auotbox to null\n\na primitive cannot be null','Collections',1,NULL),(1561,'The generics type identifier can be used in class, method, and variable declarations....\n\n','class Foo<t> { }	// a class\nT anInstance;		//an instance variable\nFoo(T aRef) { }	// a constructor argument\nvoid bar(T aRef) { }	// a method argument\nT baz() { }		// a return type\n\nThe compiler will substitute the actual type','Generics',1,NULL),(1562,'Which Collection interfaces have a method for removing an element by the object ?','List and Set, With Maps you remove by the key which removes the element','Collections',1,NULL),(1563,'public class Hello {\n    public static void main(String[] args){\n        List myList = new ArrayList();\n        myList.add(\"Hoyt\");\n        myList.add(\"JOJO\");\n        myList.add(\"Adam\");\n        \n        String athletename = myList.get(1);\n        System.out.println(athletename+ \" \" + athletename.length());\n    }\n}','Will Not compile\n\nuntyped collections store Objects so you would have to cast to a String. ','Collections',1,NULL),(1564,'void takeListOfStrings(List<String> strings) {\n	strings.add(new Integer(42) ); \n}','Will Not compile','Generics',1,NULL),(1565,'public List<Dog> getDogList() {\n	List<Dog> dogs = new ArrayList<>();\n	//add dogs to list\n	return dogs;\n}\n\nDog d = getDogList().get(0);','Compiles fine, you know what is coming out of a typed list returned from a method declared with that type','Generics',1,NULL),(1566,'public List getDogList() {\n	List dogs = new ArrayList();\n	dogs.add(\"Dicks\");\n	dogs.add(\"Spot\");\n	dogs.add(\"FIdo\");\n	return dogs;\n}\n\npsvm(sa){	\n	List dognames = getDogList();\n	Dog fido = dognames.get(2);\n}\n	','Will not compile','Generics',1,NULL),(1567,'psvm(sa){\n	List<Integer> list = new ArrayList<>();\n	list.add(5);\n	list.add(9);\n	list.add(7);\n\n	Integer i = (Integer) list.get(0);\n}','The cast is unecessary but it wont cause any error','Generics',1,NULL),(1568,'public class Hello {\n    public static void main(String[] args){\n        List<Integer> myList = new ArrayList<>();\n        \n        myList.add(4);\n        myList.add(6);\n        Adder adder = new Adder();\n        int total = adder.addAll(myList);\n        \n        System.out.println(total);\n        \n    }\n}\n\nclass Adder {\n        int addAll(List list){\n            Iterator it = list.iterator();\n            int total = 0;\n            \n            while(it.hasNext()){\n                int i = ((Integer)it.next()).intValue();\n                total += i;\n            }\n            \n            return total;\n        }\n}','Works fine. ','Generics',1,NULL),(1569,'public class Hello {\n    public static void main(String[] args){\n        List myList = new ArrayList();\n        \n        myList.add(4);\n        myList.add(6);\n        myList.add(\"whoops\");\n        Adder adder = new Adder();\n        int total = adder.addAll(myList);\n        \n        System.out.println(total);\n        \n    }\n}\n\nclass Adder {\n        int addAll(List list){\n            Iterator it = list.iterator();\n            int total = 0;\n            \n            while(it.hasNext()){\n                int i = ((Integer)it.next()).intValue();\n                total += i;\n            }\n            \n            return total;\n        }\n}','ClassCastException','Generics',1,NULL),(1570,'public class Hello {\n    public static void main(String[] args){\n        List<Integer> myList = new ArrayList<>();\n        \n        myList.add(4);\n        myList.add(6);\n        Inserter is = new Inserter();\n        is.insert(myList);\n        \n    }\n}\n\nclass Inserter {\n        void insert(List list){\n            list.add(new Integer(42));\n            Iterator it = list.iterator();\n            int total = 0;\n            \n            while(it.hasNext()){\n                int i = ((Integer)it.next()).intValue();\n                total += i;\n            }\n\n        }\n}','compiles and runs no problem','Generics',1,NULL),(1571,'public class Hello {\n    public static void main(String[] args){\n        List<Integer> myList = new ArrayList<>();\n        \n        myList.add(4);\n        myList.add(6);\n        Inserter is = new Inserter();\n        is.insert(myList);\n        \n    }\n}\n\nclass Inserter {\n        void insert(List list){\n            list.add(\"42\");\n            Iterator it = list.iterator();\n            int total = 0;\n            \n            while(it.hasNext()){\n                int i = ((Integer)it.next()).intValue();\n                total += i;\n            }\n\n        }\n}','ClassCastException\n\nand compiler warning for going into unsafe method','Generics',1,NULL),(1572,'public class Hello {\n    public static void main(String[] args){\n        List<Integer> myList = new ArrayList<>();\n        \n        myList.add(4);\n        myList.add(6);\n        Inserter is = new Inserter();\n        is.insert(myList);\n        \n    }\n}\n\nclass Inserter {\n        void insert(List list){\n            list.add(\"42\");\n            Iterator it = list.iterator();\n            int total = 0;\n            \n            while(it.hasNext()){\n                int i = (it.next()).intValue();\n                total += i;\n            }\n\n        }\n}','Will not compile because of .intValue() the list declared in inserter is of type Object','Generics',1,NULL),(1573,'public class Hello {\n    public static void main(String[] args){\n        List<Integer> myList = new ArrayList<>();\n        \n        myList.add(4);\n        myList.add(6);\n        Inserter is = new Inserter();\n        is.insert(myList);\n        \n    }\n}\n\nclass Inserter {\n        void insert(List list){\n            list.add(\"42\");           \n        }\n}','comiler warning but compiles and runs just fine, in order to support legacy code this must be allowed. ','Generics',1,NULL),(1574,'The compiiler only issues warnings when a typed collection is going into an untyped method and that method\nADDS somethiing. ','','Generics',1,NULL),(1575,'\"Type Erasure\"\n','The generic types are removed by the compiler before runtime. The types are just for the compiler the JVM\nhas no idea about types. To the JVM generic code looks the same as pre generic. ','Generics',1,NULL),(1576,'List myList = new ArrayList();\n        \nmyList.add(45);\n        \nint x = (Integer) myList.get(0);','cast is required here','Generics',1,NULL),(1577,' List<Integer> myList = new ArrayList<>();\n        \n        myList.add(45);\n        \n        int x = myList.get(0);\n        \n        ','cast not necessary here','Generics',1,NULL),(1578,'List<Object> myList = new ArrayList<JButton>();\nList<Number> myList = new ArrayList<Integer>();\nList<JButton> myList = new ArrayList<JButton>();\nList<String> myList = new ArrayList<String>();','no\nno\nyes\nyes','Generics',1,NULL),(1579,'class Parent { }\nclass Child extends Parent { }\n\npublic class Test {\n	psvm(SA){\n		Parent[] myArray = new Child[4];\n	}\n}','This is ok!\n\nunlike collection types array types can use polymorphism.\n','Generics',1,NULL),(1580,'List<Object> myList = new ArrayList<JButton>();	','This not ok ','Generics',1,NULL),(1581,'public class AnimalDoctor {\n	public void checkAnimals(ArrayLIst<Animal> list){\n		for(Animal a : animals){\n			a.checkup();\n		}\n	}\n}\n\npsvm(Sa){\n        List<Dog> dogs = new ArrayList<Dog>();\n        dogs.add(new Dog()); dogs.add(new Dog());\n\n        List<Cat> cats = new ArrrayLiist<Cat>();\n        cats.add(new Cat()); cats.add(new Cat());\n\n        AnimalDoctor ad = new AnimalDoctor();\n        ad.checkAnimals(dogs);\n        ad.checkAnimals(cats);\n}\n}','Will not compile\n\nif the method parameter says ArrayList<Animal> then you\ncan only pass in an ArrayList of type <Animal>, \npolymorphism doesn\'t work for generic types','Generics',1,NULL),(1582,'Animal[] animals = new Animal[3];\nanimals[0] = new Cat();\nanimals[1] = new Dog();','fine','Generics',1,NULL),(1583,'List<Animal> animals = new ArrayList<Animal>();\nanimals.add(new Cat());\nanimals.add(new Dog());\n','fine you can add and instance of a subtype into an array or collection declared with a supertype.\n\nyou can addDogs and Cats to an Animal array or an Animal Collection. ','Generics',1,NULL),(1584,'public class Hello {\n    public static void main(String[] args){\n       \n      \n        \n    }\n    \n    public void foo() {\n	Dog[] dogs = { new Dog(), new Dog() };\n	addAnimal(dogs);\n    }\n    \n    public void addAnimal(Animal[] animals) {\n	animals[0] = new Dog();\n        animals[1] = new Cat();\n    }\n}','ok!','Generics',1,NULL),(1585,'public class Hello {\n    public static void main(String[] args){\n \n    }\n    \n    public void foo() {\n	Cat[] cats = { new Cat(), new Cat() };\n	addAnimal(cats);\n    }\n    \n    public void addAnimal(Animal[] animals) {\n	animals[0] = new Dog();\n        animals[1] = new Cat();\n    }\n}','ok !\n\nThe compiler thinks its ok to add a Dog to an Animal[] since a Dog can be assigned to an animal reference. B\n\nBut the compiler does not know if you passed in an array of an animal subtype. \n\nThe reason: at runtime the JVM knows the type of the array but not the type of the collection ','Generics',1,NULL),(1586,'public class Hello {\n    public static void main(String[] args){\n        List<Animal> animals = new ArrayList<Animal>();\n        animals.add(new Dog());\n        animals.add(new Cat());\n        \n        addAnimal(animals);\n    \n    }\n    public static void addAnimal(List<Animal> animals) {\n	animals.add(new Dog());\n    }\n}','comiles and runs just fine','Generics',1,NULL),(1587,'public class Hello {\n    public static void main(String[] args){\n        ArrayList<Animal> animals = new ArrayList<>();\n        animals.add(new Dog());\n        animals.add(new Cat());\n        \n        addAnimal(animals);\n    \n    }\n    public static void addAnimal(List<Animal> animals) {\n	animals.add(new Dog());\n    }\n}','comiles fine','Generics',1,NULL),(1588,'public class Hello {\n    public static void main(String[] args){\n        List<Dog> animals = new ArrayList<>();\n        animals.add(new Dog());\n        \n        \n        addAnimal(animals);\n    \n    }\n    public static void addAnimal(List<Animal> animals) {\n	animals.add(new Dog());\n    }\n}','will not compile, ','Generics',1,NULL),(1589,'public class Hello {\n    public static void main(String[] args){\n        ArrayList<Dog> animals = new ArrayList<>();\n        animals.add(new Dog());\n        \n        \n        addAnimal(animals);\n    \n    }\n    public static void addAnimal(List<Animal> animals) {\n	animals.add(new Dog());\n    }\n}','will not compile because of ArrayList<Dog> cant be applied to List<Animal>','Generics',1,NULL),(1590,'What mechanism is used to tell the compiler \" Hey, I\'m using the collection passed in just to invoke methods \non the elements  and I promise not to ADD anything into the collection\"','<?> wildcard\n\ntells the compiler you can take any generic subtype of the declared argument type because you won\'t\nbe putting anything in the collection. ','Generics',1,NULL),(1591,'public class Hello {\n    public static void main(String[] args){\n        ArrayList<Dog> animals = new ArrayList<>();\n        animals.add(new Dog());\n        \n        \n        addAnimal(animals);\n    \n    }\n    public static void addAnimal(List<? extends Animal> animals) {\n	animals.add(new Dog());\n    }\n}','wont compile \n\nadding to a collection is not compatible with ? notation','Generics',1,NULL),(1592,'public class Hello {\n    public static void main(String[] args){\n        ArrayList<Dog> animals = new ArrayList<>();\n        animals.add(new Dog());\n        \n        \n        addAnimal(animals);\n    \n    }\n    public static void addAnimal(List<? extends Animal> animals) {\n	for(Animal a : animals){\n            a.makesound();\n        }\n    }\n}','compiles fine!','Generics',1,NULL),(1593,'public class Hello {\n    public static void main(String[] args){\n        ArrayList<Dog> animals = new ArrayList<>();\n        animals.add(new Dog());\n        \n        \n        addAnimal(animals);\n    \n    }\n    public static void addAnimal(List<? extends Serializable> animals) {\n	for(Animal a : animals){\n            a.makesound();\n        }\n    }\n}\n\nclass Dog extends Animal{}\nclass Cat extends Animal{}\nclass Animal implements Serializable{\n    public void makesound(){ System.out.println(\"SOUND\"); }\n        \n}','will not compile because of for(Animal a : animals)\n\n	needs to be... \n		for(Serializable a : animals)','Generics',1,NULL),(1594,'public class Hello {\n    public static void main(String[] args){\n        ArrayList<Dog> animals = new ArrayList<>();\n        animals.add(new Dog());\n        \n        \n        addAnimal(animals);\n    \n    }\n    public static void addAnimal(List<? extends Serializable> animals) {\n	for(Serializable a : animals){\n            //call method form interface\n        }\n    }\n}\n\nclass Dog extends Animal{}\nclass Cat extends Animal{}\nclass Animal implements Serializable{\n    public void makesound(){ System.out.println(\"SOUND\"); }\n        \n}','compiles fine!','Generics',1,NULL),(1595,'What can you use to type a method parameter and still add to the collection','<? super Dog>\n\npublic class Hello {\n    public static void main(String[] args) {     \n\n        List<Animal> animals = new ArrayList<Animal>();\n        animals.add(new Dog());\n        animals.add(new Cat());\n        \n        addAnimal(animals);\n    \n    }\n    \n    public static void addAnimal(List<? super Dog> animals) {\n	animals.add(new Dog());\n    }\n}\n\nWhile you can now accept in List types of <? super Dog> you can still only\nadd type Dog to that list. This is created because its ok to add a Dog to List<Object>\n\n\n','Generics',1,NULL),(1596,'public class Hello {\n    public static void main(String[] args){\n        List<Animal> animals = new ArrayList<Animal>();\n        animals.add(new Dog());\n        animals.add(new Animal());\n        \n        addAnimal(animals);\n        \n    \n    }\n    public static void addAnimal(List<? super Dog> animals) {\n	animals.add(new Dog());\n    }\n}','this is fine\n\n\"Hey compiler, please accept any List with a generic type that is of type Dog or a supertype of Dog. \nNothing lower in the inheritance tree can come in, but anything higher than Dog is okay\"\n\nif you pass in a List of type Animal then it\'s perfectly fine to add a Dog to it. If you pass in a list of type Dog\nits still ok to add a Dog to it. if you pass in a list of type Object its still ok. \n\nHowever that doesn\'t give you the freedom to just add anything  you can still\nonly add the type after the super','Generics',1,NULL),(1597,'public class Hello {\n    public static void main(String[] args){\n        List<Animal> animals = new ArrayList<Animal>();\n        animals.add(new Dog());\n        animals.add(new Animal());\n        \n        addAnimal(animals);\n        \n    \n    }\n    public static void addAnimal(List<Object> animals) {\n	animals.add(new Dog());\n    }\n}','will not compile incompatible types ','Generics',1,NULL),(1598,'','','Generics',1,NULL),(1599,'whats the difference between\n\npublic void foo(List<?> list){ }\npublic void foo(List<Object> list) { }','? will mean that any type of list can be passed to this method however nothing will be allowed to be added to it\n\n<Object> will mean that only lists of type Object can be passed to this method and \nyou will be able to add pretty much anything to that list. ','Generics',1,NULL),(1600,'public class TestWildcards {\n	psvm(sa) {\n		List<Integer> myList = new ArrayList<Integer>();\n		Bar bar = new Bar();\n		bar.doInsert(MyList);\n	}\n}\n\nclass Bar {\n	void doInsert(List<Object> list) {\n		list.add(new Dog();	\n	}\n}\n\nwhich class fails compilation here ?','class Bar compiles fine\n\nTest is the class that fails. ','Generics',1,NULL),(1601,'public class TestWildcards {\n	psvm(sa) {\n		List<Integer> myList = new ArrayList<Integer>();\n		Bar bar = new Bar();\n		bar.doInsert(MyList);\n	}\n}\n\nclass Bar {\n	void doInsert(List<?> list) {\n		list.add(new Dog();	\n	}\n}\n\nwhich class fails compilation here ?','Bar','Generics',1,NULL),(1602,'whats the difference between \n\nList<?>\nList<? extends Object>','nothing they are identicle \n\nthey both say I can refer to any type of object. but you wont be able to addd to me. \n\nthis is very differenct from List<Object> ','Generics',1,NULL),(1603,'1 List<?> list = new ArrayList<Dog>();\n2 List<? extends Animal> alist = new ArrayList<Dog>();\n3  List<?> foo = new ArrayList<? extends Animal>();\n4 List<? extends Dog> cList = new ArrayList<Integer>();\n5 List<? super Dog> dList = new ArrayList<Animal>();\n6 List<? super Animal elist = new ArrayList<Dog>();\n\n','1 2  and 5 compile ','Generics',1,NULL),(1604,'Which interface close() is idempotent ?','AutoCloseable()\nyou can call close() mulitple times and nothing will happen the second time and beyond. \n\nCloseable() is not, something could go wrong the second time','Generics',1,NULL),(1605,'declare a generic method:\n\npublic <T> void makeArrayList(T t){ }\n\npublic void makeArrayList(T t) { }\n\npublic void <T> makeArrayList(T t){\n}','public <T> void makeArrayList(T t){ }\n\nYou have to define the type variable BEFORE the return type of the method\n\n','Generics',1,NULL),(1606,'public class Hello<T> {\n    public static void main(String[] args){\n        Printer<String> x = Printer.getInstance();\n\n    }\n    public static void addAnimal(List<T> animals) {\n	animals.add(new Dog());\n    }\n    \n    public <G> ArrayList<G> makeArrayList(G g){\n        ArrayList<G> genlist = new ArrayList();\n        genlist.add(g);\n        return genlist;\n        \n    }\n}\n\nclass Printer<T> {\n    private ArrayList<T> joblist = new ArrayList<>();\n    private static Printer instance = null;\n    \n    protected Printer(){\n        \n    }\n    \n    public static Printer getInstance(){\n        if(instance == null){\n            instance = new Printer();\n            return instance;\n        }\n        \n        return instance;\n        \n    }\n    \n    public void addJob(T t){\n        joblist.add(t);\n    }\n}','Will not compile \n\nNon static type variable cannot be referenced from static context. \n\nWhen T is defined for a new class it is appropriate for that instance there forfore static methods of that \nclass wont really know about the individualy typed instances. \n\nSingleton with generics doesn\'t make a whole lot of sense anyway....\n\npublic class SimpleSingleton {\nprivate Map<String, Object> counter = new HashMap<String, Object>();\n\npublic <T> T getInstance(Class<T> clazz) throws IllegalAccessException, InstantiationException {\n    T singleton = (T) counter.get(clazz.getName());\n    if (singleton == null) {\n        singleton = clazz.newInstance();\n        counter.put(clazz.getName(), singleton);\n    }\n    return singleton;\n}\n\n\nalso adding a Dog to an ArrayList typed for T will not compile \n','Generics',1,NULL),(1607,'public class Hello<T> {\n    public static void main(String[] args){\n        Printer<String> x = new Printer<>();\n        String y = x.instance;\n        System.out.println(y.length());\n\n    } \n    public <G> ArrayList<G> makeArrayList(G g){\n        ArrayList<G> genlist = new ArrayList();\n        genlist.add(g);\n        return genlist;\n        \n    }\n}\n\nclass Printer<T> {\n    private ArrayList<T> joblist = new ArrayList<>();\n    T instance;\n    \n    public Printer(){\n        \n    }\n    \n    public void addJob(T t){\n        joblist.add(t);\n    }\n    \n    public T getAnewT(){\n        return instance;\n    }\n}','NullPointerException\n\ninstance in class Printer is never intitialized','Generics',1,NULL),(1608,'class Printer<T> {\n    private ArrayList<T> joblist = new ArrayList<>();\n    private T instance;\n    \n    public Printer(){\n        \n    }\n    \n    public Printer(T b){\n        T = b;\n    }\n    \n    public void addJob(T t){\n        joblist.add(t);\n    }\n    \n    public T getAnewT(){\n        return instance;\n    }\n}','in the overloaded constructor T should be instance, remember a Type is an Object not an reference varialb.e','Generics',1,NULL),(1609,'class Printer<T extends Number> {\n    private ArrayList<T> joblist = new ArrayList<>();\n    private T instance;\n    \n    public Printer(){\n        \n    }\n    \n    public Printer(T b){\n       instance = b;\n    }\n    \n    public void addJob(T t){\n        joblist.add(t);\n    }\n    \n    public T getAnewT(){\n        return instance;\n    }\n}','a Class will be created with a type that extends number','Generics',1,NULL),(1610,'class Printer<? extends Number> {\n    private ArrayList<T> joblist = new ArrayList<>();\n    private T instance;\n    \n    public Printer(){\n        \n    }\n    \n    public Printer(T b){\n       instance = b;\n    }\n    \n    public void addJob(T t){\n        joblist.add(t);\n    }\n    \n    public T getAnewT(){\n        return instance;\n    }\n}','will not compile, a type variable is needed here not a wildcard.\n\nWildcards are never used in generic class definitions','Generics',1,NULL),(1611,'class Printer<T super Beagle> {\n    private ArrayList<T> joblist = new ArrayList<>();\n    private T instance;\n    \n    public Printer(){\n        \n    }\n    \n    public Printer(T b){\n       instance = b;\n    }\n    \n    public void addJob(T t){\n        joblist.add(t);\n    }\n    \n    public T getAnewT(){\n        return instance;\n    }\n}\n\nclass Animal{}\nclass Dog extends Animal{}\nclass Beagle extends Dog{}','Does not compile,\n\nyou cant use super when defining a generic class','Generics',1,NULL),(1612,'class Printer<T extends Animal> {\n    private ArrayList<T> joblist = new ArrayList<>();\n    private T instance;\n    \n    public Printer(){\n        \n    }\n    \n    public Printer(T b){\n       instance = b;\n    }\n    \n    public void addJob(T t){\n        joblist.add(t);\n    }\n    \n    public void makeSound() {\n        instance.makeSound();\n    }\n    \n    public T getAnewT(){\n        return instance;\n    }\n}\n\nclass Animal{public void makeSound(){\n            System.out.println(\"Sound!\");\n}\n}\nclass Dog extends Animal{}\nclass Beagle extends Dog{}','fine,\n\nyou use extends when creating a generic class to specify bounds','Generics',1,NULL),(1613,'public class Hello<T> {\n    public static void main(String[] args){\n        \n        Printer<String> x = new Printer<>();\n\n\n    } \n    public <G> ArrayList<G> makeArrayList(G g){\n        ArrayList<G> genlist = new ArrayList();\n        genlist.add(g);\n        return genlist;\n        \n    }\n}\n\nclass Printer<T extends Animal> {\n    private ArrayList<T> joblist = new ArrayList<>();\n    private T instance;\n    \n    public Printer(){\n        \n    }\n    \n    public Printer(T b){\n       instance = b;\n    }\n    \n    public void addJob(T t){\n        joblist.add(t);\n    }\n    \n    public void makeSound() {\n        instance.makeSound();\n    }\n    \n    public T getAnewT(){\n        return instance;\n    }\n}\n\nclass Animal{public void makeSound(){\n            System.out.println(\"Sound!\");\n}\n}\nclass Dog extends Animal{}\nclass Beagle extends Dog{}','will not compile type argument string is not within bound of class Printer','Generics',1,NULL),(1614,'public class Hello<T> {\n    public static void main(String[] args){\n\n        ArrayList x = makeArrayList(Dog d);\n        \n        ArrayList c = new ArrayList<String>();\n\n    } \n    public <G> ArrayList<G> makeArrayList(G g){\n        ArrayList<G> genlist = new ArrayList();\n        genlist.add(g);\n        return genlist;\n        \n    }\n}','will not compile because of (Dog d)','Generics',1,NULL),(1615,'public class Hello<T> {\n    public static void main(String[] args){\n        \n        Dog d = new Dog();\n        \n        ArrayList x = makeArrayList(d);\n        \n        ArrayList c = new ArrayList<String>();\n\n    } \n    public static <G> ArrayList<G> makeArrayList(G g){\n        ArrayList<G> genlist = new ArrayList();\n        genlist.add(g);\n        return genlist;\n        \n    }\n}','compiles fine.','Generics',1,NULL),(1616,'public class Hello<T> {\n    public static void main(String[] args){\n        \n        Dog d = new Dog();\n        \n        ArrayList x = makeArrayList(d);\n        \n        ArrayList c = new ArrayList<String>();\n        c.add(\"quick string\");\n        \n        x.add(new Dog());\n        \n        Dog a = x.get(0);\n        String stringa = c.get(0);\n \n    } \n    public static <G> ArrayList<G> makeArrayList(G g){\n        ArrayList<G> genlist = new ArrayList();\n        genlist.add(g);\n        return genlist;\n        \n    }\n}','neither Dog a nor stringa will compile. The Declared type of the arraylists is non generic so they return objects\n','Generics',1,NULL),(1617,'public class Hello<T> {\n    public static void main(String[] args){\n        \n        Dog d = new Dog();\n        \n        ArrayList<Dog> c = makeArrayList(d);\n \n    } \n    public static <G> ArrayList<G> makeArrayList(G g){\n        ArrayList<G> genlist = new ArrayList();\n        genlist.add(g);\n        return genlist;\n        \n    }\n}','compiles fine','Generics',1,NULL),(1618,'public class Hello<T> {\n    public static void main(String[] args){\n        \n        Dog d = new Dog();\n        \n        ArrayList<Dog> c = makeArrayList(d);\n        \n        c.add(new Beagle());\n \n    } \n    public static <G extends Animal> ArrayList<G> makeArrayList(G g){\n        ArrayList<G> genlist = new ArrayList();\n        genlist.add(g);\n        return genlist;\n        \n    }\n}\n\n\nclass Animal{public void makeSound(){\n            System.out.println(\"Sound!\");\n}\n}\nclass Dog extends Animal{}\nclass Beagle extends Dog{}','compiles fine','Generics',1,NULL),(1619,'public class Hello<T> {\n    public static void main(String[] args){\n        \n        Dog d = new Dog();\n        \n        ArrayList<Dog> c = makeArrayList(d);\n \n    } \n    public static <? extends Animal> ArrayList<?> makeArrayList(? g){\n        ArrayList<?> genlist = new ArrayList();\n        genlist.add(g);\n        return genlist;\n        \n    }\n}','Compilation fails ? wildcard is not valid here you need a type varialbe istead','Generics',1,NULL),(1620,'public class Hello<T> {\n    public static void main(String[] args){\n        \n        Dog d = new Dog();\n        \n        ArrayList<?> c = makeArrayList(d);\n \n    } \n    public static <G extends Animal> ArrayList<G> makeArrayList(G g){\n        ArrayList<G> genlist = new ArrayList();\n        genlist.add(g);\n        return genlist;\n        \n    }\n}','compiles fine, \n\nyou can define ArrayLIsts this way, you wont be able to add anything to it though','Generics',1,NULL),(1621,'public class Hello<T> {\n    public static void main(String[] args){\n        \n        Dog d = new Dog();\n        \n        ArrayList<?> c = makeArrayList(d);\n        c.add(new Animal());\n    } \n    public static <G extends Animal> ArrayList<G> makeArrayList(G g){\n        ArrayList<G> genlist = new ArrayList();\n        genlist.add(g);\n        return genlist;\n        \n    }\n}','compilation fails','Generics',1,NULL),(1622,'public class Hello<T> {\n    public static void main(String[] args){\n        \n        Dog d = new Dog();\n        \n        ArrayList<H extends Beagle> c = makeArrayList(d);\n        \n    } \n    public static <G extends Animal> ArrayList<G> makeArrayList(G g){\n        ArrayList<G> genlist = new ArrayList();\n        genlist.add(g);\n        return genlist;\n        \n    }\n}','does not compile because of H extends Beagle\n\nshould be ? extends Beagle','Generics',1,NULL),(1623,'public class Hello<T> {\n    public static void main(String[] args){\n        \n        Dog d = new Dog();\n        \n        ArrayList<? extends Beagle> c = makeArrayList(d);\n        \n    } \n    public static <G extends Animal> ArrayList<G> makeArrayList(G g){\n        ArrayList<G> genlist = new ArrayList();\n        genlist.add(g);\n        return genlist;\n        \n    }\n}\n\n\nclass Animal{public void makeSound(){\n            System.out.println(\"Sound!\");\n}\n}\nclass Dog extends Animal{}\nclass Beagle extends Dog{}','does not compile Beagle is the lowest type and nothing extends it,\n\nthe only type that would be acceptable here is a Beagle','Generics',1,NULL),(1624,'public class Hello<T> {\n    public static void main(String[] args){\n        \n        Dog d = new Dog();\n        \n        ArrayList<? extends Animal> c = makeArrayList(d);\n        \n    } \n    public static <G extends Animal> ArrayList<G> makeArrayList(G g){\n        ArrayList<G> genlist = new ArrayList();\n        genlist.add(g);\n        return genlist;\n        \n    }\n}\n\n\nclass Animal{public void makeSound(){\n            System.out.println(\"Sound!\");\n}\n}\nclass Dog extends Animal{}\nclass Beagle extends Dog{}','compiles fine','Generics',1,NULL),(1625,'PECS','\n\nPECS (short for \"Producer extends and Consumer super\") can be explained by : Get and Put Principle\nGet And Put Principle (From Java Generics and Collections)\n\nIt states,\n\n    use an extends wildcard when you only get values out of a structure\n    use a super wildcard when you only put values into a structure\n    and don’t use a wildcard when you both get and put.\n\nLet\'s understand it by example:\n\n1. For Extends Wildcard(get values i.e Producer extends)\n\nHere is a method, that takes a collection of numbers, converts each to a double, and sums them up\n\npublic static double sum(Collection<? extends Number> nums) {\n   double s = 0.0;\n   for (Number num : nums) \n      s += num.doubleValue();\n   return s;\n}\n\nLet\'s call the method :\n\nList<Integer>ints = Arrays.asList(1,2,3);\nassert sum(ints) == 6.0;\nList<Double>doubles = Arrays.asList(2.78,3.14);\nassert sum(doubles) == 5.92;\nList<Number>nums = Arrays.<Number>asList(1,2,2.78,3.14);\nassert sum(nums) == 8.92;\n\nSince, sum() method uses extends, all of the following calls are legal. The first two calls would not be legal if extends was not used.\n\nEXCEPTION : You cannot put anything into a type declared with an extends wildcard—except for the value null, which belongs to every reference type:\n\nList<Integer> ints = new ArrayList<Integer>();\nints.add(1);\nints.add(2);\nList<? extends Number> nums = ints;\nnums.add(null);  // ok\nassert nums.toString().equals(\"[1, 2, null]\");\n\n2. For Super Wildcard(put values i.e Consumer super)\n\nHere is a method, that takes a collection of numbers and an int n, and puts the first n integers, starting from zero, into the collection:\n\npublic static void count(Collection<? super Integer> ints, int n) {\n    for (int i = 0; i < n; i++) ints.add(i);\n}\n\nLet\'s call the method :\n\nList<Integer>ints = new ArrayList<Integer>();\ncount(ints, 5);\nassert ints.toString().equals(\"[0, 1, 2, 3, 4]\");\nList<Number>nums = new ArrayList<Number>();\ncount(nums, 5); nums.add(5.0);\nassert nums.toString().equals(\"[0, 1, 2, 3, 4, 5.0]\");\nList<Object>objs = new ArrayList<Object>();\ncount(objs, 5); objs.add(\"five\");\nassert objs.toString().equals(\"[0, 1, 2, 3, 4, five]\");\n\nSince, count() method uses super, all of the following calls are legal: The last two calls would not be legal if super was not used.\n\nEXCEPTION : you cannot get anything out from a type declared with a super wildcard—except for a value of type Object, which is a supertype of every reference type:\n\nList<Object> objs = Arrays.<Object>asList(1,\"two\");\nList<? super Integer> ints = objs;\nString str = \"\";\nfor (Object obj : ints) str += obj.toString();\nassert str.equals(\"1two\");\n\n3. When both Get and Put, don\'t Use wildcard\n\nWhenever you both put values into and get values out of the same structure, you should not use a wildcard.\n\npublic static double sumCount(Collection<Number> nums, int n) {\n   count(nums, n);\n   return sum(nums);\n}\n\n','Generics',1,NULL),(1626,'public class Hello<T> {\n    \n    public static void main(String[] args){\n        \n        Dog d = new Dog();\n        \n        ArrayList<? extends Animal> c = new ArrayList<Beagle>();\n        \n        c.add(new Beagle()); // does not compile\n        c.add(new Beagle()); // does not compile\n        \n        Animal a = c.get(0);\n    } ','PECS\n\nproducers extends consumers super','Generics',1,NULL),(1627,'public class Hello<T> {\n    \n    public static void main(String[] args){\n        \n        Dog d = new Dog();\n        \n        ArrayList<? super Beagle> c = new ArrayList<Beagle>();\n        \n        c.add(new Beagle());\n        c.add(new Beagle()); \n        \n        Beagle a = c.get(0);\n    } ','does not compile because of Beagle a = c.get(0);','Generics',1,NULL),(1628,'public class Hello<T> {\n    \n    public static void main(String[] args){\n        \n        Dog d = new Dog();\n        \n        ArrayList<Dog> c = makeArrayList(d);\n        \n        c.add(new Beagle());\n        c.add(new Beagle()); \n\n    } \n    public static <G extends Animal> ArrayList<G> makeArrayList(G g){\n        ArrayList<G> genlist = new ArrayList<>();\n        genlist.add(g);\n        return genlist;\n        \n    }\n}','compiles fine','Generics',1,NULL),(1629,'public class Hello<T> {\n    \n    public static void main(String[] args){\n        \n        Dog d = new Dog();\n        \n        ArrayList<Dog> c = makeArrayList(new Beagle());\n        \n        c.add(new Beagle());\n        c.add(new Beagle()); \n\n    } \n    public static <G extends Animal> ArrayList<G> makeArrayList(G g){\n        ArrayList<G> genlist = new ArrayList<>();\n        genlist.add(g);\n        return genlist;\n        \n    }\n}','compiles fine','Generics',1,NULL),(1630,'public class Hello<T> {\n    \n    public static void main(String[] args){\n        \n        Dog d = new Dog();\n        \n        ArrayList<Dog> c = makeArrayList(new Animal());\n        \n        c.add(new Beagle());\n        c.add(new Beagle()); \n\n    } \n    public static <G extends Animal> ArrayList<G> makeArrayList(G g){\n        ArrayList<G> genlist = new ArrayList<>();\n        genlist.add(g);\n        return genlist;\n        \n    }\n}','comilation fails\n\nArrayLIst<Animal> cannot be applied to ArrayList<Dog>','Generics',1,NULL),(1631,'\npublic class Hello<T> {\n    \n    public static void main(String[] args){\n        \n        Dog d = new Dog();\n        \n        ArrayList<?> c = makeArrayList(new Animal());\n        \n\n    } \n    public static <G extends Animal> ArrayList<G> makeArrayList(G g){\n        ArrayList<G> genlist = new ArrayList<>();\n        genlist.add(g);\n        return genlist;\n        \n    }\n}','comiles fine','Generics',1,NULL),(1632,'public class Test {\n\n    public class A {}\n\n    public class B extends A {}\n\n    public class C extends B {}\n\n    public void testCoVariance(List<? extends B> myBlist) {\n        B b = new B();\n        C c = new C();\n        myBlist.add(b); // does not compile\n        myBlist.add(c); // does not compile\n        A a = myBlist.get(0); \n    }\n\n    public void testContraVariance(List<? super B> myBlist) {\n        B b = new B();\n        C c = new C();\n        myBlist.add(b);\n        myBlist.add(c);\n        A a = myBlist.get(0); // does not compile\n    }\n}','','Generics',1,NULL),(1633,'PECS','\n\nJosh Bloch\'s mnemonic PECS is useful here. It stands for:\n\nProducer extends, Consumer super\n\nThis means that when a parameterized type being passed to a method will produce instances of T (they will be retrieved from it in some way), ? extends T should be used, since any instance of a subclass of T is also a T.\n\nWhen a parameterized type being passed to a method will consume instances of T (they will be passed to it to do something), ? super T should be used because an instance of T can legally be passed to any method that accepts some supertype of T. A Comparator<Number> could be used on a Collection<Integer>, for example. ? extends T would not work, because a Comparator<Integer> could not operate on a Collection<Number>.\n\nEdit: To clarify a little more on get/put (produce/consume):\n\npublic T something();\n       ^\n\nThe above is a method that produces T.\n\npublic void something(T t);\n                      ^\n\nThe above is a method that consumes T.\n\n\"Producer extends, Consumer super\" applies to how the method a parameterized object is being passed to is going to be using that object. In the case of Collections.max(), items will be retrieved from the Collection, so it is a producer. Those items will be passed as arguments to the method on Comparator, so it is a consumer.\n','Generics',1,NULL),(1634,'/ Source \n       List<Integer> intList = Arrays.asList(1,2,3);\n       List<Double> doubleList = Arrays.asList(2.78,3.14);\n       List<Number> numList = Arrays.asList(1,2,2.78,3.14,5);\n\n       // Destination\n       List<Integer> intList2 = new ArrayList<>();\n       List<Double> doublesList2 = new ArrayList<>();\n       List<Number> numList2 = new ArrayList<>();\n\n        // Works\n        copyElements1(intList,intList2);         // from int to int\n        copyElements1(doubleList,doublesList2);  // from double to double\n\n\n     static <T> void copyElements1(Collection<T> src, Collection<T> dest) {\n        for(T n : src){\n            dest.add(n);\n         }\n      }\n\n\n     // Let\'s try to copy intList to its supertype\n     copyElements1(intList,numList2); // error, method signature just says \"T\"\n                                      // and here the compiler is given \n                                      // two types: Integer and Number, \n                                      // so which one shall it be?\n\n     // PECS to the rescue!\n     copyElements2(intList,numList2);  // possible\n\n\n\n    // copy Integer (? extends T) to its supertype (Number is super of Integer)\n    private static <T> void copyElements2(Collection<? extends T> src, \n                                          Collection<? super T> dest) {\n        for(T n : src){\n            dest.add(n);\n        }\n    }','','Generics',1,NULL),(1635,'public class Hello<T> {\n    \n    public static void main(String[] args){\n        ArrayList<Animal> a;\n        ArrayList<Beagle> b;\n        \n        Hello<String> x = new Hello<>();\n        \n        x.copyColl(a,b);\n        \n\n    } \n    public <G> void copyColl(Collection<G> src, Collection<G> dest){\n        \n        for(G n : src)\n            dest.add(n);\n        \n    }\n}','does not compile Collection<G> is given two different types here\n\nalso a and b were not initialized, that is ok to do with instance variables\nbut not locals \n\nyou could say \n\nArrayList<Animal> a = null;\nand same for b;','Generics',1,NULL),(1636,'public class Hello<T> {\n    \n    public static void main(String[] args){\n        ArrayList<Dog> a = new ArrayList<>();\n        ArrayList<Dog> b = new ArrayList<>();\n        \n        Hello<String> x = new Hello<>();\n        \n        x.copyColl(a,b);\n        \n\n    } \n    public <G extends Animal> void copyColl(Collection<G> src, Collection<G> dest){\n        \n        for(G n : src)\n            dest.add(n);\n        \n    }\n}','compiles fine','Generics',1,NULL),(1637,'public class Hello<T> {\n    \n    public static void main(String[] args){\n        ArrayList<Dog> a = new ArrayList<>();\n        ArrayList<Dog> b = new ArrayList<>();\n        \n        Hello<String> x = new Hello<>();\n        \n        \n        \n        x.copyColl(a,b);\n        \n\n    } \n    public <G extends Animal> void copyColl(Collection<G> src, Collection<? extends G> dest){\n        \n        for(G n : src)\n            dest.add(n);\n        \n    }\n}','does not compile \n\nyou cant add to a collection declared with wildcard extends','Generics',1,NULL),(1638,'public class Hello<T> {\n    \n    public static void main(String[] args){\n        ArrayList<Dog> a = new ArrayList<>();\n        ArrayList<Dog> b = new ArrayList<>();\n        \n        Hello<String> x = new Hello<>();\n        \n        \n        \n        x.copyColl(a,b);\n        \n\n    } \n    public <G extends Animal> void copyColl(Collection<G> src, Collection<? super G> dest){\n        \n        for(G n : src)\n            dest.add(n);\n        \n    }\n}','compiles fine','Generics',1,NULL),(1639,'public class Hello<T> {\n    \n    public static void main(String[] args){\n        ArrayList<Animal> a = new ArrayList<>();\n        ArrayList<Dog> b = new ArrayList<>();\n        \n        Hello<String> x = new Hello<>();\n        \n        \n        \n        x.copyColl(a,b);\n        \n\n    } \n    public <G extends Animal> void copyColl(Collection<? extends G> src, Collection<? super G> dest){\n        \n        for(G n : src)\n            dest.add(n);\n        \n    }\n}','will not compiile at x.copyColl','Generics',1,NULL),(1640,'public class Hello<T> {\n    \n    public static void main(String[] args){\n        ArrayList<Beagle> a = new ArrayList<>();\n        ArrayList<Animal> b = new ArrayList<>();\n        \n        Hello<String> x = new Hello<>();\n        \n        \n        \n        x.copyColl(a,b);\n        \n\n    } \n    public <G extends Animal> void copyColl(Collection<? extends G> src, Collection<? super G> dest){\n        \n        for(G n : src)\n            dest.add(n);\n        \n    }\n}','compiles fine\n\nyou can easily take a beagle and add it to an Animal array','Generics',1,NULL),(1641,'','','blank',1,NULL),(1642,'','','blank',1,NULL),(1643,'','','blank',1,NULL),(1644,'','','blank',1,NULL),(1645,'','','blank',1,NULL),(1646,'public class Visit extends SimpleFileVisitor<Path> {\n\n	//insert here\n\n   public static void main(String[] args) throws Exception {\n	Visit v = new Visit();\n	Files.walkFileTree(Paths.get(\"/mydir\"),v);\n   }\n}\n\nwhat inserted here will print out the provided directory and all \nsubdirectories ?\n\n\n','public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs)\nthrows IOException {\n	sout( dir );\n	return FileVisitResult.CONTINUE;\n}\n\npublic FileVisitResult postVisitDirectory(Path dir, IOException e)\nthrows IOException {\n	sout( dir );\n	return FileVisitResult.CONTINUE;\n}\n\n**VisitFile is called only for Files and not directories','Input/Output',1,NULL),(1647,'','','blank',1,NULL),(1648,'','','blank',1,NULL),(1649,'class Bird {	\n	{ System.out.println(\"b1\"); }	\n	public Bird() { System.out.println(\"b2\"); }\n}\n\nclass Raptor extends Bird {\n	static {System.out.println(\"r1\"); }\n	public Raptor() { System.out.println(\"r2\"); }\n	{ System.out.println(\"r3\"); }\n	static { System.out.println(\"r4\"); }\n}\npublic class Hello extends Raptor {\n\n    public static void main(String[] args) {\n        System.out.println(\"pre \");\n        new Hello();\n        System.out.println(\"hawk\");\n    }\n}\n		','r1\nr4\npre \nb1\nb2\nr3\nr2\nhawk\n\nstatic init blocks run at class loading time. Instance init blocks run after\nthe constructors call to super()','OOP',1,NULL),(1650,'public static void makeFileCreatedOnMonday(Path d) throws IOException{\n        BasicFileAttributes ba = Files.readAttributes(d, BasicFileAttributes.class);\n        Calendar c = Calendar.getInstance();\n        //BasicFileAttributeView baView = Files.readAttributeView(d,BasicFileAttributes.class)\n        //BasicFileAttributeView baView = Files.getBasicAttributeView(d,BasicFileAttributes.class);\n        //BasicFileAttributeView baView = Files.getFileAttributeView(d,BasicFileAttributes.class);\n        //BasicFileAttributeView baView = Files.getFileAttributeView(d,BasicFileAttributeView.class);\n        \n	//void setTimes(FileTime lastModifiedTime,FileTime lastAccessTime,FileTime createTime)\n        \n        Date creationDate = new Date(ba.creationTime().toMillis());\n        c.setTime(creationDate);\n        \n        if(c.get(Calendar.DAY_OF_WEEK) == Calendar.MONDAY){\n            baView.setTimes(null,null,null);\n        } else {\n            //other fields are retained\n            c.set(Calendar.DAY_OF_WEEK,Calendar.MONDAY);\n            FileTime newDay = FileTime.fromMillis(c.getTimeInMillis());\n            \n            baView.setTimes(null,null,newDay);\n        }\n        \n    }\n\nHow do you create a FileAttributeView ?','BasicFileAttributeView baView = Files.getFileAttributeView(d,BasicFileAttributeView.class);','Strings',1,NULL),(1651,'','','blank',1,NULL),(1652,'psvm(SA){\n	List<Integer> list = new ArrayLIst<>();\n	list.add(5); //autoboxing\n	foo( list );\n}\n\nstatic void foo(List alist) {\n	alist.add(new Dog(\"Charly\"));\n}','compiles with warnings \n\nthe problems will arrise down the road when you get that dog out of a supposedly Integer array. ','Generics',1,NULL),(1653,'Generic type information does not exist at runtime - it is for compile-time safetly only.\nMixing generics with legacy code can create compiled code that may throw an excecption at runtime. ','','Generics',1,NULL),(1654,'polymorphic assingment rules apply everywhere an assignment can be made for generics,\n\nthe following are not allowed:\n	\n	void foo(List<Animal> alist {  }  //cannot take a List<Dog>\n\n	List<Animal> bar() {  }  // cannot return a List<Dog>','','Generics',1,NULL),(1655,'class Animal{\n    public void makeSound() throws InterruptedException {\n            System.out.println(\"Sound!\");\n    }\n}\nclass Dog extends Animal{\n    public void makeSound() throws InterruptedException {\n        System.out.println(\"Bark!\");\n        \n    }\n}\nclass BullDog extends Dog{\n    public void makeSound() throws InterruptedException {\n        System.out.println(\"Grumble!\");\n    }\n}','compiles fine','Generics',1,NULL),(1656,'class Animal{\n    public void makeSound() throws InterruptedException {\n            System.out.println(\"Sound!\");\n    }\n}\nclass Dog extends Animal{\n    public void makeSound(){\n        System.out.println(\"Bark!\");\n        \n    }\n}\nclass BullDog extends Dog{\n    public void makeSound() throws InterruptedException {\n        System.out.println(\"Grumble!\");\n    }\n}','BullDog does not compile, Dog\'s makeSound chose not to throw the exception but then when BullDog chose \nto override it didn\'t know that Animal used to throw that exception. ','General',1,NULL),(1657,'public class Hello<T> {\n    \n    public static void main(String[] args){\n      Hello<?> x = new Hello<>();\n      \n      List<?> readonlylist = x.dogs();\n      List<?> readonlyanimallist = x.animals();\n        \n\n    } \n    public ArrayList<Animal> animals(){\n        ArrayList<Animal> vetlist = new ArrayList<>();\n        vetlist.add(new Animal());\n        vetlist.add(new BullDog());\n        vetlist.add(new BullDog());\n        vetlist.add(new Dog());\n        vetlist.add(new Animal());\n        \n        return vetlist;\n  \n    }\n    \n    public ArrayList<Dog> dogs(){\n        ArrayList<Animal> vetlist = new ArrayList<>();\n        vetlist.add(new Dog());\n        vetlist.add(new BullDog());\n        vetlist.add(new BullDog());\n        vetlist.add(new Dog());\n        vetlist.add(new Dog());\n\n        return vetlist;\n    }','does not compile because you cannot return an Animal list from a method declaring a return statemnt\nof Dog list','Generics',1,NULL),(1658,'Wildcard syntax allows a generic method to accept subtypes or supertypes of the declared type\nof the method argument.\n\n	void addD(List<Dog> d) {  } //can take only <Dog>\n	\n	void addD(List<? extends Dog>) { } //take a <Dog> or <Beagle>','','Generics',1,NULL),(1659,'The wildcard keyword \'extends\' is used to mean either \" extends \" or \"implements\" \n\nso in <? extends Dog> Dog can be a class or interface. ','','Generics',1,NULL),(1660,'When using a wildcard List<? extends Dog>, the collection can be accessed but not modified','','Generics',1,NULL),(1661,'When using a wildcard List<?> any generic type can be assigned to the reference, but for access only\nno modifications.','','Generics',1,NULL),(1662,'List<Object> refers only to a List<Object>, while List<?> or List<? extends Object> can hold \nany type of object, but for access only. \n\n','','Generics',1,NULL),(1663,'The generic type identifier can be used in class, method, and variable declarations:\n\n	class Foo<t> { }\n	T anInstance;\n	Foo(T aRef) { } // a constructor argument\n	void bar(T aRef) {  }	//method argument\n	T baz() { }	//return type','got it ','Generics',1,NULL),(1664,'You can declare a generic method using a type not defined in the class:\n	\n	public <T> void makeList(T t) { }\n\n\n    This is not using T as a return type. This method has a void return type, but to use T within the argument you must declare the <T>\n	which happens before the return type. ','','Generics',1,NULL),(1665,'psvm(SA){\n	for(int i = 0; i<= 10; i++) {\n		List<Integer> row = new ArrayList<>();\n		for (int j = 0; j<= 10; j++)\n		         row.add(i*j);\n		table.add(row);\n	}\n	for(List<Integer> row : table)\n		sout(row);\n}\n\ndefine table','List<List<Integer>> table = new ArrayList<>();\n\nList<List<Integer>> table = new ArrayList<List<Integer>>();\n\n	not this:\n		List<List<Integer>> superlist1 = new ArrayList<ArrayList<Integer>>();\n\n	.... incompatible types','Generics',1,NULL),(1666,'Which statements are true about comparing two instances of the same class \ngiven that equals() and hashCode() have been properly overriden\n\n1 if the equals() returns true, the hashCode() comparison == might return false\n\n2 if the equals() returns false, the hashCode() comparison == might return true\n\n3 if the hashCode() comparison == returns true, the equals() method must return true\n\n4 if the hashCode() comparison == returns true, the equals() method might return true\n\n5 if the hashCode() comparison != returns true, the equals() method might return true','2 is true because often two dissiimilar objects can return the same hashcode value.\n\n4 is true because if the hashCode() comparison == returns true, might or might not be equal. \n\n3 is incorrect because often two dissimilar objects can return the same hashcode value. \n\n1 and 5 are a negation of the equals and hashCode() contract','Generics',1,NULL),(1667,'IF TWO OBJECTS ARE EQUAL ACCORDING TO THE EQUALS(OBJECT) METHOD, THE CALLING THE HASHCODE()\nMETHOD ON EACH OF THE TWO OBJECT MUST PRODUCE THE SAME INTEGER RESULT. ','got it\n','Generics',1,NULL),(1668,'It is not required that if two object are unequal according to the dquals method, the calling the hashCode()\non each of the two objects must produce distinct integer results. ','','Generics',1,NULL),(1669,'public static void before() {\n	Set set = new TreeSet();\n	set.add(\"2\");\n	set.add(3);\n	set.add(\"1);\n	Iterator it = set.iterator();\n		while(it.hasNext() )\n	sout( it.next() );\n}\n','ClassCastException','Generics',1,NULL),(1670,'interface Hungry<E> { void munch(E x); }\ninterface Carnivore<E extends Animal> extends Hungry<E> { }\ninterface Herbivore<E extends Plant> extends Hungry<E> { }\nabstract class Plant { }\nabstract class Animal { }\nclass Grass extends Plant { }\nclass Sheep extends Animal implements Herbivore<Sheep> {\n    public void munch (Sheep x){ }\n}\nclass Wolf extends Animal implements Carnivore<Sheep> {\n    public void munch(Sheep x) { }\n}\n\nwhat can you change to make this compile','Change Herbivore interface to\n	\n	 interface Herbivore<E extends Animal> extends Hungry<E> { }','Generics',1,NULL),(1671,'interface Hungry<E> { void munch(E x); }\ninterface Carnivore<E extends Animal> extends Hungry<E> { }\ninterface Herbivore<E extends Plant> extends Hungry<E> { }\nabstract class Plant { }\nabstract class Animal { }\nclass Grass extends Plant { }\nclass Sheep extends Animal implements Herbivore<Plant> {\n    public void munch (Sheep x){ }\n}\nclass Wolf extends Animal implements Carnivore<Sheep> {\n    public void munch(Sheep x) { }\n}','Sheep does not compile,\n\n	Sheep is not abstract and does not override abstract method munch(Plant) in Hungry','Generics',1,NULL),(1672,'public class Hello<T> {\n  public static void main(String[] args){\n      Sheep bella = new Sheep();\n      \n      bella.munch(new Grass());\n      \n  }\n      \n}\n\ninterface Hungry<E> { void munch(E x); }\ninterface Carnivore<E extends Animal> extends Hungry<E> { }\ninterface Herbivore<E extends Plant> extends Hungry<E> { }\nabstract class Plant { }\nabstract class Animal { }\nclass Grass extends Plant { }\nclass Sheep extends Animal implements Herbivore<Plant> {\n    public void munch (Plant x){ }\n}\nclass Wolf extends Animal implements Carnivore<Sheep> {\n    public void munch(Sheep x) { }\n}','compiles and runs no problem','Generics',1,NULL),(1673,'public class Hello<T> {\n\n   public static void main(String[] args){\n\n    Dog d = new Dog();\n\n    ArrayList<? super Beagle> c = makeArrayList(d);\n\n    c.add(new Beagle());\n    c.add(new Beagle());\n    c.add(new Dog());    \n  } \n\n  public static <G extends Animal> ArrayList<G> makeArrayList(G g){\n    ArrayList<G> genlist = new ArrayList<>();\n    genlist.add(g);\n    return genlist;\n\n }\n}\n\n\nclass Animal{public void makeSound(){\n        System.out.println(\"Sound!\");\n }\n}   \n class Dog extends Animal{}\nclass Beagle extends Dog{}','The variable c of type ArrayList<? super Beagle> could possibly hold an instance of \nArrayList<Beagle>, ArrayList<Dog>, ArrayList<Animal>, or ArrayList<Object>.\n If it happened to be set to an ArrayList<Beagle>, it would violate the generic type to add a Dog to it.\n The compiler can\'t track what you actually assign to the ArrayList<? super Beagle> variable over the course of the program, \nso it assumes the worst and prevents the possible type safety violation. ','Generics',1,NULL),(1674,'Let\'s test your understanding of generics. Is the following code snippet legal?\n\nList<String> ls = new ArrayList<String>(); // 1\nList<Object> lo = ls; // 2 \n\nLine 1 is certainly legal. The trickier part of the question is line 2. This boils down to the question: is a List of String a List of Object. Most people instinctively answer, \"Sure!\"\n\nWell, take a look at the next few lines:\n\nlo.add(new Object()); // 3\nString s = ls.get(0); // 4: Attempts to assign an Object to a String!\n\nHere we\'ve aliased ls and lo. Accessing ls, a list of String, through the alias lo, we can insert arbitrary objects into it. As a result ls does not hold just Strings anymore, and when we try and get something out of it, we get a rude surprise.\n\nThe Java compiler will prevent this from happening of course. Line 2 will cause a compile time error.\n\nIn general, if Foo is a subtype (subclass or subinterface) of Bar, and G is some generic type declaration, it is not the case that G<Foo> is a subtype of G<Bar>. This is probably the hardest thing you need to learn about generics, because it goes against our deeply held intuitions.\n\nWe should not assume that collections don\'t change. Our instinct may lead us to think of these things as immutable.','For example, if the department of motor vehicles supplies a list of drivers to the census bureau, this seems reasonable. We think that a List<Driver> is a List<Person>, assuming that Driver is a subtype of Person. In fact, what is being passed is a copy of the registry of drivers. Otherwise, the census bureau could add new people who are not drivers into the list, corrupting the DMV\'s records.','Generics',1,NULL),(1675,'static void fromArrayToCollection(Object[] a, Collection<?> c) {\n    for (Object o : a) { \n        c.add(o); // compile-time error\n    }\n}\n\nfix this with a generic method....','static <T> void fromArrayToCollection(T[] a, Collection<T> c) {\n    for (T o : a) {\n        c.add(o); // Correct\n    }\n}','Generics',1,NULL),(1676,'\n\nNo, a List<Dog> is not a List<Animal>. Consider what you can do with a List<Animal> - you can add any animal to it... including a cat. Now, can you logically add a cat to a litter of puppies? Absolutely not.\n\n// Illegal code - because otherwise life would be Bad\nList<Dog> dogs = new ArrayList<Dog>(); // ArrayList implements List\nList<Animal> animals = dogs; // Awooga awooga\nanimals.add(new Cat());\nDog dog = dogs.get(0); // This should be safe, right?\n\nSuddenly you have a very confused cat.\n\nNow, you can\'t add a Cat to a List<? extends Animal> because you don\'t know it\'s a List<Cat>. \nYou can retrieve a value and know that it will be an Animal, but you can\'t add arbitrary animals. \nThe reverse is true for List<? super Animal> - in that case you can add an Animal to it safely, but you don\'t know anything about what might be retrieved from it, because it could be a List<Object>.\n','','Generics',1,NULL),(1677,'public class Hello<T> {\n  public static void main(String[] args){\n      Sheep bella = new Sheep();\n      \n  }\n      \n}\n\ninterface Hungry<E> { void munch(E x); }\ninterface Carnivore<E extends Animal> extends Hungry<E> { }\ninterface Herbivore<Plant> extends Hungry<Plant> { }\nabstract class Plant { }\nabstract class Animal { }\nclass Grass extends Plant { }\nclass Sheep extends Animal implements Herbivore<Grass> {\n    public void munch (Grass x){ }\n}\nclass Wolf extends Animal implements Carnivore<Sheep> {\n    public void munch(Sheep x) { }\n}','compiles fine...\n\nHerbivore<Plant> extends Hungry<Plant> works because the type is a parameter just like the formal \nparameters. So it is not necessary that a subinterface has the same parameters as long as its indicated that\nit does in fact take a type parameter. \n\nIn a nutshell, generics enable types (classes and interfaces) to be parameters when defining classes, interfaces and methods. Much like the more familiar formal parameters used in method declarations, type parameters provide a way for you to re-use the same code with different inputs. The difference is that the inputs to formal parameters are values, while the inputs to type parameters are types.\n\nits the same reason why List<E>, an interface, has to be the same as = new ArrayList<E> but not the \nsame as all other Lists\n\nList<String> list = new ArrayList<String>();\n	\n	ArrayList implements List just like Herbivore extends Hungry.','Generics',1,NULL),(1678,'Raw Types\n\nA raw type is the name of a generic class or interface without any type arguments. For example, given the generic Box class:\n\npublic class Box<T> {\n    public void set(T t) { /* ... */ }\n    // ...\n}\n\nTo create a parameterized type of Box<T>, you supply an actual type argument for the formal type parameter T:\n\nBox<Integer> intBox = new Box<>();\n\nIf the actual type argument is omitted, you create a raw type of Box<T>:\n\nBox rawBox = new Box();\n\nTherefore, Box is the raw type of the generic type Box<T>. However, a non-generic class or interface type is not a raw type.\n\nRaw types show up in legacy code because lots of API classes (such as the Collections classes) were not generic prior to JDK 5.0. When using raw types, you essentially get pre-generics behavior — a Box gives you Objects. For backward compatibility, assigning a parameterized type to its raw type is allowed:\n\nBox<String> stringBox = new Box<>();\nBox rawBox = stringBox;               // OK\n\nBut if you assign a raw type to a parameterized type, you get a warning:\n\nBox rawBox = new Box();           // rawBox is a raw type of Box<T>\nBox<Integer> intBox = rawBox;     // warning: unchecked conversion\n\nYou also get a warning if you use a raw type to invoke generic methods defined in the corresponding generic type:\n\nBox<String> stringBox = new Box<>();\nBox rawBox = stringBox;\nrawBox.set(8);  // warning: unchecked invocation to set(T)\n\nThe warning shows that raw types bypass generic type checks, deferring the catch of unsafe code to runtime. Therefore, you should avoid using raw types.','','Generics',1,NULL),(1679,'class Driver<E>{\n    \n}\nabstract class Auto{}\nclass Truck extends Auto{}\nclass Car extends Auto{}\n\npublic class Hello<T> {\n  public static void main(String[] args){\n      Driver<Truck> truckdriver = new Driver<>();\n      Driver untypeddriver = truckdriver;\n      \n      List biglist = new ArrayList<String>();\n      \n  }\n      \n}','compiles fine \n\ngeneric typed objects can be assigned to raw types.','Generics',1,NULL),(1680,'public class Hello<T> {\n  public static void main(String[] args){\n      \n      List biglist = new ArrayList<String>();\n      \n      biglist.add(8);\n      biglist.add(\"bigdick\");\n      \n  }\n      \n}','compiles fine, raw type reerences that are assinged to typed objects still take objects.','Generics',1,NULL),(1681,'public class Hello<T> {\n  public static void main(String[] args){\n      Driver<Truck> truckdriver = new Driver<>();\n      Driver untypeddriver = truckdriver;\n      \n      List biglist = new ArrayList<Driver<Truck>>();\n      \n      biglist.add(8);\n      biglist.add(\"bigdick\");\n      \n  }\n      \n}','compiles fine,  but you can still add anything to biglist','Generics',1,NULL),(1682,'public class Hello {\n  public static void main(String[] args){\n      Driver<Truck> truckdriver = new Driver();\n      \n      testmethod(new Driver<Truck>());   \n  }\n  \n  public static void testmethod(Object x){\n      // do something\n  }\n      \n}','fine','Generics',1,NULL),(1683,'Generic Classes and Subtyping',' You can subtype a generic class or interface by extending or implementing it. The relationship between the type parameters of one class or interface and the type parameters of another are determined by the extends and implements clauses.\n\nUsing the Collections classes as an example, ArrayList<E> implements List<E>, and List<E> extends Collection<E>. So ArrayList<String> is a subtype of List<String>, which is a subtype of Collection<String>. So long as you do not vary the type argument, the subtyping relationship is preserved between the types.\ndiagram showing a sample collections hierarchy: ArrayList<String> is a subtype of List<String>, which is a subtype of Collection<String>.\nA sample Collections hierarchy\n\nNow imagine we want to define our own list interface, PayloadList, that associates an optional value of generic type P with each element. Its declaration might look like:\n\ninterface PayloadList<E,P> extends List<E> {\n  void setPayload(int index, P val);\n  ...\n}\n\nThe following parameterizations of PayloadList are subtypes of List<String>:\n\n    PayloadList<String,String>\n    PayloadList<String,Integer>\n    PayloadList<String,Exception>\n','Generics',1,NULL),(1684,'Generics, Inheritance, and Subtypes',' As you already know, it is possible to assign an object of one type to an object of another type provided that the types are compatible. For example, you can assign an Integer to an Object, since Object is one of Integer\'s supertypes:\n\nObject someObject = new Object();\nInteger someInteger = new Integer(10);\nsomeObject = someInteger;   // OK\n\nIn object-oriented terminology, this is called an \"is a\" relationship. Since an Integer is a kind of Object, the assignment is allowed. But Integer is also a kind of Number, so the following code is valid as well:\n\npublic void someMethod(Number n) { /* ... */ }\n\nsomeMethod(new Integer(10));   // OK\nsomeMethod(new Double(10.1));   // OK\n\nThe same is also true with generics. You can perform a generic type invocation, passing Number as its type argument, and any subsequent invocation of add will be allowed if the argument is compatible with Number:\n\nBox<Number> box = new Box<Number>();\nbox.add(new Integer(10));   // OK\nbox.add(new Double(10.1));  // OK\n\nNow consider the following method:\n\npublic void boxTest(Box<Number> n) { /* ... */ }\n\nWhat type of argument does it accept? By looking at its signature, you can see that it accepts a single argument whose type is Box<Number>. But what does that mean? Are you allowed to pass in Box<Integer> or Box<Double>, as you might expect? The answer is \"no\", because Box<Integer> and Box<Double> are not subtypes of Box<Number>.\n\nThis is a common misunderstanding when it comes to programming with generics, but it is an important concept to learn.\ndiagram showing that Box<Integer> is not a subtype of Box<Number>\nBox<Integer> is not a subtype of Box<Number> even though Integer is a subtype of Number.\nNote: Given two concrete types A and B (for example, Number and Integer), MyClass<A> has no relationship to MyClass<B>, regardless of whether or not A and B are related. The common parent of MyClass<A> and MyClass<B> is Object.','Generics',1,NULL),(1685,'List<? extends Integer> intList = new ArrayList<>();\nList<? extends Number>  numList = intList;  // OK. List<? extends Integer> is a subtype of List<? extends Number>','','Generics',1,NULL),(1686,'interface Hungry<E> { void munch(E x); }\ninterface Carnivore<E extends Animal> extends Hungry<E> { }\n\ninterface Herbivore<Plant> extends Hungry<Plant> { }\n\n\ninterface Pineavore<Pine> extends Herbivore<Plant> { }\n\n\n\nclass Panda implements Herbivore<Pine>{  \n    void munch(Pine x){\n            System.out.println(\"eat pines\");\n    };\n} \nclass Chamelion implements Herbivore<Flowers>{ \n    public void munch(Flowers x){ } \n}','compilation fails,\n\ninterface methods are implicityl public abstract so when you overid them like munch in Panda you have to say\npublic . ','Generics',1,NULL),(1687,'interface Hungry<E> { void munch(E x); }\n\nclass Driver<E> implements Hungry<T>{\n    public void munch(T food){\n        \n    }\n    \n}','will not compile, when you implement a generic interface, you must provide a type similarly you cannot say\nnew Thing<E>();','Generics',1,NULL),(1688,'interface Hungry<E> { void munch(E x); }\n\ninterface Herbivore<Grass> extends Hungry<Plant> { }\n\nclass Panda implements Herbivore<Grass>{  \n        public void munch(Grass x){\n            System.out.println(\"eat pines\");\n    };\n} \n\nabstract class Animal { }\nabstract class Plant { }\nclass Grass extends Plant { }','Panda does not compile \n\ndoes not override abstract method munch(Plant) in class Hungry.\n\n	','Generics',1,NULL),(1689,'Which collection class allows you to grow or shrink its size and provide indexed access to its elements,\nbut whose methods are not synhcronized ?','ArrayList','Generics',1,NULL),(1690,'public static <E extends Number> List<E> process(List<E> nums)\n\n// declare input and output\n\noutput = process(input);\n\n','1 ArrayList<Integer> input = null;\n   List<Integer> output = null;\n\n2 List<Number> input = null;\n    List<Number> output = null\n\n3  List<Integer> input = null\n   List<Integer> output = null;\n\n\nThe return type is List so the output has to be a list it cant be arraylist. \nwhatever the input is thats what the output will be so input and output have to be the same type\nand the type has to be something that extends Number','Generics',1,NULL),(1691,'public class Hello {\n  public static void main(String[] args){\n      PriorityQueue<String> pq = new PriorityQueue<String>();\n      pq.add(\"2\");\n      pq.add(\"4\");\n      System.out.println(pq.peek());\n      pq.offer(\"1\");\n      pq.add(\"3\");\n      pq.remove(\"1\");\n      System.out.println(pq.poll());\n      if(pq.remove(\"2\")) System.out.println(pq.poll());\n      System.out.println(pq.poll() + \" \" + pq.peek());\n  }\n   \n}','2\n2\n3 4\n\nfor the sake of the exam add and offer both add to naturally sorted collections \nso here the order becomes the natural order. \n\neven strings get sorted numerically.\n\n','Generics',1,NULL),(1692,'public class Hello {\n  public static void main(String[] args){\n      PriorityQueue<String> pq = new PriorityQueue<String>();\n      pq.add(\"2\");\n      pq.add(\"4\");\n\n      pq.offer(\"1\");\n      pq.add(\"3\");\n      \n      pq.add(\"2\");\n      pq.offer(\"5\");\n      \n      pq.add(\"67\");\n      pq.add(\"7\");\n      \n      for(String x : pq)\n          System.out.print(x+\" \");\n      \n      System.out.println(\"\");\n      \n      for(int x = 0; x <8; x++)\n          System.out.print(pq.poll()+\" \");\n\n  }\n   \n}','1 2 2 4 3 5 67 7 \n1 2 2 3 4 5 67 7\n\nString only looks at the first charater so 67 is the same as 6','Generics',1,NULL),(1693,'public class Hello {\n  public static void main(String[] args){\n      LinkedHashSet<Turtle> t = new LinkedHashSet<>();\n      t.add(new Turtle(1)); t.add( new Turtle(2)); t.add(new Turtle(1));\n      t.add(new Turtle(1)); t.add( new Turtle(2)); t.add(new Turtle(1));\n      t.add(new Turtle(1)); t.add(new Turtle(1)); t.add(new Turtle(1));\n      t.add(new Turtle(1)); t.add(new Turtle(1)); t.add(new Turtle(1));\n      \n      System.out.println(t.size());\n\n  }\n   \n}\n\ninterface Hungry<E> { void munch(E x); }\nabstract class Animal { }\nabstract class Plant { }\nclass Grass extends Plant { }\n\nclass Turtle {\n    int size;\n    public Turtle(int z){\n        size = z;\n    }\n    \n    public boolean equals(Object o){\n        return (this.size == ((Turtle)o).size);\n    }\n    \n    public int hashCode() { return size/5; }\n}','2\n\nthe size is two when hashCode is implementd this imp. will place all turtles with size 1 in the same bucket\n\nsize() counts the buckets.\n\nif hashCode was not implemented then every entry would go into its own bucket and the size would be\n12\n\n','Generics',1,NULL),(1694,'class Grass extends Plant { }\n\npublic class Hello {\n  public static void main(String[] args){\n     TreeSet<Grass> grassset = new TreeSet<>();\n     grassset.add(new Grass());\n\n  }\n   \n}','classcastexception','Generics',1,NULL),(1695,'public class GeoCache {\n	public static void main(String[ ]args) {\n		String[] s = {\"map\",\"pen\",\"marble\",\"key\"};\n		Othello o = new Othello();\n		Arrays.sort(s,o);\n		for(String s2: s) sout(s2+\" \");\n		sout( Arrays.binarySearch(s,\"map\");\n	}\n\n	static class Othello implements Comparator<String> {\n		public int compare(String a, String b) { return b.compareTo(a);l }\n	}\n}\n		','The output will contain a -1\n\n\"pen marble map key\" \n\n.binarySearch has to be invoked with the same Comparator that created it. \n	here it doesn\'t know how the array is sorted so it gives insertion point','Collections',1,NULL),(1696,'public class ArrayList<E> extends AbstractList<E>\n         implements List<E>, RandomAccess, Cloneable, java.io.Serializable {\n    ...\n    public Iterator<E> iterator() {\n         return new Itr();\n    }\n\n    private class Itr implements Iterator<E> {\n    ...\n    }\n\n    public ListIterator<E> listIterator() {\n         return new ListItr(0);\n    }\n\n    private class ListItr extends Itr implements ListIterator<E> {\n    ...\n    }\n}','One good usage of inner classes that comes into my mind is in java.util.ArrayList that hides its iterators implementations into private inner classes. You can\'t create them except by invoking iterator() or listIterator() on the list object.\n\nThis way the Iterator and ListIterator implementations for ArrayList are grouped with their related class and methods for enhanced readability (the implementations are pretty short), but hidden from others.\n\nThey can\'t be declared static as they need access to their enclosing instance object.','General',1,NULL),(1697,'public class Hello {\n    private int secretnum = 7;\n    \n  public static void main(String[] args){\n     Hello h = new Hello();\n     h.createInner();\n\n  }\n  \n  public void createInner(){\n      Hello.Inner a = new Hello.Inner();\n      a.foo(); a.seeOuter();\n  }\n  \n  \n  class Inner {\n      public void seeOuter(){\n          System.out.println(secretnum);\n      }\n      \n      void foo(){\n          System.out.println(\"Foo\");\n      }\n  }\n   \n}','foo 7\n\ncompiles fine, you need the outer classes reference for a regular inner class\n\nthe inner class can be created as such from within the enclosing class. \n\ncould also be Inner a = new Inner();','Inner Classes',1,NULL),(1698,'public class Hello {\n    private int secretnum = 7;\n    \n  public static void main(String[] args){\n     Hello h = new Hello();\n     h.createInner();\n\n  }\n  \n  public void createInner(){\n      Hello.Inner a = new Hello.Inner();\n      a.foo(); a.seeOuter();\n  }\n  \n  \n  class Inner {\n      private static int verysecret = 8;\n      \n      public void seeOuter(){\n          System.out.println(secretnum);\n      }\n      \n      void foo(){\n          System.out.println(\"Foo\");\n      }\n  }','WNC,\n\nNo static declarations are allowed in regular inner classes unless they \nare final.\n\nThe creation of a is legal though redundant, it could have been:\n\n	Inner a = new Inner();\n','Inner Classes',1,NULL),(1699,'public class Hello {\n    private int secretnum = 7;\n    \n  public static void main(String[] args){\n     Hello h = new Hello();\n     h.createInner();\n\n  }\n  \n  public void createInner(){\n      Hello.Inner a = new Hello.Inner();\n      a.foo(); a.seeOuter();\n  }\n  \n  \n  class Inner {\n      private static final int verysecret = 8;\n      \n      public void seeOuter(){\n          System.out.println(secretnum);\n      }\n      \n      void foo(){\n          System.out.println(\"Foo\");\n      }\n  }\n   \n}','compiles fine, if an inner class is going to have static member it has to be final','Inner Classes',1,NULL),(1700,'public class sequence {\n	psvm(sa){\n		ArrayList<String> list = new ArrayList<>();\n		list.add(\"apple\");\n		list.add(\"organe\");\n		list.add(\"plum\");\n		list.add(1,\"carrot\");\n		sout( list );\n	}\n}','apple carrot orange plum\n\nwith arraylist you can add(int index, object elemetn) to a specific index','Collections',1,NULL),(1701,'public class Hello {\n    private int secretnum = 7;\n    \n    public static void main(String[] args){\n        Inner in = new Inner();\n\n    }\n  \n     class Inner {\n        private static final int verysecret = 8;\n        void foo(){\n          System.out.println(\"Foo\");\n        } \n  }\n   \n}','will not compile,\n\ninner classes are the same as class instance variables so naturally you cannot access \nthem from a static context. ','Inner Classes',1,NULL),(1702,'public class Hello {\n    private int secretnum = 7;\n    \n    public static void main(String[] args){\n        Hello h = new Hello();\n        Hello.Inner in = h.new Inner();\n\n    }\n  \n     class Inner {\n        private static final int verysecret = 8;\n        void foo(){\n          System.out.println(\"Foo\");\n        } \n  }\n   \n}','compiles fine','Inner Classes',1,NULL),(1703,'public class Hello {\n    private int secretnum = 7;\n    private static Inner inner;\n    \n    public static void main(String[] args){\n        Hello h = new Hello();\n        Hello.Inner in = h.new Inner();\n        \n        Hello.Inner in2 = h.new Inner();\n        \n        Hello.Inner in3 = new Hello().new Inner();\n        \n        inner = h.new Inner();\n        \n        //Inner a = new Inner(); this would not work\n        \n\n    }\n    \n    public void instancemaker(){\n        Inner a = new Inner();\n        System.out.println(a.verysecret);\n    }\n  \n     class Inner {\n        private static final int verysecret = 8;\n        \n        public void Inner(int x){\n            \n        }\n        void foo(){\n          System.out.println(\"Foo\");\n        } \n  }\n   \n}','When instantiating from a static method You have to provide the Outer class name\n\nthe inner class is just a like an instance member. \n\nbut in the instance method its easy to create the inner class normally. \n\nits the same to create a new inner class in the static method as it is from another class.\n\n\nThis was one is also confusing because it has a mistakenly named method \nthat looks like a constructor. But its not. ','Inner Classes',1,NULL),(1704,'public class Hello {\n    private int secretnum = 7;\n    public static void main(String[] args) {}\n    class Inner {  private static final int verysecret = 8; }\n}\n\nclass Dog extends Hello.Inner {}\n\nchange this code so it compiles, and creates a class that extends Hello.Inner','public class Hello {\n    private int secretnum = 7;\n    public static void main(String[] args) {}\n    class Inner {  private static final int verysecret = 8; }\n}\n\nclass Dog extends Hello { class Innerdog extends Inner{ } }','Inner Classes',1,NULL),(1705,'public class Hello {\n    private int secretnum = 7;\n    public static void main(String[] args) {}\n    class Inner {  private static final int verysecret = 8; }\n}\n\nclass Dog extends Hello{ class Inner extends Inner { } }\n\nthis is illegal what could make it legal ?','class Dog extends Hello{ class Inner extends Hello.Inner { } }','Inner Classes',1,NULL),(1706,'public Iterator<String> iterator() {\n    return new Iterator<String>() {\n\n      private int index;\n\n      public boolean hasNext() {\n        return index < size();\n      }\n\n      public String next() {\n\n        if (hasNext()) {\n          return getToken(index++);\n        }\n        else {\n          throw new NoSuchElementException();\n        }\n      }\n\n      public void remove() {\n        throw new UnsupportedOperationException();\n      }\n\n    };\n  }','good example of an anonymous inner class from opennlp','Inner Classes',1,NULL),(1707,'public Iterator<String> iterator() {\n    return new Iterator<String>() {\n\n      private int index;\n\n      public boolean hasNext() {\n        return index < size();\n      }\n\n      public String next() {\n\n        if (hasNext()) {\n          return getToken(index++);\n        }\n        else {\n          throw new NoSuchElementException();\n        }\n      }\n\n      public void remove() {\n        throw new UnsupportedOperationException();\n      }\n\n    };\n  }','good example of anonymous inner class','Inner Classes',1,NULL),(1708,'public static Dictionary parseOneEntryPerLine(Reader in) throws IOException {\n    BufferedReader lineReader = new BufferedReader(in);\n\n    Dictionary dictionary = new Dictionary();\n\n    String line;\n\n    while ((line = lineReader.readLine()) != null) {\n      StringTokenizer whiteSpaceTokenizer = new StringTokenizer(line, \" \");\n\n      String[] tokens = new String[whiteSpaceTokenizer.countTokens()];\n\n      if (tokens.length > 0) {\n        int tokenIndex = 0;\n        while (whiteSpaceTokenizer.hasMoreTokens()) {\n          tokens[tokenIndex++] = whiteSpaceTokenizer.nextToken();\n        }\n\n        dictionary.put(new StringList(tokens));\n      }\n    }\n\n    return dictionary;\n  }','fine\ngood example of;\nStringTokenizer\nBufferedReader\n\n','General',1,NULL),(1709,'public static Dictionary parseOneEntryPerLine(Reader in)  {\n    BufferedReader lineReader = new BufferedReader(in);\n\n    Dictionary dictionary = new Dictionary();\n\n    String line;\n\n    while ((line = lineReader.readLine()) != null) {\n      StringTokenizer whiteSpaceTokenizer = new StringTokenizer(line, \" \");\n\n      String[] tokens = new String[whiteSpaceTokenizer.countTokens()];\n\n      if (tokens.length > 0) {\n        int tokenIndex = 0;\n        while (whiteSpaceTokenizer.hasMoreTokens()) {\n          tokens[tokenIndex++] = whiteSpaceTokenizer.nextToken();\n        }\n\n        dictionary.put(new StringList(tokens));\n      }\n    }\n\n    return dictionary;\n  }','will not compile \nreadLine() method throws IOException\n\nmust be caught or thrown!','Input/Output',1,NULL),(1710,'public class Hello {\n    private int secretnum = 7;\n    public static void main(String[] args) {\n        Map<Integer,String> hellomap = new HashMap();\n        hellomap.put(1,\"Bell\");\n        hellomap.put(3,\"Whistle\");\n        hellomap.put(5,\"Nic\");\n        \n        for(Entry<Integer,String> x : hellomap.entrySet()){\n            System.out.println(x);\n        }\n    \n    }\n    public class Inner {  private static final int verysecret = 8; }\n}','1=Bell\n3=Whistle\n5=Nic\n\ninner classes can have static members only if they are final','Inner Classes',1,NULL);
INSERT INTO `FlashCards` VALUES (1711,'public class Hello {\n    private final static int SIZE = 25;\n    private int[] array = new int[SIZE];\n    \n    public Hello(){\n        for(int i = 0; i<SIZE; i++){\n            array[i] = i;\n        }\n    }\n    \n    public void printEven(){\n        \n    }\n    \n    interface DSIterator extends java.util.Iterator<Integer> { }\n    \n    private class EvenIterator implements DSIterator{\n        \n    }\n    \n\n    public static void main(String[] args) {\n\n    \n    }\n\n}','EvenIterator will not compile is not abstract and does not impelemnt next() in Iterator()\n\nThis shows that since DSIterator extends Iterator the first concrete class has to be the one to \nimplement the interfaces methods. ','General',1,NULL),(1712,'public class Hello {\n    private final static int SIZE = 100;\n    private int[] array = new int[SIZE];\n    \n    public Hello(){\n        for(int i = 0; i<SIZE; i++){\n            array[i] = i;\n        }\n    }\n    \n    public void print(){\n        ThirdIterator it = new ThirdIterator();\n        while(it.hasNext()){\n            System.out.print(it.next() +\" \");\n        }\n        \n    }\n    \n    interface DSIterator extends java.util.Iterator<Integer> { }\n    \n    private class ThirdIterator implements DSIterator{\n        private int nextIndex = 0;\n        \n        public boolean hasNext(){\n            return (nextIndex <= SIZE - 1);\n        }\n        \n        public Integer next(){\n            Integer retValue = Integer.valueOf(array[nextIndex]);\n            \n            nextIndex += 3;\n            return retValue;\n            \n        }\n        \n    }\n    \n\n    public static void main(String[] args) {\n        print();\n    \n    }\n\n}','will not compile print() cannot be called from a static context.','General',1,NULL),(1713,'public class Hello {\n    private final static int SIZE = 100;\n    private int[] array = new int[SIZE];\n    \n    public Hello(){\n        for(int i = 0; i<SIZE; i++){\n            array[i] = i;\n        }\n    }\n    \n    public void print(){\n        ThirdIterator it = new ThirdIterator();\n        while(it.hasNext()){\n            Object i = it.next();\n            //System.out.print(it.next() +\" \");\n        }\n        \n    }\n    \n    interface DSIterator extends java.util.Iterator { }\n    \n    private class ThirdIterator implements DSIterator{\n        private int nextIndex = 0;\n        \n        public boolean hasNext(){\n            return (nextIndex <= SIZE - 1);\n        }\n        \n        public Integer next(){\n            Integer retValue = Integer.valueOf(array[nextIndex]);\n            \n            nextIndex += 3;\n            return retValue;\n            \n        }\n        \n    }\n    \n\n    public static void main(String[] args) {\n        Hello h = new Hello();\n        h.print();\n    \n    }\n\n}','0 3 6 9 12 15 18 21 24 27 30 33 36 39 42 45 48 51 54 57 60 63 66 69 72 75 78 81 84 87 90 93 96 99','General',1,NULL),(1714,'public class Hello {\n    private final static int SIZE;\n    private int[] array;\n    \n    public Hello(int size){\n        this.SIZE = size;\n        \n        array = new int[SIZE];\n        \n        for(int i = 0; i<SIZE; i++){\n            array[i] = i;\n        }\n    }\n}','if a final variable is static it has be intitialized right away.\n\nWhere a final instance varialbe must be intitialized at some point either in the constructor or upon creation.\n\n','General',1,NULL),(1715,'public class Hello {\n    private final int SIZE;\n    private int[] array;\n    \n    public void print(){\n        ThirdIterator it = new ThirdIterator();\n        while(it.hasNext()){\n            Integer i = it.next();\n            //System.out.print(it.next() +\" \");\n        }\n        \n    }\n\n}','Will not compile \n\nfinal variable SIZE is never initialized in default constructor or otherwise and this is a compilererror','General',1,NULL),(1716,'public class Hello {\n    private final int SIZE;\n    private int[] array;\n    \n    interface DSIterator extends java.util.Iterator<Integer> { }\n    \n    private class ThirdIterator implements DSIterator{\n        private int nextIndex = 0;\n        public ThirdIterator(){\n            SIZE = 100;\n            for(int ix=0; ix<SIZE; ix++){\n                array[ix] = ix;\n            }\n        }\n        \n        public boolean hasNext(){\n            return (nextIndex <= SIZE - 1);\n        }\n        \n        public Integer next(){\n            Integer retValue = Integer.valueOf(array[nextIndex]);\n            \n            nextIndex += 3;\n            return retValue;\n            \n        }\n        \n    }\n    \n    private static class EveryFourth implements DSIterator{\n        private int nextIndex = 0;\n        private static final int SIZE = 1000;\n        private int[] array = new int[SIZE];\n        \n        public EveryFourth(){\n           for(int i =0; i<100; i++){\n               array[i] = i;\n           }\n        }\n        \n        public boolean hasNext(){\n            return (nextIndex <= SIZE-1);\n        }\n        \n        public Integer next() {\n            Integer retValue = Integer.valueOf(array[nextIndex]);\n            \n            nextIndex += 4;\n            return retValue;\n        }\n    }\n    \n\n    public static void main(String[] args) {\n        EveryFourth a = new EveryFourth();\n        ThirdIterator b = new ThirdIterator();\n        \n    \n    }\n\n}\n\nThere multiple problems here','final Variable SIZE in Hello is not intitialized in constructor \n\ncannot assign a value to final variable SIZE in innerclass ThirdIterator\n\nnon static third iterator class cannot be referenced from static main.\n\n','Inner Classes',1,NULL),(1717,'public class Hello {\n    private final int SIZE;\n    private int[] array;\n    \n    public Hello(){\n        ThirdIterator x = new ThirdIterator();\n    }\n    \n    interface DSIterator extends java.util.Iterator<Integer> { }\n    \n    private class ThirdIterator implements DSIterator{\n        private int nextIndex = 0;\n        public ThirdIterator(){\n            SIZE = 100;\n            for(int ix=0; ix<SIZE; ix++){\n                array[ix] = ix;\n            }\n        }\n......\n.........','you cant do this either\nfinal variable SIZE is not instantiated on creation or in the \nconstructor. Even though it is in the ThirdIterator class\nconstructor. that does not work. ','Inner Classes',1,NULL),(1718,'public class Hello {\n    private final int SIZE = 100;\n    private int[] array;\n\n    interface DSIterator extends java.util.Iterator<Integer> { }\n    \n    private class ThirdIterator implements DSIterator{\n        private int nextIndex = 0;\n        public ThirdIterator(){\n            for(int ix=0; ix<SIZE; ix++){\n                array[ix] = ix;\n            }\n        }  \n        public boolean hasNext(){\n            return (nextIndex <= SIZE - 1);\n        }\n        public Integer next(){\n            Integer retValue = Integer.valueOf(array[nextIndex]); \n            nextIndex += 3;\n            return retValue;    \n        }\n    }\n    private static class EveryFourth implements DSIterator{\n        private int nextIndex = 0;\n        private static final int SIZE = 1000;\n        private int[] array = new int[SIZE];\n        public EveryFourth(){\n           for(int i =0; i<100; i++){\n               array[i] = i;\n           }\n        }\n        public boolean hasNext(){\n            return (nextIndex <= SIZE-1);\n        }\n        \n        public Integer next() {\n            Integer retValue = Integer.valueOf(array[nextIndex]);\n            \n            nextIndex += 4;\n            return retValue;\n        }\n    }\n    public static void main(String[] args) {\n        EveryFourth a = new EveryFourth();\n        Hello.ThirdIterator b = new Hello().new ThirdIterator();\n    }\n\n}','compiles fine','Inner Classes',1,NULL),(1719,'public class Hello {\n    private final int SIZE = 100;\n    private int[] array;\n\n    \n    static interface DSIterator extends java.util.Iterator<Integer> { }\n    \n    private class ThirdIterator implements DSIterator{\n        private int nextIndex = 0;\n        public ThirdIterator(){\n            for(int ix=0; ix<SIZE; ix++){\n                array[ix] = ix;\n            }\n        }\n        \n        public boolean hasNext(){\n            return (nextIndex <= SIZE - 1);\n        }\n        \n     ......','A nested interface declared static is redundant. A nested interface is automatically static. \nstatic can be removed without and affect on semantics. Similar to public on interface methods \nor public final on interface fields. \n\nIt doen\'t change the fact that code without access to Foo wont have access to Foo.Bar interface.\n\nIt is acceptable to use if you excpect it only to be used from the enclosing class\n\npublic class Foo {\n	public interface Bar {\n		void callback();\n	}\n	public static void registerCallback(Bar bar){...}\n}\n//elsewhere\nFoo.registerCallback(new Foo.Bar() {\n	public void callback() {...}\n});','Inner Classes',1,NULL),(1720,'public class Hello {\n    private final int SIZE = 100;\n    private int[] array;\n\n    \n    interface DSIterator extends java.util.Iterator<Integer> { }\n    \n    interface Petable {\n        void speak();\n        void wag();\n    }\n    \n    private class ThirdIterator implements DSIterator{\n        private int nextIndex = 0;\n        public ThirdIterator(){\n            for(int ix=0; ix<SIZE; ix++){\n                array[ix] = ix;\n            }\n        }\n        \n        public boolean hasNext(){\n            return (nextIndex <= SIZE - 1);\n        }\n        \n        public Integer next(){\n            Integer retValue = Integer.valueOf(array[nextIndex]);\n            \n            nextIndex += 3;\n            return retValue;\n            \n        }\n        \n    }\n    \n    private static class EveryFourth implements DSIterator{\n        private int nextIndex = 0;\n        private static final int SIZE = 1000;\n        private int[] array = new int[SIZE];\n        \n        public EveryFourth(){\n           for(int i =0; i<100; i++){\n               array[i] = i;\n           }\n        }\n        \n        public boolean hasNext(){\n            return (nextIndex <= SIZE-1);\n        }\n        \n        public Integer next() {\n            Integer retValue = Integer.valueOf(array[nextIndex]);\n            \n            nextIndex += 4;\n            return retValue;\n        }\n    }\n    \n\n    public static void main(String[] args) {\n        \n        EveryFourth a = new EveryFourth();\n        Hello.ThirdIterator b = new Hello().new ThirdIterator();\n        \n    \n    }\n\n}\n\nclass Dog implements Petable {\n    \n    public void bark(){\n        \n    }\n\n    @Override\n    public void speak() {\n        throw new UnsupportedOperationException(\"Not supported yet.\"); //To change body of generated methods, choose Tools | Templates.\n    }\n\n    @Override\n    public void wag() {\n        throw new UnsupportedOperationException(\"Not supported yet.\"); //To change body of generated methods, choose Tools | Templates.\n    }\n    \n}','does not compile without outer reference for inner interface.\n\nshould be:\n\n	class Dog implements Hello.Petable {\n    \n ','Inner Classes',1,NULL),(1721,'class MyOuter{\n	private int x = 7;\n\n	class MyInner{\n	public void seeOuter(){\n		sout( x );\n	}\n\n}\n\nclass OCP{\n	public static void main(SA){\n		MyOuter mo = new MyOuter();\n		MYOuter.MyInner inner = mo.new MyInner();\n		inner.seeOuter();\n	}\n}','how to instantiate an inner class object from outside the outter class instance code.','Inner Classes',1,NULL),(1722,'psvm(SA){\n	MyOuter.MyInner inner = new MyOuter().new MyInner();\n	inner.seeOuter();\n}','one liner','Inner Classes',1,NULL),(1723,'class MyOuter{\n    private int x = 7;\n    public void makeInner() {\n        MyInner in = new MyInner();\n       in.seeOuter();\n   }\n\n    class MyInner {	\n           public void seeOuter {\n	sout( \"Outer x is \" + x );\n	sout(\"Inner class ref is \" + this);\n	sout( \"Outer class ref is \" + MyOuter.this );\n            }\n}\n\n      psvm(sa) {\n	MyOuter.MyInner inner = new MyOuter().new MyInner();\n	inner.seeOuter();\n     }\n}\n		','\n	The rules for an inner class to reference itself or the outer class instance are as follows:\n\n	To reference the inner class instance itself from within the inner class code,\n		use this\n\n	toreference the \"outer this\" from within the inner class code,\n		use MyOuter.this.','Inner Classes',1,NULL),(1724,'what member modifiers can be applied to an inner class	','final\nabstract\npublic \nprivate\nprotected\nstatic\nstrictfp','Inner Classes',1,NULL),(1725,'class MyOuter2 {\n	private String x = \"Outer2\";\n	void doStuff() {\n	        class MyInner {\n		public void seeOuter() {\n	                               sout(\" outer x is \" + x );\n		}\n	        }\n	\n	MyInner mi = new MyInner(); // THIS LINE MUST COME AFTER THE CLASS\n\n	mi.seeOuter();\n	}\n}\n\n	','How to properly use a method local inner class','Inner Classes',1,NULL),(1726,'public class Hello {\n   \n    public static void main(String[] args) {\n        Hello h = new Hello();\n        h.methodlocal();\n    }\n    \n    public void methodlocal(){\n        \n        class WayInner {\n            private int size;\n        \n            public WayInner(int x){ size = x;}\n            public void printDetail(){\n                System.out.println(\"WayInner: \"+ size);\n            }\n        }\n        \n        WayInner a = new WayInner(7);\n        a.printDetail();\n    }\n\n}','WayInner: 7\n\nthe proper way to use a method local inner ','Inner Classes',1,NULL),(1727,'public class Hello {\n   \n    public static void main(String[] args) {\n        Hello h = new Hello();\n        h.methodlocal();\n    }\n    \n    public void methodlocal(){\n        int y = 56;\n        \n        class WayInner {\n            public int size;\n        \n            public WayInner(int x){ size = x;}\n            public void printDetail(){\n                System.out.println(\"WayInner: \"+ size);\n            }\n            \n            public void showall(){\n                System.out.println(size+\" \"+y);\n            }\n        }\n        \n        WayInner a = new WayInner(7);\n        a.printDetail();\n        a.showall();\n        \n    }\n\n}','will not compile in java 7. \n\nlocal varialbe cannot be accesed from within inner class. \n\nLocal varialbe exist on the stack and only exist for the lifetime of the method. \n\nwhen the method ends the local varialbes are destroyed, however the inner class object might still live on\n ','Inner Classes',1,NULL),(1728,'public class Hello {\n   \n    public static void main(String[] args) {\n        Hello h = new Hello();\n        h.methodlocal();\n    }\n    \n    public void methodlocal(){\n        final int y = 56;\n        \n        class Zombie {\n            public int size;\n        \n            public Zombie(int x){ size = x;}\n            public void mone(){\n                System.out.println(\"ughhhg: \"+ size);\n            }\n            \n            public void accessTheLiving(){\n                System.out.println(\"local var: \"+y);\n            }\n            \n        }\n        \n        Zombie zom = new Zombie(7);\n        \n    }\n\n}','will compile method local inner class can only access local variables if they are marked final.','Inner Classes',1,NULL),(1729,'public class Hello {\n   \n    public static void main(String[] args) {\n        Hello h = new Hello();\n        h.methodlocal();\n    }\n    \n    public void methodlocal(){\n        final int y = 56;\n        \n        protected class Zombie {\n            public int size;\n        \n            public Zombie(int x){ size = x;}\n            public void mone(){\n                System.out.println(\"ughhhg: \"+ size);\n            }\n            \n            public void accessTheLiving(){\n                System.out.println(\"local var: \"+y);\n            }\n            \n        }\n        \n        Zombie zom = new Zombie(7);\n        \n    }\n\n}','will not compile method local inner classes cannot be marked public private protected static or transient.','Inner Classes',1,NULL),(1730,'public class Hello {\n   \n    public static void main(String[] args) {\n        Hello h = new Hello();\n        h.methodlocal();\n    }\n    \n    public void methodlocal(){\n        final int y = 56;\n        \n        static class Zombie {\n            public int size;\n        \n            public Zombie(int x){ size = x;}\n            public void mone(){\n                System.out.println(\"ughhhg: \"+ size);\n            }\n            \n            public void accessTheLiving(){\n                System.out.println(\"local var: \"+y);\n            }\n            \n        }\n        \n        Zombie zom = new Zombie(7);\n        \n    }\n\n}','will not compile ML inner class cannot be marked static. ','Inner Classes',1,NULL),(1731,'public class Hello {\n   \n    public static void main(String[] args) {\n        Hello h = new Hello();\n        h.methodlocal();\n    }\n    \n    public void methodlocal(){\n        final int y = 56;\n        \n        class Zombie {\n            public int size;\n        \n            public Zombie(int x){ size = x;}\n            public static void mone(){\n                System.out.println(\"ughhhg: \"+ size);\n            }\n            \n            public void accessTheLiving(){\n                System.out.println(\"local var: \"+y);\n            }\n            \n        }\n        \n        Zombie zom = new Zombie(7);\n        \n    }\n\n}','will not compile \n\nillegal static declaration in method local inner class. ','Inner Classes',1,NULL),(1732,'public class Hello {\n   \n    public static void main(String[] args) {\n        Hello h = new Hello();\n        h.methodlocal();\n    }\n    \n    public void methodlocal(){\n        final int y = 56;\n        \n        \n        class Zombie {\n            public int size;\n            public static int num = 5;\n        \n            public Zombie(int x){ size = x;}\n            public void mone(){\n                System.out.println(\"ughhhg: \"+ size);\n            }\n            \n            public void accessTheLiving(){\n                System.out.println(\"local var: \"+y);\n            }\n            \n        }\n        \n        Zombie zom = new Zombie(7);\n        \n    }\n\n}','will not compile\n\nillegal modifier static is only allowed in constant decalartations. \n\nto compile make num final','Inner Classes',1,NULL),(1733,'public class Hello {\n   \n    public static void main(String[] args) {\n        Hello h = new Hello();\n        h.methodlocal();\n    }\n    \n    public void methodlocal(){\n        final int y = 56;\n        \n        \n        class Zombie {\n            public int size;\n            public static final int num = 5;\n        \n            public Zombie(int x){ size = x;}\n            public void mone(){\n                System.out.println(\"ughhhg: \"+ size);\n            }\n            \n            public void accessTheLiving(){\n                System.out.println(\"local var: \"+y);\n            }\n            \n        }\n        \n        Zombie zom = new Zombie(7);\n        \n    }\n\n}','compiles fine.\n\nto use static in an inner class it must be marked final','Inner Classes',1,NULL),(1734,'For inner classes \'static\' is only allowed for constant variable declarations. ','','Inner Classes',1,NULL),(1735,'public class Hello {\n   \n    public static void main(String[] args) {\n        Hello h = new Hello();\n        h.methodlocal();\n    }\n    \n    public static void methodlocal(){\n        final int y = 56;\n        \n        \n        class Zombie {\n            public int size;\n            public static final int num = 5;\n        \n            public Zombie(int x){ size = x;}\n            public static final void mone(){\n                System.out.println(\"ughhhg: \"+ size);\n            }\n            \n            public void accessTheLiving(){\n                System.out.println(\"local var: \"+y);\n            }\n            \n        }\n        \n        Zombie zom = new Zombie(7);\n        \n    }\n\n}','does not compile, \n\neven if the method is static ML innner class cannot decalre staic unless it is a static final constant. ','Inner Classes',1,NULL),(1736,'public class Hello {\n    private String name = \"marco\";\n    private final static String gem = \"Gemini\";\n    private static String west = \"Eunech\";\n   \n    public static void main(String[] args) {\n        Hello h = new Hello();\n        h.methodlocal();\n    }\n    \n    public static void methodlocal(){\n        final int y = 56;\n        //System.out.println(name); //wouldnt compile\n        System.out.println(gem);\n        \n        \n        class Zombie {\n            public int size;\n            public static final int num = 5;\n        \n            public Zombie(int x){ size = x; System.out.println(gem); System.out.println(west); System.out.println(name); }\n            public void mone(){\n                System.out.println(\"ughhhg: \"+ size);\n            }\n            \n            public void accessTheLiving(){\n                System.out.println(\"local var: \"+y);\n            }\n            \n        }\n        \n        Zombie zom = new Zombie(7);\n        \n    }\n\n}','does not compile\n\na MLIC declared in a static method cannot access instance varialbes of the outerclass. \n\nso\n sout(name) does not compile here. \n\nit can however access those static variables, if it was just the statics \nit would print:\n\n	Gemini\n	Gemini\n	Eunech','Inner Classes',1,NULL),(1737,'public class Hello {\n    private String name = \"marco\";\n    private final static String gem = \"Gemini\";\n    private static String west = \"Eunech\";\n   \n    public static void main(String[] args) {\n        Hello h = new Hello();\n        h.methodlocal();\n    }\n    \n    public void methodlocal(){\n        final int y = 56;\n        //System.out.println(name); //wouldnt compile\n        System.out.println(gem);\n        \n        \n        class Zombie {\n            public int size;\n            public static final int num = 5;\n        \n            public Zombie(int x){ size = x; System.out.println(gem); System.out.println(west); System.out.println(name); }\n            public void mone(){\n                System.out.println(\"ughhhg: \"+ size);\n            }\n            \n            public void accessTheLiving(){\n                System.out.println(\"local var: \"+y);\n            }\n            \n        }\n        \n        Zombie zom = new Zombie(7);\n        \n    }\n\n}','this compiles fine \nMLIC in a instance method can access both static and instance variables','Inner Classes',1,NULL),(1738,'class Horse extends Animal {\n        void buck() { }\n}\n\nclass Animal {\n        void eat() { }\n}\nclass Test {\n        public static void main(String[] atrgs) {\n	Animal h = new Horse();\n	h.eat();\n	h.buck();\n       }\n}	','h.buck() will not compile because you can only call the superclasses methods on a polymorphic reference','Inner Classes',1,NULL),(1739,'public class Hello {\n   \n    public static void main(String[] args) {\n        Biggie smalls = new Biggie(){\n            public void getLoot(){\n                System.out.println(\"Gimmie the loot!\");\n            }\n            \n        };\n        \n        smalls.actFly();\n        smalls.getLoot();\n        \n      \n    }\n\n}\n\nclass Biggie {\n    public void actFly(){\n        System.out.println(\"Shit so fly\");\n    }\n    public static void getPaid(){\n        System.out.println(\"Its so easy!\");\n    }\n    public int getFemaleDigits(){\n        return 5556784;\n    }\n}','here smalls.actFly() compiles \n\nhowever, getLoot() is defined in the anonyous subclass so polynorphically it cannot compile.\n\nThe only way to use methods declared in the anonymous subclass is to override methods of \nthe super class where overriding rules still apply. ','Inner Classes',1,NULL),(1740,'public class Hello {\n   \n    public static void main(String[] args) {\n        Biggie smalls = new Biggie(){\n            private void getLoot(){\n                System.out.println(\"Gimmie the loot!\");\n            }\n            \n            public void actFly(){\n                System.out.println(\"Still acting fly\");\n            }\n            \n        };\n        \n        smalls.actFly();\n        smalls.actFly();\n    }\n\n}\n\nclass Biggie {\n    public void actFly(){\n        System.out.println(\"Shit so fly\");\n    }\n    public static void getPaid(){\n        System.out.println(\"Its so easy!\");\n    }\n    public int getFemaleDigits(){\n        return 5556784;\n    }\n}','proper override','Inner Classes',1,NULL),(1741,'public class Hello {\n   \n    public static void main(String[] args) {\n        Biggie smalls = new Biggie(){\n            private void getLoot(){\n                System.out.println(\"Gimmie the loot!\");\n            }\n            \n            public int actFly(){\n                int x = 66;\n                System.out.println(\"Still acting fly\");\n                return x;\n            }\n            \n        };\n        \n        smalls.actFly();\n        smalls.actFly();\n    }\n\n}\n\nclass Biggie {\n    public void actFly(){\n        System.out.println(\"Shit so fly\");\n    }\n    public static void getPaid(){\n        System.out.println(\"Its so easy!\");\n    }\n    public int getFemaleDigits(){\n        return 5556784;\n    }\n}','will not compile override methods cannot return a different type unless its a subtype','Inner Classes',1,NULL),(1742,'public class Hello {\n   \n    public static void main(String[] args) {\n        Biggie smalls = new Biggie(){\n            private void getLoot(){\n                System.out.println(\"Gimmie the loot!\");\n            }\n            \n            public void actFly(){\n                System.out.println(\"Still acting fly\");\n            }\n            \n            public Integer getFemalDigits(){\n                return 5671123;\n            }  \n        };\n        \n        smalls.actFly();\n        smalls.actFly();\n    }\n\n}\n\nclass Biggie {\n    protected void actFly(){\n        System.out.println(\"Shit so fly\");\n    }\n    public static void getPaid(){\n        System.out.println(\"Its so easy!\");\n    }\n    public Number getFemaleDigits(){\n        return 5556784;\n    }\n}','this will compile just fine. \n\nan override method is allowed to have less reestricted access but not more,\n\nan override method must have the same return type or it can return a subclass. ','Inner Classes',1,NULL),(1743,'public class Hello {\n   \n    public static void main(String[] args) {\n        Biggie smalls = new Biggie(){\n            private void getLoot(){\n                System.out.println(\"Gimmie the loot!\");\n            }\n            \n            public void actFly(){\n                System.out.println(\"Still acting fly\");\n            }\n            \n            public Integer getFemalDigits(){\n                return 5671123;\n            }  \n            \n            public void getPaid(){\n                System.out.println(\"Boy I get money!\");\n            }\n        };\n        \n        smalls.actFly();\n        smalls.actFly();\n    }\n\n}\n\nclass Biggie {\n    protected void actFly(){\n        System.out.println(\"Shit so fly\");\n    }\n    public static void getPaid(){\n        System.out.println(\"Its so easy!\");\n    }\n    public Number getFemaleDigits(){\n        return 5556784;\n    }\n}','will not compile, \n\nyou cannot override a method marked static. \n\nThe only way you could make this work is by making getPaid in the anonymous\nclass static which would \'hide\' the superclass static method not override it.\n\nunfortuanlytel you cannot put a static method in an anonymous class. \n\n\n\nOver-riding basically supports late binding . Therefore, which method will be called is decided at run time.It is for non-static methods. Hiding is for all other members (static methods , instance members, static members). It is based on the early binding . More clearly , the method or member to be called or used is decided during compile time.\n\nIn your example, the first call , Animal.testClassMethod() is a call to a static method,hence, it is pretty sure as to which method is going to be called.\n\nIn the second call,myAnimal.testInstanceMethod(), it calls a non-static method. It is what you call run-time polymorphism. It is not decided until run time which method is to be called.\n\nFor further clarification, read this.\n','Inner Classes',1,NULL),(1744,'public class Hello {\n   \n    public static void main(String[] args) {\n        Biggie smalls = new Biggie(){\n            private void getLoot(){\n                System.out.println(\"Gimmie the loot!\");\n            }\n            \n            public void actFly(){\n                System.out.println(\"Still acting fly\");\n            }\n            \n            public Integer getFemalDigits(){\n                return 5671123;\n            }  \n            \n            public static void getPaid(){\n                System.out.println(\"Boy I get money!\");\n            }\n        };\n        \n        smalls.actFly();\n        smalls.actFly();\n    }\n\n}\n\nclass Biggie {\n    protected void actFly(){\n        System.out.println(\"Shit so fly\");\n    }\n    public static void getPaid(){\n        System.out.println(\"Its so easy!\");\n    }\n    public Number getFemaleDigits(){\n        return 5556784;\n    }\n}','Will not compile\n\nstatic definitions not allowed in inner classes except for constant varaible definintions. ','Inner Classes',1,NULL),(1745,'class Biggie {\n    public static int thashitt = 568;\n    protected void actFly(){\n        System.out.println(\"Shit so fly\");\n    }\n    public static void getPaid(){\n        System.out.println(\"Its so easy!\");\n    }\n    public Number getFemaleDigits(){\n        return 5556784;\n    }\n}\n\nclass Benzino extends Biggie{\n    \n    public void printThaShitt(){\n        System.out.println(thashitt);\n    }\n    \n    public static void getPaid(){\n        System.out.println(\"It\'s somewhat difficult\");\n    }\n    \n    public Integer getFemaleDigits(){\n        return null;\n    }\n    \n}','this compiles fine,\n\n','Inner Classes',1,NULL),(1746,'public class Hello {\n   \n    public static void main(String[] args) {\n        Biggie smalls = new Biggie(){\n            private void getLoot(){\n                System.out.println(\"Gimmie the loot!\");\n            }\n            \n            public void actFly(){\n                System.out.println(\"Still acting fly\");\n            }\n            \n            public Integer getFemaleDigits(){\n                return 5671123;\n            }  \n\n        };\n        \n        smalls.actFly();\n        System.out.println(smalls.getFemaleDigits());\n        \n        Biggie benz = new Benzino();\n        benz.getPaid();\n    }\n\n}\n\nclass Biggie {\n    public static int thashitt = 568;\n    protected void actFly(){\n        System.out.println(\"Shit so fly\");\n    }\n    public static void getPaid(){\n        System.out.println(\"Its so easy!\");\n    }\n    public Number getFemaleDigits(){\n        return 5556784;\n    }\n}\n\nclass Benzino extends Biggie{\n    \n    public void printThaShitt(){\n        System.out.println(thashitt);\n    }\n    \n    public static void getPaid(){\n        System.out.println(\"It\'s somewhat difficult\");\n    }\n    \n    public Integer getFemaleDigits(){\n        return null;\n    }\n    \n}','Still acting fly\n5671123\nIts so easy!\n\nthe reference smalls is of type anonymous class so its methods are theoverriden methods in the anonymous \nclass\n\nwhen getPaid() is called on benz you are accessing a static method from a reference variable, so \nthe Biggie version is used because thats the type of the reference variable, \n\nstatic methods cannot be overridden but they can be hidden. ','Inner Classes',1,NULL),(1747,'public class Hello {\n   \n    public static void main(String[] args) {\n        Biggie smalls = new Biggie(){\n            private void getLoot(){\n                System.out.println(\"Gimmie the loot!\");\n            }\n            \n            public void actFly(){\n                System.out.println(\"Still acting fly\");\n            }\n            \n            public Integer getFemaleDigits(){\n                return 5671123;\n            }  \n\n        };\n        \n        smalls.actFly();\n        System.out.println(smalls.getFemaleDigits());\n        \n        Benzino benz = new Benzino();\n        benz.getPaid();\n    }\n\n}\n\nclass Biggie {\n    public static int thashitt = 568;\n    protected void actFly(){\n        System.out.println(\"Shit so fly\");\n    }\n    public static void getPaid(){\n        System.out.println(\"Its so easy!\");\n    }\n    public Number getFemaleDigits(){\n        return 5556784;\n    }\n}\n\nclass Benzino extends Biggie{\n    \n    public void printThaShitt(){\n        System.out.println(thashitt);\n    }\n    \n    public static void getPaid(){\n        System.out.println(\"It\'s somewhat difficult\");\n    }\n    \n    public Integer getFemaleDigits(){\n        return null;\n    }\n    \n}','Still acting fly\n5671123\nIt\'s somewhat difficult','Inner Classes',1,NULL),(1748,'class Popcorn {\n	public void pop(){\n		sout(\"popcorn\");\n	}\n}\n\nclass Food {\n	Popcorn p = new Popcorn() {\n		public void sizzle(){\n			sout(\"anonymouse sizzling popcorn\");\n		}\n\n		public void pop(){\n			sout(\"anonumous popcorn\");\n		}\n	};\n\n	public void popIt(){\n		p.pop();\n		p.sizzle();\n	}\n}','p.pop(); is ok because popcorn has a pop method\n\np.sizzle();  is illegal because popcorn does not have sizzle().\n\n','Inner Classes',1,NULL),(1749,'public class Hello {\n   \n    public static void main(String[] args) {\n        Biggie benz = new Benzino();\n        benz.printThaShitt();\n    }\n\n}\n\nclass Biggie {\n    public static int thashitt = 568;\n    protected void actFly(){\n        System.out.println(\"Shit so fly\");\n    }\n    public static void getPaid(){\n        System.out.println(\"Its so easy!\");\n    }\n    public Number getFemaleDigits(){\n        return 5556784;\n    }\n}\n\nclass Benzino extends Biggie{\n    \n    public void printThaShitt(){\n        System.out.println(thashitt);\n        getPaid();\n        super.getPaid();\n        Biggie.getPaid();\n    }\n    \n    public static void getPaid(){\n        System.out.println(\"It\'s somewhat difficult\");\n    }\n    \n    public Integer getFemaleDigits(){\n        return null;\n    }\n    \n}','will not compile class Benzino does not have that method. ','Inner Classes',1,NULL),(1750,'public class Hello {\n   \n    public static void main(String[] args) {\n        Benzino benz = new Benzino();\n        benz.printThaShitt();\n    }\n\n}\n\nclass Biggie {\n    public static int thashitt = 568;\n    protected void actFly(){\n        System.out.println(\"Shit so fly\");\n    }\n    public static void getPaid(){\n        System.out.println(\"Its so easy!\");\n    }\n    public Number getFemaleDigits(){\n        return 5556784;\n    }\n}\n\nclass Benzino extends Biggie{\n    \n    public void printThaShitt(){\n        System.out.println(thashitt);\n        getPaid();\n        super.getPaid();\n        Biggie.getPaid();\n    }\n    \n    public static void getPaid(){\n        System.out.println(\"It\'s somewhat difficult\");\n    }\n    \n    public Integer getFemaleDigits(){\n        return null;\n    }\n    \n}\n','568\nIt\'s somewhat difficult\nIts so easy!\nIts so easy!\n\n\ngetPaid() is used plainly as is it calls Benzinos static method, \n\nall the others access the super class. \n\nStatic variables in Java are not inherited, they exist only in the class which declares them; \nhowever, they can be accessed implicitly by referring to an instance or subclass (or subclass instance) of the class which defines the \nstatic variable. \n(Static variable handling is one of the few confusing parts of the Java language, IMHO.)','Inner Classes',1,NULL),(1751,'public class Test {\n    public static void foo() {\n        System.out.println(\"Test.foo() called \");\n    }\n    public static void foo(int a) { \n        System.out.println(\"Test.foo(int) called \");\n    }\n    public static void main(String args[])\n    { \n        Test.foo();\n        Test.foo(10);\n    }\n}','this shows that static methods can be overloaded','Inner Classes',1,NULL),(1752,'public class Test {\n    public static void foo() {\n        System.out.println(\"Test.foo() called \");\n    }\n    public void foo() { \n        System.out.println(\"Test.foo(int) called \");\n    }\n    public static void main(String args[]) { \n        Test.foo();\n    }\n}','will not compile, you cannot overload based on static keyword alone','Inner Classes',1,NULL),(1753,'public class Hello {\n\n   \n    public static void main(String[] args) {\n        Burnable stick = new Burnable(){\n            \n        };\n    }\n\n}\n\ninterface Burnable{\n    int people = 10;\n    void burn();\n    void shakeoff();\n    int unburn();\n    \n}','will not compile, \n\nanonymous class of stick is not abstract and does not overrride interface\nmethods\n\n','Inner Classes',1,NULL),(1754,'public class Hello {\n\n   \n    public static void main(String[] args) {\n        Burnable stick = new Burnable(){\n            public void burn(){\n                System.out.println(\"Theres \"+people+\" people here so get the fire going\");\n            }\n            \n        };\n    }\n\n}\n\ninterface Burnable{\n    int people = 10;\n    void burn();\n    void shakeoff();\n    int unburn();\n    \n}','does not compile, \n\nanonymous subclass does not impelement all abstract methods ','Inner Classes',1,NULL),(1755,'public class Hello {\n\n    public static void main(String[] args) {\n        \n        Burnable stick = new Burnable(){\n            public void burn(){\n                System.out.println(\"Theres \"+people+\" people here so get the fire going\");\n            }\n            \n            public int unburn(){\n                System.out.println(\"That\'s impossible\");\n                return 0;\n            }\n            \n            public void shakeoff(){\n                System.out.println(\"That was my shoe!\");\n            }\n            \n        };\n    }\n\n}\n\ninterface Burnable{\n    int people = 10;\n    void burn();\n    void shakeoff();\n    int unburn();\n}\n','This type of anonomuous inner class implemtents an interface\n\nThis is the only time you can use new with an interface.\n\nIt compiles because all of the abstract methods are implemented\n\n','Inner Classes',1,NULL),(1756,'interface Burnable{\n    int people = 10;\n    void burn();\n    void shakeoff();\n    int unburn();\n    void people(){\n        System.out.println(people+\" \");\n    }\n}','will not compile interfaces are 100% abstract, they can have nothing\nconcrete','Inner Classes',1,NULL),(1757,'public class Hello {\n\n    public static void main(String[] args) {\n        \n        Burnable stick = new Burnable(){\n            int people = 8;\n            public void burn(){\n                System.out.println(\"Theres \"+people+\" people here so get the fire going\");\n            }\n            \n            public int unburn(){\n                System.out.println(\"That\'s impossible\");\n                return 0;\n            }\n            \n            public void shakeoff(){\n                System.out.println(\"That was my shoe!\");\n            }\n            \n        };\n        \n        stick.burn();\n    }\n\n}\n\ninterface Burnable{\n    int people = 10;\n    void burn();\n    void shakeoff();\n    int unburn();\n}\n','Theres 8 people here so get the fire going','Inner Classes',1,NULL),(1758,'public class Hello {\n\n    public static void main(String[] args) {\n        \n        Burnable stick = new Burnable(){\n            int people = 8;\n            public void burn(){\n                System.out.println(\"Theres \"+people+\" people here so get the fire going\");\n            }\n            \n            public int unburn(){\n                System.out.println(\"That\'s impossible\");\n                return 0;\n            }\n            \n            public void shakeoff(int x){\n                System.out.println(\"That was my shoe!\"+x);\n            }\n            \n            public void shakeoff(){\n                System.out.println(\"its off\");\n            }\n            \n            \n            \n        };\n        \n        stick.burn();\n        stick.shakeoff();\n    }\n\n}\n\ninterface Burnable{\n    int people = 10;\n    void burn();\n    void shakeoff(int z);\n    int unburn();\n}','Will not compile, shakeoff() is overloaded in anonymous subclass. \n\nThe overload is legal using it outside the inner class is not\n\nthat method is an overload it is created in the anonnymous subclass and\ncant be used on the Burnable refernence','Inner Classes',1,NULL),(1759,'public class Hello {\n\n    public static void main(String[] args) {\n        Gym.BasketBallCourt bc = new Gym.BasketBallCourt();\n        bc.collectBalls();\n    }\n\n}\n\nclass Gym{\n    public int weights = 8000;\n    public String name = \"Max\'s gym\";\n    public int price = 50;\n    \n    public void pitch(){\n        System.out.println(\"Were the best gym\");\n    }\n    \n    static class BasketBallCourt {\n        private int courts = 2;\n        \n        public void collectBalls(){\n            System.out.println(\"gimmmie all the balls!\");\n        }\n        \n        public int Scoreboard(){\n            return 114;\n        }\n    }\n}','gimmie all the balls!','Inner Classes',1,NULL),(1760,'class Gym{\n    public int weights = 8000;\n    public String name = \"Max\'s gym\";\n    public int price = 50;\n    \n    public void pitch(){\n        System.out.println(\"Were the best gym\");\n    }\n    \n    static class BasketBallCourt {\n        private int courts = 2;\n        \n        public void collectBalls(){\n            System.out.println(\"gimmmie all the balls!\");\n        }\n        \n        public void gymPrice(){\n            System.out.println(name+\" \"+price);\n        }\n        \n        public int Scoreboard(){\n            return 114;\n        }\n    }','will not compile, static classes are like static members of the enclosing\nclass they cannot access instance varialbes','Inner Classes',1,NULL),(1761,'class Gym{\n    public int weights = 8000;\n    public String name = \"Max\'s gym\";\n    public int price = 50;\n    \n    public void pitch(){\n        System.out.println(\"Were the best gym\");\n    }\n    \n    static class BasketBallCourt {\n        private static int courts = 2;\n        \n        public void collectBalls(){\n            System.out.println(\"gimmmie all the balls!\");\n        }\n        \n        public void gymPrice(){\n            Gym g = new Gym();\n            System.out.println(g.price);\n        }\n        \n        public int Scoreboard(){\n            return 114;\n        }\n    }\n}','This compiles fine static inner classes can have static fields and methods\n','Inner Classes',1,NULL),(1762,'public class Hello {\n\n    public static void main(String[] args) {\n        Gym.BasketBallCourt bc = new Gym.BasketBallCourt();\n        bc.collectBalls();\n    }\n\n}\n\nclass Gym{\n    public int weights = 8000;\n    public String name = \"Max\'s gym\";\n    public int price = 50;\n    \n    public void pitch(){\n        BasketBallCourt bc = new BasketBallCourt();\n        System.out.println(\"Were the best gym\");\n        System.out.println(\"Our court is huge too! \"+bc.courts());\n    }\n    \n    static class BasketBallCourt {\n        private static int courts = 2;\n        \n        public static void collectBalls(){\n            System.out.println(\"gimmmie all the balls!\");\n        }\n        public int courts(){\n            return courts;\n        }\n        \n        public void gymPrice(){\n            Gym g = new Gym();\n            System.out.println(g.price);\n        }\n        \n        public int Scoreboard(){\n            return 114;\n        }\n    }\n}','this compiles fine, shows how to properly instantiate static nested clases','Inner Classes',1,NULL),(1763,'public class Hello {\n\n    public static void main(String[] args) {\n        Gym.BasketBallCourt bc = new Gym.BasketBallCourt();\n        Gym g = new Gym();\n        \n        Gym.BasketBallCourt bc3 = g.new BasketBallCourt();\n        \n        g.pitch();\n        \n    }\n\n}\n\nclass Gym{\n    public int weights = 8000;\n    public String name = \"Max\'s gym\";\n    public int price = 50;\n    \n    public void pitch(){\n        BasketBallCourt bc = new BasketBallCourt();\n        System.out.println(\"Were the best gym\");\n        System.out.println(\"Our court is huge too! \"+bc.courts());\n    }\n    \n    static class BasketBallCourt {\n        private static int courts = 2;\n        \n        public static void collectBalls(){\n            System.out.println(\"gimmmie all the balls!\");\n        }\n        public int courts(){\n            return courts;\n        }\n        \n        public void gymPrice(){\n            Gym g = new Gym();\n            System.out.println(g.price);\n        }\n        \n        public int Scoreboard(){\n            return 114;\n        }\n    }\n}','will not compile, that is not the right instantiation of a static nested class','Inner Classes',1,NULL),(1764,'public class Hello {\n\n    public static void main(String[] args) {\n        Gym.BasketBallCourt bc = new Gym.BasketBallCourt();\n        Gym g = new Gym();\n        \n        Gym.BasketBallCourt bc3 = new Gym.BasketBallCourt();\n        \n        bc3.Scoreboard();\n        \n        Gym.BasketBallCourt.collectBalls();\n        \n    }\n\n}\n\nclass Gym{\n    public int weights = 8000;\n    public String name = \"Max\'s gym\";\n    public int price = 50;\n    \n    public void pitch(){\n        BasketBallCourt bc = new BasketBallCourt();\n        System.out.println(\"Were the best gym\");\n        System.out.println(\"Our court is huge too! \"+bc.courts());\n    }\n    \n    static class BasketBallCourt {\n        private static int courts = 2;\n        \n        public static void collectBalls(){\n            System.out.println(\"gimmmie all the balls!\");\n        }\n        public int courts(){\n            return courts;\n        }\n        \n        public void gymPrice(){\n            Gym g = new Gym();\n            System.out.println(g.price);\n        }\n        \n        public int Scoreboard(){\n            return 114;\n        }\n    }\n}','114\ngimmie all the balls','Inner Classes',1,NULL),(1765,'public class Hello {\n\n    public static void main(String[] args) {\n        Gym.BasketBallCourt gbg = new Gym().new BasketBallCourt();\n        System.out.println(gbg.Scoreboard());\n        \n    }\n\n}\n\nclass Gym{\n    public int weights = 8000;\n    public String name = \"Max\'s gym\";\n    public int price = 50;\n    \n    public void pitch(){\n        BasketBallCourt bc = new BasketBallCourt();\n        System.out.println(\"Were the best gym\");\n    }\n    \n    class BasketBallCourt {\n        \n        public void collectBalls(){\n            System.out.println(\"gimmmie all the balls!\");\n        }\n        \n        public void gymPrice(){\n            Gym g = new Gym();\n            System.out.println(g.price);\n        }\n        \n        public int Scoreboard(){\n            return 114;\n        }\n    }\n}','114','Inner Classes',1,NULL),(1766,'public class Hello {\n\n    public static void main(String[] args) {\n        Gym.BasketBallCourt gbg = new Gym().new BasketBallCourt();\n        \n    }\n\n}\n\nclass Gym{\n    public int weights = 8000;\n    public String name = \"Max\'s gym\";\n    public int price = 50;\n    \n    public void pitch(){\n        BasketBallCourt bc = new BasketBallCourt();\n        System.out.println(\"Were the best gym\");\n    }\n    \n    private class BasketBallCourt {\n        \n        public void collectBalls(){\n            System.out.println(\"gimmmie all the balls!\");\n        }\n        \n        public void gymPrice(){\n            Gym g = new Gym();\n            System.out.println(g.price);\n        }\n        \n        public int Scoreboard(){\n            return 114;\n        }\n    }\n}','does not compile because of private modifier','Inner Classes',1,NULL),(1767,'public class Hello {\n\n    public static void main(String[] args) {\n        Gym.BasketBallCourt gbg = new Gym().new BasketBallCourt();\n        \n    }\n\n}\n\nclass Gym{\n    public int weights = 8000;\n    public String name = \"Max\'s gym\";\n    public int price = 50;\n    \n    public void pitch(){\n        BasketBallCourt bc = new BasketBallCourt();\n        System.out.println(\"Were the best gym\");\n    }\n    \n    protected class BasketBallCourt {\n        \n        public void collectBalls(){\n            System.out.println(\"gimmmie all the balls!\");\n        }\n        \n        public void gymPrice(){\n            Gym g = new Gym();\n            System.out.println(g.price);\n        }\n        \n        public int Scoreboard(){\n            return 114;\n        }\n    }\n}','this compiles fine','Inner Classes',1,NULL),(1768,'public class Hello {\n\n    public static void main(String[] args) {\n        LifeTime lt = new LifeTime();\n        lt.showLifeTimesCourt();    \n    }\n\n}\n\nclass Gym{\n    public int weights = 8000;\n    public String name = \"Max\'s gym\";\n    public int price = 50;\n    \n    public void pitch(){\n        BasketBallCourt bc = new BasketBallCourt();\n        System.out.println(\"Were the best gym\");\n    }\n    \n    protected class BasketBallCourt {\n        \n        public void collectBalls(){\n            System.out.println(\"gimmmie all the balls!\");\n        }\n        \n        public void showCourt(){\n            System.out.println(\"oooh ahhh\");\n        }\n        \n        public void gymPrice(){\n            Gym g = new Gym();\n            System.out.println(g.price);\n        }\n        \n        public int Scoreboard(){\n            return 114;\n        }\n    }\n}\n\nclass LifeTime extends Gym{\n    public void showLifeTimesCourt(){\n        BasketBallCourt b = new BasketBallCourt();\n        b.showCourt();\n    }\n}','oooh ahhh\n\nsince inner classes are members of the enclsoing class just like anything else\nthey are inherited too.','Inner Classes',1,NULL),(1769,'public class Hello {\n\n    public static void main(String[] args) {\n       LifeTime lt = new LifeTime();\n       Gym.BasketBallCourt bc = lt.new BasketBallCourt();\n       \n    }\n\n}\n\nclass Gym{\n    public int weights = 8000;\n    public String name = \"Max\'s gym\";\n    public int price = 50;\n    \n    public void pitch(){\n        BasketBallCourt bc = new BasketBallCourt();\n        System.out.println(\"Were the best gym\");\n    }\n    \n    protected class BasketBallCourt {\n        \n        public void collectBalls(){\n            System.out.println(\"gimmmie all the balls!\");\n        }\n        \n        public void showCourt(){\n            System.out.println(\"oooh ahhh\");\n        }\n        \n        public void gymPrice(){\n            Gym g = new Gym();\n            System.out.println(g.price);\n        }\n        \n        public int Scoreboard(){\n            return 114;\n        }\n    }\n}\n\nclass LifeTime extends Gym{\n    public void showLifeTimesCourt(){\n        BasketBallCourt b = new BasketBallCourt();\n        b.showCourt();\n    }\n}','this compiles and runs','Inner Classes',1,NULL),(1770,'public class Hello {\n\n    public static void main(String[] args) {\n       Gym lt = new Gym();\n       Gym.BasketBallCourt bc = lt.new BasketBallCourt();\n       \n    }\n\n}\n\nclass Gym{\n    public int weights = 8000;\n    public String name = \"Max\'s gym\";\n    public int price = 50;\n    \n    public void pitch(){\n        BasketBallCourt bc = new BasketBallCourt();\n        System.out.println(\"Were the best gym\");\n    }\n    \n    protected class BasketBallCourt {\n        public String name = \"Maxs court\";\n        \n        public void collectBalls(){\n            System.out.println(\"gimmmie all the balls!\");\n        }\n        \n        public void showCourt(){\n            System.out.println(\" \"+name);\n            System.out.println(\"oooh ahhh\");\n        }\n        \n        public void gymPrice(){\n            System.out.println(\" \"+Gym.this.name);\n            System.out.println(Gym.this.price);\n        }\n        \n        public int Scoreboard(){\n            return 114;\n        }\n    }\n}','How to access this reference of outer class','Inner Classes',1,NULL),(1771,'public class Hello {\n\n    public static void main(String[] args) {\n       LifeTime lt = new LifeTime();\n       Gym.BasketBallCourt bc = lt.new BasketBallCourt();\n       \n    }\n\n}\n\nclass Gym{\n    public int weights = 8000;\n    public String name = \"Max\'s gym\";\n    public int price = 50;\n    \n    public void pitch(){\n        BasketBallCourt bc = new BasketBallCourt();\n        System.out.println(\"Were the best gym\");\n    }\n    \n    protected class BasketBallCourt {\n        public String name = \"Maxs court\";\n        \n        public void collectBalls(){\n            System.out.println(\"gimmmie all the balls!\");\n        }\n        \n        public void showCourt(){\n            System.out.println(\" \"+name);\n            System.out.println(\"oooh ahhh\");\n        }\n        \n        public void gymPrice(){\n            System.out.println(\" \"+Gym.this.name);\n            System.out.println(Gym.this.price);\n        }\n        \n        public int Scoreboard(){\n            return 114;\n        }\n    }\n}\n\nclass LifeTime extends Gym{\n    public void showLifeTimesCourt(){\n        final int time = 530;\n        class SalesRep{\n            public void appointment(){\n                System.out.println(\"The time of our appointment is: \"+time);\n            }\n            \n        }\n        SalesRep sr = new SalesRep();\n        sr.appointment();\n        BasketBallCourt b = new BasketBallCourt();\n        b.showCourt();\n    }\n}','compiles fine','Inner Classes',1,NULL),(1772,'package hello;\n\nimport java.awt.Container;\nimport java.awt.EventQueue;\nimport java.awt.event.ActionEvent;\nimport java.awt.event.InputEvent;\nimport java.awt.event.KeyEvent;\nimport java.io.IOException;\nimport java.io.Serializable;\nimport java.nio.file.DirectoryStream;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Hashtable;\nimport java.util.Iterator;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.NavigableMap;\nimport java.util.PriorityQueue;\nimport java.util.Set;\nimport java.util.SortedMap;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport javax.swing.AbstractAction;\nimport javax.swing.GroupLayout;\nimport javax.swing.InputMap;\nimport javax.swing.JButton;\nimport javax.swing.JComponent;\nimport javax.swing.JFrame;\nimport javax.swing.JPanel;\nimport javax.swing.KeyStroke;\n\npublic class Hello {\n\n    public static void main(String[] args) {\n       LifeTime lt = new LifeTime();\n       Gym.BasketBallCourt bc = lt.new BasketBallCourt();\n       \n    }\n\n}\n\nclass Gym{\n    public int weights = 8000;\n    public String name = \"Max\'s gym\";\n    public int price = 50;\n    \n    public void pitch(){\n        BasketBallCourt bc = new BasketBallCourt();\n        System.out.println(\"Were the best gym\");\n    }\n    \n    protected class BasketBallCourt {\n        public String name = \"Maxs court\";\n        \n        public void collectBalls(){\n            System.out.println(\"gimmmie all the balls!\");\n        }\n        \n        public void showCourt(){\n            System.out.println(\" \"+name);\n            System.out.println(\"oooh ahhh\");\n        }\n        \n        public void gymPrice(){\n            System.out.println(\" \"+Gym.this.name);\n            System.out.println(Gym.this.price);\n        }\n        \n        public int Scoreboard(){\n            return 114;\n        }\n    }\n}\n\nclass LifeTime extends Gym{\n    public void showLifeTimesCourt(){\n        int time = 530;\n        class SalesRep{\n            public void appointment(){\n                System.out.println(\"The time of our appointment is: \"+time);\n            }\n            \n        }\n        SalesRep sr = new SalesRep();\n        sr.appointment();\n        BasketBallCourt b = new BasketBallCourt();\n        b.showCourt();\n    }\n}\n\n\n','compilation fails, non final local variable is access from Method local inner \nclass.','Inner Classes',1,NULL),(1773,'class Gym{\n    public int weights = 8000;\n    public String name = \"Max\'s gym\";\n    public int price = 50;\n    \n    public void pitch(){\n        BasketBallCourt bc = new BasketBallCourt();\n        System.out.println(\"Were the best gym\");\n    }\n    \n    protected class BasketBallCourt {\n        public String name = \"Maxs court\";\n        \n        public void collectBalls(){\n            System.out.println(\"gimmmie all the balls!\");\n        }\n        \n        public void showCourt(){\n            System.out.println(\" \"+name);\n            System.out.println(\"oooh ahhh\");\n        }\n        \n        public void gymPrice(){\n            System.out.println(\" \"+Gym.this.name);\n            System.out.println(Gym.this.price);\n        }\n        \n        public int Scoreboard(){\n            return 114;\n        }\n    }\n}\n\nclass LifeTime extends Gym{\n    public void showLifeTimesCourt(){\n        int time = 530;\n        protected class SalesRep{\n            public void appointment(){\n                System.out.println(\"The time of our appointment is: \"+time);\n            }\n            \n        }\n        SalesRep sr = new SalesRep();\n        sr.appointment();\n        BasketBallCourt b = new BasketBallCourt();\n        b.showCourt();\n    }\n}','Method inner classes cannot be declared protected public private or static','Inner Classes',1,NULL),(1774,'public class Hello {\n    public static void main(String[] args) {\n       Gym g = new LifeTime() {\n           public void showLifeTimeCourt(){\n               System.out.println(\"LT on meridean\");\n           }\n       };\n    }\n}\n\nclass Gym{\n    public int weights = 8000;\n    public String name = \"Max\'s gym\";\n    public int price = 50;\n    \n    public void pitch(){\n        BasketBallCourt bc = new BasketBallCourt();\n        System.out.println(\"Were the best gym\");\n    }\n    \n    static class BasketBallCourt {\n        public String name = \"Maxs court\";\n        \n        public void collectBalls(){\n            System.out.println(\"gimmmie all the balls!\");\n        }\n        \n        public void showCourt(){\n            System.out.println(\" \"+name);\n            System.out.println(\"oooh ahhh\");\n        }\n        \n        public void gymPrice(){\n\n        }\n        \n        public int Scoreboard(){\n            return 114;\n        }\n    }\n}\n\nclass LifeTime extends Gym{\n    \n    public void showLifeTimesCourt(){\n        final int time = 530;\n        BasketBallCourt bc = new BasketBallCourt();\n        bc.collectBalls();\n    }\n}','This compiles fine, you can create an anonymous inner class with a subclass\nthen assign it to a superclass reference. ','Inner Classes',1,NULL),(1775,'public class Hello {\n    public static void main(String[] args) {\n        \n        AquaticLife shark = new Shark(){\n            String unknown = \"unknown species\";\n            public void species(){\n                System.out.println(unknown);\n            }\n        };\n        \n        shark.swim();\n        shark.devourSeal();\n  \n    }\n}\n\nclass AquaticLife{ \n    public void swim(){ \n        System.out.println(\"Bubbles\");\n    }\n     \n    public void useGills(){\n        System.out.println(\"ahhh\");\n    }\n}\n\nclass Shark extends AquaticLife{\n    public void devourSeal(){\n        System.out.println(\"chomp\");\n    }\n    \n    public void swin(){\n        System.out.println(\"Swims up to 60mph\");\n    }\n    public void electricSense(){\n        System.out.println(\"I can feel you in the water\");\n    }\n}','shark.devourSeal() does not compile. \n\nthe anonymous class is declared with a reference type of AquaticLife\nso you can only use methods of that class','Inner Classes',1,NULL),(1776,'class AquaticLife{ \n    public void swim(){ \n        System.out.println(\"Bubbles\");\n    }\n     \n    public void useGills(){\n        System.out.println(\"ahhh\");\n    }\n    \n    class BottomFeeder extends AquaticLife {\n        public void useGills(){\n            System.out.println(\"I dont have gills\");\n        }\n    }\n}','an inner class can extend the outlying classs','Inner Classes',1,NULL),(1777,'which are true about a method local inner class ?\n\nIt must be marked final\nIt can be marked abstract\nIt can be marked public \nIt can be marked static \nIt can access private members of the enclosing class','It can be abstract,\n	that would mean a concrete class would have to be created in the \n	method so that would probably not be very useful\n\nIt can access private members of the enclosing class\n--------------------------------------------------------\nIt can be marked final but it doesnt\' have to be\n\na method local inner class cannot be marked public, or static','Inner Classes',1,NULL),(1778,'public class TestObj {\n	public static void main(SA){\n		Object ob = new Object() {\n			public boolean equals(Object ob){\n				return true;\n			}\n		}\n		sout(ob.equals(\"FRED\");\n	}\n}','Compilation fails with an error at the line where the semicolon should be \nafter the inner class','Inner Classes',1,NULL),(1779,'public class HorseTest {\n	public static void main(SA){\n		class Horse {\n			public String name;\n			public Horse(String s) {\n				name = s;\n			}\n		}\n		Object ob = new Horse(\"Zippo\");\n		sout(ob.name);\n	}\n}','compilation fails at sout(ob.name);\n\nif the reference variable is of type Object you can only access members \ndefined class Object','Inner Classes',1,NULL),(1780,'public abstract class AbstractTest {\n	public int getNum(){\n		return 45;\n	}\n	public abstract class Bar {\n		public int getNum(){\n			return 38;\n		}\n	}\n	public staic void main(String[] args) {\n		AbstractTest t = new AbstractTest(){\n			public int getNum() {\n				return 22;\n			}\n		};\n		AbstractTest.Bar f = t.new Bar() {\n			public int getNum(){\n				return 57;\n			}\n		};\n		sout(f.getNum() + \" \" + t.getNum() );\n	}\n}','57 22\n\nto create an instance of an inner class you have to create it with an \nouter class reference here AbstractTest is abstract so it had to be\ninstantiated with an anonymous inner class to have a concrete reference\nto tie the new anonymous class of type Bar to. ','Inner Classes',1,NULL),(1781,'public class Tour {\n	public static void main(SA){\n		Cathedral c = new Cathedral();\n		// insert code\n		s.go();\n	}\n}\n\nclass Cathedral {\n	class Sanctum {\n		void go() { sout(\"spooky\"); }\n	}\n}\n\nproperly instantiate Sanctume','Cathedral.Sanctum s = c.new Sanctum();\n\nor\n\nCathedral.Sanctum s1 = new Cathedral().new Sanctum();','Inner Classes',1,NULL),(1782,'public abstract class Hello {\n    public static void main(String[] args) {\n        new Hello().test();\n        \n    }\n    \n    void test() {\n        class Breaker{ void foo(){ System.out.println(\"Inner\"); } }\n    }\n    \n    class Breaker {\n        void foo(){\n            System.out.println(\"middle\");\n        }\n    }\n}\n\nclass Breaker{\n    void foo(){\n        System.out.println(\"Outer\");\n    }\n    \n}','Will not compile Hello is abstract cannot be instantiated lol ','Inner Classes',1,NULL),(1783,'public class Hello {\n    public static void main(String[] args) {\n        new Hello().test();\n        \n    }\n    \n    void test() {\n        new Breaker().foo();\n        class Breaker{ void foo(){ System.out.println(\"Inner\"); } }\n    }\n    \n    class Breaker {\n        void foo(){\n            System.out.println(\"middle\");\n        }\n    }\n}\n\nclass Breaker{\n    void foo(){\n        System.out.println(\"Outer\");\n    }\n    \n}','middle\n\nThe closest scoped class is middle. The inner class is declared after the\ncall to foo() and the Outer class comes after any inner classes','Inner Classes',1,NULL),(1784,'public class Hello {\n    public static void main(String[] args) {\n        blue.biteHook();\n        \n        BlueGill blue = new BlueGill(){\n            public void biteHook(){\n                System.out.println(\"Not This Time\");\n            }\n        }\n        \n    }\n    \n    BlueGill bigBlue = new BlueGill(){\n        public int bubble() throws IOException {\n            System.out.println(\"Big Bubbles\");\n            return 5;\n        }\n        \n    };\n}\n\nabstract class Fish {\n    public abstract void swim();\n    private abstract int numberOfFins();\n    \n}\n\nclass BlueGill extends Fish {\n    public void swim(){\n        System.out.println(\"Swims in lakes\");\n    }\n    \n    public void biteHook() throws IOException {\n        System.out.println(\"What the hell\");\n    }\n    \n    public int bubble() throws Exception{\n        System.out.println(\"bubble bubble\");\n        return 2;\n    }\n}','the call to blue in main fails because it is called before the anon class\nis created. \n\nanonymous class bigBlue works fine, you can define anonymous classes as\nmembers \n\nalso anon class blue forgets to end with a ; \n\nabsract classes cannnot have private abstract members, how would they\nbe instantiated ?\n\nbecaue of that BlueGill cannot properly override method numberOfFins()\n\nan overriding method can choose not to throw the same exception or can \nthrow a narrower one. \n','Inner Classes',1,NULL),(1785,'public class Hello {\n    public static void main(String[] args) {     \n        BlueGill blue = new BlueGill(){\n            public void biteHook() throws IOException{\n                System.out.println(\"Not This Time\");\n            }\n            public void biteHook(boolean yesno) throws NullPointerException{\n                System.out.println(\"That worm looks so tasty\");\n            }\n            \n        };\n        \n    }\n}\n\nabstract class Fish {\n    public abstract void swim() throws Exception;\n    public abstract int numberOfFins();\n    public static void breathe(){\n        System.out.println(\"ahhh\");\n    }\n    \n    \n}\n\nclass BlueGill extends Fish {\n    public void swim(){\n        breathe();\n        System.out.println(\"Swims in lakes\");\n    }\n    \n    public void biteHook() throws IOException {\n        System.out.println(\"What the hell\");\n    }\n    \n    public int numberOfFins() throws SQLException {\n        return 4;\n    }\n    \n    public int bubble() throws Exception{\n        System.out.println(\"bubble bubble\");\n        return 2;\n    }\n}','numberOfFins() in abstract class Fish does not throw SQLException\n	so the override in BlueGill cannot throw a new Exception.\n\nbiteHook is declared in BlueGill then overriden in the annon class with\nthe same exception so its ok.\n\nthen the anon class does not override the method numberOfFins which was \nnot properly overriden in the abstract class so that makes the anon class\nnot compile. If it had overriden numberOfFins() then it could have compiled\n\nstill though the NOF in BlueGill threw that SQLException so it wont ever compile..','Inner Classes',1,NULL),(1786,'public class  Car {\n	class Engine {\n		// insert here\n	}\n	public static void main(SA){\n		new Car().go();\n	}\n	void go() {\n		new Engine();\n	}\n	void drive() { sout(\"hi\"); }\n}\n\n// what can be given at insert here to produce \"hi\" ?\n','{ Car.this.drive(); }\n\nEngine() { Car.this.drive(); }','Inner Classes',1,NULL),(1787,'public class City {\n	class Manhattan {\n		void doStuff() throws Exception { sout(\"x \"); }\n	}\n	class Timesquare extends Manhattan {\n		void doStuff throws Exception {  }\n	}\n\n	public static void main(Stringp]] args) throws Exception{\n		new City().go();\n	}\n	void go() throws Exception { new Timesquare().doStuff(); }\n}','no output is produced, the inner classes are valid and the exceptions are \nthrown properly','Inner Classes',1,NULL),(1788,'public class Navel {\n	private int size = 7;\n	private static int length = 3;\n	public static void main(String[] args) {\n		new Navel().go();\n	}\n	void go(){\n		int size = 5;\n		sout( new Gazer().adder() );\n	}\n	class Gazer {\n		int adder() { return size * length; }\n	}\n}	','21','Inner Classes',1,NULL),(1789,'public class Hello {\n    public static void main(String[] args) {     \n        BlueGill blue = new BlueGill();\n        blue.breathe();\n        blue.swim();\n        \n    }\n}\n\nabstract class Fish {\n    public abstract void swim() throws Exception;\n    public abstract int numberOfFins();\n    public static void breathe(){\n        System.out.println(\"ahhh\");\n    }   \n}\n\nclass BlueGill extends Fish {\n    public void swim(){\n        breathe();     \n        System.out.println(\"Swims in a lake\");\n    }\n    \n    public int numberOfFins(){\n        return 5;    \n    }   \n}','ahhh\nahhh\nSwims in a lake','Inner Classes',1,NULL),(1790,'public class Hello {\n    public static void main(String[] args) {     \n        BlueGill blue = new BlueGill();\n        \n        Fish.breathe();\n        \n    }\n}\n\nabstract class Fish {\n    public abstract void swim() throws Exception;\n    public abstract int numberOfFins();\n    public static void breathe(){\n        System.out.println(\"ahhh\");\n    }   \n}\n\nclass BlueGill extends Fish {\n    public void swim(){\n        breathe();     \n        System.out.println(\"Swims in a lake\");\n    }\n    \n    public int numberOfFins(){\n        return 5;    \n    }   \n}','ahhh','Inner Classes',1,NULL),(1791,'abstract class Fish {\n    public static int species = 100;\n    public abstract void swim() throws Exception;\n    public abstract int numberOfFins();\n    public static void breathe(){\n        System.out.println(\"ahhh\");\n    }   \n}\n\nclass BlueGill extends Fish {\n    public void swim(){\n        breathe();     \n        System.out.println(species);\n        System.out.println(\"Swims in a lake\");\n    }\n    \n    public int numberOfFins(){\n        return 5;    \n    }   \n}','compiles','Inner Classes',1,NULL),(1792,'public class Pockets {\n	public static void main(SA){\n		String[] sa = {\"nickle\",\"button\", \"key\", \"lint\" };\n		Sorter s = new Sorter();\n		for(String s2: sa) sout( s2+\" \" );\n		Arrays.sort(sa,s);\n		sout();\n		for(String s2 : sa) sout( s2+\" \" );\n		\n	}\n	class Sorter implements Comparator<String> {	\n		public int compare(String a, String b) {\n			return b.compareTo(a);\n		}\n	}\n}','compilation fails, \nClass sorter must be delcared static to be used in static methood main. ','Collections',1,NULL),(1793,'public class Hello {\n    public static void main(String[] args) {     \n        BlueGill blue = new BlueGill();\n        blue.swim();\n        \n    }\n}\nclass BlueGill extends Fish {\n    public void swim(){\n        breathe();     \n        System.out.println(species);\n        System.out.println(\"Swims in a lake\");\n    }\n    \n    public int numberOfFins(){\n        return 5;    \n    }   \n}\n\nabstract class Fish {\n    public static int species = 100;\n    public abstract void swim() throws Exception;\n    public abstract int numberOfFins();\n    public static void breathe(){\n        System.out.println(\"ahhh\");\n    }   \n}\n   ','ahhh\n100\nSwims in a lake\n\noverriding methods cannot throw new or broader checked exceptions, they can throw none at all. ','Inner Classes',1,NULL),(1794,'public class Hello {\n    public static void main(String[] args) {     \n        BlueGill blue = new BlueGill();\n        blue.swim();\n        \n    }\n class BlueGill extends Fish {\n    public void swim(){\n        breathe();     \n        System.out.println(species);\n        System.out.println(\"Swims in a lake\");\n    }\n    \n    public int numberOfFins(){\n        return 5;    \n    }   \n}\n}\n\nabstract class Fish {\n    public static int species = 100;\n    public abstract void swim() throws Exception;\n    public abstract int numberOfFins();\n    public static void breathe(){\n        System.out.println(\"ahhh\");\n    }   \n}','will not compile, BlueGill is an inner class therefor must be declared static\nto be used in static method main. ','Inner Classes',1,NULL),(1795,'public class Hello {\n    public static void main(String[] args) {     \n        BlueGill blue = new BlueGill();\n        blue.swim();\n        \n    }\n static class BlueGill extends Fish {\n    public void swim(){\n        breathe();     \n        System.out.println(species);\n        System.out.println(\"Swims in a lake\");\n    }\n    \n    public int numberOfFins(){\n        return 5;    \n    }   \n}\n}\n\nabstract class Fish {\n    public static int species = 100;\n    public abstract void swim() throws Exception;\n    public abstract int numberOfFins();\n    public static void breathe(){\n        System.out.println(\"ahhh\");\n    }   \n}','ahhh\n100\nSwims in lake','Inner Classes',1,NULL),(1796,'public class Hello {\n    public static void main(String[] args) {     \n        Locker<SchoolSupplies> locker = new Locker<>();\n        locker.stuff.add(new Book(\"AAA\"));\n        locker.stuff.add(new Book(\"BBB\"));\n        \n        System.out.println(locker.getOut(new Book(\"AAA\")));\n        \n    }\n}\n\nclass Locker<T> {\n    ArrayList<T> stuff = new ArrayList<T>();\n    public T getOut(T that){\n        return stuff.get(that);\n    }\n}\n\nabstract class SchoolSupplies{\n    public abstract void use();\n    public abstract int lend();\n    public abstract boolean isCool();\n}\n\nclass Book extends SchoolSupplies{\n    private String name;\n    Book(String n){\n        name = n;\n    }\n    public void use(){\n        System.out.println(\"Read it\");\n    }\n    \n    public int lend(){\n        System.out.println(\"I need back by 4th\");\n        return 4;\n    }\n    \n    public boolean isCool(){\n        return false;\n    }\n}\n\nclass Pen extends SchoolSupplies {\n    public void use(){\n        System.out.println(\"doodle\");\n    }\n    \n    public int lend(){\n        System.out.println(\"just have it\");\n        return null;\n    }\n    \n    public boolean isCool(){\n        return true;\n    }\n}','Arraylist doesn\'t have a method that returns the given object. \n\nalso you cannot return null when the return type is primitive.','Inner Classes',1,NULL),(1797,'public class Hello {\n    public static void main(String[] args) {     \n\n        List<Animal> animals = new ArrayList<Animal>();\n        animals.add(new Dog());\n        animals.add(new Cat());\n        \n        addAnimal(animals);\n    \n    }\n    \n    public static void addAnimal(List animals) {\n	animals.add(new Object());\n    }\n}','compiles with a warning','Generics',1,NULL),(1798,'public class Hello {\n    public static void main(String[] args) {     \n\n        Animal a = new Animal(6,\"dog\");\n        System.out.println(a.getSize());\n    \n    }\n\n}\n        \nclass Animal implements Comparable<Animal>{\n    private int size;\n    private String name;\n    public Animal(int s, String n){\n        size = s;\n        name = n;\n        \n    }\n    public int getSize(){\n        return size;\n    }\n    public int compareTo(Animal a){\n        int asize = a.getSize();\n        int bsize = this.size;\n        \n        if(asize < bsize)\n            return 1;\n        else if(asize == bsize)\n            return 0;\n        else\n            return -1;\n        \n        \n    }\n    \n    public String toString(){\n        return name;\n    }\n}\n\nclass Dog extends Animal{}\nclass Cat extends Animal{} ','will not compile,\n\ndefault constructors in Dog and Cat do not give proper calls to super()\nanimal non-defautl constructor','General',1,NULL),(1799,'public class Hello {\n    public static void main(String[] args) {     \n        List<Spankable> spanklist = new ArrayList<>();\n        spanklist.add(new Doll());\n        spanklist.add(new Doll());\n        \n    }\n    \n    public static void runit(List<? extends Shaveable> sList){\n        for(Spankable s : sList){\n            s.shave();\n        }\n    }\n\n}\n\ninterface Shaveable{\n    public void shave();\n}\n\ninterface Spankable extends Shaveable{\n    public void spank();\n}\n\nclass Doll implements Spankable{\n    public void spank(){\n        System.out.println(\"OW!\");\n    }\n    \n    public void shave(){\n        System.out.println(\"HMMM : O\");\n    }\n}','will not compile,\n\n	should be...\n		for(Shaveable s : sList){\n			...','General',1,NULL),(1800,'public class Hello {\n    public static void main(String[] args) {     \n        List<Spankable> spanklist = new ArrayList<>();\n        spanklist.add(new Doll());\n        spanklist.add(new Doll());\n        \n    }\n    \n    public static void runit(List<? extends Shaveable> sList){\n        for(Shaveable s : sList){\n            s.shave();\n        }\n    }\n\n}\n\ninterface Shaveable{\n    public void shave();\n}\n\ninterface Spankable extends Shaveable{\n    public void spank();\n}\n\nclass Doll implements Spankable{\n    public void spank(){\n        System.out.println(\"OW!\");\n    }\n    \n    public void shave(){\n        System.out.println(\"HMMM : O\");\n    }\n}','compiles\n\nhmmm : O\nhmmm : O','General',1,NULL),(1801,'public class Hello {\n    public static void main(String[] args) {     \n        List<Spankable> spanklist = new ArrayList<>();\n        spanklist.add(new Doll());\n        spanklist.add(new Doll());\n        \n        runit(spanklist);\n        \n    }\n    \n    public static void runit(List<? extends Spankable> sList){\n        for(Shaveable s : sList){\n            s.shave();\n        }\n    }\n\n}\n\ninterface Shaveable{\n    public void shave();\n}\n\ninterface Spankable extends Shaveable{\n    public void spank();\n}\n\nclass Doll implements Spankable{\n    public void spank(){\n        System.out.println(\"OW!\");\n    }\n    \n    public void shave(){\n        System.out.println(\"HMMM : O\");\n    }\n}','HMMM : O\nHMMM : O\n\n','General',1,NULL),(1802,'class Hello {\n    public static void main(String[] args) {     \n        List<Spankable> spanklist = new ArrayList<>();\n        spanklist.add(new Doll());\n        spanklist.add(new Doll());\n        \n        runit(spanklist);\n        \n    }\n    \n    public static void runit(List<? extends Shaveable> sList){\n        for(Shaveable s : sList){\n            s.shave();\n        }\n    }\n\n}\n\ninterface Shaveable{\n    public void shave();\n}\n\ninterface Spankable extends Shaveable{\n    public void spank();\n}\n\nclass Doll implements Spankable{\n    public void spank(){\n        System.out.println(\"OW!\");\n    }\n    \n    public void shave(){\n        System.out.println(\"HMMM : O\");\n    }\n}                     ','HMMM : O\nHMMM : O','General',1,NULL),(1803,'class Hello {\n    public static void main(String[] args) {     \n        List<Doll> spanklist = new ArrayList<>();\n        spanklist.add(new Doll());\n        spanklist.add(new Doll());\n        \n        runit(spanklist);\n        \n    }\n    \n    public static void runit(List<? extends Shaveable> sList){\n        for(Shaveable s : sList){\n            s.shave();\n        }\n    }\n\n}\n\ninterface Shaveable{\n    public void shave();\n}\n\ninterface Spankable extends Shaveable{\n    public void spank();\n}\n\nclass Doll implements Spankable{\n    public void spank(){\n        System.out.println(\"OW!\");\n    }\n    \n    public void shave(){\n        System.out.println(\"HMMM : O\");\n    }\n}                  ','HMMM : O\nHMMM : O','General',1,NULL),(1804,'class Hello {\n    public static void main(String[] args) {     \n        Path p1 = Paths.get(\"/home/max/tmp\");\n        Path p2 = Paths.get(\"/tmp/google/file.txt\");\n        System.out.println(p1.resolve(p2));\n        \n    }\n\n}','/tmp/google/file.txt','General',1,NULL),(1805,'class Hello {\n    public static void main(String[] args) {     \n        Path p1 = Paths.get(\"/home/max/tmp\");\n        Path p2 = Paths.get(\"tmp/google/file.txt\");\n        System.out.println(p1.resolve(p2));\n        \n    }\n\n}','/home/max/tmp/tmp/google/file.txt','Input/Output',1,NULL),(1806,'class Hello {\n    public static void main(String[] args) {     \n        Path p1 = Paths.get(\"/home/max/tmp\");\n        Path p2 = Paths.get(\"google/file.txt\");\n        System.out.println(p1.resolve(p2));\n        \n    }\n\n}','/home/max/tmp/google/file.txt','Input/Output',1,NULL),(1807,'class Hello {\n    public static void main(String[] args) {     \n        Path p1 = Paths.get(\"/home/max/tmp\");\n        Path p2 = Paths.get(\"file.txt\");\n        System.out.println(p1.resolve(p2));\n        \n    }\n\n}','/home/max/tmp/file.txt','General',1,NULL),(1808,'class Hello {\n    public static void main(String[] args) {     \n        Path p1 = Paths.get(\"home/max/tmp\");\n        Path p2 = Paths.get(\"file.txt\");\n        System.out.println(p1.resolve(p2));\n        \n    }\n\n}','home/max/tmp/file.txt','General',1,NULL),(1809,'class Hello {\n    public static void main(String[] args) {     \n        Path p1 = Paths.get(\"home/max/tmp/file.txt\");\n        Path p2 = Paths.get(\"file.txt\");\n        System.out.println(p1.resolve(p2));\n        \n    }\n\n}','home/max/tmp/file.txt/file.txt','General',1,NULL),(1810,'class Hello {\n    public static void main(String[] args) {     \n        Path p1 = Paths.get(\"\");\n        Path p2 = Paths.get(\"file.txt\");\n        System.out.println(p1.resolve(p2));\n        \n    }\n\n}','file.txt','General',1,NULL),(1811,'class Hello {\n    public static void main(String[] args) {     \n        Path p1 = Paths.get(\"home/max/tmp/file.txt\");\n        Path p2 = Paths.get(\"\");\n        System.out.println(p1.resolve(p2));\n        \n    }\n\n}','home/max/tmp/file.txt','General',1,NULL),(1812,'class Hello {\n    public static void main(String[] args) {     \n        Path p1 = Paths.get(\"home/max/tmp/file.txt\");\n        Path p2 = Paths.get(\"file.txt\");\n        System.out.println(p2.resolve(p1));\n        \n    }\n\n}','file.txt/home/max/tmp/file.txt','General',1,NULL),(1813,'public class Hello<T> {\n    public static void main(String[] args){\n\n        ArrayList<? extends Animal> c = makeArrayList(new Animal(5));\n        \n        Animal max = new Animal(100);\n        Animal bear = new Animal(45);\n        Animal Hippo = new Animal(45);\n        \n        System.out.println(bear.equals(Hippo));    \n    } \n    public static <G extends Animal> ArrayList<G> makeArrayList(G g){\n        ArrayList<G> genlist = new ArrayList();\n        genlist.add(g);\n        return genlist;\n        \n    }\n}\n\nclass Animal{\n    private int size;\n    public Animal(int s){\n        size = s;\n    }\n    public void makeSound(){\n            System.out.println(\"Sound!\");\n            \n    }\n    \n    public int getSize(){\n        return size;\n    }\n\n    public boolean equals(Object o){\n        // equals without instanceof \n        if(((Animal)o).getSize() == this.size){\n            return true;\n        } else {\n            return false;\n        }\n        \n    }\n}\n\nclass Flower {\n    public void pretty(){\n        System.out.println(\"i look so pretty\");\n    }\n}','true\n\nHowever Animal does not have an instanceof test in its boolean so be \ncareful you could get a classcastexception','General',1,NULL),(1814,'public class Hello<T> {\n    public static void main(String[] args){\n\n        ArrayList<? extends Animal> c = makeArrayList(new Animal(5));\n        \n        Animal max = new Animal(100);\n        Animal bear = new Animal(45);\n        Animal Hippo = new Animal(45);\n        Flower flower = new Flower();\n        \n        System.out.println(bear.equals(Hippo));  \n        System.out.println(max.equals(flower));\n    } \n    public static <G extends Animal> ArrayList<G> makeArrayList(G g){\n        ArrayList<G> genlist = new ArrayList();\n        genlist.add(g);\n        return genlist;\n        \n    }\n}\n\nclass Animal{\n    private int size;\n    public Animal(int s){\n        size = s;\n    }\n    public void makeSound(){\n            System.out.println(\"Sound!\");\n            \n    }\n    \n    public int getSize(){\n        return size;\n    }\n\n    public boolean equals(Object o){\n        // equals without instanceof \n        if(((Animal)o).getSize() == this.size){\n            return true;\n        } else {\n            return false;\n        }\n        \n    }\n}\n\nclass Flower {\n    public void pretty(){\n        System.out.println(\"i look so pretty\");\n    }\n}','ClassCastException','General',1,NULL),(1815,'class Foo {\n    public static void classMethod() {\n        System.out.println(\"classMethod() in Foo\");\n    }\n \n    public void instanceMethod() {\n        System.out.println(\"instanceMethod() in Foo\");\n    }\n}\n \nclass Bar extends Foo {\n    public static void classMethod() {\n        System.out.println(\"classMethod() in Bar\");\n    }\n \n    public void instanceMethod() {\n        System.out.println(\"instanceMethod() in Bar\");\n    }\n}\n  \nclass Test {\n    public static void main(String[] args) {\n        Foo f = new Bar();\n        f.instanceMethod();\n        f.classMethod();\n    }\n}','instanceMethod() in Bar\nclassMethod() in Foo\n\nBriefly, when you override a method, you still get the benefits of run-time polymorphism, and when you hide, you don\'t\n\nWhy do we get instanceMethod from Bar, but classMethod() from Foo? Aren\'t we using the same instance f to access both of these? Yes we are - but since one is overriding and the other is hiding, we see different behavior.\n\nSince instanceMethod() is (drum roll please...) an instance method, in which Bar overrides the method from Foo, at run time the JVM uses the actual class of the instance f to determine which method to run. Although f was declared as a Foo, the actual instance we created was a new Bar(). So at runtime, the JVM finds that f is a Bar instance, and so it calls instanceMethod() in Bar rather than the one in Foo. That\'s how Java normally works for instance methods.\n\nWith classMethod() though. since (ahem) it\'s a class method, the compiler and JVM don\'t expect to need an actual instance to invoke the method. And even if you provide one (which we did: the instance referred to by f) the JVM will never look at it. The compiler will only look at the declared type of the reference, and use that declared type to determine, at compile time, which method to call. Since f is declared as type Foo, the compiler looks at f.classMethod() and decides it means Foo.classMethod. It doesn\'t matter that the instance reffered to by f is actually a Bar - for static methods, the compiler only uses the declared type of the reference. That\'s what we mean when we say a static method does not have run-time polymorphism.\n\nBecause instance methods and class methods have this important difference in behavior, we use different terms - \"overriding\" for instance methods and \"hiding\" for class methods - to distinguish between the two cases. And when we say you can\'t override a static method, what that means is that even if you write code that looks like it\'s overriding a static method (like the first Foo and Bar at the top of this page) - it won\'t behave like an overridden method. ','General',1,NULL),(1816,'class Bear extends Animal{\n    private static int ALLBEARSAREBIG = 100;\n    \n    public Bear(){\n        super(ALLBEARSAREBIG);\n        \n    }\n    \n    public static void eat(){\n        System.out.println(\"Eat salmon\");\n    }\n    \n}\n\nclass Animal{\n    private int size;\n    public Animal(int s){\n        size = s;\n    }\n    public static void eat(){\n        System.out.println(\"all animals eat\");\n    }\n    public void makeSound(){\n            System.out.println(\"Sound!\");\n            \n    }\n    \n    public int getSize(){\n        return size;\n    }\n\n    public boolean equals(Object o){\n        // equals without instanceof \n        if(((Animal)o).getSize() == this.size){\n            return true;\n        } else {\n            return false;\n        }\n        \n    }\n}\n\npublic class Hello<T> {\n    public static void main(String[] args){\n        Animal cat = new Animal(5);\n        Animal bear = new Bear();\n        \n        cat.eat();\n        Animal.eat();\n        bear.eat();\n        Bear.eat();\n\n    } \n }','all animals eat\nall animals eat\nall animals eat\nEat salmon\n\nIt is allowed to call a static method of the class on an instance \nvariable, but it is confusing and not recomneded. \n\nstatic variables are not overriden by subclass methods they are hidden\n\nso, at runtime there will be no polymorphism for static methods','General',1,NULL),(1817,'public class Hello<T> {\n    public static void main(String[] args){\n        Animal cat = new Animal(5);\n        Animal bear = new Bear();\n        \n        cat.eat();\n        Animal.eat();\n        bear.eat();\n        Bear.eat();\n\n    } \n }\n\nclass Animal{\n    private int size;\n    public Animal(int s){\n        size = s;\n    }\n    public static void eat(){\n        System.out.println(\"all animals eat\");\n    }\n    public void makeSound(){\n            System.out.println(\"Sound!\");\n            \n    }\n    \n    public int getSize(){\n        return size;\n    }\n\n    public boolean equals(Object o){\n        // equals without instanceof \n        if(((Animal)o).getSize() == this.size){\n            return true;\n        } else {\n            return false;\n        }\n        \n    }\n}\n\nclass Bear extends Animal{\n    private static int ALLBEARSAREBIG = 100;\n    \n    public Bear(){\n        super(ALLBEARSAREBIG);\n        \n    }\n    \n    public void eat(){\n        System.out.println(\"Eat salmon\");\n    }\n    \n}','will not compile you cannot override a static method\n\nto fix change eat in Bear to static or do something else with the other class\nand varialbes','General',1,NULL),(1818,'public class Hello<T> {\n    public static void main(String[] args){\n        Animal cat = new Animal(5);\n        Animal bear = new Bear();\n        \n        cat.eat();\n        Animal.eat();\n        bear.eat();\n        Bear.eat();\n\n    } \n }\n\nclass Animal{\n    private int size;\n    public Animal(int s){\n        size = s;\n    }\n    public static void eat(){\n        System.out.println(\"all animals eat\");\n    }\n    public void makeSound(){\n            System.out.println(\"Sound!\");\n            \n    }\n    \n    public int getSize(){\n        return size;\n    }\n\n    public boolean equals(Object o){\n        // equals without instanceof \n        if(((Animal)o).getSize() == this.size){\n            return true;\n        } else {\n            return false;\n        }\n        \n    }\n}\n\nclass Bear extends Animal{\n\n    \n    public Bear(){\n        \n    }\n    \n    public static void eat(){\n        System.out.println(\"Eat salmon\");\n    }\n    \n}\n\nclass Flower {\n    public void pretty(){\n        System.out.println(\"i look so pretty\");\n    }\n}','will not compile,\n\ncall to super in Bear defautl constructor does not fit with ANimal int constructor\n\nremeber if you provide a parameterized constructor the implicit defautl one\ngoes away','General',1,NULL),(1819,'Path p1 = Paths.get(\"/home/maxbisesi/file.txt\");\n        System.out.println(p1.resolve(null));','Will not compile, reference to resolve is ambiguous. \n\nboth resolve(String) and resolve(Path) match','Input/Output',1,NULL),(1820,'public class Hello {\n\n    public static void main(String[] args) {\n        \n        Burnable stick = new Burnable(){\n            int people = 8;\n            public void burn(){\n                System.out.println(\"Theres \"+people+\" people here so get the fire going\");\n            }\n            \n            public int unburn(){\n                System.out.println(\"That\'s impossible\");\n                return 0;\n            }\n            \n            public void shakeoff(int x){\n                System.out.println(\"That was my shoe!\"+x);\n            }\n            \n            public void shakeoff(){\n                \n                this.shakeoff(4);\n                System.out.println(\"its off\");\n            }\n            \n            \n            \n        };\n        \n        stick.burn();\n    }\n\n}\n\ninterface Burnable{\n    int people = 10;\n    void burn();\n    void shakeoff(int z);\n    int unburn();\n}','Compiles fine! you can use the overloaded method within the inner class\n\nTheres 8 people here so get the fire going','Inner Classes',1,NULL),(1821,'The thread is the worker and the runnable is the job to be done','','Threads',1,NULL),(1822,'Thread Constructors','Thread()\nThread(Runnable target)\nThread(Runnable target, String name)\nThread(String name)','Threads',1,NULL),(1823,'When is a thread considered dead?','after the run() is complete','Threads',1,NULL),(1824,'Nothing is guarenteed in threading other than Each thread will start and each thread\nwill run to completion. ','It is not guarenteed that the threads will be started in the order that\nthey are declared. Or that they will finish and start at the same time\n\nor that a loop will complete once it has begun.','Threads',1,NULL),(1825,'The order in which runnable threads are chosen to run is not guarenteed.','','Threads',1,NULL),(1826,'public class Hello {\n    public static void main(String[] dicks){\n       Thread t = new Thread(new FooRunnable());\n       t.start();\n              \n\n    }\n}\n\nclass FooRunnable implements Runnable {\n    public void run(){\n        for(int x = 1; x <= 100; x++){\n            if((x % 10) == 0){\n                System.out.println(\"next 10\");\n            }\n            System.out.println(x+\" \");\n            Thread.sleep(1000); \n            }\n            \n        }\n    }\n}','Will not compile, unreported Exception InteruptedException must be caught\nor thrown. ','Threads',1,NULL),(1827,'A thread gets a default priority that is the default priority of the thread of\nexecution that creates it. ','','Threads',1,NULL),(1828,'FooRunnable r = new FooRunnable();\nThread t = new Thread(r);\nt.setPriority(8);\nt.start();\n','default thread priority is 5','Threads',1,NULL),(1829,'Thread class constants ','Thread.MIN_PRIORITY (1)\nThread.NORM_PRIORITY (5)\nThread.MAX_PRIORITY (10)\n','Threads',1,NULL),(1830,'Thread.yeild()','will cause a thread to go from running to runnable, but it might not do\nanything at all. ','Threads',1,NULL),(1831,'join() is static','FALSE','Threads',1,NULL),(1832,'Thread t = new Thread();\nt.start();\nt.join();','takes the currently running thread(if this were in the main method then that\nwould be the main thread) and joins it onto the end of the thread\nreferenced by t. \n\n','Threads',1,NULL),(1833,'public class Hello implements Runnable{\n    private synchronized Account acct = new Account(50);\n    \n    public static void main(String[] dicks){\n       Hello h = new Hello();\n       Thread one = new Thread(h);\n       Thread two = new Thread(h);\n       one.setName(\"Max\");\n       two.setName(\"Angela\");\n       \n       one.start();\n       two.start();\n\n    }\n    \n    public void run(){\n        for(int x = 0; x < 5; x++){\n            makeWithdrawl(10);\n            if(acct.getBalance() < 0){\n                System.out.println(\"account is overdrawn\");\n            }\n        }\n    }\n    \n    private synchronized void makeWithdrawl(int amt){\n        //this operation is not atomic\n        if(acct.getBalance() >= amt){\n            System.out.println(Thread.currentThread().getName()+\" is going to withdraw\");\n            \n            try{\n                Thread.sleep(500);\n            } catch(InterruptedException e){\n                \n            }\n            \n            acct.withdraw(amt);\n            System.out.println(Thread.currentThread().getName() + \" completes the withdraw\");\n        } else {\n            System.out.println(\"insufficinet funds for: \" + Thread.currentThread().getName() );\n        }\n    }\n}','will not compile, only methods or blocks can be synchronized not variables\nor classes','Threads',1,NULL),(1834,'If a thread goes to sleeep it holds any locks it has','','Threads',1,NULL),(1835,'private JPanel createAddFlashCardPanel() {\n        JPanel jp = new JPanel(new FlowLayout());\n        \n        \n        JTextArea ja = new JTextArea(17,78);\n        ja.setWrapStyleWord(true);\n        JScrollPane question = new JScrollPane(ja);\n        ja.setTabSize(5);\n        ja.setFont(textfont);\n        \n        \n        AbstractDocument doc = (AbstractDocument) ja.getDocument();\n        doc.addDocumentListener(new TextChanger());\n        \n        class TextChanger implements DocumentListener {\n\n        @Override\n        public void insertUpdate(DocumentEvent e) {\n            try{\n                String addedtext = doc.getText(e.getOffset(), e.getLength());\n                System.out.println(addedtext);\n            } catch(BadLocationException blexc){\n                \n            }\n        }\n        @Override\n        public void removeUpdate(DocumentEvent e) {\n            \n        }\n        @Override\n        public void changedUpdate(DocumentEvent e) {\n            \n        }\n       \n    }\n  \n    ','will not compile, method local inner classes must be declared before they \nare used. ','Threads',1,NULL),(1836,' private SwingWorker<String, String> worker = new SwingWorker<String, String>() {\n        public String doInBackground() {\n            while (!searchwords.isEmpty()) {\n                String word = searchwords.poll();\n                if(word == null){\n                    continue;\n                }\n                \n                try{\n                    ArrayList<Card> foundcards = Database.searchDatabase(word);\n                } catch (IOException e){\n                    System.out.println(\"problem serarch db\");\n                }\n\n                for (Card c : foundcards) {\n\n                }\n\n            }\n        }','will not compile, foundcards is defined only in the scope of the try{}\n\nto fix \n\nput it above try{ } ','Threads',1,NULL),(1837,'public static synchronized int getCount() {\n	return count;\n}\n\nhow to could this method be re made excactly using a synchronized block ?','public static int getCount() {\n	synchronized(MyClass.class) {\n		return count;\n	}\n}\n\n- there is only one copyy of static data you\'re trying to protect so you\nonly need one lock per class to synchronize static methods- a lock for the whole class.\n\nevery class loaded in java has a corresponding instance of java.lang.Class\nrepresenting that Class. It\'s that Class instance used to lock on \nstatic methods. ','Threads',1,NULL),(1838,'public class Hello extends Thread {\n   StringBuilder sb;\n    \n    public Hello(StringBuilder stb){\n        sb = stb;\n    }\n   \n    \n    public static void main(String[] dicks){\n        StringBuilder sbmain = new StringBuilder(\"A\");  \n        Hello a = new Hello(sbmain);\n        Hello b = new Hello(sbmain);\n        Hello c = new Hello(sbmain);\n        a.start();\n        b.start();\n        c.start();\n    }\n    \n    public void run(){\n        \n        synchronized(sb){\n            for(int i = 0; i < 100; i++){\n                System.out.println(sb);\n            }\n            sb.append(\"A\");  \n        }\n    }\n}','100x A\n\n100x AA\n\n100x AAA\n\nall these threads synchronize onto the same object','Threads',1,NULL),(1839,'public class Hello extends Thread {\n   StringBuilder sb;\n    \n    public Hello(StringBuilder stb){\n        sb = stb;\n    }\n   \n    public static void main(String[] dicks){\n        StringBuilder sbmain = new StringBuilder(\"A\");  \n        Hello a = new Hello(sbmain);\n        Hello b = new Hello(sbmain);\n        Hello c = new Hello(sbmain);\n        a.start();\n        b.start();\n        c.start();\n    }  \n    public void run(){\n            for(int i = 0; i < 1000; i++){\n                System.out.println(i+\" \"+sb);\n            }\n            sb.append(\"A\");   \n    }\n}','un predicatable results - without synch. you cannot be sure what thread will\nwill be executing when. ','Threads',1,NULL),(1840,'Threads calling non-static synchronized methods in the same class will only\nblock each other if they\'re invoked using THE SAME INSTANCE. that\'s because theyeach\nlock on this instance, and if they\'re called using two differenct instances,\nthey get two locks, which do not interfere with each other. ','got it','Threads',1,NULL),(1841,'Threads calling static synchronized methods in the same class will always \nblock each other- they all lock on the same class instance. ','got it ','Threads',1,NULL),(1842,'a static synchronized method and a non-static synhcronized method will not block\neach other, ever. the static method locks on a Class instance, while the non\nstatic locks on this instance. These actions do not interfere with each other.','','Threads',1,NULL),(1843,'Generally use synchronization anytime more than one thread is accessing mutable\ndata. Dont worry about local varialbes each thread gets its own copy of those\nTwo threads executing the same method at the same time will use different\ncopiies of local variables.\n	However:\n		do worry about static and non sttaic fields if they contain data that \n		can be changed. ','','Threads',1,NULL),(1844,'public class Hello {\n    \n   public static void main (String [] args){\n       Thing thing = new Thing();\n       \n       new Thread(new Accessor(thing),\"Max\").start();\n       new Thread(new Accessor(thing),\"Bart\").start();\n       new Thread(new Accessor(thing),\"Thread C\").start();\n \n   }\n}\n\nclass Accessor implements Runnable{\n    private Thing thisthing;\n    \n    public Accessor(Thing x){\n        thisthing = x;\n    }\n    \n    public void run(){\n        thisthing.setNonstaticField(5);\n        System.out.println(thisthing.getNonstaticField());\n    }\n}\n\nclass Thing {\n    private static int staticField;\n    private int nonstaticField;\n    \n    public static synchronized int getStaticField(){\n        return staticField;\n    }\n    \n    public static synchronized void setStaticField(int x){\n        //use class not this\n        Thing.staticField = x;\n    }\n    \n    public synchronized int getNonstaticField(){\n        return nonstaticField;\n    }\n    \n    public synchronized void setNonstaticField(int y){\n        this.nonstaticField = y;\n    }\n}','5\n5\n5','Threads',1,NULL),(1845,'public class Hello {\n    \n   public static void main (String [] args){\n       Thing thing = new Thing();\n       \n       new Thread(new Accessor(thing),\"Max\").start();\n       new Thread(new Accessor(thing),\"Bart\").start();\n       new Thread(new Accessor(thing),\"Thread C\").start();\n \n   }\n}\n\nclass Accessor implements Runnable{\n    private Thing thisthing;\n    \n    public Accessor(Thing x){\n        thisthing = x;\n    }\n    \n    public void run(){\n        for(int i = 1; i <= 10; i++){\n            thisthing.setNonstaticField(i);\n            System.out.println(thisthing.getNonstaticField());\n        }\n    }\n}\n\nclass Thing {\n    private static int staticField;\n    private int nonstaticField;\n    \n    public static synchronized int getStaticField(){\n        return staticField;\n    }\n    \n    public static synchronized void setStaticField(int x){\n        //use class not this\n        Thing.staticField = x;\n    }\n    \n    public synchronized int getNonstaticField(){\n        return nonstaticField;\n    }\n    \n    public synchronized void setNonstaticField(int y){\n        this.nonstaticField = y;\n    }\n}','un predictable results, to make predictable\n\nput loop code inside a synhcronized block that locks onto thisthing!','Threads',1,NULL),(1846,'public class Hello {\n    \n   public static void main (String [] args){\n       Thing thing = new Thing();\n       \n       new Thread(new Accessor(thing),\"Max\").start();\n       new Thread(new Accessor(thing),\"Bart\").start();\n       new Thread(new Accessor(thing),\"Thread C\").start();\n \n   }\n}\n\nclass Accessor implements Runnable{\n    private Thing thisthing;\n    \n    public Accessor(Thing x){\n        thisthing = x;\n    }\n    \n    public void run(){\n        synchronized(thisthing){\n            for(int i = 1; i <= 10; i++){\n              thisthing.setNonstaticField(i);\n             System.out.println(thisthing.getNonstaticField());\n         }\n        }\n    }\n}\n\nclass Thing {\n    private static int staticField;\n    private int nonstaticField;\n    \n    public static synchronized int getStaticField(){\n        return staticField;\n    }\n    \n    public static synchronized void setStaticField(int x){\n        //use class not this\n        Thing.staticField = x;\n    }\n    \n    public synchronized int getNonstaticField(){\n        return nonstaticField;\n    }\n    \n    public synchronized void setNonstaticField(int y){\n        this.nonstaticField = y;\n    }\n}','run:\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n','Threads',1,NULL),(1847,'class SynchronizedRGB {\n\n    // Values must be between 0 and 255.\n    private int red;\n    private int green;\n    private int blue;\n    private String name;\n\n    private void check(int red,\n                       int green,\n                       int blue) {\n        if (red < 0 || red > 255\n            || green < 0 || green > 255\n            || blue < 0 || blue > 255) {\n            throw new IllegalArgumentException();\n        }\n    }\n\n    public SynchronizedRGB(int red,\n                           int green,\n                           int blue,\n                           String name) {\n        check(red, green, blue);\n        this.red = red;\n        this.green = green;\n        this.blue = blue;\n        this.name = name;\n    }\n\n    public void set(int red,\n                    int green,\n                    int blue,\n                    String name) {\n        check(red, green, blue);\n        synchronized (this) {\n            this.red = red;\n            this.green = green;\n            this.blue = blue;\n            this.name = name;\n        }\n    }\n\n    public synchronized int getRGB() {\n        return ((red << 16) | (green << 8) | blue);\n    }\n\n    public synchronized String getName() {\n        return name;\n    }\n\n    public synchronized void invert() {\n        red = 255 - red;\n        green = 255 - green;\n        blue = 255 - blue;\n        name = \"Inverse of \" + name;\n    }\n}','SynchronizedRGB must be used carefully to avoid being seen in an inconsistent state. Suppose, for example, a thread executes the following code:\n\nSynchronizedRGB color =\n    new SynchronizedRGB(0, 0, 0, \"Pitch Black\");\n...\nint myColorInt = color.getRGB();      //Statement 1\nString myColorName = color.getName(); //Statement 2\n\nIf another thread invokes color.set after Statement 1 but before Statement 2, the value of myColorInt won\'t match the value of myColorName. To avoid this outcome, the two statements must be bound together:\n\nsynchronized (color) {\n    int myColorInt = color.getRGB();\n    String myColorName = color.getName();\n} \n\nThis kind of inconsistency is only possible for mutable objects — it will not be an issue for the immutable version of SynchronizedRGB.','Threads',1,NULL),(1848,'public class Hello {\n    \n   public static void main (String [] args){\n       Thing thing = new Thing();\n       \n       new Thread(new Accessor(thing),\"Max\").start();\n       new Thread(new Accessor(thing),\"Bart\").start();\n       new Thread(new Accessor(thing),\"Thread C\").start();\n       new Thread(new staticAccessor(),\"stat Max\").start();\n       new Thread(new staticAccessor(),\"stat bart\").start();\n       new Thread(new staticAccessor(),\"stat c\").start();\n \n   }\n}\n\nclass Accessor implements Runnable{\n    private Thing thisthing;\n    \n    public Accessor(Thing x){\n        thisthing = x;\n    }\n    \n    public void run(){\n        synchronized(thisthing){\n            for(int i = 1; i <= 10; i++){\n              thisthing.setNonstaticField(i);\n             System.out.println(thisthing.getNonstaticField());\n         }\n        }\n    }\n}\n\nclass staticAccessor implements Runnable {\n    \n    public void run(){\n        synchronized(Thing.class){\n            for(int i = 30; i > 10; i--){\n                Thing.setStaticField(i);\n                System.out.println(Thing.getStaticField()+\" \");\n            }\n        }\n    }\n    \n}','run:\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n30 \n29 \n28 \n27 \n26 \n25 \n24 \n23 \n22 \n21 \n20 \n19 \n18 \n17 \n16 \n15 \n14 \n13 \n12 \n11 \n30 \n29 \n28 \n27 \n26 \n25 \n24 \n23 \n22 \n21 \n20 \n19 \n18 \n17 \n16 \n15 \n14 \n13 \n12 \n11 \n30 \n29 \n28 \n27 \n26 \n25 \n24 \n23 \n22 \n21 \n20 \n19 \n18 \n17 \n16 \n15 \n14 \n13 \n12 \n11 \n\n','Threads',1,NULL),(1849,'class DeadlockRisk {\n    private static class Resource {\n        public int value;\n    }\n    \n    private Resource resA = new Resource();\n    private Resource resB = new Resource();\n    \n    public int read() {\n        synchronized(resA) { // may deadlock\n            synchronized(resB) {\n                return resB.value + resA.value;\n            }\n        }\n    }\n    \n    public void write(int a, int b){\n        synchronized(resB){//may deadlock\n            synchronized(resA){\n                resA.value = a;\n                resB.value = b;\n            }\n        }\n    }\n}','this class may deadlock','Threads',1,NULL),(1850,'wait() notify() and notifyAll() must be called from within a synhcronized\ncontext! A thread can\'t invoke a wait or notify method on an object unless it owns \nthat object\'s lock','','Threads',1,NULL),(1851,'public class Hello {\n    \n   public static void main (String [] args){\n       \n       ThreadB b = new ThreadB();\n       b.start();\n       \n       synchronized(b) {\n           try {\n               System.out.println(\"waiting for b to complete...\");\n               b.wait();\n           } catch(InterruptedException e) { }\n           \n           System.out.println(\"Total is \" + b.total);\n       }\n \n   }\n  \n}\n\nclass ThreadB extends Thread {\n       int total;\n       \n       public void run() {\n           synchronized(this) {\n               for(int i = 0; i<100; i++){\n                   total += i;\n               }\n               \n               notify();\n           }\n       }\n   }','run:\nwaiting for b to complete...\nTotal is 4950\n\n','Threads',1,NULL),(1852,'public class Hello {\n    \n   public static void main (String [] args){\n       \n       ThreadB b = new ThreadB();\n       b.start();\n       \n       synchronized(this) {\n           try {\n               System.out.println(\"waiting for b to complete...\");\n               b.wait();\n           } catch(InterruptedException e) { }\n           \n           System.out.println(\"Total is \" + b.total);\n       }\n \n   }\n  \n}','will not compile non static variable this cannot be referenced from\na static context. ','Threads',1,NULL),(1853,'use notifyAll() to signal all waiting threads,\nnotify() will only signal one unspecified thread.','','Threads',1,NULL),(1854,'public class Hello {\n    \n   public static void main (String [] args){\n      \n        Calculator cal = new Calculator();\n        new Reader(cal).start();\n        new Reader(cal).start();\n        new Reader(cal).start();\n\n   }\n  \n}\n\nclass Reader extends Thread {\n    Calculator c;\n    \n    public Reader(Calculator calc) {\n        c = calc;\n    }\n    \n    public void run(){\n        synchronized(c) {\n            try {\n                System.out.println(\"Waiting for calc\");\n                    c.wait();\n            } catch(InterruptedException e){ }\n                \n            System.out.println(\"Total is: \"+ c.total);\n            \n        }\n    }\n}\n\nclass Calculator implements Runnable {\n    int total;\n    \n    public void run() {\n        synchronized(this) {\n            for(int i = 0; i < 100; i++){\n                total += i;\n            }\n            notifyAll();\n        }\n    }\n}','this programm will wait indefinately, \nbecause the calculator was never started so the threads will continuously\nwait for it. ','Threads',1,NULL),(1855,'public class Hello {\n    \n   public static void main (String [] args){\n      \n        Calculator cal = new Calculator();\n        new Reader(cal).start();\n        new Reader(cal).start();\n        new Reader(cal).start();\n        new Thread(cal).start();\n\n   }\n  \n}\n\nclass Reader extends Thread {\n    Calculator c;\n    \n    public Reader(Calculator calc) {\n        c = calc;\n    }\n    \n    public void run(){\n        synchronized(c) {\n            try {\n                System.out.println(\"Waiting for calc\");\n                    c.wait();\n            } catch(InterruptedException e){ }\n                \n            System.out.println(\"Total is: \"+ c.total);\n            \n        }\n    }\n}\n\nclass Calculator implements Runnable {\n    int total;\n    \n    public static void run() {\n        synchronized(this) {\n            for(int i = 0; i < 100; i++){\n                total += i;\n            }\n            notifyAll();\n        }\n    }\n}','will not compile, run() in Calculator cannot override run() in Runnable\noverriding method is static','Threads',1,NULL),(1856,'public String getSection(){\n	String[] sections = {\"ABD\",\"AfG\",\"HTL\",\"AtL\",\"MAX\",\"AKH\",\"TYU\"};	\n     List<String> sectionList = Collections.asList(sections);\n     Collections.shuffle(sectionList);\n     String ret = sectionList.get(counter);\n	counter++;\n	return ret;\n}','Will not compile Collections.asList() does not exist \n\nyour thinking of Arrays.asList();','Threads',1,NULL),(1857,' public String getSection(){\n            String[] sections = {\"ABD\",\"AfG\",\"HTL\",\"AtL\",\"MAX\",\"AKH\",\"TYU\"};\n            ArrayList sectionList = Arrays.asList(sections); \n            Collections.shuffle(sectionList);\n            String ret = sectionList.get(counter);\n            counter++;\n            return ret;\n        }','will not compile, \n\nList<String> coming from Arrays.asList cannot be converted to ArrayList.\n\nTherefore secionList should be a List<String>\n','Threads',1,NULL),(1858,'class CodeMaker{\n    private String code = \": \";\n    private static int counter = 0;\n    private String[] sections = {\"ABD\",\"AfG\",\"HTL\",\"AtL\",\"MAX\",\"AKH\",\"TYU\"};\n    \n    \n    class SectionGenerator implements Runnable{\n        //private static int counter = 0; cannot have static members in inner class\n           \n        public String getSection(){\n            \n            synchronized(CodeMaker.class){\n                //sections.size()\n                if(counter < sections.length){\n                    String sec = sections[counter];\n                    counter++;\n                    return sec;\n                }\n            }\n            return null;\n        }\n        \n        public void run() {\n            code += getSection() + \" : \";\n        }\n\n    }\n    \n    public void coder(){\n        for(int i = 0; i < 7; i++){\n            new Thread(new SectionGenerator()).start();\n        }\n        System.out.println(\"code: \"+code);\n    }\n    \n    \n}','It will print an undeterminable series of codes though they will be in order,\n\nthe getSection() method has a block that is synchronized on the CodeMake.class\nobject but that only protects static methods.\n\nso when one thread is synched on CodeMaker.class no other thread can execute \nthat same block of code, here it is no applicable because all the threads \nhave the same block of code. That counter is the same for all threads,\nwhile the sections array is copied across all instances. The array is \nnot mutated in any way though. ','Threads',1,NULL),(1859,'class CodeMaker{\n    private String code = \": \";\n    private String[] sections = {\"ABD\",\"AfG\",\"HTL\",\"AtL\",\"MAX\",\"AKH\",\"TYU\"};\n    \n    \n    class SectionGenerator implements Runnable{\n        private static int counter = 0;\n           \n        public String getSection(){\n            \n            synchronized(CodeMaker.class){\n                //sections.size()\n                if(counter < sections.length){\n                    String sec = sections[counter];\n                    counter++;\n                    return sec;\n                }\n            }\n            return null;\n        }\n        \n        public void run() {\n            code += getSection() + \" : \";\n        }\n\n    }\n    \n    public void coder(){\n        for(int i = 0; i <= 7; i++){\n            new Thread(new SectionGenerator()).start();\n        }\n        System.out.println(\"code: \"+code);\n    }\n    \n    \n}','will not compile illegal modifier static in inner class, \n\nto fix you would have to make counter final but that would defeat the\npurpose of having a counter!','Threads',1,NULL),(1860,'class CodeMaker{\n    private String code = \": \";\n    private static int counter = 0;\n    private String[] sections = {\"ABD\",\"AfG\",\"HTL\",\"AtL\",\"MAX\",\"AKH\",\"TYU\"};\n    \n    \n    class SectionGenerator implements Runnable{\n           \n        public String getSection(){\n            \n            synchronized(CodeMaker.class){\n                if(counter < sections.size()){\n                    String sec = sections[counter];\n                    counter++;\n                    return sec;\n                }\n            }\n            return null;\n        }\n        \n        public void run() {\n            code += getSection() + \" : \";\n        }\n\n    }\n    \n    public void coder(){\n        for(int i = 0; i <= 7; i++){\n            new Thread(new SectionGenerator()).start();\n        }\n        System.out.println(\"code: \"+code);\n    }\n    \n    \n}','will not compile, an array does not have a size() method \nit has a length attribute','Threads',1,NULL),(1861,'class CodeMaker{\n    private String code = \": \";\n    private static int counter = 0;\n    private String[] sections = {\"ABD\",\"AfG\",\"HTL\",\"AtL\",\"MAX\",\"AKH\",\"TYU\"};\n    \n    \n    class SectionGenerator implements Runnable{\n           \n        public String getSection(){\n            \n                if(counter < sections.length){\n                    String sec = sections[counter];\n                    counter++;\n                    return sec;\n                }\n            \n            return null;\n        }\n        \n        public void run() {\n            code += getSection() + \" : \";\n        }\n\n    }\n    \n    public void coder(){\n        for(int i = 0; i <= 7; i++){\n            new Thread(new SectionGenerator()).start();\n        }\n        System.out.println(\"code: \"+code);\n    }\n    \n    \n}','code: : AfG : HTL : AtL : MAX : \ncode: : ABD : AfG : HTL : AtL : MAX : AKH : TYU : \ncode: : ABD : AfG : HTL : AtL : MAX : AKH : TYU :\ncode: : ABD : HTL : AtL : MAX : AKH : TYU : \ncode: : ABD : AfG : HTL : AtL : MAX : AKH : TYU : \n\n...results from a few different runs. Without synchronization you cannot\nbe sure what will print because one thread could come in bewteen execution\nof getSection() and disrupt the results. This however will not change the\norder in which the code are retrieved because no matter \nhow choatic the threads execute there is no code that will\ncause static int counter to decrease or increase more than one. \n','Threads',1,NULL),(1862,'class CodeMaker{\n    private String code = \": \";\n    private int counter = 0;\n    private static String[] sections = {\"ABD\",\"AfG\",\"HTL\",\"AtL\",\"MAX\",\"AKH\",\"TYU\"};\n    \n    \n    class SectionGenerator implements Runnable{\n           \n        public String getSection(){\n            \n            synchronized(CodeMaker.class){\n            \n                if(counter < sections.length){\n                    String sec = sections[counter];\n                    counter++;\n                    return sec;\n                }\n                \n                return null;\n                \n            }\n            \n            \n        }\n        \n        public void run() {\n            code += getSection() + \" : \";\n        }\n\n    }\n    \n    public void coder(){\n        for(int i = 0; i <= 7; i++){\n            new Thread(new SectionGenerator()).start();\n        }\n        System.out.println(\"code: \"+code);\n    }\n    \n    \n}\n\npublic class Hello {\n    \n   public static void main (String [] args){\n      new CodeMaker().coder();\n\n   }\n  \n}','This code will not print accurate results as in it will not reliably\nprint all the sections. \n\nThis is becaue the reading of a code and tacking it into the complete \ncode is not an atomic operation. \n\nto uniformly print all the codes you would do this:\n\n	class SectionGenerator implements Runnable{\n\n        public void run() {\n            synchronized(CodeMaker.class){\n            \n                if(counter < sections.length){\n                    String sec = sections[counter];\n                    counter++;\n                    code += sec + \" : \";\n                }\n\n                \n            }\n        }\n\n    }','Threads',1,NULL),(1863,'class CodeMaker{\n    private String code = \": \";\n    private int counter = 0;\n    private static String[] sections = {\"ABD\",\"AfG\",\"HTL\",\"AtL\",\"MAX\",\"AKH\",\"TYU\"};\n    \n    \n    class SectionGenerator implements Runnable{\n\n        public void run() {\n            synchronized(CodeMaker.class){\n            \n                if(counter < sections.length){\n                    String sec = sections[counter];\n                    counter++;\n                    code += sec + \" : \";\n                }\n\n                \n            }\n        }\n\n    }\n    \n    public void coder(){\n        for(int i = 0; i <= 7; i++){\n            new Thread(new SectionGenerator()).start();\n        }\n        System.out.println(\"code: \"+code);\n    }\n    \n    \n}\n\npublic class Hello {\n    \n   public static void main (String [] args){\n      new CodeMaker().coder();\n\n   }\n  \n}','will print:\n\ncode: : ABD : AfG : HTL : AtL : MAX : AKH : TYU :\n\nevery time. \n\nin previous questions counter was not static, if that were the case here\nresults would not be predictable. ','Threads',1,NULL),(1864,'public class Hello {\n    \n   public static void main (String [] args){\n      new CodeMaker().coder();\n\n   }\n  \n}\n\nclass CodeMaker{\n    private String code = \": \";\n    private int counter = 0;\n    private static String[] sections = {\"ABD\",\"AfG\",\"HTL\",\"AtL\",\"MAX\",\"AKH\",\"TYU\"};\n    \n    \n    class SectionGenerator implements Runnable{\n\n        public void run() {\n            synchronized(CodeMaker.class){\n            \n                if(counter < sections.length){\n                    String sec = sections[counter];\n                    counter++;\n                    code += sec + \" : \";\n                }\n                \n            }\n        }\n\n    }\n    \n    public void coder(){\n        for(int i = 0; i <= 7; i++){\n            new Thread(new SectionGenerator()).start();\n        }\n        System.out.println(\"code: \"+code);\n    }\n    \n    \n}','will produce unpredictable results because counter is not static, so\nits access is not locked by synchronization onto CodeMaker.class\n','Threads',1,NULL),(1865,'class statPrinter {\n    private int counter = 0;\n    \n    class Adder implements Runnable {\n        \n        public void run(){\n                //Thread.sleep(1000); with no try\n                counter++;\n                System.out.println(counter + \", Adder +1 \");  \n        }\n    }\n    \n    class Minuser implements Runnable {\n        public void run() {\n                counter--;\n                System.out.println(counter+\", Minuser -1 \");    \n        }\n    }\n    \n    public void test(){\n        for(int i = 0; i < 100; i++){\n            new Thread(new Adder()).start();\n            new Thread(new Minuser()).start();\n            \n        }\n    }\n}','without synchronization here the results will be wildly unpredictable.','Threads',1,NULL),(1866,'class statPrinter {\n    private int counter = 0;\n    \n    class Adder implements Runnable {\n        \n        public void run(){\n                Thread.sleep(1000); \n                counter++;\n                System.out.println(counter + \", Adder +1 \");  \n        }\n    }\n    \n    class Minuser implements Runnable {\n        public void run() {\n                Thread.sleep(500);\n                counter--;\n                System.out.println(counter+\", Minuser -1 \");    \n        }\n    }\n    \n    public void test(){\n        for(int i = 0; i < 100; i++){\n            new Thread(new Adder()).start();\n            new Thread(new Minuser()).start();\n            \n        }\n    }\n}','will not compile, unreported interrupt exception coming from \nThread.sleep();\n\nmust wrap in try catch or declare it to be thrown','Threads',1,NULL),(1867,'class statPrinter {\n    private int counter = 0;\n    \n    class Adder implements Runnable {\n        \n        public synchronized void run(){\n                counter++;\n                System.out.println(counter + \", Adder +1 \");  \n        }\n    }\n    \n    class Minuser implements Runnable {\n        public synchronized void run() {\n                counter--;\n                System.out.println(counter+\", Minuser -1 \");    \n        }\n    }\n    \n    public void test(){\n        for(int i = 0; i < 100; i++){\n            new Thread(new Adder()).start();\n            new Thread(new Minuser()).start();\n            \n        }\n    }\n}','These results are unpredicatable, \n\nyes run() can be synched, these two methods synchronize on the current\nobject, all that means is that theyre code \n\n	counter++;\n     System.out.println(counter+\", Minuser -1 \"); \n\n	counter--;\n      System.out.println(counter+\", Minuser -1 \"); 	\n\nwill run in order completely without being interrupted by another thread.\n\nhowever that does not stop another thread from jumping the gun and being\nrun twice though!\n\n','Threads',1,NULL),(1868,'class statPrinter {\n    private int counter = 0;\n    \n    class Adder implements Runnable {\n        \n        public void run(){\n            synchronized(this){\n                counter++;\n                System.out.println(counter + \", Adder +1 \");  \n            }\n        }\n    }\n    \n    class Minuser implements Runnable {\n        public void run() {\n            synchronized(this){\n                counter--;\n                System.out.println(counter+\", Minuser -1 \");   \n            }\n        }\n    }\n    \n    public void test(){\n        for(int i = 0; i < 100; i++){\n            new Thread(new Adder()).start();\n            new Thread(new Minuser()).start();\n            \n        }\n    }\n}','this will give unpredictable results, \n\npublic void run() {\n            synchronized(this){\n                counter--;\n                System.out.println(counter+\", Minuser -1 \");   \n            }\n        }\n\nis the same as\n\npublic synchronized void run(){\n	...\n}\n\n\nthey both lock onto the current obejct, meaning no other thread can\naccess that object. The variable of concern here though is counter which\nis a variable of the statPrinter object. ','Threads',1,NULL),(1869,'class CodeMaker{\n    private String code;\n    private int counter;\n    private static String[] sections;\n    private ArrayList<String> al;\n    \n    public CodeMaker(){\n        code = \": \";\n        counter = 0;\n        sections = {\"ABD\",\"AfG\",\"HTL\",\"AtL\",\"MAX\",\"AKH\",\"TYU\"};\n        al = new ArrayList<>();\n    }\n    \n    \n    class SectionGenerator implements Runnable{\n\n        public void run() {\n            synchronized(CodeMaker.class){\n            \n                if(counter < sections.length){\n                    String sec = sections[counter];\n                    counter++;\n                    code += sec + \" : \";\n                }\n                \n            }\n        }\n\n    }\n    \n    public void coder(){\n        for(int i = 0; i <= 10; i++){\n            new Thread(new SectionGenerator()).start();\n        }\n        System.out.println(\"code: \"+code);\n    }\n    \n    \n}','Will not compile you cannot intitialize an array with shorthand like that.\nBecause, at the time of creation java wants to know excactly how \nmuch memory to allocate when you jsut create the reference you basically\ncreate nothing.\n\nin the constructor you whene you initialize you have to excplicitly\ncreate the memory with the new array using new. \n\nto compile do this:\n	\n	sections = new String[]{\"ABD\",\"AfG\",\"HTL\",\"AtL\",\"MAX\",\"AKH\",\"TYU\"};','Threads',1,NULL),(1870,'class CodeMaker{\n    private String code;\n    private int counter;\n    private static String[] sections;\n    private ArrayList<String> al;\n    \n    public synchronized CodeMaker(){\n        code = \": \";\n        counter = 0;\n        sections = new String[]{\"ABD\",\"AfG\",\"HTL\",\"AtL\",\"MAX\",\"AKH\",\"TYU\"};\n        al = new ArrayList<>();\n    }\n    \n    \n    class SectionGenerator implements Runnable{\n\n        public void run() {\n            synchronized(CodeMaker.class){\n            \n                if(counter < sections.length){\n                    String sec = sections[counter];\n                    counter++;\n                    code += sec + \" : \";\n                }\n                \n            }\n        }\n\n    }\n    \n    public void coder(){\n        for(int i = 0; i <= 10; i++){\n            new Thread(new SectionGenerator()).start();\n        }\n        System.out.println(\"code: \"+code);\n    }\n    \n    \n}','will not compile, Constructors cannot be synchronized. ','Threads',1,NULL),(1871,'class CodeMaker  extends Thread {\n    private String code;\n    private int counter;\n    private ArrayList<String> al;\n    private char[] letters = {\'A\',\'B\',\'C\',\'D\',\'E\',\'F\',\'G\',\'H\',\'I\'};\n    \n    public CodeMaker(){\n        counter = 0;\n        al = new ArrayList<>();\n    }\n\n    class SectionGenerator implements Runnable{\n        private String sec = \"\";\n        private Random ran;\n\n        public void run() {\n            //tried to use notify outside of synchronized context\n            synchronized(this){\n                int x = ran.nextInt(3);\n                int y = ran.nextInt(3);\n                int z = ran.nextInt(3);\n            \n            \n                sec += letters[x];\n                sec += letters[y];\n                sec += letters[z];\n                notifyAll();\n            }\n        }\n        \n        public synchronized String section(){\n            return sec;\n        }\n\n    }\n    \n    class NumberGenerator implements Runnable{\n        private String number = \"\";\n        private Random ran;\n        \n        public void run(){\n            //tried to use notify outside of synchronized context\n            synchronized(this){\n                int x1 = ran.nextInt(100);\n                int x2 = ran.nextInt(100);\n                int x3 = ran.nextInt(100);\n            \n                number+= x1+\".\"+x2+\".\"+x3;\n                notifyAll();\n            }\n        }\n        \n        public synchronized String Number(){\n            return number;\n        }\n    }\n    \n   public void run(){\n       \n       SectionGenerator sg1 = new SectionGenerator();\n       NumberGenerator ng1 = new NumberGenerator();\n       Thread t1 = new Thread(sg1);\n       Thread t2 = new Thread(ng1);\n       \n       t1.start();\n       t2.start();\n       \n       t1.wait();\n       code += sg1.section();\n       t2.wait();\n       code += ng1.Number();\n       \n       System.out.println(code);\n\n       \n   }\n    \n    \n}\n','will not compile becaue of wait(),\n\nureported exception, interruptedexception, must be caught or thrown\n\n','Threads',1,NULL),(1872,'class CodeMaker  extends Thread {\n    private String code;\n    private int counter;\n    private ArrayList<String> al;\n    private char[] letters = {\'A\',\'B\',\'C\',\'D\',\'E\',\'F\',\'G\',\'H\',\'I\'};\n    \n    public CodeMaker(){\n        counter = 0;\n        al = new ArrayList<>();\n    }\n\n    class SectionGenerator implements Runnable{\n        private String sec = \"\";\n        private Random ran;\n\n        public void run() {\n            //tried to use notify outside of synchronized context\n            synchronized(this){\n                int x = ran.nextInt(3);\n                int y = ran.nextInt(3);\n                int z = ran.nextInt(3);\n            \n            \n                sec += letters[x];\n                sec += letters[y];\n                sec += letters[z];\n                notifyAll();\n            }\n        }\n        \n        public synchronized String section(){\n            return sec;\n        }\n\n    }\n    \n    class NumberGenerator implements Runnable{\n        private String number = \"\";\n        private Random ran;\n        \n        public void run(){\n            //tried to use notify outside of synchronized context\n            synchronized(this){\n                int x1 = ran.nextInt(100);\n                int x2 = ran.nextInt(100);\n                int x3 = ran.nextInt(100);\n            \n                number+= x1+\".\"+x2+\".\"+x3;\n                notifyAll();\n            }\n        }\n        \n        public synchronized String Number(){\n            return number;\n        }\n    }\n    \n   public void run() throws InterruptedException {\n       \n       SectionGenerator sg1 = new SectionGenerator();\n       NumberGenerator ng1 = new NumberGenerator();\n       Thread t1 = new Thread(sg1);\n       Thread t2 = new Thread(ng1);\n       \n       t1.start();\n       t2.start();\n       \n       t1.wait();\n       code += sg1.section();\n       t2.wait();\n       code += ng1.Number();\n       \n       System.out.println(code);\n\n       \n   }\n    \n    \n}','will not compile, not a proper override of run(),\n\noverrides cannot throw new or broader checked exceptions','Threads',1,NULL),(1873,'public class Hello extends Thread {\n    public static void main(String[] args){\n        new CodeMaker().start();\n    }\n}\n\nclass CodeMaker  extends Thread {\n    private String code;\n    private int counter;\n    private ArrayList<String> al;\n    private char[] letters = {\'A\',\'B\',\'C\',\'D\',\'E\',\'F\',\'G\',\'H\',\'I\'};\n    \n    public CodeMaker(){\n        counter = 0;\n        al = new ArrayList<>();\n    }\n\n    class SectionGenerator implements Runnable{\n        private String sec = \"\";\n        private Random ran;\n\n        public void run() {\n            //tried to use notify outside of synchronized context\n            synchronized(this){\n                int x = ran.nextInt(3);\n                int y = ran.nextInt(3);\n                int z = ran.nextInt(3);\n            \n            \n                sec += letters[x];\n                sec += letters[y];\n                sec += letters[z];\n                notifyAll();\n            }\n        }\n        \n        public synchronized String section(){\n            return sec;\n        }\n\n    }\n    \n    class NumberGenerator implements Runnable{\n        private String number = \"\";\n        private Random ran;\n        \n        public void run(){\n            //tried to use notify outside of synchronized context\n            synchronized(this){\n                int x1 = ran.nextInt(100);\n                int x2 = ran.nextInt(100);\n                int x3 = ran.nextInt(100);\n            \n                number += x1+\".\"+x2+\".\"+x3;\n                notifyAll();\n            }\n        }\n        \n        public synchronized String Number(){\n            return number;\n        }\n    }\n    \n   public synchronized void run(){\n       \n       SectionGenerator sg1 = new SectionGenerator();\n       NumberGenerator ng1 = new NumberGenerator();\n       Thread t1 = new Thread(sg1);\n       Thread t2 = new Thread(ng1);\n       \n       t1.start();\n       t2.start();\n       \n       try{\n        t1.wait();\n        code += sg1.section();\n        t2.wait();\n        code += ng1.Number();\n       } catch(InterruptedException e){\n           \n       }\n       System.out.println(code);\n\n       \n   }\n    \n    \n}','NPE, ran is nevere intitialized. ','Threads',1,NULL),(1874,'public class Hello extends Thread {\n    public static void main(String[] args){\n        new CodeMaker().start();\n    }\n}\n\nclass CodeMaker  extends Thread {\n    private String code;\n    private int counter;\n    private ArrayList<String> al;\n    private char[] letters = {\'A\',\'B\',\'C\',\'D\',\'E\',\'F\',\'G\',\'H\',\'I\'};\n    \n    public CodeMaker(){\n        counter = 0;\n        al = new ArrayList<>();\n    }\n\n    class SectionGenerator implements Runnable{\n        private String sec = \"\";\n        private Random ran = new Random();\n\n        public void run() {\n            //tried to use notify outside of synchronized context\n            synchronized(this){\n                int x = ran.nextInt(3);\n                int y = ran.nextInt(3);\n                int z = ran.nextInt(3);\n            \n            \n                sec += letters[x];\n                sec += letters[y];\n                sec += letters[z];\n                notifyAll();\n            }\n        }\n        \n        public synchronized String section(){\n            return sec;\n        }\n\n    }\n    \n    class NumberGenerator implements Runnable{\n        private String number = \"\";\n        private Random ran = new Random();\n        \n        public void run(){\n            //tried to use notify outside of synchronized context\n            synchronized(this){\n                int x1 = ran.nextInt(100);\n                int x2 = ran.nextInt(100);\n                int x3 = ran.nextInt(100);\n            \n                number += x1+\".\"+x2+\".\"+x3;\n                notifyAll();\n            }\n        }\n        \n        public synchronized String Number(){\n            return number;\n        }\n    }\n    \n   public synchronized void run(){\n       \n       SectionGenerator sg1 = new SectionGenerator();\n       NumberGenerator ng1 = new NumberGenerator();\n       Thread t1 = new Thread(sg1);\n       Thread t2 = new Thread(ng1);\n       \n       t1.start();\n       t2.start();\n       \n       try{\n        t1.wait();\n        code += sg1.section();\n        t2.wait();\n        code += ng1.Number();\n       } catch(InterruptedException e){\n           \n       }\n       System.out.println(code);\n\n       \n   }\n    \n    \n}','IllegalMonitorStateException, ','Threads',1,NULL),(1875,'public class Hello extends Thread {\n    public static void main(String[] args){\n        \n    }\n    \n    class Operator extends Thread {\n        Machine machine = new Machine();\n        Machine.MachineInstructions job;\n        \n        public void run(){\n            while(true){\n                String shape = getShapeFromUser();\n                job = calculateNewInstructionsFor(shape);\n                \n                machine.addJob(job);\n            }\n        }\n        \n        public Machine.MachineInstructions calculateNewInstructionsFor(String x){\n            // dah duh duu da du\n            return machine.new MachineInstructions();\n        }\n        \n        public String getShapeFromUser(){\n            System.out.println(\"What shape? square ok thanks\");\n            return \"Square\";\n        }\n        \n    }\n    \n    class Machine extends Thread {\n        List<MachineInstructions> joblist = new ArrayList<>(0);\n        \n        public void addJob(MachineInstructions job){\n            synchronized(joblist){\n                joblist.add(job);\n                joblist.notify();\n            }\n        }\n        \n        public void run(){\n            while(true) {\n                synchronized(joblist) {\n                    //wait until at least one job is available\n                    while(joblist.isEmpty()) {\n                        try{\n                            joblist.wait();\n                        } catch(InterruptedException ei){\n                            \n                        }\n                        \n                        //if we get here you know the list is\'nt empty\n                        MachineInstructions inst = joblist.remove(0);\n                        \n                    }\n                }\n            }\n        }\n        \n        \n        static class MachineInstructions {\n            \n        }\n    }\n}','will not compile, static classes are not allowed in inner classes,\n\nonly static final varialbe definitions is allowed.','Threads',1,NULL),(1876,'public class Hello extends Thread {\n    public static void main(String[] args){\n        new Operator().start();\n        new Machine().start();\n    }\n    \n    class Operator extends Thread {\n        Machine machine = new Machine();\n        Machine.MachineInstructions job;\n        \n        public void run(){\n            while(true){\n                String shape = getShapeFromUser();\n                job = calculateNewInstructionsFor(shape);\n                \n                machine.addJob(job);\n            }\n        }\n        \n        public Machine.MachineInstructions calculateNewInstructionsFor(String x){\n            // dah duh duu da du\n            return machine.new MachineInstructions(x);\n        }\n        \n        public String getShapeFromUser(){\n            System.out.println(\"What shape? square ok thanks\");\n            return \"Square\";\n        }\n        \n    }\n    \n    class Machine extends Thread {\n        List<MachineInstructions> joblist = new ArrayList<>();\n        \n        public void addJob(MachineInstructions job){\n            synchronized(joblist){\n                joblist.add(job);\n                joblist.notify();\n            }\n        }\n        \n        public void run(){\n            while(true) {\n                synchronized(joblist) {\n                    //wait until at least one job is available\n                    while(joblist.isEmpty()) {\n                        try{\n                            joblist.wait();\n                        } catch(InterruptedException ei){\n                            \n                        }\n                        \n                        //if we get here you know the list is\'nt empty\n                        MachineInstructions inst = joblist.remove(0);\n                        \n                        \n                    }\n                }\n            }\n        }\n        \n        \n        class MachineInstructions {\n            private String shape;\n            \n            public MachinInstructions(String shape){\n                this.shape = shape;\n            }\n            public void produceShape(){\n                System.out.println(\"Here\'s your :\"+shape);\n            }\n            \n        }\n    }\n}','will not compile, non static inner classes cannot be accessed from static\nmain','Threads',1,NULL),(1877,'public class Hello extends Thread {\n    Operator op = new Operator();\n    Machine m = new Machine();\n    public static void main(String[] args){\n        op.start();\n        m.start();\n    }\n    \n    class Operator extends Thread {\n        Machine machine = new Machine();\n        Machine.MachineInstructions job;\n        \n        public void run(){\n            while(true){\n                String shape = getShapeFromUser();\n                job = calculateNewInstructionsFor(shape);\n                \n                machine.addJob(job);\n            }\n        }\n        \n        public Machine.MachineInstructions calculateNewInstructionsFor(String x){\n            // dah duh duu da du\n            return machine.new MachineInstructions(x);\n        }\n        \n        public String getShapeFromUser(){\n            System.out.println(\"What shape? square ok thanks\");\n            return \"Square\";\n        }\n        \n    }\n    \n    class Machine extends Thread {\n        List<MachineInstructions> joblist = new ArrayList<>();\n        \n        public void addJob(MachineInstructions job){\n            synchronized(joblist){\n                joblist.add(job);\n                joblist.notify();\n            }\n        }\n        \n        public void run(){\n            while(true) {\n                synchronized(joblist) {\n                    //wait until at least one job is available\n                    while(joblist.isEmpty()) {\n                        try{\n                            joblist.wait();\n                        } catch(InterruptedException ei){\n                            \n                        }\n                        \n                        //if we get here you know the list is\'nt empty\n                        MachineInstructions inst = joblist.remove(0);\n                        \n                        \n                    }\n                }\n            }\n        }\n        \n        \n        class MachineInstructions {\n            private String shape;\n            \n            public MachinInstructions(String shape){\n                this.shape = shape;\n            }\n            public void produceShape(){\n                System.out.println(\"Here\'s your :\"+shape);\n            }\n            \n        }\n    }\n}','will not compile non static instance variable cannot be referenced \nfrom static main','Threads',1,NULL),(1878,'public class Hello extends Thread {\n    private static Operator op = new Operator();\n    private static Machine m = new Machine();\n    public static void main(String[] args){\n        op.start();\n        m.start();\n    }\n    \n    class Operator extends Thread {\n        Machine machine = new Machine();\n        Machine.MachineInstructions job;\n        \n        public void run(){\n            while(true){\n                String shape = getShapeFromUser();\n                job = calculateNewInstructionsFor(shape);\n                \n                machine.addJob(job);\n            }\n        }\n        \n        public Machine.MachineInstructions calculateNewInstructionsFor(String x){\n            // dah duh duu da du\n            return machine.new MachineInstructions(x);\n        }\n        \n        public String getShapeFromUser(){\n            System.out.println(\"What shape? square ok thanks\");\n            return \"Square\";\n        }\n        \n    }\n    \n    class Machine extends Thread {\n        List<MachineInstructions> joblist = new ArrayList<>();\n        \n        public void addJob(MachineInstructions job){\n            synchronized(joblist){\n                joblist.add(job);\n                joblist.notify();\n            }\n        }\n        \n        public void run(){\n            while(true) {\n                synchronized(joblist) {\n                    //wait until at least one job is available\n                    while(joblist.isEmpty()) {\n                        try{\n                            joblist.wait();\n                        } catch(InterruptedException ei){\n                            \n                        }\n                        \n                        //if we get here you know the list is\'nt empty\n                        MachineInstructions inst = joblist.remove(0);\n                        \n                        \n                    }\n                }\n            }\n        }\n        \n        \n        class MachineInstructions {\n            private String shape;\n            \n            public MachinInstructions(String shape){\n                this.shape = shape;\n            }\n            public void produceShape(){\n                System.out.println(\"Here\'s your :\"+shape);\n            }\n            \n        }\n    }\n}','will not compile non static variable this cannot be reference from a static\ncontext. \n\nthe inner classes are instance classes so, even though you define \nthe variables as static they have to use this to access the inner class\n\nso it will still not compile','Threads',1,NULL),(1879,'public class Hello extends Thread {\n \n    public static void main(String[] args){\n        Hello h = new Hello();\n        h.new Operator().start();\n        h.new Machine().start();\n    }\n    \n    class Operator extends Thread {\n        Machine machine = new Machine();\n        Machine.MachineInstructions job;\n        \n        public void run(){\n            while(true){\n                String shape = getShapeFromUser();\n                job = calculateNewInstructionsFor(shape);\n                \n                machine.addJob(job);\n            }\n        }\n        \n        public Machine.MachineInstructions calculateNewInstructionsFor(String x){\n            // dah duh duu da du\n            return machine.new MachineInstructions(x);\n        }\n        \n        public String getShapeFromUser(){\n            System.out.println(\"What shape? square ok thanks\");\n            return \"Square\";\n        }\n        \n    }\n    \n    class Machine extends Thread {\n        List<MachineInstructions> joblist = new ArrayList<>();\n        \n        public void addJob(MachineInstructions job){\n            synchronized(joblist){\n                joblist.add(job);\n                joblist.notify();\n            }\n        }\n        \n        public void run(){\n            while(true) {\n                synchronized(joblist) {\n                    //wait until at least one job is available\n                    while(joblist.isEmpty()) {\n                        try{\n                            joblist.wait();\n                        } catch(InterruptedException ei){\n                            \n                        }\n                        \n                        //if we get here you know the list is\'nt empty\n                        MachineInstructions inst = joblist.remove(0);\n                        \n                        \n                    }\n                }\n            }\n        }\n        \n        \n        class MachineInstructions {\n            private String shape;\n            \n            public MachineInstructions(String shape){\n                this.shape = shape;\n            }\n            public void produceShape(){\n                System.out.println(\"Here\'s your :\"+shape);\n            }\n            \n        }\n    }\n}','will produce: \n	What shape? square ok thanks\n	What shape? square ok thanks\n	What shape? square ok thanks\n	What shape? square ok thanks\n...ad infinum\n\nThe conintinuos loops are meant to keep checking for new shapes. \n\nnotice that one of the threads is alwasy synched in with the jobslist\n\nthey then use wait and notify to bounce back and forth.','Threads',1,NULL),(1880,'public class Hello extends Thread {\n \n    public static void main(String[] args){\n        Hello h = new Hello();\n        h.new Operator().start();\n        h.new Machine().start();\n    }\n    \n    class Operator extends Thread {\n        Machine machine = new Machine();\n        Machine.MachineInstructions job;\n        \n        public void run(){\n            while(true){\n                String shape = getShapeFromUser();\n                job = calculateNewInstructionsFor(shape);\n                \n                machine.addJob(job);\n            }\n        }\n        \n        public Machine.MachineInstructions calculateNewInstructionsFor(String x){\n            // dah duh duu da du\n            return machine.new MachineInstructions(x);\n        }\n        \n        public String getShapeFromUser(){\n            System.out.println(\"What shape? square ok thanks\");\n            return \"Square\";\n        }\n        \n    }\n    \n    class Machine extends Thread {\n        List<MachineInstructions> joblist = new ArrayList<>();\n        \n        public void addJob(MachineInstructions job){\n            synchronized(joblist){\n                joblist.add(job);\n                joblist.notify();\n            }\n        }\n        \n        public void run(){\n            while(true) {\n                    //wait until at least one job is available\n                    while(joblist.isEmpty()) {\n                        try{\n                            joblist.wait();\n                        } catch(InterruptedException ei){\n                            \n                        }\n                        \n                        //if we get here you know the list is\'nt empty\n                        MachineInstructions inst = joblist.remove(0);\n                        \n                        \n                    }\n            }\n        }\n        \n        \n        class MachineInstructions {\n            private String shape;\n            \n            public MachineInstructions(String shape){\n                this.shape = shape;\n            }\n            public void produceShape(){\n                System.out.println(\"Here\'s your :\"+shape);\n            }\n            \n        }\n    }\n}','IllegalMonitorStateException\n\nwait in thread machine is called from outside a synchronized context\n\nyou have to synchronized on an object to wait on it. ','Threads',1,NULL),(1881,'public class Hello extends Thread {\n \n    public static void main(String[] args){\n        Hello h = new Hello();\n        h.new Operator().start();\n        h.new Machine().start();\n    }\n    \n    class Operator extends Thread {\n        Machine machine = new Machine();\n        Machine.MachineInstructions job;\n        \n        public void run(){\n            while(true){\n                String shape = getShapeFromUser();\n                job = calculateNewInstructionsFor(shape);\n                \n                machine.addJob(job);\n            }\n        }\n        \n        public Machine.MachineInstructions calculateNewInstructionsFor(String x){\n            // dah duh duu da du\n            return machine.new MachineInstructions(x);\n        }\n        \n        public String getShapeFromUser(){\n            System.out.println(\"What shape? square ok thanks\");\n            return \"Square\";\n        }\n        \n    }\n    \n    class Machine extends Thread {\n        List<MachineInstructions> joblist = new ArrayList<>();\n        \n        public void addJob(MachineInstructions job){\n                joblist.add(job);\n                joblist.notify();\n        }\n        \n        public void run(){\n            while(true) {\n                synchronized(joblist) {\n                    //wait until at least one job is available\n                    while(joblist.isEmpty()) {\n                        try{\n                            joblist.wait();\n                        } catch(InterruptedException ei){\n                            \n                        }\n                        \n                        //if we get here you know the list is\'nt empty\n                        MachineInstructions inst = joblist.remove(0);\n                        \n                        \n                    }\n                }\n            }\n        }\n        \n        \n        class MachineInstructions {\n            private String shape;\n            \n            public MachineInstructions(String shape){\n                this.shape = shape;\n            }\n            public void produceShape(){\n                System.out.println(\"Here\'s your :\"+shape);\n            }\n            \n        }\n    }\n}','IllegalMonitorStateException, \n\nnotify() in addJob is called without being synched with joblist.\n\nyou have to be synched on an object to wait on it or notify it.\n\nRemember you wait and notify objects not threads. ','Threads',1,NULL),(1882,'//ignore the answer try to figure out what wrong with this thin\npublic class Hello extends Thread {\n \n    public static void main(String[] args){\n        Hello h = new Hello();\n        h.new Operator().start();\n        h.new Machine().start();\n        new ButterFinger().start();\n    }\n    \n    class Operator extends Thread {\n        Machine machine = new Machine();\n        Machine.MachineInstructions job;\n        \n        public void run(){\n            while(true){\n                String shape = getShapeFromUser();\n                job = calculateNewInstructionsFor(shape);\n                \n                machine.addJob(job);\n            }\n        }\n        \n        public Machine.MachineInstructions calculateNewInstructionsFor(String x){\n            // dah duh duu da du\n            return machine.new MachineInstructions(x);\n        }\n        \n        public String getShapeFromUser(){\n            System.out.println(\"What shape? square ok thanks\");\n            return \"Square\";\n        }\n        \n    }\n    \n    class Machine extends Thread {\n        private List<MachineInstructions> joblist = new ArrayList<>();\n        \n        public void addJob(MachineInstructions job){\n            synchronized(joblist){\n                joblist.add(job);\n                joblist.notifyAll();\n            }\n        }\n        \n        public void run(){\n            while(true) {\n                synchronized(joblist) {\n                    //wait until at least one job is available\n                    while(joblist.isEmpty()) {\n                        try{\n                            joblist.wait();\n                        } catch(InterruptedException ei){\n                            \n                        }\n                        \n                        //if we get here you know the list is\'nt empty\n                        MachineInstructions inst = joblist.remove(0);\n                        \n                        \n                    }\n                }\n            }\n        }\n        \n        \n        class MachineInstructions {\n            private String shape;\n            \n            public MachineInstructions(String shape){\n                this.shape = shape;\n            }\n            public void produceShape(){\n                System.out.println(\"Here\'s your :\"+shape);\n            }\n            \n        }\n    }\n     \n}\n\nclass ButterFinger extends Thread {\n    private Hello h = new Hello();\n    private Hello.Machine machine = h.new Machine();\n    \n        public void run(){\n            while(true){\n                machine.addJob(machine.new MachineInstructions(\"Whoops I fucked up\"));\n            }\n            \n        }\n}','Here butterfingers is unable to get his meaty claws on the same machine \nthe operator is using becasue those two are instance classes created \nin static main, joblist is an instance variable so the one they are \nusing belongs to the instance created in main. \n\nButterFinger created his own seperated machine to fuck with here, good\nso the output will be \n\nWhat shape? square ok thanks\nWhat shape? square ok thanks\nWhat shape? square ok thanks\nWhat shape? square ok thanks     for ever and ever. ','Threads',1,NULL),(1883,'public class Hello extends Thread {\n    Operator op = new Operator();\n    Machine m = new Machine();\n \n    public static void main(String[] args){\n       Hello h = new Hello();\n       h.op.start();\n       h.m.start();\n    }\n    \n    class Operator extends Thread {\n        Machine machine = new Machine();\n        Machine.MachineInstructions job;\n        \n        public void run(){\n            while(true){\n                String shape = getShapeFromUser();\n                job = calculateNewInstructionsFor(shape);\n                \n                machine.addJob(job);\n            }\n        }\n        \n        public Machine.MachineInstructions calculateNewInstructionsFor(String x){\n            // dah duh duu da du\n            return machine.new MachineInstructions(x);\n        }\n        \n        public String getShapeFromUser(){\n            System.out.println(\"What shape? square ok thanks\");\n            return \"Square\";\n        }\n        \n    }\n    \n    class Machine extends Thread {\n        private List<MachineInstructions> joblist = new ArrayList<>();\n        \n        public void addJob(MachineInstructions job){\n            synchronized(joblist){\n                joblist.add(job);\n                joblist.notifyAll();\n            }\n        }\n        \n        public void run(){\n            while(true) {\n                synchronized(joblist) {\n                    //wait until at least one job is available\n                    while(joblist.isEmpty()) {\n                        try{\n                            joblist.wait();\n                        } catch(InterruptedException ei){\n                            \n                        }\n                        \n                        //if we get here you know the list is\'nt empty\n                        MachineInstructions inst = joblist.remove(0);\n                        \n                        \n                    }\n                }\n            }\n        }\n        \n        \n        class MachineInstructions {\n            private String shape;\n            \n            public MachineInstructions(String shape){\n                this.shape = shape;\n            }\n            public void produceShape(){\n                System.out.println(\"Here\'s your :\"+shape);\n            }\n            \n        }\n    }\n     \n}\n\nclass ButterFinger extends Thread {\n    private Hello h = new Hello();\n    \n        public void run(){\n            while(true){\n                h.m.addJob(h.m.new MachineInstructions(\"Whoops I fucked up\"));\n            }\n            \n        }\n}','Butterfinger now has the right machine however the main method never\nstarts him so the output is still \n\nwhat shape? square ok thanks\nWhat shape? square ok thanks\nWhat shape? square ok thanks\nWhat shape? square ok thanks    forever...\n\nno,\n\n	Operator and Machine have no way to connect. Operator has its own\n	version of machine and therefore does not connect with the machine\n	thread that was started in main. ','Threads',1,NULL),(1884,'public class Hello {\n    public static void main(String[] args){\n        CodeMaker cm = new CodeMaker();\n        \n        for(int i = 0; i<10; i++){\n            cm.start();\n        }\n        \n    }\n}\n\nclass CodeMaker  extends Thread {\n    private String code;\n    private int counter;\n    private ArrayList<String> al;\n    private char[] letters = {\'A\',\'B\',\'C\',\'D\',\'E\',\'F\',\'G\',\'H\',\'I\'};\n    \n    public CodeMaker(){\n        counter = 0;\n        al = new ArrayList<>();\n    }\n\n    class SectionGenerator implements Runnable{\n        private String sec = \"\";\n        private Random ran = new Random();\n\n        public void run() {\n            //tried to use notify outside of synchronized context\n            synchronized(this){\n                int x = ran.nextInt(3);\n                int y = ran.nextInt(3);\n                int z = ran.nextInt(3);\n            \n            \n                sec += letters[x];\n                sec += letters[y];\n                sec += letters[z];\n                notifyAll();\n            }\n        }\n        \n        public synchronized String section(){\n            return sec;\n        }\n\n    }\n    \n    class NumberGenerator implements Runnable{\n        private String number = \"\";\n        private Random ran = new Random();\n        \n        public void run(){\n            //tried to use notify outside of synchronized context\n            synchronized(this){\n                int x1 = ran.nextInt(100);\n                int x2 = ran.nextInt(100);\n                int x3 = ran.nextInt(100);\n            \n                number += x1+\".\"+x2+\".\"+x3;\n                notifyAll();\n            }\n        }\n        \n        public synchronized String Number(){\n            return number;\n        }\n    }\n    \n    \n   public synchronized void run(){\n       \n       SectionGenerator sg1 = new SectionGenerator();\n       NumberGenerator ng1 = new NumberGenerator();\n       Thread t1 = new Thread(sg1);\n       Thread t2 = new Thread(ng1);\n       \n       t1.start();\n       t2.start();\n       \n       try{\n        t1.wait();\n        code += sg1.section();\n        t2.wait();\n        code += ng1.Number();\n       } catch(InterruptedException e){\n           \n       }\n       System.out.println(code);\n   }    ','IllegalMonitorStateException\n\nyou cannot call start() on a thread more than once. ','Threads',1,NULL),(1885,'You can call start() on a Thread object only once, otherwise you get an\nIllegalThreadStateException\n\nyou can however create many threads from the same runnable','','Threads',1,NULL),(1886,'public class Hello implements Runnable {\n\n    public static void main(String[] args) {\n        Thread t = new Thread(new Hello());\n    }\n    \n    public void run() {\n        System.out.println(\"run once\");\n    }\n}\n\n\nwhat state is this thread in ?\n\n','New State\n\nA thread that is created but not yet started is in the new state and not yet alive','Threads',1,NULL),(1887,'Once a thread is started it goes into the runnable state,\n\nThe schedular can move a thread back and forth between the runnable state and \nthe running state. \n\nA running thread may enter a blocked / waiting state by a wait, sleep, or join \ncall\n\na running thread can enter the blocked/ waiting state because it cant acquire the lock \nfor a synchroized block\n\na dead thread cannot be started again.',' got it ? ','Threads',1,NULL),(1888,'sleeping is used to delay execution for a period of time and .. \n\nno locks are released when a thread goes to sleep','','Threads',1,NULL),(1889,'A sleeping thread is thread is guarenteed to sleep for at least the time specified\nin the argument to sleep() but there is not guarentee is actually return to running\n\nthe sleep mehtod is static so it only affects the currently running thread. ','','Threads',1,NULL),(1890,'unless explicitly set a thread\'s priority will have the same priority as the thread\nthat created it. ','','Threads',1,NULL),(1891,'when one thread call join() on another thread, the currently running thhread\nwill wait until the thread it joins with has completed. Think of join() as saying\n\n\"Hey thread I want to join on to the end of you. let me know when you\'re done, so \nI can enter the runnable state\"','','Threads',1,NULL),(1892,'While only one thread can be accessing synchronized code of a particular\ninstance, multiple threads can still access the same object\'s unsynchronized code.\n\nWhen a thread goes to sleep its locks will be unavailable to other threads.','','Threads',1,NULL),(1893,'Object.wait() = add me to your waiting list.','','Threads',1,NULL),(1894,'notify() is used to send a signal to onne and onnly one of the threads that \nare waiting, it cannot specify which thread will be notified.','','Threads',1,NULL),(1895,'wait() notify() and notifyAll() must called from within a synchronized context\nthe synchronization must be with the object that the thread is calling one of these\nmethhods on !','','Threads',1,NULL),(1896,'Runnable target = new MyRunnable();\nThread myThread = new Thread(target);\n\n\npublic class MyRunnable extends Runnable{public void run(){}}\npublic class MyRunnable implements Runnable{public void start{}}\npublic class MyRunnable implements Runnable{public void run(){}}\n','the third one','Threads',1,NULL),(1897,'public class Hello extends Thread {\n    public static void main(String[] args){\n       Hello h = new Hello();\n       Thread x = new Thread(h);\n       h.start();\n        \n    }\n    \n    public void run() {\n        for(int i=0; i<3; ++i)\n            System.out.print(i+\"...\");\n    }\n}','0..1..2..','Threads',1,NULL),(1898,'public class Hello {\n    public static void main(String[] args){\n       printAll(args);\n        \n    }\n    \n    public static void printAll(String[] lines){\n        for(int i = 0; i<lines.length; i++){\n            System.out.println(lines[i]);\n            Thread.currentThread().sleep(1000);\n        }\n    }\n}\n\nwhat is the result','will not compile .sleep() must be enclosed in a try block to catch its\nInterruptedException','Threads',1,NULL),(1899,'you have two private variables a and b. prevent concurrent access problems using\ntheir read() and set(int a, int b){} methods.','public synchronized int read() { return a+b; }\npublic synchronized void set(int a, int b){this.a = a; this.b = b;}\n\npublic int read(){ synchronized(this){ return a+b; } }\npublic void set(int a, int b){synchronized(this){ this.a = a; this.b = b;} }\n\n\n','Threads',1,NULL),(1900,'public class WaitTest {\n	public static void main(String[] args){\n		sout(\"1\");\n		synchronized(args){\n			sout(\"2\");\n			try{\n				args.wait();\n			} catch(InterruptedException e) {\n			}\n		}\n		sout(\"3\");\n	}\n}\n\n1. IllegalMonitorStateException\n2. will not compile\n3. 1 2 3\n4. 1 2\n5. fails to compile because of wait() illegalMonitorstatexception','1 2 \n\nIllegalMonitorStateException is unchecked and thrown by trying to wait\nsomething yyou do not own the lock to!','Threads',1,NULL),(1901,'\'the following method is called from thread A on an object B and it is properly synchronized\n\nwait(2000);\n\nafter calling the method when will thread A becoma a canidate to get another \nturn at the CPU ?\n\'','\'After object B is notified, or after two seconds. \n\nUPDATE ANIMATION !\'','\'Threads\'',1,NULL),(1902,'which are true ?\n\n1 the notifyAll() must be called from a synchronized context\n2 to call wati() an object must own the lock on the thread\n3 the notify() method is defined in class java.lang.thread\n4 when a thread is waiting as a result of wait() it releases its lock\n5 notify() method causes a thread to imeediately release its lock\n6 the difference between notify() and notifyAll() is that notifyAll() notifies\nall waiting threads regardless of the object theyre waiting on','1 4','Threads',1,NULL),(1903,'public class Logger {\n	private StringBuilder contents = new StringBuilder();\n	public void log(String mess){\n		contents.append(System.currentTimeMillis());\n		contents.append(\": \");\n		contents.append(Thread.currentThread().getName());\n		contents.append(mess);\n	}\n\n	public String getContents() { return contents.toString(); }\n}\n\nhow can you enxure that instances of this class can be safely used by multiple \nthreads ?\n\nreplace StringBuilder with thread-safe StringBuffer ?','synchronize both log() and getContents()\n\neven though stringbuffer is synchronized internally, append is called \nmultiple times so anythread could get in there in between calls','Threads',1,NULL),(1904,'public static synchronized void main(Stirng[] args) throws InterruptedException {\n	Thread t = new Thread();\n	t.start();\n	sout(\"X\");\n	t.wait(10000);\n	sout(\"y\");\n}','IllegalMonitorStateException is thrown because the main thread does not \nhave a lock on t before it decides to wait on it. ','Threads',1,NULL),(1905,'class MyThread extends Thread {\n	MyThread() {\n		sout(\"MyThread\");\n	}\n	public void run(){\n		sout(\"bar\");\n	}\n\n	public void run(String s){\n		sout(\"baz\");\n	}\n}\n\npublic class Test {\n	psvm(sa){\n		Thread t = new MyThread(){\n			public void run(){\n				sout(\"foo\");\n			}\n		};\n		t.start();\n	}\n}\n		','MyThread foo','Threads',1,NULL),(1906,'public class Hello {\n    public static void main(String[] args){\n       WatchService watchService\n          = FileSystems.getDefault().newWatchService();\n \n        Path path = Paths.get(System.getProperty(\"user.home\"));\n \n        path.register(\n          watchService, \n            StandardWatchEventKinds.ENTRY_CREATE, \n              StandardWatchEventKinds.ENTRY_DELETE, \n                StandardWatchEventKinds.ENTRY_MODIFY);\n \n        WatchKey key;\n        while ((key = watchService.take()) != null) {\n            for (WatchEvent<?> event : key.pollEvents()) {\n                System.out.println(\n                  \"Event kind:\" + event.kind() \n                    + \". File affected: \" + event.context() + \".\");\n            }\n            key.reset();\n        }\n        \n    }\n    \n    \n}','will not compile unreported IOException from newWatchService() and \npath.register()','Input/Output',1,NULL),(1907,'public class Hello {\n    public static void main(String[] args) throws IOException{\n       WatchService watchService\n          = FileSystems.getDefault().newWatchService();\n \n        Path path = Paths.get(System.getProperty(\"user.home\"));\n \n        path.register(\n          watchService, \n            StandardWatchEventKinds.ENTRY_CREATE, \n              StandardWatchEventKinds.ENTRY_DELETE, \n                StandardWatchEventKinds.ENTRY_MODIFY);\n \n        WatchKey key;\n        while ((key = watchService.take()) != null) {\n            for (WatchEvent<?> event : key.pollEvents()) {\n                System.out.println(\n                  \"Event kind:\" + event.kind() \n                    + \". File affected: \" + event.context() + \".\");\n            }\n            key.reset();\n        }\n        \n    }\n    \n    \n}','will not compile take() throws an InterruptedException because \nit will wait if there are no events present','Input/Output',1,NULL),(1908,'public class Hello {\n    public static void main(String[] args) throws IOException, InterruptedException {\n       WatchService watchService\n          = FileSystems.getDefault().newWatchService();\n \n        Path path = Paths.get(System.getProperty(\"user.home\"));\n \n        path.register(\n          watchService, \n            StandardWatchEventKinds.ENTRY_CREATE, \n              StandardWatchEventKinds.ENTRY_DELETE, \n                StandardWatchEventKinds.ENTRY_MODIFY);\n \n        WatchKey key;\n        while ((key = watchService.take()) != null) {\n            for (WatchEvent<?> event : key.pollEvents()) {\n                System.out.println(\n                  \"Event kind:\" + event.kind() \n                    + \". File affected: \" + event.context() + \".\");\n            }\n            key.reset();\n        }\n        \n    }\n    \n    \n}','compiles fine if you were to delete a file from home directory \nyou would get a notice like this: \n	\n	Event kind:ENTRY_CREATE. File affected: Untitled Document.\n\n','Input/Output',1,NULL),(1909,'public class Hello {\n    public static void main(String[] args) throws IOException {\n       WatchService watchService\n          = FileSystems.getDefault().newWatchService();\n \n        Path path = Paths.get(System.getProperty(\"user.home\"));\n \n        path.register(\n          watchService, \n            StandardWatchEventKinds.ENTRY_CREATE, \n              StandardWatchEventKinds.ENTRY_DELETE, \n                StandardWatchEventKinds.ENTRY_MODIFY);\n \n        WatchKey key;\n        while ((key = watchService.poll()) != null) {\n            for (WatchEvent<?> event : key.pollEvents()) {\n                System.out.println(\n                  \"Event kind:\" + event.kind() \n                    + \". File affected: \" + event.context() + \".\");\n            }\n            key.reset();\n        }\n        \n    }\n    \n    \n}','this would run one time, if there were no WatchEvents immediately available\nit would end.\nPoll() gets events and does not wait. \n\n','Input/Output',1,NULL),(1910,'Path path = Paths.get(\"/home\");\nWatchService watchService = FileSystems.getDefault().newWatchService();\nWatchKey watchKey = path.register(watchService,ENTRY_CREATE,ENTRY_DELETE,ENTRY_MODIFY);\n\nprivate boolean notDone = true;\nwhile(notDone){\n    try{\n         WatchKey watchKey = watchService.poll(60,TimeUnit.SECONDS);\n         List<WatchEvent.Kind<?>> events = watchKey.pollEvents();\n         for(WatchEvent event : events){\n            ...process the events\n         }\n         if(!watchKey.reset()){\n            ...handle situation no longer valid\n         }\n     }catch(InterruptedException e){\n            Thread.currentThread().interrupt();\n     }','...just a good example','Input/Output',1,NULL),(1911,'public class Hello {\n    public static void main(String[] dicks){\n        Thread t1 = new Thread(new Advertiser());\n        Thread t2 = new Thread(new Subleaser());\n    }\n\n}    \n\nclass MessageBoard {\n    private StringBuilder contents = new StringBuilder();\n    \n    public synchronized void postMessage(String s){\n        contents.append(s + \" \");\n    }\n    \n    public synchronized String readBoard(){\n        return contents.toString();\n    }\n    \n    public StringBuilder takeTurnAtBoard(){\n        return contents;\n    }\n}\n\nclass Advertiser implements Runnable{\n    protected MessageBoard mb = new MessageBoard();\n    public void run(){\n        synchronized(mb){\n            mb.postMessage(\"Attention!\");\n            mb.postMessage(\"Platonics\");\n            mb.postMessage(\"Lost Dog! 1000$ reward\");\n            mb.postMessage(\"Sex Change coupon\");\n            \n            System.out.println(mb.readBoard());\n        } \n    }\n}\n\nclass Subleaser{\n    private MessageBoard mb = new MessageBoard();\n    \n    public void run(){\n        synchronized(mb){\n            mb.postMessage(\"1000 a month!\");\n            mb.postMessage(\"two br\");\n            mb.postMessage(\"no dogs allowed!\");\n        }\n    }\n}','will not compile, Subleaser does not implemnet runnable!\n\nAlso the two threads synchronize on their very own messageboards so \nthey have no problem getting access to them and printing their messages.\n\nSecondly Nothing is ever printed from the MessageBoard.','Threads',1,NULL),(1912,'public class Hello {\n    public static void main(String[] dicks){\n        Thread t1 = new Thread(new Advertiser(),\"advertiser\");\n        Thread t2 = new Thread(new Subleaser(),\"subleaser\");\n        \n        t1.start();\n        t2.start();\n    }\n\n}    \n\nclass MessageBoard {\n    private StringBuilder contents = new StringBuilder();\n    \n    public synchronized void postMessage(String s){\n        contents.append(s);\n        contents.append(\" \");\n    }\n    \n    public synchronized String readBoard(){\n        return contents.toString();\n    }\n    \n    public StringBuilder takeTurnAtBoard(){\n        return contents;\n    }\n}\n\nclass Advertiser implements Runnable{\n    protected MessageBoard mb = new MessageBoard();\n    public void run(){\n            //Thread.getName() static method cannot be called from non static\n            mb.postMessage(Thread.currentThread().getName()+\" \");\n            mb.postMessage(\"Attention!\");\n            mb.postMessage(\"Platonics\");\n            mb.postMessage(\"Lost Dog! 1000$ reward\");\n            mb.postMessage(\"Sex Change coupon\");\n            \n            System.out.println(mb.readBoard());\n        \n    }\n}\n\nclass Subleaser implements Runnable{\n    private MessageBoard mb = new MessageBoard();\n    \n    public void run(){\n            mb.postMessage(Thread.currentThread().getName()+\" \");\n            mb.postMessage(\"1000 a month!\");\n            mb.postMessage(\"two br\");\n            mb.postMessage(\"no dogs allowed!\");\n            \n            System.out.println(mb.readBoard());\n        }\n}','subleaser  1000 a month! two br no dogs allowed! \nadvertiser  Attention! Platonics Lost Dog! 1000$ reward Sex Change coupon \n\nadvertiser  Attention! Platonics Lost Dog! 1000$ reward Sex Change coupon \nsubleaser  1000 a month! two br no dogs allowed!\n\nthese results can be unpredictable, though the methods are synched\nnothing is stopping another thread from coming in between append calls.\n\nto make the ressults truly predictable synchronized the postmessage calls in a block\non mb','Input/Output',1,NULL),(1913,'public class Hello {\n    public static void main(String[] dicks){\n        MessageBoard mb = new MessageBoard();\n        Thread t1 = new Thread(new Advertiser(mb),\"advertiser\");\n        Thread t2 = new Thread(new Subleaser(mb),\"subleaser\");\n        \n        t1.start();\n        t2.start();\n    }\n\n}    \n\nclass MessageBoard {\n    private StringBuilder contents = new StringBuilder();\n    \n    public synchronized void postMessage(String s){\n        contents.append(s);\n        contents.append(\" \");\n    }\n    \n    public synchronized String readBoard(){\n        return contents.toString();\n    }\n    \n    public StringBuilder takeTurnAtBoard(){\n        return contents;\n    }\n}\n\nclass Advertiser implements Runnable{\n    protected MessageBoard mb;\n    \n    public Advertiser(MessageBoard mb){\n        this.mb = mb;\n    }\n    public void run(){\n            //Thread.getName() static method cannot be called from non static\n            mb.postMessage(Thread.currentThread().getName()+\" \");\n            mb.postMessage(\"Attention!\");\n            mb.postMessage(\"Lost Dog! 1000$ reward\");\n            mb.postMessage(\"Sex Change coupon\");\n            \n            System.out.println(mb.readBoard());\n        \n    }\n}\n\nclass Subleaser implements Runnable{\n    private MessageBoard mb;\n    \n    public Subleaser(MessageBoard mb){\n        this.mb = mb;\n    }\n    \n    public void run(){\n            mb.postMessage(Thread.currentThread().getName()+\" \");\n            mb.postMessage(\"two br\");\n            mb.postMessage(\"no dogs allowed!\");\n            mb.postMessage(\"1200$ a month\");\n            \n            System.out.println(mb.readBoard());\n        }\n}\n','these can be quiet unpredictable:\n\n	subleaser  two br no dogs allowed! 1200$ a month advertiser  Attention! Lost Dog! 1000$ reward Sex Change coupon \nsubleaser  two br no dogs allowed! 1200$ a month advertiser  Attention! Lost Dog! 1000$ reward Sex Change coupon \n\nBoth threads are operating on the same instance, that instances objects\nmethods are synchronized but that doesn\'t stop the other thread from coming\ninbetween calls to postMessage()','Input/Output',1,NULL),(1914,'public class Hello {\n    public static void main(String[] dicks){\n        MessageBoard mb = new MessageBoard();\n        Thread t1 = new Thread(new Advertiser(mb),\"advertiser\");\n        Thread t2 = new Thread(new Subleaser(mb),\"subleaser\");\n        \n        t1.start();\n        t2.start();\n    }\n\n}    \n\nclass MessageBoard {\n    private StringBuilder contents = new StringBuilder();\n    \n    public synchronized void postMessage(String s){\n        contents.append(s);\n        contents.append(\" \");\n    }\n    \n    public synchronized String readBoard(){\n        return contents.toString();\n    }\n    \n    public StringBuilder takeTurnAtBoard(){\n        return contents;\n    }\n}\n\nclass Advertiser implements Runnable{\n    protected MessageBoard mb;\n    \n    public Advertiser(MessageBoard mb){\n        this.mb = mb;\n    }\n    public void run(){\n        synchronized(mb){\n            //Thread.getName() static method cannot be called from non static\n            mb.postMessage(Thread.currentThread().getName()+\" \");\n            mb.postMessage(\"Attention!\");\n            mb.postMessage(\"Lost Dog! 1000$ reward\");\n            mb.postMessage(\"Sex Change coupon\");\n            \n            System.out.println(mb.readBoard());\n        }\n    }\n}\n\nclass Subleaser implements Runnable{\n    private MessageBoard mb;\n    \n    public Subleaser(MessageBoard mb){\n        this.mb = mb;\n    }\n    \n    public void run(){\n        synchronized(mb){\n            mb.postMessage(Thread.currentThread().getName()+\" \");\n            mb.postMessage(\"two br\");\n            mb.postMessage(\"no dogs allowed!\");\n            mb.postMessage(\"1200$ a month\");\n            \n            System.out.println(mb.readBoard());\n        }\n        }\n        \n}\n','You can be assured that these results will be predictable,\n\nThe synchronized blocks get a hold of the lock so it is just a compettion\nof which thread will lock first. ','Input/Output',1,NULL),(1915,'public class Hello {\n    public static void main(String[] dicks) throws InterruptedException {\n        try{\n            WatchService watcher = FileSystems.getDefault().newWatchService();\n            Path home = Paths.get(\"/home/maxbisesi\");\n            home.register(watcher, StandardWatchEventKinds.ENTRY_CREATE,StandardWatchEventKinds.ENTRY_DELETE);\n            \n            WatchKey key;\n            \n            //throws interruptedException \n            while((key = watcher.take()) != null) {\n                for(WatchEvent<?> event : key.pollEvents()){\n                    System.out.println(event.context() + \" \" + event.kind());\n              }\n           }\n        } catch(IOException ei){\n            \n        }    \n    }\n\n}    \n\nI delete foo.txt out of the home directory then go into Documents and delete\nindex.html. What is the result ?','foo.txt ENTRY_DELETE\n\n... Watcher only watches one directory at a time, not subdirectories','Input/Output',1,NULL),(1916,'public class Starter implements Runnable {\n	void go(long id) {\n		sout(id);\n	}\n\n	public static void main(String[] args){\n		sout(Thread.currentThread().getId() + \" \");\n		//insert code\n	}\n	public void run() { go(Thread.currentThread().getId()); }\n}\n\n1. new Starter().run();\n2. new Starter().start();\n3. new Thread(new Starter());\n4. new Thread(new Starter()).run();\n5. new Thread(new Starter()).start();','1. 4 4 \n2. does not compile\n3. prints nothign , but starts a new thread\n4. creates a new thread and invokes run() directlyy\n5. creates and starts a new thread. ','Input/Output',1,NULL),(1917,'public class Hello implements Runnable {\n    public void run(){\n        System.out.println(\"r1 \");\n        System.out.println(\"r2 \");\n    }\n    public static void main(String[] args){\n        Thread t = new Thread(new Hello());\n        t.start();\n        System.out.println(\"m1 \");\n        t.join();\n        System.out.println(\"m2 \");\n    }\n}','will not commpile, join throws interruptedexception ','Input/Output',1,NULL),(1918,'public class Hello implements Runnable {\n    public void run(){\n        System.out.println(\"r1 \");\n        System.out.println(\"r2 \");\n    }\n    public static void main(String[] args){\n        Thread t = new Thread(new Hello());\n        t.start();\n        System.out.println(\"m1 \");\n        try{\n            t.join();\n        } catch(InterruptedException e){\n            \n        }\n        System.out.println(\"m2 \");\n    }\n}','could be:\n\nm1 r1 r2 m2\nr1 m1 r2 m2\nr1 r2 m1 m2\n\njoin throws interruptedexception, it causes main to join onto the end\nof the thread t and wait till its done to continue. ','Input/Output',1,NULL),(1919,'public class Hello implements Runnable {\n    Chicks c;\n    public void run(){\n       c.yack(Thread.currentThread().getId());\n    }\n    public static void main(String[] args){\n        new Hello().go();\n       \n    }\n    \n    void go(){\n        c = new Chicks();\n        new Thread(new Hello()).start();\n        new Thread(new Hello()).start();\n    }\n}\n\nclass Chicks {\n    synchronized void yack(long id){\n        for(int x = 1; x <3; x++){\n            System.out.println(id + \" \");\n            Thread.yield();\n        }\n    }\n}','NullpointerException,\n\nthis one is hard to spot but c is initialized in the go method, an \ninstance method. The two threads start their own new instance and go\ndirectly to the run() method, without go() c never gets initialized. \n\nfor this to work c would have to be static. \n','Input/Output',1,NULL),(1920,'public class Hello implements Runnable {\n    static Chicks c;\n    public void run(){\n       c.yack(Thread.currentThread().getId());\n    }\n    public static void main(String[] args){\n        new Hello().go();\n       \n    }\n    \n    void go(){\n        c = new Chicks();\n        new Thread(new Hello()).start();\n        new Thread(new Hello()).start();\n    }\n}\n\nclass Chicks {\n    synchronized void yack(long id){\n        for(int x = 1; x <3; x++){\n            System.out.println(id + \" \");\n            Thread.yield();\n        }\n    }\n}','8\n8\n9\n9','Input/Output',1,NULL),(1921,'public class Hello implements Runnable {\n    static Chicks c;\n    public void run(){\n       c.yack(Thread.currentThread().getId());\n    }\n    public static void main(String[] args){\n        new Hello().go();\n       \n    }\n    \n    void go(){\n        c = new Chicks();\n        new Thread(new Hello()).start();\n        new Thread(new Hello()).start();\n    }\n}\n\nclass Chicks {\n    static long flag = 0;\n    synchronized void yack(long id){\n        if(flag == 0) flag = id;\n        for(int x = 1; x <3; x++){\n            if(flag == id) System.out.println(\"yada yada \");\n            else System.out.println(\"ehh \");\n        }\n    }\n}','','Input/Output',1,NULL),(1922,'public class Hello implements Runnable {\n    public void run(){\n       move(Thread.currentThread().getId());\n    }\n    \n    void move(long id){\n        System.out.println(id + \" \");\n        System.out.println(id + \" \");\n    }\n    public static void main(String[] args){\n        Hello h = new Hello();\n        new Thread(h).start();\n        new Thread(new Hello()).start();\n    }\n}','the output could be 8 9 8 9\n\n..it could be anything really','Input/Output',1,NULL),(1923,'public class Hello implements Runnable {\n    public void run(){\n       move(Thread.currentThread().getId());\n    }\n    \n    synchronized void move(long id){\n        System.out.println(id + \" \");\n        System.out.println(id + \" \");\n    }\n    public static void main(String[] args){\n        Hello h = new Hello();\n        new Thread(h).start();\n        new Thread(new Hello()).start();\n    }\n}','the output could be 4 2 4 2\n\nWhile the method is synhcronized it is being invoked by two different\nobjects so they could print in any order still \n\n','Input/Output',1,NULL),(1924,'test	','test','Input/Output',1,NULL),(1925,'Which method from a CopyOnWriteArrayList will caue a new copy of the internal\narray to be created ?','add  and  remove','Input/Output',1,NULL),(1926,'public class Hello {\n    public static void main(String[] args){\n        new ReentrantLockingDemo().go();\n    }\n}\n\nclass ReentrantLockingDemo {\n\n    final Lock lock = new ReentrantLock();\n\n    public void go() {\n\n        Runnable run1 = newRunable();\n        Thread t1 = new Thread(run1, \"Thread1\");\n        System.out.println(run1.hashCode());\n        t1.start();\n\n        Runnable run2 = newRunable();\n        Thread t2 = new Thread(run2, \"Thread2\");\n        System.out.println(run2.hashCode());\n        t2.start();\n\n    }\n\n    private Runnable newRunable() {\n        return new Runnable() {\n            public int hashCode() {\n                return super.hashCode();\n            }\n            public void run() {\n                do {\n                    try {\n                        if (lock.tryLock(500, TimeUnit.MILLISECONDS)) {\n                            try {\n                                System.out.println(\"locked thread \"\n                                        + Thread.currentThread().getName());\n                                Thread.sleep(1000);\n                            } finally {\n                                lock.unlock();\n                                System.out.println(\"unlocked locked thread \"\n                                        + Thread.currentThread().getName());\n                            }\n                            break;\n                        } else {\n                            System.out.println(\"unable to lock thread \"\n                                    + Thread.currentThread().getName()\n                                    + \" will re try again\");\n                        }\n                    } catch (InterruptedException e) {\n                        e.printStackTrace();\n                    }\n                } while (true);\n            }     \n        };\n    }\n\n}','2018699554\n1311053135\nlocked thread Thread1\nunable to lock thread Thread2 will re try again\nunlocked locked thread Thread1\nlocked thread Thread2\nunlocked locked thread Thread2\n\nThe two threads use two different Runnables, but they are both vying for the same\nlock. ','Input/Output',1,NULL),(1927,'public class ThreadTest {\n	class InnerRun implements Runnable {\n		public void run() {\n			for(int x = 0; x < 100; x++){\n				try{\n					Thread.sleep(5);\n				} catch(Exception e) {}\n				sout( \"Ren\" );\n			}\n		}\n	}\n\n	class InnerRunTwo implements Runnable {\n		Thread other;\n		public InnerRunTwo(Thread x){ other = x; }\n		public void run() {\n			try{\n				other.join();\n			} catch(Exception e) { }\n			for(int x = 0; x < 100; x++){\n			   try{\n				Thread.sleep(5);\n			   } catch( Exception e) { }\n			   sout( \"stimpy\" );\n			}\n		}	\n	}\nvoid start(){\n	InnerRun ir = new InnerRun();\n	Thread t = new Thread(ir);\n	InnerRunTwo irr = new InnerRunTwo(t);\n	Thread u = new Thread(irr);\n		t.start();	\n		u.start();\n}\npsvm(SA){ ThreadTest tt = new ThreadTest(); tt.start(); }\n}','How a join should be used and implemented. \n\n100 Rens followed by 100 stimpys','Input/Output',1,NULL),(1928,'public class Hello {\n    public static void main(String[] args){\n        Data data = new Data();\n        DataThread dt = new DataThread(data);\n        Thread t1 = new Thread(dt);\n        Thread t2 = new Thread(dt);\n        Thread t3 = new Thread(dt);\n        Thread t4 = new Thread(dt);\n        Thread t5 = new Thread(dt);\n        \n        t1.start();\n        t2.start();\n        t3.start();\n        t4.start();\n        t5.start();\n        \n    }\n}\n\nclass Data {\n    public Object lock = new Object();\n    public static Object staticLock = new Object();\n    \n    public synchronized void instanceLocked(){\n        System.out.println(\"Instance locked by: \"+Thread.currentThread().getName());\n    }\n    \n    public static synchronized void classLocked(){\n        System.out.println(\"class locked by: \"+Thread.currentThread().getName());\n        while(true){\n            \n        }\n    }\n}\n\nclass DataThread implements Runnable {\n    private Data data;\n    \n    public DataThread(Data data){\n        this.data = data;\n    }\n    public void run(){\n        synchronized(data.lock){\n            \n            for(int i = 0; i<100; i++){\n                data.instanceLocked();\n                System.out.println(i);\n                \n                try{\n                    Thread.sleep(1000);\n                } catch(InterruptedException e){\n                    \n                }\n            }\n            \n        }\n    }\n    \n}','run:\nInstance locked by: Thread-0\n0\nInstance locked by: Thread-0\n1\nInstance locked by: Thread-0\n2\nInstance locked by: Thread-0\n3\nInstance locked by: Thread-0\n4\nInstance locked by: Thread-0\n5\nInstance locked by: Thread-0\n6\nInstance locked by: Thread-0\n7\nInstance locked by: Thread-0\n8\nInstance locked by: Thread-0\n9\nInstance locked by: Thread-0\n10\nBUILD STOPPED (total time: 10 seconds)\n','Input/Output',1,NULL),(1929,'public class Hello {\n    public static void main(String[] args){\n         final Safelock.Friend alphonse =\n            new Safelock.Friend(\"Alphonse\");\n        final Safelock.Friend gaston =\n            new Safelock.Friend(\"Gaston\");\n        new Thread(new Safelock.BowLoop(alphonse, gaston)).start();\n        new Thread(new Safelock.BowLoop(gaston, alphonse)).start();\n    }\n}\n\nclass Safelock {\n    static class Friend {\n        private final String name;\n        private final Lock lock = new ReentrantLock();\n\n        public Friend(String name) {\n            this.name = name;\n        }\n\n        public String getName() {\n            return this.name;\n        }\n\n        public boolean impendingBow(Friend bower) {\n            Boolean myLock = false;\n            Boolean yourLock = false;\n            try {\n                myLock = lock.tryLock();\n                yourLock = bower.lock.tryLock();\n            } finally {\n                if (! (myLock && yourLock)) {\n                    if (myLock) {\n                        lock.unlock();\n                    }\n                    if (yourLock) {\n                        bower.lock.unlock();\n                    }\n                }\n            }\n            return myLock && yourLock;\n        }\n            \n        public void bow(Friend bower) {\n            if (impendingBow(bower)) {\n                try {\n                    System.out.format(\"%s: %s has\"\n                        + \" bowed to me!%n\", \n                        this.name, bower.getName());\n                    bower.bowBack(this);\n                } finally {\n                    lock.unlock();\n                    bower.lock.unlock();\n                }\n            } else {\n                System.out.format(\"%s: %s started\"\n                    + \" to bow to me, but saw that\"\n                    + \" I was already bowing to\"\n                    + \" him.%n\",\n                    this.name, bower.getName());\n            }\n        }\n\n        public void bowBack(Friend bower) {\n            System.out.format(\"%s: %s has\" +\n                \" bowed back to me!%n\",\n                this.name, bower.getName());\n        }\n    }\n\n    static class BowLoop implements Runnable {\n        private Friend bower;\n        private Friend bowee;\n\n        public BowLoop(Friend bower, Friend bowee) {\n            this.bower = bower;\n            this.bowee = bowee;\n        }\n    \n        public void run() {\n            Random random = new Random();\n            for (;;) {\n                try {\n                    Thread.sleep(random.nextInt(10));\n                } catch (InterruptedException e) {}\n                bowee.bow(bower);\n            }\n        }\n    }\n}','Gaston: Alphonse has bowed to me!\nAlphonse: Gaston started to bow to me, but saw that I was already bowing to him.\nAlphonse: Gaston has bowed back to me!\nAlphonse: Gaston has bowed to me!\nGaston: Alphonse has bowed back to me!\nAlphonse: Gaston has bowed to me!\nGaston: Alphonse has bowed back to me!\nGaston: Alphonse has bowed to me!\nAlphonse: Gaston has bowed back to me!\nAlphonse: Gaston has bowed to me!\nGaston: Alphonse has bowed back to me!\nGaston: Alphonse has bowed to me!\nAlphonse: Gaston has bowed back to me!\nAlphonse: Gaston has bowed to me!\nGaston: Alphonse has bowed back to me!\nGaston: Alphonse has bowed to me!\nAlphonse: Gaston has bowed back to me!\nAlphonse: Gaston has bowed to me!\nGaston: Alphonse has bowed back to me!\nGaston: Alphonse has bowed to me!\nAlphonse: Gaston has bowed back to me!\nGaston: Alphonse has bowed to me!\nAlphonse: Gaston has bowed back to me!\nAlphonse: Gaston has bowed to me!\nGaston: Alphonse has bowed back to me!\nAlphonse: Gaston has bowed to me!\nGaston: Alphonse has bowed back to me!\nGaston: Alphonse has bowed to me!\nAlphonse: Gaston has bowed back to me!\nAlphonse: Gaston has bowed to me!\nGaston: Alphonse has bowed back to me!\nGaston: Alphonse started to bow to me, but saw that I was already bowing to him.\nAlphonse: Gaston has bowed to me!\nGaston: Alphonse has bowed back to me!\nAlphonse: Gaston has bowed to me!\nGaston: Alphonse has bowed back to me!','Input/Output',1,NULL),(1930,'class BoundedBuffer {\n   final Lock lock = new ReentrantLock();\n   final Condition notFull  = lock.newCondition(); \n   final Condition notEmpty = lock.newCondition(); \n\n   final Object[] items = new Object[100];\n   int putptr, takeptr, count;\n\n   public void put(Object x) throws InterruptedException {\n     lock.lock();\n     try {\n       while (count == items.length)\n         notFull.await();\n       items[putptr] = x;\n       if (++putptr == items.length) putptr = 0;\n       ++count;\n       notEmpty.signal();\n     } finally {\n       lock.unlock();\n     }\n   }\n\n   public Object take() throws InterruptedException {\n     lock.lock();\n     try {\n       while (count == 0)\n         notEmpty.await();\n       Object x = items[takeptr];\n       if (++takeptr == items.length) takeptr = 0;\n       --count;\n       notFull.signal();\n       return x;\n     } finally {\n       lock.unlock();\n     }\n   }\n }','good example of Conditions','Input/Output',1,NULL),(1931,'class DataThread implements Runnable {\n    private Data data;\n    private ArrayList listData;\n    \n    public DataThread(Data data){\n        this.data = data;\n    }\n    public void run(){\n            data.lock.lock();\n            try{\n                listData = data.produceData();\n            try{\n               data.done.await();\n            } catch(InterruptedException e){\n                \n            }\n            \n            for(Integer i : listData){\n                System.out.println(i);\n            }\n            } finally {\n                data.lock.unlock();\n            }\n    }\n    \n}','Will not compile, ArrayList listData is a raw type so in the foreach loop\nyou assign them to an Integer, you would have had to cast','Input/Output',1,NULL),(1932,'public class Hello {\n    private List<Integer> integers = new ArrayList<>();\n    private ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();\n    \n    public void add(Integer i){\n        rwl.writeLock().lock();\n        try {\n            integers.add(i);\n        } finally {\n            rwl.writeLock().unlock();\n        }\n    }\n    \n    public int findMax() {\n        rwl.readLock().lock();\n        try {\n            return Collections.max(integers);\n        } finally {\n            rwl.readLock().unlock();\n        }\n    }\n    public static void main(String[] args){\n      \n    }\n\n}','With ReentrantReadWriteLock you can grant write access to only one thread, but\nit is possible to allow many threads to be reading at the same time. ','Input/Output',1,NULL),(1933,'read-only(immutabel) objects are always thread safe. ','','Input/Output',1,NULL),(1934,'Use copy on write collections when...','your data sets remain small and the number of read operations and traversals greatly outnumber\nmodifications to the collection. \n\nCopy on write collections work by copying their internal array of data with\nany mutating operation. This copied array will replace the original read only\narrray. \n\nThis allows it to be safely shared between multiple threads. ','Input/Output',1,NULL),(1935,'Just because a collection is thread safe does not make the elements stored within\nthread safe','','Input/Output',1,NULL),(1936,'The Iterator for a concurrent collection is weakly consistent; it can return elements \nfrom the point in time the Iterator was created or LATER. This means that \nwhile looping through a concurrent collection, you might observel elements that\nare being inserted by other threads. also you might see only some of the elements\nthat another thread is inserting. ','','Input/Output',1,NULL),(1937,'Which concurrent Collections are sorted ?','ConcurrentSkipListMap and ConcurrentSkipListSet \n\n-They require the use of comparable and comparotr to enable ordering. ','Input/Output',1,NULL),(1938,'copy on write and concurrent collections are centered on the idea of multiple\nthreads sharing data. \n\nA BlockingQueue is used to exchnage data between two or more threads while causing\nsome of the threads to wait until the point in time when the data can be \ntransfered. ','','Input/Output',1,NULL),(1939,'class Hello {\n    public static void main(String[] args) {     \n        Pattern p = Pattern.compile(\"\\\\B\\\\d\\\\B\");\n        Matcher m = p.matcher(\"Th4t\'ll b3 the d4y, on th3 v3ry l6ast d8y\");\n        \n        while(m.find()){\n            System.out.println(m.group());\n        }\n        \n    }\n\n}','4\n4\n3\n6\n8\n\nto indicate that you want a pattern to be surrounded by other similar characteres\nsurround it with non word boundaries. If you did want the character to \nbee alone surround it with word boudaries.','Strings',1,NULL),(1940,'BlockingQueue implementations','ArrayBlockingQueue\nLinkedBlockingQueue\nLinkedBlockingQueue\nPriorityBlockingQueue\nDelayQueue\nLinkedTransferQueue\nSynchronousQueue\n','Concurrency',1,NULL),(1941,'A blocking collection, depending on the method being called, may cause a thread to block\nuntil another threads calls a corresponding method on the collection. \n\nif you attempt to reemove an element() by calling take() on any BlockingQueue\nthat is empty, the operation will block until another thread inserts an element.\n','','Concurrency',1,NULL),(1942,'BlockingQueue method:\n\nadd(E e)','Returns true if object added,\n\nfalse if duplicate objects are not allowed.\n\nThrows IllegalStateException if the queue is bounded and full','Concurrency',1,NULL),(1943,'BlockingQueue method:\n\noffer(E e)','returns true if object added, false if the queue is bounded and full','Concurrency',1,NULL),(1944,'BlockingQueue method:\n\nput(E e)','returns void.\n\nwill block until space in the queue becomes available if needed ','Concurrency',1,NULL),(1945,'offer(E e, long timeout, TimeUnit unit)','returns false if the object was not able to be inserted before the time idicated,\n','Concurrency',1,NULL),(1946,'BlockingQueue method:\n\nremove(Object o)','returns true if an equal object was found in the queue and removed; \notherwise returns false.','Concurrency',1,NULL),(1947,'BlockingQueue method:\n\npoll(long timeout, TimeUnit unit)','removes the first object in the queue and returns it. \n\nif the timeout expires before an object can be removed becaue the queue is empty\nthen a null will be returned. ','Concurrency',1,NULL),(1948,'BlockingQueue method:\n\ntake()','Removes and returns the first object in the queue, blocking if needed until the \nobject becomes available. \n\nonly throws InterruptedException','Concurrency',1,NULL),(1949,'BlockingQueue method:\n\npoll()','removes and returns the first object in the queue and returns null if the queue is empty\n','Concurrency',1,NULL),(1950,'BlockingQueue method:\n\nelement()','Gets the head of the queue without removing it, Throws a NoSuchElementException\nif the queue is empty. ','Concurrency',1,NULL),(1951,'BlockingQueue method:\n\npeek()','gets the head of the queue without removing it, Returns a null if the queue is \nempty. ','Concurrency',1,NULL),(1952,'BlockingQueue<Integer> bq = new ArrayBlockingQueue<>(1);\n\ntry{\n	bq.put(34);\n	bq.put(35);\n} catch(InterruptedException e) {}','The second put(35) will block until previous values is removed by another thread.','Concurrency',1,NULL),(1953,'SynchronousQueue','...is a speciel type of bounded blocking queue; it has a capacity of \nzero. The first thread to attempt either an insert or remvoe operaion\non a synchronousQueue will block until another thread performs the opposite \noperation. USe this when you need threads to meet up and exchange an object.','Concurrency',1,NULL),(1954,'public class Hello {\n    public static void main(String[] args){\n       CopyOnWriteArrayList<Integer> list = new CopyOnWriteArrayList<>();\n       \n       list.add(5);\n       list.add(9);\n       Iterator<Integer> it = list.iterator();\n       \n       list.add(3);\n       \n       while(it.hasNext()){\n           System.out.println(it.next());\n       }\n    }\n}','5\n9\n\nThe iterator was obtained before the 3 was added. As long as the reference to \nthe iterator is maintained it will only provide access to 5 9.\n\nIt is ConcurrentCollections that will remain weakly consistant with the changes\nmade by other threads, This is a copyonwrite array list which is thread safe but\nnot concurrent.','Concurrency',1,NULL),(1955,'public class Hello {\n    public static void main(String[] args){\n       CopyOnWriteArrayList<Integer> cowlist = new CopyOnWriteArrayList<>();\n       \n       cowlist.add(5);\n       cowlist.add(9);\n       cowlist.add(4);\n       \n       Iterator<Integer> it = cowlist.iterator();\n       \n       cowlist.remove(2);\n       \n       while(it.hasNext()){\n           System.out.println(it.next());\n       }\n       \n    }\n}','5\n9\n4\n\nThe iterator is obtained before the element at index 2 is removed.','Concurrency',1,NULL),(1956,'public class Hello {\n    public static void main(String[] args){\n       CopyOnWriteArrayList<Integer> cowlist = new CopyOnWriteArrayList<>();\n       \n       cowlist.add(5);\n       cowlist.add(9);\n       cowlist.add(4);\n       \n       Iterator<Integer> it = cowlist.iterator();\n       \n       cowlist.remove(5);\n       \n       while(it.hasNext()){\n           System.out.println(it.next());\n       }\n       \n    }\n}','IndexOutofBoundsException \n\nthis can be confusing here the remove(int index) is being used. \n\nto fix do this\n\ncowlist.remove(new Integer(5));','Concurrency',1,NULL),(1957,'Which methods from copyonwritearraylist will cause a new copy of the internal\narray to be created\n\nadd\nget\niterator\nremove','add and remove. These are the only methods shown that modify the list','Concurrency',1,NULL),(1958,'ArrayBlockingQueue<Integer> abq = new ArrayBlockingQueue<>(10);\n\nwhich operation can block indefinitely\n\nabq.add(1);\nabq.offer(1);\nabq.put(1);\nabq.offer(1,5,TimeUnit.SECONDS);','only put()','Concurrency',1,NULL),(1959,'public class Hello implements Runnable {\n    private static ArrayBlockingQueue<Integer> abq = new ArrayBlockingQueue<>(10);\n    public static void main(String[] args){\n       Hello h = new Hello();\n       Thread t1 = new Thread(h);\n       Thread t2 = new Thread(h);\n       Thread t3 = new Thread(h);\n       Thread t4 = new Thread(h);\n       \n       t1.start();\n       t2.start();\n       t3.start();\n       t4.start();\n       \n    }\n    public void run(){\n        for(int i = 0; i<5; i++){\n            abq.add(i);\n        }\n    }\n}','IllegalStateEXception queue is full','Concurrency',1,NULL),(1960,'public class Hello implements Runnable {\n    private static ArrayBlockingQueue<Integer> abq = new ArrayBlockingQueue<>(10);\n    public static void main(String[] args){\n       Hello h = new Hello();\n       Thread t1 = new Thread(h);\n       Thread t2 = new Thread(h);\n       Thread t3 = new Thread(h);\n       Thread t4 = new Thread(h);\n       \n       t1.start();\n       t2.start();\n       t3.start();\n       t4.start();\n       \n    }\n    public void run(){\n        for(int i = 0; i<5; i++){\n            System.out.println(abq.add(i));\n        }\n    }\n}','true\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\nException in thread \"Thread-2\" java.lang.IllegalStateException: Queue full\n	at java.util.AbstractQueue.add(AbstractQueue.java:98)\n	at java.util.concurrent.ArrayBlockingQueue.add(ArrayBlockingQueue.java:312)\n	at hello.Hello.run(Hello.java:27)\n	at java.lang.Thread.run(Thread.java:745)\nException in thread \"Thread-3\" java.lang.IllegalStateException: Queue full\n	at java.util.AbstractQueue.add(AbstractQueue.java:98)\n	at java.util.concurrent.ArrayBlockingQueue.add(ArrayBlockingQueue.java:312)\n	at hello.Hello.run(Hello.java:27)\n	at java.lang.Thread.run(Thread.java:745)','Concurrency',1,NULL),(1961,'public class Hello implements Runnable {\n    private static ArrayBlockingQueue<Integer> abq = new ArrayBlockingQueue<>(10);\n    public static void main(String[] args){\n       Hello h = new Hello();\n       Thread t1 = new Thread(h);\n       Thread t2 = new Thread(h);\n       Thread t3 = new Thread(h);\n       Thread t4 = new Thread(h);\n       \n       t1.start();\n       t2.start();\n       t3.start();\n       t4.start();\n       \n    }\n    public void run(){\n        for(int i = 0; i<5; i++){\n            System.out.println(abq.offer(i));\n        }\n    }\n}','offer() Inserts the specified element at the tail of this queue if \nit is possible to do so immediately \nwithout exceeding the queue\'s capacity, \nreturning true upon success and false if this queue is full. \nThis method is generally preferable to method add(E), which can fail to insert an element \nonly by throwing an exception.\n\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\nfalse\nfalse\nfalse\nfalse\nfalse\nfalse\nfalse\nfalse\nfalse\nfalse','Concurrency',1,NULL),(1962,'public class Hello implements Runnable {\n    private static ArrayBlockingQueue<Integer> abq = new ArrayBlockingQueue<>(10);\n    public static void main(String[] args){\n       Hello h = new Hello();\n       Thread t1 = new Thread(h);\n       Thread t2 = new Thread(h);\n       Thread t3 = new Thread(h);\n       Thread t4 = new Thread(h);\n       \n       t1.start();\n       t2.start();\n       t3.start();\n       t4.start();\n       \n    }\n    public void run(){\n        for(int i = 0; i<5; i++){\n            System.out.println(abq.put(i));\n        }\n    }\n}','will not compile, .put() return void and blocks until space becomes available\n\n\'void\' is not allowed is sout();','Concurrency',1,NULL),(1963,'public class Hello implements Runnable {\n    private static ArrayBlockingQueue<Integer> abq = new ArrayBlockingQueue<>(10);\n    public static void main(String[] args){\n       Hello h = new Hello();\n       Thread t1 = new Thread(h);\n       Thread t2 = new Thread(h);\n       Thread t3 = new Thread(h);\n       Thread t4 = new Thread(h);\n       \n       t1.start();\n       t2.start();\n       t3.start();\n       t4.start();\n       \n    }\n    public void run(){\n        for(int i = 0; i<5; i++){\n            abq.put(i);\n        }\n    }\n}','Will not compile,\n\nput will block, therefore it may throw an interruptedException\n\nsurround with try catch','Concurrency',1,NULL),(1964,'public class Hello implements Runnable {\n    private static ArrayBlockingQueue<Integer> abq = new ArrayBlockingQueue<>(10);\n    public static void main(String[] args){\n       Hello h = new Hello();\n       Thread t1 = new Thread(h);\n       Thread t2 = new Thread(h);\n       Thread t3 = new Thread(h);\n       Thread t4 = new Thread(h);\n       \n       t1.start();\n       t2.start();\n       t3.start();\n       t4.start();\n       \n    }\n    public void run(){\n        for(int i = 0; i<5; i++){\n            try{\n                abq.put(i);\n            } catch(InterruptedException e){}\n        }\n    }\n}','will run indefinitely, put will block until space becomes available, here \nit will never become available because there is no code removing objects','Concurrency',1,NULL),(1965,'public class Hello implements Runnable {\n    private static ArrayBlockingQueue<Integer> abq = new ArrayBlockingQueue<>(10);\n    public static void main(String[] args){\n        for(int i = 0; i<10; i++)\n                abq.add(i);\n  \n       Hello h = new Hello();\n       Thread t1 = new Thread(h);\n       Thread t2 = new Thread(h);\n       Thread t3 = new Thread(h);\n       Thread t4 = new Thread(h);\n       \n       t1.start();\n       t2.start();\n       t3.start();\n       t4.start();\n       \n    }\n    public void run(){\n        for(int i = 0; i<5; i++){\n            System.out.println(Thread.currentThread().getName()+\"removed element: \"+abq.peek());\n        }\n        \n    }\n}','peek() returns the head without removing it. returns null if empty\nThread-0removed element: 0\nThread-0removed element: 0\nThread-0removed element: 0\nThread-0removed element: 0\nThread-0removed element: 0\nThread-2removed element: 0\nThread-2removed element: 0\nThread-2removed element: 0\nThread-2removed element: 0\nThread-2removed element: 0\nThread-3removed element: 0\nThread-3removed element: 0\nThread-3removed element: 0\nThread-3removed element: 0\nThread-3removed element: 0\nThread-1removed element: 0\nThread-1removed element: 0\nThread-1removed element: 0\nThread-1removed element: 0\nThread-1removed element: 0\n','Concurrency',1,NULL),(1966,'ArrayBlockingQueue<E>\n\nA bounded blocking queue backed by an array. \nThis queue orders elements FIFO (first-in-first-out). \nThe head of the queue is that element that has been on the queue the longest time. \nThe tail of the queue is that element that has been on the queue the shortest time. \nNew elements are inserted at the tail of the queue, and the queue retrieval operations obtain elements at the head of the queue.\n\nThis is a classic \"bounded buffer\", in which a fixed-sized array holds elements inserted by producers and extracted by consumers. \nOnce created, the capacity cannot be changed. Attempts to put an element into a full queue will result in the operation blocking; \nattempts to take an element from an empty queue will similarly block. ','','Concurrency',1,NULL),(1967,'public class Hello {\n    public static void main(String[] args){\n        SynchronousQueue<String> sq = new SynchronousQueue<String>();\n        Thread putThread = new Thread(new PutRunnable<String>(sq, \"One\"), \"PutThread\");\n        putThread.start();\n        Thread takerThread = new Thread(new TakerRunnable<String>(sq), \"TakerThread\");\n        takerThread.start();\n\n    }\n}\n\n class PutRunnable<T> implements Runnable {\n    private T value;\n    private SynchronousQueue<T> syncQ;\n    PutRunnable(SynchronousQueue<T> syncQ, T value) {\n        this.syncQ = syncQ;\n        this.value = value;\n    }\n    public void run() {\n        try {\n            PrintUtils.print(\"Put \" + value);\n            syncQ.put(value);\n            PrintUtils.print(\"Returned from put\");\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n \n}\nclass TakerRunnable<T> implements Runnable {\n    private T value;\n    private SynchronousQueue<T> syncQ;\n    TakerRunnable(SynchronousQueue<T> syncQ) {\n        this.syncQ = syncQ;\n    }\n    public void run() {\n        try {\n            PrintUtils.print(\"Retrieve using take\");\n            value = syncQ.take();\n            PrintUtils.print(\"take() returned \" + value);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n    public T getValue() {\n        return value;\n    }\n}\n\nclass PrintUtils {\n    public static void print(String s) {\n        System.out.println(Thread.currentThread().getName() + \":\" + s);\n    }\n}','PutThread:Put One\nTakerThread:Retrieve using take\nTakerThread:take() returned One\nPutThread:Returned from put\n\nSyncQueue is used to make two threads meet up and hand off an object. \n\nBoth insertion and removal operations will block until the other thread\ndoes the inverse thus making the threads meet and exchange. ','Concurrency',1,NULL),(1968,'public class Hello {\n    \n    private static TransferQueue<Integer> tq = new LinkedTransferQueue<>();\n\n    public static void main(String[] args){\n        boolean b1 = tq.add(1); // true if added, IllegalStateException if full\n        \n        try{\n            //both of these throw interruptedExceptions because they block and wait\n            \n            tq.put(2);  //blocks if bounded or full\n        \n            tq.transfer(88); //blocks until element is consumed\n            \n        } catch(InterruptedException e){ }\n        \n        tq.tryTransfer(7); // returns true if consumed by the awaiting thread, or false without adding if there was no awaiting consumer.\n            // does not block therefore does not throw interruptedException\n        \n        try {\n            \n            //will wait the given time, blocking, then will return if not consumed\n            boolean b7 = tq.tryTransfer(99,10,TimeUnit.SECONDS);\n            \n        } catch(InterruptedException e){ }\n\n    }\n    \n    public static void methodsToRetrieve(){\n        Integer i1 = tq.element(); // gets without removing, throws NoSuchElementException if empty\n        \n        Integer i2 = tq.peek(); // gets without removing, null if empty\n        \n        Integer i3 = tq.poll(); //returns and removes the head, null if empty\n        \n        try{\n            Integer i4 = tq.poll(10,TimeUnit.MILLISECONDS); // removes the head, waits the specified time beffore returning null if empty\n        } catch(InterruptedException e) { }\n        \n        Integer i5 = tq.remove(); // removes the head of the queue throws NoSuchElementException if empty\n                \n        try{\n            Integer i6 = tq.take(); //removes the head blocks until an element is ready,\n        } catch(InterruptedException e) { }\n                \n    }','LinkedTranserQueue implements the BlockingQueue, TransferQueue, and Queue interfaces\n\nit is used here to demonstrate all the inserting and removing methods.','Concurrency',1,NULL),(1969,'public class Hello {\n    \n    private static TransferQueue<Integer> tq = new LinkedTransferQueue<>(45);\n\n    public static void main(String[] args){\n        boolean b1 = tq.add(1); // true if added, IllegalStateException if full\n        \n        try{\n            //both of these throw interruptedExceptions because they block and wait\n            \n            tq.put(2);  //blocks if bounded or full\n        \n            tq.transfer(88); //blocks until element is consumed\n            \n        } catch(InterruptedException e){ }\n        \n        tq.tryTransfer(7); // returns true if consumed by the awaiting thread, or false without adding if there was no awaiting consumer.\n            // does not block therefore does not throw interruptedException\n        \n        try {\n            \n            //will wait the given time, blocking, then will return if not consumed\n            boolean b7 = tq.tryTransfer(99,10,TimeUnit.SECONDS);\n            \n        } catch(InterruptedException e){ }\n\n    }\n    \n    public static void methodsToRetrieve(){\n        Integer i1 = tq.element(); // gets without removing, throws NoSuchElementException if empty\n        \n        Integer i2 = tq.peek(); // gets without removing, null if empty\n        \n        Integer i3 = tq.poll(); //returns and removes the head, null if empty\n        \n        try{\n            Integer i4 = tq.poll(10,TimeUnit.MILLISECONDS); // removes the head, waits the specified time beffore returning null if empty\n        } catch(InterruptedException e) { }\n        \n        Integer i5 = tq.remove(); // removes the head of the queue throws NoSuchElementException if empty\n                \n        try{\n            Integer i6 = tq.take(); //removes the head blocks until an element is ready,\n        } catch(InterruptedException e) { }\n                \n    }','will not compile, LinkedTransferQueue is not bounded and cannot be supplied with\na size argument','Concurrency',1,NULL),(1970,'public class Hello {\n    \n    private static TransferQueue<Integer> tq = new LinkedTransferQueue<>();\n\n    public static void main(String[] args){\n        boolean b1 = tq.add(1); // true if added, IllegalStateException if full\n            \n        tq.put(2);  //blocks if bounded or full\n        \n        tq.transfer(88); //blocks until element is consumed\n        \n        tq.tryTransfer(7); // returns true if consumed by the awaiting thread, or false without adding if there was no awaiting consumer.\n            // does not block therefore does not throw interruptedException\n        \n        try {\n            \n            //will wait the given time, blocking, then will return if not consumed\n            boolean b7 = tq.tryTransfer(99,10,TimeUnit.SECONDS);\n            \n        } catch(InterruptedException e){ }\n\n    }\n    \n    public static void methodsToRetrieve(){\n        Integer i1 = tq.element(); // gets without removing, throws NoSuchElementException if empty\n        \n        Integer i2 = tq.peek(); // gets without removing, null if empty\n        \n        Integer i3 = tq.poll(); //returns and removes the head, null if empty\n        \n        try{\n            Integer i4 = tq.poll(10,TimeUnit.MILLISECONDS); // removes the head, waits the specified time beffore returning null if empty\n        } catch(InterruptedException e) { }\n        \n        Integer i5 = tq.remove(); // removes the head of the queue throws NoSuchElementException if empty\n                \n        try{\n            Integer i6 = tq.take(); //removes the head blocks until an element is ready,\n        } catch(InterruptedException e) { }\n                \n    }','will not compile, put and transfer block and wait, therefore they throw \nInterruptedExceptions','Concurrency',1,NULL),(1971,'public class Hello {\n    \n    public static void main(String[] args){\n        Library library = new Library();\n        \n        new Thread(library).start();\n        \n        new Thread(new Renter(library,\"Mike\")).start();\n        new Thread(new Renter(library,\"Max\")).start();\n        new Thread(new Renter(library,\"Priebe\")).start();\n        new Thread(new Renter(library,\"Dom\")).start();\n    }\n}\n\nclass Library implements Runnable{\n    private TransferQueue<Book> shelves = new LinkedTransferQueue<>();\n    \n    public Library() {\n        shelves.add(new Book(\"Topics of Destruction\"));\n        shelves.add(new Book(\"War what is it good for\"));\n        shelves.add(new Book(\"LOTR\"));\n        shelves.add(new Book(\"Manson, the secret life\"));\n    }\n    \n    public void run(){\n        while(true){ }\n    }\n    \n    public Book lend(){\n        \n        try {\n            Book book = shelves.take();\n            System.out.println(\"This ones good try \"+book.getName()+\". Enjoy!\");\n            return book;\n        } catch(InterruptedException e){ }\n        \n        return new Book(\"Free Library Pamphlet on plagarism\");\n    }\n    \n    public void accept(Book book){\n        shelves.offer(book);\n       \n    }\n}\n\nclass Renter implements Runnable {\n    private Library lib;\n    private String name;\n    public Renter(Library lib,String x){\n        name = x;\n        this.lib = lib;\n    }\n    public void run(){\n        while(true){\n            Book book = lib.lend();\n            System.out.println(name+\" chekced out \"+book.getName());\n            try{\n                Thread.sleep(ThreadLocalRandom.current().nextInt(1000,5000));\n            } catch(InterruptedException e) { }\n            \n            System.out.println(name+\": Im done with \"+book.getName()+\" here take it back!\");\n            lib.accept(book);\n        }\n    }\n}\n\n\nclass Book{\n    private String name;\n    public Book(String x ){\n        name = x;\n    }\n    \n    public String getName(){\n        return name;\n    }\n    \n}','This shows the proper use of take() which will block until a book is available,\noffer is also properlyy used becaue it will only add if the queue is not full\nif it is it simply doesn\'t add it and doesn\'t throw an exception or anything.\n\nThis ones good try Topics of Destruction. Enjoy!\nMike chekced out Topics of Destruction\nThis ones good try War what is it good for. Enjoy!\nMax chekced out War what is it good for\nThis ones good try LOTR. Enjoy!\nPriebe chekced out LOTR\nThis ones good try Manson, the secret life. Enjoy!\nDom chekced out Manson, the secret life\nMike: Im done with Topics of Destruction here take it back!\nThis ones good try Topics of Destruction. Enjoy!\nMike chekced out Topics of Destruction\nPriebe: Im done with LOTR here take it back!\nThis ones good try LOTR. Enjoy!\nPriebe chekced out LOTR\nDom: Im done with Manson, the secret life here take it back!\nThis ones good try Manson, the secret life. Enjoy!\nDom chekced out Manson, the secret life\nMike: Im done with Topics of Destruction here take it back!\nThis ones good try Topics of Destruction. Enjoy!\nMike chekced out Topics of Destruction\nMax: Im done with War what is it good for here take it back!\nThis ones good try War what is it good for. Enjoy!\nMax chekced out War what is it good for\nPriebe: Im done with LOTR here take it back!\nThis ones good try LOTR. Enjoy!\nPriebe chekced out LOTR\nMike: Im done with Topics of Destruction here take it back!\nThis ones good try Topics of Destruction. Enjoy!\nMike chekced out Topics of Destruction\nPriebe: Im done with LOTR here take it back!\nThis ones good try LOTR. Enjoy!\nPriebe chekced out LOTR','Concurrency',1,NULL),(1972,'public class Hello {\n    \n    public static void main(String[] args){\n        Library library = new Library();\n        \n        new Thread(library).start();\n        \n        new Thread(new Renter(library,\"Mike\")).start();\n        new Thread(new Renter(library,\"Max\")).start();\n        new Thread(new Renter(library,\"Priebe\")).start();\n        new Thread(new Renter(library,\"Dom\")).start();\n    }\n}\n\nclass Library implements Runnable{\n    private TransferQueue<Book> shelves = new LinkedTransferQueue<>();\n    \n    public Library() {\n        shelves.add(new Book(\"Capulets and Montagues, the unknown link\"));\n        shelves.add(new Book(\"War What is it Good For\"));\n        shelves.add(new Book(\"Virtuous Villians\"));\n        shelves.add(new Book(\"Love in the Water\"));\n    }\n    \n    public void run(){\n        while(true){ }\n    }\n    \n    public Book lend(){\n        \n        try {\n            Book book = shelves.element();\n            System.out.println(\"This ones good try \"+book.getName()+\". Enjoy!\");\n            return book;\n        } catch(NoSuchElementException e){System.out.println(\"I\'m sorry sir we dont have that book right now\"); }\n        \n        return new Book(\"Free Library Pamphlet on plagarism\");\n    }\n    \n    public void accept(Book book){\n        shelves.offer(book);\n       \n    }\n}\n\nclass Renter implements Runnable {\n    private Library lib;\n    private String name;\n    public Renter(Library lib,String x){\n        name = x;\n        this.lib = lib;\n    }\n    public void run(){\n        while(true){\n            Book book = lib.lend();\n            System.out.println(name+\" chekced out \"+book.getName());\n            try{\n                Thread.sleep(ThreadLocalRandom.current().nextInt(1000,5000));\n            } catch(InterruptedException e) { }\n            \n            System.out.println(name+\": Im done with \"+book.getName()+\" here take it back!\");\n            lib.accept(book);\n        }\n    }\n}\n\nclass Book{\n    private String name;\n    public Book(String x ){\n        name = x;\n    }\n    \n    public String getName(){\n        return name;\n    }\n    \n}','element() throws NoSuchElementException,\n\n','Concurrency',1,NULL),(1973,'public class Hello {\n    \n    public static void main(String[] args){\n        Library library = new Library();\n        \n        new Thread(library).start();\n        \n        new Thread(new Renter(library,\"Mike\")).start();\n        new Thread(new Renter(library,\"Max\")).start();\n        new Thread(new Renter(library,\"Priebe\")).start();\n        new Thread(new Renter(library,\"Dom\")).start();\n    }\n}\n\nclass Library implements Runnable{\n    private TransferQueue<Book> shelves = new LinkedTransferQueue<>();\n    \n    public Library() {\n        shelves.add(new Book(\"Capulets and Montagues, the unknown link\"));\n        shelves.add(new Book(\"War What is it Good For\"));\n        shelves.add(new Book(\"Virtuous Villians\"));\n        shelves.add(new Book(\"Love in the Water\"));\n    }\n    \n    public void run(){\n        while(true){ }\n    }\n    \n    public Book lend(){\n\n            Book book = shelves.peek();\n            System.out.println(\"This ones good try \"+book.getName()+\". Enjoy!\");\n        \n            if(book == null){\n                return new Book(\"Free Library Pamphlet on plagarism\");\n            } else {\n                return book;\n            }\n    }\n    \n    public void accept(Book book){\n        shelves.offer(book);\n       \n    }\n}\n\nclass Renter implements Runnable {\n    private Library lib;\n    private String name;\n    public Renter(Library lib,String x){\n        name = x;\n        this.lib = lib;\n    }\n    public void run(){\n        while(true){\n            Book book = lib.lend();\n            System.out.println(name+\" chekced out \"+book.getName());\n            try{\n                Thread.sleep(ThreadLocalRandom.current().nextInt(1000,5000));\n            } catch(InterruptedException e) { }\n            \n            System.out.println(name+\": Im done with \"+book.getName()+\" here take it back!\");\n            lib.accept(book);\n        }\n    }\n}\n\nclass Book{\n    private String name;\n    public Book(String x ){\n        name = x;\n    }\n    \n    public String getName(){\n        return name;\n    }\n    \n}','The same book keeps getting checked out because peek()\nreturns but does not remove the element\n\nThis ones good try Capulets and Montagues, the unknown link. Enjoy!\nMike chekced out Capulets and Montagues, the unknown link\nThis ones good try Capulets and Montagues, the unknown link. Enjoy!\nMax chekced out Capulets and Montagues, the unknown link\nThis ones good try Capulets and Montagues, the unknown link. Enjoy!\nPriebe chekced out Capulets and Montagues, the unknown link\nThis ones good try Capulets and Montagues, the unknown link. Enjoy!\nDom chekced out Capulets and Montagues, the unknown link\nDom: Im done with Capulets and Montagues, the unknown link here take it back!\nThis ones good try Capulets and Montagues, the unknown link. Enjoy!\nDom chekced out Capulets and Montagues, the unknown link\nMike: Im done with Capulets and Montagues, the unknown link here take it back!\nThis ones good try Capulets and Montagues, the unknown link. Enjoy!\nMike chekced out Capulets and Montagues, the unknown link\nPriebe: Im done with Capulets and Montagues, the unknown link here take it back!\nThis ones good try Capulets and Montagues, the unknown link. Enjoy!\nPriebe chekced out Capulets and Montagues, the unknown link\nMax: Im done with Capulets and Montagues, the unknown link here take it back!\nThis ones good try Capulets and Montagues, the unknown link. Enjoy!\nMax chekced out Capulets and Montagues, the unknown link\nDom: Im done with Capulets and Montagues, the unknown link here take it back!','Concurrency',1,NULL),(1974,'public class Hello {\n    \n    public static void main(String[] args){\n        Library library = new Library();\n        \n        new Thread(library).start();\n        \n        new Thread(new Renter(library,\"Mike\")).start();\n        new Thread(new Renter(library,\"Max\")).start();\n        new Thread(new Renter(library,\"Priebe\")).start();\n        new Thread(new Renter(library,\"Dom\")).start();\n    }\n}\n\nclass Library implements Runnable{\n    private TransferQueue<Book> shelves = new LinkedTransferQueue<>();\n    \n    public Library() {\n        shelves.add(new Book(\"Capulets and Montagues, the unknown link\"));\n        shelves.add(new Book(\"War What is it Good For\"));\n        shelves.add(new Book(\"Virtuous Villians\"));\n        shelves.add(new Book(\"Love in the Water\"));\n    }\n    \n    public void run(){\n        while(true){ }\n    }\n    \n    public Book lend(){\n\n            Book book = shelves.poll();\n            System.out.println(\"This ones good try \"+book.getName()+\". Enjoy!\");\n        \n            if(book == null){\n                return new Book(\"Free Library Pamphlet on plagarism\");\n            } else {\n                return book;\n            }\n    }\n    \n    public void accept(Book book){\n        shelves.put(book);\n       \n    }\n}\n\nclass Renter implements Runnable {\n    private Library lib;\n    private String name;\n    public Renter(Library lib,String x){\n        name = x;\n        this.lib = lib;\n    }\n    public void run(){\n        while(true){\n            Book book = lib.lend();\n            System.out.println(name+\" chekced out \"+book.getName());\n            try{\n                Thread.sleep(ThreadLocalRandom.current().nextInt(1000,5000));\n            } catch(InterruptedException e) { }\n            \n            System.out.println(name+\": Im done with \"+book.getName()+\" here take it back!\");\n            lib.accept(book);\n        }\n    }\n}\n\nclass Book{\n    private String name;\n    public Book(String x ){\n        name = x;\n    }\n    \n    public String getName(){\n        return name;\n    }\n    \n}','does not compile, \n\nput() will block if there is no space available therefor it throws an\n\nInterruptedException','Concurrency',1,NULL),(1975,'Which BlockingCollection method will block if needed until an object becomes\navailabel','take()','Concurrency',1,NULL),(1976,'Which BlockingCollection method throws nosuchelementexception','element()','Concurrency',1,NULL),(1977,'Which BlockingQueue method throws an illegalstateexception if the queueu is bounded and full ? ','add()','Concurrency',1,NULL),(1978,'Whic BlockingQueue method returns true if it was added and false if \nthe queueu was full but also provides a timeout overloaded option','offer() and offer(e, long timeout, timeunit)','Concurrency',1,NULL),(1979,'','','blank',1,NULL),(1980,'	String a = \"String\";\n        int b = 4;\n        int c = 3;\n        System.out.println(a+b+c);\n        System.out.println(a+(b+c));\n        System.out.println(\"\" + b + 3);\n        System.out.println(b+3);\n        System.out.println(++b + \"\" + c--);\n        System.out.println(c);','String43\nString7\n43\n7\n53\n2','Strings',1,NULL),(1981,'','','blank',1,NULL),(1982,'ExecutorService ex = Executors.newCachedThreadPool();','Cached thread pools will create new threads as needed and reuse threads that \nhave become free. Thread that have been idle for 60 seconds are removed.\n\nCan create more threads than system can handle so watch out. ','Executors',1,NULL),(1983,'ExecutorService ex = Executors.newFixedThreadPool(4);\n','constructed with an int argument that specifies the number of threads to use\nto execute the tasks. Most common. Prevents system from being overloaded\nwith too many threads. \n\nBase number of threads on some kind of system resource. \n\nuse java.lang.Runtime\n\nRuntime rt = Runtime.getRuntime();\nint cpus = rt.availabeProcessors();','Executors',1,NULL),(1984,'How to adust the thread count of a pool at runtime\n\n','ThreadPoolExecutor tpe = (ThreadPoolExecutor) Executors.newFixedThreadPool(4);\ntpe.setCorePoolSize(8);\ntpe.setMaximumPoolSize(8);','Executors',1,NULL),(1985,'public class Hello {\n    public static void main(String[] args){\n        ExecutorService ex = Executors.newSingleThreadPool();\n\n        Future<Integer> futint = ex.submit(new FileCounter());\n        \n        System.out.println(\"Do other things while the files are getting counted\");\n        \n        try{\n            int count = futint.get();\n            System.out.println(count);\n            futint.shutdown();\n        }catch(ExecutionException | InterruptedException e){\n            \n        }\n        \n    }\n    \n    \n}\n\nclass FileCounter implements Callable<Integer>{\n    private int fileCount = 0;\n    public Integer call() throws IOException{\n        fileCount = count(Paths.get(\"/home/maxbisesi/Documents\"));\n        return fileCount; \n    }\n    \n    public Integer count(Path d) throws IOException {\n        int count = 0;\n	try(DirectoryStream<Path> stream = Files.newDirectoryStream(d)){\n		for(Path path: stream){\n			count++;\n		}\n	}\n        return count;\n    }\n}','        ExecutorService ex = Executors.newSingleThreadExecutor(); \n\nwil not compile, it is singlethreadexecutor not singlethreadPool\n\n**Also you shutdown the ExecutorService not the Future!','Executors',1,NULL),(1986,'Scheduled Thread pool:\n	scheduled after a delay or at repeating intervals\n\npublic class Hello {\n    \n    public static void main(String[] args){\n     ScheduledExecutorService ftses = Executors.newScheduledThreadPool(4);\n     \n     ftses.schedule(r, 5, TimeUnit.SECONDS); //run once after a delay\n     \n     ftses.scheduleAtFixedRate(r, 2,5,TimeUnit.SECONDS); //begin after 2 sec delay and begin again every 5\n     \n     ftses.scheduleWithFixedDelay(r, 2, 5, TimeUnit.SECONDS); //begin after 2 sec delay and again 5 seconds after the last exection\n}','','Executors',1,NULL),(1987,'an ExecutorService can take what two kinds of objects ?','Callable and Runnable','Executors',1,NULL),(1988,'What is the primary benifit of using a Callable ?','being able to return a result','Executors',1,NULL),(1989,'submitting a Callable to an ExecutorService returns a Future reference.\n\nwhat are two possible exceptions that could result ?','InterruptedException and ExecutionException','Executors',1,NULL),(1990,'ExecutionException','raised when an exception was thrown during the execution of the callable\'s\ncall()','Executors',1,NULL),(1991,'public class Hello {\n    \n    public static void main(String[] args){\n        Callable<Integer> c = new LoopCounter();\n        \n        ExecutorService ex = Executors.newCachedThreadPool();\n        \n        Future<Integer> f = ex.submit(c); //finishes in the future\n        \n        try{\n            Integer v = f.get(); // will block until done\n            System.out.println(\"Ran: \" + v);\n        } catch(InterruptedException | ExecutionException iex){\n            System.out.println(\"Failed\");\n        }\n        \n        for(int i = 0; i<10; i++){\n            System.out.println(\"main: \"+ i);\n        }\n    }\n}\n\nclass LoopCounter implements Callable<Integer> {\n    \n    public Integer call(){\n        int count = ThreadLocalRandom.current().nextInt(1,11);\n        for(int i = 1; i <= count; i++){\n                System.out.println(\"running...\" + i);\n        }\n        return count;\n    }\n}','When a callable task is submitted to an executor the task will go run,\ncalling for its return value will block until it is done so otherwise go on \nwith your program until you are ready to use that result. In this code the rest\nof main is executed only after the future is returned.\nrunning...1\nrunning...2\nrunning...3\nrunning...4\nrunning...5\nrunning...6\nrunning...7\nrunning...8\nrunning...9\nrunning...10\nRan: 10\nmain: 0\nmain: 1\nmain: 2\nmain: 3\nmain: 4\nmain: 5\nmain: 6\nmain: 7\nmain: 8\nmain: 9\n','Executors',1,NULL),(1992,'Using Executors takes away the need for synchronization, waiting, joining and \nnotifying','got it ','Executors',1,NULL),(1993,'public class Hello {\n    \n    public static void main(String[] args){\n        Callable<Integer> c = new LoopCounter();\n        \n        ExecutorService ex = Executors.newCachedThreadPool();\n        \n        Future<Integer> f = ex.submit(c); //finishes in the future\n        \n        try{\n            Integer v = f.get(); // will block until done\n            System.out.println(\"Ran: \" + v);\n        } catch(InterruptedException | ExecutionException iex){\n            System.out.println(\"Failed\");\n        }\n        \n        for(int i = 0; i<10; i++){\n            System.out.println(\"main: \"+ i);\n        }\n        \n        ex.shutdown();\n    }\n}\n\nclass LoopCounter implements Callable<Integer> {\n    \n    public Integer call(){\n        int count = ThreadLocalRandom.current().nextInt(1,11);\n        for(int i = 1; i <= count; i++){\n                System.out.println(\"running...\" + i);\n        }\n        return count;\n    }\n}','The program will complete normally, without shutdown() it would continue to run,\nit is best to shutdown an executor service in order to free up threads.','Executors',1,NULL),(1994,'ExecutorService ex = ...\n//......\n\nex.shutdown(); // no more new tasks but finish existing tasks\n\ntry{\n	boolean term = ex.awaitTermination(2,TimeUnit.SECONDS);\n		//wait two seconds for running tasks to finsish\n} catch(InterruptedException ex) {\n	//did not wait full two seconds\n} finally {\n   if(!ex.isTerminated()) // are all tasks done ?\n   {\n	List<Runnable> unfinished = ex.shutdownNow();\n		// a collection of unfished tasks\n   }\n}','','Executors',1,NULL),(1995,'class RandomInitRA extends RecursiveAction {\n    private static final int THRESHOLD = 10000;\n    private int[] data;\n    private int start;\n    private int end;\n    \n    public RandomInitRA(int[] data, int start, int end) {\n        this.data = data;\n        this.start = start;\n        this.end = end;\n    }\n    \n    protected void compute() {\n        if(end - start <= THRESHOLD) {\n            // if this is a manageable amount of work do the task\n            for(int i = start; i<end; i++){\n                data[i] = ThreadLocalRandom.current().nextInt();\n            }\n        } else { //task too big\n            int halfway = ((end - start) / 2) + start;\n            RandomInitRA a1 = new RandomInitRA(data,start,halfway);\n            a1.fork();\n            RandomInitRA a2 = new RandomInitRA(data,halfway,end);\n            a2.compute();\n            a1.join();\n        }\n    }\n}','breaks a big task down into smaller parts\n\n','Executors',1,NULL),(1996,'class RandomInitRA extends RecursiveAction {\n    private static final int THRESHOLD = 10000;\n    private int[] data;\n    private int start;\n    private int end;\n    \n    public RandomInitRA(int[] data, int start, int end) {\n        this.data = data;\n        this.start = start;\n        this.end = end;\n    }\n    \n    protected void compute() {\n        if(end - start <= THRESHOLD) {\n            // if this is a manageable amount of work do the task\n            for(int i = start; i<end; i++){\n                data[i] = ThreadLocalRandom.current().nextInt();\n            }\n        } else { //task too big\n            int halfway = ((end - start) / 2) + start;\n            RandomInitRA a1 = new RandomInitRA(data,start,halfway);\n            RandomInitRA a2 = new RandomInitRA(data,halfway,end);\n            invokeAll(a1,a2);\n        }\n    }\n}','use invokeAll instead of the fork join compute, \nRecursiveAction does not reutrn a value so you should not excpect a value\nfrom invoke all. ','Executors',1,NULL),(1997,'class RandomInitRA extends RecursiveAction {\n    private static final int THRESHOLD = 10000;\n    private int[] data;\n    private int start;\n    private int end;\n    \n    public RandomInitRA(int[] data, int start, int end) {\n        this.data = data;\n        this.start = start;\n        this.end = end;\n    }\n    \n    protected int compute() {\n        if(end - start <= THRESHOLD) {\n            // if this is a manageable amount of work do the task\n            for(int i = start; i<end; i++){\n                data[i] = ThreadLocalRandom.current().nextInt();\n            }\n        } else { //task too big\n            int halfway = ((end - start) / 2) + start;\n            RandomInitRA a1 = new RandomInitRA(data,start,halfway);\n            RandomInitRA a2 = new RandomInitRA(data,halfway,end);\n            invokeAll(a1,a2);\n        }\n    }\n}','will not compile, return type of compute from RecursiveAction is void as\nRAs do not return values. ','Executors',1,NULL),(1998,'public class Hello{\n    public static void main(String[]  args){\n        \n        \n        \n    }\n}\n \nclass RandomInitRA extends RecursiveAction {\n    private static final int THRESHOLD = 10000;\n    private int[] data;\n    private int start;\n    private int end;\n    \n    public RandomInitRA(int[] data, int start, int end) {\n        this.data = data;\n        this.start = start;\n        this.end = end;\n    }\n    \n    protected void compute() {\n        if(end - start <= THRESHOLD) {\n            // if this is a manageable amount of work do the task\n            for(int i = start; i<end; i++){\n                data[i] = ThreadLocalRandom.current().nextInt();\n            }\n        } else { //task too big\n            int halfway = ((end - start) / 2) + start;\n            RandomInitRA a1 = new RandomInitRA(data,start,halfway);\n            RandomInitRA a2 = new RandomInitRA(data,halfway,end);\n            invokeAll(a1,a2);\n        }\n    }\n}\n\n//given that the task of this RA is to fill a big array with random numbers\n// how would you start it in main given int[] data = new int[10_000_000];','int[] data = new int[10_000_000];\nForkJoinPool fjpool = new ForkJoinPool();\nRandomInitRA ra = new RandomInitRA(data,0,data.length);\n        \nfjpool.invoke(ra);','Executors',1,NULL),(1999,'public class Hello{\n    public static void main(String[]  args){\n        int[] data = new int[10_000_000];\n        ForkJoinPool fjpool = new ForkJoinPool();\n        RandomInitRA ra = new RandomInitRA(data,0,data.length);\n        \n        fjpool.invokeAll(ra);\n    }\n}\n \nclass RandomInitRA extends RecursiveAction {\n    private static final int THRESHOLD = 10000;\n    private int[] data;\n    private int start;\n    private int end;\n    \n    public RandomInitRA(int[] data, int start, int end) {\n        this.data = data;\n        this.start = start;\n        this.end = end;\n    }\n    \n    protected void compute() {\n        if(end - start <= THRESHOLD) {\n            // if this is a manageable amount of work do the task\n            for(int i = start; i<end; i++){\n                data[i] = ThreadLocalRandom.current().nextInt();\n            }\n        } else { //task too big\n            int halfway = ((end - start) / 2) + start;\n            RandomInitRA a1 = new RandomInitRA(data,start,halfway);\n            RandomInitRA a2 = new RandomInitRA(data,halfway,end);\n            invokeAll(a1,a2);\n        }\n    }\n}','the forkjoinpool method is invoke() not invokeAll()\n\nit should be:\n\n	fjpool.invoke(ra);\n\nThere is an invokeAll() but it takes a collection of callable and returns \na list of futures. \n\nnotice too that it doesn\'t return a value, technically it is of type Void, and\nnull is the only valid type for Void','Executors',1,NULL),(2000,'Two subclasses of ForkJoinTask<V>','RecursiveAction RecursiveTask','Executors',1,NULL),(2001,'class RandomInitRA extends RecursiveAction {\n    private static final int THRESHOLD = 10000;\n    private int[] data;\n    private int start;\n    private int end;\n    \n    public RandomInitRA(int[] data, int start, int end) {\n        this.data = data;\n        this.start = start;\n        this.end = end;\n    }\n    \n    public void compute() {\n        if(end - start <= THRESHOLD) {\n            // if this is a manageable amount of work do the task\n            for(int i = start; i<end; i++){\n                data[i] = ThreadLocalRandom.current().nextInt();\n            }\n        } else { //task too big\n            int halfway = ((end - start) / 2) + start;\n            RandomInitRA a1 = new RandomInitRA(data,start,halfway);\n            RandomInitRA a2 = new RandomInitRA(data,halfway,end);\n            invokeAll(a1,a2);\n        }\n    }\n}','this will compile \n\nan overriden method CAN have less restrive access, but not more restrictive.\n\ncompute() is protected in abstract class','Executors',1,NULL),(2002,'','','Executors',1,NULL),(2003,'class RandomInitRA extends RecursiveAction {\n    private static final int THRESHOLD = 10000;\n    private int[] data;\n    private int start;\n    private int end;\n    \n    public RandomInitRA(int[] data, int start, int end) {\n        this.data = data;\n        this.start = start;\n        this.end = end;\n    }\n    \n    private void compute() {\n        if(end - start <= THRESHOLD) {\n            // if this is a manageable amount of work do the task\n            for(int i = start; i<end; i++){\n                data[i] = ThreadLocalRandom.current().nextInt();\n            }\n        } else { //task too big\n            int halfway = ((end - start) / 2) + start;\n            RandomInitRA a1 = new RandomInitRA(data,start,halfway);\n            RandomInitRA a2 = new RandomInitRA(data,halfway,end);\n            invokeAll(a1,a2);\n        }\n    }\n}','will not compile an overriden method CAN have more restrictive access but not \nless. private is less than public.','Executors',1,NULL),(2004,'class RandomInitRA extends RecursiveAction {\n    private static final int THRESHOLD = 10000;\n    private int[] data;\n    private int start;\n    private int end;\n    \n    public RandomInitRA(int[] data, int start, int end) {\n        this.data = data;\n        this.start = start;\n        this.end = end;\n    }\n    \n    void compute() {\n        if(end - start <= THRESHOLD) {\n            // if this is a manageable amount of work do the task\n            for(int i = start; i<end; i++){\n                data[i] = ThreadLocalRandom.current().nextInt();\n            }\n        } else { //task too big\n            int halfway = ((end - start) / 2) + start;\n            RandomInitRA a1 = new RandomInitRA(data,start,halfway);\n            RandomInitRA a2 = new RandomInitRA(data,halfway,end);\n            invokeAll(a1,a2);\n        }\n    }\n}','will not compile, an overriden method cannot have more restrictive access\ndefault is more restrictive than protected.','Executors',1,NULL),(2005,'class FindMaxPosition extends RecursiveTask<Integer> {\n     private static final int THRESHOLD = 10000;\n    private int[] data;\n    private int start;\n    private int end;\n    \n    public FindMaxPosition(int[] data, int start, int end) {\n        this.data = data;\n        this.start = start;\n        this.end = end;\n    }\n    \n    public Integer compute() {\n        if (end - start <= THRESHOLD){\n            int position = 0;\n            for(int i = start; i < end; i++){\n                 if(data[i] > data[position]) {\n                     position = i;\n                 }\n            }\n            \n            return position;\n        } else { //task is too big, split it\n            int halfway = ((end - start) / 2) + start;\n            FindMaxPosition p1 = new FindMaxPosition(data,start,halfway);\n            p1.fork();\n            FindMaxPosition p2 = new FindMaxPosition(data,start,halfway);\n            int pos2 = p2.compute();\n            int pos1 = p1.join();\n            \n            //these forked tasks found the greatest value in their subsections now compare the two results \n            \n            if(data[pos1] > data[pos2]) {\n                return pos1;\n            } else if(data[pos1] < data[pos2]){\n                return pos2;\n            } else {\n                return pos1 < pos2 ? pos1 : pos2;\n            }\n        }\n        \n    }\n}','RecursiveTask<V> returns a value\n\nfor this particular example you should initialize the array with random \nnumber using RandomInitRecursiveAction that doesn\'t return a result. \n\npublic static void main(String[] args) {\n        int[] bigdata = new int[20000];\n        ForkJoinPool fj = new ForkJoinPool();\n        FindMaxPosition fmp = new FindMaxPosition(bigdata,0,bigdata.length);\n        Integer i = fj.invoke(fmp);\n        \n    }','Executors',1,NULL),(2006,'public class Hello{\n    public static void main(String[]  args){\n        int[] data = new int[10_000_000];\n        ForkJoinPool fjpool = new ForkJoinPool();\n        RandomInitRA ra = new RandomInitRA(data,0,data.length);\n        fjpool.invoke(ra);\n        \n        FindMaxPosition task = new FindMaxPosition(data,0,data.length);\n        Integer position = fjpool.invoke(task);\n        System.out.println(\"Bigggest value:;\"+ data[position]);\n    }\n}\n\nclass FindMaxPosition extends RecursiveTask<Integer> {\n     private static final int THRESHOLD = 10000;\n    private int[] data;\n    private int start;\n    private int end;\n    \n    public FindMaxPosition(int[] data, int start, int end) {\n        this.data = data;\n        this.start = start;\n        this.end = end;\n    }\n    \n    public Integer compute() {\n        if (end - start <= THRESHOLD){\n            int position = 0;\n            for(int i = start; i < end; i++){\n                 if(data[i] > data[position]) {\n                     position = i;\n                 }\n            }\n            \n            return position;\n        } else { //task is too big, split it\n            int halfway = ((end - start) / 2) + start;\n            FindMaxPosition p1 = new FindMaxPosition(data,start,halfway);\n            p1.fork();\n            FindMaxPosition p2 = new FindMaxPosition(data,start,halfway);\n            int pos2 = p2.compute();\n            int pos1 = p1.join();\n            \n            //these forked tasks found the greatest value in their subsections now compare the two results \n            \n            if(data[pos1] > data[pos2]) {\n                return pos1;\n            } else if(data[pos1] < data[pos2]){\n                return pos2;\n            } else {\n                return pos1 < pos2 ? pos1 : pos2;\n            }\n        }\n        \n    }\n}\n \nclass RandomInitRA extends RecursiveAction {\n    private static final int THRESHOLD = 10000;\n    private int[] data;\n    private int start;\n    private int end;\n    \n    public RandomInitRA(int[] data, int start, int end) {\n        this.data = data;\n        this.start = start;\n        this.end = end;\n    }\n    \n    protected void compute() {\n        if(end - start <= THRESHOLD) {\n            // if this is a manageable amount of work do the task\n            for(int i = start; i<end; i++){\n                data[i] = ThreadLocalRandom.current().nextInt();\n            }\n        } else { //task too big\n            int halfway = ((end - start) / 2) + start;\n            RandomInitRA a1 = new RandomInitRA(data,start,halfway);\n            RandomInitRA a2 = new RandomInitRA(data,halfway,end);\n            invokeAll(a1,a2);\n        }\n    }\n}','This will create an array of 10000000 elements then, find the biggest value in it\n','Executors',1,NULL),(2007,'ConcurrentMap<String,Integer> ages = new ConcurrentHashMap<>();\nages.put(\"John\",23);\n\nWhich method would delete Joh from the map only if his value was still equal \nto 23','ages.remove(\"John\",23);\n\npublic boolean remove(Object key,\n             Object value)\n\nRemoves the entry for a key only if currently mapped to a given value. This is equivalent to\n\n   if (map.containsKey(key) && map.get(key).equals(value)) {\n       map.remove(key);\n       return true;\n   } else return false;\n\nexcept that the action is performed ATOMICALLY.\n\nThere is another remove method that comes from the map Interface...\nthat is the standard remove function.\n\npublic V remove(Object key)\n\nRemoves the key (and its corresponding value) from this map. This method does nothing if the key is not in the map.\n\nSpecified by:\n    remove in interface Map<K,V>\nOverrides:\n    remove in class AbstractMap<K,V>\nParameters:\n    key - the key that needs to be removed\nReturns:\n    the previous value associated with key, or null if there was no mapping for key','Concurrency',1,NULL),(2008,'AtomicInteger i = new AtomicInteger();\ntwo methods to atomically increment by 9?','i.addAndGet(9);\ni.getAndAdd(9);','Concurrency',1,NULL),(2009,'class LeaderBoard {\n    private ReadWriteLock rwl = new ReentrantReadWriteLock();\n    private List<Integer> highScores = new ArrayList<Integer>();\n    public void addScore(Integer score){\n        Lock lock = rwl.writeLock();\n        lock.lock();\n        \n        try{\n            if(highScores.size() < 10) {\n                highScores.add(score);\n            } else if(highScores.get(highScores.size() - 1) < score) {\n                highScores.set(highScores.size() - 1, score);\n            } else {\n                return;\n            }\n            \n            Collections.sort(highScores,Collections.reverseOrder());\n        } finally{\n            lock.unlock();\n        }\n    }\n    \n    public List getHighScores(){\n        Lock lock = rwl.readLock();\n        lock.lock();\n        try{\n            return Collections.unmodifiableList(highScores);\n        } finally {\n            lock.unlock();\n        }\n    }\n}','only one thread at a time can access the write lock where multiple threads\ncan access the readLock','Concurrency',1,NULL),(2010,'public class Hello {\n\n    public static void main(String[] args) {\n       LeaderBoard lb = new LeaderBoard();\n       lb.addScore(56);\n    }\n    \n}\n\nclass LeaderBoard {\n    private ReadWriteLock rwl = new ReentrantReadWriteLock();\n    private List<Integer> highScores = new ArrayList<Integer>();\n    public void addScore(Integer score){\n        Lock lock = rwl.writeLock();\n        \n        try{\n            if(highScores.size() < 10) {\n                highScores.add(score);\n            } else if(highScores.get(highScores.size() - 1) < score) {\n                highScores.set(highScores.size() - 1, score);\n            } else {\n                return;\n            }\n            \n            Collections.sort(highScores,Collections.reverseOrder());\n        } finally{\n            lock.unlock();\n        }\n    }\n    \n    public List getHighScores(){\n        Lock lock = rwl.readLock();\n        lock.lock();\n        try{\n            return Collections.unmodifiableList(highScores);\n        } finally {\n            lock.unlock();\n        }\n    }\n}','IllegalMonitorStateExcetion rwl.writeLock() was not locked before it was unloked\n','Concurrency',1,NULL),(2011,'public class Hello {\n\n    public static void main(String[] args) {\n       LeaderBoard lb = new LeaderBoard();\n       lb.addScore(5);\n    }\n    \n}\n\nclass LeaderBoard {\n    private ReadWriteLock rwl = new ReentrantReadWriteLock();\n    private List<Integer> highScores = new ArrayList<Integer>();\n    public void addScore(Integer score){\n        Lock lock = rwl.writeLock();\n        lock.lock();\n        try{\n            if(highScores.size() < 10) {\n                highScores.add(score);\n            } else if(highScores.get(highScores.size() - 1) < score) {\n                highScores.set(highScores.size() - 1, score);\n            } else {\n                return;\n            }\n            \n            Collections.sort(highScores,Collections.reverseOrder());\n        } finally{\n\n        }\n    }\n    \n    public List getHighScores(){\n        Lock lock = rwl.readLock();\n        lock.lock();\n        try{\n            return Collections.unmodifiableList(highScores);\n        } finally {\n            lock.unlock();\n        }\n    }\n}','compiles fine, The writeLock is locked but never unlocked,that will not throw\nan exception.','Concurrency',1,NULL),(2012,'public class Hello {\n\n    public static void main(String[] args) {\n       LeaderBoard lb = new LeaderBoard();\n       Player a = new Player(lb);\n       Player b = new Player(lb);\n       Player c = new Player(lb);\n       \n       a.start();\n       b.start();\n       c.start();\n    }\n    \n}\n\nclass LeaderBoard {\n    private ReadWriteLock rwl = new ReentrantReadWriteLock();\n    private List<Integer> highScores = new ArrayList<Integer>();\n    public void addScore(Integer score){\n        Lock lock = rwl.writeLock();\n        lock.lock();\n        try{\n            if(highScores.size() < 10) {\n                highScores.add(score);\n            } else if(highScores.get(highScores.size() - 1) < score) {\n                highScores.set(highScores.size() - 1, score);\n            } else {\n                return;\n            }\n            \n            Collections.sort(highScores,Collections.reverseOrder());\n        } finally{\n            lock.unlock();\n        }\n    }\n    \n    public List getHighScores(){\n        Lock lock = rwl.readLock();\n        lock.lock();\n        try{\n            return Collections.unmodifiableList(highScores);\n        } finally {\n\n        }\n    }\n}\n\nclass Player extends Thread {\n    private LeaderBoard lb;\n    public Player(LeaderBoard x){\n        lb = x;\n        \n    }\n    public void run(){\n        System.out.println(Thread.currentThread().getName()+\" \"+lb.getHighScores());\n        for(int i = 0; i<3; i++){\n            postHighScore();\n        }    \n    }\n    \n    public void postHighScore(){\n        lb.addScore(ThreadLocalRandom.current().nextInt());\n    }\n}\n','Thread-0 []\nThread-2 []\nThread-1 []\n... and will keep running\n\nsince the readlock is never unlocked() in getHighScores() the three threads will\nacquire the read lock but never release it. \n\nThat will prevent any of them from getting the write lock. RRWL allows multiple\nthreads to read at the same time but will wait for an exclusive lock before\nallowing threads to write to it. meaning no other thread can be reading while\nanother thread is writing to the locked object!','Concurrency',1,NULL),(2013,'I can\'t seem to determine any difference between InputStreamReader and FileReader besides the way the two are initialized. \nIs there any benefit to using one or the other? \nMost other articles cover FileInputStream vs InputStreamReader, but I am contrasting with FileReader instead. \nSeems to me they both have the same purpose.','\n\nFirst, InputStreamReader can handle all input streams, not just files. Other examples are network connections, classpath resources and ZIP files.\n\nSecond, FileReader does not allow you to specify an encoding and instead uses the plaform default encoding, which makes it pretty much useless as using it will result in corrupted data when the code is run on systems with different platform default encodings.\n\nIn short, forget that FileReader exists.\n','General',1,NULL),(2014,'while (scanNumOfLines.hasNextLine())    \n    {\n    NumOfLines ++;\n    scanNumOfLines.nextLine();\n    }\n    System.out.println(\"NumOfLines = \"+NumOfLines);\n\nSo it counts fine, but I want to re-use the scanner for another purpose, but the nextLine has moved to the last line of the file, and I want to reset it back to the first line.\n\n(Instead, I had to use another scanner for the other purpose, and to me this seems less elegant than it should be.)\n\nI\'m sure there must be a scanner method that resets the counter to zero?','-This is impossible to do.\n The reason to not include it, is the wide range of input types it supports. One example is streams. These don\'t store the results after they have been passed on,\n so they don\'t support resetting.\n So the elegant way is to create a new Scanner. \n If you give it many custom settings, create a factory method.\n\n-There is no \"counter\" in the Scanner object. \n Instead think of it as more like a conveyor belt. \n The belt has no knowledge or care about what\'s on it. \n It just keeps spitting things out at you while there are items left on it. \n And once you take them, they\'re gone from it for good.\n','General',1,NULL),(2015,'What difference that final makes between the code below. Is there any advantage in declaring the arguments as final.\n\npublic String changeTimezone( Timestamp stamp, Timezone fTz, Timezone toTz){  \n    return ....\n}\n\npublic String changeTimezone(final Timestamp stamp, final Timezone fTz, \n        final Timezone toTz){\n    return ....\n}\n\n','- \n\nAs a formal method parameter is a local variable, you can access them from inner anonymous classes only if they are declared as final.\n\nThis saves you from declaring another local final variable in the method body:\n\n void m(final int param) {\n        new Thread(new Runnable() {\n            public void run() {\n                System.err.println(param);\n            }\n        }).start();\n    }\n\n\n\n\n- final is used here to ensure the two indexes i and j won\'t accidentally be reset by the method. It\'s a handy way to protect against an insidious bug that erroneously changes the value of your parameters. \nGenerally speaking, short methods are a better way to protect from this class of errors,\nbut final parameters can be a useful addition to your coding style.\nNote that final parameters are not considered part of the method signature, and are ignored by the compiler when resolving method calls. Parameters can be declared final (or not) with no influence on how the method is overriden.\n\n-Might be better to use objects rather than primitives for this example, as primitive changes will always only be visible inside the method. \nAnd in the case of objects, you can still change them. You just can\'t point at a new object. In fact now I think about it, final doesn\'t really change anything \ncompared to leaving it out, other than saving a variable declaration with AICs and having the compiler point out accidental modifications of parameters that \nyou didn\'t want to modify for some reason.\n\n\n\nThe final prevents you from assining a new value to the variable, and this can be helpful in catching typos. \nStylistically you might like to keep the parameters received unchanged and assign only to local variables, \nso final would help to enforce that style.\n\npublic int example(final int basicRate){\n    int discountRate;\n\n    discountRate = basicRate - 10;\n    // ... lots of code here \n    if ( isGoldCustomer ) {\n        basicRate--;  // typo, we intended to say discountRate--, final catches this\n    }\n    // ... more code here\n\n    return discountRate;\n}\n\n','General',1,NULL),(2016,'abstract class A {\n    public abstract void foo(final String s);\n}\n\nclass B extends A {\n    public void foo(String x){\n        System.out.println(x);\n    }\n}','compiles fine','General',1,NULL),(2017,'Executor ex = Executors.newFixedThreadPool(9);\nExecutor ex2 = Executors.newFixedThreadPool();\nExecutor ex3 = Executor.newFixedThreadPool(9);\nExecutor ex4 = Executors.newCachedThreadPool(7);\n\nwhich can compile ?','only the first,\n\nthe only argument constructor for cachedthreadpool takes a threadfactory.\n\na fixed thread pool has to have a size.','Executors',1,NULL),(2018,'private Integer executeTask (ExecutorService service, Callable<Integer> task){\n        try{\n            Future<Integer> future = service.submit(task);\n            return future.get();\n        } catch(InterruptedException e){\n            return null;\n        }\n    }','will not compile, unreported exception ExecutionException thrown by .get()','Executors',1,NULL),(2019,'private Integer executeTask (ExecutorService service, Callable<Integer> task){\n        try{\n            Future<Integer> future = service.submit(task);\n            return future.get();\n        } catch(ExecutionException e){\n            return null;\n        }\n    }','will not compile, unreported Exeption InterruptedException thrown by .get()\n\nshould be :\n\n	catch(ExecutionException | InterruptedException e){\n            return null;\n        }','Executors',1,NULL),(2020,' private Integer executeTask (ExecutorService service, Callable<Integer> task){\n        try{\n            Future<Integer> future = service.submit(task);\n            return future.get();\n        } catch(InterruptedException | ExecutionException e){\n            return null;\n        }\n    }','will execute the submitted task\n\nfuture.get() will block until the activity is done.','Executors',1,NULL),(2021,' private Integer executeTask (ExecutorService service, Callable<Integer> task){\n        // insert code \n    }\n\nwhat code could you insert here to execute the task using the service','try{\n	Future<Integer> future = service.submit(task);\n	return future.get();\n} catch(InterruptedException | ExecutionException e){\n   	return null;\n}\n\nor ...\n\ntry{\n	Future<Integer> future = service.submit(task);\n	return future.get();\n} catch(Exception e){\n   	return null;\n}\n\n.get() will block until a result is available','Executors',1,NULL),(2022,'A runnable can return a result and throw an exception','FALSE, A Callable<E> can do that a runnable cannot do either of those things.','Executors',1,NULL),(2023,'With RecursiveTask subclasses which are true ?\n\n1.fork() and join() should be called on the same task.\n2.fork() and compute() should be called on the same task.\n3.compute() and join() should be called on the same task.\n4.compute() should be called before fork()\n5.fork() should be called before compute()\n6.join() should be called after fork() but before compute()','1 and 5\n\nWhen creating multiple forkjointask instances all tasks except one shuld be forked\nfirst so that they can be picked up by other forkjoin worker threads.\nThe final task should then be executed within the same thread by calling compute()\nbefore calling join on all the forked threads to await their results. \n\ncallin methods in the wrong order will not cause compiler error so care must be taken','Concurrency',1,NULL),(2024,'public class Hello {\n\n    public static void main(String[] args) {\n        Fibonacci fibonacci = new Fibonacci(10);\n        ForkJoinPool pool = new ForkJoinPool();\n        System.out.println(pool.invoke(fibonacci));\n    }\n}\n\nclass Fibonacci extends RecursiveTask<Long> {\n    final long n;\n    \n    Fibonacci(long n) {\n        this.n = n;\n    }\n    \n    public Long compute() {\n        if (n<=10) {\n            return do_fibonacci(n);\n        }\n        ForkJoinTask<Long> subTask = new Fibonacci(n-1).fork();\n        return new Fibonacci(n-2).compute() + subTask.join();\n    }\n    \n    static long do_fibonacci(long n) {\n        if ( n<=1 ) return n;\n        return do_fibonacci(n-1) + do_fibonacci(n-2);\n    }\n}','55','Concurrency',1,NULL),(2025,'public class Hello {\n\n    public static void main(String[] args) {\n        Fibonacci fibonacci = new Fibonacci(10);\n        ForkJoinPool pool = new ForkJoinPool();\n        System.out.println(pool.invoke(fibonacci));\n    }\n}\n\nclass Fibonacci extends RecursiveTask<Long> {\n    final long n;\n    \n    Fibonacci(long n) {\n        this.n = n;\n    }\n    \n    public Long compute() {\n        if (n<=10) {\n            return do_fibonacci(n);\n        }\n        //ForkJoinTask<Long> subTask = new Fibonacci(n-1).fork();\n        //return new Fibonacci(n-2).compute() + subTask.join();\n        //same as ...\n        ForkJoinTask<Long> f1 = new Fibonacci(n-1);\n        Fibonacci f2 = new Fibonacci(n-2);\n        f1.fork();\n        Long l1 = f2.compute();\n        Long l2 = f1.join();\n        return l1+l2;\n    }\n    \n    static long do_fibonacci(long n) {\n        if ( n<=1 ) return n;\n        return do_fibonacci(n-1) + do_fibonacci(n-2);\n    }\n}','55, join() returns the result of the forked procedure. \n\nfork() and join() should be called on the same, Task','Concurrency',1,NULL),(2026,'class Fibonacci extends RecursiveTask<Long> {\n    final long n;\n    \n    Fibonacci(long n) {\n        this.n = n;\n    }\n    \n    public Long compute() {\n        if (n<=10) {\n            return do_fibonacci(n);\n        }\n        //ForkJoinTask<Long> subTask = new Fibonacci(n-1).fork();\n        //return new Fibonacci(n-2).compute() + subTask.join();\n        //same as ...\n        ForkJoinTask<Long> f1 = new Fibonacci(n-1);\n        ForkJoinTask<Long> f2 = new Fibonacci(n-2);\n        f1.fork();\n        Long l1 = f2.compute();\n        Long l2 = f1.join();\n        return l1+l2;\n    }\n    \n    static long do_fibonacci(long n) {\n        if ( n<=1 ) return n;\n        return do_fibonacci(n-1) + do_fibonacci(n-2);\n    }\n}','Polymorphism bites you in the ass here again,\nclass Fibonacci has a compute method not FJT','Concurrency',1,NULL),(2027,'public class Hello {\n\n    public static void main(String[] args) {\n        Fibonacci fibonacci = new Fibonacci(10);\n        ForkJoinPool pool = new ForkJoinPool();\n        System.out.println(pool.invoke(fibonacci));\n    }\n}\n\nclass Fibonacci extends RecursiveTask<Long> {\n    final long n;\n    \n    Fibonacci(long n) {\n        this.n = n;\n    }\n    \n    public Long compute() {\n        if (n<=10) {\n            return do_fibonacci(n);\n        }\n        //ForkJoinTask<Long> subTask = new Fibonacci(n-1).fork();\n        //return new Fibonacci(n-2).compute() + subTask.join();\n        //same as ...\n        ForkJoinTask<Long> f1 = new Fibonacci(n-1);\n        Fibonacci<Long> f2 = new Fibonacci(n-2);\n        f1.fork();\n        Long l1 = f2.compute();\n        Long l2 = f1.join();\n        return l1+l2;\n    }\n    \n    static long do_fibonacci(long n) {\n        if ( n<=1 ) return n;\n        return do_fibonacci(n-1) + do_fibonacci(n-2);\n    }\n}','type fibonacci does not take parameters','General',1,NULL),(2028,'public class Hello {\n\n    public static void main(String[] args) {\n         Fibonacci fibonacci = new Fibonacci(15);\n         ForkJoinPool pool = new ForkJoinPool();\n         System.out.println(pool.invoke(fibonacci));\n    }\n}\n\n\nclass Fibonacci extends RecursiveTask<Long> {\n    final long n;\n    public static Long[] result = new Long[2];\n    public static int max_num = 1;\n    \n    public static void set_max(int num) {\n        result[0] = new Long(1);\n        result[1] = new Long(1);\n        if ( num > max_num ) {\n            Long[] new_result = new Long[num+1];\n            \n            for (int i=0; i<=max_num; i++) {\n                new_result[i] = result[i];\n            }\n            \n            result = new_result;\n            \n            for (int i=max_num+1; i<=num; i++) {\n                result[i] = new Long(0);\n            }\n            max_num = num;            \n        }\n    }\n    \n    Fibonacci(long n) {\n        this.n = n;\n        if ( n > 1 )\n            set_max((int)n);\n    }\n        \n    public Long compute() {\n        Long ret;\n        if ( result[(int)n].longValue() != 0 ) {\n            return result[(int)n];\n        }\n        if (n<=10) {\n            return do_fibonacci(n);\n        }\n        ForkJoinTask<Long> subTask = new Fibonacci(n-1);\n        ret = new Fibonacci(n-2).compute() + subTask.join();\n        result[(int)n] = new Long(ret);\n        return ret;\n    }\n    \n    static long do_fibonacci(long n) {\n        long ret;\n        if (result[(int)n].longValue() != 0) {\n            ret = result[(int)n].longValue();\n        } else {\n            long ret_n_1 = do_fibonacci(n-1);\n            long ret_n_2 = do_fibonacci(n-2);\n            ret = ret_n_1 + ret_n_2;\n            result[(int)n] = new Long(ret);\n        }\n        return ret;\n    }\n}','this program will never complete subtask is never forked so using join() will \nnever be able to return a result and it will block forever. \n\nto fix \n\nsubtask.fork();\n\n	ForkJoinTask<Long> subTask = new Fibonacci(n-1).fork();\n        ret = new Fibonacci(n-2).compute() + subTask.join();\n        result[(int)n] = new Long(ret);\n        return ret;','General',1,NULL),(2029,'public class Hello {\n\n    public static void main(String[] args) {\n         Fibonacci fibonacci = new Fibonacci(15);\n         ForkJoinPool pool = new ForkJoinPool();\n         System.out.println(pool.invoke(fibonacci));\n    }\n}\n\n\nclass Fibonacci extends RecursiveTask<Long> {\n    final long n;\n    public static Long[] result = new Long[2];\n    public static int max_num = 1;\n    \n    public static void set_max(int num) {\n        result[0] = new Long(1);\n        result[1] = new Long(1);\n        if ( num > max_num ) {\n            Long[] new_result = new Long[num+1];\n            \n            for (int i=0; i<=max_num; i++) {\n                new_result[i] = result[i];\n            }\n            \n            result = new_result;\n            \n            for (int i=max_num+1; i<=num; i++) {\n                result[i] = new Long(0);\n            }\n            max_num = num;            \n        }\n    }\n    \n    Fibonacci(long n) {\n        this.n = n;\n        if ( n > 1 )\n            set_max((int)n);\n    }\n        \n    public Long compute() {\n        Long ret;\n        if ( result[(int)n].longValue() != 0 ) {\n            return result[(int)n];\n        }\n        if (n<=10) {\n            return do_fibonacci(n);\n        }\n        ForkJoinTask<Long> subTask = new Fibonacci(n-1);\n        ret = new Fibonacci(n-2).compute() + subTask.join();\n        subTask.fork();\n        result[(int)n] = new Long(ret);\n        return ret;\n    }\n    \n    static long do_fibonacci(long n) {\n        long ret;\n        if (result[(int)n].longValue() != 0) {\n            ret = result[(int)n].longValue();\n        } else {\n            long ret_n_1 = do_fibonacci(n-1);\n            long ret_n_2 = do_fibonacci(n-2);\n            ret = ret_n_1 + ret_n_2;\n            result[(int)n] = new Long(ret);\n        }\n        return ret;\n    }\n}','will wait forever a subtask has to be fork()ed before it can rejoin the \nmain task. ','General',1,NULL),(2030,'private final ReentrantReadWriteLock    rwl         = new ReentrantReadWriteLock();\nprotected final Lock                    readLock    = rwl.readLock();\nprotected final Lock                    writeLock   = rwl.writeLock();\nprotected final Condition               hasData     = writeLock.newCondition();\n\n\npublic void write() {\n\n    writeLock.lock();\n    try {\n        // write data\n        // ...\n        if (something_written) {\n            hasData.signalAll();\n        }\n    }\n    finally {\n        writeLock.unlock();\n    }\n}\n\n// replace Object by something else\npublic Object read() throws InterruptedException {\n\n    Object data = tryRead();\n\n    while (data == null) {\n        waitForData();\n        data = tryRead();\n    }\n\n    return data;\n}\n\n// replace Object by something else\nprivate Object tryRead() {\n\n    readLock.lock();\n    try {\n        Object data = null;\n        // read data\n        // ...\n        // if there no data available, return null\n        return data;\n    }\n    finally {\n        readLock.unlock();\n    }\n}\n\nprivate void waitForData() throws InterruptedException {\n\n    writeLock.lock();\n    try {\n        boolean data_available = // check data\n        while (!data_available) {\n            hasData.await(1000L, TimeUnit.MILLISECONDS);\n            data_available = // check data\n        }\n    }\n    finally {\n        writeLock.unlock();\n    }\n}\n','This is the same behavior of your typical ReadWriteLock usage case if there\n is available data for reading. If no data exists, then a reader becomes a\n \"writer\" (in the lock sense) and waits until some data is available. The \ncycle repeats until some available data is returned (or until an interrupt \noccurs).\n\nSince you\'re using a ReadWriteLock, it means you\'re expecting a much \ngreater number of reads than writes and so you chose a lock that minimizes \ncontention between reader threads (the readLock).\n\nThe method waitForData() turns readers into \"writers\" because they lock on\n the writeLock instead, resulting in an increased contention between all\n threads (readers and writers). However, since writes are assumed to be \nmuch rarer than reads, a situation where data keeps toggling fast \nbetween \"available\" and \"unavailable\" is not expected. In other words, \nassuming writes are rare:\n\n    If there is no available data for reading, then virtually all readers\n will typically block in the method waitForData() after some time, and\n will all be notified at the same time when some new data is written.\n\n    If there is some available data for reading, then all readers will\n simply read it without creating any contention among the threads when \nlocking the readLock.\n','Concurrency',1,NULL),(2031,'private final ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();\nprotected final Lock readLock = rwl.readLock();\nprotected final Lock writeLock = rwl.writeLock();\nprotected final Condition hasData = writeLock.newCondition();\nprivate HashMap myData = new HashMap(); //example structure to read and write\n\nprivate final ReentrantLock dataArrivalLock = new ReentrantLock();\nprivate final Condition dataArrivalSignal = dataArrivalLock.newCondition();\n\nYour writer method pattern :\n\ntry {\n   writeLock.lock();    \n\n   //...\n   myData.put(\"foo\",\"ffoo\"); //write something !!\n   if( something_written ) {\n      hasData.signalAll();\n   }\n\n}\nfinally {\n   writeLock.unlock();\n}\n  try {\n                //signal other threads that data has been put in\n                dataArrivalLock.lock();\n                dataArrivalSignal.signalAll();\n\n            } finally {\n                dataArrivalLock.unlock();\n            }\n\nYour reader method pattern\n\ntry {\n            boolean gotData = false;\n            while (!gotData) {\n                try {\n                    readLock.lock();\n                    if (myData.size() > 0) {\n                        gotData = true;\n                        //retrieve the data that is written by writer thred!!\n                        myData.get(\"foo\");\n                    }\n                } finally {\n                    readLock.unlock();\n                }\n                if(!gotData) {\n //sleep the reader thread for x milliseconds. x depends on your application requirement\n                  //   Thread.sleep(250);\n                    try {\n                        //instead of Thread.sleep(), use the dataArrivalLock signal to wakeup\n                        dataArrivalLock.lock();\n                        dataArrivalSignal.await();\n                        //based on how the application works a timed wait might be better !!\n                        //dataArrivalSignal.await(250);\n                    } finally {\n                        dataArrivalLock.unlock();\n                    }\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        } ','What this does is force your reader thread to sleep until some data is written by the writer thread .','Concurrency',1,NULL),(2032,'class CarRadio extends Thread {\n    \n    public void run(){\n      while(true){  \n        Song nextSong = DJ.spinNextTrack();\n        play(nextSong);\n        try{ Thread.sleep(2000); } catch(InterruptedException e) { }\n      }\n    }\n    public void play(Song song){\n        System.out.println(\"CarRadio: \"+song.getClip());\n    }\n    \n}\n\nclass DJ {\n    private final static LinkedList<Song> queue = new LinkedList<>();\n    private final static ReentrantReadWriteLock queueLock = new ReentrantReadWriteLock();\n    private final static Lock readLock = queueLock.readLock();\n    private final static Lock writeLock = queueLock.writeLock();\n    private final static Condition newSong = writeLock.newCondition();\n    private final static Condition readSong = readLock.newCondition();\n    private final static DJ INSTANCE = new DJ();\n    \n    private DJ(){\n\n    }\n    \n    public static DJ callDJ(){\n        return INSTANCE;\n    }\n\n    public static Song spinNextTrack(){\n        readLock.lock();\n        try{\n            if(queue.isEmpty()){\n                try { newSong.await(); }catch(InterruptedException e) { }\n            }\n            return queue.poll(); \n        } finally {\n            readLock.unlock();\n        }      \n    }\n\n    public static void addToQueue(Song song){\n        writeLock.lock();\n        try{\n            //this lock blocks until acquired\n            //queueLock.writeLock().lock();\n            queue.add(song);\n            newSong.signalAll();\n        } finally{\n            writeLock.unlock();\n        }\n    }\n}\n\nclass ConstantPop extends Thread {\n    private String[] sounds = {\" Lah \", \" La La \", \" Naaahh \", \" YOLO \" };\n    private static int songCounter = 0;\n    \n    public void run(){\n        while(true){\n            Song hotNewSong = studio();\n            DJ.addToQueue(hotNewSong);\n            try { Thread.sleep(2000); } catch(InterruptedException e) { }  \n        }\n    }\n    private Song studio(){\n        StringBuilder sb = new StringBuilder();\n        for(int i = 0; i<=3; i++){\n            sb.append(sounds[ThreadLocalRandom.current().nextInt(0,3)]);\n        }\n        songCounter++;\n        return new Song(\"PopSong.\"+songCounter,sb.toString());\n    }\n}','Read lock does not support Conditions so calling newCondition() will cause \nan UnsupportedOperationException','Concurrency',1,NULL),(2033,'Which Collection from java.util.concurrent is best when there are more reads\nthan writes','Copy on write, because they mkae a new copy of the collection for each write.','Concurrency',1,NULL),(2034,'ConcurrentSkipListMap and concurrentMap atomic methods','putIfAbsent(K key, V value)\n\nremove(Object key, Object value)\n\nreplace(K key, V value)\n\nreplace(K key, V oldValue, V newValue)','Concurrency',1,NULL),(2035,'Factory patter:','a concrete class with static methods is used to create instances of objects \nthat implement an interface.','Concurrency',1,NULL),(2036,'what pattern ?\n\npublic interface Vehicle {\n	public void start();\n	public void stop();\n}\n\npublic class Car implements Vehicle {\n	public void start() { }\n	public void stop() { }\n}\n\npublic class CarManufacturer {\n	public static Vehicle getVehicle(String type) {\n		//create an instance of the type passed in\n	}\n}\n\nclass MyClass {\n	psmv(sa) {\n		Vehicle ferrari = CarManufacturer.getVehicle(\"Ferrari\");\n	\n		ferrari.start();\n	}\n}','Factory,\n\nfactory is used to create instances of classes that implement an interface.\nCan be used at runtime to decide which object to create at runtime','Concurrency',1,NULL),(2037,'for jdbc 3.0 drivers and earlier you are responsible for loading the class\nusing static forName(). Later driver classes are loaded automatically.','','Concurrency',1,NULL),(2038,'public class Hello {\n    public static void main(String[] args){\n        try {\n            Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\");\n            Statement st = conn.createStatement();\n            String query = \"Select * From employees limit 10\";\n            ResultSet rs = st.executeQuery(query);\n            while(rs.next()){\n                System.out.println(rs.getInt(\"emp_no\"));\n                System.out.println(rs.getString(\"first_name\"));\n                System.out.println(rs.getString(\"last_name\"));\n            } \n            \n        } catch(SQLException e){ }\n        \n    }\n}\n','10001\nGeorgi\nFacello\n10002\nBezalel\nSimmel\n10003\nParto\nBamford\n10004\nChirstian\nKoblick\n10005\nKyoichi\nMaliniak\n10006\nAnneke\nPreusig\n10007\nTzvetan\nZielinski\n10008\nSaniya\nKalloufi\n10009\nSumant\nPeac\n10010\nDuangkaew\nPiveteau','Concurrency',1,NULL),(2039,'public class Hello {\n    public static void main(String[] args){\n        try {\n            Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\");\n            Statement st = conn.createStatement();\n            String update = \"update employee set emp_no = 11111 where first_name = Georgi\";\n            ResultSet rs = st.executeUpdate(update);\n            while(rs.next()){\n                System.out.println(rs.getInt(\"emp_no\"));\n                System.out.println(rs.getString(\"first_name\"));\n                System.out.println(rs.getString(\"last_name\"));\n            } \n            \n        } catch(SQLException e){ }\n        \n    }\n}','will not compile, executeUPdate returns an int of updated rows.','Concurrency',1,NULL),(2040,'what jdbc method would you use when you are unsure of the result of a query\nor update','execute(String sql) \n\nthe return value is true if the result is a result set and false if the \nquery is an update count or no results. \n\n','Concurrency',1,NULL),(2041,'public class Hello {\n    public static void main(String[] args){\n        try {\n            Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\");\n            Statement st = conn.createStatement();\n            String update = \"Update employees Set first_name = \'Big John\' where first_name = \'Georgi\'\";\n            boolean b = st.execute(update);\n            System.out.println(b);\n        } catch(SQLException e){System.out.println(\"something went wrong\"); }\n        \n    }\n}','false \n\nexecute returns true if it returns a result set and false for an update count','Concurrency',1,NULL),(2042,'public class Hello {\n    public static void main(String[] args){\n        try {\n            Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\");\n            Statement st = conn.createStatement();\n            String update = \"Update employees Set first_name = \'Big John\' where first_name = \'Georgi\'\";\n            boolean b = st.execute(update);\n            if(b){\n                //ResultSet res = update.getResultSet();\n                ResultSet res = st.getResultSet();\n            } else {\n                int numrows = st.getUpdateCount();\n                if(numrows == -1){\n                    System.out.println(\"No Results\");\n                }\n            }\n        } catch(SQLException e){System.out.println(\"something went wrong\"); }\n        \n    }\n}','if getUpdateCount() returns -1 then there were no results.','Concurrency',1,NULL),(2043,'public class Hello {\n    public static void main(String[] args){\n        try {\n            Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\");\n            Statement st = conn.createStatement();\n            String update = \"Update employees Set first_name = \'Big John\' where first_name = \'Georgi\'\";\n            boolean b = st.execute(update);\n            if(b){\n                ResultSet res = update.getResultSet();\n            } else {\n                int numrows = st.getUpdateCount();\n                if(numrows == -1){\n                    System.out.println(\"No Results\");\n                }\n            }\n        } catch(SQLException e){System.out.println(\"something went wrong\"); }\n        \n    }\n}','will not compiles, getResultSet is from a statement object','Concurrency',1,NULL),(2044,'public class Hello {\n    public static void main(String[] args){\n        try {\n            Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\");\n            Statement st = conn.createStatement();\n            String update = \"Select first_name from employees\";\n            boolean b = st.execute(update);\n            if(b){\n                //ResultSet res = update.getResultSet();\n                ResultSet res = st.getResultSet();\n                System.out.println(res.getString(\"first_name\"));\n            } else {\n                int numrows = st.getUpdateCount();\n                if(numrows == -1){\n                    System.out.println(\"No Results\");\n                }\n            }\n            \n            \n        } catch(SQLException e){System.out.println(\"something went wrong\"); }\n        \n    }\n}','something went wrong\n\nyou have to always call next() before processing a rown from a result set \nthe cursors starts out as before the first row.\n\nIt is a sqlexception to try to get a row when it is before the first row.','Concurrency',1,NULL),(2045,'public class Hello {\n    public static void main(String[] args){\n        try {\n            Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\");\n            Statement st = conn.createStatement();\n            String update = \"Select first_name from employees\";\n            boolean b = st.execute(update);\n            if(b){\n                //ResultSet res = update.getResultSet();\n                ResultSet res = st.getResultSet();\n                res.next();\n                System.out.println(res.getString(\"first_name\"));\n            } else {\n                int numrows = st.getUpdateCount();\n                if(numrows == -1){\n                    System.out.println(\"No Results\");\n                }\n            }\n            \n            \n        } catch(SQLException e){System.out.println(\"something went wrong\"); }\n        \n    }\n}\n','Big John','Concurrency',1,NULL),(2046,'ublic class Hello {\n    public static void main(String[] args){\n        try {\n            Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\");\n            Statement st = conn.createStatement();\n            String update = \"Select first_name from employees\";\n            boolean b = st.execute(update);\n            if(b){\n                ResultSet res = st.getResultSet();\n                res.next();\n                System.out.println(res.getInt(1));\n                System.out.println(res.getDate(2));\n                System.out.println(res.getString(3));\n                \n            } else {\n                int numrows = st.getUpdateCount();\n                if(numrows == -1){\n                    System.out.println(\"No Results\");\n                }\n            }\n            \n            \n        } catch(SQLException e){System.out.println(e); }\n        \n    }\n}','SQLException invalid value for getInt()\n\nyour sql query only selected the firstnames, there are no other coluns to get\ninfo from. ','JDBC',1,NULL),(2047,'public class Hello {\n    public static void main(String[] args){\n        try {\n            Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\");\n            Statement st = conn.createStatement();\n            String update = \"Select * from employees\";\n            boolean b = st.execute(update);\n            if(b){\n                ResultSet res = st.getResultSet();\n                res.next();\n                System.out.println(res.getInt(1));\n                System.out.println(res.getDate(2));\n                System.out.println(res.getString(3));\n                \n            } else {\n                int numrows = st.getUpdateCount();\n                if(numrows == -1){\n                    System.out.println(\"No Results\");\n                }\n            }\n            \n            \n        } catch(SQLException e){System.out.println(e); }\n        \n    }\n}','run:\n10001\n1953-09-02\nBig John\nBUILD SUCCESSFUL (total time: 1 second)\n','JDBC',1,NULL),(2048,'public class Hello {\n    public static void main(String[] args){\n        try {\n            Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\");\n            Statement st = conn.createStatement();\n            String update = \"Select * from employees\";\n            boolean b = st.execute(update);\n            if(b){\n                ResultSet res = st.getResultSet();\n                res.next();\n                System.out.println(res.getInt(0));\n                System.out.println(res.getDate(1));\n                System.out.println(res.getString(2));\n                \n            } else {\n                int numrows = st.getUpdateCount();\n                if(numrows == -1){\n                    System.out.println(\"No Results\");\n                }\n            }\n            \n            \n        } catch(SQLException e){System.out.println(e); }\n        \n    }\n}','sql exception index out of range,\n\nindexs range from 1 to the size','JDBC',1,NULL),(2049,'public class Hello {\n    public static void main(String[] args){\n        try {\n            Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\");\n            Statement st = conn.createStatement();\n            String update = \"Select * from employees\";\n            boolean b = st.execute(update);\n            if(b){\n                ResultSet res = st.getResultSet();\n                System.out.println(res.getInt(1));\n                System.out.println(res.getDate(2));\n                System.out.println(res.getString(3));\n                \n            } else {\n                int numrows = st.getUpdateCount();\n                if(numrows == -1){\n                    System.out.println(\"No Results\");\n                }\n            }\n            \n            \n        } catch(SQLException e){System.out.println(e); }\n        \n    }\n}\n','sqlexception, next() was not called before processing a result set','JDBC',1,NULL),(2050,'java.sql.Date extends java.util.Date\n\nwhats the main difference\n\njava.sql.Date pubDate = rs.getDate(\"PubDate\");','sql Date stores in the form yyyy mm dd','JDBC',1,NULL),(2051,'java.sql.Time time = rs.getTime(\"FinishTime\");\n\nwhat form does this kind of Time take ?','\"hh:mm:ss\"','JDBC',1,NULL),(2052,'use getObject for a general purpose get()\n\njdbc will return a wrapper for the appropriate sql type.\n\nso a sql int would return integer\n\nObject o = rs.getObject(\"AuthorID\");\nif( o instanceof Integer){\n	//do\n}','','JDBC',1,NULL),(2053,'How can you figure out the number of columns in a ResultSet ?','String query = \"  \";\nResultSet res = stmt.executeQuery(query);\nReslutSetMetaData rsmd = rs.getMetaData();\nrs.next();\nint colCount = rsmd.getColumnCount();','JDBC',1,NULL),(2054,'public class Hello {\n    public static void main(String[] args){\n        try {\n            Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\");\n            Statement st = conn.createStatement();\n            String q = \"Select * from employees\";\n            \n            ResultSet rs = st.executeQuery(q);\n            ResultSetMetaData rmd = rs.getMetaData();\n            int cols = rmd.getColumnCount();\n            \n            for(int i = 1; i <= cols; i++){\n                System.out.println(rmd.getTableName(i));\n                System.out.println(rmd.getColumnName(i));\n                System.out.println(rmd.getColumnDisplaySize(i));\n            } \n        } catch(SQLException e){System.out.println(e); }\n        \n    }\n}','employees\nemp_no\n11\nemployees\nbirth_date\n10\nemployees\nfirst_name\n14\nemployees\nlast_name\n16\nemployees\ngender\n1\nemployees\nhire_date\n10','JDBC',1,NULL),(2055,'public class Hello {\n    public static void main(String[] args){\n        try {\n            Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\");\n            Statement st = conn.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE,ResultSet.CONCUR_READ_ONLY);\n            String q = \"Select * From employees limit 100\";\n            ResultSet rs = st.executeQuery(q);\n            \n            rs.first();\n            System.out.println(\"First entry:\");\n            System.out.println(rs.getString(\"first_name\") + \" \" +rs.getString(\"last_name\"));\n            \n            rs.last();\n            System.out.println(\"Last entry:\");\n            System.out.println(rs.getString(\"first_name\") + \" \" +rs.getString(\"last_name\"));\n            \n            rs.absolute(20);\n            System.out.println(\"row: \"+ rs.getRow());\n            System.out.println(rs.getString(\"first_name\") + \" \" +rs.getString(\"last_name\"));\n            \n            rs.relative(10);\n            System.out.println(\"row: \"+ rs.getRow());\n            System.out.println(rs.getString(\"first_name\") + \" \" +rs.getString(\"last_name\"));  \n        } catch(SQLException e){System.out.println(e); }\n        \n    }\n}','First entry:\nMicheal Boyd\nLast entry:\nKenroku Malabarba\nrow: 20\nKyoichi Maliniak\nrow: 30\nGuoxiang Nooteboom','JDBC',1,NULL),(2056,'Once created you cannot change the concurrency or Cursor type of an existing\nstatement object.','true','JDBC',1,NULL),(2057,'if cursor or concurrency settings are not supported then the driver will show\na warning and silently revert to default settings. ','','JDBC',1,NULL),(2058,'public class Hello {\n    public static void main(String[] args){\n       int a = 8;\n        System.out.println(\"what is b? :\"+a++);\n    }\n}','what is b? :8\n','JDBC',1,NULL),(2059,'public class Hello {\n   \n    public static void main(String[] args) {\n        Hello h = new Hello();\n        h.methodlocal();\n    }\n    \n    public void methodlocal(){\n        int y = 56;\n        \n        private class Zombie {\n            public int size;\n        \n            public Zombie(int x){ size = x;}\n            public void mone(){\n                System.out.println(\"ughhhg: \"+ size);\n            }\n            \n            public void accessTheLiving(){\n                System.out.println(\"local var: \"+y);\n            }\n            \n        }\n        \n        Zombie zom = new Zombie(7);\n        \n    }\n\n}','method local inner classes cannot access non final local variables,\n\nalso method local classes are just like local variables they cannot be \n	static private public protected or anything else','JDBC',1,NULL),(2060,'public class Hello {\n    public static void main(String[] args){\n        List<Animal> animals = new ArrayList<Animal>();\n        animals.add(new Dog());\n        animals.add(new Animal());\n    }\n    public static void addAnimal(List<Object> animals) {\n	animals.add(new Dog());\n    }\n}\n\nclass Dog extends Animal {}\nclass Animal { }','compiles fine','JDBC',1,NULL),(2061,'public class Hello<T> {\n    \n    public static void main(String[] args){\n        ArrayList<Beagle> a = new ArrayList<>();\n        ArrayList<Animal> b = new ArrayList<>();\n        \n        Hello<String> x = new Hello<>();\n        \n        \n        \n        x.copyColl(a,b);\n        \n\n    } \n    public <G extends Being> void copyColl(Collection<? extends G> src, Collection<? super G> dest){\n        \n        for(G n : dest)\n            src.add(n);\n        \n    }\n}\n\nclass Beagle extends Animal { }\nclass Animal extends Being {} \nclass Being { }','will not compile, \n\nfirst you cant add to a collection defined with ? extends. \n\nsecond, since dest is defined with ? super it is saying that that collection\ncan be of any type of super class of G,thouhg you can still add only G. \n\nTherefore the iterator will return objects not Gs.\n\nYou are taking from dest and adding to src. dest is the producer and src is the\nconsumer. Producers extend Consumers Super. ITs backward here. ','Collections',1,NULL),(2062,'public class Hello<T> {\n    \n    public static void main(String[] args){\n        ArrayList<RedWolf> a = new ArrayList<>();\n        ArrayList<Animal> b = new ArrayList<>();\n        \n        Hello<String> x = new Hello<>();\n        \n        \n        \n        x.copyColl(a,b);\n        \n\n    } \n    public <G extends Beagle> void copyColl(Collection<? extends G> src, Collection<? super G> dest){\n        \n        for(G g : src)\n            dest.add(g);\n        \n    }\n}\n\n\nclass GoodBeagles extends Beagle { }\nclass Beagle extends Animal { }\nclass Animal extends Being {} \nclass Being { }\nclass Wolf { } \nclass RedWolf{ }','will not compile redwolf does not extend beagle','Collections',1,NULL),(2063,'public class Hello {\n    public static void main(String[] dicks){\n         try {\n            Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\");\n            Statement st = conn.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_UPDATABLE);\n            String q = \"Select * from employees\";\n            ResultSet rs = st.executeQuery(q);\n            \n            if(rs.last()){\n               int rowCount = rs.getRow();\n               rs.beforeFirst();\n                System.out.println(rowCount);\n            }\n            \n            \n        } catch(SQLException e){System.out.println(e); }\n    }\n}','shows the number of rows ','Collections',1,NULL),(2064,'public class Hello {\n    public static void main(String[] dicks){\n         try {\n            Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\");\n            Statement st = conn.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_UPDATABLE);\n            String q = \"Select * from employees limit 100\";\n            ResultSet rs = st.executeQuery(q);\n            rs.absolute(-10);\n             System.out.println(rs.getRow()); \n        } catch(SQLException e){System.out.println(e); }\n    }\n}','91\n\nif absolute takes a - number it starts from the last row and works backward. \n\nreturns false if the cursor is beyond the lst row or beffore the first','Collections',1,NULL),(2065,'public class Hello extends Thread {\n    public static void main(String[] args){\n        try(Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees\", \"root\", \"Basketball12\")){\n            String getAllEmployeeNames = \"select first_name,last_name from employees\";\n            Statement st1 = conn.createStatement();\n            \n            ResultSet empnames = st1.executeQuery(getAllEmployeeNames);\n            \n            empnames.last();\n            \n            System.out.println(empnames.getString(\"first_name\")+\" \"+empnames.getString(\"last_name\"));\n            \n        }catch(SQLException e){\n            System.out.println(e);\n        }\n    }\n}','Sachin Tsukuda','JDBC',1,NULL),(2066,'public class Hello {\n    public static void main(String[] dicks){\n         try {\n            Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\");\n            Statement st = conn.createStatement(ResultSet.TYPE_FORWARD_ONLY,ResultSet.CONCUR_UPDATABLE);\n            String q = \"Select * from employees limit 100\";\n            ResultSet rs = st.executeQuery(q);\n            System.out.println(rs.getRow()); \n        } catch(SQLException e){System.out.println(e); }\n    }\n}','0','JDBC',1,NULL),(2067,'public class Hello {\n    public static void main(String[] dicks){\n         try {\n            Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\");\n            Statement st = conn.createStatement(ResultSet.TYPE_FORWARD_ONLY,ResultSet.CONCUR_UPDATABLE);\n            String q = \"Select * from employees limit 100\";\n            ResultSet rs = st.executeQuery(q);\n            rs.afterLast();\n            System.out.println(rs.getRow()); \n        } catch(SQLException e){System.out.println(e); }\n    }\n}','also 0','JDBC',1,NULL),(2068,'public class Hello {\n    public static void main(String[] dicks){\n         try {\n            Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\");\n            Statement st = conn.createStatement(ResultSet.TYPE_FORWARD_ONLY,ResultSet.CONCUR_UPDATABLE);\n            String q = \"Select * from employees limit 100\";\n            String q2 = \"Select * from salaries limit 100\";\n            ResultSet rs = st.executeQuery(q);\n            rs.afterLast();\n            System.out.println(rs.getRow()); \n            conn.close();\n            rs = st.executeQuery(q2);\n            while(rs.next()){\n                System.out.println(rs.getInt(\"salary\"));\n            }\n        } catch(SQLException e){System.out.println(e); }\n    }\n}','run:\n0\njava.sql.SQLException: No operations allowed after statement closed.\nBUILD SUCCESSFUL (total time: 0 seconds)\n\nit is not an exception to call getRow after the last row or before the first.\nit will simply give zero. \n','JDBC',1,NULL),(2069,'public class Hello {\n    public static void main(String[] dicks){\n         try(Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\");\n            Statement st = conn.createStatement(ResultSet.TYPE_FORWARD_ONLY,ResultSet.CONCUR_UPDATABLE);) {\n            String q = \"Select * from employees limit 100\";\n            String q2 = \"Select * from salaries limit 100\";\n            ResultSet rs = st.executeQuery(q);\n            rs.afterLast();\n            System.out.println(rs.getRow()); \n        } catch(SQLException e){System.out.println(e); }\n    }\n}','0','JDBC',1,NULL),(2070,'String url = \"   \";\nString user = \"  \";\nString pwd = \"    \";\n\n// insert here\nConnection conn = DriverManaget.getConnection(url,user,pwd);\n\nwhat would you use to load a JDBC 3.0 driver class','Class.forName(\"org.abc.mmmysql.Driver\");','JDBC',1,NULL),(2071,'What does it take for a driver to be jdbc 4.0 compliant ?	','Must include a MEAT-INF file, this allows the driver to autoload.\n\nMust provide implementations of Driver, Connection, Statement, ResultSet\ninterfaces\n\nMust support transactions\n\n','JDBC',1,NULL),(2072,'What three are availabe through an instance of DatabaseMetaData ?\n\n1 number of columns returned\n2 number of rows returned\n3 name of jdbc driver\n4 default transaciton isolation level\n5 last query used\n6 names of stored procedures\n7 current Savepoint name','3\n4\n6','JDBC',1,NULL),(2073,'try {\n	Statement st = conn.createStatement();\n	String query = \"Select * From Author Where LastName Like \'Rand%\'\";\n	Resultset rs = st.executeQuery(query);\n	if(rs == null) {\n		sout( \"no results\" );\n	} else {\n		sout(rs.getString(\"FirstName\");\n	}\n} catch(SQLException se) {\n	sout(\"SQLException\");\n}','SQLException, next() wass not called the cursors starts of pointing to BEFORE\nthe first row. ','JDBC',1,NULL),(2074,'public class Hello {\n    public static void main(String[] dicks){\n         try(Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employee?useSSL=false\", \"root\", \"Basketball12\")){\n             String query = \"Update employees set first_name = \'Hefty\' where emp_no = 10001\"; \n             Statement st = conn.createStatement();\n             st.executeQuery(query);\n         } catch(SQLException e){\n             System.out.println(\"SQLException\");\n         }\n    }\n \n}','SQLException\n\nexecuteQuery cannot be used to execute update insrt delete or ddl statements \nor it will throw a sqlexception. \n','JDBC',1,NULL),(2075,'try {\n	ResultSet rs = null;\n	try (Statement st = conn.createStatement()) {\n		String query = \"Select * From Customer\";\n		rs = st.executeQuery(query);\n	} catch(SQLException se) {\n		sout(\"Illegal query\");	\n	}\n\n	while (rs.next()) {\n		//process customers \n	}\n} catch(SQLException e) {\n	sout(\"SQLException\");\n}','SQLException\n\ntrying to access a closed ResultSet. ','JDBC',1,NULL),(2076,'Statement st = conn.createStatement();\nResultSet rs;\nString query = \"<QUERY HERE>\";\nst.execute(query);\nif ((Rs = st.getResultSet()) != null) {\n	sout(\"Results\");\n}\nif (st.getUpdateCount() > -1) {\n	sout(\"update\");\n}\n\nSelect * from customer\ninsert into ...\nupdate...\ndelete...','these would all produce their indicated rsults, update will produce and update count\neven if no rows are affected','JDBC',1,NULL),(2077,'String q = \"update customer set Last_name = ? Where Customer_id = ?\";\ntry {\n	PreparedStatement pt = conn.prepareStatement(q);\n	pt.setString(0,\"Smith\");\n	pt.setString(1,\"5001\");\n	int result = pt.executeUpdate();\n	if(result != 1) sout(\"error\");\n} catch(SQLException e) {\n	sout(\"Exception\");\n}','exception\n\nparameters are numbered starting from 1 not 0.','JDBC',1,NULL),(2078,'try {\n	String[] searchPair = {\"%a%\", \"%b%\",\"%c%\",\"%d%\" };\n	String query = \"Sleect ... ? ... ?\";\n	PreparedStatement pt = conn.PrepareStatement(query);\n	for(int i = 0; i < searchPair.length; i+=2) {\n		pt.setString(i+1, searchPAir[i]);\n		pt.setString(i+2, searchPair[i++]);\n		ResultSet rs = pt.executeQuery();\n		while(rs.next()) {\n			sout(\"yes\");\n		}\n	}\n} catch(Sqlexcepiton ee) {\n	sout	(\"SQLException\");\n}\n			','yes yes sqlexception everything is smooth on the first iteration, but \nthe second the preparedstatement index paramenters will be 3 and 4 when there\nare only two parameters, this will cause the exc.','JDBC',1,NULL),(2079,'public class Hello {\n    public static void main(String[] dicks){\n         List<?> list = new ArrayList<Dog>();\n         list.add(new Dog());\n         list.add(new Dog());\n         list.add(new Dog());\n    }\n \n}\n\nclass Dog {\n    \n}','Collections of type ? can be assigned to by any type of list but cannot be\nadded to. ','Collections',1,NULL),(2080,'public class Hello {\n    public static void main(String[] dicks){\n         List<Dog> Doglist = new ArrayList<Dog>();\n         Doglist.add(new Dog(\"Charly\"));\n         Doglist.add(new Dog(\"Baily\"));\n         Doglist.add(new Dog(\"Wiley\"));\n         \n         List<?> unmodifiableDogList = Doglist;\n         \n         for(Dog d : unmodifiableDogList){\n             System.out.println(d.getName());\n         }\n    }\n \n}\n\nclass Dog {\n    private String name;\n    public Dog(String s ){\n        name = s;\n    }\n    \n    public String getName(){\n        return name;\n    }\n    \n}','will not compile, object cannot be converted to Dog.\nThe objects comming out of a List<?> are Objects.','Collections',1,NULL),(2081,'public class Hello {\n    public static void main(String[] dicks){\n         List<Dog> Doglist = new ArrayList<Dog>();\n         Doglist.add(new Dog(\"Charly\"));\n         Doglist.add(new Dog(\"Baily\"));\n         Doglist.add(new Dog(\"Wiley\"));\n         \n         ArrayList<?> unmodifiableDogList = Doglist;\n         \n         for(Object d : unmodifiableDogList){\n             System.out.println(d.getName());\n         }\n    }\n \n}\n\nclass Dog {\n    private String name;\n    public Dog(String s ){\n        name = s;\n    }\n    \n    public String getName(){\n        return name;\n    }\n    \n}','althought the base type here is ArrayList Doglist is defined as a list \nso it cannot be assigned to an ArrayList ','Collections',1,NULL),(2082,'public class Hello<T> {\n    public static void main(String[] args){\n        \n        Dog d = new Dog();\n        \n        ArrayList x = makeArrayList(d);\n        \n        ArrayList c = new ArrayList<String>();\n        c.add(new Dog());\n        c.add(90);\n\n    } \n    public static <G> ArrayList<G> makeArrayList(G g){\n        ArrayList<G> genlist = new ArrayList();\n        genlist.add(g);\n        return genlist;\n        \n    }\n}\n\nclass Dog {\n    \n}','compiles fine the reference type is still defined as a raw type','Collections',1,NULL),(2083,'public class Hello {\n    public static void main(String[] args){\n       File file1 = new File(\"~/Public/TestDir/file1\");\n       File file2 = new File(\"~/Public/TestDir/file2\");\n       File dir = new File(\"~/Public/TestDir\");\n       \n       if(dir.exists() && dir.isDirectory()){\n           file1.createNewFile();\n           file2.createNewFile();\n       } else {\n           dir.mkdir();\n           file1.createNewFile();\n           file2.createNewFile();\n       }\n    } \n}','will not compile, all those methods throw IOExceptions','Input/Output',1,NULL),(2084,'public class Hello<T> {\n    \n    public static void main(String[] args){\n        \n        Dog d = new Dog();\n        \n        ArrayList<? extends Dog> c = new ArrayList<Beagle>();\n        Animal a = c.get(0);\n    } \n}\n\nclass Animal{}\nclass Dog extends Animal { }\nclass Beagle extends Dog { }','fine','Generics',1,NULL),(2085,'public class Hello<T> {\n    \n    public static void main(String[] args){\n        ArrayList<Animal> a;\n        ArrayList<Beagle> b;\n        \n        Hello<String> x = new Hello<>();\n        \n        x.copyColl(a,b);\n        \n\n    } \n    public <G> void copyColl(Collection<G extends Animal> src, Collection<G> dest){\n        \n        for(G n : src)\n            dest.add(n);\n        \n    }\n}\n\nclass Animal{}\nclass Dog extends Animal { }\nclass Beagle extends Dog { }','will not compile wrong number of type arguments, \nthis is a generic method, \n\nit should be <? extends Animal>','Generics',1,NULL),(2086,'public class Hello<T> {\n    \n    public static void main(String[] args) {\n        Cat cat = parse(\"cat\");\n        Dog dog = parse(\"dog\");\n        System.out.println(\"the cat object is a \" + cat);\n        System.out.println(\"the dog object is a \" + dog);\n    }\n\n    private static class Dog {\n        public String toString() { return \"dog\"; }\n    }\n\n    private static class Cat {\n        public String toString() { return \"cat\"; }\n    }\n\n    private static Object untypedParse(String stringToParse) {\n        if(stringToParse.equals(\"dog\")) {\n            return new Dog();\n        } else if(stringToParse.equals(\"cat\")) {\n            return new Cat();\n        } else {\n            throw new RuntimeException(\"not expected\");\n        }\n    }\n\n    public static <T> T parse(String stringToParse) {\n        return (T)untypedParse(stringToParse);\n    }\n\n}','in java 7 and beyond the compiler can infer the type from the return type !','Generics',1,NULL),(2087,'//How to fix this\npublic static T fromXml<T>(String xml) {\n  try {\n    JAXBContext context = JAXBContext.newInstance(T.class);\n    Unmarshaller um = context.createUnmarshaller();\n    return (T)um.unmarshal(new StringReader(xml));\n  } catch (JAXBException je) {\n    throw new RuntimeException(\"Error interpreting XML response\", je);\n  }\n}\n\n//Also the call doesn\'t work...\nfromXml<SomeSubObject>(\"<xml/>\");','First it should be: public static <T> T fromXML<T>(String xml)\n\nIn Java, generics are compile-time only data, which are lost at run time. \nSo, if you called a method like that, the JVM would have no way of knowing what T.class was. \nThe normal way to get around this is to pass a class instance object as a parameter to the method, \nlike this:\n\npublic static <T> T fromXml(Class<T> clazz, String xml) {\n  try {\n    JAXBContext context = JAXBContext.newInstance(clazz);\n    Unmarshaller um = context.createUnmarshaller();\n    return (T)um.unmarshal(new StringReader(xml));\n  } catch (JAXBException je) {\n    throw new RuntimeException(\"Error interpreting XML response\", je);\n  }\n}\n\nfromXml(SomeSubObject.class, \"<xml/>\");\n\n','Generics',1,NULL),(2088,'public class Hello<T> {\n    \n    public static void main(String[] args){\n        try (Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\")){\n            String prepInsert = \"Insert into employees values(?,\'1962-11-07\',?,?,\'F\',\'1962-11-07\')\";\n            PreparedStatement ps = conn.prepareStatement(prepInsert,ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_UPDATABLE);\n            ps.setInt(1,555);\n            ps.setString(3,\"Angela\");\n            ps.setString(4,\"Horton\");\n            \n            int rowsupdated = ps.executeUpdate();\n            \n            System.out.println(rowsupdated);\n\n        }catch(Exception e){\n            System.out.println(e);\n            \n        }\n        \n    }\n}','java.sql.SQLException: Parameter index out of range (4 > number of parameters, which is 3).','JDBC',1,NULL),(2089,'public class Hello<T> {\n    \n    public static void main(String[] args){\n        try (Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\")){\n            String prepInsert = \"Insert into employees values(?,\'1962-11-07\',?,?,\'F\',\'1962-11-07\')\";\n            PreparedStatement ps = conn.prepareStatement(prepInsert,ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_UPDATABLE);\n            ps.setInt(1,556);\n            ps.setString(2,\"Angela\");\n            ps.setString(3,\"Horton2\");\n            \n            int rowsupdated = ps.executeUpdate();\n            System.out.println(rowsupdated);\n            \n            ps.setInt(1,666);\n            ps.setString(2,\"MAX\");\n            ps.setString(3,\"AMILLION\");\n            \n            rowsupdated = ps.executeUpdate();\n            \n            System.out.println(rowsupdated);\n\n        }catch(Exception e){\n            System.out.println(e);\n            \n        }\n        \n    }\n}','1\n1\n\nyou can use a prepared statement multiple times','JDBC',1,NULL),(2090,'public class Hello<T> {\n    \n    public static void main(String[] args){\n        try (Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\")){\n            String prepInsert = \"Select * from employees where first_name = ? OR last_name = ?\";\n            PreparedStatement ps = conn.prepareStatement(prepInsert,ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_UPDATABLE);\n            ps.setString(1,\"Georgi\");\n            ps.setString(2,\"Horton\");\n            \n            ResultSet rs = ps.executeQuery();\n            \n            while(rs.next()){\n                System.out.println(rs.getString(\"first_name\")+\" \"+rs.getString(\"emp_no\"));\n            }\n        }catch(Exception e){\n            System.out.println(e);           \n        }\n    }\n}','Angela 555','JDBC',1,NULL),(2091,'public class Hello<T> {\n    \n    public static void main(String[] args){\n        try (Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\")){\n            String prepInsert = \"Select * from employees where first_name = ? OR last_name = ?\";\n            PreparedStatement ps = conn.prepareStatement(prepInsert,ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_UPDATABLE);\n            ps.setString(1,\"Georgi\");\n            ps.setString(2,\"Horton\");\n            \n            ResultSet rs = ps.executeQuery(prepInsert);\n            \n            while(rs.next()){\n                System.out.println(rs.getString(\"first_name\")+\" \"+rs.getString(\"emp_no\"));\n            }\n        }catch(Exception e){\n            System.out.println(e);           \n        }\n    }\n}','com.mysql.jdbc.exceptions.jdbc4.MySQLSyntaxErrorException: You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near \'? OR last_name = ?\' at line 1\n\npreparedstatement execute query does not take a String parameter, it already\nknows the query to execute. ','JDBC',1,NULL),(2092,'int customerID = 5001;\njava.sql.Date fromDate = ...;\njava.sql.Date toDate = ...;\nString getBooksInDateRange = \"{call getBooksDateRange(?,?,?)}\";\n\nCallableStatement cstmt = conn.prepareCall(getBooksInDateRange,ResultSet.TYPE_SCROLL_INSESNSITIVE,ResultSet.CONCUR_UPDATABLE);\n\ncstmt.setInt(1,customerID);\ncstmt.setDate(2,fromDate);\ncstmt.setDate(3,toDate);\nResultSet rs = cstmt.executeQuery();\n\n\n','calls the stored proceudre getBooksInDateRange','JDBC',1,NULL),(2093,'int customerID = 5001;\njava.sql.Date fromDate = ...;\njava.sql.Date toDate = ...;\nString getBooksInDateRange = \"{? =call customerTotal (?)}\";\n\nCallableStatement cstmt = conn.prepareCall(getBooksInDateRange,ResultSet.TYPE_SCROLL_INSESNSITIVE,ResultSet.CONCUR_UPDATABLE);\n\ncstmt.registerOutParameter(1,java.sql.Types.DOUBLE);\n\ncstmt.setInt(2,customerID);\n\ncstmt.execute(); // not returning a resultset\n\nint total = cstmt.getDouble(1);\n','to use a stored procedure you have to register the out parameter \nfirst. As shown here. ','JDBC',1,NULL),(2094,'int customerID = 5001;\njava.sql.Date fromDate = ...;\njava.sql.Date toDate = ...;\nString getBooksInDateRange = \"{? =call customerTotal (?)}\";\n\nCallableStatement cstmt = conn.prepareCall(getBooksInDateRange,ResultSet.TYPE_SCROLL_INSESNSITIVE,ResultSet.CONCUR_UPDATABLE);\n\ncstmt.registerOutParameter(1,java.sql.Types.DOUBLE);\n\ncstmt.setInt(2,customerID);\n\ncstmt.execute(getBookInDateRange); // not returning a resultset\n\nint total = cstmt.getDouble(1);\n                                  ','sqlexception execute doesn\'t take a parameter','JDBC',1,NULL),(2095,'int customerID = 5001;\nint numberOfOrders;\nCallableStatement ct = conn.prepareCall(\"{call customerOrderCount (?) }\");\nct.setInt(1,customerID);\nct.registerOutParameter(1.java.sql.Types.INTEGER);  // the out\n\nct.execute();\n\nint numberoforders = ct.getInt(1);','registers an INOUT parameter','JDBC',1,NULL),(2096,'int customerID = 5001;\nint numberOfOrders;\nCallableStatement ct = conn.prepareCall(\"{call customerOrderCount (?) }\");\nct.setInt(1,customerID);\nct.registerOutParameter(1.java.sql.Types.INTEGER);  // the out\n\nct.executeQuery();\n\nint numberoforders = ct.getInt(1);','storedprocedures is code thta you dont have insight to and if you invoke executeQuery()\non a procedure that doesn\'t return a result set you get a sqlException\n\nso its best to use execute()','JDBC',1,NULL),(2097,'int customerID = 5001;\nint numberOfOrders;\nCallableStatement ct = conn.prepareCall(\"{call customerOrderCount (?) }\");\nct.setInt(1,customerID);\nct.registerOutParameter(1.java.sql.Types.INTEGER);  // the out\n\nct.execute();\n\nint numberoforders = ct.getInt(1);\n\nif(ct.getMoreResults()) // returns true if there is a resultset to get. ','','JDBC',1,NULL),(2098,'RowSetFactory rsf = RowSetProvider.newFactory();\nJdbcRowSet jrs = rsf.createJdbcRowSet();\n// Provider returns a facotry that will create Rowset objects from\n// the reference implementation\n\n//with the factory it is easy to swap out the implementation\n\nRowSetFactorys rsf2 = RowSetProvider.newFactory(\"com.example.MyRowSetProvider\",null);\nJdbcRowSet jrs = rsf.createJdbcRowSet();','','JDBC',1,NULL),(2099,'public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n        try(JdbcRowSet jrs = RowSetProvider.newFactory().createJdbcRowSet()){\n            String query = \"Select * from employees limit 100\";\n            jrs.setCommand(query);\n            jrs.setUrl(url);\n            jrs.setUsername(user);\n            jrs.setPassword(pw);\n            jrs.execute();\n            while(jrs.next()){\n                System.out.println(jrs.getString(\"first_name\") + \" \" + jrs.getString(\"last_name\"));\n            }    \n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n}','prints the first 100 employees\' full names\n\nyou construct a JdbcRowSet from a RowSetProvider.newFactory().createJdbcRowSet();\n\ninstead of statement conncection and resultSet you use RowSet commands\nto set the uname, pw and url. \n\nthen simply execute it. ','JDBC',1,NULL),(2100,'public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n        try(JdbcRowSet jrs = RowSetProvider.createJdbcRowSet()){\n            String query = \"Select * from employees limit 100\";\n            jrs.setCommand(query);\n            jrs.setUrl(url);\n            jrs.setUsername(user);\n            jrs.setPassword(pw);\n            jrs.execute();\n            while(jrs.next()){\n                System.out.println(jrs.getString(\"first_name\") + \" \" + jrs.getString(\"last_name\"));\n            }    \n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n}','will not compile the proper way to create a JdbcRowSet is\n\n	JdbcRowSet jrs = RowSetProvider.newFactory().createJdbcRowSet()','JDBC',1,NULL),(2101,'public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n            JdbcRowSet jrs = RowSetProvider.newFactory().createJdbcRowSet();\n            String query = \"Select * from employees limit 100\";\n            jrs.setCommand(query);\n            jrs.setUrl(url);\n            jrs.setUsername(user);\n            jrs.setPassword(pw);\n            jrs.execute();\n            while(jrs.next()){\n                System.out.println(jrs.getString(\"first_name\") + \" \" + jrs.getString(\"last_name\"));\n            }    \n    }\n}','Will not compil creating a JdbcRowSet throws an sql exception so it is usually\ncreated in a try() - catch block, \n\nNot to mention every other of those commands throws an sqlexception','JDBC',1,NULL),(2102,'public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n        try(JdbcRowSet jrs = RowSetProvider.newFactory().createJdbcRowSet()){\n            String query = \"Select * from employee limit 100\";\n            jrs.setCommand(query);\n            jrs.execute();\n            while(jrs.next()){\n                System.out.println(jrs.getString(\"first_name\") + \" \" + jrs.getString(\"last_name\"));\n            }    \n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n}','NullPointerException, the username and password and url were not set, \n\nIT could Also throw an sqlexception for this,\n\nexecute fills the rowset with data. Just alswyas make sure that data is set.','JDBC',1,NULL),(2103,'public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n        try(JdbcRowSet jrs = RowSetProvider.newFactory().createJdbcRowSet()){\n            String query = \"Select * from employees limit 100\";\n            jrs.setCommand(query);\n            jrs.setUrl(url);\n            jrs.setUsername(user);\n            jrs.setPassword(pw);\n            jrs.setType(ResultSet.TYPE_SCROLL_INSENSITIVE);\n            jrs.execute();\n            while(jrs.next()){\n                System.out.println(jrs.getString(\"first_name\") + \" \" + jrs.getString(\"last_name\"));\n            }    \n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n}','RowSet extends Result set so it is a result set\n\nseting the type still uses the resultset types. ','JDBC',1,NULL),(2104,'public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n        try(JdbcRowSet jrs = RowSetProvider.newFactory().createJdbcRowSet()){\n            String query = \"Select * from employees limit 100\";\n            jrs.setCommand(query);\n            jrs.setUrl(url);\n            jrs.setUsername(user);\n            jrs.setPassword(pw);\n            jrs.setType(RowSet.TYPE_SCROLL_INSENSITIVE);\n            jrs.execute();\n            while(jrs.next()){\n                System.out.println(jrs.getString(\"first_name\") + \" \" + jrs.getString(\"last_name\"));\n            }    \n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n}','will not compile,\n\nResultSet.TYPE_SCROLL_INSENSITIVE\n\nThose fields are inherited from ResultSet. \n\nFields inherited from interface java.sql.ResultSet\nCONCUR_READ_ONLY, \nCONCUR_UPDATABLE, \nTYPE_FORWARD_ONLY, \nTYPE_SCROLL_INSENSITIVE, \nTYPE_SCROLL_SENSITIVE','JDBC',1,NULL),(2105,'public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n        try(JdbcRowSet jrs = RowSetProvider.newFactory().createJdbcRowSet()){\n            String query = \"Update employees set first_name = \'Mike\' where emp_no = 789\";\n            jrs.setCommand(query);\n            jrs.setUrl(url);\n            jrs.setUsername(user);\n            jrs.setPassword(pw);\n            jrs.setType(ResultSet.TYPE_SCROLL_INSENSITIVE);\n            jrs.execute();\n            while(jrs.next()){\n                System.out.println(jrs.getString(\"first_name\") + \" \" + jrs.getString(\"last_name\"));\n            }    \n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n}','SQLException, you cannot Update insert or delete with execute() on a RowSet.\n\nto update the data you just update the data on your JdbcRowSet.\n\nthere are no executeQuery() or executeUpdate methods for RowSets. ','JDBC',1,NULL),(2106,'public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n        try(JdbcRowSet jrs = RowSetProvider.newFactory().createJdbcRowSet()){\n            String query = \"Update employees set first_name = \'Mike\' where emp_no = 789\";\n            jrs.setCommand(query);\n            jrs.setUrl(url);\n            jrs.setUsername(user);\n            jrs.setPassword(pw);\n            jrs.setType(ResultSet.TYPE_SCROLL_INSENSITIVE);\n            jrs.executeUpdate();\n            while(jrs.next()){\n                System.out.println(jrs.getString(\"first_name\") + \" \" + jrs.getString(\"last_name\"));\n            }    \n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n}','will not compile there is no executeUpdate() for RowSets,\nbecause you do not update insert or delete in this way. You use the update api.\n\nThis would be a sql exception anyway because you cannot perform update \ninsert or deletes with a sql command and a jdbc rowset.','JDBC',1,NULL),(2107,'public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n        try(JdbcRowSet jrs = RowSetProvider.newFactory().createJdbcRowSet()){\n            String query = \"Select * from employees limit 100\";\n            jrs.setCommand(query);\n            jrs.setUrl(url);\n            jrs.setUsername(user);\n            jrs.setPassword(pw);\n            jrs.setType(ResultSet.TYPE_SCROLL_INSENSITIVE);\n            jrs.executeQuery();\n            while(jrs.next()){\n                System.out.println(jrs.getString(\"first_name\") + \" \" + jrs.getString(\"last_name\"));\n            }    \n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n}','will not compiles there is no executeQuery() with Jdbcrowsets. The Command is \nexecute()','JDBC',1,NULL),(2108,'How do you execute a query with a JdbcRowSet object ? ','first set the user pw and url with:\n\n	       jrs.setUrl(url);\n            jrs.setUsername(user);\n            jrs.setPassword(pw);\n\nthen set the command: \n		String query = \"Select * from employees limit 100\";\n            jrs.setCommand(query);\n\nthen use the only command to execute:\n\nexecute()','JDBC',1,NULL),(2109,'public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n        try(JdbcRowSet jrs = RowSetProvider.newFactory().createJdbcRowSet()){\n            String query = \"Select * from employees limit 100\";\n            jrs.setUrl(url);\n            jrs.setUsername(user);\n            jrs.setPassword(pw);\n            jrs.setType(ResultSet.TYPE_SCROLL_INSENSITIVE);\n            jrs.execute();\n            while(jrs.next()){\n                System.out.println(jrs.getString(\"first_name\") + \" \" + jrs.getString(\"last_name\"));\n            }    \n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n}','NullpointerExeption you never set the command, could be an sqlException too\n\ndont forget to:\n\nsetCommand(query);','JDBC',1,NULL),(2110,'public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n        try(JdbcRowSet jrs = RowSetProvider.newFactory().createJdbcRowSet()){\n            String query = \"Select * from employees limit 100\";\n            jrs.setQuery(query);\n            jrs.setUrl(url);\n            jrs.setUsername(user);\n            jrs.setPassword(pw);\n            jrs.execute();\n            while(jrs.next()){\n                System.out.println(jrs.getString(\"first_name\") + \" \" + jrs.getString(\"last_name\"));\n            }    \n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n}','will not copile the method is setCommand not setQuery','JDBC',1,NULL),(2111,'You can update data in the database with a resultset but thats not on the \nexam so DONT WORRY ABOUT IT. \n\nyou can do the same with RowSet and that IS on the exam so thats what you shuld focus on','','JDBC',1,NULL),(2112,'public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n        try(JdbcRowSet jrs = RowSetProvider.newFactory().createJdbcRowSet()){\n            String query = \"Select * from employees limit 100\";\n            jrs.setCommand(query);\n            jrs.setUrl(url);\n            jrs.setUsername(user);\n            jrs.setPassword(pw);\n            jrs.execute();\n            while(jrs.next()){\n                System.out.println(jrs.getString(\"first_name\") + \" \" + jrs.getString(\"last_name\"));\n            }\n            jrs.last();\n            jrs.updateString(\"first_name\",\"Big Max\");\n            jrs.updateRow();\n            \n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n}','change the last employees first name to \'Big Max\'','JDBC',1,NULL),(2113,'public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n        try(JdbcRowSet jrs = RowSetProvider.newFactory().createJdbcRowSet()){\n            String query = \"Select * from employees limit 100\";\n            jrs.setCommand(query);\n            jrs.setUrl(url);\n            jrs.setUsername(user);\n            jrs.setPassword(pw);\n            jrs.execute();\n            \n            jrs.last();\n            jrs.updateString(\"first_name\",\"Big Max\");\n            jrs.updateRow();\n\n            while(jrs.next()){\n                System.out.println(jrs.getString(\"first_name\") + \" \" + jrs.getString(\"last_name\"));\n            }\n            \n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n}','This will print nothing, the cursor is already at the last poisiton so\nthere is not next for jrs to go to to fix add \n\n	jrs.first()\n\njust before the while loop.','JDBC',1,NULL),(2114,'public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n        try(JdbcRowSet jrs = RowSetProvider.newFactory().createJdbcRowSet()){\n            String query = \"Select * from employees limit 100\";\n            jrs.setCommand(query);\n            jrs.setUrl(url);\n            jrs.setUsername(user);\n            jrs.setPassword(pw);\n            jrs.execute();\n            \n            jrs.last();\n            jrs.updateString(\"first_name\",\"Big Max\");\n            jrs.updateRow();\n            jrs.first();\n            while(jrs.next()){\n                System.out.println(jrs.getString(\"first_name\") + \" \" + jrs.getString(\"last_name\"));\n            }\n            \n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n}','will show the updated rows ','JDBC',1,NULL),(2115,'public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n        try(JdbcRowSet jrs = RowSetProvider.newFactory().createJdbcRowSet()){\n            String query = \"Select * from employees limit 100\";\n            jrs.setCommand(query);\n            jrs.setUrl(url);\n            jrs.setUsername(user);\n            jrs.setPassword(pw);\n            jrs.execute();\n            jrs.first();\n            jrs.updateString(\"first_name\",\"Big Max\");\n            jrs.updateString(\"last_name\",\"Big Dick Bisesi\");\n            jrs.updateRow();\n            System.out.println(jrs.getString(\"first_name\") + \" \" + jrs.getString(\"last_name\"));\n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n}','will update the first row of the RowSet and write teh changes to the database\n\nprints: Big Max Big Dick Bisesi','JDBC',1,NULL),(2116,'public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n        try(JdbcRowSet jrs = RowSetProvider.newFactory().createJdbcRowSet()){\n            String query = \"Select * from employees limit 100\";\n            jrs.setCommand(query);\n            jrs.setUrl(url);\n            jrs.setUsername(user);\n            jrs.setPassword(pw);\n            jrs.first();\n            jrs.updateString(\"first_name\",\"Big Max\");\n            jrs.updateString(\"last_name\",\"Big Dick Bisesi\");\n            jrs.updateRow();\n            System.out.println(jrs.getString(\"first_name\") + \" \" + jrs.getString(\"last_name\"));\n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n}','SQLException: Invalid State\n\nexecute() was never used.','JDBC',1,NULL),(2117,'public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n        try(JdbcRowSet jrs = RowSetProvider.newFactory().createJdbcRowSet()){\n            String query = \"Select * from employees limit 100\";\n            jrs.setCommand(query);\n            jrs.setUrl(url);\n            jrs.setUsername(user);\n            jrs.setPassword(pw);\n            jrs.execute();\n            jrs.beforeFirst();\n            jrs.updateString(\"first_name\",\"Big Max\");\n            jrs.updateString(\"last_name\",\"Big Dick Bisesi\");\n            jrs.updateRow();\n            System.out.println(jrs.getString(\"first_name\") + \" \" + jrs.getString(\"last_name\"));\n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n}','NullPointerException the cursor is before the first row','JDBC',1,NULL),(2118,'public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n        try(JdbcRowSet jrs = RowSetProvider.newFactory().createJdbcRowSet()){\n            String query = \"Select * from employees limit 100\";\n            jrs.setCommand(query);\n            jrs.setUrl(url);\n            jrs.setUsername(user);\n            jrs.setPassword(pw);\n            jrs.execute();\n            jrs.absolute(0);\n            jrs.updateString(\"first_name\",\"Big Max\");\n            jrs.updateString(\"last_name\",\"Big Dick Bisesi\");\n            jrs.updateRow();\n            System.out.println(jrs.getString(\"first_name\") + \" \" + jrs.getString(\"last_name\"));\n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n}','NPE moving to absolute(0) moves to before the first row. \n\nmoving abosolute(-n) starts at the last row and moves the cursor backward','JDBC',1,NULL),(2119,'public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n        try(JdbcRowSet jrs = RowSetProvider.newFactory().createJdbcRowSet()){\n            String query = \"Select * from employees limit 100\";\n            jrs.setCommand(query);\n            jrs.setUrl(url);\n            jrs.setUsername(user);\n            jrs.setPassword(pw);\n            jrs.execute();\n            jrs.absolute(5);\n            jrs.updateString(\"first_name\",\"Angela\");\n            jrs.updateString(\"last_name\",\"Big Butt Horton\");\n            jrs.updateRow();\n            System.out.println(jrs.getString(\"first_name\") + \" \" + jrs.getString(\"last_name\"));\n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n}','changes the fifth row in the rowset.\n\nAngela Bit Butt Horton','JDBC',1,NULL),(2120,'How to insert a new row into a RowSet ?','jrs.moveToInsertRow();\njrs.updateString(\"first_name\",\"Jonny\");\njrs.udateString...\njrs.updateInt...\njrs.insertRow();\njrs.moveToCurrentRow();','JDBC',1,NULL),(2121,'public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n        try(JdbcRowSet jrs = RowSetProvider.newFactory().createJdbcRowSet()){\n            String query = \"Select * from employees limit 100\";\n            jrs.setCommand(query);\n            jrs.setUrl(url);\n            jrs.setUsername(user);\n            jrs.setPassword(pw);\n            \n            jrs.moveToInsertRow();\n            jrs.updateInt(\"emp_no\",12345);\n            jrs.updateString(\"firs_name\",\"Blue\");\n            jrs.updateString(\"last_name\",\"Bella\");\n            jrs.insertRow();\n            \n            //System.out.println(jrs.getString(\"first_name\") + \" \" + jrs.getString(\"last_name\"));\n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n}','sqlexception: invalid state there is no rowset to perforem these changes on \nbecause execute() wasn\'t called.','JDBC',1,NULL),(2122,'public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n        try(JdbcRowSet jrs = RowSetProvider.newFactory().createJdbcRowSet()){\n            String query = \"Select * from employees limit 100\";\n            jrs.setCommand(query);\n            jrs.setUrl(url);\n            jrs.setUsername(user);\n            jrs.setPassword(pw);\n            \n            jrs.execute();\n            \n            jrs.moveToInsertRow();\n            jrs.updateInt(\"emp_no\", 789);\n            jrs.updateString(\"first_name\",\"Blue\");\n            jrs.updateString(\"last_name\",\"Bella\");\n            jrs.insertRow();\n            \n            System.out.println(jrs.getString(\"first_name\") + \" \" + jrs.getString(\"last_name\"));\n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n}','Blue Bella this prints the values just inserted in the insert row.','JDBC',1,NULL),(2123,'public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n        try(JdbcRowSet jrs = RowSetProvider.newFactory().createJdbcRowSet()){\n            String query = \"Select * from employees limit 100\";\n            jrs.setCommand(query);\n            jrs.setUrl(url);\n            jrs.setUsername(user);\n            jrs.setPassword(pw);\n            jrs.execute();\n            jrs.moveToInsertRow();\n            System.out.println(jrs.getString(\"first_name\") + \" \" + jrs.getString(\"last_name\"));\n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n}','null null','JDBC',1,NULL),(2124,'public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n        try(JdbcRowSet jrs = RowSetProvider.newFactory().createJdbcRowSet()){\n            String query = \"Select * from employees limit 100\";\n            jrs.setCommand(query);\n            jrs.setUsername(user);\n            jrs.setPassword(pw);\n            jrs.execute();\n            jrs.moveToInsertRow();\n            System.out.println(jrs.getString(\"first_name\") + \" \" + jrs.getString(\"last_name\"));\n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n}','NPE setURL was left out ','JDBC',1,NULL),(2125,'public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n        try(JdbcRowSet jrs = RowSetProvider.newFactory().createJdbcRowSet()){\n            String query = \"Select * from employees limit 100\";\n            jrs.setCommand(query);\n            jrs.setUrl(url);\n            jrs.setUsername(user);\n            jrs.setPassword(pw);\n            jrs.execute();\n            \n            jrs.addRowSetListener(new MyRowSetListener());\n            \n            jrs.moveToInsertRow();\n            jrs.updateInt(\"emp_no\",3);\n            jrs.updateString(\"first_name\",\"Micheal\");\n            jrs.updateString(\"last_name\",\"Boyd\");\n            jrs.insertRow();\n            \n            jrs.moveToCurrentRow();\n            \n            while(jrs.next()){\n                System.out.println(jrs.getString(\"first_name\") + \" \" + jrs.getString(\"last_name\"));\n            }\n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n    \n    class MyRowSetListener implements RowSetListener {\n        \n        public void rowChanged(RowSetEvent event) {\n            if(event.getSource() instanceof RowSet) {\n                try{\n                    ((RowSet) event.getSource()).execute();\n                    //re excute the query every time the rowset is updchanged to update it\n                } catch(SQLException e){\n                    \n                }\n                \n            }\n        }\n        \n        public void cursorMoved(RowSetEvent e) { }\n        public void rowSetChanged(RowSetEvent e){ }\n    }\n}','will not compile non static variable cannot be referenced from static context','JDBC',1,NULL),(2126,'\npublic class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n        try(JdbcRowSet jrs = RowSetProvider.newFactory().createJdbcRowSet()){\n            String query = \"Select * from employees limit 100\";\n            jrs.setCommand(query);\n            jrs.setUrl(url);\n            jrs.setUsername(user);\n            jrs.setPassword(pw);\n            jrs.execute();\n            \n            jrs.addRowSetListener(new MyRowSetListener());\n            \n            jrs.moveToInsertRow();\n            jrs.updateInt(\"emp_no\",3);\n            jrs.updateString(\"first_name\",\"Micheal\");\n            jrs.updateString(\"last_name\",\"Boyd\");\n            jrs.insertRow();\n            \n            jrs.moveToCurrentRow();\n            \n            while(jrs.next()){\n                System.out.println(jrs.getString(\"first_name\") + \" \" + jrs.getString(\"last_name\"));\n            }\n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n    \n    static class MyRowSetListener implements RowSetListener {\n        \n        public void rowChanged(RowSetEvent event) {\n            if(event.getSource() instanceof RowSet) {\n                try{\n                    ((RowSet) event.getSource()).execute();\n                    //re excute the query every time the rowset is updchanged to update it\n                } catch(SQLException e){\n                    \n                }\n                \n            }\n        }\n        \n        public void cursorMoved(RowSetEvent e) { }\n        public void rowSetChanged(RowSetEvent e){ }\n    }\n}','create a rowsetlistener','JDBC',1,NULL),(2127,'a JdbcRowSet is connected which means its update are actively written to\nthe db, a CachedRowSet and all the rest are disconnected which means they\ncan connect to get the data disconnect change the data then re connect to \nupdate their changes, thats what a cache is.','got it','JDBC',1,NULL),(2128,'how do you create a CachedRowSet','CachedRowSet cs = RowSetProvider.newFactory().createCachedRowSet();','JDBC',1,NULL),(2129,'\npublic class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n        try(JdbcRowSet jrs = RowSetProvider.newFactory().createJdbcRowSet()){\n            String query = \"Select * from employees limit 100\";\n            jrs.setCommand(query);\n            jrs.setUrl(url);\n            jrs.setUsername(user);\n            jrs.setPassword(pw);\n            jrs.execute();\n            \n            jrs.addRowSetListener(new MyRowSetListener());\n            \n            jrs.moveToInsertRow();\n            jrs.updateInt(\"emp_no\",3);\n            jrs.updateString(\"first_name\",\"Micheal\");\n            jrs.updateString(\"last_name\",\"Boyd\");\n            jrs.insertRow();\n            \n            jrs.moveToCurrentRow();\n            \n            while(jrs.next()){\n                System.out.println(jrs.getString(\"first_name\") + \" \" + jrs.getString(\"last_name\"));\n            }\n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n    \n    static class MyRowSetListener implements RowSetListener {\n        \n        public void rowChanged(RowSetEvent event) {\n            if(event.getSource() instanceof RowSet) {\n                try{\n                    ((RowSet) event.getSource()).execute();\n                    //re excute the query every time the rowset is updchanged to update it\n                } catch(SQLException e){\n                    \n                }\n                \n            }\n        }\n        \n        public void cursorMoved(RowSetEvent e) { }\n        public void rowSetChanged(RowSetEvent e){ }\n    }\n}','will not compile thats not how you create a RowSet. you should add \n\n	createJdbcRowSet();','JDBC',1,NULL),(2130,'When your done changing CachedRowSet what do you call?','acceptChanges();','JDBC',1,NULL),(2131,'how do you begin a transaction in jdbc ?','Connection conn = DriverManager..\nconn.setAutoCommit(false); // begin transaction','JDBC',1,NULL),(2132,'A jdbc transaction includes all of the sQL queries you execute until either ...?','you exlicityly commmit the current transaction\n\nyou excplicityl roll back the current transaction\n\nthere is a failure that forces automatic rollback.','JDBC',1,NULL),(2133,'public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n       try(Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\")){\n           conn.setAutoCommit(false);\n           Statement stmt = conn.createStatement();\n           stmt.execute(\"Insert into employees values (601,\'Dixon\',\'Ramey\')\");\n           stmt.execute(\"Insert into employees values (602,\'Alex\',\'Ramey\')\");\n           stmt.execute(\"Insert into employees values (603,\'Kevin\',\'Ramey\')\");\n           \n           conn.commit();\n           \n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n    \n}','start a transacation by setting autoCommit(false), then make sure you commit()\nit otherwise everything you just did will be automatically rolledback. \n\nAs soon you commit() another transaction is started.\n\nThere can only be one transaction at a time. ','JDBC',1,NULL),(2134,'public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n       try(Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\")){\n           conn.setAutoCommit(false);\n           Statement stmt = conn.createStatement();\n           stmt.execute(\"Insert into employees values (601,\'Dixon\',\'Ramey\')\");\n           stmt.execute(\"Insert into employees values (602,\'Alex\',\'Ramey\')\");\n           stmt.execute(\"Insert into employees values (603,\'Kevin\',\'Ramey\')\");\n           \n           conn.commit();\n           \n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n            \n            conn.rollback();\n        }\n    }\n    \n}','will not compile, Connection is scoped only within that try block because it is\nin a try with resources, conn in the catch is out of scope. ','JDBC',1,NULL),(2135,'public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\");\n  \n        try{   \n        \n            conn.setAutoCommit(false);\n           Statement stmt = conn.createStatement();\n           stmt.execute(\"Insert into employees values (601,\'Dixon\',\'Ramey\')\");\n           stmt.execute(\"Insert into employees values (602,\'Alex\',\'Ramey\')\");\n           stmt.execute(\"Insert into employees values (603,\'Kevin\',\'Ramey\')\");\n           \n           conn.commit();\n           \n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n            \n            conn.rollback();\n        }\n    }\n    \n}','WNC DriverManager.getConnection throws a sqlexception ','JDBC',1,NULL),(2136,'public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n       try(Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\")){\n           conn.setAutoCommit(false);\n           Statement stmt = conn.createStatement();\n           int updatecount = 0;\n           \n           updatecount += stmt.executeUpdate(\"Insert into employees values (701,\'Dixon\',\'Ramey\')\");\n           updatecount += stmt.executeUpdate(\"Insert into employees values (702,\'Alex\',\'Ramey\')\");\n           updatecount += stmt.executeUpdate(\"Insert into employees values (703,\'Kevin\',\'Ramey\')\");\n           \n           if(updatecount == 3){\n               System.out.println(\"Transaction complete\");\n                conn.commit();\n           } else {\n               System.out.println(\"Something didn\'t go through\");\n               conn.rollback();\n           }\n\n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n    \n}','if the insertions go as planned then commit the transaction otherwise try again\n','JDBC',1,NULL),(2137,'public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n       try(Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\")){\n           Statement stmt = conn.createStatement();\n           int updatecount = 0;\n           \n           updatecount += stmt.executeUpdate(\"Insert into employees values (701,\'Dixon\',\'Ramey\')\");\n           updatecount += stmt.executeUpdate(\"Insert into employees values (702,\'Alex\',\'Ramey\')\");\n           updatecount += stmt.executeUpdate(\"Insert into employees values (703,\'Kevin\',\'Ramey\')\");\n           \n           if(updatecount == 3){\n               System.out.println(\"Transaction complete\");\n                conn.commit();\n           } else {\n               System.out.println(\"Something didn\'t go through\");\n               conn.rollback();\n           }\n\n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n    \n}','sqlexception transaction has not been started. setAutoCommit(false) to start one','JDBC',1,NULL),(2138,'public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n       try(Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\")){\n           conn.setAutoCommit(false);\n           Statement stmt = conn.createStatement();\n           int updatecount = 0;\n           \n           updatecount += stmt.executeUpdate(\"Insert into employees values (706,\'Dixon\',\'Ramey\')\");\n           updatecount += stmt.executeUpdate(\"Insert into employees values (707,\'Alex\',\'Ramey\')\");\n           updatecount += stmt.executeUpdate(\"Insert into employees values (708,\'Kevin\',\'Ramey\')\");\n           \n           if(updatecount == 3){\n               System.out.println(\"Transaction complete\");\n                conn.setAutoCommit(true);\n           } else {\n               System.out.println(\"Something didn\'t go through\");\n               conn.rollback();\n           }\n\n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n    \n}','setting autocommit to true will committ any current transaction and turn auto commit back on','JDBC',1,NULL),(2139,'JDBC:\n\nYou call setAutoCommit(false) on Statement ojbects ','FALSE ! Connection objects','JDBC',1,NULL),(2140,'a savepoint represents a point in the transaction that you can rollback to.\nit is created from a connection object.','','JDBC',1,NULL),(2141,'public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n       try(Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\")){\n           conn.setAutoCommit(false);//start a transaction\n           Statement stmt = conn.createStatement();\n           int updatecount = 0;\n           \n           updatecount += stmt.executeUpdate(\"Insert into employees values (710,\'steve\',\'davidson\')\");\n           updatecount += stmt.executeUpdate(\"Insert into employees values (711,\'Alex\',\'The great\')\");\n           updatecount += stmt.executeUpdate(\"Insert into employees values (713,\'baily\',\'Ramey\')\");\n           Savepoint sp1 = conn.setSavepoint();\n           \n           stmt.executeUpdate(\"Insert into employees values(801,\'Whitey\',\'Ford\')\");\n           \n           conn.rollback();\n\n           ResultSet rs = stmt.executeQuery(\"select * from employees where first_name = \\\'Whitey\\\'\");\n           \n           while(rs.next()){\n               System.out.println(rs.getInt(\"emp_no\"));\n           }\n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n    \n}','how to use a savepoint','JDBC',1,NULL),(2142,'public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n       try(Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\")){\n          String call = \"{CALL REMOVEBOOKS(?,?)}\";\n          String titleToRemove = null;\n          int maxBooks = 0;\n          CallableStatement cstmt = conn.prepareCall(call);\n          String titles = \"%Hero%\";\n          int numBooksRemoved;\n          cstmt.setInt(0,maxBooks);\n          cstmt.setString(1,titleToRemove);\n          cstmt.registerOutParameter(0,java.sql.Types.INTEGER);\n          cstmt.execute();\n          numBooksRemoved = cstmt.getInt(0); \n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n    \n}','Prepared and Callable statement setXXX() methods number parameters from \n1 not 0. ','JDBC',1,NULL),(2143,'public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n       try(Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\")){\n          String call = \"{CALL REMOVEBOOKS(?,?)}\";\n          String titleToRemove = null;\n          int maxBooks = 0;\n          CallableStatement cstmt = conn.prepareCall(call);\n          String titles = \"%Hero%\";\n          int numBooksRemoved;\n          cstmt.setInt(0,maxBooks);\n          cstmt.setString(1,titleToRemove);\n          cstmt.registerOutParameter(0,java.sql.Types.INTEGER);\n          cstmt.executeQuery(query);\n          numBooksRemoved = cstmt.getInt(0); \n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n    \n}','executeQuery() for callable and preparedstatements must not have the query passed\nin as a parameter. \n\nAlso the indexes are numbered incorectly','JDBC',1,NULL),(2144,'public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n       try(Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\")){\n          String call = \"{CALL REMOVEBOOKS(?,?)}\";\n          String titleToRemove = null;\n          String query = \"select * from Books\";\n          int maxBooks = 0;\n          CallableStatement cstmt = conn.prepareCall(call);\n          String titles = \"%Hero%\";\n          int numBooksRemoved;\n          cstmt.setInt(1,maxBooks);\n          cstmt.setString(2,titleToRemove);\n          cstmt.registerOutParameter(1,java.sql.Types.INTEGER);\n          cstmt.executeQuery(query);\n          numBooksRemoved = cstmt.getInt(1);\n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n    \n}','sqlexception executeQuery() for callable and prepared statements must not have\nthe query passed in as a parameter ','JDBC',1,NULL),(2145,'public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n       try(Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\")){\n          String call = \"{CALL REMOVEBOOKS(?,?)}\";\n          String titleToRemove = null;\n          String query = \"select * from Books\";\n          int maxBooks = 0;\n          CallableStatement cstmt = conn.prepareCall(call);\n          String titles = \"%Hero%\";\n          int numBooksRemoved;\n          cstmt.setInt(1,maxBooks);\n          cstmt.setString(2,titleToRemove);\n          cstmt.execute();\n          cstmt.registerOutParameter(1,java.sql.Types.INTEGER);\n          numBooksRemoved = cstmt.getInt(1);\n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n    \n}','sqlexception for registering the out parameter after the execute call.','JDBC',1,NULL),(2146,'public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n       try(Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\")){\n          String call = \"{CALL REMOVEBOOKS(?,?)}\";\n          String titleToRemove = null;\n          String query = \"select * from Books\";\n          int maxBooks = 0;\n          CallableStatement cstmt = conn.prepareCall(call);\n          String titles = \"%Hero%\";\n          int numBooksRemoved;\n          cstmt.setInt(1,maxBooks);\n          cstmt.setString(2,titleToRemove);\n          cstmt.registerOutParameter(1,java.sql.Types.INTEGER);\n          ResultSet rs = cstmt.executeQuery();\n          rs.next();\n          numBooksRemoved = cstmt.getInt(1);\n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n    \n}','this stored proceudre does not return a resultset, so while it will compile\nbcasue executeQuery() will return a ResultSet to rs. cstmt.getInt(1); will throw\na sql exception.','JDBC',1,NULL),(2147,'public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n       try(Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\")){\n          String call = \"{CALL REMOVEBOOKS(?,?)}\";\n          String titleToRemove = null;\n          String query = \"select * from Books\";\n          int maxBooks = 0;\n          CallableStatement cstmt = conn.prepareCall(call);\n          String titles = \"%Hero%\";\n          int numBooksRemoved;\n          cstmt.setInt(1,maxBooks);\n          cstmt.setString(2,titleToRemove);\n          cstmt.registerOutParameter(1,java.sql.Types.INTEGER);\n          cstmt.execute();\n          numBooksRemoved = cstmt.getInt(1);\n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }  \n}','this is the way to use a CallableStatement.','JDBC',1,NULL),(2148,'try(RowSetFactory rsf = RowSetProvider.newFactory()) {\nRowSet rws = rsf.createRowSet();','Will not compile RowSetFactory does not implement autocloseable','JDBC',1,NULL),(2149,'String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n       //try(Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\")){\n        \n        try(CachedRowSet crs = RowSetProvider.newFactory().createCachedRowSet()) {\n            String query = \"Select * From employee\";\n            crs.setCommand(query);\n            crs.setUrl(url);\n            crs.setUsername(user);\n            crs.setPassword(pw);\n            crs.execute();\n            crs.last();\n            crs.updateString(\"last_name\", \"Sullivan\");\n            //database goes offline\n            crs.moveToInsertRow();\n            crs.updateInt(\"ID\",101);\n            crs.updateString(\"first_name\",\"Billy\");\n            crs.updateString(\"last_name\",\"Blue\");\n            crs.insertRow();\n            crs.moveToCurrentRow();\n            crs.absolute(10);\n            crs.deleteRow();\n            //db backonline\n        } catch(SQLException e){\n            System.out.println(e);\n        }','this database will be unchanged. the error here is that acceptChanges() was\nnever called to reconcile the changes made with the in memory version and the\nactual db.\n\nthe database being offline anytime after the execute() is invoked in irrelevent\n','JDBC',1,NULL),(2150,'public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n       //try(Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\")){\n        \n        try(CachedRowSet crs = RowSetProvider.newFactory().createCachedRowSet()) {\n            String query = \"Select * From employee\";\n            crs.setCommand(query);\n            crs.setUrl(url);\n            crs.setUsername(user);\n            crs.setPassword(pw);\n            crs.execute();\n            crs.last();\n            crs.updateString(\"last_name\", \"Sullivan\");\n            //database goes offline\n            crs.moveToInsertRow();\n            crs.updateInt(\"ID\",101);\n            crs.updateString(\"first_name\",\"Billy\");\n            crs.updateString(\"last_name\",\"Blue\");\n            crs.moveToCurrentRow();\n            crs.absolute(10);\n            crs.deleteRow();\n            //db backonline\n        } catch(SQLException e){\n            System.out.println(e);\n        }\n    }  \n}\nwhats missing here ?','crs.insertRow();\n\nalso crs.acceptChanges()','JDBC',1,NULL),(2151,'public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n       //try(Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\")){\n        \n        try(CachedRowSet crs = RowSetProvider.newFactory().createCachedRowSet()) {\n            String query = \"Select * From employee\";\n            crs.setCommand(query);\n            crs.setUrl(url);\n            crs.setUsername(user);\n            crs.setPassword(pw);\n            crs.last();\n            crs.updateString(\"last_name\", \"Sullivan\");\n            //database goes offline\n            crs.moveToInsertRow();\n            crs.updateInt(\"ID\",101);\n            crs.updateString(\"first_name\",\"Billy\");\n            crs.updateString(\"last_name\",\"Blue\");\n            crs.insertRow();\n            crs.moveToCurrentRow();\n            crs.absolute(10);\n            crs.deleteRow();\n            //db backonline\n        } catch(SQLException e){\n            System.out.println(e);\n        }\n    }  \n}','crs.execute() is missing','JDBC',1,NULL),(2152,'public class Hello {\n    public static void main(String[] args){\n        \n        boolean businessrule = true;\n       try(Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\")){\n            String query = \"Inser into ...\";\n            String query2 = \"Updat table...\";\n            \n            Statement st = conn.createStatement();\n            \n            st.executeUpdate(query);\n            st.executeUpdate(query2);\n            \n            if(businessrule){\n                conn.rollback();\n            }\n        } catch(SQLException e){\n            System.out.println(e);\n        }\n    }  \n}','the first two updates are executed, but then a sqlexception is thrown because \na transaction was never started to rollback.\n\nyou would have had to setAutoCommit(false) to start a transaction.\n\nThe first two were automatically commited. ','JDBC',1,NULL),(2153,'public class Hello {\n    public static void main(String[] args){\n        \n        boolean businessrule = false;\n       try(Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\")){\n            conn.setAutoCommit(false);\n            String query = \"Inser into ...\";\n            String query2 = \"Updat table...\";\n            \n            Statement st = conn.createStatement();\n            \n            st.executeUpdate(query);\n            st.executeUpdate(query2);\n            \n            if(businessrule){\n                conn.rollback();\n            } else {\n                conn.commit();\n            }\n        } catch(SQLException e){\n            System.out.println(e);\n        }\n    }  \n}','if the business rule remains false then both updates will be comitted.\nsince autocommit is false.','JDBC',1,NULL),(2154,'public class Hello {\n    public static void main(String[] args){\n\n       try(Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\")){\n            conn.setAutoCommit(false);\n            String query = \"Inser into ...\";\n            String query2 = \"Updat table...\";\n            Statement st = conn.createStatement();\n            \n            st.executeUpdate(query);\n            \n            Savepoint sp1 = conn.setSavepoint();\n            \n            st.executeUpdate(query2);\n            \n            conn.rollback();\n           \n        } catch(SQLException e){\n            System.out.println(e);\n        }\n    }  \n}','no rows are added at all, the rollback() rolls back to the savepoint but erasing the\nsecond update, but because there is no commit() at all the first update will also be \nrolledback when the try block closes for good becaus autocommitmode was set\nto false. ','JDBC',1,NULL),(2155,'public class Hello {\n    public static void main(String[] args){\n        try {\n            Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\");\n            Statement st = conn.createStatement();\n            String q = \"Select * From employees limit 100\";\n            ResultSet rs = st.executeQuery(q);\n            \n            rs.first();\n            System.out.println(\"First entry:\");\n            System.out.println(rs.getString(\"first_name\") + \" \" +rs.getString(\"last_name\"));\n            \n            rs.last();\n            System.out.println(\"Last entry:\");\n            System.out.println(rs.getString(\"first_name\") + \" \" +rs.getString(\"last_name\"));\n            \n            rs.absolute(20);\n            System.out.println(\"row: \"+ rs.getRow());\n            System.out.println(rs.getString(\"first_name\") + \" \" +rs.getString(\"last_name\"));\n            \n            rs.relative(10);\n            System.out.println(\"row: \"+ rs.getRow());\n            System.out.println(rs.getString(\"first_name\") + \" \" +rs.getString(\"last_name\")); \n            \n            String update = \"insert into employees values(09,\'Broden\',\'Chapman\')\";\n            boolean results = st.execute(update);\n            \n            if(!results){\n                System.out.println(\"update executed\");\n            }\n            \n            rs.last();\n            System.out.println(\"new entry row: \"+ rs.getRow());\n            System.out.println(rs.getString(\"first_name\") + \" \" +rs.getString(\"last_name\")); \n\n        } catch(SQLException e){System.out.println(e); }\n        \n    }\n}','First entry:\nMicheal Boyd\nLast entry:\nKenroku Malabarba\nrow: 20\nKyoichi Maliniak\nrow: 30\nGuoxiang Nooteboom\nupdate executed\njava.sql.SQLException: Operation not allowed after ResultSet closed\n\nAfter re executing a statement, all ResultSets tied to that statemnt are \nautomatically closed','JDBC',1,NULL),(2156,'public class Hello {\n    public static void main(String[] args){\n        try {\n            Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\");\n            Statement st = conn.createStatement();\n            String q = \"Select * From employees limit 100\";\n            getDBfile();\n            ResultSet rs = st.executeQuery(q);\n            \n            rs.first();\n            System.out.println(\"First entry:\");\n            System.out.println(rs.getString(\"first_name\") + \" \" +rs.getString(\"last_name\"));\n            \n            rs.last();\n            System.out.println(\"Last entry:\");\n            System.out.println(rs.getString(\"first_name\") + \" \" +rs.getString(\"last_name\"));\n            \n            rs.absolute(20);\n            System.out.println(\"row: \"+ rs.getRow());\n            System.out.println(rs.getString(\"first_name\") + \" \" +rs.getString(\"last_name\"));\n            \n            rs.relative(10);\n            System.out.println(\"row: \"+ rs.getRow());\n            System.out.println(rs.getString(\"first_name\") + \" \" +rs.getString(\"last_name\")); \n            \n            String update = \"insert into employees values(09,\'Broden\',\'Chapman\')\";\n            boolean results = st.execute(update);\n            \n            if(!results){\n                System.out.println(\"update executed\");\n            }\n            \n            rs.last();\n            System.out.println(\"new entry row: \"+ rs.getRow());\n            System.out.println(rs.getString(\"first_name\") + \" \" +rs.getString(\"last_name\")); \n\n        } catch(SQLException e | IOException e){System.out.println(e); }\n        \n    }\n    \n    public static void getDBfile() throws IOException { }  \n}','Will not compile, this is not the right syntax for multi - catch\nshould be \n\n	} catch(SQLException | IOException e){  ... }','General',1,NULL),(2157,'public class Hello {\n    public static void main(String[] args){\n        try {\n            Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\");\n            PreparedStatement pst = conn.prepareStatement(\"Select * From employees limit 100\");\n            ResultSet rs = pst.executeQuery();\n            \n            java.util.Date d = new java.util.Date();\n\n            rs.first();\n            System.out.println(\"First entry:\");\n            System.out.println(\"Hired today: \"+d);\n            System.out.println(rs.getString(\"first_name\") + \" \" +rs.getString(\"last_name\"));\n            \n            rs.last();\n            System.out.println(\"Last entry:\");\n            System.out.println(rs.getString(\"first_name\") + \" \" +rs.getString(\"last_name\"));\n            \n            rs.absolute(20);\n            System.out.println(\"row: \"+ rs.getRow());\n            System.out.println(rs.getString(\"first_name\") + \" \" +rs.getString(\"last_name\"));\n            \n            rs.relative(10);\n            System.out.println(\"row: \"+ rs.getRow());\n            System.out.println(rs.getString(\"first_name\") + \" \" +rs.getString(\"last_name\")); \n            \n            String update = \"insert into employees values(11,\'Broden\',\'Chapman\')\";\n            boolean results = pst.execute(update);\n            \n            if(!results){\n                System.out.println(\"update executed\");\n            }\n            \n            rs.last();\n            System.out.println(\"new entry row: \"+ rs.getRow());\n            System.out.println(rs.getString(\"first_name\") + \" \" +rs.getString(\"last_name\")); \n\n        } catch(SQLException e){System.out.println(e); }\n        \n    }\n}','First entry:\nHired today: Fri Jul 28 11:29:33 EDT 2017\nMicheal Boyd\nLast entry:\nTuval Kalloufi\nrow: 20\nChirstian Koblick\nrow: 30\nBerni Genin\nupdate executed\njava.sql.SQLException: Operation not allowed after ResultSet closed','JDBC',1,NULL),(2158,'public static void main(sa) {\n	//most useless method\n	Date d = new Date();\n	sout( d.getTime() + \" \" );\n}\n\nwhat does this show ?','public long getTime()\n\nReturns the number of milliseconds \nsince January 1, 1970, 00:00:00 GMT represented by this Date object.','Strings',1,NULL),(2159,'public class Hello {\n    public static void main(String[] args){\n        try {\n            Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\");\n            PreparedStatement pst = conn.prepareStatement(\"Select * From employees limit 100\");\n            ResultSet rs = pst.executeQuery();\n            \n            Date d = new Date();\n            //Calendar c = Calendar.getInstance();\n            Calendar c = new Calendar();\n            c.setTime(d);\n\n            rs.first();\n            System.out.println(\"First entry:\");\n            System.out.println(\"Hired today: \"+d);\n            System.out.println(\"Start first upcoming monday: \"+firstNextMonday(d));\n            System.out.println(rs.getString(\"first_name\") + \" \" +rs.getString(\"last_name\"));\n            \n            c.add(Calendar.MONTH,-1);\n            Date monthago = c.getTime();\n            rs.last();\n            System.out.println(\"Last entry:\");\n            System.out.println(\"Hired a month ago: \"+monthago);\n            System.out.println(rs.getString(\"first_name\") + \" \" +rs.getString(\"last_name\"));\n            ','WNC, the correct way to create a Calendar is \n\n	Calendar c = Calendar.getInstance();','Strings',1,NULL),(2160,'public class Hello {\n    public static void main(String[] args){\n        try {\n            Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\");\n            PreparedStatement pst = conn.prepareStatement(\"Select * From employees limit 100\");\n            ResultSet rs = pst.executeQuery();\n            \n            Date d = new Date();\n            Calendar c = new Calendar();\n            c.setTime(d);\n\n            rs.first();\n            System.out.println(\"First entry:\");\n            System.out.println(\"Hired today: \"+d);\n            System.out.println(\"Start first upcoming monday: \"+firstNextMonday(d));\n            System.out.println(rs.getString(\"first_name\") + \" \" +rs.getString(\"last_name\"));\n            \n            c.add(Calendar.MONTH,-1);\n            Date monthago = c.getTime();\n            rs.last();\n            System.out.println(\"Last entry:\");\n            System.out.println(\"Hired a month ago: \"+monthago);\n            System.out.println(rs.getString(\"first_name\") + \" \" +rs.getString(\"last_name\"));\n        } catch(SQLException e){ }\n        \n    }\n    \n    public static Date firstNextMonday(Date d){\n        Calendar c = Calendar.getInstance();\n        c.setTime(d);\n        \n        while(c.DAY_OF_WEEK != c.MONDAY){\n            //c.add(1,DAY_OF_WEEK);\n            c.add(c.DAY_OF_WEEK,1);\n        }\n        \n        return c.getTime();\n        \n    }\n}','WNC, the corrct ways to create a Calendar is \n\n	Calendar c = Calendar.getInstance();\n\nif that was corrected then this program would print:\n\n	First entry:\n	Hired today: Mon Aug 07 16:39:34 EDT 2017\n\nand keep running forever...\n\n	you were using accesing a static field at c.DAY_OF_WEEK\n	\n	it should be:\n\n	while(c.get(Calendar.DAY_OF_WEEK) != c.MONDAY){\n            //c.add(1,DAY_OF_WEEK);\n            c.add(c.DAY_OF_WEEK,1);\n        }\n\nif today was monday it would print the excact time and day of right now','Strings',1,NULL),(2161,'public class Hello {\n    public static void main(String[] args){\n        try {\n            Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\");\n            PreparedStatement pst = conn.prepareStatement(\"Select * From employees where first_name = ?\");\n            ResultSet rs = pst.executeQuery();\n            \n            Date d = new Date();\n            Calendar c = Calendar.getInstance();\n            c.setTime(d);\n            \n            DateFormat dateformat = DateFormat.getInstance();\n\n            rs.first();\n            System.out.println(\"First entry:\");\n            System.out.println(\"Hired today: \"+d);\n            System.out.println(\"Start first upcoming monday: \"+firstNextMonday(d));\n            System.out.println(rs.getString(\"first_name\") + \" \" +rs.getString(\"last_name\"));\n            \n            c.add(Calendar.MONTH,-1);\n            Date monthago = c.getTime();\n            rs.last();\n            System.out.println(\"Last entry:\");\n            System.out.println(\"Hired a month ago: \"+monthago);\n            System.out.println(rs.getString(\"first_name\") + \" \" +rs.getString(\"last_name\"));\n            \n            c.setTime(d);\n            c.add(Calendar.YEAR,-1);\n            c.add(Calendar.MONTH, -6);\n            Date yearandahalf = c.getTime();\n            rs.absolute(20);\n            System.out.println(\"row: \"+ rs.getRow());\n            System.out.println(\"Hired a year and a half ago\"+yearandahalf);\n            System.out.println(rs.getString(\"first_name\") + \" \" +rs.getString(\"last_name\"));\n	} catch(SQLException e) { }\n   }\n}','java.sql.SQLException: No value specified for parameter 1','Strings',1,NULL),(2162,'public static void main(String[] args){\n        Date d = new Date();\n        DateFormat df = DateFormat.getInstance();\n        \n        System.out.println(df.format(d));\n        \n    }','7/28/17 12:39 PM','Strings',1,NULL),(2163,'public static void main(String[] args){\n\n        Date d = new Date();\n        DateFormat df = DateFormat.getDateInstance();\n        \n        System.out.println(df.format(d));\n        \n    }','Jul 28, 2017','Strings',1,NULL),(2164,'What dateformat is this\n\n7/28/17',' public static void main(String[] args){\n        Date d = new Date();\n        DateFormat df = DateFormat.getDateInstance(DateFormat.SHORT);\n        \n        System.out.println(df.format(d));\n        \n    }','Strings',1,NULL),(2165,'public static void main(String[] args){\n        Date d = new Date();\n        DateFormat df = DateFormat.getDateInstance(DateFormat.SHORT);\n        \n        String s = df.format(d);\n        \n        Date d2 = df.parse(s);\n    }','will not compile, ParseException must be caught or thrown','Strings',1,NULL),(2166,'public static void main(String[] args){\n        Date d = new Date();\n        DateFormat df = DateFormat.getDateInstance(DateFormat.SHORT);\n        \n        String s = df.format(d);\n        \n        try{\n            Date d2 = df.parse(s);\n            System.out.println(\"parsed \"+d2);\n        } catch( ParseException e){\n            \n        }\n    }','parsedFri Jul 28 00:00:00 EDT 2017','Strings',1,NULL),(2167,'public static void main(String[] args){\n        Date d = new Date();\n        DateFormat df = new DateFormat(DateFormat.SHORT);\n        \n        String s = df.format(d);\n        \n        try{\n            Date d2 = df.parse(s);\n            System.out.println(\"parsed \"+d2);\n        } catch( ParseException e){\n            \n        }\n    }','WNC dateformat is abstract cannot be instantiated ','Strings',1,NULL),(2168,'try {\n            Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\");\n            PreparedStatement pst = conn.prepareStatement(\"Select * From employees limit 100\");\n            ResultSet rs = pst.executeQuery();\n            \n            Date d = new Date();\n            Calendar c = Calendar.getInstance();\n            c.setTime(d);\n            \n            DateFormat dateformat = DateFormat.getInstance();\n            Locale italian = new Locale(\"it\");\n            DateFormat italianformat = DateFormat.getInstance(DateFormat.FULL,italian);\n} catch(SQLException e){ }','The regular DF constructor doesn\'t take a style or Locale.\n\nGet a default date/time \nformatter that uses the SHORT style for both the date and the time.\n\nwith statements preparedstatements callablestatements:\n\n	executeQuery() returns a ResultSet\n	executeUpdate() returns an int\n	execute()  returns a boolean','Strings',1,NULL),(2169,'public class Hello {\n    public static void main(String[] args){\n        DateFormat df = DateFormat.getDateInstance(DateFormat.FULL,Locale.KOREA);\n        Date now = new Date();\n        \n        System.out.println(df.format(now));\n        \n        df.setLocale(Locale.US);\n        \n        System.out.println(df.format(now));\n    }\n}','WNC you can only set a DateFormat and NumberFormat can only set\n local at the time of instantiation. There is not method to change locale\nafterward.','Strings',1,NULL),(2170,'public class Hello {\n    public static void main(String[] args){\n        Locale loc1 = new Locale(\"pt\",\"BR\");\n        Locale loc2 = new Locale(\"da\",\"DK\");\n        Locale loc3 = new Locale(\"it\", \"IT\");\n        \n        System.out.println(loc1.getDisplayCountry());\n        System.out.println(loc2.getDisplayCountry());\n        System.out.println(loc3.getDisplayCountry());\n        \n        //display the countrys name in that language\n        \n        System.out.println(loc1.getDisplayCountry(loc1));\n        System.out.println(loc2.getDisplayCountry(loc2));\n        System.out.println(loc3.getDisplayCountry(loc3));\n    }\n}','Brazil\nDenmark\nItaly\nBrasil\nDanmark\nItalia','Strings',1,NULL),(2171,'public class Hello {\n    public static void main(String[] args){\n        float f1 = 123.43535353f;\n        NumberFormat nf = NumberFormat.getInstance();\n        System.out.println(nf.getMaximumFractionDigits());\n        \n        System.out.println(nf.format(f1));\n        \n    }\n}','3\n123.435','Strings',1,NULL),(2172,'public class Hello {\n    public static void main(String[] args){\n        float f1 = 123.43535353f;\n        NumberFormat nf = NumberFormat.getInstance();\n        System.out.println(nf.getMaximumFractionDigits());\n        \n        System.out.println(nf.format(f1));\n        \n        nf.setMaximumFractionDigits(5);\n        \n        System.out.println(nf.format(f1));\n        \n    }\n}','3\n123.435\n123.43536','Strings',1,NULL),(2173,'public class Hello {\n    public static void main(String[] args){\n        float f1 = 123.43535353f;\n        NumberFormat nf = NumberFormat.getInstance();\n        \n        try{\n            System.out.println(nf.parse(\"345.3435\"));\n            nf.setParseIntegerOnly(true);\n            System.out.println(nf.parse(\"345.3435\"));\n        } catch(ParseException e){\n            \n        }\n    }\n}','345.3435\n345','Strings',1,NULL),(2174,'public class Hello {\n    public static void main(String[] args){\n        float f1 = 123.43535353f;\n        NumberFormat nf = NumberFormat.getInstance();\n        NumberFormat nf2 = NumberFormat.getInstance(Locale.KOREA);\n        NumberFormat nf3 = NumberFormat.getCurrencyInstance();\n        NumberFormat nf4 = NumberFormat.getCurrencyInstance(Locale.KOREA);\n        \n        System.out.println(nf.format(f1));\n        System.out.println(nf2.format(f1));\n        System.out.println(nf3.format(f1));\n        System.out.println(nf4.format(f1));\n\n    }\n}','123.435\n123.435\n$123.44\n?123\n\ncould vary from maching to machine','Strings',1,NULL),(2175,'public class Hello {\n    public static void main(String[] args){\n        Pattern p = Pattern.compile(\"ab\");\n        Matcher m = p.matcher(\"abakdnfab kekrls ab\");\n        \n        while(m.find()){\n            System.out.println(m.start());\n        }\n        \n    }\n}','0\n7\n17','Strings',1,NULL),(2176,'public class Hello {\n    public static void main(String[] args){\n        Pattern p = Pattern.compile(\"\\\\d\");\n        Matcher m = p.matcher(\"The silly Dog89 ran for miles.56 Like a silly little puppy45\");\n        \n        while(m.find()){\n            System.out.println(m.start());\n        }\n        \n    }\n}','13\n14\n30\n31\n58\n59\n\n\\\\d looks for digits','Strings',1,NULL),(2177,'first:\n    public static void main(String[] args){\n        Pattern p = Pattern.compile(\"\\\\d\");\n        Matcher m = p.matcher(\"The silly Dog ran for 89 miles.\");\n        \n        while(m.find()){\n            System.out.println(m.start());\n        }\n        \n    }\nsecond:\n	public static void main(String[] args){\n        Pattern p = Pattern.compile(\"\\\\D\");\n        Matcher m = p.matcher(\"The silly Dog ran for 89 miles.\");\n        \n        while(m.find()){\n            System.out.println(m.start());\n        }\n        \n    }\n','\\\\d looks for digits, \\\\D looks for nondigitis\nfirst:\n22\n23\n\nsecond:\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n24\n25\n26\n27\n28\n29\n30','Strings',1,NULL),(2178,'regex metacharacter:\n\n\\s','a whitespace character \\t \\n \\f \\r','Strings',1,NULL),(2179,'regex metacharacter:\n\n\\S','non white space','Strings',1,NULL),(2180,'regex metacharacter:\n\n\\w word character\n\nmeaning what ?','a-z A-Z digits or _','Strings',1,NULL),(2181,'regex metacharacter:\n\n\\W non word character\n\nmeaning what ?','everything besides a-z A-Z _ or digits','Strings',1,NULL),(2182,'public static void main(String[] args){\n        Pattern p = Pattern.compile(\"\\\\s\");\n        Matcher m = p.matcher(\"The silly Dog ran for 89 miles.\");\n        \n        while(m.find()){\n            System.out.println(m.start());\n        }\n        \n    }','3\n9\n13\n17\n21\n24\n\nwhitespace characters','Strings',1,NULL),(2183,'public static void main(String[] args){\n        Pattern p = Pattern.compile(\"\\\\S\");\n        Matcher m = p.matcher(\"The silly Dog ran for 89 miles.\");\n        \n        while(m.find()){\n            System.out.println(m.start());\n        }\n        \n    }','all the non white spaces:\n0\n1\n2\n4\n5\n6\n7\n8\n10\n11\n12\n14\n15\n16\n18\n19\n20\n22\n23\n25\n26\n27\n28\n29\n30','Strings',1,NULL),(2184,'public static void main(String[] args){\n        Pattern p = Pattern.compile(\"\\\\w\");\n        Matcher m = p.matcher(\"The silly Dog ran for 89 miles.\");\n        \n        while(m.find()){\n            System.out.println(m.start());\n        }\n        \n    }','0   all the word characters similiar to \\\\S\n1\n2\n4\n5\n6\n7\n8\n10\n11\n12\n14\n15\n16\n18\n19\n20\n22\n23\n25\n26\n27\n28\n29','Strings',1,NULL),(2185,'public static void main(String[] args){\n        Pattern p = Pattern.compile(\"\\\\W\");\n        Matcher m = p.matcher(\"The silly Dog ran for 89 miles.\");\n        \n        while(m.find()){\n            System.out.println(m.start());\n        }\n        \n    }','3  //non word character similar to \\\\S numbers are word characters\n9\n13\n17\n21\n24\n30','Strings',1,NULL),(2186,'public class Hello {\n    public static void main(String[] args){\n        Pattern p = Pattern.compile(\"\\\\b\");\n        Matcher m = p.matcher(\"The silly Dog ran for 89 miles.\");\n        \n        while(m.find()){\n            System.out.println(m.start());\n        }\n        \n    }\n}','a word boundary, anytime there is a word character and a non word right next to\neach other.\nThere are invisible non word characters at the end and beginning of a string.\n\n0\n3\n4\n9\n10\n13\n14\n17\n18\n21\n22\n24\n25\n30','Strings',1,NULL),(2187,'public class Hello {\n    public static void main(String[] args){\n        Pattern p = Pattern.compile(\"\\\\B\");\n        Matcher m = p.matcher(\"The silly Dog ran for 89 miles.\");\n        \n        while(m.find()){\n            System.out.println(m.start());\n        }\n        \n    }\n}','//non word boundary each of these is a case where there IS NO word boundary\nor two word characters are beside each other or two non words are beside each other\nreturns the position of the second character.\n\n1 \n2\n5\n6\n7\n8\n11\n12\n15\n16\n19\n20\n23\n26\n27\n28\n29\n31','Strings',1,NULL),(2188,'public static void main(String[] args){\n        Pattern p = Pattern.compile(\"[soi]\");\n        Matcher m = p.matcher(\"The silly Dog ran for 89 miles.\");\n        \n        while(m.find()){\n            System.out.println(m.start());\n        }\n        \n    }','4\n5\n11\n19\n26\n29','Strings',1,NULL),(2189,'public class Hello {\n    public static void main(String[] args){\n        Pattern p = Pattern.compile(\"[a-z]\");\n        Matcher m = p.matcher(\"The silly Dog ran for 89 miles.\");\n        \n        while(m.find()){\n            System.out.println(m.start());\n        }\n        \n    }\n}\n','1\n2\n4\n5\n6\n7\n8\n11\n12\n14\n15\n16\n18\n19\n20\n25\n26\n27\n28\n29','Strings',1,NULL),(2190,'public class Hello {\n    public static void main(String[] args){\n        Pattern p = Pattern.compile(\"[a-cA-C]\");\n        Matcher m = p.matcher(\"The silly Dog ran for 89 miles.\");\n        \n        while(m.find()){\n            System.out.println(m.start());\n        }\n        \n    }\n}','15','Strings',1,NULL),(2191,'public class Hello {\n    public static void main(String[] args){\n        Pattern p = Pattern.compile(\"a?\");\n        Matcher m = p.matcher(\"The silly Dog ran for at least 89 miles.I am tired he said\");\n        \n        while(m.find()){\n            System.out.println(m.group());\n        }\n        \n    }\n}','// the mistake here is that ? gives you \"ZERO OR ONE\" so if there is no a \nthere that still mathces!\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58','Strings',1,NULL),(2192,'creaet a regex that finds a word composed of an \'a\' with any character next to it','public class Hello {\n    public static void main(String[] args){\n        Pattern p = Pattern.compile(\" a.\");\n        Matcher m = p.matcher(\"The silly Dog ran for at least 89 miles.I am tired he said\");\n        \n        while(m.find()){\n            System.out.println(m.start());\n            System.out.println(m.group());\n        }\n        \n    }\n}\n\n21\n at\n41\n am','Strings',1,NULL),(2193,'public class Hello {\n    public static void main(String[] args){\n        Pattern p = Pattern.compile(\"a.\");\n        Matcher m = p.matcher(\"The silly Dog ran for at least 89 miles.I am tired he said\");\n        \n        while(m.find()){\n            System.out.println(m.start());\n            System.out.println(m.group());\n        }\n        \n    }\n}\n\n','Without the space at the beginning of the pattern you allow a then any character\nto but up against any other character if you wanted it to just be individual\nwords then you could add a space at the beginning or a whitespce character.\n15\nan\n22\nat\n27\nas\n42\nam\n55\nai','Strings',1,NULL),(2194,'public class Hello {\n    public static void main(String[] args){\n        Pattern p = Pattern.compile(\"\\\\sa.\");\n        Matcher m = p.matcher(\"The silly Dog ran for at least 89 miles.I am tired he said\");\n        \n        while(m.find()){\n            System.out.println(m.start());\n            System.out.println(m.group());\n        }\n        \n    }\n}','21\n at\n41\n am','Strings',1,NULL),(2195,'public class Hello {\n    public static void main(String[] args){\n        //five letter words\n        Pattern p = Pattern.compile(\"\\\\s.....\\\\s\");\n        Matcher m = p.matcher(\"A regular expression, specified as a string, must first be compiled into an instance of this class\");\n        \n        while(m.find()){\n            System.out.println(m.start());\n            System.out.println(m.group());\n        }\n        \n    }\n}','49\n first ','Strings',1,NULL),(2196,'public class Hello {\n    public static void main(String[] dicks){\n      Path src = Paths.get(\"/home/maxbisesi/Documents/allfiles/copy.txt\");\n      Path srcParent = src.getParent();\n      System.out.println(srcParent);\n      \n    }\n\n}','/home/maxbisesi/Documents/allfiles\n\nNone of these methods throw an IOE','Input/Output',1,NULL),(2197,' public static void main(String[] args){\n        //five letter words\n        Pattern p = Pattern.compile(\".*xx\");\n        Matcher m = p.matcher(\"yyxxxyxx\");\n        \n        while(m.find()){\n            System.out.println(m.start());\n            System.out.println(m.group());\n		  System.out.println(m.end());\n        }\n        \n      \n    }','0\nyyxxxyxx\n8\n\n* is greedy so it reads then entire source then works backward, until it finds\nthe rightmost match. ','Strings',1,NULL),(2198,'public static void main(String[] args){\n        //five letter words\n        Pattern p = Pattern.compile(\".*y\");\n        Matcher m = p.matcher(\"yyxxxyxx\");\n        \n        while(m.find()){\n            System.out.println(m.start());\n            System.out.println(m.group());\n            System.out.println(m.end());\n        }\n        \n      \n    }','0\nyyxxxy\n6\n\ngreedy reads the whole source data first','Strings',1,NULL),(2199,' public static void main(String[] args){\n        //five letter words\n        Pattern p = Pattern.compile(\"\\\\d*\");\n        Matcher m = p.matcher(\"yy4xx89xxye90g\");\n        \n        while(m.find()){\n            System.out.println(m.start()+\":_\"+m.group()+\"_\");\n        }\n        \n      \n    }','This pattern says its looking for zero or more digits, \nso at the positions other than 2 5 and 11 it does find 0 digits\n\n0:__\n1:__\n2:_4_\n3:__\n4:__\n5:_89_\n7:__\n8:__\n9:__\n10:__\n11:_90_\n13:__\n14:__\n\n','Strings',1,NULL),(2200,'public static void main(String[] args){\n        //five letter words\n        Pattern p = Pattern.compile(\"a?\");\n        Matcher m = p.matcher(\"abaabbbaaabbaaa\");\n        \n        while(m.find()){\n            System.out.println(m.start()+\":_\"+m.group()+\"_:\"+m.end());\n        }\n        \n      \n    }','Greedy will allow zero length matches, proven by the start and end indexs being \nthe same.\n\n0:_a_:1\n1:__:1\n2:_a_:3\n3:_a_:4\n4:__:4\n5:__:5\n6:__:6\n7:_a_:8\n8:_a_:9\n9:_a_:10\n10:__:10\n11:__:11\n12:_a_:13\n13:_a_:14\n14:_a_:15\n15:__:15','Strings',1,NULL),(2201,'public class Hello {\n    public static void main(String[] args){\n        String[] tokens = \"hello my darling\".split(\" \");\n        \n        for(String s : tokens){\n            System.out.println(s);\n        }\n    }\n\n}','hello\nmy\ndarling','Strings',1,NULL),(2202,'public static void main(String[] args){\n        String[] tokens = \"hello5my5darling\".split(\"\\\\d\");\n        \n        for(String s : tokens){\n            System.out.println(s);\n        }\n    }','hello\nmy\ndarling','Strings',1,NULL),(2203,'public static void main(String[] args){\n        String[] tokens = \"bigibhjvu louf kvciy\".split(\"\");\n        \n        for(String s : tokens){\n            System.out.println(s);\n        }\n    }','b\ni\ng\ni\nb\nh\nj\nv\nu\n \nl\no\nu\nf\n \nk\nv\nc\ni\ny','Strings',1,NULL),(2204,'what is scanners default delemiter','whitespace','Strings',1,NULL),(2205,'public static void main(String[] args){\n        Pattern p = Pattern.compile(\"\\\\d*\");\n        Matcher m = p.matcher(\"ab34ef\");\n        while(m.find()){\n            System.out.print(m.start() + m.group());\n        }\n    }','01234456','Strings',1,NULL),(2206,'public static void main(String[] args){\n        Pattern p = Pattern.compile(\"\\\\d*\");\n        Matcher m = p.matcher(\"ab34ef8hk12345\");\n        while(m.find()){\n            System.out.print(m.start() + m.group());\n        }\n    }','0123445687891234514','Strings',1,NULL),(2207,'public class Hello {\n    public static void main(String[] args){\n        ResourceBundle rb = ResourceBundle.getBundle(\"NickNames\");\n        System.out.println(rb.getString(\"Max Bisesi\"));\n        \n    }\n}\n\nclass NickNames extends ListResourceBundle {\n    protected Object[][] getContents(){\n        return new Object[][]{{\"hello\",\"from java\"},{\"Max Bisesi\",\"Big Bad Max\"},{\"Garret Gieske\", \"gieske\"}};\n    }\n}','\n\n\n\n\n\n\n\n\n\n\nException in thread \"main\" java.util.MissingResourceException: \nCan\'t find bundle for base name NickNames, locale en_US\n\n\n\n\n\n\n\n\n\n\n\n','Locale',1,NULL),(2208,'public static void main(String[] args){\n       Locale initial = Locale.getDefault();\n        System.out.println(initial);\n        \n        Locale.setDefault(Locale.GERMANY);\n        System.out.println(Locale.getDefault());\n        \n    }','en_US\nde_DE','Locale',1,NULL),(2209,'two ways to get a ResourceBundle: ?','ResourceBundle.getBundle(basename);\nResourceBundle.getBundle(basename, locale);\n\nfirst uses default locale','Locale',1,NULL),(2210,'Java chooses the most specific resource bundle it can while while giving\npreference to java ListResourceBundle','got it !','Locale',1,NULL),(2211,'request french canadian resource bundle\n\nLocale loc = new Locale(\"fr\",\"CA\");\nResourceBundle rb = ResourceBundle.getBundle(\"RB\",loc);\n\nhow will java search for that bundle ?','RB_fr_CA.java // a java class mathcing excactly\nRB_fr_CA.properties // then it looks for exectaly matching property files\n\nRB_fr.java\nRB_fr.properites // if it cant find both it will look for the Language\n\n\nRB_en_US.java\nRB_en_US.poperties   // use the default locale instead\n\nRB_en.java\nRB_en.properties   //just llook for the default language\n\nRB.java\nRB.properties    //try default Bundle name','Locale',1,NULL),(2212,'What happens if java cant find a resourceBundle','missingresourceexception','Locale',1,NULL),(2213,'ResourceBundles can inherit properties from parents\n\nRB_en.properties\n	ride.in=Take a ride in\n\nRB_en_US.properties\n	elevator=elevator\n\nRB_en_UK.properties\n	elevator=lift\n\nLocale locale = new Locale(\"en\",\"UK\");\nResourceBundle rb = ResourceBundle.getBundle(\"RB\",locale);\nsout(rb.getString(\"ride.in\") + rb.getString(\"elevator\"));','Take a ride in the lift','Locale',1,NULL),(2214,'public static void main(String[] args){\n      ResourceBundle rb = ResourceBundle.getBundle(\"Flag\",new Locale(\"en_CA\"));\n        System.out.println(rb.getString(\"key\"));\n        \n    }\n\nthere are no resourcebundles loaded','MissingResourceException','Locale',1,NULL),(2215,'public static void main(String[] args){\n      ResourceBundle rb = ResourceBundle.getBundle(\"Flag\",new Locale(\"en_CA\"));\n        System.out.println(rb.getString(\"key\"));\n        \n    }\n\ndefault locale is Italian if there is only one resource bundle on the classpath\nhow will java search for that bundle based on the above ?','Flag_en_CA.properties\nFlag_en.java\nFlag_en.properties\nFlag.properties','Locale',1,NULL),(2216,'public static void main(String[] args){\n      ResourceBundle rb = ResourceBundle.getBundle(\"Flag\",new Locale(\"en_CA\"));\n        System.out.println(rb.getString(\"key\"));\n        \n    }\n\nwhich will be chosen ?\n\nFlag_fr_CA.properties\nFlag_en.properties\nFlag_CA.properties ','Flag_en.properties\n\nFlag_fr_CA.properties the language does not match\n\nFlag_CA.properties, CA is not a valid lang code','Locale',1,NULL),(2217,'public static void main(String[] args){\n      Pattern p = Pattern.compile(\"\\\\b\");\n      Matcher m = p.matcher(\"^23 *$76 bc\");\n      while(m.find()){\n          System.out.println(m.start()+\" \");\n      }\n        \n    }','1 \n3 \n6 \n8 \n9 \n11 \n\n\\\\b says that the number reported is the end of a boundary between a wordcharacter\nand a non word character,\n\nbetween 0 and 1 is a boundary between a word and a non word.\n\nimagine the end and beginning of a string is an invisible non word.\nposition 0 was not returned here because ^ is non word and that against the \ninvisble non word is not a boundary','Locale',1,NULL),(2218,'  public static void main(String[] args){\n      Pattern p = Pattern.compile(\"\\\\b\");\n      Matcher m = p.matcher(\"#ab de#\");\n      while(m.find()){\n          System.out.println(m.start()+\" \");\n      }\n        \n    }','1\n3\n4\n6','Locale',1,NULL),(2219,' public static void main(String[] args){\n      Pattern p = Pattern.compile(\"\\\\B\");\n      Matcher m = p.matcher(\"#ab de#\");\n      while(m.find()){\n          System.out.println(m.start()+\" \");\n      }\n        \n    }','0 \n2 \n5 \n7\n\nif there is a non word boundary between the last character and \nthe invible end of string non word boundary then start will give \nthe very last character index, where normally it would give the second \nindex of the two characters creating the non word boudary. ','Strings',1,NULL),(2220,'public static void main(String[] args){\n      Pattern p = Pattern.compile(\"\\\\b\");\n      Matcher m = p.matcher(\"abci####r\");\n      while(m.find()){\n          System.out.println(m.start()+\" \");\n      }\n        \n    }','0 \n4 \n8 \n9','Locale',1,NULL),(2221,'when searched using \\\\b what string would give the result: 2467 ?','something like this ^^rt##r\n\nthe output is determined by the difference between a boundary adn a word boundary\n\n','Strings',1,NULL),(2222,'when searched with \\\\B what string could give 1234567 ? ','^^^^^^^\n\nimagine Strings contain non word characters at the beginning and end of\neach string. Here, \\\\B is saying that there is NOT a word boundary between\nthe imaginary non word character that represents the beginning of the string\nand the first ^ symbol because they are both non words.\n\nThen there is NOT a word boundary between the first and subsequent ^ symbols\nbecause they are all non words. ','Locale',1,NULL),(2223,'public static void main(String[] args){\n        String[] chunks = \"1 a2 b 3 c4d 5e\".split(\"\\\\d\");\n        \n        for(String s : chunks){\n            System.out.println(\".\"+s+\".\");\n        }\n        \n    }','..\n. a.\n. b .\n. c.\n.d .\n.e.\n\nif the first character in the String is a delimter the first array\nelement will be an empty token','Locale',1,NULL),(2224,'if the first character in the String is a delimter the first array\nelement will be an empty token','got it ','Locale',1,NULL),(2225,'Train_en_US.properties: train=subway\nTrain_en_UK.properties: train=undergroudn\nTrain_en_.properties: ride = ride;\n\npublic class Choochoo {\n	public static void main(String[] args) {\n		Locale.setDefault(new Locale(\"en\",\"US\"));\n		ResourceBundle rb = \n	ResourceBundle.getBundle(\"Train\",new Locale(\"en\",\"US\"));\n		sout( rb.getString(\"ride\")+\" \"+rb.getString(\"train\"));\n	}\n}\n\nwhich change can you make independently to change the output to \"ride underground\"\n\nchange line 1 to Locale.setDefault(new Locale(\"en\",\"UK));\nAdd train=underground to Train_en.porperties\nchange line5 to new Locale(\"en\",\"UK\"));\nDelete Train_en_US.properties','Changed line5 to new Locale(\"en\",\"UK\")','Locale',1,NULL),(2226,'when using StringBuilder if you append past the current capacity it\ncan be automatically increased.\n\nif you insert past it you will receive an exception','go it ','Locale',1,NULL),(2227,'public static void main(String[] args){\n        StringBuilder sb = new StringBuilder(8);\n        System.out.println(sb.length() + \" \" + sb + \" \");\n        sb.insert(0,\"abcdef\");\n        sb.append(\"789\");\n        System.out.println(sb.length() + \" \" + sb);   \n    }','0  \n9 abcdef789','Locale',1,NULL),(2228,'public static void main(String[] args){\n        StringBuilder sb = new StringBuilder(8);\n        System.out.println(sb.length() + \" \" + sb + \" \");\n        sb.insert(0,\"abcdefghij\");\n        System.out.println(sb.length() + \" \" + sb);   \n    }','0  \n10 abcdefghij\n\nthe string builders capacity has been increased automatically','General',1,NULL),(2229,'public class Hello {\n    public static void main(String[] args){\n        ResourceBundle rb = ResourceBundle.getBundle(\"NickNames\",Locale.getDefault());\n        Object ob = rb.getInteger(\"123\");\n        \n    }\n}\n\nclass NickNames extends ListResourceBundle {\n    protected Object[][] getContents(){\n        return new Object[][]{{\"hello\",\"from java\"},{\"Max Bisesi\",\"Big Bad Max\"},{\"Garret Gieske\", \"gieske\"},{\"123\",678}};\n    }\n}','will not compile, there is no method getInteger();','General',1,NULL),(2230,'public class Hello {\n    public static void main(String[] args){\n        ResourceBundle rb = ResourceBundle.getBundle(\"Hello.NickNames\",Locale.getDefault());\n        Object ob = rb.getString(\"123\");\n        \n    }\n}\n\nclass NickNames extends ListResourceBundle {\n    protected Object[][] getContents(){\n        return new Object[][]{{\"hello\",\"from java\"},{\"Max Bisesi\",\"Big Bad Max\"},{\"Garret Gieske\", \"gieske\"},{\"123\",678}};\n    }\n}','ClassCastException\n\nyoou can either use getString to get a string or getObject to get anything else\nbut you cannot use getString to get an object','General',1,NULL),(2231,'public static void main(Sa) {\n	String s1 = \"abc\";\n	String s2 = s1;\n	s1 += \"d\";\n	sout(s1+\" \"+s2+\" \"+ (s1==s2));\n	\n	StringBuffer sb1 = new StringBuffer(\"abc\");\n	StringBuffer sb2 = sb1;\n	sb1.append(\"d\");\n	sout(sb1+ \" \" + sb2 + \" \" + (sb1==sb2));\n}','abcd abc false\nabcd abcd true\n\nstring objects are immutable references are mutable\n\nSo here, when the s1+=\"d\" executes. The String \"abc\" was once referenced\nby s1 but it not longer is. Now it is referenced by s2. a New String object\nis created abcd and s1 is reassinged to reference that.','General',1,NULL),(2232,'public class Hello {\n    public static void main(String[] args){\n       String s = \" maxy \";\n       String x = \" denny \";\n       s.trim();\n       x.trim();\n       String y = s+x;\n       \n        System.out.println(y);\n    }\n}',' maxy  denny \n\nstrings are immutable, when s.trim() is executed a new String is created\nand a reference to it is returned then immediately lost. s and x remain\npointing to the strings \" maxy \" and \" denny \".\n','General',1,NULL),(2233,'String s = \"987.123456\";\ndouble d = 987.123456d;\nNumberFormat nf = NumberFormat.getInstance();\nnf.setMaximumFractionDigits(5);\nsout(nf.format(d) + \" \");\ntry {\n	sout(nf.parse(s));\n} catch(ParseException e){ }','987.12346 // rounds doesn\'t truncate\n987.123456 // setMaxFracDigs applies to formating but not parsing','General',1,NULL),(2234,'public static void main(String[] args){\n        Pattern p = Pattern.compile(\"\\\\d+\");\n        Matcher m = p.matcher(\"ab2c4d67\");\n        int count = 0;\n        while(m.find()){\n            count++;\n        }\n        System.out.println(count);\n    }','3\n\n\\\\d looks for digits\n\n+ says one or more ','Strings',1,NULL),(2235,' public static void main(String[] args){\n        Pattern p = Pattern.compile(\"\\\\w+\");\n        Matcher m = p.matcher(\"ab2c4d67\");\n        int count = 0;\n        while(m.find()){\n            count++;\n        }\n        System.out.println(count);\n    }','this one is confusing but remember + is greedy\n\nits not a series of word characters in this case the whole damn thing is \none word character','Strings',1,NULL),(2236,'public static void main(String[] args){\n        Pattern p = Pattern.compile(\"\\\\S+\");\n        Matcher m = p.matcher(\"ab2c4d67\");\n        int count = 0;\n        while(m.find()){\n            count++;\n        }\n        System.out.println(count);\n    }','1\n\nthe whole string is one long non whitespace character and + is greedy\nso it took the whole thing','Strings',1,NULL),(2237,' public static void main(String[] args){\n        Pattern p = Pattern.compile(\"\\\\d+\");\n        Matcher m = p.matcher(\"78254467\");\n        int count = 0;\n        while(m.find()){\n            count++;\n        }\n        System.out.println(count);\n    }','1\n\n+ is greedy so this whole number is one big digit, greedy took the whole \nthing','Strings',1,NULL),(2238,'public static void main(String[] args){\n        Pattern p = Pattern.compile(\"\\\\W+\");\n        Matcher m = p.matcher(\"$%^&*\");\n        int count = 0;\n        while(m.find()){\n            count++;\n        }\n        System.out.println(count);\n    }','1\n\nthe whole string is one big non word character so the greedy + took the whole\nthing','Strings',1,NULL),(2239,'psvm(Sa){\n	String input = \"1 2 a 3 45 6\";	\n	Scanner sc = new Scanner(input);\n	int x = 0;\n	do {\n		x = sc.nextInt();\n		sout(x);	\n	} while(x!=0);\n}','1 2 followed by an exception','General',1,NULL),(2240,'Glob rules',' When the syntax is \"glob\" then the String representation of the path is matched using a limited pattern language that resembles regular expressions but with a simpler syntax. For example:\n\n    *.java 	Matches a path that represents a file name ending in .java\n    *.* 	Matches file names containing a dot\n    *.{java,class} 	Matches file names ending with .java or .class\n    foo.? 	Matches file names starting with foo. and a single character extension\n    /home/*/* 	Matches /home/gus/data on UNIX platforms\n    /home/** 	Matches /home/gus and /home/gus/data on UNIX platforms\n    C:\\\\* 	Matches C:\\foo and C:\\bar on the Windows platform (note that the backslash is escaped; as a string literal in the Java Language the pattern would be \"C:\\\\\\\\*\")\n\nThe following rules are used to interpret glob patterns:\n\n    The * character matches zero or more characters of a name component without crossing directory boundaries.\n\n    The ** characters matches zero or more characters crossing directory boundaries.\n\n    The ? character matches exactly one character of a name component.\n\n    The backslash character (\\) is used to escape characters that would otherwise be interpreted as special characters. The expression \\\\ matches a single backslash and \"\\{\" matches a left brace for example.\n\n    The [ ] characters are a bracket expression that match a single character of a name component out of a set of characters. For example, [abc] matches \"a\", \"b\", or \"c\". The hyphen (-) may be used to specify a range so [a-z] specifies a range that matches from \"a\" to \"z\" (inclusive). These forms can be mixed so [abce-g] matches \"a\", \"b\", \"c\", \"e\", \"f\" or \"g\". If the character after the [ is a ! then it is used for negation so [!a-c] matches any character except \"a\", \"b\", or \"c\".\n\n    Within a bracket expression the *, ? and \\ characters match themselves. The (-) character matches itself if it is the first character within the brackets, or the first character after the ! if negating.\n\n    The { } characters are a group of subpatterns, where the group matches if any subpattern in the group matches. The \",\" character is used to separate the subpatterns. Groups cannot be nested.\n\n    Leading period/dot characters in file name are treated as regular characters in match operations. For example, the \"*\" glob pattern matches file name \".login\". The Files.isHidden(java.nio.file.Path) method may be used to test whether a file is considered hidden.\n\n    All other characters match themselves in an implementation dependent manner. This includes characters representing any name-separators.\n\n    The matching of root components is highly implementation-dependent and is not specified.\n\nWhen the syntax is \"regex\" then the pattern component is a regular expression as defined by the Pattern class.\n\nFor both the glob and regex syntaxes, the matching details, such as whether the matching is case sensitive, are implementation-dependent and therefore not specified.','Strings',1,NULL),(2241,'public class Hello {\n    public static void main(String[] args) {\n        PathMatcher matcher = FileSystems.getDefault().getPathMatcher(\"*\");\n        Path p1 = Paths.get(\"One.java\");\n        \n        System.out.println(matcher.matches(p1));\n\n    }\n\n}','Exception in thread \"main\" java.lang.IllegalArgumentException\n\ngetPathMatcher() argument must take the form:\n\n	syntax:pattern\n\nspecify glob or regex ','Strings',1,NULL),(2242,'public class Hello {\n    public static void main(String[] args) {\n        PathMatcher matcher = FileSystems.getDefault().getPathMatcher(\"glob: *\");\n        Path p1 = Paths.get(\"One.java\");\n        \n        System.out.println(matcher.matches(p1));\n\n    }\n\n}','false, \nthe space after \'glob:\' matters. \n\nto give expected behavior take that space away.','Strings',1,NULL),(2243,'public class Hello {\n    public static void main(String[] args) {\n        PathMatcher matcher = FileSystems.getDefault().getPathMatcher(\"glob:*\");\n        Path p1 = Paths.get(\"One.java\");\n        \n        System.out.println(matcher.matches(p1));\n\n    }\n\n}','true,\n\nin glob * means any string inside directory bounds','Strings',1,NULL),(2244,'public class Hello {\n    public static void main(String[] args) {\n        PathMatcher matcher = FileSystems.getDefault().getPathMatcher(\"glob:\");\n        Path p1 = Paths.get(\"One.java\");\n        Path p2 = Paths.get(\"/home/Files/two.txt\");\n        Path p3 = Paths.get(\"/home/Pictures/amy1.pic\");\n        \n        System.out.println(matcher.matches(p1));\n        System.out.println(matcher.matches(p2));\n        System.out.println(matcher.matches(p3));\n\n    }\n\n}\ncreate a glob to match each of these paths','p1 could be:\n\"glob:*\" \"glob:**\" \"glob:*.{java,class}\" \"glob:One.????\"\n\n ','Strings',1,NULL),(2245,'public class Hello {\n    public static void main(String[] args) {\n        PathMatcher matcher = FileSystems.getDefault().getPathMatcher(\"glob:*{*txt,*pic,/dir}\");\n        Path p1 = Paths.get(\"files.*txt\");\n        Path p2 = Paths.get(\"pictures.*pic\");\n        Path p3 = Paths.get(\"home/dir\");\n        \n        System.out.println(matcher.matches(p1));\n        System.out.println(matcher.matches(p2));\n        System.out.println(matcher.matches(p3));\n    }\n\n}','true\ntrue\ntrue\n\nin a bracketed expression * ? and / match themselves\n\n* matches anything within a directory boundary','Strings',1,NULL),(2246,'public class Hello {\n    public static void main(String[] args) {\n        PathMatcher matcher = FileSystems.getDefault().getPathMatcher(\"glob:*{*txt,*pic,/dir}\");\n        Path p1 = Paths.get(\"home/files.*txt\");\n        Path p2 = Paths.get(\"documents/pictures.*pic\");\n        Path p3 = Paths.get(\"home/dir\");\n        \n        System.out.println(matcher.matches(p1));\n        System.out.println(matcher.matches(p2));\n        System.out.println(matcher.matches(p3));\n    }\n\n}','false \nfalse\ntrue\n\n* doesn\'t work accross directory bounds ','Strings',1,NULL),(2247,'public class Hello {\n    public static void main(String[] args) {\n        PathMatcher matcher = FileSystems.getPathMatcher(\"glob:*{*txt,*pic,/dir}\");\n        Path p1 = Paths.get(\"home/files.*txt\");\n        Path p2 = Paths.get(\"documents/pictures.*pic\");\n        Path p3 = Paths.get(\"home/dir\");\n        \n        System.out.println(matcher.matches(p1));\n        System.out.println(matcher.matches(p2));\n        System.out.println(matcher.matches(p3));\n    }\n\n}','will not compile the proper syntax is:\n\n	FileSystems.getDefault().getPathMatcher()','Strings',1,NULL),(2248,'public class Hello {\n    public static void main(String[] args) {\n        PathMatcher matcher = FileSystems.getDefault().getPathMatcher(\"regex:.*\");\n        Path p1 = Paths.get(\"home/files.*txt\");\n        Path p2 = Paths.get(\"documents/pictures.*pic\");\n        Path p3 = Paths.get(\"home/dir\");\n        \n        System.out.println(matcher.matches(p1));\n        System.out.println(matcher.matches(p2));\n        System.out.println(matcher.matches(p3));\n    }\n\n}','you can also do this to use regex instead of glob.\n\nhere they would all say \'true\'','Strings',1,NULL),(2249,'public class Hello {\n	private int size = 7;\n	private static int length = 3;\n	public static void main(String[] args) {\n		new Hello().go();\n	}\n	void go(){\n		int size = 5;\n                 System.out.println(new Gazer().adder());\n                 \n                 class Gazer {\n                     private int size = 6;\n                      int adder() { return size * length; }\n                }\n	}\n	\n}','will not compile, \n\nGazer is declared after it is used in a method,thats not allowed move it to before','Strings',1,NULL),(2250,'public class Hello {\n	private int size = 7;\n	private static int length = 3;\n	public static void main(String[] args) {\n		new Hello().go();\n	}\n	void go(){\n		int size = 5;\n                class Gazer {\n                      int adder() { return size * length; }\n                }\n                 System.out.println(new Gazer().adder());\n	}\n}','WNC,  \n\nlocal variable size is accessed from within inner class needs to be final,\n\n\n	','Strings',1,NULL),(2251,'public class Hello {\n	private int size = 7;\n	private static int length = 3;\n	public static void main(String[] args) {\n		new Hello().go();\n	}\n	void go(){\n                class Gazer {\n                      int adder() { return size * length; }\n                }\n                 System.out.println(new Gazer().adder());\n	}\n}','21\n\nnothing wrong here, instances can access statics just not the other way around!','Inner Classes',1,NULL),(2252,'public class Hello<T> {\n    \n    public static void main(String[] args){\n        \n        Dog d = new Dog();\n        \n        ArrayList<?> c = makeArrayList(new Animal());\n        \n\n    } \n    public static <G super Dog> ArrayList<G> makeArrayList(G g){\n        ArrayList<G> genlist = new ArrayList<>();\n        genlist.add(g);\n        return genlist;\n        \n    }\n}\n\nclass Animal{}\nclass Dog extends Animal{}','WNC\n\nsuper to bound a named type parameter (e.g. <S super T>) as opposed to a wildcard (e.g. <? super T>) is ILLEGAL simply because even if it\'s allowed, it wouldn\'t do what you\'d hoped it would do, because since Object is the ultimate super of all reference types, and everything is an Object, in effect there is no bound.\n\nIn your specific example, since any array of reference type is an Object[] (by Java array covariance), it can therefore be used as an argument to <S super T> S[] toArray(S[] a) (if such bound is legal) at compile-time, and it wouldn\'t prevent ArrayStoreException at run-time.\n\nWhat you\'re trying to propose is that given:\n\nList<Integer> integerList;\n\nand given this hypothetical super bound on toArray:\n\n<S super T> S[] toArray(S[] a) // hypothetical! currently illegal in Java\n\nthe compiler should only allow the following to compile:\n\nintegerList.toArray(new Integer[0]) // works fine!\nintegerList.toArray(new Number[0])  // works fine!\nintegerList.toArray(new Object[0])  // works fine!\n\nand no other array type arguments (since Integer only has those 3 types as super). That is, you\'re trying to prevent this from compiling:\n\nintegerList.toArray(new String[0])  // trying to prevent this from compiling\n\nbecause, by your argument, String is not a super of Integer. However, Object is a super of Integer, and a String[] is an Object[], so the compiler still would let the above compile, even if hypothetically you can do <S super T>!\n\nSo the following would still compile (just as the way they are right now), and ArrayStoreException at run-time could not be prevented by any compile-time checking using generic type bounds:\n\nintegerList.toArray(new String[0])  // compiles fine!\n// throws ArrayStoreException at run-time\n\nGenerics and arrays don\'t mix, and this is one of the many places where it shows.\nA non-array example\n\nAgain, let\'s say that you have this generic method declaration:\n\n<T super Integer> void add(T number) // hypothetical! currently illegal in Java\n\nAnd you have these variable declarations:\n\nInteger anInteger\nNumber aNumber\nObject anObject\nString aString\n\nYour intention with <T super Integer> (if it\'s legal) is that it should allow add(anInteger), and add(aNumber), and of course add(anObject), but NOT add(aString). Well, String is an Object, so add(aString) would still compile anyway.','Generics',1,NULL),(2253,'package xcom;\npublic class Stuff{\n	public static int MY_COSTANT = 5;\n	public static int dosStuff(int x) { return (x++)*x; }\n}\n\nimport static xcom.Stuff;\nimport static java.lang.System;\nclass User {\n	public static void mian(SA){\n		new User().go()\n	}\n	void go(){\n			out.println(doStuff(MY_CONSTANT);\n	}\n}','will not compile to import a static member an import sattemten must say \nimport static wiht either a wildcard or excplicity the member to be imported','General',1,NULL),(2254,'public class Hello {\n    \n    public static void main(String[] args){\n        Path file = Paths.get(\"~/Public/Data\");\n        FileSearcher fs = new FileSearcher(file,\"\\\\b\\\\W\\\\w+\");\n        ExecutorService es = Executors.newCachedThreadPool();\n        HashMap<Integer,String> searchresults = es.submit(fs);\n        System.out.println(\"We\'re wating on your search results\");\n        Future<HashMap<Integer,String>> futuresearch;\n        \n        try{\n            //HashMap<Integer,String> searchresults = futuresearch.get();\n            searchresults = futuresearch.get();\n            if(searchresults == null){\n                System.out.println(\"There were no results bro\");\n                System.exit(0);\n            }\n            \n        }catch(ExecutionException | InterruptedException e){\n            \n        }\n    }\n}\n\nclass FileSearcher implements Callable<HashMap<Integer,String>> {\n    private Path fileToLoad;\n    private String regex;\n    public FileSearcher(Path file,String reg){\n        fileToLoad = file;\n        regex = reg;\n    }\n    \n    public HashMap<Integer,String> call() throws IOException{\n        int linenum = 0;\n        HashMap<Integer,String> map = new HashMap<>();\n        BufferedReader br = new BufferedReader(new FileReader(fileToLoad.toFile()));\n        Pattern p = Pattern.compile(regex);\n        Matcher m;\n        String line;\n        while((line = br.readLine()) != null){\n            map.put(++linenum,line);\n        }\n        return map;\n    }\n}','WNC,\n\nsubmitting a Callable to an ExecutorService gets you a Future of the type \nreturned by the call(), then you get that result from the future with \nget() wich can block.','Executors',1,NULL),(2255,'class Nearly {\n	String value;\n	public Nearly(String v) { value = v; }\n	public int hashCode() { return 1; }\n	public boolean equals(Nearly n){\n		if(value.charAt(0) == n.value.charAt(0)) return true;\n		return false;\n	}\n	psvm(sa){	\n		Nearly n1 = new Nearly(\"aaa\");\n		Nearly n2 = new Nearly(\"aaa\");\n		String s = \"-\";\n		if(n1.equals(n2)) s += \"1\";\n		if(n1 == n2) s += \"2\";\n		Set<Nearly> set = new HashSet<Nearly>();\n		set.add(n1);	\n		set.add(n2);\n		sout( s + set.size() );\n	}\n}','-12\n\nNearly does not properly override equals(Object o).\n\nSo by nearly\'s wrongly implemented equals() they are equal so you get -1\n\nbut Set knows the true equals to use and here it cant find it so it uses\nthe default equal which states that all objects are different and allows in\ntwo identicle objects. ','OOP',1,NULL),(2256,'x = 0;\nif(x1.hashCode() != x2.hashCode() ) x = x +1;\nif(x3.equals(x4) == false) x = x + 10;\nif(x5.equals(x6) == true) x = x + 100;\nif(x7.hashCode() == x8.hashCode() ) x = x + 1000;\nsout( \"x = \" + x);\n\nif the output is x = 1111 what has to always be true ?\n\nx2.equals(x1) == true\nx3.hashCode() != x4.hashCode()\nx5.hashCode() == x6.hashCode()\nx8.equals(x7) == true','x5.hashCode() == x6.hashCode()\n\nif the hashcode values are not equal the two objects must not be equal\n\nif equals() is not true there is not guarentee of results from hashcode\n\nhashcode will often return equals values even if the two objects are not equal','OOP',1,NULL),(2257,'if the hashcode values are not equal the two objects must not be equal','got it','OOP',1,NULL),(2258,'import static statements must import explicitly the members ','','OOP',1,NULL),(2259,'class Sortof {\n	String name;\n	int bal;\n	String code;\n	short rate;\n	public int hashCode() {\n		return (code.length() * bal);\n	}\n	public boolean equals(Object o){\n		//insert here\n	}\n}\n\nhow can you fullfill the equals and hashcode contracts for this class ?\n','return ((Sortof)o).code.length * ((Sortof)o).bal == this.code.length * this.bal;\n\nreturn ((Sortof)o).code.length * ((Sortof)o).bal * ((Sortof)o).rate == this.code.length * this.bal * this.rate;\n\n\nthe equals algorithm must be at least as precise as hashcode at determining\nwhat is \"meaningfully equivalent\" ','OOP',1,NULL),(2260,'public class Hello{\n    public static void main(String[] args){\n        Bango b1 = new Bango();\n        Bango b2 = new Bongo();\n        Bango b3 = new Bingo();\n        \n        Bongo b4 = b2;\n        Bongo b5 = (Bongo)b2;\n        Bango b6 = b3;\n        Bango b7 = (Bango) b3;\n        Bingo b8 = b3;\n        Bingo b9 = (Bingo) b3;\n        Bango b10 = (Bongo) b3;\n    \n    }\n}\n\nclass Bango { }\nclass Bongo extends Bango { }\nclass Bingo extends Bongo { }\n\nwhich wont compile ? ','b4 and b8','OOP',1,NULL),(2261,'class Clojure extends FP {\n	boolean typed;\n	public static void main(String[] args){\n		Clojure c = new Clojure();\n		c.monad();\n	}\n	void mondad() {\n		sout(\"foo\");\n	}\n}\n\nclass FP {\n	String name = \"basic\";\n	protected FP(String s){ name = s; }\n}','WILL NOT COMPILE','OOP',1,NULL),(2262,'class AlternateFuel {\n	int getRating() { return 42; }\n	static int getRating2() { return 43; }\n}\nclass Bio extends AlternateFuel {\n	psvm(){\n		new Bio().go();\n		sout( super.getRating2() );\n	}\n	void go() {\n		sout( super.getRating() );\n	}\n}','Will not compile only instance methods can be overriden and calls to super \nare only for obverridne methods. ','OOP',1,NULL),(2263,'class Alpha { int over = 1; }\nclass Beta extends Alpha { int over = 2; }\nclass Gamma extends Beta {\n	int over = 3;\n	public static void main(SA){\n		new Gamma().go();\n	}\n\n	void go() {	\n		Beta b = new Gamma();\n		Alpha a = new Gamma();\n		sout( super.over+\" \"+b.over+\" \"+a.over );\n	}\n}','2 2 1\n\ninstance variables are not overriden, the variable used is related to \nthe reference type. \n\nsuper can be used to access super class instance variables','OOP',1,NULL),(2264,'class Programmer {\n	Programmer debug(){ return this; }\n}\n\nclass SCJP extends Programmer {\n	//insert here\n}\n\nProgrammer debug() { return this; }\nSCJP debug() { return this; }\n\nint debug(int x) { return 1; }\nObject debug(String s){ return this; }','two legal overrides, one a covariant return\n\ntwo legal overloads ','OOP',1,NULL),(2265,'class Programmer {\n	Programmer debug(){ return this; }\n}\n\nclass SCJP extends Programmer {\n	Object debug(String s){ return this; }\n}\n\n','legal overload','OOP',1,NULL),(2266,'public class Hello{\n    public static void main(String[] args){\n        Short s = null;\n        \n        boolean b = (s instanceof String);\n    \n    }\n}','WNC, they have to be in the same inheritance tree','OOP',1,NULL),(2267,'Class Dog follows the equals and hashcode contract, x and y are reference variable\nto two Dog objects which are true?\n\nif x.equals(y) is true then x.hashCode() == y.hashCode() may be false\n','false\n\nif two objects are equal, their hashCodes must be equal\n\nif two objects are not equal, their hashCodes must not be equal. ','OOP',1,NULL),(2268,'join() throws InterruptedException','got it','Threads',1,NULL),(2269,'public class Hello{\n    public static void main(String[] args){\n        Pattern p = Pattern.compile(\"\\\\W\");\n        Matcher m = p.matcher(\"565757 43353535\");\n        \n        while(m.find()){\n            System.out.println(m.start());\n        }\n        \n    }\n}','6','Strings',1,NULL),(2270,'YOU CANT USE SUPER WHEN DEFINING A GENERIC CLASS','got it','Generics',1,NULL),(2271,'class E implements Closeable { public void close() throws Exception {}}','WNC close() throws IOEXception, cannot throw new or broader checked exceptions','Collections',1,NULL),(2272,'What methods are defined in the thread class ?','start() and run()','Threads',1,NULL),(2273,'Both wait() and notify() must be called from a synchronized context\n\nthe wait() method is overloaded to accept a duration','got it','Threads',1,NULL),(2274,'if a class has synchronized code multiple threads can still access the unsynchronized\ncode\n\nwhen a thread invokes wait() it releases its locks','got it','Threads',1,NULL),(2275,'class Widget { }\nclass WidgetMaker extends Thread {\n    List<Widget> finishedWidget = new ArrayList<Widget>();\n    public void run(){\n        try{\n            while(true){\n                Thread.sleep(2000);\n                Widget w = new Widget();\n                \n                //insert something\n                \n            }\n        } catch(InterruptedException e){ }\n    }\n    \n    public Widget waitForWidget() {\n        synchronized(finishedWidget) {\n            if(finishedWidget.size() == 0){\n                try{\n                    finishedWidget.wait();\n                } catch(InterruptedException e){ }\n            }\n            return finishedWidget.remove(0);\n        }\n    }\n}\n\npublic class Hello extends Thread{\n    private WidgetMaker maker;\n    public Hello(String name, WidgetMaker me){\n        super(name);\n        this.maker = me;\n    }\n    \n    public void run(){\n        Widget w = maker.waitForWidget();\n        System.out.println(getName() + \"got a widget\");\n    }\n   \n    public static void main(String[] args) {\n       WidgetMaker maker = new WidgetMaker();\n       maker.start();\n       new Hello(\"lenny\",maker).start();\n       new Hello(\"Moe\",maker).start();\n       new Hello(\"Ben\",maker).start();\n    }\n}\n\nif each user should get its own widget which no other user is using what should\nyuou put in //insert here ? \n\nsynchronized(finishedWidget){\n	finshedWidget.add(w);\n	finishedWidget.notify();\n}\n\nor \n\nsynchronized(finishedWidget){\n	finshedWidget.add(w);\n	finishedWidget.notifyAll();\n}','notifyAll() would be a mistake since only one waiting thread can have \na widget. \n\nnotify() is better \n\nif they are all notified only one would get the new widget but the others \nwould probably throw an exception since they try to get a widgeth without\ndouble checking if one is available','Threads',1,NULL),(2276,'public class Hello extends Thread{\n    private String name;\n    public Hello(String name){ this.name = name; }\n    public void write() {\n        System.out.println(name);\n        System.out.println(name);\n    }\n    public static void main(String[] args) {\n        new Hello(\"X\").start();\n        new Hello(\"Y\").start(); \n    }\n}\n\nyou want to guarentee that output is XXYY or YYXX how can you do this ?\n\n\npublic synchronized void run() { write(); }\npublic void run(){ synchronized(this){ write(); } }','NO, \nThese two run() method lock onto an instance of Hello but there are two \ndifferent instances so that wont prevent thme from running at the same time.\n\nyou can do...\n\n	public void run(){ synchronized(Letters.class){write();} }\n	\n	or\n	\n	public void run(){ synchronized(System.out){ write(); } }\n\nnow they wont run at the same time as they go for the same locks','Threads',1,NULL),(2277,'class Calculator {\n    private AtomicInteger i = new AtomicInteger();\n    public void add(int val){\n        int old = i.get();\n        int newval = old + val;\n        System.out.println(i.compareAndSet(old,newval));   //LINE A\n    }\n    public int getValue() {\n        return i.get();\n    }\n}','This class is thread safe \n\nline a would always print true if a lock were used befor int old','Concurrency',1,NULL),(2278,'public class Hello {\n    ExecutorService service = Executors.newFixedThreadPool(8);\n    \n        public void runAsynchronously(Asynchronous object){\n            Future<?> result = service.submit(object);\n        }\n        \n }\n\nwhat is a valid declaration of Asynchronous ?\n','class Asynchronous implements Runnable\nclass Asynchronous implements Callable<String>\n\nif the object sent to submit is a Runnable, the submit method will return\nan instance of Future whos get method will return null\n\notherwise Futures get method will return a type of the Type of class of Callable','Concurrency',1,NULL),(2279,'ExecutorService method:\n\nsubmit\n\nFuture<?> submit(Runnable task)\n\nSubmits a Runnable task for execution and returns a Future representing that task. \nThe Future\'s get method will return null upon successful completion.','got it','Concurrency',1,NULL),(2280,'public class Hello {\n\n    private static ExecutorService service = Executors.newFixedThreadPool(8);\n\n    public static void runAsynchronously(Asynchronous object) {\n        Future<?> result = service.submit(object);\n        try{\n            System.out.println(result.get());\n        } catch(InterruptedException | ExecutionException e){ }\n    }\n\n    public static void main(String[] args) {\n        runAsynchronously(new Asynchronous());\n    }\n\n}\n\nclass Asynchronous implements Runnable {\n\n    public void run() {\n        System.out.println(\"executing a runnable\");\n    }\n}','executing a runnable\nnull','Concurrency',1,NULL),(2281,'public class Hello {\n    private Lock lock = new ReentrantLock();\n    private int value = 0;\n    public void increment(){\n        lock.lock();\n        value++;\n        lock.unlock();\n    }\n    public void decrement(){\n        lock.lock();\n        value--;\n        lock.unlock();\n    }\n    public int getValue(){\n        return value;\n    }\n    public static void main(String[] args){\n        \n    }    \n}\n\nis this class thread safe ?','yes,\n\nyou could also use Atomic integer with getAndIncrement and getAndDecrement\ninstead of value and the lock ','Concurrency',1,NULL),(2282,'public static void main(SA) { \n	int[] myData = new int[10000000];\n	ForkJoin fj = new ForkJoin();\n\n	MyRecursiveInitClass action = new MyRecursiveInitClass(x,y,mydata);\n\n	fj.submit(action);\n\n	doStuff(myData);\n}\n\n','WNC fj should be a ForkJoinPool and use ivoke instead of submit','Concurrency',1,NULL),(2283,'A ForkJoinPool implements Executor and ExecutorService\n\nextends AbstractExecutorService','true got it','Concurrency',1,NULL),(2284,'ForkJoinPool is a ExecutorService\n\nthe implementation of the compute() in ForkJoinTask the fork method should \nalways be be called before the join() or the invokeAll()\n\ninvoke() from class ForkJoinPool only accpts as parameters istances of \nForkJoinTask \n\nif the algorithim does not have to return a value you should extends RecursiveAction\nnot RecursiveTask\n\nForkJoinPool is a ExecutorService so it can be usd to process a Callable\nvia the submit method.','got it','Concurrency',1,NULL),(2285,'public class ConcurrentModification {\nList<Integer> list = new CopyOnWriteArrayList<>();\n\npublic void work(){\n	Iterator<Integer> iter = list.iterator();\n	while(it.hasNext()){\n		it.next();\n		list.add(100);\n	}\n	sout( list.size() );\n	}\n}','200 is printed this does not throw a ConcurrentModificationException because\na CopyOnWriteArrayList allows modifications while being iterated.\n\n\n\n','Concurrency',1,NULL),(2286,'public class Hello implements Runnable {\n    private static ArrayBlockingQueue<Integer> abq = new ArrayBlockingQueue<>(10);\n    public static void main(String[] args){\n       Hello h = new Hello();\n       Thread t1 = new Thread(h);\n       Thread t2 = new Thread(h);\n       Thread t3 = new Thread(h);\n       Thread t4 = new Thread(h);\n       \n       t1.start();\n       t2.start();\n       t3.start();\n       t4.start();\n       \n    }\n    public void run(){\n        for(int i = 0; i<5; i++){\n            System.out.println(Thread.currentThread().getName()+\"removed element: \"+abq.peek());\n        }\n        \n    }\n}','Thread-1removed element: null\nThread-1removed element: null\nThread-1removed element: null\nThread-1removed element: null\nThread-1removed element: null\nThread-0removed element: null\nThread-0removed element: null\nThread-0removed element: null\nThread-0removed element: null\nThread-0removed element: null\nThread-2removed element: null\nThread-3removed element: null\nThread-2removed element: null\nThread-3removed element: null\nThread-2removed element: null\nThread-3removed element: null\nThread-2removed element: null\nThread-3removed element: null\nThread-2removed element: null\nThread-3removed element: null\n\npeek() returns null if empty','Concurrency',1,NULL),(2287,'ArrayBlockingQueue\n\n\npeek() returns null if empty','got it ','Concurrency',1,NULL),(2288,'peek() and poll() in interface Queue return null if empty','got it ','General',1,NULL),(2289,'public class Hello {\n    enum A { A };\n    public static void main(String[] args) {\n        enum B{ B };\n    }\n}\nenum C{ C }','WNC enum types must not be local','General',1,NULL),(2290,'enums cant be local to a method ','\n\nEnums are static nested classes because they define static member variables \n(the enum values), and this is disallowed for inner classes: \nhttp://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.1.3\n\nUpdate: I was looking through the JLS (java language specification) for\n more detail on the restrictions of static nested classes, and didn\'t find \nit (although it\'s probably there, hidden under a different topic). From a \npure implementation perspective, there\'s no reason that this couldn\'t be \ndone. \n\nAs a comment: if your methods are large enough that they require their own \nenums, then it\'s a strong sign that you need refactoring.\n','General',1,NULL),(2291,'public class Hello extends Flipper {\n    public static void main(String[] args) {\n        \n    }\n    public void flip(){System.out.println(\"hello\");}\n}\nclass Flipper {\n    public final void flip() { System.out.println(\"flip\"); }\n}','WNC cannot override final methods','General',1,NULL),(2292,'public class Hello{\n    static String s = \"-\";\n    \n    public static void main(String[] args) {\n        go();\n        System.out.println(s);\n    }\n    { go(); }\n    static { go(); }\n    static void go(){ s+=\"s\"; }\n}','-ss','OOP',1,NULL),(2293,'public class Hello{\n    \n    public static void main(String[] args) {\n       Bigger.Faster bf = Bigger.Faster.HIGHER;\n    }\n   \n}\nclass Bigger {\n    enum Faster { HIGHER,  LONGER };\n}','compiles fine how to use an enum','General',1,NULL),(2294,'public class Hello{\n    \n    public static void main(String[] args) {\n        System.out.println(Bulbs.ON);\n    }\n   \n}\nenum Bulbs{ ON(\"Bright\"), OFF(\"Dim\") };','WNC,\n\nthe constants are declared with String constructors so the default constructor\nwont do. ','General',1,NULL),(2295,'public class Hello{\n    \n    public static void main(String[] args) {\n        System.out.println(Bulbs.ON);\n    }\n   \n}\nenum Bulbs{ \n    ON(\"Bright\"), OFF(\"Dim\");\n    \n    String name;\n\n    Bulbs(String x){ name = x; }\n};','how to contruct a string argumnet enum constant','General',1,NULL),(2296,'public class Hello{\n    \n    public static void main(String[] args) {\n        System.out.println(Bulbs.ON);\n    }\n   \n}\nenum Bulbs{ \n    ON(\"Bright\"), OFF(\"Dim\");\n    \n    String name;\n\n    public Bulbs(String x){ name = x; }\n};','WNC enum constructos cannot be public or protected.\n\nThe constructor for an enum type must be package-private or private access.\'\n It automatically creates the constants that are defined at the beginning \nof the enum body. You cannot invoke an enum constructor yourself. \n\nThink of Enums as a class with a finite number of instances. \nThere can never be any different instances beside the ones you initially\n declare.\n\nThus, you cannot have a public or protected constructor, because that would\n allow more instances to be created.','General',1,NULL),(2297,'public class Hello extends B{\n    void m1() { System.out.println(\"c-m1\"); }\n    void m2() { }\n    \n    public static void main(String[] args) {\n        new Hello().go();\n        new Hello().m1();\n        new Hello().m2();\n    }\n    \n    void go(){ super.m1(); }\n    Hello(){ System.out.println(\"C \"); }\n}\nabstract class B {\n    void m1() { System.out.println(\"b-m1\");}\n    abstract void m2();\n    B() { System.out.println(\"B \");}\n    \n}','B \nC \nb-m1\nB \nC \nc-m1\nB \nC \n\nabstract classes can have constructors, when a subclass constructor is called\nit calls its super first.\n\n','General',1,NULL),(2298,'class Top {\n    { System.out.println(\"A\"); }\n    public Top(){ System.out.println(\"B\"); }\n    public Top(String s){ System.out.println(\"C\"); }\n}\n\nclass Middle extends Top {\n    {System.out.println(\"D\");}\n    public Middle(){ System.out.println(\"E\"); }\n    public Middle(String z){System.out.println(\"F\"); }\n}\npublic class Hello extends Middle{\n   {System.out.println(\"G\");}\n   public Hello(){ System.out.println(\"H\");}\n   public Hello(String x){ System.out.println(\"Z\");}\n    public static void main(String[] args) {\n      new Hello();\n    }\n}','A\nB\nD\nE\nG\nH','OOP',1,NULL),(2299,'DateFormat f3 = DateFormat.getDateInstance(DateFormat.SHORT);\nDateFormat f4 = DateFormat.getDateInstance(DateFormat.SHORT);\n\nif f3 == f4 always returns true, DateFormat is a factory\nif f3 == f4 always returns false, DateFormat is a factory','You can tell that DateFormat is not a singleton because it takes a parameter\n','OOP',1,NULL),(2300,'A factory can have a public constructor\n\na factory can reate a new object each time you call it ','','OOP',1,NULL),(2301,'overriding requires the use of IS A relationship','','OOP',1,NULL),(2302,'IS A relationships always rely on inheritance\n\nIS A relationships always require at least two class types\n\nPolymorphism always relies on IS A relationships','','OOP',1,NULL),(2303,'BioDiesel b4 = new BioDiesel(new Viscosity());','tight coupling','OOP',1,NULL),(2304,'DAO implementation must implements an interface,\n\nincreases cohesion by seperating data access code from the object representing\nthe data','Got it','OOP',1,NULL),(2305,'what is this an example of:\n\ninterface B { void c(); }\n\nclass A implements B {\n	private B;\n\n	public A(B b){ this.b = b; }\n\n	public void c(){ b.c(); }\n\n	public void d(){ }\n}','object composition, method delegation','OOP',1,NULL),(2306,'public class Stadium { \n	private static final Stadium i = new Stadium();\n	public static Stadium newStadium() {\n		return i;\n	}\n	private Stadium() { }\n}','singleton\nthough not good with the nameing convention, should be getInstance()','OOP',1,NULL),(2307,'interface Box{\n    void pack();\n    void seal();\n}\n\ninterface Mailer {\n    void addPostage();\n    void ship();\n}\n\nclass GiftBox implements Box{\n    public void pack(){ }\n    public void seal() { }\n}\n\nclass MailerBox implements Box,Mailer {\n    private Box box;\n    public MailerBox(Box box){\n        this.box = box;\n    }\n    public void pack(){ box.pack(); }\n    public void seal(){ box.seal(); }\n    public void addPostage(){\n        System.out.println(\"post\");\n    }\n    public void ship(){\n        System.out.println(\"Put in a box\");\n    }\n}','object composition','OOP',1,NULL),(2308,'public interface BookDao {\n	Collection<Book> findAllBooks();\n	Book findBookByIsbn(Book book);\n	void create(Book book);	\n	void delet(Book book);\n	void update(Book book);\n}\n\npublic class inMemoryDao implements BookDao { }\n\n','Daos should immplement an interface so that is is easy to swap out database\nimplementations','OOP',1,NULL),(2309,'loose coupling is desirable, classes are well encapulated minimize reference\nto each other and limit the breadth of API use','got it ','OOP',1,NULL),(2310,'Object compositoin takes advantage of ISA HASA and polymorphism','got it','OOP',1,NULL),(2311,'a Factory creates any subclass of an interface or abstract class\nFactoy is an abstract class\nThe Factory method return type is an interface or abstract class\nreturns subclasses of the target subect','got it ','OOP',1,NULL),(2312,'You want the factory class to be an abstract class so that\nyou can implement some concrete code if necesarry. ','','OOP',1,NULL),(2313,'class A() { }\n\nabstract class G {\n	A m() { return n(); }\n	abstract A n();\n}\n\nwhich design pattern ?','Factory, A is the object we are creating and G is the abstract super class\nfor the factory what is not shown is the subclass that impleents the factory. ','OOP',1,NULL),(2314,'class Hello{\n    public static void main(String[] args) {\n        Queue<String> x = new PriorityQueue<>();\n        x.add(\"one\");\n        x.add(\"two\");\n        x.add(\"thread\");\n        System.out.println(x.poll());\n    }\n}','one, \n\nQueue\n\nQueue is a ordered collection of items.\n\nItems are deleted at one end called ‘front’ end of the queue.\n\nItems are inserted at other end called ‘rear’ of the queue.\n\nThe first item inserted is the first to be removed (FIFO).\n\nStack\n\nStack is a collection of items.\n\nIt allows access to only one data item: the last item inserted.\n\nItems are inserted & deleted at one end called ‘Top of the stack’.\n\nIt is a dynamic & constantly changing object.\n\nAll the data items are put on top of the stack and taken off the top\n\nThis structure of accessing is known as Last in First out structure (LIFO)','Generics',1,NULL),(2315,'class Hello{\n    public static void main(String[] args) {\n        TreeSet<String> x = new TreeSet<>();\n        x.add(\"one\");\n        x.add(\"two\");\n        x.add(\"thread\");\n        System.out.println(x.poll());\n    }\n}','WNC, TreeSet does not implement Queue so it does not have poll()','Collections',1,NULL),(2316,'class A {   \n      private void methodA() {System.out.println(\"Hello, I am A!\");}   \n      public static void main(String[] args) {   \n        A a = new A();   \n        a.methodA(); }   \n} ','A private member can be access via a reference variable from within the object\nthat private was declared.  \n\nMethods, Variables and Constructors that are declared private can only be \naccessed within the declared class itself.\n\n','General',1,NULL),(2317,'class Hello{\n    private Set<Integer> numbers = new TreeSet<Integer>();\n    public Hello(int...nums){\n        for(int n: nums){\n            numbers.add(n);\n        }\n    }\n    public Hello negate(){\n        Hello negatives = new Hello();\n        for(int n : numbers){\n            negatives.numbers.add(-n);\n        }\n        return negatives;\n    }\n    public void show(){\n        for(int n : numbers){\n            System.out.println(n+\" \");\n        }\n    }\n    public static void main(String[] args) {\n        new Hello(1,3,-5).negate().show();\n    }\n}','-3 -1 5\n\nit doesnt matter what order the numbers are added to the set, it is a treeset\n\nthe negate() creates a new set withc negated values they are then put into \nincreasing order','General',1,NULL),(2318,'public static void main(String[] args) {\n        \n        Comparator<Integer> cmp = new Comparator<Integer>() {\n            public int compare(Integer n1, Integer n2){\n                return n2.compareTo(n1);\n            }\n        };\n        \n        PriorityQueue pq = new PriorityQueue<Integer>(100,cmp);\n        pq.addAll(Arrays.asList(16,8,42,15,4,23));\n        System.out.println(pq.poll());\n}','42,\n\n100 is the initial capacity.\n\nThis sorts in reverse order. ','Collections',1,NULL),(2319,'public static void main(String[] args) {\n        Map<Integer,String> lat = new HashMap<>();\n        lat.put(60,\"Sea\");\n        lat.put(66,\"circle\");\n        System.out.println(lat.put(62,\"island\"));\n        System.out.println(lat.put(60,\"ocean\"));\n        lat.put(65,\"island\");\n        System.out.println(lat.size() + \" \");\n        System.out.println(lat.containsValue(\"sea\") + \" \");\n}','Sea\n4 \nfalse\n\nput returns the value previously associated with the key, or null if there\nwas nothing with it previously. ','Collections',1,NULL),(2320,'public <S extends CharSequence> S foo(S s){\n	//return s;\n	//return (Object) s;\n	//return s.toString();\n	//return new StringBuilder(s);\n	//return (S) new StringBUilder(s);\n	//return null\n}\n\nwhich compile?','only return s and return null, \n\nalthough String and StringBuilder are both subtypes of charsequence they are\nnot necesarrily subtypes of whatever is passed in ','Collections',1,NULL),(2321,'TreeSet map = new TreeSet();\nmap.add(\"one\");\nmap.add(\"two\");\nmap.add(\"three\");\nmap.add(\"four\")\nmap.add(\"one\");\nIterator it = map.iterator();\nwhile(it.hasNext()){\n	sout(	it.next() + \" \" );\n}','four one three two\n\nTreeSet assures no duplicate entries, it will return elements in natrual\norder for strings thats alphebetical. ','Collections',1,NULL),(2322,'class Hello{\n   public static void main(String[] args){\n       Queue<String> q = new LinkedList<String>();\n       q.add(\"V\");\n       q.add(\"Wallace\");\n       q.add(\"Duncan\");\n       showAll(q);\n   }\n   \n   public static void showAll(Queue q) {\n       q.add(new Integer(42));\n       while(!q.isEmpty()){\n           System.out.println(q.remove()+ \" \");\n       }\n   }\n}','V \nWallace \nDuncan \n42 \n\nqueue is a FIFO \n\na compiler warning will be produced but it will still compile and run without\nexception ','Collections',1,NULL),(2323,'public static void main(String[] args){\n       TreeSet<Number> tree = new TreeSet<Number>();\n       tree.add(108);\n       //tree.add(3.14);\n       //tree.add(\"42\");\n       //tree.add(Integer.valueOf(\"-1\");\n       //tree.add(null);\n       //tree.add(new Long(123));\n       //tree.add(0XCAFE);\n       \n   }\n\nwhich will compile and run ?','only Integer.valueOf(\"-1\") and 0xCAFE\n\nThis TreeSet will allow only numbers but the numbers must be mutually comparable\nthe 108 is an integer so anything added afterward must be an integer.\n\n0xCAFE is a valid hex literal for an int. \n\n3.14 is a double. ','Collections',1,NULL),(2324,'public static void main(String[] args){\n       TreeSet<Number> tree = new TreeSet<Number>();\n       tree.add(108);\n       tree.add(3.14);\n       //tree.add(\"42\");\n       tree.add(Integer.valueOf(\"-1\"));\n       tree.add(null);\n       tree.add(new Long(123));\n       tree.add(0XCAFE);\n       \n   }','ClassCastExcepiton','Collections',1,NULL),(2325,'diamond operator cannot be used with anonymous classes','Internally, a Java compiler operates over a richer set of types than those \nthat can be written down explicitly in a Java program. The compiler-internal\n types which cannot be written in a Java program are called non-denotable\n types. Non-denotable types can occur as the result of the inference used\n by diamond. Therefore, using diamond with anonymous inner classes is not \nsupported since doing so in general would require extensions to the class \nfile signature attribute to represent non-denotable types, a de facto JVM \nchange. It is feasible that future platform versions could allow use of \ndiamond when creating an anonymous inner class as long as the inferred type \nwas denotable.','General',1,NULL),(2326,'What collection would be best to implement a stack that does not have \nthe overhead of synchronized methods ?','LinkedList\n\nallows duplicates and has methods apporopriate for pushing and popping from the\nstack addFirst() getFirst()','Collections',1,NULL),(2327,'public static void main(String[] args){\n       String[] s = { \"inch\", \"foot\", \"yard\", \"rod\", \"meter\" };\n       List list = Arrays.asList(s);\n       list.set(4,\"chain\");\n       System.out.println(s[4]);\n       s[2] = \"meter\";\n       System.out.println(\" \" + list.get(2));\n   }','chain meter','Collections',1,NULL),(2328,'public static void main(String[] args){\n       String[] s = { \"inch\", \"foot\", \"yard\", \"rod\" };\n       List list = Arrays.asList(s);\n       list.set(4,\"chain\");\n       System.out.println(s[4]);\n       s[2] = \"meter\";\n       System.out.println(\" \" + list.get(2));\n   }','ArrayIndexOutofBoundsException you are refereing to place 4 when there is \nonly 3 indexs 0-3','Collections',1,NULL),(2329,' public static void main(String[] args){\n       String[] s = { \"inch\", \"foot\", \"yard\", \"rod\", \"meter\" };\n       List list = Arrays.asList(s);\n       list.set(4,\"chain\");\n       System.out.println(s[4]);\n       s[2] = \"meter\";\n       System.out.println(\" \" + list.get(2));\n       list.add(9);\n   }','UnsupportedOerationException,\n\nwhen you use asList the list and array becomes bound at the hip. so changes\nin one refect in the other,\n\nyou can only reset indexes though you cannot make any new addition or removals\nto the list, and you cant add or remove from an array anyway.','Collections',1,NULL),(2330,'class BackLister {\n    public static <T> List<T> backwards(List<T> input)\n    {\n        List<T> output = new LinkedList<T>();\n        for(T t : input)\n            output.add(0,t);\n        return output;\n    }\n}','compiles fine. ','Collections',1,NULL),(2331,'class BackLister {\n    //insert here \n    {\n        List<T> output = new LinkedList<T>();\n        for(T t : input)\n            output.add(0,t);\n        return output;\n    }\n}\n\npublic static <T> List<T> backwards(List<T> iput)\npublic static <T> List<T> backwards(List<? extends T> input)\npublic static <? super T> List<T> backwards(List<T> input)\npublic static <? extends T> List<T> backwards(List<T> input)\npublic static <T> List<? extends T> backwards(List<T> input)\npublic static <T> List<T> backwards(List<? super T> input)\npublic static <T> List<? super T> backwards(List<T> input)\n\nwhich compile and run without error ?\n','public static <T> List<T> backwards(List<T> iput)\n	- a standard way to create a generic method\n\npublic static <T> List<T> backwards(List<? extends T> input)\n	-this says to the compile \" I want to be allowed to pass\n		in lsits of subtypes of the declared type but only\n		to invoke methods on the elements.\n\npublic static <T> List<? super T> backwards(List<T> input)\npublic static <T> List<? extends T> backwards(List<T> input)\n\n\npublic static <T> List<T> backwards(List<? super T> input)\n\n	this will nto compile because if the input can containt any super type\nof T then those elements couldn\'t be added to a collection of type T','Collections',1,NULL),(2332,'class Hello{\n   public static void main(String[] args){\n       ArrayList<Integer> ints = new ArrayList<>();\n       ints.add(9);\n       ints.add(8);\n       ints.add(7);\n   }\n\n    public static <T> List<T> backwards(List<? super T> input)\n    {\n        List<T> output = new LinkedList<T>();\n        for(T t : input)\n            output.add(0,t);\n        return output;\n    }\n}','WNC,\n\nif the input can contain any super type of T then those elements couldn\'t be\nadded to a collection of type T.','Collections',1,NULL),(2333,'public static <? extends T> List<T> backwards(List<T> input)','WILL NEVER COPMPILE\n\ncannot use wildcards in the type declaration','Collections',1,NULL),(2334,'public static <? super T> List<T> backwards(List<T> input)','WILL NEVER COMPILE\n\ncannot use wildcards in the type variable delcaraiotn','Collections',1,NULL),(2335,'CANNOT USE ? WILDCARDS IN THE TYPE VARIABLE DECLARATION OF THE GENERIC METHOD','got it ','Collections',1,NULL),(2336,'class Hello<G>{\n   public static void main(String[] args){\n       ArrayList<G> ints = new ArrayList<>();\n   }\n\n    public static <T> List<T> backwards(List<? super T> input)\n    {\n        ArrayList<G> ints = new ArrayList<>();\n        List<T> output = new LinkedList<T>();\n        for(T t : input)\n            output.add(0,t);\n        return output;\n    }\n}\n','WNC,\n\nnon static type variable G cannot be used in static context','Collections',1,NULL),(2337,'class Hello<G>{\n   public static void main(String[] args){\n       \n   }\n\n    public static <T extends G> List<T> backwards(List<T> input)\n    {\n        List<T> output = new LinkedList<T>();\n        for(T t : input)\n            output.add(0,t);\n        return output;\n    }\n}','WNC non static type variable G cannot be referenced from a static context','Collections',1,NULL),(2338,'This is the first part of PECS i.e. PE (Producer extends). To more relate it to real life terms, let’s use an analogy of a basket of fruits (i.e. collection of fruits). When we pick a fruit from basket, then we want to be sure that we are taking out only fruit only and nothing else; so that we can write generic code like this:\n\nFruit get = fruits.get(0);\n\nIn above case, we need to declare the collection of fruits as List<? extends Fruit>. e.g.\nclass Fruit {\n   @Override\n   public String toString() {\n      return \"I am a Fruit !!\";\n   }\n}\n \nclass Apple extends Fruit {\n   @Override\n   public String toString() {\n      return \"I am an Apple !!\";\n   }\n}\n \npublic class GenericsExamples\n{\n   public static void main(String[] args)\n   {\n      //List of apples\n      List<Apple> apples = new ArrayList<Apple>();\n      apples.add(new Apple());\n       \n      //We can assign a list of apples to a basket of fruits;\n      //because apple is subtype of fruit \n      List<? extends Fruit> basket = apples;\n       \n      //Here we know that in basket there is nothing but fruit only\n      for (Fruit fruit : basket)\n      {\n         System.out.println(fruit);\n      }\n       \n      //basket.add(new Apple()); //Compile time error\n      //basket.add(new Fruit()); //Compile time error\n   }\n}','','Collections',1,NULL),(2339,'a producer will extend the type being used because it will possibly contain\nsubtypes, it is a producer therefore you shouldn\'t have to nor want to\nadd anything else to it. so <? extends G> is for producers nothing will be\nadded to this collection','','Collections',1,NULL),(2340,'class Fruit {\n   @Override\n   public String toString() {\n      return \"I am a Fruit !!\";\n   }\n}\n \nclass Apple extends Fruit {\n   @Override\n   public String toString() {\n      return \"I am an Apple !!\";\n   }\n}\n \nclass AsianApple extends Apple {\n   @Override\n   public String toString() {\n      return \"I am an AsianApple !!\";\n   }\n}\n \npublic class GenericsExamples\n{\n   public static void main(String[] args)\n   {\n      //List of apples\n      List<Apple> apples = new ArrayList<Apple>();\n      apples.add(new Apple());\n       \n      //We can assign a list of apples to a basket of apples\n      List<? super Apple> basket = apples;\n       \n      basket.add(new Apple());      //Successful\n      basket.add(new AsianApple()); //Successful\n      basket.add(new Fruit());      //Compile time error\n   }\n}\n\nWe are able to add apple and even Asian apple inside basket, but we are not\n able to add Fruit (super type of apple) to basket. Why?\n\nReason is that basket is a reference to a List of something that is a \nsupertype of Apple. Again, we cannot know which supertype it is, but we\n know that Apple and any of its subtypes (which are subtype of Fruit) can \nbe added to be without problem (you can always add a subtype in collection \nof supertype). So, now we can add any type of Apple inside basket.\n\nproducers use super','','Collections',1,NULL),(2341,'class Hello{\n   public static void main(String[] args){\n       new Hello().go();\n   }\n   void go() throws IOException {\n       String row;\n       try {\n          FileReader fr = new FileReader(\"TestFile.txt\");\n          BufferedReader br = new BufferedReader(fr);\n          while((row = br.readLine()) != null)\n               System.out.println(row);\n       } catch(IOException e){\n           System.out.println(\"IOERROR\");\n       } finally {\n           System.out.println(\"done\");    \n       }\n   }\n}','WNC though it is not thrown go() declares that it throws an excpetion so it \nshould be handled by main','Exceptions',1,NULL),(2342,'class Party {\n    static class Rain extends Exception { }\n    static class Thunderstorm extends Rain{ }\n    public void eat() {\n        try {\n            bbq();\n        } catch(Rain | Thunderstorm e){\n            \n        }\n    }\n    private void bbq() throws Rain, Thunderstorm{ }\n}','multi catch may not contain exception types that are in the same heirarchy','Exceptions',1,NULL),(2343,'class Hello{\n   public static int y;\n   public static void main(String[] args){\n       int t = 2;\n       assert t < 4 : bar(7);\n       assert t > 1 : foo(8);\n       System.out.println(\"done\");\n   }\n    public static int foo(int x) {\n        System.out.println(\"foo \");\n        return y = x;\n    }\n    public static int bar(int z) {\n        System.out.println(\"bar \");\n        return y = z;\n    }\n}','done\n\nboth assert statements are true so the methods are never called','Exceptions',1,NULL),(2344,'class Hello{\n    static class A implements AutoCloseable {\n        public void close() throws Exception {\n            throw new Exception(\"catch\");\n        }\n    }\n    \n    private static void method() throws Exception {\n        try(A a = new A()) {\n            throw new Exception(\"try\");\n        } finally {\n            throw new Exception(\"finally\");\n        }\n    }\n\n   public static void main(String[] args){\n       try {\n           method();\n       } catch(Exception e) {\n           System.out.println(e.getMessage());\n           System.out.println(e.getSuppressed()[0]);\n       }\n   }\n\n}','finally\nException in thread \"main\" java.lang.ArrayIndexOutOfBoundsException: 0\n	at hello.Hello.main(Hello.java:53)\n/home/maxbisesi/.cache/netbeans/8.1/executor-snippets/run.xml:53: Java returned: 1\n\n\nTHe other two excpeitons weren\'t suppressed they were forgotten when \nfinally threw a new exception. \n\nso getSuppressed() cant find anything and throws the indexOB exception.','Exceptions',1,NULL),(2345,'%[arg_index][flags][width][.precision]conversion char\n\nflags\n-=-=-=-=-=-\n- left justify\n+ include a sign\n0 pad argument with zeros\n, use locale specific grouping serperators\n( Enclose negative numbers in parentheses\n\nconversion chars\n-=-=-=-=-=-=-=-=-=-\nb boolean\nc char\nd integer\nf floating point\ns string','got it','Strings',1,NULL),(2346,'Barring booleans, if your conversion character doesn\'t match your argument type,\nan exception will be thrown','got it','Strings',1,NULL),(2347,'private static void method() throws Exception {\n        int a = 831;\n        int b = 7566;\n        int c = 317;\n        System.out.printf(\">%1$(7d< \\n\",c);\n        System.out.printf(\">%0,7d< \\n\",a);\n        System.out.printf(\">%+-7d< \\n\",b);\n    }','>    317< \n>0000831< \n>+7566  < \n\n','Strings',1,NULL),(2348,'format flags:\n\n,','use locale specific seperators','Strings',1,NULL),(2349,'format flags:\n\n(','Encolose negative numbers in paranethes','Strings',1,NULL),(2350,'format flags:\n\n0','Pad this argument with zeroes','Strings',1,NULL),(2351,'format flags:\n\n+','Include a sign with this argument','Strings',1,NULL),(2352,'format flags:\n\n-','left justify this argument','Strings',1,NULL),(2353,'format conversion chararcters:\n\nb\nc\nd\nf\ns','boolean\ncharacter\ninteger\nfloating point\nstring','Strings',1,NULL),(2354,'private static void method() throws Exception {\n        int a = 831;\n        String s = \"The world is not enough\";\n        boolean yea = true;\n        \n        System.out.printf(\"%1$s, and there is no tomorrow\",s);\n    }','The world is not enough, and there is no tomorrow\n\neverything after the conversion character is printed as is','Strings',1,NULL),(2355,'private static void method() throws Exception {\n        int a = 831;\n        String s = \"The world is not enough\";\n        boolean yea = true;\n        \n        System.out.printf(\"%1$s, and there is no tomorrow\",a);\n    }','831, and there is no tomorrow','Strings',1,NULL),(2356,'private static void method() throws Exception {\n        int a = 831;\n        String s = \"The world is not enough\";\n        boolean yea = true;\n        \n        System.out.printf(\"%1$s, and there is no tomorrow\",a);\n    }','831, and there is no tomorrow','Strings',1,NULL),(2357,'private static void method() throws Exception {\n        int a = 831;\n        String s = \"The world is not enough\";\n        boolean yea = true;\n        \n        System.out.printf(\"%1$s, and there is no tomorrow\",a);\n    }','831, and there is no tomorrow','Strings',1,NULL),(2358,'private static void method() throws Exception {\n        int a = 831;\n        String s = \"The world is not enough\";\n        boolean yea = true;\n        \n        System.out.printf(\"%1$s, and there is no tomorrow\",a);\n    }','831, and there is no tomorrow','Strings',1,NULL),(2359,'private static void method() throws Exception {\n        int a = 831;\n        String s = \"The world is not enough\";\n        boolean yea = true;\n        \n        System.out.printf(\"%1$s, and there is no tomorrow\",a);\n    }','831, and there is no tomorrow','Strings',1,NULL),(2360,'private static void method() throws Exception {\n        int a = 831;\n        String s = \"The world is not enough\";\n        boolean yea = true;\n        \n        System.out.printf(\"%1$s, and there is no tomorrow\",a);\n    }','831, and there is no tomorrow','Strings',1,NULL),(2361,'private static void method() throws Exception {\n        int a = 831;\n        String s = \"The world is not enough\";\n        boolean yea = true;\n        \n        System.out.printf(\"%1$s, and there is no tomorrow\",a);\n    }','831, and there is no tomorrow','Strings',1,NULL),(2362,'private static void method() throws Exception {\n        int a = 831;\n        String s = \"The world is not enough\";\n        boolean yea = true;\n        \n        System.out.printf(\"%1$s, and there is no tomorrow\",a);\n    }','831, and there is no tomorrow','Strings',1,NULL),(2363,'private static void method() throws Exception {\n        int a = 831;\n        String s = \"The world is not enough\";\n        boolean yea = true;\n        \n        System.out.printf(\"%1$s, and there is no tomorrow\",a);\n    }','831, and there is no tomorrow','Strings',1,NULL),(2364,'private static void method() throws Exception {\n        int a = 831;\n        String s = \"The world is not enough\";\n        boolean yea = true;\n        \n        System.out.printf(\"%1$s, and there is no tomorrow\",a);\n    }','831, and there is no tomorrowa','Strings',1,NULL),(2365,'private static void method() throws Exception {\n        int a = 831;\n        String s = \"The world is not enough\";\n        boolean yea = true;\n        \n        System.out.printf(\"%1$s, and there is no tomorrow\",a);\n    }','831, and there is no tomorrowa','Strings',1,NULL),(2366,'private static void method() throws Exception {\n        int a = 831;\n        String s = \"The world is not enough\";\n        boolean yea = true;\n        \n        System.out.printf(\"%1$s, and there is no tomorrow\",a);\n    }','831, and there is no tomorrowa','Strings',1,NULL),(2367,'private static void method() throws Exception {\n        int a = 831;\n        String s = \"The world is not enough\";\n        boolean yea = true;\n        \n        System.out.printf(\"%1$s, and there is no tomorrow\",a);\n    }','831, and there is no tomorrowa','Strings',1,NULL),(2368,'private static void method() throws Exception {\n        int a = 831;\n        String s = \"The world is not enough\";\n        boolean yea = true;\n        \n        System.out.printf(\"%1$s, and there is no tomorrow\",a);\n    }','831, and there is no tomorrowa','Strings',1,NULL),(2369,'private static void method() throws Exception {\n        int a = 831;\n        String s = \"The world is not enough\";\n        boolean yea = true;\n        \n        System.out.printf(\"%1$s, and there is no tomorrow\",a);\n    }','831, and there is no tomorrowa','Strings',1,NULL),(2370,'private static void method() throws Exception {\n        int a = 831;\n        String s = \"The world is not enough\";\n        boolean yea = true;\n        \n        System.out.printf(\"%1$s, and there is no tomorrow\",a);\n    }','831, and there is no tomorrowa','Strings',1,NULL),(2371,'private static void method() throws Exception {\n        int a = 831;\n        String s = \"The world is not enough\";\n        boolean yea = true;\n        \n        System.out.printf(\"%1$s, and there is no tomorrow\",a);\n    }','831, and there is no tomorrowa','Strings',1,NULL),(2372,'public static void main(String[] args){\n        int count = 0;\n            for (int ch = \'a\'; ch <= \'z\'; ch++) {\n            System.out.printf(\"      %1$4c%1$4x\", ch);\n            if (++count % 6 == 0) {\n                 System.out.printf(\"%n\");\n             }\n        System.out.printf(\"      %1$4c%<4x\", ch);\n        }\n\n   }','         a  61         a  61         b  62         b  62         c  63         c  63         d  64         d  64         e  65         e  65         f  66\n         f  66         g  67         g  67         h  68         h  68         i  69         i  69         j  6a         j  6a         k  6b         k  6b         l  6c\n         l  6c         m  6d         m  6d         n  6e         n  6e         o  6f         o  6f         p  70         p  70         q  71         q  71         r  72\n         r  72         s  73         s  73         t  74         t  74         u  75         u  75         v  76         v  76         w  77         w  77         x  78\n         x  78         y  79         y  79         z  7a         z  7','Strings',1,NULL),(2373,'public static void main( String args[] )\n   { \n      char character = \'A\';\n      String string = \"This is also a string\";\n      Integer integer = 1234;  // initialize integer (autoboxing)\n\n      System.out.printf( \"%c\\n\", character );\n      System.out.printf( \"%s\\n\", \"This is a string\" );\n      System.out.printf( \"%s\\n\", string );\n      System.out.printf( \"%S\\n\", string );\n      System.out.printf( \"%s\\n\", integer ); // implicit call to toString\n   }','A\nThis is a string\nThis is also a string\nTHIS IS ALSO A STRING\n1234','Strings',1,NULL),(2374,'public static void main( String args[] ) \n   {\n      Object test = null;\n      System.out.printf( \"%b\\n\", false );\n      System.out.printf( \"%b\\n\", true );\n      System.out.printf( \"%b\\n\", \"Test\" );\n      System.out.printf( \"%B\\n\", test );\n      System.out.printf( \"Hashcode of \\\"hello\\\" is %h\\n\", \"hello\" );\n      System.out.printf( \"Hashcode of \\\"Hello\\\" is %h\\n\", \"Hello\" );\n      System.out.printf( \"Hashcode of null is %H\\n\", test );\n      System.out.printf( \"Printing a %% in a format string\\n\" );\n      System.out.printf( \"Printing a new line %nnext line starts here\" );\n   }','false\ntrue\ntrue\nFALSE\nHashcode of \"hello\" is 5e918d2\nHashcode of \"Hello\" is 42628b2\nHashcode of null is NULL\nPrinting a % in a format string\nPrinting a new line \nnext line starts here','Strings',1,NULL),(2375,'public static void main(String[] args){\n        int count = 0;\n        String s = \" true\";\n        boolean yea = true;\n        boolean nah = false;\n        System.out.printf(\"use boolean to convert non-boolean\\n count:%b \\n s:%b \\n yea:%b \\n nah:%b \",count,s,yea,nah);\n   }','a boolean conversion character will convert anything non boolean to \"true\"\nand a false to boolean to \"false\"','Strings',1,NULL),(2376,'public static void main(String[] args){\n        int count = 0;\n        String s = \" true\";\n        boolean yea = true;\n        boolean nah = false;\n        System.out.printf(\"use string to convert non-boolean\\n count:%s \\n s:%s \\n yea:%s \\n nah:%s \",count,s,yea,nah);\n   }','use string to convert non-boolean\n count:0 \n s: true \n yea:true \n nah:false','Strings',1,NULL),(2377,'At least five wide 	\n\nprintf(\"\'%5d\'\", 10); 	\'   10\'\n\nAt least five-wide, left-justified 	\n\nprintf(\"\'%-5d\'\", 10); 	\'10   \'\n\nAt least five-wide, zero-filled 	\n\nprintf(\"\'%05d\'\", 10); 	\'00010\'\n\nAt least five-wide, with a plus sign 	\n\nprintf(\"\'%+5d\'\", 10); 	\'  +10\'\n\nFive-wide, plus sign, left-justified 	\n\nprintf(\"\'%-+5d\'\", 10); 	\'+10  \'','got it ','Strings',1,NULL),(2378,'The %3d specifier is used with integers, and means a minimum width of three\n spaces, which, by default, will be right-justified:\n\nprintf(\"%3d\", 0); 	0\nprintf(\"%3d\", 123456789); 	123456789\nprintf(\"%3d\", -10); 	-10\nprintf(\"%3d\", -123456789); 	-123456789','got it','Strings',1,NULL),(2379,'To left-justify integer output with printf, just add a minus sign (-) after\n the % symbol, like this:\n\nprintf(\"%-3d\", 0); 	0\nprintf(\"%-3d\", 123456789); 	123456789\nprintf(\"%-3d\", -10); 	-10\nprintf(\"%-3d\", -123456789); 	-123456789','got it','Strings',1,NULL),(2380,'As a summary of printf integer formatting, here’s a little collection of \ninteger formatting examples. Several different options are shown, including\n a minimum width specification, left-justified, zero-filled, and also a \nplus sign for positive numbers.\n\nAt least five wide 	printf(\"\'%5d\'\", 10); 	\'   10\'\nAt least five-wide, left-justified 	printf(\"\'%-5d\'\", 10); 	\'10   \'\nAt least five-wide, zero-filled 	printf(\"\'%05d\'\", 10); 	\'00010\'\nAt least five-wide, with a plus sign 	printf(\"\'%+5d\'\", 10); 	\'  +10\'\nFive-wide, plus sign, left-justified 	printf(\"\'%-+5d\'\", 10); 	\'+10  \'','got it','Strings',1,NULL),(2381,'A simple string 	printf(\"\'%s\'\", \"Hello\"); 	\'Hello\'\nA string with a minimum length 	printf(\"\'%10s\'\", \"Hello\"); 	\'     Hello\'\nMinimum length, left-justified 	printf(\"\'%-10s\'\", \"Hello\"); 	\'Hello     \'','got it','Strings',1,NULL),(2382,'Print one position after the decimal 	\n\nprintf(\"\'%.1f\'\", 10.3456); 	\'10.3\'\n\nTwo positions after the decimal 	\n\nprintf(\"\'%.2f\'\", 10.3456); 	\'10.35\'\n\nEight-wide, two positions after the decimal 	\n\nprintf(\"\'%8.2f\'\", 10.3456); 	\'   10.35\'\n\nEight-wide, four positions after the decimal 	\n\nprintf(\"\'%8.4f\'\", 10.3456); 	\' 10.3456\'\n\nEight-wide, two positions after the decimal, zero-filled 	\n\nprintf(\"\'%08.2f\'\", 10.3456); 	\'00010.35\'\n\nEight-wide, two positions after the decimal, left-justified 	\n\nprintf(\"\'%-8.2f\'\", 10.3456); 	\'10.35   \'\n\nPrinting a much larger number with that same format 	\n\nprintf(\"\'%-8.2f\'\", 101234567.3456); 	\'101234567.35\'','got it if the argument is larger than the width, it will be extended','Strings',1,NULL),(2383,'public static void main(String[] args){\n        int count = 0;\n        String s = \" true\";\n        boolean yea = true;\n        boolean nah = false;\n        System.out.printf(\"%1$(4s\",s);\n   }','Exception in thread \"main\" java.util.FormatFlagsConversionMismatchException: Conversion = s, Flags = (\n\nfor using flags that dont apply to strings','Strings',1,NULL),(2384,'public static void main(String[] args){\n        int count = 0;\n        String s = \" true\";\n        boolean yea = true;\n        boolean nah = false;\n        System.out.printf(\"%1$0s\",s);\n   }','Exception in thread \"main\" java.util.FormatFlagsConversionMismatchException:\n Conversion = s, Flags = 0','Strings',1,NULL),(2385,'public static void main(String[] args){\n        int count = -34;\n        String s = \" true\";\n        boolean yea = true;\n        boolean nah = false;\n        System.out.printf(\"%1$0(3d\",count);\n   }','(34)\n\nit goes like this:\n\narg_index flags width precision conversion character\n\nso here the fomat string means index 1, pad with zeroes, \nwidth of three, enclose negatives in zero, convert from an int','Strings',1,NULL),(2386,'public static void main(String[] args){\n        double count = -34.45;\n        String s = \" true\";\n        boolean yea = true;\n        boolean nah = false;\n        System.out.printf(\"%1$0(3d\",count);\n   }','Exception in thread \"main\" java.util.IllegalFormatConversionException:\n d != java.lang.Double','Strings',1,NULL),(2387,'public static void main(String[] args){\n        double count = -34.45;\n        String s = \" true\";\n        boolean yea = true;\n        boolean nah = false;\n        System.out.printf(\"%1$0(3f\",count);\n   }','(34.450000)','Strings',1,NULL),(2388,'public static ArrayList<Card> findCardsWithNoCategory(ArrayList<? extends Card> list){\n        ArrayList<? super Card> cards = new ArrayList<Card>();\n        \n        for(Card c : list){\n            if(c.getCategory().equals(\"\") || c.getCategory().equals(\" \")){\n                cards.add(c);\n            }\n        }\n        \n        return cards;\n        \n    }','\nWNC\ncant return <? super Cards> when return type is <Card>','Generics',1,NULL),(2389,'DirectoryStream dm = ...\n\nFileSystem.getDefault().getDirectoryStream(Path p, String glob);\n\nFiles.getDefault().newDirectoryStream(File f, String regex);\n\nFiles.getDefault().newDirectoryStream(Path p, String glob);\n\nFiles.newDirectoryStream(Path p, String glob);\n\nFiles.getDirectoryStream(Files f, String regex);\n\n','Files.newDirectoryStream(Path p, String glob)\n\nDirectoryStream only uses glob\n\nso you dont have to say \"glob: *\"\n\nif you do it wont match anything','Input/Output',1,NULL),(2390,'DirectoryStream dm = ...\n\nFileSystem.getDefault().getDirectoryStream(Path p, String glob);\n\nFiles.getDefault().newDirectoryStream(File f, String regex);\n\nFiles.getDefault().newDirectoryStream(Path p, String glob);\n\nFiles.newDirectoryStream(Path p, String glob);\n\nFiles.getDirectoryStream(Files f, String regex);\n\n','Files.newDirectoryStream(Path p, String glob)\n\nDirectoryStream only uses glob\n\nso you dont have to say \"glob: *\"\n\nif you do it wont match anything','Input/Output',1,NULL),(2391,'DirectoryStream dm = ...\n\nFileSystem.getDefault().getDirectoryStream(Path p, String glob);\n\nFiles.getDefault().newDirectoryStream(File f, String regex);\n\nFiles.getDefault().newDirectoryStream(Path p, String glob);\n\nFiles.newDirectoryStream(Path p, String glob);\n\nFiles.getDirectoryStream(Files f, String regex);\n\n','Files.newDirectoryStream(Path p, String glob)\n\nDirectoryStream only uses glob\n\nso you dont have to say \"glob: *\"\n\nif you do it wont match anything','Input/Output',1,NULL),(2392,'DirectoryStream dm = ...\n\nFileSystem.getDefault().getDirectoryStream(Path p, String glob);\n\nFiles.getDefault().newDirectoryStream(File f, String regex);\n\nFiles.getDefault().newDirectoryStream(Path p, String glob);\n\nFiles.newDirectoryStream(Path p, String glob);\n\nFiles.getDirectoryStream(Files f, String regex);','Files.newDirectoryStream(Path p, String glob)\n\nDirectoryStream only uses glob\n\nso you dont have to say \"glob: *\"\n\nif you do it wont match anything','Input/Output',1,NULL),(2393,'try(DirectoryStream<Path> dm = Files.newDirectoryStream(home,\"glob:*\")){\n           for(Path path:dm){\n               System.out.println(path);\n           }\n           \n       } catch(IOException e){ System.out.println(e); }','comiles but will not match anything,\nDirectoryStream only takes globs so when you say glob: it trys to match a file\nlike that. ','Input/Output',1,NULL),(2394,'PathMatcher pm = ...\n\nFiles.getDefault().getPathMatcher(\"glob:file?.*\");\nFileSystems.getDefault().getPathMatcher(Path dir,\"TextFile?.*\");\nFileSystems.getPathMatcher(\"regex:TextFile?.*\");\nFiles.newPathMatcher(File file, String glob);\n\n','FileSystems.getDefault().getPathMatcher(\"glob:TextFile?.*\");\n\nthe argument to getPathMatcher is (String syntaxandpatter)\n\nso that means it supports glob or regex.\n\nsyntax:pattern\n\nglob:*.txt\nregex:.*{.txt}\n\n*Dont put a space after the : that wll be included in the pattern','Input/Output',1,NULL),(2395,'public static void main(String[] args){\n       \n       Path file = Paths.get(\"/home/maxbisesi/Public/Data/InnerDir/emptyFile.txt\");\n       try{\n           Files.createFile(file);\n           System.out.println(\"File created\");\n           Path dir = Paths.get(\"/home/maxbisesi/Public/Data/InnerDir\");\n           Files.delete(dir);\n       } catch(IOException e){\n           System.out.println(e);\n       }\n       \n            \n   }','DirectoryNotEmptyException\n\nFiles.delete cannot delete a directory thats not empty','Input/Output',1,NULL),(2396,' public static void main(String[] args){\n       	// imagine InnerDir contains one text file\n           File file = new File(\"/home/maxbisesi/Public/Data/InnerDir\");\n           file.mkdir();\n           System.out.println(\"File created\");\n           file.renameTo(new File(\"/home/maxbisesi/Public/Data/MaxsDir\"));\n           System.out.println(file);\n\n            \n   }','File created\n/home/maxbisesi/Public/Data/InnerDir\n\nyou can rename a File dir even if it is not empty','Input/Output',1,NULL),(2397,'public class Hello {\n    public static void main(String[] args){\n        ExecutorService ex = Executors.newSingleThreadExecutor(); \n        Future<Integer> futint = ex.submit(new FileCounter());\n        \n        System.out.println(\"Do other things while the files are getting counted\");\n        \n        try{\n            int count = futint.get();\n            System.out.println(count);\n            //ex.shutdown();\n        }catch(ExecutionException | InterruptedException e){\n            \n        }\n        \n    }\n    \n    \n}\n\nclass FileCounter implements Callable<Integer>{\n    private int fileCount = 0;\n    public Integer call() throws IOException{\n        fileCount = count(Paths.get(\"/home/maxbisesi/Documents\"));\n        return fileCount; \n    }\n    \n    public Integer count(Path d) throws IOException {\n        int count = 0;\n	try(DirectoryStream<Path> stream = Files.newDirectoryStream(d)){\n		for(Path path: stream){\n			count++;\n		}\n	}\n        return count;\n    }\n}\nwhat will happen ? ','it will print its two messages then continue to run,\n\nwithout shutdown() the executor doesn\'t know when to stop. ','Executors',1,NULL),(2398,'ExecutorService ex = \n//..\nex.shutdown(); // no more new task but finish the currently executing ones\n\ntry {\n	boolean term = ex.awaitTermination(2,TimeUnit.SECONDS);\n} catch(InterruptedException e){\n	//did not wait the full 2 seconds\n} finally {\n	if(!ex.isTerminated()) // are all tasks done ?\n	{\n		List<Runnable> unfinished = ex.shutdownNow();\n		//a collection of unfinished tasks\n	}\n}','got it \n\nshutdownNow() will call Thread.interrupt() in an attemtpt to terminate any \nunfinished tasks.','Executors',1,NULL),(2399,'public class Hello {\n    public static void main(String[] args){\n        try {\n            Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\");\n            PreparedStatement pst = conn.prepareStatement(\"Select * From employees limit 100\");\n            ResultSet rs = pst.executeQuery();\n            \n            Date d = new Date();\n            Calendar c = Calendar.getInstance();\n            c.setTime(d);\n\n            rs.first();\n            System.out.println(\"First entry:\");\n            System.out.println(\"Hired today: \"+d);\n            System.out.println(\"Start first upcoming monday: \"+firstNextMonday(d));\n            System.out.println(rs.getString(\"first_name\") + \" \" +rs.getString(\"last_name\"));\n            \n            c.add(Calendar.MONTH,-1);\n            Date monthago = c.getTime();\n            rs.last();\n            System.out.println(\"Last entry:\");\n            System.out.println(\"Hired a month ago: \"+monthago);\n            System.out.println(rs.getString(\"first_name\") + \" \" +rs.getString(\"last_name\"));\n        } catch(SQLException e){ }\n        \n    }\n    \n    public static Date firstNextMonday(Date d){\n        Calendar c = Calendar.getInstance();\n        c.setTime(d);\n        \n        while(c.get(Calendar.DAY_OF_WEEK) != c.MONDAY){\n            //c.add(1,DAY_OF_WEEK);\n            c.add(c.DAY_OF_WEEK,1);\n        }\n        \n        return c.getTime();\n        \n    }\n}','First entry:\nHired today: Mon Aug 07 16:43:51 EDT 2017\nStart first upcoming monday: Mon Aug 07 16:43:51 EDT 2017\nMicheal Boyd\nLast entry:\nHired a month ago: Fri Jul 07 16:43:51 EDT 2017\nVishv Zockler\n','Executors',1,NULL),(2400,'create a fixed thread pool...\n\nExecutor ex = ExecutorService.newFixedThreadPool(4);\nExecutor ex = Executor.newFixedThreadPool(4);\nExecutorService = ExecutorService.newFixedThreadPool(4);\nExecutorService = Executors.newFixedThreadExecutor(4);','ExecutorService ex = Executors.newFixedThreadPool(4);\n\nits none of those','Executors',1,NULL),(2401,'public class Hello {\n\n    private static ArrayBlockingQueue<String> abq = new ArrayBlockingQueue<>(20);\n\n    public static void main(String[] args) {\n        //ExecutorService ex = ExecutorService.newFixedThreadPool(4);\n        ExecutorService ex = Executors.newFixedThreadPool(4);\n        Future<?> fut = ex.submit(new FileLister());\n        try{\n            System.out.println(fut.get()); // will print null\n        } catch(ExecutionException | InterruptedException e){ }\n        \n        for(String file : abq){\n            System.out.println(file+\" \");\n        }\n\n    }\n\n    static class FileLister implements Runnable {\n        public void run() {\n            Path home = Paths.get(\"/home/maxbisesi\");\n            try (DirectoryStream<Path> stream = Files.newDirectoryStream(home)) {\n                for (Path path : stream) {\n                    boolean added = false;\n                    added = abq.offer(path.toString());\n                    System.out.println(\"added: \"+added);\n\n                    if (!added) {\n                        System.out.println(\"queue is full offer will not add anymore\");\n                    }\n                }\n            } catch (IOException e) { }\n        }\n    }\n}','added: true\nadded: true\nadded: true\nadded: true\nadded: true\nadded: true\nadded: true\nadded: true\nadded: true\nadded: true\nadded: true\nadded: true\nadded: true\nadded: true\nadded: true\nadded: true\nadded: true\nadded: true\nadded: true\nadded: true\nadded: false\nqueue is full offer will not add anymore\nadded: false\nqueue is full offer will not add anymore\nadded: false\nqueue is full offer will not add anymore\nadded: false\nqueue is full offer will not add anymore\nadded: false\nqueue is full offer will not add anymore\nadded: false\nqueue is full offer will not add anymore\nadded: false\nqueue is full offer will not add anymore\nadded: false\nqueue is full offer will not add anymore\nadded: false\nqueue is full offer will not add anymore\nadded: false\nqueue is full offer will not add anymore\nadded: false\nqueue is full offer will not add anymore\nadded: false\nqueue is full offer will not add anymore\nadded: false\nqueue is full offer will not add anymore\nadded: false\nqueue is full offer will not add anymore\nnull\n/home/maxbisesi/.config \n/home/maxbisesi/.nano \n/home/maxbisesi/Desktop \n/home/maxbisesi/.bash_history \n/home/maxbisesi/Templates \n/home/maxbisesi/examples.desktop \n/home/maxbisesi/.bashrc \n/home/maxbisesi/.gnupg \n/home/maxbisesi/.java \n/home/maxbisesi/.xsession-errors \n/home/maxbisesi/.local \n/home/maxbisesi/.dmrc \n/home/maxbisesi/.Xauthority \n/home/maxbisesi/.ICEauthority \n/home/maxbisesi/Music \n/home/maxbisesi/qb_aug6.sql \n/home/maxbisesi/Documents \n/home/maxbisesi/NetBeansProjects \n/home/maxbisesi/.netbeans \n/home/maxbisesi/Downloads ','Concurrency',1,NULL),(2402,'public class Hello {\n    public static void main(String[] dicks){\n        PriorityQueue<Animal> q = new PriorityQueue<>();\n        \n        q.add(new Animal(5,\"Sheep\"));\n        q.offer(new Animal(6,\"Goat\"));\n        q.offer(new Animal(10,\"Cow\"));\n        q.offer(new Animal(12,\"Bull\"));\n        q.offer(new Animal(3,\"Cat\"));\n        q.offer(new Animal(7,\"Sloth\"));\n        \n        System.out.println(q.remove());\n        System.out.println(q.remove(new Animal(7,\"Sloth\")));\n        \n        while(!q.isEmpty()){\n            System.out.println(q.poll());\n        }\n    }\n}\n\nclass Animal implements Comparable<Animal> {\n    private Integer size;\n    private String name;\n    \n    public Animal(int x, String y){\n        size = x;\n        name = y;\n    }\n    public Animal(){\n        size = 0;\n        name = \"\";\n    }\n\n    public int getSize() {\n        return size;\n    }\n\n    public String getName() {\n        return name;\n    }\n    \n    public String toString(){\n        return name;\n    }\n    \n    public int compareTo(Animal o){\n        return size.compareTo(o.getSize());\n        \n    }\n    \n        \n    public boolean equals(Object o){\n        if((o instanceof Animal)){\n            if((((Animal)o).getSize() == this.size) && (((Animal)o).getName().equals(name) ))\n                return true;\n            return false;           \n        } \n        return false;\n    }\n\n}','Cat\ntrue\nSheep\nGoat\nCow\nBull\n\nqueues remove from the head, here remove() returns the object removed,\nthe remove(E e) return true or false, the eleemnts are sorted according to\ntheir compareTo which orders in ascending order by size. ','Collections',1,NULL),(2403,'public static void main(String[] args){\n        try{\n            Path p = Paths.get(\"/home/maxbisesi/Public/GenDir/genFile.txt\");\n            Files.createFile(p);\n        } catch(IOException e){System.out.println(e);}\n        \n        \n    }\n\nGenDir directory does not exist. ','java.nio.file.NoSuchFileException: /home/maxbisesi/Public/GenDir/genFile.txt\n\nthe directory must exist before a file is created in it. ','Input/Output',1,NULL),(2404,' public void addFlashCard(Card c) {\n        try{\n            jrs.moveToInsertRow();\n            jrs.updateString(\"answer\",c.getAnswer());\n            jrs.updateString(\"card\",c.getCard());\n            jrs.updateString(\"category\",c.getCategory());\n            jrs.updateRow();\n            \n            System.out.printf(\"Flash Card added: today: %1$03d \\n last added:\\n %2$s \\n category:%3$s\",todaysCount,c.getCard(),c.getCategory());\n            todaysCount++;\n        } catch(SQLException e){\n            System.out.println(\"something went wrong adding flashcards to rowset\");\n            System.out.println(e);\n        }\n    }','It should be jrs.insertRow(), the docs say that updateRow cannot be called\nwhile on the insert row. \n\nThis will not work, will throw a SQLException','JDBC',1,NULL),(2405,'public class Hello {\n\n    public static void main(String[] args) {\n        new Hello().printDateTime(Paths.get(\"/home/maxbisesi\"));\n    }\n\n    public void printDateTime(Path d) {\n        DateFormat df = DateFormat.getDateInstance(DateFormat.LONG);\n        DateFormat dftime = DateFormat.getTimeInstance(DateFormat.SHORT);\n        try {\n            BasicFileAttributes ba = Files.readAttributes(d, BasicFileAttributes.class);\n            String creationDate = df.format(ba.creationTime().toMillis());\n            String lastAccessedDate = df.format(ba.lastAccessTime().toMillis());\n            String lastModifiedDate = df.format(ba.lastModifiedTime().toMillis());\n\n            String creationTime = dftime.format(ba.creationTime().toMillis());\n            String lastAccessedTime = dftime.format(ba.lastAccessTime().toMillis());\n            String lastModifiedTime = dftime.format(ba.lastModifiedTime().toMillis());\n\n            System.out.println(ba.isDirectory());\n\n            System.out.println(\"last modified: \" + lastModifiedDate + \" at: \" + lastModifiedTime);\n            System.out.println(\"last accessed: \" + lastAccessedDate + \" at: \" + lastAccessedTime);\n            System.out.println(\"created: \" + creationDate + \" at: \" + creationTime);\n\n        } catch (IOException e) { System.out.println(e);}\n\n    }\n}','true\nlast modified: August 8, 2017 at: 12:14 PM\nlast accessed: August 8, 2017 at: 3:58 PM\ncreated: August 8, 2017 at: 12:14 PM','Strings',1,NULL),(2406,'public class Hello {\n\n    public static void main(String[] args) {\n        Path home = Paths.get(\"/home/maxbisesi\");\n        Files.walkFileTree(home,new FileInfoPrinter());\n    }\n\n    public void printDateTime(Path d) {\n        DateFormat df = DateFormat.getDateInstance(DateFormat.LONG);\n        DateFormat dftime = DateFormat.getTimeInstance(DateFormat.SHORT);\n        try {\n            BasicFileAttributes ba = Files.readAttributes(d, BasicFileAttributes.class);\n            String creationDate = df.format(ba.creationTime().toMillis());\n            String lastAccessedDate = df.format(ba.lastAccessTime().toMillis());\n            String lastModifiedDate = df.format(ba.lastModifiedTime().toMillis());\n\n            String creationTime = dftime.format(ba.creationTime().toMillis());\n            String lastAccessedTime = dftime.format(ba.lastAccessTime().toMillis());\n            String lastModifiedTime = dftime.format(ba.lastModifiedTime().toMillis());\n\n            System.out.println(\"directory: \" + ba.isDirectory());\n\n            System.out.println(\"last modified: \" + lastModifiedDate + \" at: \" + lastModifiedTime);\n            System.out.println(\"last accessed: \" + lastAccessedDate + \" at: \" + lastAccessedTime);\n            System.out.println(\"created: \" + creationDate + \" at: \" + creationTime);\n\n        } catch (IOException e) {\n            System.out.println(e);\n        }\n\n    }\n\n    class FileInfoPrinter extends SimpleFileVisitor<Path> {\n\n        public FileVisitResult preVisitDirectory(Path file, BasicFileAttributes attrs) {\n            System.out.print(file);\n            printDateTime(file);\n            return FileVisitResult.CONTINUE;\n        }\n\n    }\n}','WNC unreported IOException at Files.walkFileTree()\n\nnon static inner class FileInfoPrinter cant be access from static context','Strings',1,NULL),(2407,'public static void main(String[] args) {\n        Path home = Paths.get(\"/home/maxbisesi\");\n        System.out.println(home.getFileName());\n    }\n}','maxbisesi\n\ngetFileName() is different from getName(int index)\n\nkeep in mind that getFileName() and getName return a Path','Input/Output',1,NULL),(2408,'public class Hello {\n\n    public static void main(String[] args) {\n        Path home = Paths.get(\"/home/maxbisesi\");\n        Hello h = new Hello();\n        Hello.FileInfoPrinter fip = h.new FileInfoPrinter();\n        try{\n            Files.walkFileTree(home,fip);\n        }catch(IOException e){ }\n    }\n\n    public static void printDateTime(Path d) {\n        DateFormat df = DateFormat.getDateInstance(DateFormat.LONG);\n        DateFormat dftime = DateFormat.getTimeInstance(DateFormat.SHORT);\n        try {\n            BasicFileAttributes ba = Files.readAttributes(d, BasicFileAttributes.class);\n            String creationDate = df.format(ba.creationTime().toMillis());\n            String lastAccessedDate = df.format(ba.lastAccessTime().toMillis());\n            String lastModifiedDate = df.format(ba.lastModifiedTime().toMillis());\n\n            String creationTime = dftime.format(ba.creationTime().toMillis());\n            String lastAccessedTime = dftime.format(ba.lastAccessTime().toMillis());\n            String lastModifiedTime = dftime.format(ba.lastModifiedTime().toMillis());\n\n            System.out.println(\"directory: \" + ba.isDirectory());\n            System.out.println(\"\");\n            System.out.println(\"last modified: \" + lastModifiedDate + \" at: \" + lastModifiedTime);\n            System.out.println(\"last accessed: \" + lastAccessedDate + \" at: \" + lastAccessedTime);\n            System.out.println(\"created: \" + creationDate + \" at: \" + creationTime);\n            System.out.println(\"\");\n\n        } catch (IOException e) {\n            System.out.println(e);\n        }\n\n    }\n\n    class FileInfoPrinter extends SimpleFileVisitor<Path> {\n        private Pattern p = Pattern.compile(\"\\\\..*\");\n        private Matcher hidden;\n        \n\n        public FileVisitResult preVisitDirectory(Path file, BasicFileAttributes attrs) {\n            hidden = p.matcher(file.getFileName().toString());\n            if(hidden.find()){\n                return FileVisitResult.SKIP_SUBTREE;\n            }\n            System.out.print(file);\n            System.out.println(\"\");\n            printDateTime(file);\n            return FileVisitResult.CONTINUE;\n        }\n\n    }\n}','This will print out the contents of the home directory but skipping hidden files\nthat begin with a . like .config.\n\nremember that FileVisitor goes down as deep as it can before returning back up the\ntree.\n\nand files and directories at the same level can get visited in any order. \n\n\n/home/maxbisesi\ndirectory: true\n\nlast modified: August 8, 2017 at: 12:14 PM\nlast accessed: August 8, 2017 at: 3:58 PM\ncreated: August 8, 2017 at: 12:14 PM\n\n/home/maxbisesi/Desktop\ndirectory: true\n\nlast modified: July 21, 2017 at: 9:15 AM\nlast accessed: August 9, 2017 at: 11:33 AM\ncreated: July 21, 2017 at: 9:15 AM\n\n/home/maxbisesi/Templates\ndirectory: true\n\nlast modified: July 21, 2017 at: 9:15 AM\nlast accessed: August 9, 2017 at: 11:33 AM\ncreated: July 21, 2017 at: 9:15 AM\n\n/home/maxbisesi/Music\ndirectory: true\n\nlast modified: July 21, 2017 at: 9:15 AM\nlast accessed: August 9, 2017 at: 11:33 AM\ncreated: July 21, 2017 at: 9:15 AM\n\n/home/maxbisesi/Documents\ndirectory: true\n\nlast modified: July 24, 2017 at: 9:51 AM\nlast accessed: August 9, 2017 at: 11:33 AM\ncreated: July 24, 2017 at: 9:51 AM\n\n/home/maxbisesi/Documents/Code\ndirectory: true\n\nlast modified: August 8, 2017 at: 11:59 AM\nlast accessed: August 8, 2017 at: 11:59 AM\ncreated: August 8, 2017 at: 11:59 AM\n\n/home/maxbisesi/Documents/resumes\ndirectory: true\n\nlast modified: July 24, 2017 at: 9:51 AM\nlast accessed: August 9, 2017 at: 11:33 AM\ncreated: July 24, 2017 at: 9:51 AM\n\n/home/maxbisesi/NetBeansProjects\ndirectory: true\n\nlast modified: July 29, 2017 at: 12:03 PM\nlast accessed: August 9, 2017 at: 11:33 AM\ncreated: July 29, 2017 at: 12:03 PM\n\n/home/maxbisesi/NetBeansProjects/SourceManager\ndirectory: true\n\nlast modified: July 22, 2017 at: 2:52 PM\nlast accessed: August 8, 2017 at: 3:09 PM\ncreated: July 22, 2017 at: 2:52 PM\n\n/home/maxbisesi/NetBeansProjects/SourceManager/dist\ndirectory: true\n\nlast modified: July 22, 2017 at: 2:52 PM\nlast accessed: August 9, 2017 at: 11:33 AM\ncreated: July 22, 2017 at: 2:52 PM\n\n/home/maxbisesi/NetBeansProjects/SourceManager/nbproject\ndirectory: true\n\nlast modified: July 22, 2017 at: 12:35 PM\nlast accessed: August 8, 2017 at: 3:09 PM\ncreated: July 22, 2017 at: 12:35 PM\n','Input/Output',1,NULL),(2409,'public class Hello {\n\n    public static void main(String[] args) {\n        Path home = Paths.get(\"/home/maxbisesi\");\n        Hello h = new Hello();\n        Hello.FileInfoPrinter fip = h.new FileInfoPrinter();\n        try{\n            Files.walkFileTree(home,fip);\n        }catch(IOException e){ }\n    }\n\n    public static void printDateTime(Path d) {\n        DateFormat df = DateFormat.getDateInstance(DateFormat.LONG);\n        DateFormat dftime = DateFormat.getTimeInstance(DateFormat.SHORT);\n        try {\n            //BasicFileAttributes ba = Files.readAttributes(d, BasicFileAttributes.class);\n            BasicFileAttributes ba = new BasicFileAttributes(d, BasicFileAttributes.class);\n            String creationDate = df.format(ba.creationTime().toMillis());\n            String lastAccessedDate = df.format(ba.lastAccessTime().toMillis());\n            String lastModifiedDate = df.format(ba.lastModifiedTime().toMillis());\n\n            String creationTime = dftime.format(ba.creationTime().toMillis());\n            String lastAccessedTime = dftime.format(ba.lastAccessTime().toMillis());\n            String lastModifiedTime = dftime.format(ba.lastModifiedTime().toMillis());\n\n            System.out.println(\"directory: \" + ba.isDirectory());\n            System.out.println(\"\");\n            System.out.println(\"last modified: \" + lastModifiedDate + \" at: \" + lastModifiedTime);\n            System.out.println(\"last accessed: \" + lastAccessedDate + \" at: \" + lastAccessedTime);\n            System.out.println(\"created: \" + creationDate + \" at: \" + creationTime);\n            System.out.println(\"\");\n\n        } catch (IOException e) {\n            System.out.println(e);\n        }\n\n    }\n\n    class FileInfoPrinter extends SimpleFileVisitor<Path> {\n        private Pattern p = Pattern.compile(\"\\\\..*\");\n        private Matcher hidden;\n        \n\n        public FileVisitResult preVisitDirectory(Path file, BasicFileAttributes attrs) {\n            hidden = p.matcher(file.getFileName().toString());\n            if(hidden.find()){\n                return FileVisitResult.SKIP_SUBTREE;\n            }\n            System.out.print(file);\n            System.out.println(\"\");\n            printDateTime(file);\n            return FileVisitResult.CONTINUE;\n        }\n\n    }\n}','BasicFileAttributes is absract cannot be instantiated.\n\nshould be:\n\n	BasicFileAttributes ba = Files.readAttributes(path,BasicFileAttributes.class);','Input/Output',1,NULL),(2410,'class FileInfoPrinter extends SimpleFileVisitor<Path> {\n        private Pattern p = Pattern.compile(\"\\\\..*\");\n        private Matcher hidden;\n        \n\n        public FileVisitResult preVisitDirectory(Path file, BasicFileAttributes attrs){\n            hidden = p.matcher(file.getFileName().toString());\n            if(hidden.find()){\n                return FileVisitResult.SKIP_SUBTREE;\n            }\n            //makeFileCreatedOnMonday(file);\n            System.out.print(file);\n            System.out.println(\"\");\n            printDateTime(file);\n            return FileVisitResult.CONTINUE;\n        }\n        \n        public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\n            makeFileCreatedOnMonday(file);\n            return FileVisitResult.CONTINUE;\n        }\n\n    }','FileVisitor method throw IOExceptions,\n\nbut in overrides if you choose not to declare an exception that is ok, demonstrated\nhere. ','Input/Output',1,NULL),(2411,'class DateAsker implements Runnable {\n    private final int priority;\n    \n    public DateAsker(){\n        priority = ThreadLocalRandom.current().nextInt(0,5);\n    }\n    \n    \n    public void run(){\n        DateGiver dg = DateGiver.heyyou();\n        BlockingQueue<Date> bq = dg.availability();\n        Calendar c = Calendar.getInstance();\n        \n        try{\n            if(priority >= 4){\n                \n                Date next = bq.take();// blocks until available\n                c.setTime(next);\n                c.add(Calendar.DAY_OF_WEEK,2);\n                bq.put(c.getTime()); // returns void blocks until spac is available\n                \n            } else if(priority < 4 && priority >= 3){\n                \n                Date next = bq.poll(2000,TimeUnit.SECONDS);\n                c.setTime(next);\n                //c.add(Calendar.WEEK_IN_MONTH,2);\n                c.add(Calendar.WEEK_OF_MONTH,2);\n                bq.offer(c.getTime()); // returns true if object was added. false if the queeu is bouned and full  \n\n            } else {\n                Date next = bq.element();// gets the head of the queue without removing it. Throws NoSuchElementException if queue is empty\n                c.roll(Calendar.DAY_OF_MONTH,6);\n                c.roll(Calendar.HOUR_OF_DAY,20);\n                c.set(Calendar.MONTH,Calendar.JANUARY);\n                \n                bq.add(c.getTime()); // throws IllegalStateException if queue is bounded and full.\n                        \n            }\n        } catch(InterruptedException e){\n            \n        }\n\n        \n        \n    }\n}','got it','Concurrency',1,NULL),(2412,'class DateGiver implements Runnable {\n    private BlockingQueue<Date> dates = new ArrayBlockingQueue<>(25);\n    private static final DateGiver INSTANCE = new DateGiver();\n    \n    private DateGiver(){\n        \n    }\n    \n    public static DateGiver heyyou(){\n        return INSTANCE;\n    }\n\n    public void run(){\n        try{\n            Date d = new Date();\n            Calendar c = Calendar.getInstance();\n            c.setTime(d);\n            while(dates.peek() != null){\n                c.add(Calendar.DAY_OF_MONTH, 1);\n                dates.put(c.getTime());\n            }\n        }catch(InterruptedException e){\n            System.out.println(\"Sorry I got interrupted\");\n        }\n        \n    }\n    \n    public BlockingQueue<Date> availability(){\n        return dates;\n    }\n}\n\nwhat design pattern is this ?','Singelton','OOP',1,NULL),(2413,'class DateGiver implements Runnable {\n    private BlockingQueue<Date> dates = new ArrayBlockingQueue<>(25);\n    private static final DateGiver INSTANCE = new DateGiver();\n    \n    private DateGiver(){\n        \n    }\n    \n    public DateGiver heyyou(){\n        return INSTANCE;\n    }\n\n    public void run(){\n        try{\n            Date d = new Date();\n            Calendar c = Calendar.getInstance();\n            c.setTime(d);\n            while(dates.peek() != null){\n                c.add(Calendar.DAY_OF_MONTH, 1);\n                dates.put(c.getTime());\n            }\n        }catch(InterruptedException e){\n            System.out.println(\"Sorry I got interrupted\");\n        }\n        \n    }\n    \n    public BlockingQueue<Date> availability(){\n        return dates;\n    }\n}\n\nWhat is missing from making this pattern singelton ? ','The instance getting method needs to be static. ','OOP',1,NULL),(2414,'class DateGiver implements Runnable {\n    private BlockingQueue<Date> dates = new ArrayBlockingQueue<>();\n    private static final DateGiver INSTANCE = new DateGiver();\n    \n    private DateGiver(){\n        \n    }\n    \n    public static DateGiver heyyou(){\n        return INSTANCE;\n    }\n\n    public void run(){\n        try{\n            Date d = new Date();\n            Calendar c = Calendar.getInstance();\n            c.setTime(d);\n            while(dates.peek() != null){\n                c.add(Calendar.DAY_OF_MONTH, 1);\n                dates.put(c.getTime());\n            }\n        }catch(InterruptedException e){\n            System.out.println(\"Sorry I got interrupted\");\n        }\n        \n    }\n    \n    public BlockingQueue<Date> availability(){\n        return dates;\n    }\n}','WNC, an ArrayBlockingQueue is bounded and needs to be created \nwith an initial capacity.\n\n','OOP',1,NULL),(2415,'Which concurrent collection is Optionally bounded ?','LinkedBlockingQueue','Concurrency',1,NULL),(2416,'public class Hello {\n\n    public static void main(String[] args) {\n        \n        Burnable stick = new Burnable(){\n            public void burn(){\n                System.out.println(\"Theres \"+people+\" people here so get the fire going\");\n            }\n            \n            public int unburn(){\n                System.out.println(\"That\'s impossible\");\n                return 0;\n            }\n            \n            public void shakeoff(){\n                System.out.println(\"That was my shoe!\");\n            }\n            \n            public void lookwhosHere(){\n                people++;\n                System.out.println(\"hey now theres \"+people+\" here.\");\n            }\n            \n        };\n    }\n\n}\n\ninterface Burnable{\n    int people = 10;\n    void burn();\n    void shakeoff();\n    int unburn();\n}','WNC cannot assign a value to final variable people. \n\ninterface variables are implicity constants. ','Concurrency',1,NULL),(2417,'public class Hello<T> {\n    \n    public static void main(String[] args){\n        \n        Dog d = new Dog();\n        \n        ArrayList<? extends Dog> c = new ArrayList<Beagle>();\n        \n        Beagle a = c.get(0);\n    } \n}\n\nclass Animal{}\nclass Dog extends Animal { }\nclass Beagle extends Dog { }\nclass Marly extends Beagle{ }','WNC you cannot guarentee that c wont be pointing to a list<Dog> so \nyou cannot assign what is coming out to a Beagle reference. It could be \nAnimal or Dog.','Concurrency',1,NULL),(2418,'static <T> void doSomething(List<? super T> list1, List<? extends T> list2) { }\n\ndoSomething(new ArrayList<Object>(), new ArrayList<String>());\n\nWould T type evaluate as Object or String?\n','T does not bind to a specific class here. \n\n\nThis call does not bind T to a specific class. Java does not need to know the exact T because of type erasure implementation of the generics. As long as the types that you pass are consistent with the declaration, the code should compile; in your case, lists of Object and String are consistent with the declaration.\n\nLet\'s expand your code a little so that we could force binding of T to a specific type. Perhaps the easiest way to do it is to pass Class<T>, like this:\n\nstatic <T> void doSomething(List<? super T> list1, List<? extends T> list2, Class<T> cl) {\n    System.out.println(cl);\n}\n\nNow let us try calling doSomething with String.class and with Object.class:\n\ndoSomething(new ArrayList<Object>(), new ArrayList<String>(), Object.class);\ndoSomething(new ArrayList<Object>(), new ArrayList<String>(), String.class);\n\nBoth calls successfully compile, producing the output\n\nclass java.lang.Object\nclass java.lang.String','Generics',1,NULL),(2419,'public class WildcardFixed {\n\n    void foo(List<?> i) {\n        fooHelper(i);\n    }\n\n\n    // Helper method created so that the wildcard can be captured\n    // through type inference.\n    private <T> void fooHelper(List<T> l) {\n        l.set(0, l.get(0));\n    }\n\n}','helper methods can be used to capture the wildcard','Generics',1,NULL),(2420,'public class Hello {\n    \n    public static void main(String[] args){\n        ArrayList<Object> dogs = new ArrayList<>();\n        ArrayList<Object> marlies = new ArrayList<>();\n        \n        copy(dogs,marlies);\n    } \n    \n     public static <T> void copy(List<? super T> dest, List<? extends T> src) {\n         for(T t : src){\n             dest.add(t);\n         }\n    }  \n}\n\nclass Animal{}\nclass Dog extends Animal { }\nclass Beagle extends Dog { }\nclass Marly extends Beagle{ }','Compiles fine, any thing coming out of src should be able to be added to dest. \n','Generics',1,NULL),(2421,'public class Hello {\n    \n    public static void main(String[] args){\n        ArrayList<Marly> dogs = new ArrayList<>();\n        ArrayList<Animal> marlies = new ArrayList<>();\n        \n        copy(marlies, dogs);\n    } \n    \n     public static <T> void copy(List<? super T> dest, List<? extends T> src) {\n         for(T t : src){\n             dest.add(t);\n         }\n    }  \n}\n\nclass Animal{}\nclass Dog extends Animal { }\nclass Beagle extends Dog { }\nclass Marly extends Beagle{ }','compiles, anything coming the source has to be of type that is safe to be added\nto the dest. ','Generics',1,NULL),(2422,'public class Hello {\n  public static void main(String[] args){\n      LinkedHashSet<Turtle> t = new LinkedHashSet<>();\n      t.add(new Turtle(1)); t.add( new Turtle(2)); t.add(new Turtle(1));\n      t.add(new Turtle(1)); t.add( new Turtle(2)); t.add(new Turtle(1));\n      t.add(new Turtle(1)); t.add(new Turtle(1)); t.add(new Turtle(1));\n      t.add(new Turtle(1)); t.add(new Turtle(1)); t.add(new Turtle(1));\n      \n      System.out.println(t.size());\n      for(Turtle x : t){\n          System.out.println(x);\n      }\n\n  }\n   \n}\n\ninterface Hungry<E> { void munch(E x); }\nabstract class Animal { }\nabstract class Plant { }\nclass Grass extends Plant { }\n\nclass Turtle {\n    int size;\n    String name;\n    public Turtle(int z){\n        size = z;\n        name = \"Turtle \"+size;\n    }\n    \n    public boolean equals(Object o){\n        return (this.size == ((Turtle)o).size);\n    }\n    \n    public String toString(){\n        return name;\n    }\n    \n    //public int hashCode() { return size/5; }\n}','12\nTurtle 1\nTurtle 2\nTurtle 1\nTurtle 1\nTurtle 2\nTurtle 1\nTurtle 1\nTurtle 1\nTurtle 1\nTurtle 1\nTurtle 1\nTurtle 1\n\nwhile it\'s true that Set don\'t allow duplicates it disallows them by using the \nequals method it can only use equals to among elements in the same bucket. So Because\nturtle didn\'t implement hashCode() all the elements went into seperate buckets\nand there was nothing to compare against.','Collections',1,NULL),(2423,'public class Hello<T> {\n    public static void main(String[] args){\n        Animal cat = new Animal(5);\n        Animal bear = new Bear();\n        \n        cat.eat();\n        Animal.eat();\n        bear.eat();\n        Bear.eat();\n\n    } \n }\n\nclass Animal{\n    private int size;\n    public Animal(int s){\n        size = s;\n    }\n    public static void eat(){\n        System.out.println(\"all animals eat\");\n    }\n    public void makeSound(){\n            System.out.println(\"Sound!\");\n            \n    }\n    \n    public int getSize(){\n        return size;\n    }\n\n    public boolean equals(Object o){\n        // equals without instanceof \n        if(((Animal)o).getSize() == this.size){\n            return true;\n        } else {\n            return false;\n        }\n        \n    }\n}\n\nclass Bear extends Animal{\n    private static int ALLBEARSAREBIG = 100;\n    \n    public Bear(){\n        super(ALLBEARSAREBIG);\n        \n    }\n    \n    public static void eat(){\n        System.out.println(\"Eat salmon\");\n    }\n    \n}','all animals eat\nall animals eat\nall animals eat\nEat salmon','OOP',1,NULL),(2424,'class Hello {\n    public static void main(String[] args) {     \n        Path p1 = Paths.get(\"/home/max/tmp/\");\n        Path p2 = Paths.get(\"/tmp/google/file.txt\");\n        Path p3 = Paths.get(\"tmp/google/file.txt\");\n        System.out.println(p1.resolve(p2));\n        System.out.println(p1.relativize(p2));\n        System.out.println(p1.resolve(p3));\n        System.out.println(p1.relativize(p3));\n        \n    }\n\n}','/tmp/google/file.txt\n../../../tmp/google/file.txt\n/home/max/tmp/tmp/google/file.txt\nException in thread \"main\" java.lang.IllegalArgumentException: \'other\' is different type of Path\n\nif other is an abolute path resolve returns the other, p2 is  an absolute \npath.\n\na relative path cannot be contructed if only one of the paths have a root \ncomponent. ','Input/Output',1,NULL),(2425,'If one path is absolute and the other is relative relativize will throw \nan Illegal argument Exception.\n\nBoth have to be either relative or absolute. \n\n	Path p1 = Paths.get(\"/home/maxbisesi\");\n        Path p2 = Paths.get(\"Documents/Code\");\n        \n        System.out.println(p1.relativize(p2));\n        System.out.println(p1.resolve(p2));','got it\n\nrelativize: IllegalArgumentException\nresolve: /home/maxbisesi/Documents/Code','Input/Output',1,NULL),(2426,'If the other path is absolute relativize will return the other \n\n    \n        Path p1 = Paths.get(\"/home/max/tmp/\");\n        Path p2 = Paths.get(\"/tmp/google/file.txt\");\n\n        System.out.println(p1.resolve(p2));\n\n	/tmp/google/file.txt','got it','Input/Output',1,NULL),(2427,'class Hello {\n    public static void main(String[] args) {     \n        Path p1 = Paths.get(\"/home/max/tmp/\");\n        Path p2 = Paths.get(\"/tmp/google/file.txt\");\n        Path p3 = Paths.get(\"tmp/google/file.txt\");\n        Path p4 = Paths.get(\"src/dist/all\");\n        System.out.println(p1.resolve(p2));\n        System.out.println(p1.relativize(p2));\n        System.out.println(p1.resolve(p3));\n        System.out.println(p2.resolve(p3));\n        System.out.println(p3.relativize(p4));\n        \n    }\n\n}','/tmp/google/file.txt\n../../../tmp/google/file.txt\n/home/max/tmp/tmp/google/file.txt\n/tmp/google/file.txt/tmp/google/file.txt\n../../../src/dist/all','Input/Output',1,NULL),(2428,'Matcher.end() gives the position after the last character. \n\n	Pattern p = Pattern.compile(\".*y\");\n        Matcher m = p.matcher(\"yyxxxyxx\");\n						 012345678\n        \n        while(m.find()){\n            System.out.println(m.start());\n            System.out.println(m.group());\n            System.out.println(m.end());\n        }\n\nm.end() is 6','got it ','Strings',1,NULL),(2429,'public class Hello{\n    public static void main(String[] args){\n        Bango b1 = new Bango();\n        Bango b2 = new Bongo();\n        Bango b3 = new Bingo();\n        \n        Bongo b4 = b2;\n        Bongo b5 = (Bongo)b1;\n        Bango b6 = b3;\n        Bango b7 = (Bango) b3;\n        Bingo b8 = (Bingo)b1;\n        Bingo b9 = (Bingo) b3;\n        Bango b10 = (Bongo) b3;\n    \n    }\n}\n\nclass Bango { }\nclass Bongo extends Bango { }\nclass Bingo extends Bongo { }\n\nwhich throw a ClassCastException ?','b5 and b8\n\nA class Cast will result from trying to downcast. ','Strings',1,NULL),(2430,'public class Hello {\n    private String name = \"marco\";\n    private final static String gem = \"Gemini\";\n    private static String west = \"Eunech\";\n   \n    public static void main(String[] args) {\n        Hello h = new Hello();\n        h.methodlocal();\n    }\n    \n    public static void methodlocal(){\n        final int y = 56;\n        //System.out.println(name); //wouldnt compile\n        System.out.println(gem);\n        \n        \n        class Zombie {\n            public int size;\n            public static final int num = 5;\n        \n            public Zombie(int x){ size = x; System.out.println(gem); System.out.println(west);} //System.out.println(name); }\n            public void mone(){\n                System.out.println(\"ughhhg: \"+ size);\n            }\n            \n            public void accessTheLiving(){\n                System.out.println(\"local var: \"+y);\n            }\n            \n        }\n        \n        Zombie zom = new Zombie(7);\n        \n    }\n\n}','Gemini\nGemini\nEunech','Inner Classes',1,NULL),(2431,'public class Hello<T> {\n    public static void main(String[] args){\n\n        ArrayList<? extends Animal> c = makeArrayList(new Animal(5));\n        \n        \n    } \n    public static <G extends Animal> ArrayList<G> makeArrayList(G g){\n        ArrayList<G> genlist = new ArrayList();\n        \n        Animal max = new Animal(100);\n        Animal bear = new Animal(45);\n        Animal Hippo = new Animal(45);\n        \n        genlist.add(max); \n        genlist.add(bear);\n        genlist.add(Hippo);\n        return genlist;\n        \n    }\n}','Will not compile, at compile time the compiler does not know what type G is\ngoing to be even though its runtime type will be right, this can still not be\nallowed to compile. ','Generics',1,NULL),(2432,'public class Hello {\n    public static void main(String[] args){\n\n        ArrayList<? extends Animal> c = makeArrayList(new Animal());\n        ArrayList<? extends Animal> b = makeArrayList(new Dog());\n        \n        \n    } \n    public static <G extends Animal> ArrayList<G> makeArrayList(G g){\n        ArrayList<G> genlist = new ArrayList();\n        genlist.add(g);\n        \n        return genlist;\n        \n    }\n}\n\nclass Dog extends Animal{}\nclass Beagle extends Dog { }\nclass Animal{}','Compiles','Generics',1,NULL),(2433,'public class Hello {\n    public static void main(String[] args){\n\n        ArrayList<? extends Animal> c = makeArrayList(new Animal());\n        ArrayList<? extends Animal> b = makeArrayList(new Dog());\n        ArrayList<? super Dog> a = makeArrayList(new Beagle());\n        \n        \n    } \n    public static <G extends Animal> ArrayList<G> makeArrayList(G g){\n        ArrayList<G> genlist = new ArrayList();\n        genlist.add(g);\n        \n        return genlist;\n        \n    }\n}\n\nclass Dog extends Animal{}\nclass Beagle extends Dog { }\nclass Animal{}','Will not compile, \n\nhere makeArrayList is only bounded by the INPUT the output is pretty straightforward\nit is excactly type G. Which is Below Dog in the Heirarchy so a Beagle \nList could not be applied to a ? super Dog list. ','Generics',1,NULL),(2434,'public class Hello {\n    public static void main(String[] args){\n\n        ArrayList<? extends Animal> c = makeArrayList(new Animal());\n        ArrayList<? extends Animal> b = makeArrayList(new Dog());\n        ArrayList<? super Beagle> a = makeArrayList(new Beagle());\n        \n        \n    } \n    public static <G extends Animal> ArrayList<G> makeArrayList(G g){\n        ArrayList<G> genlist = new ArrayList();\n        genlist.add(g);\n        \n        return genlist;\n        \n    }\n}\n\nclass Dog extends Animal{}\nclass Beagle extends Dog { }\nclass Animal{}','This will compile.','Generics',1,NULL),(2435,'public class Hello {\n    public static void main(String[] args){\n        Printer<String> x = Printer.getInstance();\n\n    }\n    public static <T> void addAnimal(List<T> animals) {\n	animals.add(new Dog());\n    }\n    \n    public <G> ArrayList<G> makeArrayList(G g){\n        ArrayList<G> genlist = new ArrayList();\n        genlist.add(g);\n        return genlist;\n        \n    }\n}\n\nclass Dog{ }','Will not compile, cannot add Dog to ArrayList typed for T ','Generics',1,NULL),(2436,'public class Hello {\n    \n    public static void main(String[] args){\n        Path file = Paths.get(\"/home/maxbisesi/Public/Data/sumOftwointsinarray.txt\");\n        FileSearcher fs = new FileSearcher(file,\"\\\\b\\\\w\\\\w\\\\w\\\\b\");\n        ExecutorService es = Executors.newCachedThreadPool();\n        System.out.println(\"We\'re wating on your search results\");\n        Future<HashMap<Integer,String>> futuresearch = es.submit(fs);\n        \n        try{\n            HashMap<Integer,String> searchresults;\n            searchresults = futuresearch.get();\n            HashMap<Integer,String> moreresults = futuresearch.get();\n            \n            if(searchresults == null){\n                System.out.println(\"There were no results bro\");\n                System.exit(0);\n            }\n            for(Map.Entry<Integer,String> entry : searchresults.entrySet()){\n                System.out.println(entry.getKey()+\" \"+entry.getValue()+\"\\n\");\n            }\n            \n        }catch(ExecutionException | InterruptedException e){\n            System.out.println(e);\n        }\n    }\n}\n\nclass FileSearcher implements Callable<HashMap<Integer,String>> {\n    private Path fileToLoad;\n    private String regex;\n    public FileSearcher(Path file,String reg){\n        fileToLoad = file;\n        regex = reg;\n    }\n    \n    public HashMap<Integer,String> call() throws IOException{\n        int linenum = 0;\n        HashMap<Integer,String> map = new HashMap<>();\n        BufferedReader br = new BufferedReader(new FileReader(fileToLoad.toFile()));\n        Pattern p = Pattern.compile(regex);\n        Matcher m;\n        String line;\n        while((line = br.readLine()) != null){\n            map.put(++linenum,line);\n        }\n        return map;\n    }\n}\n\nWhat are the flaws here ? ','First if you dont shutdown an executorService it will keep running and the \nprogram will never end.\n\nSecond the regex patter created is never applied to the lines coming in.','General',1,NULL),(2437,'public class Hello {\n    \n    public static void main(String[] args){\n        String in = \"1 a 10 . 100 1000\";\n        Scanner s = new Scanner(in);\n        int accum\n        = 0;\n        for (int x = 0; x < 4; x++) {\n        accum += s.nextInt();\n        }\n        System.out.println(accum);\n    }\n}','Exception in thread \"main\" java.util.InputMismatchException\n\nfor trying to read a string in as an int thats an exception','Strings',1,NULL),(2438,'public static void main(String[] args) {\n            int x = 7;\n            assert (x == 6) ? \"x == 6\" : \"x != 6\";\n        }\n    }','Will not compile, String cannot be converted to boolean.\n\nthe additional info in an assert statement must be a string. ','Exceptions',1,NULL),(2439,'public class Hello {\n\n    public static void main(String[] args) {\n        try {\n            new Hello().go();\n        } catch (Exception e) {\n            System.out.println(e);\n        }\n    }\n\n    synchronized void go() throws InterruptedException {\n        Thread t1 = new Thread();\n        t1.start();\n        System.out.print(\"1 \");\n        t1.wait(5000);\n        System.out.print(\"2 \");\n    }\n}','IllegalMonitorStateException\n\nthe method go() is synchronized, that means it will lock onto to the currently\nexecuting object. which Here is this, or the \'new Hello()\'\n\na new Thread is started and then waited on but thats not allowed because go\nis synchronized onto the current object.\n\nit should be:\n\n	Thread t1 = new Thread();\n        t1.start();\n        synchronized(t1){\n            System.out.print(\"1 \");\n            t1.wait(5000);\n            System.out.print(\"2 \");\n        }\n        \n        System.out.println(\"All done, main thread\");','Threads',1,NULL),(2440,'public class Hello {\n\n    public static void main(String[] args) {\n        try {\n            new Hello().go();\n        } catch (Exception e) {\n            System.out.println(e);\n        }\n    }\n\n    synchronized void go() throws InterruptedException {\n        Thread t1 = new Thread();\n        t1.start();\n        synchronized(t1){\n            System.out.print(\"1 \");\n            t1.wait(5000);\n            System.out.print(\"2 \");\n        }\n        \n        System.out.println(\"All done, main thread\");\n    }\n}','1 2 All done, main thread','Threads',1,NULL),(2441,'class Printer<? extends Animal> {\n    private ArrayList<T> joblist = new ArrayList<>();\n    private T instance;\n    \n    public Printer(){\n        \n    }\n    \n    public Printer(T b){\n       instance = b;\n    }\n    \n    public void addJob(T t){\n        joblist.add(t);\n    }\n    \n    public void makeSound() {\n        instance.makeSound();\n    }\n    \n    public T getAnewT(){\n        return instance;\n    }\n}\n\nclass Animal{public void makeSound(){\n            System.out.println(\"Sound!\");\n}\n}\nclass Dog extends Animal{}\nclass Beagle extends Dog{}','WNC, \n\nyou cannot use a wildcard when creating a Generic class. ','Generics',1,NULL),(2442,' public static void main(String[] args) {\n        String s = null;\n        if(s instanceof String){ System.out.println(\"It Worked\"); } \n        else { System.out.println(\"No\"); }\n \n    }','If a reference is null it is not an instance of anything. ','General',1,NULL),(2443,'int[] nums = new int[4];\nif(nums instanceof Obejct){\n	sout( \"true\");\n}','true arrays are always objects any array of any type or primitive.','General',1,NULL),(2444,' public static void main(String[] args) {\n        List<Object> strlist = new ArrayList<>();\n        ArrayList<String> arraylst = new ArrayList<>();\n        ArrayList<Object> oblist = new ArrayList<>();\n        \n        if(arraylst instanceof strlist){\n            System.out.println(\"it worked!\");\n        } else{\n            System.out.println(\"no\");\n        }\n\n \n    }','WNC you do not use instanceof to compare two references ','General',1,NULL),(2445,' public static void main(String[] args) {\n        List<Object> strlist = new ArrayList<>();\n        ArrayList<String> arraylst = new ArrayList<>();\n        ArrayList<Object> oblist = new ArrayList<>();\n        \n        if(arraylst instanceof List<String>){\n            System.out.println(\"it worked!\");\n        } else{\n            System.out.println(\"no\");\n        }\n\n \n    }','WNC, instanceof cannot test generic types. Generics are a compile time feature','General',1,NULL),(2446,'public static void main(String[] args) {\n        Path p1 = Paths.get(\"/home/maxbisesi/Public/Data/TextFile1.txt\");\n        \n        System.out.println(p1.getName(0));\n        System.out.println(p1.getName(1));\n        System.out.println(p1.getName(2));\n        System.out.println(p1.getName(3));\n        System.out.println(p1.getName(4));\n    }','home\nmaxbisesi\nPublic\nData\nTextFile1.txt','Input/Output',1,NULL),(2447,'public static void main(String[] args) {\n        Path p1 = Paths.get(\"/home/maxbisesi/Public/Data/TextFile1.txt\");\n        System.out.println(p1.getNameCount());\n        System.out.println(p1.getName(5));\n    }','5\nIllegalArgumentException\n\nwith getName() the element that is the closest to the root directory, has an\nindex of 0. \n\nthrows an IllegalArgumentException if the index is greater than the number \nof elements. ','Input/Output',1,NULL),(2448,'public static void main(String[] args) {\n        Path p1 = Paths.get(\"/home/maxbisesi/Public/Data/TextFile1.txt\");\n        Path p2 = Paths.get(\"maxbisesi/Public/Data\");\n        System.out.println(p1.getRoot());\n        System.out.println(p2.getRoot());\n        \n    }','/\nnull\n\nReturns the root component of this path as a Path object, or null if this \npath does not have a root component.','Input/Output',1,NULL),(2449,'public static void main(String[] args) {\n        Path p1 = Paths.get(\"/home/maxbisesi/Public/Data/TextFile1.txt\");\n        Path p2 = Paths.get(\"maxbisesi/Public/Data\");\n        String root = p1.getRoot();        \n    }','WNC,\n\ngetRoot() getName() subPath() resolve() relativize() toAbsolute() \n\nall return Path objects','Input/Output',1,NULL),(2450,'public static void main(String[] args) {\n\n        Path p1 = Paths.get(\"/home/maxbisesi/Public/Data/TextFile1.txt\");\n        Path p2 = Paths.get(\"maxbisesi/Public/Data\");\n        \n        boolean ab = p1.isAbsolute();\n        boolean ab2 = p2.isAbsolute();\n        \n        System.out.println(ab);\n        System.out.println(ab2);\n        \n    }','true\nfalse','Input/Output',1,NULL),(2451,' public static void main(String[] args) {\n\n        Path p1 = Paths.get(\"/home/maxbisesi/Public/Data/TextFile1.txt\");\n        \n        Path parent = p1.getParent();\n        \n        System.out.println(parent);\n        \n    }','/home/maxbisesi/Public/Data','Input/Output',1,NULL),(2452,' public static void main(String[] args) {\n\n        Path p1 = Paths.get(\"/home/maxbisesi/Public/Data/TextFile1.txt\");\n        Path p2 = Paths.get(\"maxbisesi/Public/Data\");\n        Path p3 = Paths.get(\"maxbisesi\");\n        \n        Path parent = p1.getParent();\n        Path parent2 = p3.getParent();\n        \n        System.out.println(parent);\n        System.out.println(parent2);\n        \n    }','/home/maxbisesi/Public/Data\nnull\n\ngetParent() \n	returns the paths parent or null if the path does not have a parent','Input/Output',1,NULL),(2453,'Path methods getName() and subPath() all use zero based indexs ','true\n\nthe element that is closest to the root directory in the heirarchy has an\nindex of zero. ','Input/Output',1,NULL),(2454,'public static void main(String[] args) {\n\n        Path p1 = Paths.get(\"/home/maxbisesi/Public/Data/TextFile1.txt\");\n        Path p2 = Paths.get(\"maxbisesi/Public/Data\");\n        \n        Path sub = p1.subpath(1,3); \n        \n        System.out.println(sub);\n        \n    }','maxbisesi/Public','Input/Output',1,NULL),(2455,'public static void main(String[] args) {\n\n        Path p1 = Paths.get(\"/home/maxbisesi/Public/Data/TextFile1.txt\");\n        Path p2 = Paths.get(\"maxbisesi/Public/Data\");\n        \n        Path sub = p1.subpath(0,3); \n        \n        System.out.println(sub);\n        \n    }','home/maxbisesi/Public','Input/Output',1,NULL),(2456,'public static void main(String[] args) {\n\n        Path p1 = Paths.get(\"/home/maxbisesi/Public/Data/TextFile1.txt\");\n        Path p2 = Paths.get(\"maxbisesi/Public/Data\");\n        \n        Path sub = p1.subpath(2,5); \n        \n        System.out.println(sub);\n        \n    }','Public/Data/TextFile1.txt\n\n    beginIndex - the index of the first element, inclusive\n    endIndex - the index of the last element, exclusive','Input/Output',1,NULL),(2457,'Path subpath(int beginIndex,int endIndex)\n\n    beginIndex - the index of the first element, inclusive\n    endIndex - the index of the last element, exclusive','learn it','Input/Output',1,NULL),(2458,'public static void main(String[] args) {\n\n        Path p1 = Paths.get(\"/home/maxbisesi/Public/Data/TextFile1.txt\");\n        Path p2 = Paths.get(\"maxbisesi/Public/Data\");\n        \n        Path sub = p1.subpath(2,6); \n        \n        System.out.println(sub);\n        \n    }','IllegalArgumentException\n\nonly 5 elemetns\n\n    beginIndex - the index of the first element, inclusive\n    endIndex - the index of the last element, exclusive','Input/Output',1,NULL),(2459,'public void scrambleFile(Path file) {\n        \n        FileReader inputStream = null;\n        FileWriter outputStream = null;\n\n        try {\n            inputStream = new FileReader(file.toFile());\n            Path fileToWrite = Paths.get(file.getParent().toString(),\"ScrambledFile\"+filecount+\".txt\");\n            outputStream = new FileWriter(fileToWrite.toString());\n\n            int c;\n            while((c = inputStream.read()) != -1){\n                Character a = key.get((char)c);\n                if(a == null){\n                    continue;\n                } else {\n                    outputStream.write((int)a);\n                }\n                \n            }\n            \n            inputStream.close();\n            outputStream.close();\n\n        } catch(IOException e){\n            System.out.println(e);\n        } \n        \n        filecount++;\n    }','will read characters from the first file encode them and put them in the\nnext. ','Input/Output',1,NULL),(2460,'public static void main(String[] args) {\n        double count = -34.45;\n        String s = \" true\";\n        boolean yea = true;\n        boolean nah = false;\n        System.out.printf(\"%1$0(f\",count);\n        \n    }','MissingFormatWidthException\n\nwith - and 0 the width is required.','Input/Output',1,NULL),(2461,'java.util.formatter\n\nthe flags - and 0 require you to specify the width','got it ','Strings',1,NULL),(2462,'what flags in java.util.formatter require you to specify the width ?','- and 0 ','Strings',1,NULL),(2463,'public class Hello extends Thread {\n    public static void main(String[] args){\n        new CodeMaker().start();\n    }\n}\n\nclass CodeMaker  extends Thread {\n    private String code;\n    private int counter;\n    private ArrayList<String> al;\n    private char[] letters = {\'A\',\'B\',\'C\',\'D\',\'E\',\'F\',\'G\',\'H\',\'I\'};\n    \n    public CodeMaker(){\n        counter = 0;\n        al = new ArrayList<>();\n    }\n\n    class SectionGenerator implements Runnable{\n        private String sec = \"\";\n        private Random ran = new Random();\n\n        public void run() {\n            //tried to use notify outside of synchronized context\n            synchronized(this){\n                int x = ran.nextInt(3);\n                int y = ran.nextInt(3);\n                int z = ran.nextInt(3);\n            \n            \n                sec += letters[x];\n                sec += letters[y];\n                sec += letters[z];\n                notifyAll();\n            }\n        }\n        \n        public synchronized String section(){\n            return sec;\n        }\n\n    }\n    \n    class NumberGenerator implements Runnable{\n        private String number = \"\";\n        private Random ran = new Random();\n        \n        public void run(){\n            //tried to use notify outside of synchronized context\n            synchronized(this){\n                int x1 = ran.nextInt(100);\n                int x2 = ran.nextInt(100);\n                int x3 = ran.nextInt(100);\n            \n                number += x1+\".\"+x2+\".\"+x3;\n                notifyAll();\n            }\n        }\n        \n        public synchronized String Number(){\n            return number;\n        }\n    }\n    \n   public synchronized void run(){\n       \n       SectionGenerator sg1 = new SectionGenerator();\n       NumberGenerator ng1 = new NumberGenerator();\n       Thread t1 = new Thread(sg1);\n       Thread t2 = new Thread(ng1);\n       \n       t1.start();\n       t2.start();\n       \n       try{\n        t1.wait();\n        code += sg1.section();\n        t2.wait();\n        code += ng1.Number();\n       } catch(InterruptedException e){\n           \n       }\n       System.out.println(code);\n\n       \n   }\n    \n    \n}\n','IllegalMonitorStateException,\n\nthe running thread was not synchronized onto t1, \nyou must be synchronized onto an object to wait on it.','Threads',1,NULL),(2464,'public class Hello extends Thread {\n    public static void main(String[] args){\n        try(Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees\", \"root\", \"Basketball12\")){\n            String getAllEmployeeNames = \"select first_name,last_name from employees\";\n            Statement st1 = conn.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.TYPE_READ_ONLY);\n            \n            ResultSet empnames = st1.executeQuery(getAllEmployeeNames);\n            \n            empnames.last();\n            \n            System.out.println(empnames.getString(\"first_name\")+\" \"+empnames.getString(\"last_name\"));\n            \n        }catch(SQLException e){\n            System.out.println(e);\n        }\n    }\n}','its CONCUR_READ_ONLY not TYPE_READ_ONLY','JDBC',1,NULL),(2465,'public static void main(String[] args){\n        try(Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees\", \"root\", \"Basketball12\")){\n            String getAllEmployeeNames = \"select first_name,last_name from employees\";\n            Statement st1 = conn.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);\n            \n            ResultSet empnames = st1.executeQuery(getAllEmployeeNames);\n            \n            empnames.absolute(34);\n            System.out.println(empnames.getString(\"first_name\")+\" \"+empnames.getString(\"last_name\"));\n            empnames.previous();\n            System.out.println(empnames.getString(\"first_name\")+\" \"+empnames.getString(\"last_name\"));\n            empnames.deleteRow();\n            System.out.println(empnames.getString(\"first_name\")+\" \"+empnames.getString(\"last_name\"));\n            \n        }catch(SQLException e){\n            System.out.println(e);\n        }\n    }','Cristinel Bouloucos\nKazuhito Cappelletti\n\ncom.mysql.jdbc.NotUpdatable: Result Set not updatable.This result set must \ncome from a statement that was created with a result set type of \nResultSet.CONCUR_UPDATABLE, the query must select only one table, can not \nuse functions and must select all primary keys from that table. See the \nJDBC 2.1 API Specification, section 5.6 for more details.This result set \nmust come from a statement that was created with a result set type of \nResultSet.CONCUR_UPDATABLE, the query must select only one table, can not \nuse functions and must select all primary keys from that table. See the\n JDBC 2.1 API Specification, section 5.6 for more details.','JDBC',1,NULL),(2466,'public class Hello {\n    public static void main(String[] args){\n        try(Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees\", \"root\", \"Basketball12\")){\n            String getAllEmployeeNames = \"select emp_no,first_name,last_name from employees\";\n            Statement st1 = conn.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_UPDATABLE);\n            \n            ResultSet empnames = st1.executeQuery(getAllEmployeeNames);\n            \n            empnames.absolute(34);\n            System.out.println(empnames.getString(\"first_name\")+\" \"+empnames.getString(\"last_name\"));\n            empnames.previous();\n            System.out.println(empnames.getString(\"first_name\")+\" \"+empnames.getString(\"last_name\"));\n            empnames.deleteRow();\n            System.out.println(empnames.getString(\"first_name\")+\" \"+empnames.getString(\"last_name\"));\n            \n        }catch(SQLException e){\n            System.out.println(e);\n        }\n    }\n}','CONCUR_UPDATABLE lets you delete rows. It will save those changes to the underlying db','JDBC',1,NULL),(2467,'public class Hello {\n    public static void main(String[] args){\n        try(Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees\", \"root\", \"Basketball12\")){\n            String getAllEmployeeNames = \"select emp_no,first_name,last_name from employees\";\n            Statement st1 = conn.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE,ResultSet.CONCUR_UPDATABLE);\n            \n            ResultSet empnames = st1.executeQuery(getAllEmployeeNames);\n            \n            empnames.absolute(40);\n            System.out.println(empnames.getString(\"first_name\")+\" \"+empnames.getString(\"last_name\"));\n            empnames.next();\n            System.out.println(empnames.getString(\"first_name\")+\" \"+empnames.getString(\"last_name\"));\n            empnames.next();\n            System.out.println(empnames.getString(\"first_name\")+\" \"+empnames.getString(\"last_name\"));\n\n            empnames.next();\n            System.out.println(empnames.getString(\"first_name\")+\" \"+empnames.getString(\"last_name\"));\n            empnames.updateString(\"first_name\",\"BIG MAX\");\n            empnames.updateRow();\n            System.out.println(empnames.getString(\"first_name\")+\" \"+empnames.getString(\"last_name\"));\n            \n            \n        }catch(SQLException e){\n            System.out.println(e);\n        }\n    }\n}','SCROLL SENSITIVE will show what chagnes you have made. ','JDBC',1,NULL),(2468,'Arrays/Collections must be sorted before being searched. Otherwise results\nwill be unpredictable','','Collections',1,NULL),(2469,'public static void main(String[] args) {\n	String s1 = \"abc\";\n	String s2 = s1;\n	System.out.println(s1+\"d\");\n	System.out.println(s1+\" \"+s2+\" \"+ (s1==s2));\n	\n	StringBuffer sb1 = new StringBuffer(\"abc\");\n	StringBuffer sb2 = sb1;\n	sb1.append(\"d\");\n	System.out.println(sb1+ \" \" + sb2 + \" \" + (sb1==sb2));\n    }','abcd\nabc abc true\nabcd abcd true\n\nstrings are immutable','Strings',1,NULL),(2470,'public static void main(String[] args) throws IOException {\n       File file1 = new File(\"/home/maxbisesi/Public/TestDir/file1\");\n       File file2 = new File(\"/home/maxbisesi/Public/TestDir/file2\");\n       File dir = new File(\"/home/maxbisesi/Public/TestDir\");\n       \n       if(dir.exists() && dir.isDirectory()){\n           file1.createNewFile();\n           file2.createNewFile();\n       } else {\n           dir.mkdir();\n           file1.createNewFile();\n           file2.createNewFile();\n       }\n    } ','builds the directory structure, throwing IOE if necessary','Input/Output',1,NULL),(2471,'public class Hello {\n    public static void main(String[] args){\n        \n    }\n    \n    interface Handeler{\n        void handle();\n    }\n}\n\nclass Adder implements Hello.Handeler {\n        public void handle(){\n            System.out.println(\"I got this.\");\n        }\n}','all inner interfaces are implicitly static','OOP',1,NULL),(2472,'All variables in an interface are implicitly static','got it','OOP',1,NULL),(2473,'interface varialbes are implicitly static and final','got it ','OOP',1,NULL),(2474,'interface hungry{\n    static void milk();\n}','does not compile in java 7','OOP',1,NULL),(2475,'public static void main(String[] args) {\n        String s1 = \"hi\";\n        String s2 = new String(\"hi\");\n        String s3 = \"hi\";\n        \n        if(s1 == s2){\n            System.out.println(\"A\");\n        } else{\n            System.out.println(\"B\");\n        }\n        \n        if(s1 == s3){\n            System.out.println(\"C\");\n        } else {\n            System.out.println(\"D\");\n        }\n        \n        \n    }','B\nC\n\nthe jvm keeps a constant string pool. With strings == checks the similarity\nof the objects themselves.','Strings',1,NULL),(2476,'public static void main(String[] args) {\n        String s1 = \"hi\";\n        String s3 = \"hi\";\n        \n        System.out.println((s1 == s3));\n        \n        \n    }','true\nThe jvm keeps a pool of Strings and == compares the actuall strings ','Strings',1,NULL),(2477,'public class Hello {\n    \n\n    public static void main(String[] args) {\n        Point2D p = new Point2D(10,20);\n        System.out.println(p);\n    }\n    \n}\n\nclass Point2D {\n    private int x,y;\n    \n    public Point2D(int x, int y){\n        x=x;\n    }\n    \n    public String toString(){\n        return x+\",\"+y;\n    }\n}','0,0\n\nx=x only reassigns the passed parameter not the member. \n\nyou must use this.x = x;','OOP',1,NULL),(2478,'public class Hello {\n    \n\n    public static void main(String[] args) {\n        Integer i = 10;\n        Integer j = 11;\n        Integer k = ++i;\n        System.out.println(\"k==j: \"+(k==j));\n        System.out.println(\"k.equals(j): \"+(k.equals(j)));\n    }\n    \n}','k==j: true\nk.equals(j): true\n\nInteger objects are immutable just like strings are. \n\nIf there is an Integer object for a value already exists java will not \ncreate a new object. \n\ntwo integer objects are equal no matter if you use == or equals. Because object \nvalues are all imutable. ','OOP',1,NULL),(2479,'public static void main(String []args) {\n            int []arr1 = {1, 2, 3, 4, 5};\n            int []arr2 = {1, 2, 3, 4, 5};\n            System.out.println(\"arr1 == arr2 is \" + (arr1 == arr2));\n            System.out.println(\"arr1.equals(arr2) is \" + arr1.equals(arr2));\n\n            System.out.println(\"Arrays.equals(arr1, arr2) is \" +java.util.Arrays.equals(arr1, arr2));\n}','false\nfalse \ntrue\n\narray objects dont have an equals method. There\'s is inherited from the \nObject class. \n\nThe two objects are not equal themselves they are both seperate.\n\nArrays class has various methods for testing equality of arrays. ','OOP',1,NULL),(2480,'public class Hello {\n\n        public static void main(String []args) {\n            Animal a = new Animal();\n            Animal b = new Bear();\n            \n            overload(a);\n            overload((Bear)b);\n            overload((Object)b);\n            overload(b);\n            \n        }\n        \n        public static void overload(Animal a){\n            System.out.println(\"Animal\");\n        }\n        public static void overload(Bear b){\n            System.out.println(\"Bear\");\n        }\n        public static void overload(Grizzly g){\n            System.out.println(\"Grizzly\");\n        }\n        public static void overload(Object o){\n            System.out.println(\"Object\");\n        }\n}\n\nclass Animal{}\nclass Bear extends Animal{}\nclass Grizzly extends Bear{}','Animal\nBear\nObject\nAnimal\n\noverloading is based on the static types of the objects\noverridig and runtime resolution resolves to the dynamic type. ','OOP',1,NULL),(2481,'public class Hello {\n\n        public static void main(String []args) {\n                foo(10);\n        }\n        public static void foo(Integer i) { System.out.println(\"foo(Integer)\"); }\n        public static void foo(short i) { System.out.println(\"foo(short)\"); }\n        public static void foo(long i) { System.out.println(\"foo(long)\"); }\n        public static void foo(int ... i) { System.out.println(\"foo(int ...)\"); }\n}','foo(long)\n\nfor an integer literal the jvm matches in the following order:\n\n	int, long,Integer, int...\n\n','OOP',1,NULL),(2482,'public class Hello {\n\n        public static void main(String []args) {\n                foo(null);\n        }\n        public static void foo(Integer i) { System.out.println(\"foo(Integer)\"); }\n        public static void foo(short i) { System.out.println(\"foo(short)\"); }\n        public static void foo(long i) { System.out.println(\"foo(long)\"); }\n        public static void foo(int ... i) { System.out.println(\"foo(int ...)\"); }\n}','WNC reference to foo is ambiguous','OOP',1,NULL),(2483,'enum Cards{ A,B,C,D };\npublic class Hello {\n\n        public static void main(String []args) {\n                for(Cards card: Cards.values()){\n                    System.out.println(card +\" \");\n                }\n        }\n\n}','A\nB\nC\nD\n\nhow to iterate through an enum. \n\nuse values()','General',1,NULL),(2484,'abstract class AbstractBook {\n    public String name;\n}\n\ninterface sleepy{\n    public String name = \"undefined\";\n}\n\nclass Book extends AbstractBook implements sleepy{\n    public Book(String name){\n        this.name = name;\n    }\n            \n}\npublic class Hello {\n\n        public static void main(String []args) {\n           AbstractBook ab = new Book(\"Diamonds\");\n            System.out.println(ab.name);\n        }\n\n}','WNC,\n\nreference to name is ambiguous','General',1,NULL),(2485,'public class Hello {\n\n    public static void main(String []args) {\n        Deque<Integer> deque = new ArrayDeque<>();\n        deque.addAll(Arrays.asList(1, 2, 3, 4, 5));\n        System.out.println(\"The removed element is: \" + deque.remove());\n    }\n}','the removed element is 1\n\nDeque is a double ended queue. \n\ncan be added and removed from the head or tail. ','General',1,NULL),(2486,'Dequeue methods:\n\n           First Element (Head) 	             Last Element (Tail)\n\n	Throws exception 	Special value 	Throws exception 	Special value\nInsert: 	addFirst(e) 	offerFirst(e) 	addLast(e) 	offerLast(e)\nRemove:	removeFirst() 	pollFirst() 	removeLast() 	pollLast()\nExamine: 	getFirst() 	peekFirst() 	getLast() 	peekLast()','got it ','Collections',1,NULL),(2487,'a LinkedList is a Dequeue','true','Collections',1,NULL),(2488,' public static void main(String []args) {\n        Deque<Integer> d = new ArrayDeque<>(5);\n        d.add(5);\n        d.add(1);\n        d.add(7);\n        d.add(1);\n        d.add(3); \n        d.add(9);\n        \n        System.out.println(d.getFirst());\n        System.out.println(d.getLast());\n        System.out.println(d.pollFirst());\n        System.out.println(d.pollLast());\n        System.out.println(d.removeFirst());\n        System.out.println(d.removeLast());\n    }','5\n9\n5\n9\n1\n3\n\n','Collections',1,NULL),(2489,'Dequeu whats the difference between pollFirst and removeFirst','remove throws an exception if the queue is empty','Collections',1,NULL),(2490,'public class Hello {\n\n    public static void main(String []args) {\n        Deque<Integer> d = new ArrayDeque<>(5);\n        d.add(1);\n        d.add(2);\n        d.add(3);\n        d.add(4);\n        d.add(5); \n        d.add(6);\n        \n        for(int i = 0; i < 10; i++){\n            System.out.println(d.removeLast());\n        }\n    }\n}','6\n5\n4\n3\n2\n1\nException in thread \"main\" java.util.NoSuchElementException\n\nremove throws an exception if queue is empty','Collections',1,NULL),(2491,'public class Hello {\n\n    public static void main(String []args) {\n        Deque<Integer> d = new ArrayDeque<>(5);\n        d.add(1);\n        d.add(2);\n        d.add(3);\n        d.add(4);\n        d.add(5); \n        d.add(6);\n        \n        for(int i = 0; i < 10; i++){\n            System.out.println(d.pollLast());\n        }\n    }\n}','6\n5\n4\n3\n2\n1\nnull\nnull\nnull\nnull\n\npoll returns null if empty','Collections',1,NULL),(2492,'public static void main(String []args) {\n        Deque<Integer> d = new ArrayDeque<>(5);\n        d.add(1);\n        d.add(2);\n        d.add(3);\n        d.add(4);\n        d.add(5); \n        d.add(6);\n        \n        for(int i = 0; i < 10; i++){\n            System.out.println(d.element());\n        }\n    }','1\n1\n1\n1\n1\n1\n1\n element retrrieves but does not remove the head, similar to peek() only \nelement throws an exception if dequeu is empty','Collections',1,NULL),(2493,'which dequeue methods throw exceptions if the queue is empty ? \n','getFirst getLast element removeFirst removeLast remove\n\nremove and removeFirst are equivalent','Collections',1,NULL),(2494,'A dequeue is FIFO therefore the methods that add and addLast are\nequivalent\n\nwhere the ones that remove and removeFirst are equivalent. ','cool','Collections',1,NULL),(2495,'public static void main(String []args) {\n\n            String pattern = \"a*b+c{3}\";\n            String []strings = { \"abc\", \"abbccc\", \"aabbcc\", \"aaabbbccc\" };\n            for(String str : strings) {\n                System.out.print(Pattern.matches(pattern, str) + \" \");\n            }\n    }','false true false true','Strings',1,NULL),(2496,' public static void main(String []args) {\n\n            String pattern = \"a*b+c+\";\n            String []strings = { \"abc\", \"abbccc\", \"aabbcc\", \"aaabbbccc\" };\n            for(String str : strings) {\n                System.out.print(Pattern.matches(pattern, str) + \" \");\n            }\n    }','true true  true true\n\n+ one or more \n* zero or more','Strings',1,NULL),(2497,'class InvalidKeyException extends IllegalArgumentException{ }\n\nclass New {\n    public void foo() throws InvalidKeyException{ }\n}\npublic class Hello extends New {\n\n    public static void main(String []args) {\n        new Hello().foo();\n    }\n    \n    public void foo(){\n        throw new InvalidKeyException();\n    }\n        \n}','will compile and throw InvalidKeyException,\n\nfirst an overriden method does not have to throw an excpeiton if its super does\n\nsecond IllegalArgumentException is a runtime exception anyway so it does \nnot have to be declared thrown. ','Exceptions',1,NULL),(2498,'public static void main(String []args) {\n        \n        try {\n            int i = 10/0; // LINE A\n            System.out.print(\"after throw -> \");\n        } catch(ArithmeticException ae) {\n            System.out.print(\"in catch -> \");\n            return;\n        } finally {\n            System.out.print(\"in finally -> \");\n        }\n            System.out.print(\"after everything\");\n    }','in catch -> in finally->\n\nreturn means the function will return but finally will still be executed first.\n\n','Exceptions',1,NULL),(2499,'public static void main(String []args) {\n	try {\n		assert false;\n	} catch(RuntimeException re) {\n		System.out.println(\"RuntimeException\");\n	} catch(Exception e) {\n		System.out.println(\"Exception\");\n	} catch(Error e) {\n		// LINE A\n		System.out.println(\"Error\" + e);\n	} catch(Throwable t) {\n		System.out.println(\"Throwable\");\n	}\n}\n\njava -ea Hello','Error + e \n\nyou should never catch an assertion error but if you were to It would be\ncaught by \'Error\'','Exceptions',1,NULL),(2500,'public class Hello {\n\n    public static void main(String[] args) {\n        String[] fileList = {\"/file1.txt\", \"/subdir/file2.txt\", \"/file3.txt\"};\n        for (String file : fileList) {\n            try {\n                new File(file).mkdirs();\n            } catch (Exception e) {\n                System.out.println(\"file creation failed\");\n                System.exit(-1);\n            }\n        }\n   }\n}','creates all the files and directories','Input/Output',1,NULL),(2501,'public class Hello {\n\n    public static void main(String[] args) {\n      String names = \"<bob> romeo. Allen> ^ Clark\";\n      Set<String> words = new TreeSet<>();\n      try(Scanner tokenizer = new Scanner(names)){\n          tokenizer.useDelimiter(\"\\\\W\");\n          while(tokenizer.hasNext()){\n              String word = tokenizer.next();\n              if(!word.trim().equals(\"\")){\n                  words.add(word);\n              }\n          }\n          for(String word : words){\n              System.out.println(word);\n          }\n      }\n   }\n}','Allen\nClark\nbob\nromeo\n\nthis shows that TreeSets sort there elements. And Capitols sort before lowers','Strings',1,NULL),(2502,'Path wordpadPath = Paths.get(\"C:\\\\Program Files\\\\Windows NT\\\\Accessories\\\\wordpad.exe\");\nSystem.out.println(wordpadPath.subpath(beginIndex, endIndex));\n \nWhat are the values of the integer values beginIndex and endIndex in this program that will result in this code\nsegment printing the string “Program Files” as output?\n\na) beginIndex = 1 and endIndex = 2\nb) beginIndex = 0 and endIndex = 1\nc) beginIndex = 1 and endIndex = 1\nd) beginIndex = 4 and endIndex = 16','0 1 \n\nwith subpath the element closest to the root is 0, the ending index is exclusive','Input/Output',1,NULL),(2503,'Which one of the following options is a correct way to create a watch service for watching a directory for\nchanges?\n\nWatchService watch = FileSystems.getDefault().newWatchable();\nWatchService watcher = FileSystems.getDefault().newWatchService();\nWatchService dirWatcher = FileSystems.getDefault().newDirectoryWatchService();\nWatchService fileWatcher = FileSystems.getNewFileWatchService();\nWatchService fileDirWatcher = WatchService.getNewFileDirectoryWatchService();','cool','Input/Output',1,NULL),(2504,'a) Objects of type Statement can handle IN, OUT, and INOUT parameters.\nb) PreparedStatement is used for executing stored procedures.\nc) You can get an instance of PreparedStatement by calling prepareStatement() method in the Connection\ninterface.\nd) CallableStatement extends the PreparedStatement class; PreparedStatement in turn extends the Statement\nclass.\ne) The interface Statement and its derived interfaces implement the AutoCloseable interface, hence it can be used\nwith try-with-resources statement.','c e \n\nd is wrong because CallabeStatement PreparedStatement, and Statement \nare not classes they are interfaces.\n','JDBC',1,NULL),(2505,'// assume that connection is successfully established to the database\nconnection.setAutoCommit(true);\nStatement statement = connection.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE,\nResultSet.CONCUR_UPDATABLE);\nresultSet = statement.executeQuery(\"SELECT * FROM TempSensor\");\n \n// assume that the initial value of temp is \"0\" in the table\n \nresultSet.moveToInsertRow();\nresultSet.updateString(\"temp\", \"100\");\nresultSet.insertRow();\nSavepoint firstSavepoint = connection.setSavepoint();\n \nresultSet.moveToInsertRow();\nresultSet.updateString(\"temp\", \"200\");\nresultSet.insertRow();\nSavepoint secondSavepoint = connection.setSavepoint();\n \nresultSet.moveToInsertRow();\nresultSet.updateString(\"temp\", \"300\");\nresultSet.insertRow();\nSavepoint thirdSavepoint = connection.setSavepoint();\n \nconnection.rollback(secondSavepoint);\nconnection.commit();','sqlexception autocommit is true. \n\nyou cannot set a savepoint, rollback, or commit with autocommit on','JDBC',1,NULL),(2506,'class Worker extends Thread {\n    public void run() {\n        System.out.println(Thread.currentThread().getName());\n    }\n}\n \nclass Hello {\n    public static void main(String []args) throws InterruptedException {\n        Thread.currentThread().setName(\"Master \");\n        Thread worker = new Worker();\n        worker.setName(\"Worker \");\n        worker.start();\n        Thread.currentThread().join();\n        System.out.println(Thread.currentThread().getName());\n    }\n}','worker\n\nthen hangs...\n\nwhen the current thread joins onto itself to terminate it never does because\nit is waiting for itslef.','Threads',1,NULL),(2507,'class Hello {\n    public static void main(String []args) throws InterruptedException {\n        List list = Arrays.asList(10,5,10,20);\n        System.out.println(list);\n        System.out.println(new HashSet(list));\n        System.out.println(new TreeSet(list));\n        System.out.println(new ConcurrentSkipListSet(list));\n    }\n}','[10, 5, 10, 20]\n[20, 5, 10]\n[5, 10, 20]\n[5, 10, 20]\n\nconcurrentSkipListSet is sorted.','Collections',1,NULL),(2508,'Assume that you’ve the following resource bundles in your classpath:\nResourceBundle.properties\nResourceBundle_ar.properties\nResourceBundle_en.properties\nResourceBundle_it.properties\nResourceBundle_it_IT_Rome.properties\n \nAlso assume that the default locale is English (US), where the language code is en and country code is US. Which\none of these five bundles will be loaded for the call\nloadResourceBundle(\"ResourceBundle\", new Locale(\"fr\", \"CA\", \"\"));?\n \na) ResourceBundle.properties\nb) ResourceBundle_ar.properties\nc) ResourceBundle_en.properties\nd) ResourceBundle_it.properties\ne) ResourceBundle_it_IT_Rome.properties','c\n\nsince java cant find \n	ResourceBundle_fr_CA.properties\n	ResourceBundle_fr.properties\n\njava will search for canidate locales for teh base bundle named ResourceBundle and \na default locale\n\n	ResourceBundle_en_US.properties\n	ResourceBundle_en.properties','Locale',1,NULL),(2509,'public static void main(String []args) throws InterruptedException {\n        int i = 012;\n        int a = 10.0l;\n        int b = 10.0f;\n        int c = 10.0;\n    }','only i will compile.\n\nputting a 0 in front of the numbers indicates that it is an octal which can \nbe applied to ints. ','General',1,NULL),(2510,' public static void main(String []args) throws InterruptedException {\n        byte b = 100;\n        int i = 3456;\n        short s = 400;\n        long l = 6000;\n        float f = 356.0f;\n        double d = 45000.0;\n        \n        //commented assingments do not compile\n        i = b;\n        // b = i;\n        i = s;\n        //s = i;\n        l = i;\n        //i = l;\n        f = i;\n        //i = f;\n        f = l;\n        //l = f;\n        d = f;\n        //f = d;\n        d = s;\n        l = s;\n        l = b;\n        d = i;\n        f = s;\n        l = b;  \n    }','ok','General',1,NULL),(2511,'public static void main(String []args){\n        Boolean b = null;\n        System.out.println(b ? true: false);\n                \n    }','NPE','General',1,NULL),(2512,'class Point {\n        private int x = 0, y;\n        public Point(int x, int y) {\n        this.x = x;\n        this.y = y;\n    }\n        // DEFAULT_CTOR\n}\n\na) public Point() {\n	this(0, 0);\n	super();\n}\n \nb) public Point() {\n	super();\n	this(0, 0);\n}\n \nc) private Point() {\n	this(0, 0);\n}\n \nd) public Point() {\n	this();\n}\n \ne) public Point() {\n	this(x, 0);\n}\n\n\nWhich one of the following definitions of the Point constructor can be replaced without compiler\nerrors in place of the comment DEFAULT_CTOR?',' private Point() {\n	this(0, 0);\n}\n\nyou cannot call super and this. super or this should be the first calls \nin a constructor. ','General',1,NULL),(2513,'interface EnumBase { }\n \nenum AnEnum implements EnumBase {ONLY_MEM;}\n \nclass Hello {\n    public static void main(String []args) {\n        if(AnEnum.ONLY_MEM instanceof AnEnum) {\n            System.out.println(\"yes, instance of AnEnum\");\n        }\n        if(AnEnum.ONLY_MEM instanceof EnumBase) {\n            System.out.println(\"yes, instance of EnumBase\");\n        }\n        if(AnEnum.ONLY_MEM instanceof Enum) {\n            System.out.println(\"yes, instance of Enum\");\n        }\n    }\n}','yes, instance of AnEnum\nyes, instance of EnumBase\nyes, instance of Enum\n\n\nyes, instance of AnEnum\nyes, instance of EnumBase\nyes, instance of Enum\n\nAn enumeration can implement an interface (but cannot extend a class, or cannot be\na base class).\nEach enumeration constant is an object of its enumeration type. An enumeration\nautomatically extends the abstract class java.util.Enum. Hence, all the three instanceof\nchecks succeed.','General',1,NULL),(2514,'enums can implement an interface,\n\ncannot extend a class, they already implicitly extend Enum class\n\nno class can extend an enum\n\nenum constants are objects of its class','ok','General',1,NULL),(2515,'Which of the following statements are true with respect to enums? \n\na) An enum can have private constructor.\nb) An enum can have public constructor.\nc) An enum can have public methods and fields.\nd) An enum can implement an interface.\ne) An enum can extend a class.','a) Enum can have private constructor.\nc) Enum can have public methods and fields.\nd) Enum can implement an interface.','General',1,NULL),(2516,'enums cannot have public or protected constructors \n\nwhy ?','Think of Enums as a class with a finite number of instances. \nThere can never be any different instances beside the ones you initially \ndeclare.\n\nThus, you cannot have a public or protected constructor, because that\n would allow more instances to be created.','General',1,NULL),(2517,'interface EnumBase { }\n \nenum AnEnum implements EnumBase {\n    ONLY_MEM;\n    private AnEnum(){\n        \n    }\n}','compiles','General',1,NULL),(2518,'interface EnumBase { }\n \nenum AnEnum implements EnumBase {\n    ONLY_MEM;\n    public AnEnum(){\n        \n    }\n}','WNC','General',1,NULL),(2519,'interface EnumBase { }\n \nenum AnEnum implements EnumBase {\n    ONLY_MEM;\n     AnEnum(){\n        \n    }\n}','compiles','General',1,NULL),(2520,'interface EnumBase { }\n \nenum AnEnum implements EnumBase {\n    ONLY_MEM;\n    protected AnEnum(){\n        \n    }\n}','WNC','General',1,NULL),(2521,'	class ClassA {}\n	interface InterfaceB {}\n	class ClassC {}\n\n	class Test extends ClassA implements InterfaceB {\n		String msg;\n		ClassC classC;\n	}\n\na) Class Test is related with ClassA with a has-a relationship.\nb) Class Test is related to ClassC with a composition relationship.\nc) Class Test is related with String with an is-a relationship.\nd) Class ClassA is related with InterfaceB with an is-a relationship.','b)\nClass Test is related with ClassC with a composition relationship.\nWhen a class inherits from another class, they share an is-a relationship. On the other\nhand, if a class uses another class (by declaring an instance of another class), then the first\nclass has a has-a relationship with the used class.','General',1,NULL),(2522,'a) j  ava.text.Format is the abstract base class that supports formatting of locale sensitive\ninformation such as date, time, and currency\n\nb) j  ava.text.CustomTimeFormat allows you to define custom patterns for processing\ntime for specific locales.\n\nc) j  ava.text.NumberFormat derives from the java.text.Format class; it is the base\nclass for processing numbers, currency, etc. in a locale sensitive way.\n\nd) j  ava.text.DateFormat derives from the java.text.Format class; it is the base class\nfor processing date and time information based on locale.','a) java.text.Format is the abstract base class that supports formatting of locale sensitive\ninformation such as date, time, and currency\nc) java.text.NumberFormat derives from java.text.Format class; it is the base class for\nprocessing numbers, currency, etc. in a locale sensitive way.\nd) java.text.DateFormat derives from java.text.Format class; it is the base class for\nprocessing date and time information based on locale.\nClass java.text.SimpleDateForma','General',1,NULL),(2523,'Which of the following classes in the java.util.concurrent.atomic package inherit from\njava.lang.Number? (Select all that apply).\na) AtomicBoolean\nb) AtomicInteger\nc) AtomicLong\nd) AtomicFloat\ne) AtomicDouble','b) AtomicInteger\nc) AtomicLong\n\nClasses AtomicInteger and AtomicLong extend Number class.\nAtomicBoolean does not extend java.lang.Number. Classes named as AtomicFloat or\nAtomicDouble do not exist in the java.util.concurrent.atomic package.','General',1,NULL),(2524,'class Student{\n    public Student(int r) {\n    rollNo = r;\n    }\n\n    int rollNo;\n    public int hashCode(){\n        return rollNo;\n    }\n}\n\nclass Hello {\n        public static void main(String[] args){\n            HashSet<Student> students = new HashSet<>();\n            students.add(new Student(5));\n            Student s10 = new Student(10);\n            students.add(s10);\n            System.out.println(students.contains(new Student(10)));\n            System.out.println(students.contains(s10));\n        }\n}','false \ntrue\n\nthe newly created object is not part of the student set so it will show false.\n\ns10 however is the excact object added. Since equals is not overriden, this \ncollection can only identify equal objects using the unoverriden equals()\nfrom object which says that two objects are equal only if they are the excact\nsame reference variable which in this case is true..','Collections',1,NULL),(2525,'a) The Executor interface declares a single method execute(Runnable command) that\nexecutes the given command at sometime in the future.\nb) The Callable interface declares a single method call() that computes a result.\nc) The Exchanger class provides a “synchronization point at which threads can pair and\nswap elements within pairs”.\nd) The TimeUnit enumeration represents time duration and is useful for specifying\ntiming parameters in concurrent programs.','all four\n\nExecutor is an interface with a single method execute(Runnable r).\n\nWith Executor you create your own implementation to determine how you want threads\nto execute tasks. \n\nExecutor implementations in .concurrent package implement ExecutorService\nwhich is more complete\n\nExecutorService interface extends Executor. \n\nExecutors provides basic concrete implementations of these interfaces. ','Collections',1,NULL),(2526,'Executor is an interface with a single method execute(Runnable r).\n\nWith Executor you create your own implementation to determine how you want threads\nto execute tasks. \n\nExecutor implementations in .concurrent package implement ExecutorService\nwhich is more complete\n\nExecutorService interface extends Executor. \n\nExecutors provides basic concrete implementations of these interfaces. ','ok','Executors',1,NULL),(2527,'public class JabRefExecutorService implements Executor {\n\n    public static final JabRefExecutorService INSTANCE = new JabRefExecutorService();\n    private static final Log LOGGER = LogFactory.getLog(JabRefExecutorService.class);\n    private final ExecutorService executorService = Executors.newCachedThreadPool(r -> {\n        Thread thread = new Thread(r);\n        thread.setName(\"JabRef CachedThreadPool\");\n        thread.setUncaughtExceptionHandler(new FallbackExceptionHandler());\n        return thread;\n\n    });\n    private final ExecutorService lowPriorityExecutorService = Executors.newCachedThreadPool(r -> {\n        Thread thread = new Thread(r);\n        thread.setName(\"JabRef LowPriorityCachedThreadPool\");\n        thread.setUncaughtExceptionHandler(new FallbackExceptionHandler());\n        return thread;\n    });\n    private final Timer timer = new Timer(\"timer\", true);\n    private Thread remoteThread;\n\n    private JabRefExecutorService() { }\n\n    @Override\n    public void execute(Runnable command) {\n        if (command == null) {\n            LOGGER.debug(\"Received null as command for execution\");\n            return;\n        }\n\n        executorService.execute(command);\n    }','executor and singleton','Executors',1,NULL),(2528,'class Hello {\n        public static void main(String[] args){\n            List<String> coaches = Arrays.asList(\"Joe\",\"Dean\",\"Will\",\"Aaron\");\n            System.out.println(coaches.remove(\"Joe\"));\n        }\n}','Arrays.asList returns an unmodifiable list. you cannot add or remove from it','Collections',1,NULL),(2529,'class Hello {\n        public static void main(String[] args){\n            List<String> coaches = Arrays.asList(\"Joe\",\"Dean\",\"Will\",\"Aaron\");\n            //System.out.println(coaches.remove(\"Joe\"));\n            coaches.add(\"Reese\");\n        }\n}','Arrays.asList returns an unmodifiable list. you cannot add to it or remove from\nit. \n\n','Collections',1,NULL),(2530,'Arrays.asList returns an umodifiable list you cannot add to it or remove\nfrom it or you will get an unsupportedoperationexception. ','ok','Collections',1,NULL),(2531,'class Hello {\n        public static void main(String[] args){\n            List<String> coaches = Arrays.asList(\"Joe\",\"Dean\",\"Will\",\"Aaron\");\n            //System.out.println(coaches.remove(\"Joe\"));\n            coaches.set(0,\"Dan\");\n        }\n}','compiles fine. ','Collections',1,NULL),(2532,'class Test {\n	public static void main(String []args) {\n		String s = new String(\"5\");\n		System.out.println(1+10+s+1+10);\n	}\n}\n \na) 11511\nb) 1105110\nc) 115110\nd) 27','115110\nThe string concatenation operator works as follows: if both the operands are numbers,\nit performs the addition; otherwise it concats the arguments by calling the toString()\nmethod if needed. It evaluates from left to right. Hence, the expression in the program\nresults in the string 115110.','Strings',1,NULL),(2533,'The string concatenation operator works as follows: if both the operands are numbers,\nit performs the addition; otherwise it concats the arguments by calling the toString()\nmethod if needed. It evaluates from left to right. ','wow ','Strings',1,NULL),(2534,'class Test {\n	public static void main(String []args) {\n		String s = new String(\"5\");\n		System.out.println(1.0+10.5+s+(1.0+10.5));\n	}\n}\n \na) 11.5511.5\nb) 11.551.010.5\nc) 1.010.551.010.5\nd) 11.55(1.010.5)\ne) 11.55(11.5)','a\n\nwith + if the expression is in () it evaluates first. + if the left arg\nis a string both will become strings.\n\nif the two are numbers then addition will be performed. ','Strings',1,NULL),(2535,'class Printf {\n	public static void main(String []args) {\n		System.out.printf(\"%3.4s %n\", \"hello world\");\n		System.out.printf(\"%05d\", 123);\n	}\n}','hell\n00123\n\nIn first printf() method, %3.4s indicates that you want to print the first four characters\nof a string. In the second printf() method call, %05d indicates that you wanted to print\na minimum five digits of an integer. If the number does not have enough digits, then the\nnumber will be preceded by leading zeroes.\n\n\nYou can also use String.format(\"%3.3s\", \"abcdefgh\"). \nThe first digit is the minimum length (the string will be left \npadded if it\'s shorter), the second digit is the maxiumum length \nand the string will be truncated if it\'s longer. So\n\nSystem.out.printf(\"%3.3s%3.3s\", \"abcdefgh\", \"a\");\n\nwill produce\n\n\'abc  a\'','Strings',1,NULL),(2536,'NumberFormatException is a runtime exception','ok','General',1,NULL),(2537,'class Test {\npublic static void main(String []args) {\nint a = 7, b = 10;\nSystem.out.printf(\"no:%2$s and %1$s\", a, b);\nSystem.out.printf(\"\\nno:2$s and 1$s\", a, b);\n}\n}','no:10 and 7\nno:2$s and 1$s\n\nThe format specifier string %$s indicates that you want to re-order the input values.\nA number (integer) sandwiched between a % and a $ symbol is used to re-order the\ninput values; the number indicates which input variable you want to put here. In %2$s\nit indicates that you want to put the second argument. Similarly, %1$s indicates that you\nwant to put the first argument.','General',1,NULL),(2538,'class Test {\npublic static void main(String[] s) {\nString quote = \"aba*abaa**aabaa***\";\nString [] words = quote.split(\"a\\\\**\", 10);\nfor (String word : words) {\nSystem.out.println(word);\n}\n}\n}','\nb\nb\nb','Strings',1,NULL),(2539,'class Test {\n	public static void main(String[] args) {\n		String str1 = \"xxzz\";\n		String str2 = \"xyz\";\n		String str3 = \"yzz\";\n		Pattern pattern = Pattern.compile(\"(xx)*y?z{1,}\");\n		Matcher matcher = pattern.matcher(str1);\n		System.out.println(matcher.matches());\n		System.out.println(pattern.matcher(str2).matches());\n		System.out.println(\n		Pattern.compile(\"(xx)*y?z{1,}\").\n		matcher(str3).matches());\n	}\n}','in regex ? indicates 0 or 1','Strings',1,NULL),(2540,'class Test {\n	public static void main(String[] args) {\n\n	String str =\"Suneetha N.=9876543210, Pratish Patil=9898989898\";\n\n	Pattern pattern =Pattern.compile(\"(\\\\w+)(\\\\s\\\\w+)(=)(\\\\d{10})\");\n\n	Matcher matcher = pattern.matcher(str);\n\n	String newStr = matcher.replaceAll(\"$4:$2,$1\");\n	System.out.println(newStr);\n}\n}\n ','Suneetha N.=9876543210, 9898989898: Patil,Pratish\n\n\n\npublic String replaceAll(String replacement)\n\nReplaces every subsequence of the input sequence that matches the pattern \nwith the given replacement string.\n\nThis method first resets this matcher. It then scans the input sequence \nlooking for matches of the pattern. Characters that are not part of any\n match are appended directly to the result string; each match is replaced \nin the result by the replacement string. The replacement string may contain references to captured subsequences as in the appendReplacement method.\n\nNote that backslashes (\\) and dollar signs ($) in the replacement string \nmay cause the results to be different than if it were being treated as a \nliteral replacement string. Dollar signs may be treated as references to\n captured subsequences as described above, and backslashes are used to \nescape literal characters in the replacement string.\n\nGiven the regular expression a*b, the input \"aabfooaabfooabfoob\", and \nthe replacement string \"-\", an invocation of this method on a matcher \nfor that expression would yield the string \"-foo-foo-foo-\".\n\nInvoking this method changes this matcher\'s state. If the matcher is\n to be used in further matching operations then it should first be\n reset. ','Strings',1,NULL),(2541,'if a final variable is static it has be intitialized right away.','ok ','OOP',1,NULL),(2542,'public static void main(String[] args) {\n\n            Set<String> set = new TreeSet<String>();\n            set.add(\"S\");\n            set.add(\"R\");\n            Iterator<String> iter = set.iterator();\n            set.add(\"P\");\n            set.add(\"Q\");\n            while(iter.hasNext()) {\n                System.out.print(iter.next() + \" \");\n            }\n    }','concurrent modification exception\n\nTreeSets iterator: \n\n	The iterators returned by this class\'s iterator method are fail-fast: \nif the set is modified at any time after the iterator is created, in any \nway except through the iterator\'s own remove method, the iterator will\n throw a ConcurrentModificationException.','Collections',1,NULL),(2543,'public class Hello extends Thread {\n\n    public static void main(String[] args) {\n\n         ResourceBundle resBundle = ResourceBundle.getBundle(\"ResourceBundle\", new Locale(\"it\", \"IT\", \"\"));\n         System.out.println(resBundle.getObject(new Integer(1).toString()));\n    }\n        \n     \n}\n\nclass ResourceBundle_it_IT extends ListResourceBundle {\n\n    public Object[][] getContents() {\n        return contents;\n    }\n    static final Object[][] contents = {\n        {\"1\", \"Uno\"},\n        {\"2\", \"Duo\"},\n        {\"3\", \"Trie\"},};\n}','how to correctly load an rb','Locale',1,NULL),(2544,'public static void main(String[] args) {\n\n            Set<String> set = new CopyOnWriteArraySet<String>();\n            set.add(\"2\");\n            set.add(\"1\");\n            Iterator<String> iter = set.iterator();\n            set.add(\"3\");\n            set.add(\"-1\");\n            while(iter.hasNext()) {\n                System.out.print(iter.next() + \" \");\n            }\n    }','CopyOnWrite Collections will allow concurrent modification','Collections',1,NULL),(2545,'ResourceBundle resBundle = ResourceBundle.getBundle(\"hello.ResourceBundle\", new Locale(\"it\", \"IT\", \"\"));\n            System.out.println(resBundle.getObject(new Integer(1).toString()));','the proper name of a resource bundle has its package in front. ','Locale',1,NULL),(2546,'public class Hello extends Thread {\n    Set<String> set = new CopyOnWriteArraySet<String>();\n    \n    public Hello(){\n        set.add(\"2\");\n        set.add(\"1\");\n        set.add(\"3\");\n        set.add(\"-1\");\n    }\n\n    public static void main(String[] args) {\n        //Thread t1 = new ConcAdder();\n        Hello h = new Hello();\n        Hello.ConcAdder ca = h.new ConcAdder();\n        ca.start();\n        \n        Hello.ConcIter ci = h.new ConcIter();\n        ci.start();\n\n    }\n    \n    class ConcAdder extends Thread{\n        private String[] letters = {\"A\",\"B\",\"C\",\"D\"};\n        public void run(){\n            while(true){\n                try{\n                    sleep(1000);\n                    int a = ThreadLocalRandom.current().nextInt(0,3);\n                    set.add(letters[a]);\n                } catch(InterruptedException e){\n                    \n                }\n            }\n            \n        }\n    }\n    \n    class ConcIter extends Thread {\n        public void run(){\n            while(true){\n                Iterator<String> it = set.iterator();\n\n                while(it.hasNext()){\n                    System.out.println(it.next());\n                }\n                \n                try{\n                    sleep(1000);\n                } catch(InterruptedException e){ }\n            }\n        }\n        \n    }    \n}\n','One Thread continously interates throgh the set while the other continusly adds\nnew things to it. \n\nThis is allowed with a COWSet. \n\nThough if the Iterator is obtained then an element is added that iterator\nwill not change it will print the elements that were in the set at the time\nof Instantiation of the iterator. ','Concurrency',1,NULL),(2547,'\npublic interface Iterable<T>\n\nImplementing this interface allows an object to be the target of the\n \"foreach\" statement.\n\n\nIterator<E> is an interface too	','ok','General',1,NULL),(2548,'public class Hello extends Thread {\n    Set<String> set = new CopyOnWriteArraySet<String>();\n    \n    public Hello(){\n        set.add(\"2\");\n        set.add(\"1\");\n        set.add(\"3\");\n        set.add(\"-1\");\n    }\n\n    public static void main(String[] args) {\n        //Thread t1 = new ConcAdder();\n        Hello h = new Hello();\n        Hello.ConcAdder ca = h.new ConcAdder();\n        ca.start();\n        \n        Hello.ConcIter ci = h.new ConcIter();\n        ci.start();\n\n    }\n    \n    class ConcAdder extends Thread{\n        private String[] letters = {\"A\",\"B\",\"C\",\"D\"};\n        public void run(){\n            while(true){\n                    int a = ThreadLocalRandom.current().nextInt(0,3);\n                    set.add(letters[a]);\n            }\n            \n        }\n    }\n    \n    class ConcIter extends Thread {\n        public void run(){\n            while(true){\n                Iterator<String> it = set.iterator();\n\n                while(it.hasNext()){\n                    System.out.println(it.next());\n                }\n                \n                it.remove();\n            }\n        }\n        \n    }    \n}','2\nException in thread \"Thread-2\" java.lang.UnsupportedOperationException\n1\n3\n-1\n\nYou cannot mutate the collection with Iterator methods when using \na COW colleciton. \n\nThe collection is only thread safe because it copies its entire internal array\nevery time something is added or removed. \n\nSo when an iterator is obtained it gives one copy of the immutable internal\narray. You cannot mutate an array which gives the unsupportedOperation excepiton.','Concurrency',1,NULL),(2549,'public class Hello extends Thread {\n    Set<String> set = new TreeSet<String>();\n    \n    public Hello(){\n        set.add(\"2\");\n        set.add(\"1\");\n        set.add(\"3\");\n        set.add(\"-1\");\n    }\n\n    public static void main(String[] args) {\n        //Thread t1 = new ConcAdder();\n        Hello h = new Hello();\n        Hello.ConcAdder ca = h.new ConcAdder();\n        ca.start();\n        \n        Hello.ConcIter ci = h.new ConcIter();\n        ci.start();\n\n    }\n    \n    class ConcAdder extends Thread{\n        private String[] letters = {\"A\",\"B\",\"C\",\"D\"};\n        public void run(){\n            while(true){\n                    int a = ThreadLocalRandom.current().nextInt(0,3);\n                    set.add(letters[a]);\n            }\n            \n        }\n    }\n    \n    class ConcIter extends Thread {\n        public void run(){\n            while(true){\n                Iterator<String> it = set.iterator();\n\n                while(it.hasNext()){\n                    System.out.println(it.next());\n                }\n                \n                //it.remove();\n            }\n        }\n        \n    }    \n}','-1\nException in thread \"Thread-2\" java.util.ConcurrentModificationException\n\nTreeSet iterator is fail fast','Concurrency',1,NULL),(2550,'public abstract class Hello extends Base  {\n    public static void main(String[] yea){\n        Base b = new Base();\n        b.print();\n    }\n}\n\nclass Base{\n    public void print(){\n        System.out.println(\"Base print\");\n    }\n}','Base print\nan abstract class can extend a concrete class. ','OOP',1,NULL),(2551,'class Hello {\n\n    static <E> E cast(Object item) {\n        return (E) item;\n    }\n\n    public static void main(String[] args) {\n        Object o1 = 10;\n        int i = 10;\n        Integer anInteger = 10;\n\n        Integer i1 = cast(i);\n        Integer i2 = cast(10);\n        Integer i3 = cast(anInteger);\n        Integer i4 = cast(o1);\n\n        System.out.printf(\"i1 = %d, i2 = %d, i3 = %d, i4 = %d\", i1, i2, i3, i4);\n    }\n}','i1 = 10, i2 = 10, i3 = 10, i4 = 10\nunchecked cast warning too.\n\nE becomes whatever you are assigning the variable to','OOP',1,NULL),(2552,'class Hello {\n\n    static <E> E cast(Object item) {\n        return (E) item;\n    }\n\n    public static void main(String[] args) {\n        Object o1 = 10;\n        int i = 10;\n        Integer anInteger = 10;\n\n        String i4 = cast(o1);\n\n        System.out.printf(i4);\n    }\n}','Exception in thread \"main\" java.lang.ClassCastException: \njava.lang.Integer cannot be cast to java.lang.String','Generics',1,NULL),(2553,'class Hello {\n\n    static <E> E cast(Sculptable item) {\n        return (E) item;\n    }\n\n    public static void main(String[] args) {\n       Clay c = new Clay();\n       Rock r = cast(c);\n    }\n}\n\ninterface Sculptable{ }\nclass Rock{}\nclass Clay extends Rock implements Sculptable{}','compiles fine','Generics',1,NULL),(2554,'class Hello {\n\n\n    public static void main(String[] args) {\n        Vehicle[] v = new Car[4];\n        v[0] = new Vehicle();\n        v[1] = new Car();\n        v[2] = new Toyota();\n        \n        System.out.println(v.length);\n    }\n    \n}\n\nclass Vehicle{}\nclass Car extends Vehicle{}\nclass Toyota extends Car{}','ArrayStoreException.\n\nThe compiler sees a Vehicle[] and car vehicle object being assigned to it.\n\nhowever the JVM sees a Car[] because the JVM deals with polymorphism. \nand a Vehicle object cannot be added to a Car[]','Generics',1,NULL),(2555,'class Hello {\n\n\n    public static void main(String[] args) {\n        Vehicle[] v = new Car[4];\n        //v[0] = new Vehicle();\n        v[1] = new Car();\n        v[2] = new Toyota();\n        \n        System.out.println(v.length);\n    }\n    \n}\n\nclass Vehicle{}\nclass Car extends Vehicle{}\nclass Toyota extends Car{}','4','Generics',1,NULL),(2556,'class Point { int x, y; }\nclass ColoredPoint extends Point { int color; }\nclass Test {\n    public static void main(String[] args) {\n        ColoredPoint[] cpa = new ColoredPoint[10];\n        Point[] pa = cpa;\n        System.out.println(pa[1] == null);\n        try {\n            pa[0] = new Point();\n        } catch (ArrayStoreException e) {\n            System.out.println(e);\n        }\n    }\n}','true\njava.lang.ArrayStoreException: Point\n\nThe variable pa has type Point[] and the variable cpa has as its value a \nreference to an object of type ColoredPoint[]. A ColoredPoint can be \nassigned to a Point; therefore, the value of cpa can be assigned to pa.\n\nA reference to this array pa, for example, testing whether pa[1] is null, \nwill not result in a run-time type error. This is because the element of\n the array of type ColoredPoint[] is a ColoredPoint, and every ColoredPoint\n can stand in for a Point, since Point is the superclass of ColoredPoint.\n\nOn the other hand, an assignment to the array pa can result in a run-time \nerror. At compile time, an assignment to an element of pa is checked to \nmake sure that the value assigned is a Point. But since pa holds a \nreference to an array of ColoredPoint, the assignment is valid only if \nthe type of the value assigned at run time is, more specifically, a \nColoredPoint.\n\nThe Java Virtual Machine checks for such a situation at run time to \nensure that the assignment is valid; if not, an ArrayStoreException is\nthrown. ','Generics',1,NULL),(2557,'public static void main(String[] args) {\n\n        List<Integer> list = new ArrayList<Integer>();\n        list.add(new Integer(2));\n        list.add(1);\n        list.add(5);\n        list.add(9);\n        list.add(6);\n\n        System.out.println(list.remove(2));\n        System.out.println(list);\n        System.out.println(list.remove(new Integer(9)));\n        System.out.println(list);\n\n\n    }','5\n[2, 1, 9, 6]\ntrue\n[2, 1, 6]','Collections',1,NULL),(2558,'public static void main(String[] args) {\n        String talk = \"Pick a little, talk a little, pick a little, talk a little, cheep cheep cheep, talk a lot, pick a little more\";\n        String eat = talk.replaceAll(\"talk\", \"eat\").replace(\"cheep\", \"burp\");\n        System.out.println(eat);\n    }','Pick a little, eat a little, pick a little, eat a little, burp burp burp, eat a lot, pick a little more.\n\nBoth replaceAll() and replace() methods replace all occurrences of the substring from\nthe given string. The difference between them is that replaceAll() takes regex as the\nfirst argument and replacement string as the second argument. The replace() method\ntakes CharSequence as both the arguments (note that String implements CharSequence\ninterface).','Strings',1,NULL),(2559,'replace(char oldChar, char newChar)\nReturns a new string resulting from replacing all occurrences of oldChar in this string with newChar.\n\nString 	replace(CharSequence target, CharSequence replacement)\nReplaces each substring of this string that matches the literal target sequence with the specified literal replacement sequence.\n\nString 	replaceAll(String regex, String replacement)\nReplaces each substring of this string that matches the given regular expression with the given replacement.\n\nString 	replaceFirst(String regex, String replacement)\nReplaces the first substring of this string that matches the given regular expression with the given replacement.','ok','Strings',1,NULL),(2560,'public static void main(String[] args) {\n        String talk = \"For 30 days and 30 nights, we battled the wind, the cold, the despair.\";\n        String rep = talk.replaceAll(\"\\\\d+\", \"4\");\n        System.out.println(rep);\n    }','For 4 days and 4 nights, we battled the wind, the cold, the despair.','Strings',1,NULL),(2561,'public static void main(String[] args) {\n        String talk = \"For 30 days and 30 nights, we battled the wind, the cold, the despair.\";\n        String rep = talk.replace(\"\\\\d+\", \"4\");\n        System.out.println(rep);\n    }','For 30 days and 30 nights, we battled the wind, the cold, the despair.\n\nreplace takes a charsequence as a first arg not regex','Strings',1,NULL),(2562,'public static void main(String []args) {\n        Class c1 = new ArrayList<String>().getClass();\n        // LINE A\n        Class c2 = ArrayList.class;\n        // LINE B\n        System.out.println(c1 == c2);\n    }','true\n\ntype erasure will make ArrayList raw and ArrayList<String> the same type of class\n','General',1,NULL),(2563,'class Hello {\n\n    private static void overload(Object o){ System.out.println(\"A\"); }\n    private static  void overload(double[] d){ System.out.println(\"B\"); }\n    private static void overload(){ System.out.println(\"C\"); }\n    \n    public static void main(String []args) {\n        overload(null);\n    }\n}','When executed, the program prints the following: B\n\nThe overload resolution matches to the most specific overload. When the argument null is\npassed, there are two candidates, Overload(Object) and Overload(double[]), and of these\ntwo, Overload(double[]) is the most specific overload, so the compiler resolves to calling\nthat method.\n\nOne method or constructor is less specific than another if it can accept \nany parameters passed to the other \n\nn our program, both constructors are accessible and applicable. \nThe constructor Confusing(Object) accepts any parameter passed to\n Confusing(double[]), so Confusing(Object) is less specific. \n(Every double array is an Object, but not every Object is a double array.)\n The most specific constructor is therefore Confusing(double[]), \nwhich explains the program\'s output.','General',1,NULL),(2564,'class Hello extends Super {\n    public Hello(){\n        member = \"HI\";\n    }\n    public void foo(){\n        System.out.println(\"in Hello foo \"+ member.toLowerCase());\n    }\n    private String member;\n    \n    public static void main(String []args) {\n        Super s = new Hello();\n        s.foo();\n        \n    }\n}\n\nclass Super{\n    public Super(){\n        foo();\n    }\n    \n    public void foo(){\n        System.out.println(\"Super foo\");\n    }\n}','NPE\n\n When the superclass constructor is called it calls the subclass foo()\nnot its own, resulting in an NPE.','General',1,NULL),(2565,'// class PQR in mock package\npackage mock;\n \npublic class PQR {\n	public static void foo() {\n		System.out.println(\"foo\");\n	}\n}\n \n// class XYZ in mock package\npackage mock;\nimport static mock.*;\n \npublic class XYZ {\n	public static PQR pqr;\n}\n \n// class StatImport\nimport static mock.XYZ.*;\n \nclass StatImport {\n	public static void main(String []args) {\n		// STMT\n	}\n}','pqr.foo();\n\n  In this program, the member pqr is imported statically. So, the foo() method can be accessed by\nqualifying it as pqr.foo(). Note that foo() itself is not imported statically, so it cannot be invoked directly\nin this program.','General',1,NULL),(2566,'psvm(String[] args){\n	String st = null;\n	sout( st.valueOf(10) );\n}','This program will print 10 in the console.\nThe valueOf(int) method is a static method in String that returns the String\nrepresentation of the integer value that is passed as its argument. Since calling a static\nmethod does not require dereferencing the reference variable on which it is called, this\nprogram does not throw a NullPointerException.\n\nshows the danger of using references to access static methods. ','Strings',1,NULL),(2567,'abstract class Shape{\n  protected final static double PI = 22.0/7.0;\n  protected double length;\n  public abstract double area();\n}\n\nclass Square extends Shape{\n  Square(double side){\n	length=side;// initialises inherited length\n  }\n  public double area(){// overrides area() of Shape\n	return length*length;// length inherited from Shape\n  }\n}\n\nclass Circle extends Shape{\n  Circle(double radius){\n	length=radius;// initialises inherited length\n  }\n  public double area(){// overrides area() of Shape\n	return PI*length*length;// PI & length inherited from Shape\n  }\n}\n\n/**\n * Polymorphism & Dynamic binding test class\n **/\npublic class l1PolyTest{\n  public static void main(String[] args){\n	Shape sh;// no object instance just variable declaration\n	Square sq = new Square(10.0);// sq is a Square object reference \n	Circle circ = new Circle(10.0);// circ is a Circle object reference\n\n	sh=sq;// sh dynamically bound to the Square object referenced by sq\n	System.out.println(\"Area of Square = \" + sh.area());\n\n	sh=circ; // sh dynamically bound to the Circle object referenced by circ\n	System.out.println(\"Area of circle = \" + sh.area());\n  }\n}','Area of Square = 100.0\nArea of circle = 314.2857142857143\n\nshows dynamic binding','OOP',1,NULL),(2568,'Which one of the following interfaces does NOT inherit from java.util.Collection<E>\ninterface?\n \na) Set<E>\nb) Queue<E>\nc) List<E>\nd) Map<K, V>',' MAp does not think about it a map maps keys to values that behavior is completely\nunlike all the other collection types. ','Collections',1,NULL),(2569,'finallize() and clone methods of Object class can be overriden along \nwith equals hashcode and to string','ok','OOP',1,NULL),(2570,'class Test {\n	public static void main(String []args) {\n		Locale locale1 = new Locale(\"en\"); //#1\n		Locale locale2 = new Locale(\"en\", \"in\"); //#2\n		Locale locale3 = new Locale(\"th\", \"TH\", \"TH\"); //#3\n		Locale locale4 = new Locale(locale3); //#4\n		System.out.println(locale1 + \" \" + locale2 + \" \" + locale3 + \" \" + locale4);\n	}\n}','Error at line 4, you cannot construct a locale out of another locale.','Locale',1,NULL),(2571,'public static void main(String []args) {\n        Locale l = new Locale(\"big\",\"Dick\");\n    }','compiles and runs without error, \n\nany string can be passed to a locale it is not an error if the string is \nnot a valid country and language. ','Locale',1,NULL),(2572,'class Hello implements AutoCloseable {\n    String header = null;\n    public Hello(String name) throws IOException{\n        header = name;\n        if(\"D2\".equals(name)) throw new IOException(\"Unknown\");\n        System.out.println(header + \" Opened\");        \n    }\n\n    public String read() throws IOException{\n        return \"\";\n    }\n    \n    public void close(){\n        System.out.println(\"Closing device \"+header);\n        throw new RuntimeException(\"RTE while closing \"+header);\n    }\n\n    public static void main(String []args) throws Exception {\n        try(Hello d1 = new Hello(\"D1\");\n            Hello d2 = new Hello(\"D2\")){\n            throw new Exception(\"test\");\n        } \n    }\n}','D1 Opened\nException in thread \"main\" java.io.IOException: Unknown\nClosing device D1\n\nSince an exception is thrown in the contructor of D2 it is never fullly initialized\nits reference is null.\n\nYou may think that this should cause a NPE by having Automatic Resource Management\ncall close() on a null object. But that is too deep in scope. Just Understand\nthat ARM skips D2 and calls close on d1. ','Exceptions',1,NULL),(2573,'class Resource {\n    public String data = \"DATA\";\n}\n\nclass Looney implements Runnable {\n    Resource r; int number;\n    public Looney(Resource r, int number) {\n        this.r = r;  this.number = number;\n    }\n\n    public void run(){\n        synchronized(r)  {\n            r.data = \"DATA \"+number;\n            r.notifyAll();\n            r.data = \"DATA\";\n        }\n    }\n}\n\npublic class Hello {\n\n    public static void main(String[] args) {\n        Resource r = new Resource();\n        Looney l = new Looney(r, 1);\n        Thread  t = new Thread(l);\n        t.start();\n        synchronized(r)  {\n            System.out.println(r.data);\n        }\n    }\n\n}\n','it will print DATA\n\nthink of the main method as the main thread. \nNo matter who gets the lock first it will still print DATA','Threads',1,NULL),(2574,'public class Hello\n{\n   public class A{\n   }\n   public static class B {\n   }\n   public static void main(String args[]){\n      class C{\n      }\n      new Hello().new B();\n   }\n}','WNC,\n\nby creating one instance of the outer class you automatically create an \ninstance of its static nested class and there can only be one of those.\nSo basically there wont be multiple static nested classes associated with\none outer class.\n\nanonymous class can never be static','Inner Classes',1,NULL),(2575,'public class Hello\n{\n    private static Runnable r = new Runnable(){\n          public void run(){\n              System.out.println(\"oh yea\");\n          }\n      };\n  \n   public static void main(String args[]){\n      new Thread(r).start();\n   }\n}','oh yea \n\nAn anonymous class is never abstract (§8.1.1.1). An anonymous class is \nalways an inner class (§8.1.3); it is never static (§8.1.1, §8.5.1). \nAn anonymous class is always implicitly final (§8.1.1.2).\n\nIf you want to baffle those maintaining your code, wags have discovered \njavac.exe will permit anonymous classes inside static init code and static\n methods, even though the language spec says than anonymous classes are \nnever static. These anonymous classes, of course, have no access to the \ninstance fields of the object. I don’t recommend doing this. The feature \ncould be pulled at any time. \n\n\nLet C be the class being instantiated, and let i be the instance being created. If C is an inner class then i may have an immediately enclosing instance. The immediately enclosing instance of i (§8.1.3) is determined as follows.\nIf C is an anonymous class, then:\nIf the class instance creation expression occurs in a static context (§8.1.3), then i has no immediately enclosing instance.\n Otherwise, the immediately enclosing instance of i is this.\nSo an anonymous class in a static context is roughly equivalent to a static nested class in that it does not keep a reference to the enclosing class, even though it\'s technically not a static class.','Inner Classes',1,NULL),(2576,'public class Hello\n{\n    public static Cinco c = new Cinco(){\n        Playo p = new Playo();\n    };\n  \n   public static void main(String args[]){\n      \n   }\n}\n\nclass Cinco{\n    public static final int cinco = 5;\n    \n    class Playo{\n        \n        public Playo(){\n            System.out.println(\"Playo\");\n        }\n        \n    }\n    public void output(){\n        int x = 9;\n        System.out.println(\"output: \"+9);\n    }\n    \n    public String name(){\n        return \"Cinco\";\n    }\n}','Playo','Inner Classes',1,NULL),(2577,'public class Hello\n{\n    public static Cinco c = new Cinco(\"cinco\"){\n        Playo p = new Playo(\"anon\");\n    };\n  \n   public static void main(String args[]){\n      Cinco.Playo cp = c.new Playo(\"main\");\n      Cinco.Mueno cp1 = c.new Mueno();\n   }\n}\n\nclass Cinco{\n    public static final int cinco = 5;\n    String name;\n    \n    public Cinco(String name){\n        this.name = name;\n    }\n    \n    class Playo{\n        \n        public Playo(String s){\n            System.out.println(\"Playo \"+s);\n        }\n        \n    }\n    \n    static class Mueno{\n        public void m1(){\n            System.out.println(\"mueno\");\n        }\n    }\n\n    public void output(){\n        int x = 9;\n        Cinco.Playo r = this.new Playo(\"this\");\n        System.out.println(\"output: \"+9);\n    }\n    \n    public String name(){\n        return \"Cinco\";\n    }\n}','WNC,\n\nqualified new static class. ','Inner Classes',1,NULL),(2578,'public class Hello\n{\n    public static Cinco c = new Cinco(\"cinco\"){\n        Playo p = new Playo(\"anon\");\n    };\n  \n   public static void main(String args[]){\n      Cinco.Playo cp = c.new Playo(\"main\");\n      Cinco.Mueno cp1 = new c.Mueno();\n   }\n}\n\nclass Cinco{\n    public static final int cinco = 5;\n    String name;\n    \n    public Cinco(String name){\n        this.name = name;\n    }\n    \n    class Playo{\n        \n        public Playo(String s){\n            System.out.println(\"Playo \"+s);\n        }\n        \n    }\n    \n    static class Mueno{\n        public void m1(){\n            System.out.println(\"mueno\");\n        }\n    }\n\n    public void output(){\n        int x = 9;\n        Cinco.Playo r = this.new Playo(\"this\");\n        System.out.println(\"output: \"+9);\n    }\n    \n    public String name(){\n        return \"Cinco\";\n    }\n}','WNC\n\npackage c doesnt exist','Inner Classes',1,NULL),(2579,'public class Hello\n{\n    public static Cinco c = new Cinco(\"cinco\"){\n        Playo p = new Playo(\"anon\");\n    };\n  \n   public static void main(String args[]){\n      Cinco.Playo cp = c.new Playo(\"main\");\n      Cinco.Mueno cp1 = new Cinco.Mueno();\n      cp1.m1();\n      Cinco.Mueno.m2();\n   }\n}\n\nclass Cinco{\n    public static final int cinco = 5;\n    String name;\n    \n    public Cinco(String name){\n        this.name = name;\n    }\n    \n    class Playo{\n        \n        public Playo(String s){\n            System.out.println(\"Playo \"+s);\n        }\n        \n    }\n    \n    static class Mueno{\n        public void m1(){\n            System.out.println(\"mueno\");\n        }\n        public static void m2(){\n            System.out.println(\"Mueno mueno\");\n        }\n    }\n\n    public void output(){\n        int x = 9;\n        Cinco.Playo r = this.new Playo(\"this\");\n        System.out.println(\"output: \"+9);\n    }\n    \n    public String name(){\n        return \"Cinco\";\n    }\n}','Playo anon\nPlayo main\nmueno\nMueno mueno','Inner Classes',1,NULL),(2580,'\nWhat will the following code print when compiled and run?\n\npublic class TestSIS {\n\n    public static void main(String[] args) {\n        String str = null;\n            switch(str){\n                case \"null\" : System.out.println(\"1\");\n                   break;\n                case \"\" : System.out.println(\"2\");\n                   break;\n                default : System.out.println(\"3\");\n           }\n     }\n}','There is only one important point that you need to know about String in a \nswitch statement:  The String in the switch expression is compared with the\n expressions associated with each case label as if the String.equals method\n were being used. This means if the string in the switch expression turns \nout to be null, it will cause a NullPointerException to be thrown. \n \nswitch(str){ // A NullPointerException will be thrown here if str is null. \n  case \"sss\" : System.out.println(\"sss\") ; }   \nFurther, you cannot do something like:  \n\nswitch(str){   case null : System.out.println(\"null\") \n//This line will not even compile }','General',1,NULL),(2581,'Three StandardCopyOptions ?','\n    REPLACE_EXISTING\n\n    public static final StandardCopyOption REPLACE_EXISTING\n\n    Replace an existing file if it exists.\n\n    COPY_ATTRIBUTES\n\n    public static final StandardCopyOption COPY_ATTRIBUTES\n\n    Copy attributes to the new file.\n\n    ATOMIC_MOVE\n\n    public static final StandardCopyOption ATOMIC_MOVE\n\n    Move the file as an atomic file system operation.\n','Input/Output',1,NULL),(2582,'Standard open options ','\n APPEND If the file is opened for \n\nWRITE access then bytes will be written to the end of the file rather \nthan the beginning.  CREATE Create a new file if it does not exist.  \n\nCREATE_NEW Create a new file, failing if the file already exists.  \n\nDELETE_ON_CLOSE Delete on close.  \n\nDSYNC Requires that every update to the file\'s content be written \nsynchronously to the underlying storage device.  \n\nREAD Open for read access.  \n\nSPARSE Sparse file.  \n\nSYNC Requires that every update to the file\'s content or metadata be \nwritten synchronously to the underlying storage device.  \n\nTRUNCATE_EXISTING If the file already exists and it is opened for WRITE access, then its length is truncated to 0.  \n\nWRITE Open for write access. ','Input/Output',1,NULL),(2583,'\nGiven that you have the following files in a directory named \"reports\":\n\nsalary.pdf\npayslips.pdf\nresume.rtf\nexpensesrtf (There is no . in the name)\n\nWhat will the following program print when run assuming that reports directory is present in the current directory?\n\n//assume appropriate imports\npublic class Path3 extends SimpleFileVisitor<Path>{\n    private PathMatcher pm = FileSystems.getDefault().getPathMatcher(\"glob:*pdf,rtf\");\n    public FileVisitResult visitFile(Path file,\n                                   BasicFileAttributes attr) {\n        \n        if(pm.matches(file.getFileName())){\n            System.out.println(file.getFileName());\n        }\n        return FileVisitResult.CONTINUE;\n    }\n\n    public static void main(String[] args) throws IOException{\n        Path3 p3 = new Path3();\n        Path startwith = Paths.get(\"reports\");\n        Files.walkFileTree(startwith, p3);\n    }\n\n}   ','prints nothing incorrect glob\n\nshould be *.{pdf,rtf}','Strings',1,NULL),(2584,'Path p1 = Paths.get(\"\\\\personal\\\\readme.txt\");         \nPath p2 = Paths.get(\"\\\\index.html\");         \nPath p3 = p1.relativize(p2);         \nSystem.out.println(p3);','\n..\\..\\index.html','Input/Output',1,NULL),(2585,'\nWhich is the first line that will cause compilation to fail in the following program?\n\n// Filename: A.java\nclass A\n{\n   public static void main(String args[])\n   {\n      A a = new A();\n      B b = new B();\n      a = b;  // 1\n      b = a;  // 2\n      a = (B) b; // 3\n      b = (B) a; // 4\n   }\n}\nclass B extends A { }\n','fails at line 2. This is narrowing and requires and explicit cast.\n\nCasting a base class to a subclass as in :   \nb = (B) a; is also called as narrowing (as you are trying to narrow the \nbase class object to a more specific class object) and needs explicit cast.\n Casting a sub class to a base class as in : A a = b; is also called as\n widening and does not need any casting. eg. Consider two classes:\n Automobile and Car, where Car extends Automobile Now, \nAutomobile a = new Car() is valid because a car is definitely an\n Automobile. So it does not need casting. But, Car c = a; is not\n valid as \'a\' is an Automobile and it may be a Car, or a Truck or a \nMotorCycle, so the programmer has to explicitly let the compiler know \nthat at runtime \'a\' will be a Car, by writing Car c = (Car) a;','OOP',1,NULL),(2586,'String str = \"tokens\\twith tabs and \\r\\nnew lines.\";           \n StringTokenizer st = new StringTokenizer(str);            \nSystem.out.println(st.countTokens());','6,\n\nthe default delemiters are a space, \\t\\n\\r\\f','Strings',1,NULL),(2587,'public static void main(String args[]){\n       StringTokenizer st = new StringTokenizer(\"this is a test\");\n       while (st.hasMoreTokens()){ \n        System.out.println(st.nextToken());\n       }\n   }','this\nis \na\ntest\n\nthe basic usage of StringTokenizer','Strings',1,NULL),(2588,'import maxspack.Bar;\n\n\n\npublic class Hello\n{\n  \n   public static void main(String args[]){\n      Bar b = new Bar();\n      b.foo();\n      b.reno();\n   }\n}\n\npackage maxspack;\n\n\npublic class Bar {\n    void foo(){\n        System.out.println(\"maxspack: foo\");\n    }\n    \n    public void reno(){\n        System.out.println(\"reno\");\n    }\n    \n}\n\n','WNC,\n\n\nfoo is default in Bar, cannot be used outside the package. ','OOP',1,NULL),(2589,'public class Hello{\n    static Map<Bar,Integer> map = new HashMap<>();\n    public Hello(){\n        Bar a = new Bar(\"A\");\n        map.put(a,10);\n        Bar b = new Bar(\"B\");\n        map.put(b,10);\n    }\n  \n   public static void main(String args[]){\n     Bar a1 = new Bar(\"A\");\n       System.out.println(map.get(a1));\n   }\n}\n\npackage maxspack;\npublic class Bar {\n    String name;\n    public Bar(String s){\n        name = s;\n    }\n    \n    public boolean equals(Object o){\n        return ((o instanceof Bar) && name.equals(((Bar)o).name));\n    }\n}','gives null since, there is no hashCode() in the Bar class. ','OOP',1,NULL),(2590,'public class Hello{\n   public static void main(String args[]){\n       Human max = new Human();\n       Human.Heart heart = max.new Heart();\n       \n       heart.pulse();\n       System.out.println(heart.pulse);\n       \n       \n   }\n}\n\nclass Human {\n    \n    \n    class Heart{\n        static final int pulse = 78;\n        \n        public void beat(){\n            System.out.println(\"Thump thump, thump thump\");\n        }\n        \n        public void pulse(){\n            System.out.println(\"pulse is \"+pulse);\n        }\n    }\n}','pulse is 78\n78\n\nconfusing and not recomended but will compile ','OOP',1,NULL),(2591,'variables and methods can have the same name because syntatically they \nare used completely differently. ','ok\n\npublic class SCJP extends Programmer {\n    public int debug = 9;\n    public Object debug(String s){\n        return this;\n    }\n}\n\n// this is ok ','OOP',1,NULL),(2592,'class Human {\n    protected final int chromosomes = 46;\n    \n    \n    class Heart{\n        static final int pulse = 78;\n        \n        public void beat(){\n            System.out.println(\"Thump thump, thump thump\");\n        }\n        \n        public void pulse(){\n            System.out.println(\"pulse is \"+pulse);\n        }\n    }\n}\n\nclass Politician extends Human{\n    \n    class BlackHeart extends Heart{\n        public void beat(){\n            System.out.println(\"There seems to be no pulse\");\n        }\n        \n        public void actNormal(){\n            System.out.println(\"ladies and gentelman... pulse: \"+pulse);\n        }\n        \n        public void dna(){\n            System.out.println(\":\"+chromosomes);\n        }\n        \n    }\n}','compiles fine....','Inner Classes',1,NULL),(2593,'class Human {\n    protected final int chromosomes = 46;\n    \n    \n    class Heart{\n        static final int pulse = 78;\n        \n        public void beat(){\n            System.out.println(\"Thump thump, thump thump\");\n        }\n        \n        public void pulse(){\n            System.out.println(\"pulse is \"+pulse);\n        }\n    }\n}\n\nclass Politician extends Human{\n    \n    class Heart extends Human.Heart{\n        public void beat(){\n            System.out.println(\"There seems to be no pulse\");\n        }\n        \n        public void actNormal(){\n            System.out.println(\"ladies and gentelman... pulse: \"+pulse);\n        }\n        \n        public void dna(){\n            System.out.println(\":\"+chromosomes);\n        }\n        \n    }\n}','compiles','Inner Classes',1,NULL),(2594,'class Human {\n    protected final int chromosomes = 46;\n    \n    \n    class Heart{\n        static final int pulse = 78;\n        \n        public void beat(){\n            System.out.println(\"Thump thump, thump thump\");\n        }\n        \n        public void pulse(){\n            System.out.println(\"pulse is \"+pulse);\n        }\n    }\n    \n    protected void procreate(){\n        \n    }\n    \n    abstract static class Soul{\n        protected abstract void giveLife();\n    }\n}\n\nclass Politician extends Human{\n    \n    public void procreate(){\n        \n    }\n    \n    class BlackHeart extends Heart{\n        public void beat(){\n            System.out.println(\"There seems to be no pulse\");\n        }\n        \n        public void actNormal(){\n            System.out.println(\"ladies and gentelman... pulse: \"+pulse);\n        }\n        \n        public void dna(){\n            System.out.println(\":\"+chromosomes);\n        }\n    }\n    \n    class HungrySoul extends Soul{\n        public void giveLife(){\n            System.out.println(\"I still feel worthless\");\n        }\n        \n    }\n    \n}','These compile fine,\n\nan inner class can abstract and static and be implemented by another inner \nclass.\n\noverriding can change the access modifier, it can be less restritive but\nnot more so\n','Inner Classes',1,NULL),(2595,'class Human {\n    protected final int chromosomes = 46;\n    \n    protected void procreate(){\n        Heart h = new Heart();\n    }\n    \n    class Heart{\n        static final int pulse = 78;\n        \n        public void beat(){\n            System.out.println(\"Thump thump, thump thump\");\n        }\n        \n        public void pulse(){\n            System.out.println(\"pulse is \"+pulse);\n        }\n    }\n\n    abstract static class Soul{\n        protected abstract void giveLife();\n    }\n}','This can compile only in mlic does the instantiation HAVVE to come after the \ndefinition of the class. ','Inner Classes',1,NULL),(2596,'class Human {\n    protected final int chromosomes = 46;\n    \n    class Heart{\n        static final int pulse = 78;\n        \n        public void beat(){\n            System.out.println(\"Thump thump, thump thump\");\n        }\n        \n        public void pulse(){\n            System.out.println(\"pulse is \"+pulse);\n        }\n    }\n    \n    private void breathe(){\n        System.out.println(\"ahhh\");\n    }\n    \n    \n    \n    abstract static class Soul{\n        protected abstract void giveLife();\n    }\n}\n\nclass Politician extends Human{\n    \n    public void procreate(){\n        \n    }\n    \n    public void breath() throws IOException{\n        System.out.println(\"ahhh,\");\n    }\n    \n    class BlackHeart extends Heart{\n        public void beat(){\n            System.out.println(\"There seems to be no pulse\");\n        }\n        \n        public void actNormal(){\n            System.out.println(\"ladies and gentelman... pulse: \"+pulse);\n        }\n        \n        public void dna(){\n            System.out.println(\":\"+chromosomes);\n        }\n    }\n    \n    class HungrySoul extends Soul{\n        public void giveLife(){\n            System.out.println(\"I still feel worthless\");\n        }\n        \n    }\n    \n}','private methods cannot be overriden, they are invisible to the subclass','Inner Classes',1,NULL),(2597,'class Glass{\n    private void shine(){\n        System.out.println(\"Bling bling\");\n    }\n}\n\nclass Window extends Glass{\n    public void shine() throws Exception{\n        \n    }\n}','compiles\n\nprivate methods cannot be overriden, they are invisible to the subclass','Inner Classes',1,NULL),(2598,'\nGiven that test1.txt exists but test2.txt doesn\'t exist, consider the following code?\n\npublic class Copier {\n    \n    public static void copy1(Path p1, Path p2) throws Exception {\n        Files.copy(p1, p2, StandardCopyOption.COPY_ATTRIBUTES);\n    }\n    \n    \n    public static void main(String[] args) throws Exception {\n        Path p1 = Paths.get(\"c:\\\\home\\\\resume2.txt\");\n        Path p2  = Paths.get(\"c:\\\\public\\\\resumes\\\\thankyouletter.txt\");\n        copy1(p1, p2);\n    }\n}\nwhat attributes will be copied ?','platform and system dependent','Inner Classes',1,NULL),(2599,'  public static void main(String[] args){\n        Path p1 = Paths.get(\"/home/maxbisesi/Public/MaxsDir\");\n        Path p2 = Paths.get(\"/home/maxbisesi/Public/TestDir\");\n        \n        try{\n            Files.copy(p1,p2);\n        } catch(IOException e){\n            System.out.println(e);\n            \n        }\n    }\n\nSay MaxsDir does not exist. ','NoSuchFileException /home/maxbisesi/Public/MaxsDir','Input/Output',1,NULL),(2600,'public class Hello {\n    public static void main(String[] args){\n        Path p1 = Paths.get(\"/home/maxbisesi/Public/Data/MaxsDir\");\n        Path p2 = Paths.get(\"/home/maxbisesi/Public/TestDir\");\n        \n        try{\n            Files.copy(p1,p2);\n        } catch(IOException e){\n            System.out.println(e);\n            \n        }\n    }\n    \n}\n\nTestDir already exists. ','FileAlreadyExistsExxcepiton','Input/Output',1,NULL),(2601,'public class Hello {\n    public static void main(String[] args){\n        Path p1 = Paths.get(\"/home/maxbisesi/Public/Data/MaxsDir\");\n        Path p2 = Paths.get(\"/home/maxbisesi/Public/TestDir\");\n        \n        try{\n            Files.copy(p1,p2,StandardCopyOption.REPLACE_EXISTING);\n        } catch(IOException e){\n            System.out.println(e);\n            \n        }\n    }\n    \n}\n\nTestDir is not empty	','DirectoryNotEmptyException','Input/Output',1,NULL),(2602,'public class Hello {\n    public static void main(String[] args){\n        Path p1 = Paths.get(\"/home/maxbisesi/Public/Data/MaxsDir\");\n        Path p2 = Paths.get(\"/home/maxbisesi/Public/TestDir\");\n        \n        try{\n            Files.copy(p1,p2,StandardCopyOption.REPLACE_EXISTING);\n        } catch(IOException e){\n            System.out.println(e);\n            \n        }\n    }\n}\n\nBoth of these are directories and TestDir is empty','succesfully copies MaxsDir to TestDir but does not copy all its contents too','Input/Output',1,NULL),(2603,' Deque<Integer> d = new ArrayDeque<>();\n         d.push(1);\n         d.offerLast(2);\n         d.push(3);\n         d.peekFirst();\n         d.removeLast(); \n        d.pop();   \n      System.out.println(d);','1\n\npush() is a stack method that adds the element to the front.\n Therefore, the contents of d change as follows: 1 offer(e) is a\n queue method that adds the element to the end and offerLast(e) is \nequivalent to offer(e). So the deque now contains: 1, 2 push(3) changes \nit to: 3, 1, 2 Now, peek methods don\'t modify the structure, therefore \neven though peekFirst returns 3, the deque doesn\'t change. removeLast() \nremoves the element from the end, so d now contains: 3, 1 pop() is a stack\n method that removes the element from the front. Therefore, the contents of\n d change to: 1','Collections',1,NULL),(2604,'public static void main(String[] args){\n        \n       class StringSort implements Comparator<String> {\n           public int compare(String s1, String s2){\n               return s1.length() - s2.length();\n           }\n       }\n       \n       String[] strs = {\"a\",\"cc\",\"ffff\"};\n       \n       Arrays.sort(strs,new StringSort());\n       \n       int pos = Arrays.binarySearch(strs,\"b\",new StringSort());\n        System.out.println(pos);\n       \n    }','0 \n\nbinarySearch iplemented in this way compares strings by length no matter the \ncontent if the two string are of equal length they are considered equal. ','Strings',1,NULL),(2605,'public static void main(String[] args){\n        \n       class StringSort implements Comparator<String> {\n           public int compare(String s1, String s2){\n               return s1.length() - s2.length();\n           }\n       }\n       \n       String[] strs = {\"a\",\"cc\",\"ffff\"};\n       \n       Arrays.sort(strs,new StringSort());\n       \n       int pos = Arrays.binarySearch(strs,\"tyuioo\",new StringSort());\n        System.out.println(pos);\n       \n    }','-4\n\nnegative insertion point','Strings',1,NULL),(2606,'If an array or collection is sorted using comparator it must be searched using\nthe same comparator passed as an argument','ok','Strings',1,NULL),(2607,'\nConsider the code shown below -\n\npublic class TestClass\n{\n   public Mumbo mumbo = new Mumbo();\n   public Jumbo jumbo = new Jumbo();\n   class Mumbo\n   {\n      public synchronized void doIt()\n      {\n         try{\n            LINE 1: wait();\n            System.out.println(\"done\");\n         }\n         catch(Exception e) { }\n      }\n   }\n   class Jumbo extends Thread\n   {\n      public void run()\n      {\n         mumbo.doIt();\n      }\n   }\n   public TestClass() throws Exception\n   {\n       jumbo.start();\n      Thread.sleep(1000);\n      LINE 2:    //insert code here\n   }\n   public static void main(String[] args) throws Exception\n   {\n      new TestClass();\n   }\n}\n\nAssume that you have run the above program. The jumbo thread has just executed LINE1 and the thread that called jumbo.start() is about to call LINE 2.\nWhat can you insert at LINE 2, so that the program will print done and exit?','synchronized(mumbo) { mumbo.notifyAll(); }','Threads',1,NULL),(2608,'String[] strs = {\"a\",\"cc\",\"ffff\",\"yyt\"};\n       \n       ArrayList<?> list = new ArrayList<>(Arrays.asList(strs));\n       \n       for(String s : list){\n           System.out.println(s);\n       }','WNC,\n\nobjects coming out of a collection of type <?> are always objects. ','Collections',1,NULL),(2609,'String[] strs = {\"a\",\"cc\",\"ffff\",\"yyt\"};\n       \n       ArrayList<?> list = new ArrayList<?>(Arrays.asList(strs));\n       \n       for(Object s : list){\n           System.out.println(s);\n       }','WNC,\n\nnot because of asList(), You cant create an object with wild card type <?>\n\nthe type of the collection simply has to be established at some point. ','Collections',1,NULL),(2610,'class Human {\n    protected final int chromosomes = 46;\n    \n    public void breathe(){\n        System.out.println(\"ahhh\");\n    }\n    \n}\n\nclass Politician extends Human{\n    \n    \n    public void breathe(boolean tf) throws InterruptedException{\n        if(tf){\n            System.out.println(\"ahhh\");\n        } else {\n            System.out.println(\"ughhg\");\n        }\n    }\n      \n}','an overloaded method can throw an exception. ','OOP',1,NULL),(2611,'public class TestClass implements Runnable {   \n    volatile int x;  \n    public void run(){ x = 5; } \n  \n    public static void main(String[] args)   {       \n		TestClass tc = new TestClass();       \n		tc.x = 10;       \n		new Thread(tc).start(); // 1    \n   		System.out.println(tc.x);   \n   }  \n}','output cannot be determined.','Threads',1,NULL),(2612,'public class InterfaceTest {\n    interface Gift  { void present(); }\n    interface Guest { void present(); }\n\n    interface Presentable extends Gift, Guest { }\n\n    public static void main(String[] args) {\n        Presentable johnny = new Presentable() {\n            @Override public void present() {\n                System.out.println(\"Heeeereee\'s Johnny!!!\");\n            }\n        };\n        johnny.present();                     // \"Heeeereee\'s Johnny!!!\"\n\n        ((Gift) johnny).present();            // \"Heeeereee\'s Johnny!!!\"\n        ((Guest) johnny).present();           // \"Heeeereee\'s Johnny!!!\"\n\n        Gift johnnyAsGift = (Gift) johnny;\n        johnnyAsGift.present();               // \"Heeeereee\'s Johnny!!!\"\n\n        Guest johnnyAsGuest = (Guest) johnny;\n        johnnyAsGuest.present();              // \"Heeeereee\'s Johnny!!!\"\n    }\n}','ok','OOP',1,NULL),(2613,'interface Cookable{\n    void fry() throws Exception;\n}\n\ninterface Eatable{\n    boolean fry()throws IOException;\n}\n        \n\nclass Egg implements Cookable,Eatable{\n    public void fry(){\n        \n    }\n    \n    public boolean fry(){\n        \n    }\n}','WNC, \n\nIf you implement two interfaces that have a method that is equivalent,\n\nyou can implement those interfaces with one method howeve it has be safely overridden from both interfaces ','OOP',1,NULL),(2614,'public static void main(String[] args){\n        \n        Locale myloc = new Locale(\"hinglish\",\"IN\");\n        ResourceBundle msgs = ResourceBundle.getBundle(\"mymsgs\", myloc);  \n        \n        Enumeration<String> en = msgs.getKeys(); \n        \n        while(en.hasMoreElements()){     \n            String key = en.nextElement();     \n            String val = msgs.getString(key);     \n            System.out.println(key+\"=\"+val); \n        }\n       \n    }\n\n1. mymsgs_hinglish_US.properties okLabel=OK cancelLabel=Cancel     \n2. mymsgs_hinglish_UK.properties okLabel=YES noLabel=NO','Throws Missing Resource Exception\n\nYou are trying to create  an RB for a specific locale, Since that specific\nlocale does not exist on the class path it throws an excepiton.\n\nTo select the appropriate ResourceBundle, invoke the ResourceBundle.getBundle method. The following example selects the ButtonLabel ResourceBundle for the Locale that matches the French language, the country of Canada, and the UNIX platform.\n\nLocale currentLocale = new Locale(\"fr\", \"CA\", \"UNIX\");\nResourceBundle introLabels = ResourceBundle.getBundle(\n                                 \"ButtonLabel\", currentLocale);\n\nIf a ResourceBundle class for the specified Locale does not exist, getBundle tries to find the closest match. For example, if ButtonLabel_fr_CA_UNIX is the desired class and the default Locale is en_US, getBundle will look for classes in the following order:\n\nButtonLabel_fr_CA_UNIX\nButtonLabel_fr_CA\nButtonLabel_fr\nButtonLabel_en_US\nButtonLabel_en\nButtonLabel\n','Locale',1,NULL),(2615,'To select the appropriate ResourceBundle, invoke the ResourceBundle.getBundle method. The following example selects the ButtonLabel ResourceBundle for the Locale that matches the French language, the country of Canada, and the UNIX platform.\n\nLocale currentLocale = new Locale(\"fr\", \"CA\", \"UNIX\");\nResourceBundle introLabels = ResourceBundle.getBundle(\n                                 \"ButtonLabel\", currentLocale);\n\nIf a ResourceBundle class for the specified Locale does not exist, getBundle tries to find the closest match. For example, if ButtonLabel_fr_CA_UNIX is the desired class and the default Locale is en_US, getBundle will look for classes in the following order:\n\nButtonLabel_fr_CA_UNIX\nButtonLabel_fr_CA\nButtonLabel_fr\nButtonLabel_en_US\nButtonLabel_en\nButtonLabel\n','ok','Locale',1,NULL),(2616,'Locale myloc = new Locale(\"hinglish\",\"IN\");\nResourceBundle rb = ResourceBundle.getBundle(\"rb\", myloc);\n\nwhat files will be searched for before throwing a MRE ?','rb_hinglish_IN.java\nrb_hinglish_IN.properties\n\nrb_hinglish.java\nrb_hinglish.properties\n\nrb.java\nrb.properties','Locale',1,NULL),(2617,'public class Hello {\n    public static void main(String[] args){\n        \n        List<String> list = new ArrayList<>();\n        \n        for(int i = 0; i<100; i++){\n            list.add(\"string: (\"+i+\")\");\n        }\n        \n        List<String> section = listSection(list,0,100);\n        \n        for(String s : section){ System.out.println(s); }\n       \n    }\n    \n    public static <E> List<E> listSection(List<E> list,int x, int y){\n        List<E> newlist = list.subList(x,y);\n        return newlist;\n    }\n    \n}','You may think this will throw an IndexOutOFBoundsException but in fact the\nending index in sublist is EXCLUSIVE so given the indexs 0-100 will perfectly\nmatch the passed in list. \n\nstring: (0)\nstring: (1)\n...\nstring: (99)','Collections',1,NULL),(2618,'String.substring(int beginIndex, int endIndex)\n\ninclusive and exclusive \n\nmost functions will be this way. \n\n','ok','Strings',1,NULL),(2619,'public class Hello {\n    private static Deque<String> deq = new ArrayDeque<>();\n    public static void main(String[] args){\n        ReentrantLock l1 = new ReentrantLock();\n        ReentrantLock l2 = new ReentrantLock();\n        \n        try{\n            l1.lock();\n            l1.lock();\n            \n            deq.push(\"First push\");\n            deq.offerLast(\"offer Last\");\n            deq.add(\"add\");\n            deq.push(\"push FirstFirst\");\n            \n        } finally{\n            l1.unlock();\n            l1.unlock();\n        }\n        \n        while(!deq.isEmpty())\n            System.out.println(deq.pop());\n        \n       \n    }','It is ok to aquire a lock multiple times. it is not ok to unlock a non locked\nlock\n\npush is a stack method inserting at the front, like loading a clip of bullets.\n\nadd is a queue method it adds to the end as does offerLast.\n\npop() retrieves and removes from the front. Stack method. ','Collections',1,NULL),(2620,'public class Hello {\n    private static Deque<String> deq = new ArrayDeque<>();\n    public static void main(String[] args){\n        ReentrantLock l1 = new ReentrantLock();\n        ReentrantLock l2 = new ReentrantLock();\n        \n        try{\n            l1.lock();\n            l1.lock();\n            \n            deq.push(\"First push\");\n            deq.addFirst(\"add first\");\n            deq.add(\"add\");\n            deq.offerFirst(\"offerfirst\");\n            deq.offerLast(\"offerLast\");\n            deq.push(\"push last push\");\n            \n        } finally{\n            l1.unlock();\n            l1.unlock();\n            l2.unlock();\n        }\n        \n        while(!deq.isEmpty())\n            System.out.println(deq.pop());\n        \n       \n    }\n    \n    public static <E> List<E> listSection(List<E> list,int x, int y){\n        List<E> newlist = list.subList(x,y);\n        return newlist;\n    }\n    \n}','IllegalMonitorStateException for trying to unlock an unlocked lock. ','Concurrency',1,NULL),(2621,'ublic class Hello {\n    private static Deque<String> deq = new ArrayDeque<>();\n    public static void main(String[] args){\n        ReentrantLock l1 = new ReentrantLock();\n        ReentrantLock l2 = new ReentrantLock();\n        \n        try{\n            l1.lock();\n            l1.lock();\n            \n            deq.push(\"First push\");\n            deq.addFirst(\"add first\");\n            deq.add(\"add\");\n            deq.offerFirst(\"offerfirst\");\n            deq.offerLast(\"offerLast\");\n            deq.push(\"push last push\");\n            \n        } finally{\n            l1.unlock();\n            l1.unlock();\n            //l2.unlock();\n        }\n        \n        while(!deq.isEmpty())\n            System.out.println(deq.pop());\n        \n       \n    }','push last push\nofferfirst\nadd first\nFirst push\nadd\nofferLast','Collections',1,NULL),(2622,' Assignment contexts allow the use of one of the following:\n\n        an identity conversion (§5.1.1)\n\n        a widening primitive conversion (§5.1.2)\n\n        a widening reference conversion (§5.1.5)\n\n        a boxing conversion (§5.1.7) optionally followed by a widening reference conversion\n\n        an unboxing conversion (§5.1.8) optionally followed by a widening primitive conversion.\n\ncannot do two of these in one step. \n\n','ok','General',1,NULL),(2623,'5.1.2. Widening Primitive Conversion\n\n19 specific conversions on primitive types are called the widening primitive conversions:\n\n    byte to short, int, long, float, or double\n\n    short to int, long, float, or double\n\n    char to int, long, float, or double\n\n    int to long, float, or double\n\n    long to float or double\n\n    float to double\n\nA widening primitive conversion does not lose information about the overall magnitude of a numeric value.\n\nA widening primitive conversion from an integral type to another integral type, or from float to double in a strictfp expression (§15.4), does not lose any information at all; the numeric value is preserved exactly.\n\nA widening primitive conversion from float to double that is not strictfp may lose information about the overall magnitude of the converted value.\n\nA widening conversion of an int or a long value to float, or of a long value to double, may result in loss of precision - that is, the result may lose some of the least significant bits of the value. In this case, the resulting floating-point value will be a correctly rounded version of the integer value, using IEEE 754 round-to-nearest mode (§4.2.4).\n\nA widening conversion of a signed integer value to an integral type T simply sign-extends the two\'s-complement representation of the integer value to fill the wider format.\n\nA widening conversion of a char to an integral type T zero-extends the representation of the char value to fill the wider format.\n\nDespite the fact that loss of precision may occur, a widening primitive conversion never results in a run-time exception (§11.1.1).\n\nExample 5.1.2-1. Widening Primitive Conversion\n\nclass Test {\n    public static void main(String[] args) {\n        int big = 1234567890;\n        float approx = big;\n        System.out.println(big - (int)approx);\n    }\n}\n\nThis program prints:\n\n-46\n\nthus indicating that information was lost during the conversion from type int to type float because values of type float are not precise to nine significant digits.\n','ok','General',1,NULL),(2624,'class C { \n    public    void mCPublic()    {}\n    protected void mCProtected() {} \n              void mCDefault()   {}\n    private   void mCPrivate()   {} \n} \n\ninterface I {\n    void mI();\n}\n\nclass CT extends C implements I {\n    public void mI() {}\n}\n\nclass Test {\n    <T extends C & I> void test(T t) { 	\n        t.mI();           // OK\n        t.mCPublic();     // OK \n        t.mCProtected();  // OK \n        t.mCDefault();    // OK\n        t.mCPrivate();    // Compile-time error\n    } \n}','<T extends C & I> is apparently legal, \n\nmore research is necesarry','General',1,NULL),(2625,'class Foo{\n\npublic static ArrayList<Animal> staggerSort(ArrayList<? extends Animal> list){\n        Map<String,List<Number>> byCategory = seperateToCategories(list);\n        return null;\n    }\n    \n    static Map<String,List<Number>> seperateToCategories(ArrayList<? extends Animal> list){\n        return null;\n    }\n    \n}','This will compile because seperateToCategories takes an Animal or a subtype\n\n','Generics',1,NULL),(2626,'public class Hello{\n    public static void main(String[] args){\n        Hello h = new Hello();\n        h.access();\n    }\n\n    public void access() {\n        try (Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees\", \"root\", \"Basketball12\")) {\n           Statement st = conn.createStatement();\n           conn.setAutoCommit(true);\n           String q = \"update employees set first_name = \'h\' where emp_no = 10001\";\n           boolean t = st.execute(q);\n           \n           \n           \n           conn.commit();\n\n        } catch (SQLException e) {\n            System.out.println(e);\n        }\n    }\n}','java.sql.SQLException: Can\'t call commit when autocommit=true','JDBC',1,NULL),(2627,'new OpenOption[]{StandardOpenOption.READ, StandardOpenOption.DELETE_ON_CLOSE}\nnew OpenOption[]{StandardOpenOption.APPEND, StandardOpenOption.CREATE_NEW}	\n	This throws java.lang.UnsupportedOperationException: \'APPEND\' not 				allowed.\n\n','ok','Input/Output',1,NULL),(2628,'Path p1 = Paths.get(\"c:\\\\..\\\\temp\\\\test.txt\");    System.out.println(p1.normalize().toUri());','In this case, .. is at the top level and there is no parent directory at this level. Therefore, it is redundant and is removed from the normalized path. Had there been a parent directory for .., for example, c:/temp/../test.txt, the parent directory and .. would cancel out ( i.e. the result would be c:/test.txt ).','Input/Output',1,NULL),(2629,'test','tets','Executors',1,NULL),(2630,'The location of the deployment descriptor is ?	','','Servlets',1,NULL),(2631,'The location of the deployment descritptor is ?','/WEB-INF/web.xml\n','Servlets',1,NULL),(2632,'When using multi-catch, the catch block parameter is final and cannot \nhave a new value assigned to it in the catch block.\n\ntry{\n\n} catch(SQLException | IOException e){\n	\n	e = new IOException();\n}\n\n// this shows why thats illegal, your not sure which exception type \nwill come through.\n//updated 2','try{\n\n}catch(Exception1 | Exception2 e) {\n\n	e = new Exception1();\n}\n\nTHIS WOULD FAIL COMPILATION\n\n','Exceptions',1,NULL),(2633,'To compile old code that may use \'assert\' as an identifier, \nadd 1.3. This will tell the compiler to treat the word \'assert\' as an identifier.\n\n1.4 will use \'assert\' as a keyword	','javac -source 1.3 OldCode.java\n\njavac -source 1.4 NewCode.java','Exceptions',1,NULL),(2634,'Disable assertions at runtime		','java -da com.maxbisesi.Test\n\njava -disableassertions com.maxbisesi.Test','Exceptions',1,NULL),(2635,'Dont use assert expressions that can cause side effects...','This is a bad idea...\n\npublic void doStuff(){\n	assert (modifyThings());\n	//continue\n}\n\npublic boolean modifyThings() {\n	y = x++;\n	return true;\n}','Exceptions',1,NULL),(2636,'You cant use the variable name multiple times in a multi-catch. \nThe following wont compile...\n\ncatch(Exception1 e1 | Exception2 e2){\n\n}','Fails compilation','Exceptions',1,NULL),(2637,'With Multi catch order does NOT matter...		','the following are equivalent:\n\ncatch(SQLException | IOException e)\n\ncatch(IOException | SQLException e)\nTEST','Exceptions',1,NULL),(2638,'With Multi-Catch you have to make sure a given excpetion can only\nmatch one type...\n\ncatch(IOException | SQLException e)\n\nthese two are different types.','The following will not compile...\n\ncatch(FileNotFoundException | IOException e)\n\nsince FILNOTFOUND is a subclass of IOException we could have just\nwrtten that in the first place..\n\ncatch(IOException)','Exceptions',1,NULL),(2639,'Legal or illegal...\n\ntry {\n	//do something\n} catch(IOException e){\n	\n	e = new IOException();\n}','This is legal but it is not good practice. It is illegal to reasign the value\nof a multi-catch parameter. \n\ntry {\n	\n} catch(SQLException | IOException e){\n\n	e = new IOException();\n}\n\n^^WILL NOT COMPILE\n','Exceptions',1,NULL),(2640,'public void couldthrow() throws SQLException, IOException { }\n\npublic void rethrow() throws SQLException, IOException {\n	try{\n		couldthrow();\n	} catch(Exception e){ \n		e = new IOException();\n		throw e;\n	}\n}	','Will not compile, it is legal to reassign the parameter here. But it is illegal\nto throw e. The method declares that it throws SQL and IO so throwing a \ngeneral exception is unreported. \n\nif the signature was throws Exception then everything would be fine\n\nException as a genreal','Exceptions',1,NULL),(2641,'legal or illegal\n\ntry {\n\n}','Illegal, regular trys have to have a catch or a finally\n\ntry-with can be used by themselves','Exceptions',1,NULL),(2642,'try(String s = \"hi\") {}','does not compile. \nto be declared in a try with the method has to implement auto closeable or\ncloseable','Exceptions',1,NULL),(2643,'Path p = Paths.get(\"/home/maxbisesi\");\n      try(BufferedReader br = new BufferedReader(new FileReader(p.toFile())), BufferedWriter bw = new BufferedWriter(new FileWriter(p.toFile()))){\n          \n      } catch(IOException e){\n          \n      }','will not compile,\nThe declared resources use a commma , not a semi colon ;\n\nshould be:\n\ntry(Resource r = new Resource(); ...','Exceptions',1,NULL),(2644,'Class A implements AutoCloseable { \n	public void close() throws Exception {}\n}	','ok, AutoCloseable interface allows throwing any Exception','Exceptions',1,NULL),(2645,'class B implements AutoCloseable { public void close() {}}\nclass C implements AutoCloseable { public void close() throws IOException {}}','ok sublcasses or implenting methods can throw a subclass of excpetion\nor none at all.\n\nAutoCloseable\'s  close throws an Exception','Exceptions',1,NULL),(2646,'class D implements Closeable { public void close() throws Exception{}}','ILLEGAL- Closeable only allows IOExceptions or subclasses','Exceptions',1,NULL),(2647,'class E implements Closeable { public void close() throws IOException {}}','ok Closeable allows throwing IOExceptions\n\nvoid close() throws IOException','Collections',1,NULL),(2648,'idempotent','you can call close() multiple times all day and nothing will happen the second time and beyond. \nwill not blow up. ','Exceptions',1,NULL),(2649,'AutoCloseable\'s close() is idempotent	','nothing bad will happen if you call close() more than one time. ','Exceptions',1,NULL),(2650,'Closeable\'s close() is not idempotent','might blow up if called more than once','Exceptions',1,NULL),(2651,'class A implements AutoCloseable {\n	public void close() {\n		sout(\"A\");\n	}\n}\n\nclass B implements AutoCloseable {\n	public void close() {\n		sout(\"B\");\n	}\n}\n\nclass C {\n	psvm(sa){\n		try(A a = new A(); B b = new B()){\n			throw new RuntimeException();\n		} catch(EXception e) {\n			sout(\"catch\");\n		}\n	}\n}\n\nwhat does it print?','B\nA\ncatch\n\nResources are closed in reverse order from what they are declared.','Exceptions',1,NULL),(2652,'public class Suppressed {\n	psvm(sa) {\n		try(One one = new One()) {\n			throw new exception(\"try\");\n		} catch (Exception e) {\n			sout(e.getMessage());\n			\n			for(Throwable t : e.getSuppressed()){\n				sout(\"suppressed:\" + t);\n		}	}\n	}\n}\n\nclass One implements AutoCloseable {\n	public void close() throws IOException {\n		throw new IOException(\"Closing\");\n	}\n}','Try\nsuppressed: java.io.IOException: Closing\n\nafter the exception in the try block gets thrown on line 4, the try with \nresources still calls close() and the catch block catches one \nof the exceptions.\n\nJava adds any excpeittions thrown by close() methods to a suppressed array in the main excpetion. \n\nif no other exception happens in the try block the exceptioon thrown in\nclose() gets treated as the main excpetion  for the catch block. ','Exceptions',1,NULL),(2653,'If the catch or Finally block throws an exception NO SUPPRESSION HAPPENS\nthe last exception thrown gets sent to the caller rather than the one from the \ntry- just like before try with resources','got it ','Exceptions',1,NULL),(2654,'class Bad implements AutoCloseable {\n	String name;\n	Bad(String n) { name = n; }\n	public void close() throws IOException {\n		throw new IOException(\"Closing -\" +name);\n	}\n}\n\npublic class Suppressed {\n	public static void main(SA) {\n		try(Bad b1 = new Bad(\"1\"); Bad b2 = new Bad(\"2\")) {\n			\n		} catch(Exception e) {\n			sout(e.getMessage());\n			for(Throwable t : e.getSuppressed()) {\n				sout(\"suppressed:\" + t);\n			}\n		}\n	}\n}','Closing - 2\nsuppressed: java.io.IOException: Closing - 1\n\nresources close in the opposite order they are declared','Exceptions',1,NULL),(2655,'Stream classes are used to read and write bytes, and Readers and Writers\nare used to read write Characters....','Since all file IO on the exam is related to characters, if you see a Stream\nlike DataOutputStream the the question is probably about serialization\nor something unrelated to the actual IO objective','Input/Output',1,NULL),(2656,'psvm(SA) {\n	try {\n		boolean newFile = false;\n		File file = new File(\"fiileWrite1.txt\");\n		sout(file.exists());\n		newFile = file.createNewFile());\n		sout(newFile);\n		sout(file.exists());\n	} catch (IOException e) {}\n}	','// first time\nfalse\ntrue \ntrue\n\n//second time\ntrue\nfalse\ntrue\n\nexists returns false the first time becasue the file was created as an object\nbut not yet as a physical file. ','Input/Output',1,NULL),(2657,'public static void main(String[] args){\n        File newFile = new File(\"/home/maxbisesi/Public/textFile5.txt\");\n        try{\n            System.out.println(newFile.exists());\n            newFile.createNewFile();\n            System.out.println(newFile.exists());\n        } catch(IOException e){\n            \n        }   \n    }','This method returns true if it can find the actual file\n\nfalse\ntrue\n\n	the first time it is run','Input/Output',1,NULL),(2658,'File method: \ntry {\n	createNewFile();\n} catch(IOException e) { } ','true if the named file does not exist and was successfully created; false if the named file already exists\n','Input/Output',1,NULL),(2659,'File class Constructors	','File(File parent, String child)\nCreates a new File instance from a parent abstract pathname and a child pathname string.\n\nFile(String pathname)\nCreates a new File instance by converting the given pathname string into an abstract pathname.\n\nFile(String parent, String child)\nCreates a new File instance from a parent pathname string and a child pathname string.','Input/Output',1,NULL),(2660,'File class key methods ','createNewFile()\ndelete()\nexists()\nisDirectory()\nisfile()\nlist()\nmkdir()\nrenameTo()','Input/Output',1,NULL),(2661,'FileWriter class Constructors	','FileWriter(File file)\n\nFileWriter(String filename)','Input/Output',1,NULL),(2662,'FileWriter class key methods 	','close()\nflush()\nwrite()','Input/Output',1,NULL),(2663,'BufferedWriter class constructors	','BufferedWriter(Writer out)','Input/Output',1,NULL),(2664,'BufferedWriter key methods	','close() \nflush()\nnewLine()\nwrite()','Input/Output',1,NULL),(2665,'PrintWriter constructors','PrintWriter(File file)\nCreates a new PrintWriter, without automatic line flushing, with the specified file.\n\nPrintWriter(File file, String csn)\nCreates a new PrintWriter, without automatic line flushing, with the specified file and charset.\n\nPrintWriter(OutputStream out)\nCreates a new PrintWriter, without automatic line flushing, from an existing OutputStream.\n\nPrintWriter(OutputStream out, boolean autoFlush)\nCreates a new PrintWriter from an existing OutputStream.\n\nPrintWriter(String fileName)\nCreates a new PrintWriter, without automatic line flushing, with the specified file name.\n\nPrintWriter(String fileName, String csn)\nCreates a new PrintWriter, without automatic line flushing, with the specified file name and charset.\n\nPrintWriter(Writer out)\nCreates a new PrintWriter, without automatic line flushing.\n\nPrintWriter(Writer out, boolean autoFlush)\nCreates a new PrintWriter.','Input/Output',1,NULL),(2666,'FileReader key methods 	','read()','Input/Output',1,NULL),(2667,'BufferedReader constructors	','Reader','Input/Output',1,NULL),(2668,'BufferedReader key methods','read()\nreadLine()','Input/Output',1,NULL),(2669,'File file = new file(\"filewriter2.txt\");\nFileWriter fw = new fileWriter(file);\n\nPrintWriter pw = new PrintWriter (fw);\n\npw.println(\"hello\");\npw.println(\"world\"));','filewrite2.txt would contain the text:\n\nhello\nworld','Input/Output',1,NULL),(2670,'File file = new File(\"filewrite2.txt\");\nFileReader fr = new FileReader(file);\nBufferedReader br = new BufferedReader(fr);\n\nString data = br.readLine();','','Input/Output',1,NULL),(2671,'File file = new File(\"foo\");\n\nif \"foo\" does not exist no actual file is created.\n\nif \"foo\" does exists, the new File object refers to the existing file. ','got it ','Input/Output',1,NULL),(2672,'readers dont have flush methods','io','Input/Output',1,NULL),(2673,'Console.readPassword() returns...','a char[]','Input/Output',1,NULL),(2674,'Path Method:\n\nPath getName(int index)','Returns the path element corresponding to the specified index.\n\nthe 0th element is the one closest to the root.','Input/Output',1,NULL),(2675,'Path Method:\n\nString getFileName()','returns the filename or the last element of the sequence of name elements\n\nor..\n\nReturns the name of the file or directory denoted by this path as a Path object. The file name is the farthest element from the root in the directory hierarchy.','Input/Output',1,NULL),(2676,'public class Hello {\n    public static void main(String[] dicks) throws IOException{\n      Path src = Paths.get(\"/home/maxbisesi/Documents/copy.txt\");\n\n      System.out.println(src.getNameCount());\n      \n    }\n\n}','4','Input/Output',1,NULL),(2677,'\npublic class Hello {\n    public static void main(String[] dicks) throws IOException{\n      Path src = Paths.get(\"/home/maxbisesi/Documents/copy.txt\");\n      Path srcParent = src.getParent();\n      System.out.println(srcParent);\n      \n    }\n\n}','\n/home/maxbisesi/Documents','Input/Output',1,NULL),(2678,'Path Method:\n\nPath getRoot()		','retunrs the root of thsi path, or null if this path does not have a root.','Input/Output',1,NULL),(2679,'Path Method:\n\nPath subpath(int beginindex, int endIndex)','returns a ssubsequence of this path NOT INCLUDING ROOT. \n\nbeginning INCLUSIVE\n\nending EXCLUSIVE','Input/Output',1,NULL),(2680,'Path extends from Iterable<Path>	','that means it can be iterated through in a for loop!','Input/Output',1,NULL),(2681,'int spaces = 1;\nPath myPath = Paths.get(\"tmp\", \"dir1\", \"dir2\", \"dir3\", \"file.txt\");\n\nfor(Path subpath : myPath){\n	sout( subpath + \"//\" );\n}','tmp/dir1/dir2/dir3/file.txt','Input/Output',1,NULL),(2682,'Path method:\n\nPath normalize()	','returns a path that is this path with redundant name elements eliminated\n\n. can be ignored\n\n.. followed by a directory can be removed as redundant','Input/Output',1,NULL),(2683,'Paths.get(\"/a/./b/./c\").normalize();\n','/a/b/c','Input/Output',1,NULL),(2684,'Paths.get(\".classpath\").normalize();','.classpath','Input/Output',1,NULL),(2685,'Paths.get(\"/a/b/c/..\").normalize()','/a/b','Input/Output',1,NULL),(2686,'Paths.get(\"../a/b/c\").normalize()','../a/b/c\n\nThe two dots do say go up one directory, but since there is\'nt a directory\nbefore it Path cant simplify it.','Input/Output',1,NULL),(2687,'Path dir = Paths.get(\"/home/java\");\nPath file = Paths.get(\"models/Model.pdf\");\nPath result = dir.resolve(file);\n\nsout( result );\n	','/home/java/models/Model.pdf\n\npath1.resolve(path2) should be read as \"resolve path2 within path1s directory\n','Input/Output',1,NULL),(2688,'class Hello {\n    public static void main(String[] args) {     \n        Path p1 = Paths.get(\"/home/max/tmp\");\n        Path p2 = Paths.get(\"/google\");\n        System.out.println(p1.resolve(p2));\n        \n    }\n\n}','/google\n\nResolve the given path against this path.\n\nIf the other parameter is an absolute path then this method trivially returns other.\n If other is an empty path then this method trivially returns this path.\n Otherwise this method considers this path to be a directory and resolves\n the given path against this path. In the simplest case, the given path does not have a root component, \nin which case this method joins the given path to this path \nand returns a resulting path that ends with the given path.','Input/Output',1,NULL),(2689,'Path absolute = Paths.get(\"/home/java\");\nPath relative = Paths.get(\"dir\");\nPath file = Paths.get(\"Model.pdf\");\n\nsout( absolute.resolve(relative) );\nsout( asolute.resolve(file) );\nsout( relative.resolve(file) );\nsout( relative.resolve(absolute) ); // BAD\nsout( file.resolve(absolute) ); //BAD\nsout( file.resolve(relative) ); //BAD','/home/java/dir\n/home/java/Model.pdf\n/dir/Model.pdf\n/home/java\n/home/java\nModel.pdf/dir\n\nThe first three do what you would exprect. They add the paramenter\nto resolve to the provided path object. The fourth and fifth try to resolve\nan absolute path within the context of something else. The problem is \nthat an aboluste path doesnt\'t depend on other directories it is absolute.\n','Input/Output',1,NULL),(2690,'Be carefule with questions that come in two flavors. one with a Path parameter\nand the other with a String parameter such as resolve()...\n\nPath path = Paths.get(\"/usr/bin/zip\");\npath.resolve(null);','Thhe compilere cannot decide here so it will not compile','Input/Output',1,NULL),(2691,'Which Path method is used to combine two paths and set one in another?','resolve()','Input/Output',1,NULL),(2692,'Which Path method is used to describe how to gret from one path to \nthe other	','relativize()','Input/Output',1,NULL),(2693,'Path dir = Paths.get(\"/home/java\");\nPath music = Paths.get(\"/home/java/country/Swift.mp3\");\nPath mp3 = dir.reltivize(music);\n\nsout( mp3 );','country/Swift.mp3\n\n\njava recognized that the /home/java part is the same and returned a path of\njust the remainder.\n\npath1.relativize(path2) should be read as \"give me a path shows how to get from\npath1 to path2\"','Input/Output',1,NULL),(2694,'\"give me a path shows how to get from\npath1 to path2\"','.relativize()','Input/Output',1,NULL),(2695,'Path absolute1 = Paths.get(\"/home/java\");\nPath absolute2 = Paths.get(\"/usr/local\");\nPath absolute3 = Paths.get(\"/home/java/temp/music.mp3\");\nPath relative1 = Paths.get(\"temp\");\nPath relative2 = Paths.get(\"temp/music.pdf\");\n\nsout( absolute1.relativize(absolute3) );\nsout( absolute3.relativize(absolute1) );\nsout( absolute1.relativize(absolute2) );\nsout( relative1.relativize(relative2) );\nsout( absolute1.relativize(relative1) ); //BAD','temp/music.mp3\n\n../..\n\n../../usr/local\n\nmusic.pdf\n\nExcpetion in main thread IllegalArgumentExcpetion\n\n	','Input/Output',1,NULL),(2696,'relativeize()','Path relativize(Path other)\n\nConstructs a relative path between this path and a given path.\n\nRelativization is the inverse of resolution. This method attempts to construct a relative path that when resolved against this path, yields a path that locates the same file as the given path. For example, on UNIX, if this path is \"/a/b\" and the given path is \"/a/b/c/d\" then the resulting relative path would be \"c/d\". Where this path and the given path do not have a root component, then a relative path can be constructed. A relative path cannot be constructed if only one of the paths have a root component. Where both paths have a root component then it is implementation dependent if a relative path can be constructed. If this path and the given path are equal then an empty path is returned.\n\nFor any two normalized paths p and q, where q does not have a root component,\n\n    p.relativize(p.resolve(q)).equals(q) \n\nWhen symbolic links are supported, then whether the resulting path, when resolved against this path, yields a path that can be used to locate the same file as other is implementation dependent. For example, if this path is \"/a/b\" and the given path is \"/a/x\" then the resulting relative path may be \"../x\". If \"b\" is a symbolic link then is implementation dependent if \"a/b/../x\" would locate the same file as \"/a/x\".\n\nParameters:\n    other - the path to relativize against this path\nReturns:\n    the resulting relative path, or an empty path if both paths are equal\nThrows:\n    IllegalArgumentException - if other is not a Path that can be relativized against this path','Input/Output',1,NULL),(2697,'When creating a Path you can seperate out folder and filename as much\nor as little as you want. When you don\'t begin with a root the Path\nis considered a relative path, which means Java looks from the current\ndirectory.\n\nPath p6 = Paths.get(\"tmp\", \"file1.txt\"); // relative path\n\n/ (root)\n	| - - tmp\n		| - file1.txt\n		| - tmp\n			| - file1.txt\n','If this program is run from the root, it is the one in /tmp/file1.txt\n\nif it is run from /tmp it is the one in /tmp/tmp/file1.txt\n\nif the program is run from anywhere else the path refers to a file that doesn\nnot exist. ','Input/Output',1,NULL),(2698,'With IO a file doesn\'t exists just because you create a File object.\nIt is the same with Path objects\n\nPath path = Paths.get(\"fileWrite1.txt\");\nsout(Files.exists(path)); // false\nFiles.createFile(path); \nsout(Files.exists(path)); // true','got it ','Input/Output',1,NULL),(2699,'create directories one at a time or all at once	......\n\nTHE directory must exist by the time the file is created','Path path1 = Paths.get(\"/java/source\");\nPath path2 = Paths.get(\"/java/source/directory\");\nPath file = Paths.get(\"/java/source/directory/Program.java\");\nFiles.createDirectory(path1);\nFiles.createDirectory(path2);\nFiles.createFile(file);\n\n// all at once\n\nFiles.createDirectories(path2);\nFile.createFile(file);','Input/Output',1,NULL),(2700,'Date januaryFirst = new GregorianCalendar(20q3, Calendar.January, 1).getTime();\n\nFile file = new File(\"c:/temp/file\");\nfile.createNewFile();\nfile.setLastModified(januaryFirst.getTime());\nfile.setLastModified(januaryFirst.getTime());\nsout(file.lastModified());\nfile.delete();','13570164000000','Input/Output',1,NULL),(2701,'Path path = Paths.get(\"c:/temp/file2\");\nDate januaryFirst = new GregorianCalendar(2013,Calendar.JANUARY, 1).getTime();\nFiles.createFile(path);\nFileTime fileTime = FileTime.fromMillis(januaryFirst.getTime());\nFiles.setLastModifiedTime(path,fileTime);\nsout(Files.getLastModifiedTime(path));\nFiles.delete((path);','2013-01-01T05','Input/Output',1,NULL),(2702,'How would you get the last modified date/time of a Path and a File?\n\nFile file = new file(\"test\");\nPath path = Paths.get(\"test\");','\nfile.lastModified();\n\nFiles.getLastModifiedTime(path);','Input/Output',1,NULL),(2703,'public class Hello {\n    static Thread max ,angela;\n    public static void main(String[] args){\n        angela = new Thread() {\n            public void run(){\n                System.out.println(\"A\");\n                try {\n                    max.sleep(1000);\n                } catch(Exception e){\n                    System.out.println(\"B\");\n                }\n                System.out.println(\"C\");\n                \n            }\n        };\n        \n        max = new Thread() {\n            public void run(){\n                System.out.println(\"D\");\n                try {\n                    angela.wait(); \n                } catch(Exception e){\n                    System.out.println(\"E\");\n                }\n                \n                System.out.println(\"F\");\n            }\n        };\n        \n        max.start();\n        angela.start();   \n    }\n} ','A C D E F \n\nin an undeterminable order, although thread angela uses the max reference\n.Sleep is static and therefore she puts herself to sleep. This is why\nreferences shouldn\'t be used for static methods. \n\nmax trys to synchronize on angela but he does not own the lock so he therefore\ncannot and throws an IllegalMonitorStateException. \n\n... ','Input/Output',1,NULL),(2704,'How would you get theread permision set of a Path and a File?\n\nFile file = new file(\"test\");\nPath path = Paths.get(\"test\");','file.canRead();\n\nFiles.isReadable(path);','Input/Output',1,NULL),(2705,'How would you get write and or execute permision set of a Path and a File?\n\nFile file = new file(\"test\");\nPath path = Paths.get(\"test\");','file.canWrite();\nfile.canExecute();\n\nFiles.isWritable(path);\nFiles.isExecutable(path);','Input/Output',1,NULL),(2706,'How do you set the last modified time of a path and file?\n\nFile file = new file(\"test\");\nPath path = Paths.get(\"test\");','file.setLastModifed(timeinMillis);\n\nFileTime ft = FileTime.fromMillis(timeInMillis);\nFiles.setLastModifiedTime(path,ft);','Input/Output',1,NULL),(2707,'BasicFileAttributes basic = Files.readAttributes(path, BasicFileAttributes.class);\n\nhow would you list the creation time, last access time, and last Modified time?	\n','basic.creationTime();\nbasic.lastAccessTime();\nbasick.lastModifiedTime();\n\nbasic.isDirectory();\n\n','Input/Output',1,NULL),(2708,'Three big things about BasicFileAttributes and BasicFileAttributeView...','1. BasicFileAttributes is PLURAL, BasicFileAttributeVIew is SINGULAR\n\n2. BasicFIleAttributeView basView = Files.getFileAttributeView(   );   \n\n	BasicFileAtttributes bas = FIles.readAttributes(   );\n\n3. You can ONLY update attributes in BasicFileAttributeView, \n	\n	VIEW IS FOR UPDATING','Input/Output',1,NULL),(2709,'How would you construct a PosixFileAttribute object?	','PosixFileAttributes pox = Files.readAttributes(path, PosixFileAttributes.class);\n','Input/Output',1,NULL),(2710,'How would you set a Unix File\'s permissions in Java?	','Path path = Paths.get(\"/tmp/file2\");\nFiles.createFile(path);\nPosixFileAttributes ps = Files.readAttributes(path, PosixFileAttributes.class);\n\nSet<PosixFilePermission> perms = PosixFilePermission.fromString(\"rw-r--r--\");\n\nFiles.setPosixFilePermissions(path,perms);\n\nsout( ps.permissions() );\n\nTHe output would be:\n\n[OWNER_WRITE, GROUP_READ, OTHERS_READ, OWNER_READ ]','Input/Output',1,NULL),(2711,'How to take modified times from one file\nand write new BasicFileAttributes\' last modified times\nlast access time and creation time to another file ... ?','BasicFileAttributes basic = Files.readAttributes(path1, BasicFileAttribute.class );\n\nFileTime at = basic.lastAccessTime();\nFileTime update = basic.lastModifiedTime();\nFileTime now = FileTime.fromMillis(System.currentTimeMiilis() );\n\nPath file = Paths.get(\"/temp/file.txt\");\nFiles.createFile(file);\n\nBasicFileAttributeView view = Files.getBasicFileAttributeView(file, BasicFileAttributeView.class);\n\nview.setTimes(update, at, now);','Input/Output',1,NULL),(2712,'BasicFileAttributeView is a...\n\nClass\n\nInterface\n\nAbstract class     ?','... interface\n\nmethods:\n\nString 	name()\nReturns the name of the attribute view.\n\nBasicFileAttributes 	readAttributes()\nReads the basic file attributes as a bulk operation.\n\nvoid 	setTimes(FileTime lastModifiedTime, FileTime lastAccessTime, FileTime createTime)\n\nUpdates any or all of the file\'s last modified time, last access time, and create time attributes.','Input/Output',1,NULL),(2713,'interface BasicFileAttributes methods.... ','FileTime 	creationTime()\nReturns the creation time.\n\nObject 	fileKey()\nReturns an object that uniquely identifies the given file, or null if a file key is not available.\n\nboolean 	isDirectory()\nTells whether the file is a directory.\n\nboolean 	isOther()\nTells whether the file is something other than a regular file, directory, or symbolic link.\n\nboolean 	isRegularFile()\nTells whether the file is a regular file with opaque content.\n\nboolean 	isSymbolicLink()\nTells whether the file is a symbolic link.\n\nFileTime 	lastAccessTime()\nReturns the time of last access.\n\nFileTime 	lastModifiedTime()\nReturns the time of last modification.\n\nlong 	size()\nReturns the size of the file (in bytes).','Input/Output',1,NULL),(2714,'interface PosixFileAttributes methods','GroupPrincipal 	group()\nReturns the group owner of the file.\n\nUserPrincipal 	owner()\nReturns the owner of the file.\n\nSet<PosixFilePermission> 	permissions()\nReturns the permissions of the file.','Input/Output',1,NULL),(2715,'interface PosixFileAttributeView methods ...','String 	name()\nReturns the name of the attribute view.\n\nPosixFileAttributes 	readAttributes()\nReads the basic file attributes as a bulk operation.\n\nvoid 	setGroup(GroupPrincipal group)\nUpdates the file group-owner.\n\nvoid 	setPermissions(Set<PosixFilePermission> perms)\nUpdates the file permissions.','Input/Output',1,NULL),(2716,'With DosFileAttributeView you can set what new and different file types ?','DosFileAttributeView has methods...\n\nsetArchive()\nsetHidden()\nsetReadOnly()\nsetSystem()\n\nfor Windows specific files ','Input/Output',1,NULL),(2717,'interface DosFileAttributeView methods...','String 	name()\nReturns the name of the attribute view.\n\nDosFileAttributes 	readAttributes()\nReads the basic file attributes as a bulk operation.\n\nvoid 	setArchive(boolean value)\nUpdates the value of the archive attribute.\n\nvoid 	setHidden(boolean value)\nUpdates the value of the hidden attribute.\n\nvoid 	setReadOnly(boolean value)\nUpdates the value of the read-only attribute.\n\nvoid 	setSystem(boolean value)\nUpdates the value of the system attribute.','Input/Output',1,NULL),(2718,'read a DosFileAttributes then declare if it is hidden and readonly \nthen set them so without using a DosFileAttributeView...','DosFileAttributes dos = Files.readAttributes(path, DosFileAttributes.class);\n\nsout( dos.isHidden() );\nsout( dos.isReadOnly() );\n\nFiles.setAttribute(path, \"dos:hidden\", true);\nFiles.setAttribute(path, \"dos:readonly\", true);\n\n','Input/Output',1,NULL),(2719,'You dont always need a XXXFileAttributeView object in order to change\na files attributes, you can just as easily do so with \"Files\" ...\n	','\n    setAttribute\n\n    public static Path setAttribute(Path path,\n                    String attribute,\n                    Object value,\n                    LinkOption... options)\n                             throws IOException\n\n    Sets the value of a file attribute.\n\n    The attribute parameter identifies the attribute to be set and takes the form:\n\n        [view-name:]attribute-name \n\n    where square brackets [...] delineate an optional component and the character \':\' stands for itself.\n\n    view-name is the name of a FileAttributeView that identifies a set of file attributes. If not specified then it defaults to \"basic\", the name of the file attribute view that identifies the basic set of file attributes common to many file systems. attribute-name is the name of the attribute within the set.\n\n    The options array may be used to indicate how symbolic links are handled for the case that the file is a symbolic link. By default, symbolic links are followed and the file attribute of the final target of the link is set. If the option NOFOLLOW_LINKS is present then symbolic links are not followed.\n\n    Usage Example: Suppose we want to set the DOS \"hidden\" attribute:\n\n        Path path = ...\n        Files.setAttribute(path, \"dos:hidden\", true);\n     \n\n    Parameters:\n        path - the path to the file\n        attribute - the attribute to set\n        value - the attribute value\n        options - options indicating how symbolic links are handled\n    Returns:\n        the path parameter\n    Throws:\n        UnsupportedOperationException - if the attribute view is not available\n        IllegalArgumentException - if the attribute name is not specified, or is not recognized, or the attribute value is of the correct type but has an inappropriate value\n        ClassCastException - if the attribute value is not of the expected type or is a collection containing elements that are not of the expected type\n        IOException - if an I/O error occurs\n        SecurityException - In the case of the default provider, and a security manager is installed, its checkWrite method denies write access to the file. If this method is invoked to set security sensitive attributes then the security manager may be invoked to check for additional permissions.\n\n','Input/Output',1,NULL),(2720,'You dont need PosixFileAttributeView to set a file permissions either...','Files.setPosixFilePermissions\n\npublic static Path setPosixFilePermissions(Path path,\n                           Set<PosixFilePermission> perms)\n                                    throws IOException\n\nSets a file\'s POSIX permissions.\n\nThe path parameter is associated with a FileSystem that supports the PosixFileAttributeView. This attribute view provides access to file attributes commonly associated \nwith files on file systems used by operating systems that implement the Portable \nOperating System Interface (POSIX) family of standards.\n\nParameters:\n    path - A file reference that locates the file\n    perms - The new set of permissions\nThrows:\n    UnsupportedOperationException - if the associated file system does not support the PosixFileAttributeView\n    ClassCastException - if the sets contains elements that are not of type PosixFilePermission\n    IOException - if an I/O error occurs\n    SecurityException - In the case of the default provider, and a security manager is installed, it denies RuntimePermission(\"accessUserInformation\") or its checkWrite method denies write access to the file.','Input/Output',1,NULL),(2721,'How to set a linux files permisions from a string ?\n	','PosixFileAttributes pos = Files.readAttributes(path, PosixFileAttributes.class);\nSet<PosixFilePermissions> perms = PosixFilePermissions.fromString(\"rw-r--r--:);\n\nFiles.setPosixFilePermissions(path,perms);\n\nsout(pos.group());\nsout(pos.permissions());','Input/Output',1,NULL),(2722,'What interface is used to recursively loop through a directory ?	','DirectoryStream<T> \n\nT is the element returned by the iterator. \n\nTHis allows for the convieninet use of a for - each loop to go through a dir.\n\nThe elements returned by the iterator are in no specific order.\n\n List<Path> listSourceFiles(Path dir) throws IOException {\n       List<Path> result = new ArrayList<>();\n       try (DirectoryStream<Path> stream = Files.newDirectoryStream(dir, \"*.{c,h,cpp,hpp,java}\")) {\n           for (Path entry: stream) {\n               result.add(entry);\n           }\n       } catch (DirectoryIteratorException ex) {\n           // I/O error encounted during the iteration, the cause is an IOException\n           throw ex.getCause();\n       }\n       return result;\n   }\n ','Input/Output',1,NULL),(2723,'how do you create a new DirectoryStream<T>','\n    Files.newDirectoryStream\n\n    public static DirectoryStream<Path> newDirectoryStream(Path dir)\n                                                    throws IOException\n\n    Opens a directory, returning a DirectoryStream to iterate over all entries in the directory. The elements returned by the directory stream\'s iterator are of type Path, each one representing an entry in the directory. The Path objects are obtained as if by resolving the name of the directory entry against dir.\n\n    When not using the try-with-resources construct, then directory stream\'s close method should be invoked after iteration is completed so as to free any resources held for the open directory.\n\n    When an implementation supports operations on entries in the directory that execute in a race-free manner then the returned directory stream is a SecureDirectoryStream.\n\n    Parameters:\n        dir - the path to the directory\n    Returns:\n        a new and open DirectoryStream object\n    Throws:\n        NotDirectoryException - if the file could not otherwise be opened because it is not a directory (optional specific exception)\n        IOException - if an I/O error occurs\n        SecurityException - In the case of the default provider, and a security manager is installed, the checkRead method is invoked to check read access to the directory.\n\n','Input/Output',1,NULL),(2724,'What type of object are returned by directorystreams iterator ? ','Path\n\nThe directory Stream interface is generic, but thats misleading since the \nonly way create a new DirectoryStream is by using File.newDirectoryStream\nwhich returns a Path.','Input/Output',1,NULL),(2725,'How would you filter the object returned by a directory Stream ?	','use \nFiles.newDirectoryStream(Path dir, String glob);\n\nthis lets you add a glob in that will compare the string representations \nof their file names agains the given glob.\n\nthis lets you filter your results...\n\n Path dir = ...\n     try (DirectoryStream<Path> stream = Files.newDirectoryStream(dir, \"*.java\")) {\n         :\n     }','Input/Output',1,NULL),(2726,'What will be returned by this code...\n\n	Path dir = Paths.get(\"/home/maxbisesi/Documents\");\n        \n	try(DirectoryStream<Path> ds = Files.newDirectoryStream(dir,\"[vx]*\")){\n            sout( );\n        } ','Nothing will not compile, must catch IOException for DirectoryStream','Input/Output',1,NULL),(2727,'How many directories at a time can DirectoryStream look at ?','only 1','Input/Output',1,NULL),(2728,'Think, DirectorySteam acts like ls in bash.','or ...\nDirectoryStream streams one directory','Input/Output',1,NULL),(2729,'What \"Files\" method do you use along with FileVisitor?','public static Path walkFileTree(Path start,\n                FileVisitor<? super Path> visitor)\n                         throws IOException\n\nWalks a file tree.\n\nThis method works as if invoking it were equivalent to evaluating the expression:\n\n     walkFileTree(start, EnumSet.noneOf(FileVisitOption.class), Integer.MAX_VALUE, visitor)\n     \n\nIn other words, it does not follow symbolic links, and visits all levels of the file tree.\n\nParameters:\n    start - the starting file\n    visitor - the file visitor to invoke for each file\nReturns:\n    the starting file\nThrows:\n    SecurityException - If the security manager denies access to the starting file. In the case of the default provider, the checkRead method is invoked to check read access to the directory.\n    IOException - if an I/O error is thrown by a visitor method','Input/Output',1,NULL),(2730,'FileVisitor methods return what ?','FileVisitResult','Input/Output',1,NULL),(2731,'Enum FileVisitResult elements','CONTINUE\nSKIP_SIBLINGS = continue without visiting the siblings of this file or directory\n\nSKIP_SUBTREE = continue without visiting the entries in this directory\n\nTERMINATE','Input/Output',1,NULL),(2732,'SimpleFileVisitor has a protected constructor so It can only be extended','SimpleFileVisitor sf = new SimpleFileVisitor() will not compile','Input/Output',1,NULL),(2733,'try(DirectoryStream stream = Files.newDirectoryStream(dir)){\n	sout(\"throw excpetion\");\n	//do stuff\n}\n\nWhats wrong here ?','DirectoryStream throws an IOException. Therefore anytime you use \nDirectoryStream you must catch an IOException\n\ntry(DirectoryStream stream = Files.newDirectoryStream(dir)){\n	sout(\"throw excpetion\");\n	//do stuff\n} catch(IOException e) { \n	log(e);\n}','Input/Output',1,NULL),(2734,'try(DirectoryStream stream = Files.newDirectoryStream(dir)){\n\n	for(Path file : stream){\n		sout(file.getFileName());\n	}\n} catch(IOException e ){\n\n}\n\nWhats wrong here ??','If DirectroyStream is not typed it will give Object elements. Therefore\nto use an untyped DirectoryStream you would have to use...\n	\n	for(Object file : stream) {\n	\n	}\n\n... but thats usually not what you want so always do this>>>\n\n	try(DirectoryStream<Path> Stream = Files.newDirectoryStream(dir)){\n\n	} catch(IOExcetpion e) {\n\n	}','Input/Output',1,NULL),(2735,'\npublic class CopyCharacters {\n    public static void main(String[] args) throws IOException {\n\n        FileReader inputStream = null;\n        FileWriter outputStream = null;\n\n        try {\n            inputStream = new FileReader(\"xanadu.txt\");\n            outputStream = new FileWriter(\"characteroutput.txt\");\n\n            int c;\n            while ((c = inputStream.read()) != -1) {\n                outputStream.write(c);\n            }\n        } finally {\n            if (inputStream != null) {\n                inputStream.close();\n            }\n            if (outputStream != null) {\n                outputStream.close();\n            }\n        }\n    }\n}\n','All character stream classes are descended from Reader and Writer. \nAs with byte streams, there are character stream classes that specialize in file I/O: FileReader and FileWriter. \nThe CopyCharacters example illustrates these classes.\n\nclose() throws IOException here too','Input/Output',1,NULL),(2736,'What has to be done with pretty much ALL IO classes ?','wrap them in Try Block, they all throw IOExceptions ','Input/Output',1,NULL),(2737,'What method does BufferedReader have that makes it valuable	','public String readLine()\n                throws IOException\n\nReads a line of text. A line is considered to be terminated by any one of a line feed (\'\\n\'), a carriage return (\'\\r\'), or a carriage return followed immediately by a linefeed.\n\nReturns:\n    A String containing the contents of the line, not including any line-termination characters, or null if the end of the stream has been reached\nThrows:\n    IOException - If an I/O error occurs\n\n\nOther IO classes have read methods that only read in a single character\nBufferedReader has this too. But this method really helps!','Input/Output',1,NULL),(2738,'Which IO class swallows exceptions and does not throw them but \nsaid exceptions can be checked using checkerror()','PrintWriter','Input/Output',1,NULL),(2739,'Path file = Paths.get(\"/home/dick/bigorsmall.txt\");\nBufferedWriter bw = new BufferedWriter(new FileWriter(file));\n\nbw.write(\"this ones pretty big \");','wont compile you cant construct a FileWriter from a Path not to mention there is an unreported IOException','Input/Output',1,NULL),(2740,'Files method:\n\nPath copy(Path src, Path targ, CopyOption...options)','Copy the file from the source to target and return the target.\n\nthrows FileAlreadyExistsException if target fiile already exists, and no\nREPLACE_EXSISTING copy Option is specified. ','Input/Output',1,NULL),(2741,'Files method:\n\nPath move(Path src, Path target, CopyOption options)','Moves the file from src to target return target. \n\nthrows:\n\n FileAlreadyExistsException - if the target file exists but cannot be replaced because the REPLACE_EXISTING option is not specified (optional specific exception)\n   \n DirectoryNotEmptyException - the REPLACE_EXISTING option is specified but the file cannot be replaced because it is a non-empty directory (optional specific exception)','Input/Output',1,NULL),(2742,'Path p1 = Paths.get(\"/home/One.txt\");\nPath p2 = Paths.get(\"One.txt\");\nPathMatcher matcher = FileSystems.getDefault().getPathMatcher(\"glob:*.txt\");\n\nsout( matcher.matches(p1) );\nsout( matcher.matches(p2) );','false \ntrue\n\nin glob * means match any character excpet a directory boundary\n\n** mathces any character across directory boundaries. \n\nnotice that PathMatcher(\"syntax:pattern\") can take a glob or a regex but you\nmust specify\n\nedit:\nwas previously:\nDefault().getPathMatcher(\"glob: *.txt\");\n\nthere cant be a space after the : or that will mathch...\n\n	Path path = Paths.get(\"one.txt\");\n        PathMatcher matcher = FileSystems.getDefault().getPathMatcher(\"glob: *.txt\");\n        System.out.println(matcher.matches(path));\n\nwould give false unless the space was removed. | Path p1 = Paths.get(\"/home/One.txt\");\nPath p2 = Paths.get(\"One.txt\");\nPathMatcher matcher = FileSystems.getDefault().getPathMatcher(\"glob: *.txt\");\n\nsout( matcher.matches(p1) );\nsout( matcher.matches(p2) );','Input/Output',1,NULL),(2743,'in Glob what does * mean ? what about ** ?','* matches any character inside a directory boundary\n** matches any character inside a directory boundary\n\n','Input/Output',1,NULL),(2744,'GLOB\n\nwhat does \"?\" mean ?','? matches any single character. ','Input/Output',1,NULL),(2745,'public class Hello {\n    public static void main(String[] args) {\n        PathMatcher matcher = FileSystems.getDefault().getPathMatcher(\"glob:**{.pic,.txt}\");\n        Path p1 = Paths.get(\"home/files.txt\");\n        Path p2 = Paths.get(\"documents/pictures/smile.pic\");\n        Path p3 = Paths.get(\"home/dir\");\n        \n        System.out.println(matcher.matches(p1));\n        System.out.println(matcher.matches(p2));\n        System.out.println(matcher.matches(p3));\n    }\n\n}','true\ntrue\nfalse','Input/Output',1,NULL),(2746,'public void matches(Path path, String glob){\n	PathMatcher matcher = FileSystems.getDefault().getPathMatcher(glob);\n	sout( matcher.matches(path) );\n}\n\nPath p1 = Paths.get(\"Bert-book\");\nPath p2 = Paths.get(\"Kathy-horse\");\nmatches(p1, \"glob:{Bert*,Kathy*}\");\nmatches(p2, \"glob: {Bert, Kathy}*\");\nmatches(p1, \"glob:{Bert,Kathy}\");','true\ntrue\nfalse','Input/Output',1,NULL),(2747,'FileVisitor\n\npublic FileVisitResult visitFileFailed(path file, BasicFileAttributes attrs) {\n\n	// do something\n	return FileVisitResult.CONTINUE;\n	\n}\n','wrong, visitFileFailed takes an IOExcpeption as a parameter\nas well as postVisitDirectory','Input/Output',1,NULL),(2748,'FileVisitor: \n\npublic FileVisitResult preVisitDirectory(path file, BasicFileAttributes attrs) {\n\n	// do something\n	return FileVisitResult.CONTINUE;\n	\n}','right, ','Input/Output',1,NULL),(2749,'FileVisitor:\n\npublic FileVisitResult visitFileFailed(path file, IOException e) {\n\n	// do something\n	return FileVisitResult.CONTINUE;\n	\n}','right','Input/Output',1,NULL),(2750,'FileVisitor:\n\npublic FileVisitResult postVisitDirectory(path file, IOException e) {\n\n	// do something\n	return FileVisitResult.CONTINUE;\n	\n}','right','Input/Output',1,NULL),(2751,'Date today = new Date();\n\nDateFormat df = DateFormat.getInstance();\n\nString todayFile = df.format(today);\n\nsout(todayFile);	// this gives 9/8/01 7:46 PM\n\ntodayFile.replaceAll(\" \",\"-\");\n\nsout( todayFile );\n\nwhat prints now ?','9/8/01 7:46 PM \n\nremember that strings are imutable, so even though you called \nreplaceAll on that string you didn\'t assing it to a new sString therefore it\nwas lost.\n\nshould be:\n	String newDate = todayFile.replaceAll(\" \",\"-\");','Strings',1,NULL),(2752,'Path p1 = Paths.get(todayFile+\".txt\");\nSystem.out.println(p1);\n        \nBufferedWriter bw = new BufferedWriter(new FileWriter(p1));','wont compile, FileWriter doesn\'t have a Path constructor,\n\nchange p1 to p1.toFile();\n\nFileWriter(File file)\nConstructs a FileWriter object given a File object.\n\nFileWriter(File file, boolean append)\nConstructs a FileWriter object given a File object.\n\nFileWriter(FileDescriptor fd)\nConstructs a FileWriter object associated with a file descriptor.\n\nFileWriter(String fileName)\nConstructs a FileWriter object given a file name.\n\nFileWriter(String fileName, boolean append)\nConstructs a FileWriter object given a file name with a boolean indicating whether or not to append the data written.','Input/Output',1,NULL),(2753,'class Eggs {\n	int doX(Long x, Long y){ return 1; }\n	int doX(long...){ return 2; }\n	int doX(Integer x, Integery){ return 3; }\n	int doX(Number n, Number m){ return 4; }\n	public static void main(SA){\n		new Eggs().go();\n	}\n	void go(){\n		short s = 7;\n		sout(doX(s,s) + \" \");\n		sout(doX(7,7));\n	}\n}','4 3 \n\ntwo rules apply to the first doX, you cannot widen and then box in\none step, and var-args are always chosen last. So you cannot widen shorts\nto ints or longs then box them to Integer or Long but you can box short\nto Short then widen that to Number, that takes priority over var args.\n\nthe second doX simmply boxs int to Integer.\n\n\n\n    Assignment contexts allow the use of one of the following:\n\n        an identity conversion (§5.1.1)\n\n        a widening primitive conversion (§5.1.2)\n\n        a widening reference conversion (§5.1.5)\n\n        a boxing conversion (§5.1.7) optionally followed by a widening reference conversion\n\n        an unboxing conversion (§5.1.8) optionally followed by a widening primitive conversion.\n\n\n','General',1,NULL),(2754,'What is the first and second argument to Files.walkFileTree()','the first is the directory to start walking at in the form of a Path\n\nthe second is an object of the class that extends SimpleFileVisitor<Path>','Input/Output',1,NULL),(2755,'Which Two FileVisitor methods take IOExceptions as parameters	?','visitFileFailed and postVisitDirectory','Input/Output',1,NULL),(2756,'Which two FileVisitor methods take BasicFileAttributes as parameters ?','preVisitDirectory and visitFile','Input/Output',1,NULL),(2757,'/home\n	- a.txt\n	- emptyChild	\n	- child\n		- b.txt\n		- grandchild\n			- c.txt\n\npublic class PrintDirs extends SimpleFileVisitor<Path> {\n	public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) {\n		sout( \"pre\" + dir);\n		String name = dir.getFileName().toString();\n		\n		if (name.equals(\"child\"))\n			return FileVisitResult.SKIP_SUBTREE;\n		return FileVisitResult.CONTINUE;\n\n	}\n}\n			\n			\n		\n	','now the output is:\n	pre: /home\n	file: /home/a.txt\n	pre: /home/child\n	pre: /home/emptyChild\n	post: /home/emptyChild\n	post: /home\n\npostVisitDirectory is never called if the subtree of the directory is skipped','Input/Output',1,NULL),(2758,'postVisitDirectory is never called if the subtree of the directory is skipped','','Input/Output',1,NULL),(2759,'/home\n	- a.txt\n	- emptyChild	\n	- child\n		b.txt\n		grandchild\n		c.txt\n\n\" assume you have FileVisitor method from previous flashcards where the\npre post and file are printed before printing the path of that dir or file \"\n\npublic FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) {\n	sout( \"pre: \" + dir);\n	String name = dir.getFileName().toString();\n	\n	if (name.equals(\"grandchild\"))\n		return FileVisitResult.SKIP_SUBTREE;\n	if ( name.equals(\"emptychild\")\n		return FileVisitResult.SKIP_SIBLINGS;\n	return FileVisitResult.CONTINUE;','assuming child is encountered beffore emptyChild, the output is: \n\npre: /home\nfile: /home/a.txt\npre: /home/child\nfile: /home/child/b.txt\npre: /home/child/grandchild\npost: /home/child\npre: /home/emptyChild\npost: /home\n\nyou skip the grandchld subtree so you dont see the postVisitDirectory call\n\nchild is a sibling but it was encountered before emptychild so it was not skipped','Input/Output',1,NULL),(2760,'public void matches(Path path, String glob){\n	PathMatcher matcher = FileSystems.getDefault().getPathMatcher(glob);\n	sout( matcher.matches(path) );\n}\n\nPath p1 = Paths.get(\"0*b/test/1\");\nPath p2 = Paths.get(\"9\\\\*b/test/1\");\nPath p3 = Paths.get(\"01b/test/1\");\nPath p4 = Paths.get(\"0*b/1\");\n\nString glob = \"[0-9]\\\\*{A*,b}/**/1\");\n\nmatches(p1,glob);\nmatches(p2,glob);\nmatches(p3,glob);\nmatches(p4,glob);\n','true \nfalse\nfalse\nfalse\n\n{A*,b} means A followed by anything or the single character b\n\n/**/ means one or more directories with any name\n\n\\\\* the actuall asterix character \\ escapes the * the second \\ espaces the first \\ ','Input/Output',1,NULL),(2761,'What exception if any do FileVisitor methods throw ?','IOException','Input/Output',1,NULL),(2762,'glob vs regex: \n\nZero or more of any character, including directory bounndary','glob: **\n\nregex: .*','Input/Output',1,NULL),(2763,'regex:\n\n.*','zero or or more of any character including directory boundary','Input/Output',1,NULL),(2764,'glob vs regex:\n\nZero or more of any character, not a directory boundary','glob: *\n\nregex: no syntax required','Input/Output',1,NULL),(2765,'Glob vs regex:\n\nexcactly one character','glob: ?\n\nregex: .','Input/Output',1,NULL),(2766,'glob vs regex:\n\nBegins with cat or dog','glob:\n	{cat, dog}*\n\nregex:\n\n	(cat|dog).*','Input/Output',1,NULL),(2767,'(cat|dog).*\n\nglob or regex ?','regex','Input/Output',1,NULL),(2768,'You are creating a PathMatcher\n\nPathMatcher matcher = ________._________().__________();','FileSystems.getDefault().getPathMatcher();','Input/Output',1,NULL),(2769,'You are creating a WatchService:\n\nWatchService watcher = _____________.__________()._________()','FileSystems.getDefault().newWatchService();','Input/Output',1,NULL),(2770,'What do you get from a WatchService to indicate a deletion creation or modification','WatchKey\ntry {\n	WatchKey key;\n	try {\n	key = watcher.take();\n              } catch(interuptedException x) {\n		return;\n	}\n	for(WatchEvent<?> event : key.pollEvents()){\n	//do stuff\n	}','Input/Output',1,NULL),(2771,'What are two ways to get a WatchKey ? \nand whats the difference between them ? ','take() will wait and block forever until an event takes place. Will throw\nInteruptedException if interuped without taking an event. \n\npoll() returns null if an event is not imediately available. ','Input/Output',1,NULL),(2772,'public class Frodo etends Hobbit {\n	public static void main(SA) { \n		int mygold = 7;\n		sout(countGold(mygold,6));\n	}\n}\nclass Hobbit {\n	int countGold(int x, int y) { return x + y; }\n}','does not compile countGold() cannot be called from a static context','Input/Output',1,NULL),(2773,'The contract between equals() and hashCode() is:','1) If two objects are equal, then they must have the same hash code.\n2) If two objects have the same hash code, they may or may not be equal. \n3) If two objects are not equal, they must NOT have the same hashcode\n','OOP',1,NULL),(2774,' public static void main(String[] args){\n       Path dir = Paths.get(\"/home/maxbisesi\");\n       try(DirectoryStream<Path> stream = Files.newDirectoryStream(dir,\"*\");){\n            for(Path path : stream){\n               System.out.println(path);\n            }\n        } catch(IOException e){\n            System.out.println(\"SQLException\");\n            System.out.println(e);\n        }\n   }','shows all files and directories in /home/maxbisesi\n\nsqlexception if the path is not a valid path','Input/Output',1,NULL),(2775,'public class Hello {\n    synchronized void a() { actBusy(); }\n    static synchronized void b() { actBusy(); }\n    static void actBusy() {\n        try {\n            Thread.sleep(1000);\n            \n        } catch( InterruptedException e){}\n            \n        \n    }\n    public static void main(String[] args) {\n        final Hello x = new Hello();\n        final Hello y = new Hello();\n        \n        Runnable runnable = new Runnable() {\n            public void run() {\n                int option = (int) (Math.random() * 4);\n                switch(option) {\n                    case 0: x.a(); break;\n                    case 1: x.b(); break;\n                    case 2: y.a(); break;\n                    case 3: y.b(); break;\n                }\n            }\n        };\n        \n        Thread t1 = new Thread(runnable);\n        Thread t2 = new Thread(runnable);\n        \n        t1.start();\n        t2.start();\n    \n    }\n\n}  \n\nwhich methods could never be running at the same time ?','x.a() thread1 x.a() in thread2\nx.b() thread1 x.b() in thread2\nx.b() thread1 y.b() in thread2\n\nthe same instance method of the same instance is blocked while a static\nmethod accross all methods is blocked. ','Threads',1,NULL),(2776,'Method forwarding relies on Has-a relationships','got it ','OOP',1,NULL),(2777,'class Animal implements Burriable {\n    private Integer size;\n    private String name;\n    \n    public Animal(int x, String y){\n        size = x;\n        name = y;\n    }\n    public Animal(){\n        size = 0;\n        name = \"\";\n    }\n\n    public int getSize() {\n        return size;\n    }\n\n    public String getName() {\n        return name;\n    }\n    \n    public void bury(){\n        System.out.println(\"just toss him in there...\");\n    }\n    public void digUp(){\n        System.out.println(\"Hang on this ones still kickin !\");\n    }\n    public void pray(){\n        System.out.println(\"...Lord forgive us for what we have done, hes only been gone for \"+YEARSDEAD+\" years.\");\n    }\n}\n\nclass Dog implements Burriable{\n    private Animal animal;\n    public Dog(Animal a){\n        animal = a;\n    }\n    \n    public void bury(){\n        animal.bury();\n    }\n    public void digUp(){\n        animal.digUp();\n    }\n    public void pray(){\n        animal.pray();\n    }\n    \n    public String yelpForHelp(){\n        return \"ar ar arrr....\";\n    }\n}\n\ninterface Burriable {\n    int YEARSDEAD = 1;\n    void bury();\n    void digUp();\n    void pray();\n}\n\nwhat OOP principle is this ?','method forwarding\n\nan object composition principle that calles methods on an instance variable of an object','OOP',1,NULL),(2778,'public class F {\n	private static final F f = new F();\n	public static F c(){\n		return f;\n	}\n\n	public void update(F a) { }\n	\n	public void delete(F a) { }\n\n}\nwhat design pattern is this ? ','The singleton pattern is identifiable bby the static variable for the single instance and the accessor returning it. ','OOP',1,NULL),(2779,'public class E {\n	private D d;\n	public void m() {\n		d.m();\n	}\n\n		public static E getInstance() {\n			return new E();\n		}\n}\n\nclass D {\n	public void m() { }\n}\n\nwhat design pattern principle is this ?\n','object composition, you can tell because of the method forwarding. \nSingleton is tempting but the getInstance method here returns a NEW instance\ninstead a single private static one like it should to be singleton. ','OOP',1,NULL),(2780,'class A {}\n\nabstract class G {\n	A m() { return n(); }\n	abstract A n();\n}\n\nwhat principle is demostrated','Factory,\n\nClass A is the object we are creating using the factory method. class G\nis the abstract superclass for the factory. Not shown is a class implementing \nclass G that actually creates the object. ','OOP',1,NULL),(2781,'which is a benefit of the DAO pattern ?	','Reuse The DAO pattern centralize logic for the data access code making reuse\neasier and allowing you to switch out implementations. ','OOP',1,NULL),(2782,'public void print(Path d) throws IOException {\n	try(DirectoryStream<Path> stream = Files.newDirectoryStream(d)){\n		for(Path path: stream){\n			sout( path.getFileName() );\n		}\n	}\n}\n\nwhat files will this display ? ','regular files, hidden files, and subdirectories','Input/Output',1,NULL),(2783,'public class Hello {\n    public static void main(String[] dicks) throws IOException{\n      Path src = Paths.get(\"/home/maxbisesi/Documents/copy.txt\");\n      Files.createFile(src);\n      \n      Files.copy(src, Paths.get(\"/home/maxbisesi/Documents/newcopy.txt\"));\n      \n    }\n\n}\n\nwhat happens if this is ran twice and all preivous files dont exist before','The first time the file will be created and copied normally the second time you\nwill get a file already exists excpeiotn','Input/Output',1,NULL),(2784,'public class Hello {\n    public static void main(String[] dicks){\n        ArrayList list = new ArrayList();\n        \n        list.add(\"java\");\n        list.add(\"sucks\");\n        \n        String item = list.get(0);\n\n    }\n\n}','Compilation fails, to compile would have to be \n\n	Object item = list.get(0);','Collections',1,NULL),(2785,'if(true)\n       int b = 1;\n        ','Will not compile, there is no scope there \n\nif(true){\n	int b = 1;\n} \n	this would though !','General',1,NULL),(2786,'public class Hello {\n    public static void main(String[] dicks){\n        Pattern p = Pattern.compile(\"C.*L\");\n        Matcher m = p.matcher(\"CooLooLCuuLooC\");\n        \n        while(m.find())\n            System.out.println(m.group());\n\n    }\n\n}','CooLooLCuuL\n\n* is the greedy quantifier, it takes as much as it can. ','Strings',1,NULL),(2787,'If a thread\'s priority is not specified explicitly then it gets\nNORM_PRIORITY\n\nT or F ','False it gets the same priority as the thread that created it ','Threads',1,NULL),(2788,'public class Hello {\n    public static void main(String[] dicks){\n        Animal ah2 = new Horse();\n        ah2.eat(\"carrots\");\n    }\n\n}\n\nclass Animal{\n    public void eat(){ }\n}\n\nclass Horse extends Animal {\n    public void eat() { }\n    public void eat(String s ){ } \n}\n    ','Will not compile, method eat in class animal cannot be applied to given types','General',1,NULL),(2789,'public class Hello {\n    public static void main(String[] dicks){\n        Animal ah2 = new Horse();\n        ah2.eat();\n    }\n\n}\n\nclass Animal{\n    public void eat(){ System.out.println(\"Animal\"); }\n}\n\nclass Horse extends Animal {\n    public void eat(){ System.out.println(\"Horse\");} \n}\n\n','Horse','General',1,NULL),(2790,'public class Hello {\n    public static void main(String[] dicks){\n        Animal ah2 = new Horse();\n        ah2.eat();\n    }\n\n}\n\nclass Animal{\n    public void eat(){ System.out.println(\"Animal\"); }\n}\n\nclass Horse extends Animal {\n    public void eat() throws IOException{ System.out.println(\"Horse\");} \n}','will not compile overriden method \ncannot throw new or broader checked exceptions','General',1,NULL),(2791,'public class Hello {\n    public static void main(String[] dicks){\n        Animal ah2 = new Horse();\n        ah2.eat();\n    }\n\n}\n\nclass Animal{\n    public void eat(){ System.out.println(\"Animal\"); }\n}\n\nclass Horse extends Animal {\n    public void eat(int x) throws IOException{ System.out.println(\"Horse\");} \n}','Animal\n\neat in horse is an overload, it still inherits Animals eat()','General',1,NULL),(2792,'//assume valid Connection cn, and good database connection\n\nString query = \"Select * from Answer\";\ntry(Statement stmt = cn.createStatement()){\n	ResultSet rs1 = stmt.executeQuery(query);\n	stmt.executeQuery(\"select * from Question\");\n	while(rs1.next(){\n		sout(rs1.getInt(\"fk_question_num\");\n	}\n} catch(SQLException e){\n	\n}','SQLException\n	Statement objects do not support multiple open ResultSets.\n	\n	Only a single ResultSet can be opened from the same statement object\n\n	*if the same statement object is executed more than once the previous\n	ResultSet is closed automatically\n		\n		... and attempting to access a closed RS is a SQLException','JDBC',1,NULL),(2793,'','','blank',1,NULL),(2794,'try(Connection conn = DriverManager.getConnection(url,user,pw)){\n	String pQuery = \"Select unitPrice From Book Where Title Like ?\";\n\n	PreparedStatement pstmt = conn.prepareStatement(pQuery);\n\n	ResultSet rs = pstmt.executeQuery();\n} catch(SQLException sq) {\n}\n','SQLException , attempting to execute a query without setting a parameter\nresults in an SQLException\n\n	should be>>>\n		\n		pstmt.setString(1,\"dick\");\n\nIndexing starts at 1','JDBC',1,NULL),(2795,'public class Hello {\n    public static void main(String[] dicks){\n        try{\n            couldthrow();\n        } catch(IOException | SQLException e){\n            \n        }\n        \n    }\n    \n    public static void couldthrow() throws IOException, SQLException{\n        \n    }\n\n}','compiles and runs just fine ','Exceptions',1,NULL),(2796,'public boolean equals(Object o) { \n	if(((Moof)o).getMoofValue() == this.moofValue {\n		return true;\n	} else {\n		return false;\n	}\n}\n\nwhats missing here','instanceof test','Collections',1,NULL),(2797,'equals() hashCode() and toString() are all PUBLIC','got it','Collections',1,NULL),(2798,'equals() Contract\n\nreflexive	','for any reference value x, x.equals(x) should be true. ','Collections',1,NULL),(2799,'equals() contract,\n\nsymmetric','for any reference values x and y, \n\nx.equals(y) shoud be true if and only if \ny.equals(x) returns true. ','Collections',1,NULL),(2800,'what are the four tenants of the equals contract ?','reflxive, x.equals(x) is always true\n\nsymetric, x.equals(y) and y.equals(x)\n\ntransitive, if x.equals(y) and y.equals(z) then x.equals(z)\n\nconsistent, x.equals(y) is true no matter how many times you call it\n\nif x is non null, x.equals(null) is always false','Collections',1,NULL),(2801,'if two objects are considered equal, their hashcodes...','MUST also be equal.','Collections',1,NULL),(2802,'Is it still legal to have a hashcode that always returns the same number ?','Yes just inefficient, all objects will go in the same bucket. The Collection\nwill search through a single big bucket using equal() to find the instance\nits looking for. In that case you defeat the purpose of using a hashed collection. ','Collections',1,NULL),(2803,'HashCode contract:\n\n1\n\n2\n\n\n3','When it is invoked on the same object more than once during an execution\nof a java application the hashcode() method must consistently return the \nsame integer \n\nIf two objects are equal according to the equals method, then calling hashchode)( \non each of the objects must produce the same integer\n\nunequal objects can still produce the same hashcodes \n\n*That means that equals and hashCode must work with same attributes somehow','Collections',1,NULL),(2804,'x.equals(y) == true\n\nmeans what for hashcode()...','x.hashcode() == y.hashcode()','Collections',1,NULL),(2805,'x.hashCode() != y.hashCode()	\n\nmeans what for equals()','x.equals(y) == false\n\nequals() and hashcode are like directions to get to a specific \nelement\n\nhashCode places all the elements in seperate but similiar buckets \nequals() gets the correct ones out.\n\nso if two elemets have different hashCodes they will be in different buckets\nanyway so hashCode is one level of precision and equals() is the next.','Collections',1,NULL),(2806,'public static void main(String[] args){\n        Path p = Paths.get(\"/home/maxbisesi/Public/GenDir/genFile.txt\");\n        Path p2 = Paths.get(\"/home/maxbisesi/Public\");\n        \n        System.out.println(p.relativize(p2));\n        System.out.println(p2.relativize(p));  \n}','../..\nGenDir/genFile.txt\n','Input/Output',1,NULL),(2807,'Collections:\n\n	Vector\n','a Vector is the same as an ArrayList but Vector methods are synchronized\nfor thread safety. \n\nVector and Hashtable are the two original collections\n\nunless you really need thread safety choose ArrayList over Vector, \nthe synchronized methods give an unecssary performance hit. \n\n','Collections',1,NULL),(2808,'Collections:\n\n	LinkedList','is ordered by index position except that the elements are doubly linked to \none another. This linkage gives you new methods for adding and removing\nfrom the beginning or end.\n\nEasy choice for implementing a stack or queue. \n\nmay iterate more slowly than ArrayList but still a good choice when you need\nfast insertion and deletion.\n\nLinkedList supports peek(), poll(), offer(), Queue methods!!','Collections',1,NULL),(2809,'Which Interface disallows duplicates','Set','Collections',1,NULL),(2810,'Collections:\n	\n	HashSet','unsorted and unordered. Uses the hashcode of the object being inserted\n\nso the more effeicinet your hashcode the more effecient access youll get\n\nUse for a collection with no duplicates where you dont care about the\norder when you iterate through it.','Collections',1,NULL),(2811,'Collections:\n\n	LinkedHashSet','\nMaintains a doubly linked list across elelemnts so the insertion order \nis maintained\n\nduplicates are still disallowed. ','Collections',1,NULL),(2812,'Collections:\n\n	TreeSet','Sorted\n\nguarentees elements will be in ascending order according to natural order\n\n','Collections',1,NULL),(2813,'public class Reader {\n	public void read(Path p, Charset s) {\n		try(BufferedReader r = Files.newBufferedReader(p,s)) {\n			try { r.read(); }\n			catch(IOException f) {\n				r.readLine();\n			}\n		} catch(IOException || NullPointerException e) {\n			r.close();\n		} finally {\n			r.close();\n		}\n	}\n}','compilation fails at the last three lines,\n\n1. multi catch syntax is | not ||\n\n2. objects declared in a try block are only available within the \ntry block so closing r is out of scope','Input/Output',1,NULL),(2814,'Collections:\n\n	HashMap','unsorted and unordered Map. \n\nUse When you need a map and you don\'t care\nabout the order when you iterate through. \n\nThe basic map, other maps add a little more overhead. \n\nWhere keys land in the map is based on hashCode() \n\nHashMap allows one null key and multiple null values ','blank',1,NULL),(2815,'Collections:\n	\n	Hashtable\n	','Hashtable is the synchronized counterpart to HashMap. \n\nWhile HashMap lets you have a null key and null values\n\nHashtable doesn\'t allow anything thats null!','Collections',1,NULL),(2816,'HashMap allows multiple null values','True!\n\nHashtable doesn\'t allow anything null it will throw a npe','Collections',1,NULL),(2817,'HashMap allows multiple null keys','FALSE\n\nThat would defeat the purpose of a \"key\"','Collections',1,NULL),(2818,'HashMap is sorted','FALSE\n\nunordered and unsorted','Collections',1,NULL),(2819,'HashMap is synchronized','FALSE','Collections',1,NULL),(2820,'Hashtable is synchronized ','True!','Collections',1,NULL),(2821,'Hashtable allows multiple null values and one null key','FALSE, nothing can be null in Hashtable','blank',1,NULL),(2822,'public static ArrayList<Animal> staggerSort(ArrayList<? extends Animal> list){\n        Map<String,List<Number>> byCategory = seperateToCategories(list);\n        return null;\n    }\n    \n    static Map<String,List<Number>> seperateToCategories(ArrayList<Animal> list){\n        return null;\n    }','since list is declared as anything that extends Animal you cant be sure that it\nwill be the right type to pass into the next method that taks <Animal>\n\nWill not compile','Generics',1,NULL),(2823,'public static void main(String[] args){\n        LinkedHashMap<String,String> lhm = new LinkedHashMap<>();\n        lhm.put(\"big\",\"Country\");\n        lhm.put(\"sweet\",\"Cheeks\");\n        lhm.put(\"big\",\"Bucks\");\n        \n        for(Map.Entry<String,String> entry: lhm.entrySet()){\n            System.out.println(entry.getKey()+\" \"+entry.getValue());\n        }\n        \n    }','big Bucks\nsweet Cheeks\n\nbig Bucks replaced big Country in the map, LinkedHashMaps maintain insertion\norder. \n\nso that mapping was simply replaced but it kept its position','Collections',1,NULL),(2824,'class Gutsy {\n	public static void main(String[] args){\n		new Gutsy().go();\n	}\n	void go() throws IOException {\n	String row;\n	try {\n		FileReader fr = new FileReader(\"TestFile.txt\");\n		BufferedReader br = new BufferedReader(fr);\n		while((row = br.readLine() ) != null)\n			sout( row );\n	} catch(IOException e) {\n		sout(\"got io error\");\n	} finally {\n		sout( \"done\" );\n	}\n   }\n}','WNC,\n\ngo() declares that it throws a checked exceptions so it has to be handled\nor thrown in main.\n\nif that would have compiled an IOException would be thrown so it would\nprint got io error done. ','Exceptions',1,NULL),(2825,'Given a properly prepared string[] with five elements what is the range \nof possible results that could be returned by Arrays.binarySearch() ? ','-6 through 4','Collections',1,NULL),(2826,'TreeMap','sorted Map\n\nsorted by natural order or custom comparison rules.','blank',1,NULL),(2827,'List<String> test = new ArrrayList<String>();\nString s = \"hi\";\ntest.add(\"string\");\ntest.add(s);\ntest.add(s+s);\nsout( test.size() );\nsout( test.contains(42) );\nsout( test.contains(\"hihi\") );\ntest.remove(\"hi\");\nsout( test.size() );','3\nfalse\ntrue\n2','Collections',1,NULL),(2828,'List myInts = new ArrayList();\n        myInts.add(4);\n        \n        myInts.add(new Integer(4));','These two are the same, the first demonstrates autoboxing. ','blank',1,NULL),(2829,'class Boxing2 {\n	static Integer x;\n	psvm(sa) {\n		doStuff(x);\n	}\n\n	static void doStuff(int z) {\n		int z2 = 5;\n		sout( z2 + z );\n	}\n}','NullPointerException','General',1,NULL),(2830,'public static void main(String[] dicks){\n        ArrayList<String> list = new ArrayList<>();\n        \n        list.add(\"CZ\");\n        list.add(\"a\");\n        list.add(\"AB\");\n        list.add(\"CE\");\n        list.add(\"CZ\");\n        list.add(\"cz\");\n        list.add(\"BA\");\n        list.add(\"BF\");\n        list.add(\"ABC\");\n        list.add(\"CE\");\n        list.add(\" CE\");\n        list.add(\"A\");\n        list.add(\"ce\");\n        list.add(\"A B\");\n        list.add(\"AA\");\n        list.add(\" Z\");\n        \n        System.out.println(\"unsorted: \"+list);\n        Collections.sort(list);\n        System.out.println(\"sorted: \"+list);','unsorted: [CZ, a, AB, CE, CZ, cz, BA, BF, ABC, CE,  CE, A, ce, A B, AA,  Z]\nsorted: [ CE,  Z, A, A B, AA, AB, ABC, BA, BF, CE, CE, CZ, CZ, a, ce, cz]\n\nspaces come first, as shown by A B and AA. Also capitals come before lowercase','Collections',1,NULL),(2831,'public class Hello {\n    public static void main(String[] dicks){\n        List<Horse> stable = new ArrayList<>();\n        \n        for(int x =0; x < 10; x++){\n            stable.add(new Horse());\n        }\n        \n        Collections.sort(stable);\n        \n    }\n\n}\n\nclass Horse {\n    public boolean equals(Horse s){\n        return false;\n    }\n}','Will not compile, Horse does not implement Comparable','Collections',1,NULL),(2832,'class Horse implements Comparable<Horse> {\n    public boolean equals(Horse s){\n        return false;\n    }\n    \n    int compareTo(Horse h){\n        \n    }\n    \n    \n}','will not compile, compareTo is public ','Collections',1,NULL),(2833,'public class Hello {\n    public static void main(String[] dicks){\n        List<Horse> stable = new ArrayList<>();\n        \n        for(int x =0; x < 10; x++){\n            stable.add(new Horse(\"lucky\"+x));\n        }\n        \n        Collections.sort(stable);\n        \n    }\n\n}\n\nclass Horse implements Comparable<Horse> {\n    String name;\n    \n    public Horse(String x){\n        name = x;\n    }\n    \n    public String getName(){\n        return name;\n    }\n    \n    public boolean equals(Horse s){\n        return false;\n    }\n    \n    public int compareTo(Horse h){\n        return name.compareTo(h.getName());\n        \n    }\n    \n    \n}','compiles fine!','Collections',1,NULL),(2834,'When you override equals() you must take an argument of what type ?','Object','Collections',1,NULL),(2835,'When you override compareTo() you must take an argument of type?','The type your sorting.\n\n\npublic interface Comparable<T>\n\n...type T','Collections',1,NULL),(2836,'class DVDInfo implements Comparable {\n	public int comparteTo(Object o) {\n		DVDInfo d = (DVDInfo) o;\n		return title.compareTo(d.getTitle() );\n	}\n}','This is still legal but painful, genereics make this easier but it will still \ncompile','Collections',1,NULL),(2837,'Comparator has _________________\n\nComparable has _________________','compare()\n\ncompareTo()','Collections',1,NULL),(2838,'Which soritng interface do you implement to create individual sorting classes\n	','Comparator','Collections',1,NULL),(2839,'class Dicksorter implements Comparator<Dicks> {\n	public int compareTo(Dick one) {\n	}\n}','will not compile the method is:\n\n	int compare(T o1, T o2)','Collections',1,NULL),(2841,'public class Hello {\n    public static void main(String[] dicks){\n        List<Horse> stable = new ArrayList<>();\n        \n        stable.add(new Horse(\"Honey\"));\n        stable.add(new Horse(\"Mighty Mikey\"));\n        stable.add( new Horse(\"The Fastest Stud in the Mud\"));\n        stable.add( new Horse(\"Churchill\"));\n        \n        Horse[] ranch = stable.toArray();\n\n    }\n\n}','Will not compile\n\ntoArray() in List interface returns an Object[]','Collections',1,NULL),(2842,'public class Hello {\n    public static void main(String[] dicks){\n        Horse[] stable = {new Horse(\"Johny\"), new Horse(\"wilfred\"), new Horse(\"Marco\"), new Horse(\"MAx\"), new Horse(\"Billy\") };\n        \n        int x = Arrays.binarySearch(stable,\"Johny\");\n        System.out.println(x);  \n\n    }\n\n}','ClassCastException, \"johny\" cant be turned into a horse\n\nshould be Arrays.binarySearch(stable,new Horse(\"Johny\"));','Collections',1,NULL),(2843,'public class Hello {\n    public static void main(String[] dicks){\n        Horse[] stable = {new Horse(\"Johny\"), new Horse(\"wilfred\"), new Horse(\"Marco\"), new Horse(\"MAx\"), new Horse(\"Billy\") };\n        \n        int x = Arrays.binarySearch(stable,new Horse(\"Johny\"));\n        System.out.println(x);  \n\n    }\n\n}    \n\nclass Horse implements Comparable<Horse> {\n    String name;\n    \n    public Horse(String x){\n        name = x;\n    }\n    \n    public String getName(){\n        return name;\n    }\n    \n    public boolean equals(Horse s){\n        return false;\n    }\n    \n    public int compareTo(Horse h){\n        return name.compareTo(h.getName());\n        \n    }\n    \n    \n    ','The results are undefined, the array is not sorted. ','Collections',1,NULL),(2844,'public class Hello {\n    public static void main(String[] dicks){\n        Horse[] stable = {new Horse(\"Johny\"), new Horse(\"wilfred\"), new Horse(\"Marco\"), new Horse(\"MAx\"), new Horse(\"Billy\") };\n        \n        \n        int x = Arrays.binarySearch(stable,new Horse(\"Marco\"));\n        System.out.println(x);  \n\n    }\n\n}\n\nclass Horse {\n    String name;\n    \n    public Horse(String x){\n        name = x;\n    }\n    \n    public String getName(){\n        return name;\n    }\n    \n    public boolean equals(Horse s){\n        return false;\n    }\n    \n}','ClassCastException Horse cannot be converted to Comparable\n\nbinarySearch uses comparable to search the Array.\n\nThis search would give inconsistant results anyways because \nthe array was not sorted first. \n\nto fix add this:\n\nclass Horse implements Comparable<Horse> {\n    String name;\n    \n    public Horse(String x){\n        name = x;\n    }\n    \n    public String getName(){\n        return name;\n    }\n    \n    public boolean equals(Horse s){\n        return false;\n    }\n    \n    public int compareTo(Horse s){\n        return name.compareTo(s.getName());\n    }\n    \n}\n\n-if an array is sorted in natrual order it must searched in natural order \n-if it is sorted using a comparator it must be searched using the same comparator.\n','Collections',1,NULL),(2845,'public class Hello {\n    public static void main(String[] dicks){\n        Horse[] stable = {new Horse(\"Johny\"), new Horse(\"wilfred\"), new Horse(\"Marco\"), new Horse(\"MAx\"), new Horse(\"Billy\") };\n        int x = Arrays.binarySearch(stable,new Horse(\"Marco\"));\n        System.out.println(x);  \n    }\n}\n\nclass Horse implements Comparable{\n    String name;\n    public Horse(String x){\n        name = x;\n    }\n    public String getName(){\n        return name;\n    }\n    public boolean equals(Horse s){\n        return false;\n    }\n    public int compareTo(Horse h){\n        return name.compareTo(h.getName());  \n    }\n}\n','Will not compile, if the untyped version of Comparable is used then\nthe parameter to compareTo would be Object\n\neither change to Comparable<Horse>\n\nor \n\ncomparTo(Object o) and cast.\n\notherwise, the answer would be 2 remember arrays aren\'t sorted even though\nyour using comparable the elements of an array dont get sorted so the positions are \nwhat index they were defined as !\n\nThis would give undefined results','Collections',1,NULL),(2846,'What method is used to search through Arrays and Collections','binarySearch()\n\nreturns the int index of the element being searched.\n\nUnsuccesful searches return an int index that represents the\n insertion point. \n\nThe collection or array must be sorted before you can search it.\n\nif you attempt to search an unsorted array or collection the results of the\nsearch will be unpredictable.\n\nIf it was sorted in natural order it must searched in natural order.\n	do this by NOT sending a Comparator as an argument to the binarySearch() \n\nIf it was sorted with a comparator it must be searched using the same comparator\n\n	\n	','Collections',1,NULL),(2847,'class Horse implements Comparable{\n    String name;\n    \n    public Horse(String x){\n        name = x;\n    }\n    \n    public String getName(){\n        return name;\n    }\n    \n    public boolean equals(Horse s){\n        return false;\n    }\n    \n    public int compareTo(Object h){\n        return name.compareTo(h.getName());\n  \n    }','will not compile, need to cast\n\nreturn name.compareTo(((Horse)h).getName());\n\ndoes not compile because h is an Object and Objects dont have a method\ncalled getName. \n\nyou would cast h to a horse. \n\nObject is the right argument type here though because Comparable is a raw type\nif it were Comparable<Horse> the argument would need to be Horse.','Collections',1,NULL),(2848,'public class Hello {\n    public static void main(String[] dicks){\n       Animal[] beavers = new Beaver[5];\n       \n       Animal[] animals = {new Beaver(), new Beaver(), new Beaver() };\n       \n       Animal[] ans2 = new Animal[5];\n       ans2[0] = new Beaver();\n\n    }\n}\n\nclass Animal{\n    public Animal(){\n        \n    }\n    \n    public String getName(){\n        return \"d\";\n    }\n}\n\nclass Beaver extends Animal{\n    \n}','these all compile fine, \n\nPolymorphism works with Arrays. ','Collections',1,NULL),(2849,'public class Hello {\n    public static void main(String[] dicks){\n       \n        String[] strings = {\"One\",\"Dice\",\"Angela\",\"Bisesi\",\"Franko\"};\n        \n        Arrays.sort(strings);\n        int x = Arrays.binarySearch(strings,\"Dice\");\n        System.out.println(x);  \n        \n        Arrays.sort(strings);\n        \n        System.out.println(Arrays.binarySearch(strings,\"Angela\"));\n    }\n\n}','2\n0','Collections',1,NULL),(2850,'class sortBySecondLetter implements Comparator<String> {\n    int compare(String one, String two){\n        \n    }\n}','compare must be public, will not compile','Collections',1,NULL),(2851,'class sortBySecondLetter implements Comparator<String> {\n    public int compare(String one, String two){\n        char charone = one.charAt(1);\n        char chartwo = two.charAt(1);\n        \n        return charone.compareTo(chartwo);\n    }\n}','will not compile, char is a primitive so charone cannot be dereferenced here\nchange to Character.','Collections',1,NULL),(2852,'public class Hello {\n    public static void main(String[] dicks){\n        sortBySecondLetter sbsl = new sortBySecondLetter();\n        String[] strings = {\"One\",\"Dice\",\"Angela\",\"Bisesi\",\"Franko\"};\n        \n        Arrays.sort(strings,sbsl);\n        \n        System.out.println(strings);\n    }\n\n}','[Ljava.lang.String;@15db9742\n\narrays are not classes','Collections',1,NULL),(2853,'String[] sa = {\"one\", \"two\", \"three\", \"four\" };\nList sList = Arrays.asList(sa);\n\nSout( \"size \" + sList.size() );\nsout( \"idx2 \" + sList.get(2) );\n\nsList.set(3,\"six\" );\nsa[1] = \"five\";\n\nfor(String s : sa ){\n	sout( s + \" \");\n}\nsout(\"\\n s1[1] \" + sList.get(1) );','size 4\nidx2 three\none \nfive \nthree \nsix \ns1[1] five','Collections',1,NULL),(2854,'public class Hello {\n    public static void main(String[] args){\n        String[] sa = {\"one\", \"two\", \"three\", \"four\" };\n        List sList = Arrays.asList(sa);\n\n        System.out.println( \"size \" + sList.size() );\n        System.out.println( \"idx2 \" + sList.get(2) );\n\n        sList.set(3,\"six\" );\n        sa[1] = \"five\";\n\n        for(String s : sa ){\n            System.out.println( s + \" \");\n        }\n        System.out.println(\"s1[1] \" + sList.get(1) );\n        \n        sList.remove(\"five\");\n        for(String s : sa)\n            System.out.println(s+\" \");\n    }\n\n}','UnsupportedOperationException\n\nThis UnsupportedOperationException comes when you try to perform some operation on collection where its not \nallowed and in your case, When you call Arrays.asList it \ndoes not return a java.util.ArrayList. It returns a java.util.Arrays$ArrayList which is an immutable list. \nYou cannot add to it and you cannot remove from it.\n\nReturns a {@code List} of the objects in the specified array. The size of the {@code List} cannot be modified, i.e. adding and removing are unsupported, but the elements can be set. Setting an element modifies the underlying array.\n\nEDIT\n\nThe type of the resulting list is Arrays.ArrayList, which is a private class inside Arrays.class. Practically speaking,\nit is nothing but a List-view on the array that you\'ve passed with Arrays.asList. With a consequence: if you change the array, the list is changed too. And because an array is not resizeable, \nremove and add operation must be unsupported.\n','Collections',1,NULL),(2855,'String[] sa = {\"one\", \"two\", \"three\", \"four\" };\n        List sList = Arrays.asList(sa);\n\n        System.out.println( \"size \" + sList.size() );\n        System.out.println( \"idx2 \" + sList.get(2) );\n\n        sList.set(3,\"six\" );\n        sa[1] = \"five\";\n\n        for(String s : sa ){\n            System.out.println( s + \" \");\n        }\n        System.out.println(\"s1[1] \" + sList.get(1) );\n        \n        sList.set(1, \"FIVE\");\n	sList.set(3,\"SIX);\n        for(String s : sa)\n            System.out.println(s+\" \");','size 4\nidx2 three\none \nfive \nthree \nsix \ns1[1] five\none \nFIVE \nthree \nSIX\n\nThis shows that Arrays and Lists coming from\nArrays.asList() are \"joined at the hip\" changes in one affect \nthe other. This is different from a \"Backed Collection\". Because \nBacked Collections dont go both ways and are only backed for a certain range.','Collections',1,NULL),(2856,'public static void main(String[] dicks){\n        String[] sa = {\"one\", \"two\", \"three\", \"four\" };\n        List sList = Arrays.asList(sa);\n\n        System.out.println( \"size \" + sList.size() );\n        System.out.println( \"idx2 \" + sList.get(2) );\n\n        sList.set(3,\"six\" );\n        sa[1] = \"five\";\n\n        for(String s : sa ){\n            System.out.println( s + \" \");\n        }\n        System.out.println(\"s1[1] \" + sList.get(1) );\n        \n        sList.set(1, \"FIVE\");\n        sList.set(3,\"SIX\");\n        sList.add(\"SEVEN\");\n        for(String s : sa)\n            System.out.println(s+\" \");','unsupported operation exception, \n\nList returned by asList is fixed size can only be updated not added to or removed from','Collections',1,NULL),(2857,' public static void main(String[] dicks){\n        List<Integer> iL = new ArrayList<Integer>();\n        for(int x=0; x<3; x++){\n                iL.add(x);\n        }\n        Object[] oa = iL.toArray();\n        Integer[] ia2 = new Integer[3];\n        ia2 = iL.toArray(oa);\n    }','will not compile, toArray( T[] a) will return an array of the type you send\nto it. so here an Object[] cannot be assigned to an Integer[].\n\nto fix:\n	change oa to ia2 which will cause toArray to return an Integer[]','Collections',1,NULL),(2858,'public static void main(String[] dicks){\n        List<Integer> iL = new ArrayList<Integer>();\n        for(int x=0; x<5; x++){\n                iL.add(x);\n        }\n        Object[] oa = iL.toArray();\n        Integer[] ia2 = new Integer[3];\n        ia2 = iL.toArray(ia2);\n        \n        for(Integer i : ia2){\n            System.out.println(i);\n        }     \n    }','0\n1\n2\n3\n4\n','Collections',1,NULL),(2859,'public static void main(String[] dicks){\n        List<Integer> iL = new ArrayList<Integer>();\n        for(int x=0; x<5; x++){\n                iL.add(x);\n        }\n        Object[] oa = iL.toArray();\n        Integer[] ia2 = new Integer[3];\n        ia2 = iL.toArray(ia2);\n        \n        for(Integer i : ia2){\n            System.out.println(i);\n        }\n        \n        iL.add(100);\n        \n        for(Integer i : ia2)\n            System.out.println(i);\n       \n    }','0\n1\n2\n3\n4\n0\n1\n2\n3\n4','Collections',1,NULL),(2860,' public static void main(String[] dicks){\n        List<Integer> iL = new ArrayList<Integer>();\n        for(int x=0; x<5; x++){\n                iL.add(x);\n        }\n        Integer[] oa = iL.toArray();     \n    }','will not compile, \n\n.toArray() returns an Object[]','Collections',1,NULL),(2861,'class HDTV implements Comparable<HDTV> {\n	private int size;\n	private String brand;\n        private int resolution;\n \n	public HDTV(int size, String brand, int res) {\n		this.size = size;\n		this.brand = brand;\n                this.resolution = res;\n	}\n \n	public int getSize() {\n		return size;\n	}\n        \n        public int getRes() {\n            return resolution;\n        }\n \n	public void setSize(int size) {\n		this.size = size;\n	}\n \n	public String getBrand() {\n		return brand;\n	}\n \n	public void setBrand(String brand) {\n		this.brand = brand;\n	}\n \n	@Override\n	public int compareTo(HDTV tv) {\n \n		if (this.getSize() > tv.getSize())\n			return 1;\n		else if (this.getSize() < tv.getSize())\n			return -1;\n		else\n			return 0;\n	}\n        \n        public String toString(){\n            return brand;\n        }\n}\n\npublic class Hello {\n    public static void main(String[] dicks){\n        compareTVs();\n    }\n    \n     \n    public static void compareTVs() {\n		HDTV tv1 = new HDTV(55, \"Samsung\", 6000);\n		HDTV tv2 = new HDTV(60, \"Sony\", 4500);\n                HDTV tv3 = new HDTV(70, \"MEGATV\", 10000);\n                HDTV tv4 = new HDTV(15,\"kitchenette\", 600);\n\n                HDTV[] array = {tv2, tv1, tv3, tv4 };\n                \n                System.out.println(Arrays.binarySearch(array,new HDTV(700,\"Samsung\",400)));\n                \n	}\n\n}','unpredictable result, the array is not sorted before being searched. ','Collections',1,NULL),(2862,'public static void main(String[] dicks){\n        List<HDTV> tvs = new ArrayList<>();\n        HDTV tv1 = new HDTV(55, \"Samsung\", 6000);\n        HDTV tv2 = new HDTV(60, \"Sony\", 4500);\n        HDTV tv3 = new HDTV(70, \"MEGATV\", 10000);\n        HDTV tv4 = new HDTV(15,\"kitchenette\", 600);\n        tvs.addAll(tv1,tv2,tv3,tv4);\n    }','will not compile \n\nArrayList.addAll doesn\'t work like that, it takes another collection\nthen adds all the elements from one to another. ','Collections',1,NULL),(2863,'public static void main(String[] dicks){\n        List<HDTV> tvs = new ArrayList<>();\n        \n        HDTV tv1 = new HDTV(55, \"Samsung\", 6000);\n        HDTV tv2 = new HDTV(60, \"Sony\", 4500);\n        HDTV tv3 = new HDTV(70, \"MEGATV\", 10000);\n        HDTV tv4 = new HDTV(15,\"kitchenette\", 600);\n        \n        tvs.add(tv1);\n        tvs.add(tv2);\n        tvs.add(tv3);\n        tvs.add(tv4);\n        \n        Iterator<HDTV> i3 = tvs.iterator();\n        \n        while(i3.hasNext()){\n            HDTV t3 = i3.next();\n            System.out.println(t3.getBrand());\n        }\n        \n        \n    }','Samsung\nSony\nMEGATV\nkitchenette\n\nthis shows proper use of an iterator','Collections',1,NULL),(2864,'public static void main(String[] dicks){\n        List<HDTV> tvs = new ArrayList<>();\n        \n        HDTV tv1 = new HDTV(55, \"Samsung\", 6000);\n        HDTV tv2 = new HDTV(60, \"Sony\", 4500);\n        HDTV tv3 = new HDTV(70, \"MEGATV\", 10000);\n        HDTV tv4 = new HDTV(15,\"kitchenette\", 600);\n        \n        tvs.add(tv1);\n        tvs.add(tv2);\n        tvs.add(tv3);\n        tvs.add(tv4);\n        \n        Iterator i3 = tvs.iterator();\n        \n        while(i3.hasNext()){\n            HDTV t3 = i3.next();\n            System.out.println(t3.getBrand());\n        }\n        \n        \n    }','If the iterator isn\'t typed then the elements returned by Iterator will be \nObjects so to make this compile, \n\nyou would have to cast\n\n	(HDTV) i3.next();','Collections',1,NULL),(2865,'  public static void main(String[] dicks){\n        List<HDTV> tvs = new ArrayList<>();\n        \n        HDTV tv1 = new HDTV(55, \"Samsung\", 6000);\n        HDTV tv2 = new HDTV(60, \"Sony\", 4500);\n        HDTV tv3 = new HDTV(70, \"MEGATV\", 10000);\n        HDTV tv4 = new HDTV(15,\"kitchenette\", 600);\n        \n        tvs.add(tv1);\n        tvs.add(tv2);\n        tvs.add(tv3);\n        tvs.add(tv4);\n        \n        HDTV[] tv = new HDTV[5];\n        HDTV[] hv = tvs.toArray(tv); //line 1\n        Object[] tvobjs = tvs.toArray(); //line 2\n        \n   \n    }\n\nwhich line would fail if any ?','none fail both of those are fine. ','Collections',1,NULL),(2866,'public static void main(String[] dicks){\n      Set s = new HashSet();\n      \n        System.out.println(s.add(4));\n        System.out.println(s.add(9));\n        System.out.println(s.add(5));\n        System.out.println(s.add(\"7\"));\n        System.out.println(s.add(4));\n        \n        for(Object o : s)\n            System.out.println(o);\n\n    }','true\ntrue\ntrue\ntrue\nfalse\n4\n5\n7\n9\n\nSets dont allow duplicates and the iteration order is not predictable','Collections',1,NULL),(2867,'public static void main(String[] dicks){\n      Set s = new TreeSet();\n      \n        System.out.println(s.add(4));\n        System.out.println(s.add(9));\n        System.out.println(s.add(5));\n        System.out.println(s.add(\"7\"));\n        System.out.println(s.add(4));\n        \n        for(Object o : s)\n            System.out.println(o);\n\n    }','ClassCastException\n \nTreeSets are sorted and all these elements aren\'t mutually comparabble','Collections',1,NULL),(2868,'class Dog {\n    public String name;\n    public Dog(String n) { name = n; }\n    \n    public String toString(){\n        return name;\n    }\n}\n\npublic class Hello {\n\n    public static void main(String[] dicks){\n      Map<Object,Object> map = new HashMap<>();\n      \n      map.put(\"d1\",new Dog(\"Charly\"));\n      map.put(\"d2\", new Dog(\"dumbfuck\"));\n      \n        System.out.println(map.get(\"d1\"));\n    }\n}','Charly,\n\nhere strings are used as keys and they override hashcode() and equals()\nso it can be used ','Collections',1,NULL),(2869,'class Dog {\n    public String name;\n    public Dog(String n) { name = n; }\n    \n    public String toString(){\n        return name;\n    }\n\n    public static void main(String[] dicks){\n      Map<Object,Object> map = new HashMap<>();\n      \n      map.put(new Dog(\"Bell\"),\"Big brown lab\");\n      map.put(new Dog(\"Sable\"), \"small schiperkee\");\n      \n        System.out.println(map.get(new Dog(\"Bell\")));\n    }\n\n}\n\n','null \n\nthe map cannot find the values bcause the keys dont have equals or hashcode methods.','Collections',1,NULL),(2870,'class Dog {\n    enum Pets{DOG, CAT, SNAKE};\n    public String name;\n    public Dog(String n) { name = n; }\n    \n    public String toString(){\n        return name;\n    }\n\npublic static void main(String[] dicks){\n      \n      Map<Object,Object> map = new HashMap<>();\n      \n      map.put(new Dog(\"Bell\"),\"Big brown lab\");\n      map.put(new Dog(\"Sable\"), \"small schiperkee\");\n      map.put(Pets.CAT, new Dog(\"catdog\"));\n      map.put(\"Dog\", Pets.DOG);\n      \n        System.out.println(map.get(new Dog(\"Bell\")));\n        System.out.println(map.get(Pets.CAT));\n        System.out.println(map.get(\"Dog\"));\n    }\n}','null\ncatdog\nDOG','Collections',1,NULL),(2871,'public int hashCode() { return name.length(); }\npublic int hashCode() { return 4; }\n \nwhich will be faster ?\n','both are legal, the first will be slightly better\n\nthe more unique a hashcode the faste retrieval will be. ','Collections',1,NULL),(2872,'TreeSet<Integer> tree = new TreeSet<Integer>();\ntree.add(12);\ntree.add(63);\ntree.add(34);\ntree.add(45);\n \nIterator<Integer> iterator = tree.iterator();\nSystem.out.print(\"Tree set data: \");\nwhile (iterator.hasNext()) {\n    System.out.print(iterator.next() + \" \");\n}','12\n34\n45\n63','Collections',1,NULL),(2873,'public class Hello {\n    \n    \n    public static void main(String[] dicks){\n      \n      List<Double> grades = new ArrayList<>();\n      grades.addAll(Arrays.asList( new Double[]{ 1.8, 4.6, 2.3, 8.9, 2.2 } ));\n      \n      Collections.sort(grades,new CusSort());\n      \n      System.out.println(grades);\n      \n        System.out.println(Collections.binarySearch(grades,4.2,new CusSort()));\n\n    }\n}\n    \n   class CusSort implements Comparator<Double> {\n       public int compare(Double d1, Double d2){\n           return d1.intValue() == d2.intValue() ? d2.compareTo(d1) : d1.compareTo(d2);\n           \n       }\n   }','[1.8, 2.3, 2.2, 4.6, 8.9]\n-5\n\nthis comparator sorts in ascending order uless they have the same integer\nvalue','Collections',1,NULL),(2874,'public class Hello {\n    \n    \n    public static void main(String[] dicks){\n      \n     TreeMap<String, String> map = new TreeMap<>();\n     map.put(\"a\",\"ant\"); map.put(\"b\",\"buffalo\"); map.put(\"h\",\"horse\");\n     \n     SortedMap<String, String> submap;\n     submap = map.subMap(\"b\",\"g\");\n     \n        System.out.println(map+\" \"+submap);\n        \n        map.put(\"b\",\"bat\");\n        \n        submap.put(\"f\",\"fish\");\n        \n        map.put(\"R\", \"raccoon\");\n        // submap.put(\"p\",\"pig\");\n        \n        System.out.println(map+\" \"+submap);\n    }\n}','{a=ant, b=buffalo, h=horse} {b=buffalo}\n{R=raccoon, a=ant, b=bat, f=fish, h=horse} {b=bat, f=fish}','Collections',1,NULL),(2875,'public class Hello {\n    \n    \n    public static void main(String[] dicks){\n      \n     TreeMap<String, String> map = new TreeMap<>();\n     map.put(\"a\",\"ant\"); map.put(\"b\",\"buffalo\"); map.put(\"h\",\"horse\");\n     \n     SortedMap<String, String> submap;\n     submap = map.subMap(\"b\",\"g\");\n     \n        System.out.println(map+\" \"+submap);\n        \n        map.put(\"b\",\"bat\");\n        \n        submap.put(\"f\",\"fish\");\n        \n        map.put(\"R\", \"raccoon\");\n        submap.put(\"p\",\"pig\");\n        \n        System.out.println(map+\" \"+submap);\n    }\n}','IllegalArgumnetException\n\np is out of range of the submap as first established with subMap(b g);\n\n','Collections',1,NULL),(2876,'public class Hello {\n    \n    \n    public static void main(String[] dicks){\n      \n     TreeMap<String, String> map = new TreeMap<>();\n     map.put(\"a\",\"ant\"); map.put(\"b\",\"buffalo\"); map.put(\"h\",\"horse\"); map.put(\"j\",\"jackle\");\n     \n     TreeMap<String, String> submap;\n     submap = map.subMap(\"b\",\"g\");\n     \n     System.out.println(map+\" \"+submap);\n\n    }\n}','will not compile, submap returns a SortedMap.','Collections',1,NULL),(2877,'class TreeMap<k,v> extends  _____________\n implements  ____________','AbstractMap<k,V>\nNavigableMap<K,V>','Collections',1,NULL),(2878,'public class Hello {\n    \n    \n    public static void main(String[] dicks){\n      \n     TreeMap<Animal, Integer> map = new TreeMap<>();\n     \n     map.put(new Animal(5,\"Ant\"), 6); map.put(new Animal(3,\"Beee\"),9); map.put(new Animal(25,\"Dog\"),7); map.put(new Animal(20,\"muskrat\"),20);\n     \n     System.out.println(map);\n     \n \n\n    }\n}\n\nclass sortAnimalsAlphabetically implements Comparator<Animal> {\n\n    @Override\n    public int compare(Animal o1, Animal o2) {\n        return o1.getName().compareTo(o2.getName());\n    }\n    \n}\n\nclass Animal implements Comparable<Animal> {\n    private Integer size;\n    private String name;\n    \n    public Animal(int x, String y){\n        size = x;\n        name = y;\n    }\n\n    public int getSize() {\n        return size;\n    }\n\n    public String getName() {\n        return name;\n    }\n    public int compareTo(Animal o){\n        return size.compareTo(o.getSize());\n        \n    }\n    \n    public String toString(){\n        return name;\n    }\n}','{Beee=9, Ant=6, muskrat=20, Dog=7}\n\nwithout a provided comparator TreeMap sorts using Animals comparable\n\nwhich is to rank by size','Collections',1,NULL),(2879,'public class Hello {\n    \n    \n    public static void main(String[] dicks){\n      \n     TreeMap<Animal, Integer> map = new TreeMap<>(new sortAnimalsAlphabetically());\n     \n     map.put(new Animal(5,\"Ant\"), 6); map.put(new Animal(3,\"Beee\"),9); map.put(new Animal(25,\"Dog\"),7); map.put(new Animal(20,\"muskrat\"),20);\n     \n     System.out.println(map);\n     \n \n\n    }\n}\n\nclass sortAnimalsAlphabetically implements Comparator<Animal> {\n\n    @Override\n    public int compare(Animal o1, Animal o2) {\n        return o1.getName().compareTo(o2.getName());\n    }\n    \n}\n\nclass Animal implements Comparable<Animal> {\n    private Integer size;\n    private String name;\n    \n    public Animal(int x, String y){\n        size = x;\n        name = y;\n    }\n\n    public int getSize() {\n        return size;\n    }\n\n    public String getName() {\n        return name;\n    }\n    public int compareTo(Animal o){\n        return size.compareTo(o.getSize());\n        \n    }\n    \n    public String toString(){\n        return name;\n    }\n}','{Ant=6, Beee=9, Dog=7, muskrat=20}\n\nsort using comparator','Collections',1,NULL),(2880,'public class Hello {\n    \n    \n    public static void main(String[] dicks){\n      \n     TreeMap<Animal, Integer> map = new TreeMap<>();\n     \n     map.put(new Animal(2,\"Ant\"), 6); map.put(new Animal(3,\"Beee\"),9); map.put(new Animal(15,\"Dog\"),7); map.put(new Animal(12,\"muskrat\"),20);\n     \n     SortedMap<Animal,Integer> copymap = map.subMap(map.firstKey(), map.lastKey());\n     \n     copymap.put(new Animal(50,\"Rhino\"), 1);\n     map.put(new Animal(30,\"Wolf\"), 4);\n     System.out.println(map);\n     \n     SortedMap<Animal,Integer> copy1map = copymap.subMap(new Animal(4,\"Worm\"), new Animal(25,\"Dolphin\"));\n     \n     System.out.println(copy1map);\n\n    }\n}\n\nclass sortAnimalsAlphabetically implements Comparator<Animal> {\n\n    @Override\n    public int compare(Animal o1, Animal o2) {\n        return o1.getName().compareTo(o2.getName());\n    }\n    \n}\n\nclass Animal implements Comparable<Animal> {\n    private Integer size;\n    private String name;\n    \n    public Animal(int x, String y){\n        size = x;\n        name = y;\n    }\n\n    public int getSize() {\n        return size;\n    }\n\n    public String getName() {\n        return name;\n    }\n    public int compareTo(Animal o){\n        return size.compareTo(o.getSize());\n        \n    }\n    \n    public String toString(){\n        return name;\n    }\n}','IllegalArgumentException key out of range\n\nyour trying to add a rhino - 50 - to the copied map when the biggest element\nin the orgiinal was a Dog at 15 !','Collections',1,NULL),(2881,'public class Hello {\n    \n    \n    public static void main(String[] dicks){\n      \n     TreeMap<Animal, Integer> map = new TreeMap<>();\n     \n     map.put(new Animal(2,\"Ant\"), 6); map.put(new Animal(3,\"Beee\"),9); map.put(new Animal(15,\"Dog\"),7); map.put(new Animal(12,\"muskrat\"),20);\n     \n     SortedMap<Animal,Integer> copymap = map.subMap(map.firstKey(), map.lastKey());\n     \n     map.put(new Animal(50,\"Rhino\"), 1);\n     map.put(new Animal(30,\"Wolf\"), 4);\n     System.out.println(map);\n     \n     SortedMap<Animal,Integer> copy1map = copymap.subMap(new Animal(1,\"Tic\"), new Animal(25,\"Dolphin\"));\n     \n     //System.out.println(copy1map);\n\n    }\n}\n\nclass sortAnimalsAlphabetically implements Comparator<Animal> {\n\n    @Override\n    public int compare(Animal o1, Animal o2) {\n        return o1.getName().compareTo(o2.getName());\n    }\n    \n}\n\nclass Animal implements Comparable<Animal> {\n    private Integer size;\n    private String name;\n    \n    public Animal(int x, String y){\n        size = x;\n        name = y;\n    }\n\n    public int getSize() {\n        return size;\n    }\n\n    public String getName() {\n        return name;\n    }\n    public int compareTo(Animal o){\n        return size.compareTo(o.getSize());\n        \n    }\n    \n    public String toString(){\n        return name;\n    }\n}\n','IllegalArgumentException, fromKey out of range\n\nthe tic your trying to add is too small previously the smallest elemtn was\nan Ant at 2','Collections',1,NULL),(2882,'public class Hello {\n    \n    \n    public static void main(String[] dicks){\n      \n     TreeMap<Animal, Integer> map = new TreeMap<>();\n     \n     map.put(new Animal(2,\"Ant\"), 6); map.put(new Animal(3,\"Beee\"),9); map.put(new Animal(15,\"Dog\"),7); map.put(new Animal(12,\"muskrat\"),20);\n     \n     SortedMap<Animal,Integer> copymap = map.subMap(map.firstKey(), map.lastKey());\n        System.out.println(map);\n        System.out.println(copymap);\n     \n     map.put(new Animal(50,\"Rhino\"), 1);\n     map.put(new Animal(30,\"Wolf\"), 4);\n     System.out.println(map);\n     \n     copymap = map.subMap(map.firstKey(), map.lastKey());\n     \n        System.out.println(copymap);\n     \n     //SortedMap<Animal,Integer> copy1map = copymap.subMap(new Animal(7,\"Snake\"), new Animal(40,\"Bear\"));\n     //System.out.println(copy1map);\n\n    }\n}','{Ant=6, Beee=9, muskrat=20, Dog=7}\n{Ant=6, Beee=9, muskrat=20}\n{Ant=6, Beee=9, muskrat=20, Dog=7, Wolf=4, Rhino=1}\n{Ant=6, Beee=9, muskrat=20, Dog=7, Wolf=4}\n\npublic SortedMap<K,V> subMap(K fromKey,\n                    K toKey)\n\nkeys range from fromKey, inclusive, to toKey, exclusive. (If fromKey and toKey are equal, the returned map is empty.)\n The returned map is backed by this map, so changes \nin the returned map are reflected in this map, and vice-versa.\n\nTHE TO KEY IS EXCLUSIVE ','Collections',1,NULL),(2883,'public class Hello {\n  public static void main(String[] dicks){\n      \n     TreeMap<Animal, Integer> map = new TreeMap<>();\n     \n     map.put(new Animal(2,\"Ant\"), 6); map.put(new Animal(3,\"Beee\"),9); map.put(new Animal(15,\"Dog\"),7); map.put(new Animal(12,\"muskrat\"),20);\n     \n     SortedMap<Animal,Integer> copymap = map.subMap(map.firstKey(),true, map.lastKey(),true);\n        System.out.println(map);\n        System.out.println(copymap);\n    }\n}\n\nclass Animal implements Comparable<Animal>{\n    private int size;\n    private String name;\n    public Animal(int s, String n){\n        size = s;\n        name = n;\n        \n    }\n    public int getSize(){\n        return size;\n    }\n    public int compareTo(Animal a){\n        int asize = a.getSize();\n        int bsize = this.size;\n        \n        if(asize < bsize)\n            return 1;\n        else if(asize == bsize)\n            return 0;\n        else\n            return -1;\n  \n    }\n    \n    public String toString(){\n        return name;\n    }\n}','{Ant=6, Beee=9, muskrat=20, Dog=7}\n{Ant=6, Beee=9, muskrat=20, Dog=7}\n\noverloaded version of submap indicates if that arg is inclusive \n\nThe map is sorted according to the natural ordering of its keys, or by a Comparator provided at map creation time\nNote that the ordering maintained by a tree map, like any sorted map, and whether or not an explicit comparator is provided, \nmust be consistent with equals if this sorted map is to correctly implement the Map interface. (See Comparable or Comparator for a precise definition of consistent with equals.) \nThis is so because the Map interface is defined in terms of the equals operation, but a sorted map performs all key comparisons using its compareTo (or compare) method, so two keys that are deemed equal by this method are, \nfrom the standpoint of the sorted map, equal.  ','Collections',1,NULL),(2884,'public class Hello {\n    \n    \n    public static void main(String[] dicks){\n      \n     TreeMap<Animal, Integer> map = new TreeMap<>();\n     \n     map.put(new Animal(2,\"Ant\"), 6); map.put(new Animal(3,\"Beee\"),9); map.put(new Animal(15,\"Dog\"),7); map.put(new Animal(12,\"muskrat\"),20);\n     \n     SortedMap<Animal,Integer> copymap = map.subMap(map.firstKey(),false, map.lastKey(),true);\n        System.out.println(map);\n        System.out.println(copymap);\n    }\n}','{Ant=6, Beee=9, muskrat=20, Dog=7}\n{Beee=9, muskrat=20, Dog=7}','Collections',1,NULL),(2885,'public class Hello {\n    \n    \n    public static void main(String[] dicks){\n      \n     TreeMap<Animal, Integer> map = new TreeMap<>();\n     \n     map.put(new Animal(2,\"Ant\"), 6); map.put(new Animal(3,\"Beee\"),9); map.put(new Animal(15,\"Dog\"),7); map.put(new Animal(12,\"muskrat\"),20);\n     \n     SortedMap<Animal,Integer> copymap = map.subMap(map.firstKey(),false, map.lastKey(),false);\n        System.out.println(map);\n        System.out.println(copymap);\n    }\n}','{Ant=6, Beee=9, muskrat=20, Dog=7}\n{Beee=9, muskrat=20}','Collections',1,NULL),(2886,'public class Hello {\n    \n    \n    public static void main(String[] dicks){\n      \n     TreeMap<Animal, Integer> map = new TreeMap<>();\n     \n     map.put(new Animal(2,\"Ant\"), 6); map.put(new Animal(3,\"Beee\"),9); map.put(new Animal(15,\"Dog\"),7); map.put(new Animal(12,\"muskrat\"),20);\n     \n     SortedMap<Animal,Integer> copymap = map.subMap(map.firstKey(),true, map.lastKey(),true);\n     \n        System.out.println(map);\n        System.out.println(copymap);\n     map.put(new Animal(25,\"Wolf\"), 1);\n     //copymap.put(new Animal(22,\"Lynx\"), 0);\n     map.put(new Animal(33,\"Giant sloth\"), 6);\n     //copymap.put(new Animal(30,\"Comodo\"),5);\n     \n        System.out.println(map);\n        System.out.println(copymap);        \n    }\n}','{Ant=6, Beee=9, muskrat=20, Dog=7}\n{Ant=6, Beee=9, muskrat=20, Dog=7}\n{Ant=6, Beee=9, muskrat=20, Dog=7, Wolf=1, Giant sloth=6}\n{Ant=6, Beee=9, muskrat=20, Dog=7}\n\nIf new elements are added to the orginal map that are out of the range\nof the submap then they are not copied over to the sub.\n\nThat submap only exist within the range it was defined. ','Collections',1,NULL),(2887,'public class Hello {\n    \n    \n    public static void main(String[] dicks){\n      \n     TreeMap<Animal, Integer> map = new TreeMap<>();\n     \n     map.put(new Animal(2,\"Ant\"), 6); map.put(new Animal(3,\"Beee\"),9); map.put(new Animal(15,\"Dog\"),7); map.put(new Animal(12,\"muskrat\"),20);\n     \n     SortedMap<Animal,Integer> copymap = map.subMap(map.firstKey(),true, map.lastKey(),true);\n     \n        System.out.println(map);\n        System.out.println(copymap);\n     map.put(new Animal(25,\"Wolf\"), 1);\n     copymap.put(new Animal(10,\"Fat Cat\"), 0);\n     map.put(new Animal(33,\"Giant sloth\"), 6);\n     \n        System.out.println(map);\n        System.out.println(copymap);\n    }\n}','{Ant=6, Beee=9, muskrat=20, Dog=7}\n{Ant=6, Beee=9, muskrat=20, Dog=7}\n{Ant=6, Beee=9, Fat Cat=0, muskrat=20, Dog=7, Wolf=1, Giant sloth=6}\n{Ant=6, Beee=9, Fat Cat=0, muskrat=20, Dog=7}','Collections',1,NULL),(2888,'public class Hello {\n    \n    \n    public static void main(String[] dicks){\n      \n     TreeMap<Animal, Integer> map = new TreeMap<>();\n     \n     map.put(new Animal(2,\"Ant\"), 6); map.put(new Animal(3,\"Beee\"),9); map.put(new Animal(15,\"Dog\"),7); map.put(new Animal(12,\"muskrat\"),20);\n     map.put(new Animal(25,\"Wolf\"), 1); map.put(new Animal(33,\"Giant sloth\"), 6);\n     map.put(new Animal(35,\"Leapord\"),2); map.put(new Animal(9,\"chipmunk\"),4); map.put(new Animal(46,\"Cave Dweller\"),1);\n     \n        System.out.println(map);\n        \n     SortedMap<Animal,Integer> headmap = map.headMap(new Animal(35,\"Leapord\"));\n     \n        System.out.println(headmap);\n   \n    }\n}','{Ant=6, Beee=9, chipmunk=4, muskrat=20, Dog=7, Wolf=1, Giant sloth=6, Leapord=2, Cave Dweller=1}\n{Ant=6, Beee=9, chipmunk=4, muskrat=20, Dog=7, Wolf=1, Giant sloth=6}','Collections',1,NULL),(2889,'public class Hello {\n    \n    \n    public static void main(String[] dicks){\n      \n     TreeMap<Animal, Integer> map = new TreeMap<>();\n     \n     map.put(new Animal(2,\"Ant\"), 6); map.put(new Animal(3,\"Beee\"),9); map.put(new Animal(15,\"Dog\"),7); map.put(new Animal(12,\"muskrat\"),20);\n     map.put(new Animal(25,\"Wolf\"), 1); map.put(new Animal(33,\"Giant sloth\"), 6);\n     map.put(new Animal(35,\"Leapord\"),2); map.put(new Animal(9,\"chipmunk\"),4); map.put(new Animal(46,\"Cave Dweller\"),1);\n     \n        System.out.println(map);\n        \n     SortedMap<Animal,Integer> headmap = map.headMap(new Animal(35,\"Leapord\"),true);\n     \n        System.out.println(headmap);\n   \n    }\n}','{Ant=6, Beee=9, chipmunk=4, muskrat=20, Dog=7, Wolf=1, Giant sloth=6, Leapord=2, Cave Dweller=1}\n{Ant=6, Beee=9, chipmunk=4, muskrat=20, Dog=7, Wolf=1, Giant sloth=6, Leapord=2}','Collections',1,NULL),(2890,'public class Hello {\n    \n    \n    public static void main(String[] dicks){\n      \n     TreeMap<Animal, Integer> map = new TreeMap<>();\n     \n     map.put(new Animal(2,\"Ant\"), 6); map.put(new Animal(3,\"Beee\"),9); map.put(new Animal(15,\"Dog\"),7); map.put(new Animal(12,\"muskrat\"),20);\n     map.put(new Animal(25,\"Wolf\"), 1); map.put(new Animal(33,\"Giant sloth\"), 6);\n     map.put(new Animal(35,\"Leapord\"),2); map.put(new Animal(9,\"chipmunk\"),4); map.put(new Animal(46,\"Cave Dweller\"),1);\n     \n        System.out.println(map);\n        \n     SortedMap<Animal,Integer> headmap = map.headMap(new Animal(40,\"Python\"),true);\n     \n        System.out.println(headmap);\n   \n    }\n}','{Ant=6, Beee=9, chipmunk=4, muskrat=20, Dog=7, Wolf=1, Giant sloth=6, Leapord=2, Cave Dweller=1}\n{Ant=6, Beee=9, chipmunk=4, muskrat=20, Dog=7, Wolf=1, Giant sloth=6, Leapord=2}','Collections',1,NULL),(2891,'public class Hello {\n    \n    \n    public static void main(String[] dicks){\n      \n     TreeMap<Animal, Integer> map = new TreeMap<>();\n     \n     map.put(new Animal(2,\"Ant\"), 6); map.put(new Animal(3,\"Beee\"),9); map.put(new Animal(15,\"Dog\"),7); map.put(new Animal(12,\"muskrat\"),20);\n     map.put(new Animal(25,\"Wolf\"), 1); map.put(new Animal(33,\"Giant sloth\"), 6);\n     map.put(new Animal(35,\"Leapord\"),2); map.put(new Animal(9,\"chipmunk\"),4); map.put(new Animal(46,\"Cave Dweller\"),1);\n     \n        System.out.println(map);\n        \n     SortedMap<Animal,Integer> headmap = map.headMap(new Animal(40,\"Python\"));\n     \n        System.out.println(headmap);\n   \n    }\n}','{Ant=6, Beee=9, chipmunk=4, muskrat=20, Dog=7, Wolf=1, Giant sloth=6, Leapord=2, Cave Dweller=1}\n{Ant=6, Beee=9, chipmunk=4, muskrat=20, Dog=7, Wolf=1, Giant sloth=6, Leapord=2}','Collections',1,NULL),(2892,'try{\n            bw.write(df.format(today));\n            bw.newLine();\n            bw.write(\"Flash Cards \\n\");\n            bw.newLine();\n            \n            for(Card c : cards){\n                bw.write(\"================================================\\n\");\n                bw.write(\"-\"+counter+\"-\\n\");\n                bw.write(\"================================================\\n\");\n                bw.write(c.getCard());\n                bw.newLine();\n                bw.write(\"================================================\\n\");\n                bw.write(c.getAnswer());\n                bw.newLine();\n                bw.write(\"================================================\\n\");\n                counter++;\n            }\n            \n            bw.close();\n	    bw.flush();\n            \n        } catch(IOException e){\n            System.out.println(\"Problem saving cards\");\n            e.printStackTrace(); \n        } ','IOException caused by flushing a closed Bufferedwriter','Collections',1,NULL),(2893,'public class Hello {\n    \n    \n    public static void main(String[] dicks){\n      \n     TreeMap<Animal, Integer> map = new TreeMap<>();\n     \n     map.put(new Animal(2,\"Ant\"), 6); map.put(new Animal(3,\"Beee\"),9); map.put(new Animal(15,\"Dog\"),7); map.put(new Animal(12,\"muskrat\"),20);\n     map.put(new Animal(25,\"Wolf\"), 1); map.put(new Animal(33,\"Giant sloth\"), 6);\n     map.put(new Animal(35,\"Leapord\"),2); map.put(new Animal(9,\"chipmunk\"),4); map.put(new Animal(46,\"Cave Dweller\"),1);\n     \n        System.out.println(map);\n        \n     SortedMap<Animal,Integer> headmap = map.headMap(new Animal(40,\"Python\"));\n     \n     System.out.println(headmap);\n        \n     NavigableMap<Animal,Integer> headmapincl = map.headMap(new Animal(34,\"Lynx\"), true);\n     SortedMap<Animal,Integer> headmap_2 = map.headMap(new Animal(30,\"Fox\"), true);\n     \n        System.out.println(headmapincl);\n        \n   \n    }\n}','{Ant=6, Beee=9, chipmunk=4, muskrat=20, Dog=7, Wolf=1, Giant sloth=6, Leapord=2, Cave Dweller=1}\n{Ant=6, Beee=9, chipmunk=4, muskrat=20, Dog=7, Wolf=1, Giant sloth=6, Leapord=2}\n{Ant=6, Beee=9, chipmunk=4, muskrat=20, Dog=7, Wolf=1, Giant sloth=6}','Collections',1,NULL),(2894,'public class Hello {\n    \n    \n    public static void main(String[] dicks){\n      \n     TreeMap<Animal, Integer> map = new TreeMap<>();\n     \n     map.put(new Animal(2,\"Ant\"), 6); map.put(new Animal(3,\"Beee\"),9); map.put(new Animal(15,\"Dog\"),7); map.put(new Animal(12,\"muskrat\"),20);\n     map.put(new Animal(25,\"Wolf\"), 1); map.put(new Animal(33,\"Giant sloth\"), 6);\n     map.put(new Animal(35,\"Leapord\"),2); map.put(new Animal(9,\"chipmunk\"),4); map.put(new Animal(46,\"Cave Dweller\"),1);\n     \n        System.out.println(map);\n        \n    SortedMap<Animal,Integer> tailmap = map.tailMap(new Animal(33,\"Giant Sloth\"));\n    \n        System.out.println(tailmap);\n        \n   \n    }\n}','{Ant=6, Beee=9, chipmunk=4, muskrat=20, Dog=7, Wolf=1, Giant sloth=6, Leapord=2, Cave Dweller=1}\n{Giant sloth=6, Leapord=2, Cave Dweller=1}','Collections',1,NULL),(2895,'public class Hello {\n    \n    \n    public static void main(String[] dicks){\n      \n     TreeMap<Animal, Integer> map = new TreeMap<>();\n     \n     map.put(new Animal(2,\"Ant\"), 6); map.put(new Animal(3,\"Beee\"),9); map.put(new Animal(15,\"Dog\"),7); map.put(new Animal(12,\"muskrat\"),20);\n     map.put(new Animal(25,\"Wolf\"), 1); map.put(new Animal(33,\"Giant sloth\"), 6);\n     map.put(new Animal(35,\"Leapord\"),2); map.put(new Animal(9,\"chipmunk\"),4); map.put(new Animal(46,\"Cave Dweller\"),1);\n     \n        System.out.println(map);\n        \n    SortedMap<Animal,Integer> tailmap = map.tailMap(new Animal(33,\"Giant Sloth\"),false);\n    \n        System.out.println(tailmap);\n        \n   \n    }\n}','{Ant=6, Beee=9, chipmunk=4, muskrat=20, Dog=7, Wolf=1, Giant sloth=6, Leapord=2, Cave Dweller=1}\n{Leapord=2, Cave Dweller=1}','Collections',1,NULL),(2896,' public static void main(String[] dicks){\n      \n     TreeMap<Animal, Integer> map = new TreeMap<>();\n     \n     map.put(new Animal(2,\"Ant\"), 6); map.put(new Animal(3,\"Beee\"),9); map.put(new Animal(15,\"Dog\"),7); map.put(new Animal(12,\"muskrat\"),20);\n     map.put(new Animal(25,\"Wolf\"), 1); map.put(new Animal(33,\"Giant sloth\"), 6);\n     map.put(new Animal(35,\"Leapord\"),2); map.put(new Animal(9,\"chipmunk\"),4); map.put(new Animal(46,\"Cave Dweller\"),1);\n     \n        System.out.println(map);\n        \n     SortedMap<Animal,Integer> tailmap = map.tailMap(new Animal(33,\"Giant Sloth\"),false);\n     \n        System.out.println(tailmap.pollFirtEntry());\n    \n    }\n}','will not compile,\n\npollFirstEntry(),cielingKey,higherKey(), floorKey(), pollLastEntry(),\ndescendingMap()\n\n	are all in TreeMap not interface SortedMap.','Collections',1,NULL),(2897,'public class Hello {\n    \n    \n    public static void main(String[] dicks){\n      \n     TreeMap<Animal, Integer> map = new TreeMap<>();\n     \n     map.put(new Animal(2,\"Ant\"), 6); map.put(new Animal(3,\"Beee\"),9); map.put(new Animal(15,\"Dog\"),7); map.put(new Animal(12,\"muskrat\"),20);\n     map.put(new Animal(25,\"Wolf\"), 1); map.put(new Animal(33,\"Giant sloth\"), 6);\n     map.put(new Animal(35,\"Leapord\"),2); map.put(new Animal(9,\"chipmunk\"),4); map.put(new Animal(46,\"Cave Dweller\"),1);\n     \n        System.out.println(map);\n        \n     \n        System.out.println(map.pollFirstEntry());\n        System.out.println(map.pollLastEntry());\n        System.out.println(map.ceilingKey(new Animal(2,\"Ant\")));\n        System.out.println(map.higherKey(new Animal(3,\"Beee\")));\n        System.out.println(map.floorKey(new Animal(46,\"Cave Dweller\")));\n        System.out.println(map.lowerKey(new Animal(35,\"Leapord\")));\n        \n    \n    }\n}','{Ant=6, Beee=9, chipmunk=4, muskrat=20, Dog=7, Wolf=1, Giant sloth=6, Leapord=2, Cave Dweller=1}\nAnt=6\nCave Dweller=1\nBeee\nchipmunk\nLeapord\nGiant sloth','Collections',1,NULL),(2898,'\npublic class Hello {\n    public static void main(String[] dicks){\n      \n        PriorityQueue<Animal> q = new PriorityQueue<>();\n        \n        q.add(new Animal(5,\"Sheep\"));\n        q.offer(new Animal(6,\"Goat\"));\n        q.offer(new Animal(10,\"Cow\"));\n        q.offer(new Animal(12,\"Bull\"));\n        q.offer(null);\n        \n        System.out.println(q);\n        \n    \n    }\n}','nullpointerexception, PQ does not allow null elements','Collections',1,NULL),(2899,'public class Hello {\n    public static void main(String[] dicks){\n        \n        PriorityQueue<Animal> q = new PriorityQueue<>(5);\n        \n        q.add(new Animal(5,\"Sheep\"));\n        q.offer(new Animal(6,\"Goat\"));\n        q.offer(new Animal(10,\"Cow\"));\n        q.offer(new Animal(12,\"Bull\"));\n        q.offer(new Animal(3,\"Cat\"));\n        q.offer(new Animal(7,\"Sloth\"));\n        \n        for(Animal x : q)\n            System.out.println(x);\n        \n        System.out.println(\"__________________\");\n        \n        for(Animal x : q)\n            System.out.println(q.poll());\n        \n    \n    }\n}','ConcurrentModificationExcpeiton for removing elements from the pq\nwhile iterating over it. ','Collections',1,NULL),(2900,'public class Hello {\n    public static void main(String[] dicks){\n        \n        PriorityQueue<Animal> q = new PriorityQueue<>(5);\n        \n        q.add(new Animal(5,\"Sheep\"));\n        q.offer(new Animal(6,\"Goat\"));\n        q.offer(new Animal(10,\"Cow\"));\n        q.offer(new Animal(12,\"Bull\"));\n        q.offer(new Animal(3,\"Cat\"));\n        q.offer(new Animal(7,\"Sloth\"));\n        \n        for(Animal x : q)\n            System.out.println(x);\n        \n        System.out.println(\"__________________\");\n        \n        while(!q.isEmpty())\n            System.out.println(q.poll());\n        \n    \n    }\n}','Cat\nSheep\nSloth\nBull\nGoat\nCow\n__________________\nCat\nSheep\nGoat\nSloth\nCow\nBull\n\nYou need to poll the items from the PriorityQueue one by one. toString doesn\'t do that.\n\nSo instead of your System.out.println(queue); do this:\n\nwhile(!queue.isEmpty()) {\n   System.out.println(queue.poll());\n}\n\nThe reason is that the PriorityQueue is never completely sorted internally, lookup how a heap works for more detail. Polling items from it fixes the heap during the calls, thus it should output the elements in sorted order.','Collections',1,NULL),(2901,'public class Hello {\n    public static void main(String[] dicks){\n        \n        PriorityQueue<Animal> q = new PriorityQueue<>(5);\n        \n        q.add(new Animal(5,\"Sheep\"));\n        q.offer(new Animal(6,\"Goat\"));\n        q.offer(new Animal(10,\"Cow\"));\n        q.offer(new Animal(12,\"Bull\"));\n        q.offer(new Animal(3,\"Cat\"));\n        q.offer(new Animal(7,\"Sloth\"));\n        \n        q.offer(\"Sloths\");\n        q.add(\"fake bull\");\n        \n        while(!q.isEmpty())\n            System.out.println(q.poll());\n        \n\n        \n    \n    }\n}','will not compile string cannot be converted to Animal','Collections',1,NULL),(2902,'public class Hello {\n    public static void main(String[] dicks){\n        Comparator revSort = Collections.reverseOrder();\n        PriorityQueue<Animal> q = new PriorityQueue<>();\n        \n        q.add(new Animal(5,\"Sheep\"));\n        q.offer(new Animal(6,\"Goat\"));\n        q.offer(new Animal(10,\"Cow\"));\n        q.offer(new Animal(12,\"Bull\"));\n        q.offer(new Animal(3,\"Cat\"));\n        q.offer(new Animal(7,\"Sloth\"));\n        \n        PriorityQueue<Animal> q2 = new PriorityQueue<>(q);\n        \n        Collections.sort(q2,revSort);\n        \n        while(!q.isEmpty())\n            System.out.println(q.poll());\n        \n        while(!q2.isEmpty())\n            System.out.println(q2.poll());\n\n    }\n}','will not compile, Collections.sort will only sort Lists','Collections',1,NULL),(2903,'public class Hello {\n    public static void main(String[] dicks){\n        Comparator revSort = Collections.reverseOrder();\n        PriorityQueue<Animal> q = new PriorityQueue<>(revSort);\n        \n        q.add(new Animal(5,\"Sheep\"));\n        q.offer(new Animal(6,\"Goat\"));\n        q.offer(new Animal(10,\"Cow\"));\n        q.offer(new Animal(12,\"Bull\"));\n        q.offer(new Animal(3,\"Cat\"));\n        q.offer(new Animal(7,\"Sloth\"));\n        \n        while(!q.isEmpty()){\n            System.out.println(q.poll());\n        }\n        \n        \n\n    }\n}','Bull\nCow\nSloth\nGoat\nSheep\nCat','Collections',1,NULL),(2904,'public class Hello {\n    public static void main(String[] dicks){\n        Comparator revSort = Collections.reverseOrder();\n        PriorityQueue<Animal> q = new PriorityQueue<>(revSort);\n        \n        q.add(new Animal(5,\"Sheep\"));\n        q.offer(new Animal(6,\"Goat\"));\n        q.offer(new Animal(10,\"Cow\"));\n        q.offer(new Animal(12,\"Bull\"));\n        q.offer(new Animal(3,\"Cat\"));\n        q.offer(new Animal(7,\"Sloth\"));\n        \n        System.out.println(q.remove());\n        System.out.println(q.remove(new Animal(7,\"Sloth\")));\n        \n        while(!q.isEmpty()){\n            System.out.println(q.poll());\n        }\n\n    }\n}\n\nclass Animal implements Comparable<Animal> {\n    private Integer size;\n    private String name;\n    \n    public Animal(int x, String y){\n        size = x;\n        name = y;\n    }\n\n    public int getSize() {\n        return size;\n    }\n\n    public String getName() {\n        return name;\n    }\n    public int compareTo(Animal o){\n        return size.compareTo(o.getSize());\n        \n    }\n    \n    public String toString(){\n        return name;\n    }\n}\n','Here animal doesn\'t impleemnt equals and remove uses equals to determine the \nelement to remove','Collections',1,NULL),(2905,'public class Hello {\n    public static void main(String[] dicks){\n        Comparator revSort = Collections.reverseOrder();\n        PriorityQueue<Animal> q = new PriorityQueue<>(revSort);\n        \n        q.add(new Animal(5,\"Sheep\"));\n        q.offer(new Animal(6,\"Goat\"));\n        q.offer(new Animal(10,\"Cow\"));\n        q.offer(new Animal(12,\"Bull\"));\n        q.offer(new Animal(3,\"Cat\"));\n        q.offer(new Animal(7,\"Sloth\"));\n        \n        System.out.println(q.remove());\n        System.out.println(q.remove(new Animal(7,\"Sloth\")));\n        System.out.println(\"\");\n        \n        while(!q.isEmpty()){\n            System.out.println(q.poll());\n        }\n    }\n}\n\nclass Animal implements Comparable<Animal> {\n    private Integer size;\n    private String name;\n    \n    public Animal(int x, String y){\n        size = x;\n        name = y;\n    }\n\n    public int getSize() {\n        return size;\n    }\n\n    public String getName() {\n        return name;\n    }\n    public int compareTo(Animal o){\n        return size.compareTo(o.getSize());\n        \n    }\n    \n    public String toString(){\n        return name;\n    }\n    \n    public boolean equals(Object o){\n        if((o instanceof Animal)){\n            if((((Animal)o).getSize() == this.size) && (((Animal)o).getName().equals(name) ))\n                return true;\n            return false;           \n        } \n        return false;\n    }\n}','now with equals remove() works just fine. \n\nBull\ntrue\n\nCow\nGoat\nSheep\nCat\n\nnotice the pq is sorted with a Reverse sort comparator, so the animal class\nimplements Comparable. If it didn\'t implement Comparable it could not be used \nin the PriorityQueue. If it wasn\'t for the equals method the remove(sloth)\ncall would return false and sloth would not be removed. Thus making the \noutput:\n\n	Bull\n	false\n\n	Cow\n	Sloth\n	Goat\n	Sheep\n	Cat\n\nalso notice that it is a queue and therefore removes from the head','Collections',1,NULL),(2906,'public class Hello {\n    public static void main(String[] dicks){\n        Map<Integer,String> map = new HashMap<>();\n        \n        map.put(7,\"Biffy\");\n        map.put(5,\"two tone\");\n        map.put(9,\"big slick\");\n        map.put(1,\"funny farm\");\n        map.put(10, \"twice tickled\");\n        \n        List<Integer> list = new ArrayList<>();\n        \n        list.add(7);\n        list.add(5);\n        list.add(9);\n        list.add(1);\n        list.add(10);\n        list.add(16);\n        list.add(14);\n        \n        for(int x : list){\n            System.out.println(map.remove(x));\n        }    \n\n    }\n}','Biffy\ntwo tone\nbig slick\nfunny farm\ntwice tickled\nnull\nnull','Collections',1,NULL),(2907,'public class Hello {\n    public static void main(String[] dicks){\n        Map<Integer,String> map = new HashMap<>();\n        \n        map.put(7,\"Biffy\");\n        map.put(5,\"two tone\");\n        map.put(9,\"big slick\");\n        map.put(1,\"funny farm\");\n        map.put(10, \"twice tickled\");\n        \n        List<Integer> list = new ArrayList<>();\n        \n        list.add(7);\n        list.add(5);\n        list.add(9);\n        list.add(1);\n        list.add(10);\n        list.add(16);\n        list.add(14);\n        \n        Set<Integer> set = new HashSet<>();\n        \n        set.add(7);\n        set.add(5);\n        set.add(9);\n        set.add(1);\n        set.add(10);\n        \n        for(int x : list){\n            System.out.println(\"sizes: \"+map.size() +\", \"+ list.size()+\", \"+set.size());\n            System.out.println(map.remove(x));\n            System.out.println(\"set contains?: \"+set.contains(x));\n        }    \n\n    }\n}','sizes: 5, 7, 5\nBiffy\nset contains?: true\nsizes: 4, 7, 5\ntwo tone\nset contains?: true\nsizes: 3, 7, 5\nbig slick\nset contains?: true\nsizes: 2, 7, 5\nfunny farm\nset contains?: true\nsizes: 1, 7, 5\ntwice tickled\nset contains?: true\nsizes: 0, 7, 5\nnull\nset contains?: false\nsizes: 0, 7, 5\nnull\nset contains?: false','Collections',1,NULL),(2908,'Spaces sort before characters,\nuppercases sort before the lower,\nyour good to go','','Collections',1,NULL),(2909,'public class Hello {\n    public static void main(String[] dicks){\n       HashSet<Animal> set = new HashSet<>();\n       \n       Animal cat = new Animal(3,\"Cat\");\n       Animal dog = new Animal(4,\"Dog\");\n       Animal wolf = new Animal(6,\"Wolf\");\n       Animal coyote = new Animal(5,\"Coyote\");\n       Animal cat2 = new Animal(3,\"Cat\");\n       \n        System.out.println(cat.equals(cat2));\n       \n        System.out.println(set.add(cat));\n        System.out.println(set.add(cat));\n        System.out.println(set.add(dog));\n        System.out.println(set.add(wolf));\n        System.out.println(set.add(coyote));\n        System.out.println(set.add(cat2));\n        \n       \n        System.out.println(set.size());\n        System.out.println(set.remove(cat));\n        System.out.println(set.contains(cat));\n        System.out.println(set.size());\n        \n        \n    \n    }\n}\n\n\nclass Animal {\n    private Integer size;\n    private String name;\n    \n    public Animal(int x, String y){\n        size = x;\n        name = y;\n    }\n\n    public int getSize() {\n        return size;\n    }\n\n    public String getName() {\n        return name;\n    }\n    \n    public String toString(){\n        return name;\n    }\n    \n    public boolean equals(Object o){\n        if((o instanceof Animal)){\n            if((((Animal)o).getSize() == this.size) && (((Animal)o).getName().equals(name) ))\n                return true;\n            return false;           \n        } \n        return false;\n    }\n    \n    //public int hashCode(){ return name.length() + size; }\n        \n}','true\ntrue\nfalse\ntrue\ntrue\ntrue\nfalse\n4\ntrue\nfalse\n3','Collections',1,NULL),(2910,'public class Hello {\n    public static void main(String[] dicks){\n       HashSet<Animal> set = new HashSet<>();\n       \n       Animal cat = new Animal(3,\"Cat\");\n       Animal dog = new Animal(4,\"Dog\");\n       Animal wolf = new Animal(6,\"Wolf\");\n       Animal coyote = new Animal(5,\"Coyote\");\n       Animal cat2 = new Animal(3,\"Cat\");\n       \n        System.out.println(cat.equals(cat2));\n       \n        System.out.println(set.add(cat));\n        System.out.println(set.add(cat));\n        System.out.println(set.add(dog));\n        System.out.println(set.add(wolf));\n        System.out.println(set.add(coyote));\n        System.out.println(set.add(cat2));\n        \n       \n        System.out.println(set.size());\n        System.out.println(set.remove(cat));\n        System.out.println(set.contains(cat));\n        System.out.println(set.size());\n        \n        \n    \n    }\n}\n\n\nclass Animal {\n    private Integer size;\n    private String name;\n    \n    public Animal(int x, String y){\n        size = x;\n        name = y;\n    }\n\n    public int getSize() {\n        return size;\n    }\n\n    public String getName() {\n        return name;\n    }\n    \n    public String toString(){\n        return name;\n    }\n    \n    public boolean equals(Object o){\n        if((o instanceof Animal)){\n            if((((Animal)o).getSize() == this.size) && (((Animal)o).getName().equals(name) ))\n                return true;\n            return false;           \n        } \n        return false;\n    }\n    \n    public int hashCode(){ return name.length() + size; }\n        \n}\n','true\ntrue\nfalse\ntrue\ntrue\ntrue\nfalse\n4\ntrue\nfalse\n3\n\nif hashCode() is not overriden then every object will go in its own bucket\ntherefore equals will not be able to differentiate between equal objects because it will have no\nother objects to compare that object to!','Collections',1,NULL),(2911,'public class Hello {\n    public static void main(String[] dicks){\n       HashSet<Animal> set = new HashSet<>();\n       \n       Animal cat = new Animal(3,\"Cat\");\n       Animal dog = new Animal(4,\"Dog\");\n       Animal wolf = new Animal(6,\"Wolf\");\n       Animal coyote = new Animal(5,\"Coyote\");\n       Animal cat2 = new Animal(3,\"Cat\");\n       \n        System.out.println(cat.equals(cat2));\n       \n        System.out.println(set.add(cat));\n        System.out.println(set.add(cat));\n        System.out.println(set.add(dog));\n        System.out.println(set.add(wolf));\n        System.out.println(set.add(coyote));\n        System.out.println(set.add(cat2));\n        \n       \n        System.out.println(set.size());\n        System.out.println(set.remove(cat));\n        System.out.println(set.contains(cat));\n        System.out.println(set.size());\n        \n        \n    \n    }\n}\n\n\nclass Animal {\n    private Integer size;\n    private String name;\n    \n    public Animal(int x, String y){\n        size = x;\n        name = y;\n    }\n\n    public int getSize() {\n        return size;\n    }\n\n    public String getName() {\n        return name;\n    }\n    \n    public String toString(){\n        return name;\n    }\n    \n    /**\n    public boolean equals(Object o){\n        if((o instanceof Animal)){\n            if((((Animal)o).getSize() == this.size) && (((Animal)o).getName().equals(name) ))\n                return true;\n            return false;           \n        } \n        return false;\n    } **/\n    \n    public int hashCode(){ return name.length() + size; }\n        \n}\n','false\ntrue\nfalse\ntrue\ntrue\ntrue\ntrue\n5\ntrue\nfalse\n4\n\nif equals is not overriden then only references with the same actual\nobject are considered equal','Collections',1,NULL),(2912,'public class Hello {\n    public static void main(String[] dicks){\n       Animal cat = new Animal(3,\"Cat\");\n       Animal dog = new Animal(4,\"Dog\");\n       Animal wolf = new Animal(6,\"Wolf\");\n       Animal coyote = new Animal(5,\"Coyote\");\n       Animal cat2 = new Animal(3,\"Cat\");\n       \n       LinkedHashSet<Animal> lhs = new LinkedHashSet<>();\n       HashSet<Animal> hs = new HashSet<>();\n       \n       lhs.add(cat); lhs.add(dog); lhs.add(wolf); lhs.add(coyote); lhs.add(null);\n       hs.add(cat); hs.add(dog); hs.add(wolf); hs.add(coyote); hs.add(null);\n       \n       for(Animal x : lhs){\n           System.out.print(x.getName()+\" \");\n       }\n \n    }\n}','nullpointerexception\n\nLinkedHashSet and HashSet allow null elements but when you call a method on a null\nyou get an exception','Collections',1,NULL),(2913,'public class Hello {\n    public static void main(String[] dicks){\n       Animal cat = new Animal(3,\"Cat\");\n       Animal dog = new Animal(4,\"Dog\");\n       Animal wolf = new Animal(6,\"Wolf\");\n       Animal coyote = new Animal(5,\"Coyote\");\n       Animal cat2 = new Animal(3,\"Cat\");\n       \n       LinkedHashSet<Animal> lhs = new LinkedHashSet<>();\n       HashSet<Animal> hs = new HashSet<>();\n       \n       lhs.add(cat); lhs.add(dog); lhs.add(wolf); lhs.add(coyote);\n       hs.add(cat); hs.add(dog); hs.add(wolf); hs.add(coyote); \n       \n       System.out.println( lhs.add(null) ); \n       System.out.println( hs.add(null) );\n       \n       System.out.println( lhs.add(null) );\n       System.out.println( hs.add(null) );\n        \n\n    }\n}','true\ntrue\nfalse\nfalse\n\nSets allow null elements but they also dont allow duplicates so here \nis will not let you add ANother null','Collections',1,NULL),(2914,'public class Hello {\n    public static void main(String[] dicks){\n       Animal cat = new Animal(3,\"Cat\");\n       Animal dog = new Animal(4,\"Dog\");\n       Animal wolf = new Animal(6,\"Wolf\");\n       Animal coyote = new Animal(5,\"Coyote\");\n       Animal cat2 = new Animal(3,\"Cat\");\n       \n       LinkedHashSet<Animal> lhs = new LinkedHashSet<>();\n       HashSet<Animal> hs = new HashSet<>();\n       Hashtable<Animal> ht = new Hashtable<>();\n       \n       lhs.add(cat); lhs.add(dog); lhs.add(wolf); lhs.add(coyote);\n       hs.add(cat); hs.add(dog); hs.add(wolf); hs.add(coyote); \n       \n       System.out.println(lhs.add(null)); \n       System.out.println(hs.add(null));\n       \n       System.out.println(lhs.add(null));\n       System.out.println(hs.add(null));\n        \n\n    }\n}','will not compile,\n\nHashtable is a Map !\n\nrequires two type arguments','Collections',1,NULL),(2915,'public class Hello {\n    public static void main(String[] dicks){\n       Animal cat = new Animal(3,\"Cat\");\n       Animal dog = new Animal(4,\"Dog\");\n       Animal wolf = new Animal(6,\"Wolf\");\n       Animal coyote = new Animal(5,\"Coyote\");\n       Animal cat2 = new Animal(3,\"Cat\");\n\n       Hashtable<Integer,Animal> ht = new Hashtable<>();\n\n        System.out.println(ht.put(1,cat));\n        System.out.println(ht.put(2,dog));\n        System.out.println(ht.put(3,wolf));\n        System.out.println(ht.put(4,coyote));\n        System.out.println(ht.put(5, cat2));\n        \n        System.out.println(ht.put(1,cat));\n        System.out.println(ht.put(1,new Animal(3,\"Barn Cat\")));\n        \n        System.out.println(ht.put(2,dog));\n        System.out.println(ht.put(2, new Animal(4,\"Fox\")));\n    }\n}','null\nnull\nnull\nnull\nnull\nCat\nCat\nDog\nDog\n\nput\n\npublic V put(K key,\n    V value)\n\nMaps the specified key to the specified value in this hashtable. \nNeither the key nor the value can be null.\n\nThe value can be retrieved by calling the get\n method with a key that is equal to the original key.\n\nTo successfully store and retrieve objects from a hashtable, \nthe objects used as keys \nmust implement the hashCode method and the equals method. \n\nto know anything about how this code works you need to know if it implements\nequals and hashCode','Collections',1,NULL),(2916,'public class Hello {\n    public static void main(String[] dicks){\n       Animal cat = new Animal(3,\"Cat\");\n       Animal dog = new Animal(4,\"Dog\");\n       Animal wolf = new Animal(6,\"Wolf\");\n       Animal coyote = new Animal(5,\"Coyote\");\n       Animal cat2 = new Animal(3,\"Cat\");\n\n       Hashtable<Integer,Animal> ht = new Hashtable<>();\n\n        System.out.println(ht.put(1,cat));\n        System.out.println(ht.put(2,dog));\n        System.out.println(ht.put(3,wolf));\n        System.out.println(ht.put(4,coyote));\n        System.out.println(ht.put(5, cat2));\n        \n        System.out.println(ht.put(1,cat));\n        System.out.println(ht.put(1,new Animal(3,\"Barn Cat\")));\n        \n        System.out.println(ht.size());\n        \n        System.out.println(ht.put(2,dog));\n        System.out.println(ht.put(2, new Animal(4,\"Fox\")));\n    }\n}\n\n\nclass Animal {\n    private Integer size;\n    private String name;\n    \n    public Animal(int x, String y){\n        size = x;\n        name = y;\n    }\n\n    public int getSize() {\n        return size;\n    }\n\n    public String getName() {\n        return name;\n    }\n    \n    public String toString(){\n        return name;\n    }\n    \n    /**\n    public boolean equals(Object o){\n        if((o instanceof Animal)){\n            if((((Animal)o).getSize() == this.size) && (((Animal)o).getName().equals(name) ))\n                return true;\n            return false;           \n        } \n        return false;\n    } **/\n    \n    //public int hashCode(){ return name.length() + size; }\n        \n}\n','null\nnull\nnull\nnull\nnull\nCat\nCat\n5\nDog\nDog','Collections',1,NULL),(2917,'public class Hello {\n    public static void main(String[] dicks){\n        Map<String, Integer> map = new HashMap<>();\n        \n        String name = \"Max\";\n        map.put(name,10000000);\n        \n        int total = map.get(\"Max\");\n        \n        (if total == null){\n            System.out.println(\"no money in maxs account\");\n        }\n    }\n}','will not compile int cannot auotbox to null\n\na primitive cannot be null','Collections',1,NULL),(2918,'The generics type identifier can be used in class, method, and variable declarations....\n\n','class Foo<t> { }	// a class\nT anInstance;		//an instance variable\nFoo(T aRef) { }	// a constructor argument\nvoid bar(T aRef) { }	// a method argument\nT baz() { }		// a return type\n\nThe compiler will substitute the actual type','Generics',1,NULL),(2919,'Which Collection interfaces have a method for removing an element by the object ?','List and Set, With Maps you remove by the key which removes the element','Collections',1,NULL),(2920,'public class Hello {\n    public static void main(String[] args){\n        List myList = new ArrayList();\n        myList.add(\"Hoyt\");\n        myList.add(\"JOJO\");\n        myList.add(\"Adam\");\n        \n        String athletename = myList.get(1);\n        System.out.println(athletename+ \" \" + athletename.length());\n    }\n}','Will Not compile\n\nuntyped collections store Objects so you would have to cast to a String. ','Collections',1,NULL),(2921,'void takeListOfStrings(List<String> strings) {\n	strings.add(new Integer(42) ); \n}','Will Not compile','Generics',1,NULL),(2922,'public List<Dog> getDogList() {\n	List<Dog> dogs = new ArrayList<>();\n	//add dogs to list\n	return dogs;\n}\n\nDog d = getDogList().get(0);','Compiles fine, you know what is coming out of a typed list returned from a method declared with that type','Generics',1,NULL),(2923,'public List getDogList() {\n	List dogs = new ArrayList();\n	dogs.add(\"Dicks\");\n	dogs.add(\"Spot\");\n	dogs.add(\"FIdo\");\n	return dogs;\n}\n\npsvm(sa){	\n	List dognames = getDogList();\n	Dog fido = dognames.get(2);\n}\n	','Will not compile','Generics',1,NULL),(2924,'psvm(sa){\n	List<Integer> list = new ArrayList<>();\n	list.add(5);\n	list.add(9);\n	list.add(7);\n\n	Integer i = (Integer) list.get(0);\n}','The cast is unecessary but it wont cause any error','Generics',1,NULL),(2925,'public class Hello {\n    public static void main(String[] args){\n        List<Integer> myList = new ArrayList<>();\n        \n        myList.add(4);\n        myList.add(6);\n        Adder adder = new Adder();\n        int total = adder.addAll(myList);\n        \n        System.out.println(total);\n        \n    }\n}\n\nclass Adder {\n        int addAll(List list){\n            Iterator it = list.iterator();\n            int total = 0;\n            \n            while(it.hasNext()){\n                int i = ((Integer)it.next()).intValue();\n                total += i;\n            }\n            \n            return total;\n        }\n}','Works fine. ','Generics',1,NULL),(2926,'public class Hello {\n    public static void main(String[] args){\n        List myList = new ArrayList();\n        \n        myList.add(4);\n        myList.add(6);\n        myList.add(\"whoops\");\n        Adder adder = new Adder();\n        int total = adder.addAll(myList);\n        \n        System.out.println(total);\n        \n    }\n}\n\nclass Adder {\n        int addAll(List list){\n            Iterator it = list.iterator();\n            int total = 0;\n            \n            while(it.hasNext()){\n                int i = ((Integer)it.next()).intValue();\n                total += i;\n            }\n            \n            return total;\n        }\n}','ClassCastException','Generics',1,NULL),(2927,'public class Hello {\n    public static void main(String[] args){\n        List<Integer> myList = new ArrayList<>();\n        \n        myList.add(4);\n        myList.add(6);\n        Inserter is = new Inserter();\n        is.insert(myList);\n        \n    }\n}\n\nclass Inserter {\n        void insert(List list){\n            list.add(new Integer(42));\n            Iterator it = list.iterator();\n            int total = 0;\n            \n            while(it.hasNext()){\n                int i = ((Integer)it.next()).intValue();\n                total += i;\n            }\n\n        }\n}','compiles and runs no problem','Generics',1,NULL),(2928,'public class Hello {\n    public static void main(String[] args){\n        List<Integer> myList = new ArrayList<>();\n        \n        myList.add(4);\n        myList.add(6);\n        Inserter is = new Inserter();\n        is.insert(myList);\n        \n    }\n}\n\nclass Inserter {\n        void insert(List list){\n            list.add(\"42\");\n            Iterator it = list.iterator();\n            int total = 0;\n            \n            while(it.hasNext()){\n                int i = ((Integer)it.next()).intValue();\n                total += i;\n            }\n\n        }\n}','ClassCastException\n\nand compiler warning for going into unsafe method','Generics',1,NULL),(2929,'public class Hello {\n    public static void main(String[] args){\n        List<Integer> myList = new ArrayList<>();\n        \n        myList.add(4);\n        myList.add(6);\n        Inserter is = new Inserter();\n        is.insert(myList);\n        \n    }\n}\n\nclass Inserter {\n        void insert(List list){\n            list.add(\"42\");\n            Iterator it = list.iterator();\n            int total = 0;\n            \n            while(it.hasNext()){\n                int i = (it.next()).intValue();\n                total += i;\n            }\n\n        }\n}','Will not compile because of .intValue() the list declared in inserter is of type Object','Generics',1,NULL),(2930,'public class Hello {\n    public static void main(String[] args){\n        List<Integer> myList = new ArrayList<>();\n        \n        myList.add(4);\n        myList.add(6);\n        Inserter is = new Inserter();\n        is.insert(myList);\n        \n    }\n}\n\nclass Inserter {\n        void insert(List list){\n            list.add(\"42\");           \n        }\n}','comiler warning but compiles and runs just fine, in order to support legacy code this must be allowed. ','Generics',1,NULL),(2931,'The compiiler only issues warnings when a typed collection is going into an untyped method and that method\nADDS somethiing. ','','Generics',1,NULL),(2932,'\"Type Erasure\"\n','The generic types are removed by the compiler before runtime. The types are just for the compiler the JVM\nhas no idea about types. To the JVM generic code looks the same as pre generic. ','Generics',1,NULL),(2933,'List myList = new ArrayList();\n        \nmyList.add(45);\n        \nint x = (Integer) myList.get(0);','cast is required here','Generics',1,NULL),(2934,' List<Integer> myList = new ArrayList<>();\n        \n        myList.add(45);\n        \n        int x = myList.get(0);\n        \n        ','cast not necessary here','Generics',1,NULL),(2935,'List<Object> myList = new ArrayList<JButton>();\nList<Number> myList = new ArrayList<Integer>();\nList<JButton> myList = new ArrayList<JButton>();\nList<String> myList = new ArrayList<String>();','no\nno\nyes\nyes','Generics',1,NULL),(2936,'class Parent { }\nclass Child extends Parent { }\n\npublic class Test {\n	psvm(SA){\n		Parent[] myArray = new Child[4];\n	}\n}','This is ok!\n\nunlike collection types array types can use polymorphism.\n','Generics',1,NULL),(2937,'List<Object> myList = new ArrayList<JButton>();	','This not ok ','Generics',1,NULL),(2938,'public class AnimalDoctor {\n	public void checkAnimals(ArrayLIst<Animal> list){\n		for(Animal a : animals){\n			a.checkup();\n		}\n	}\n}\n\npsvm(Sa){\n        List<Dog> dogs = new ArrayList<Dog>();\n        dogs.add(new Dog()); dogs.add(new Dog());\n\n        List<Cat> cats = new ArrrayLiist<Cat>();\n        cats.add(new Cat()); cats.add(new Cat());\n\n        AnimalDoctor ad = new AnimalDoctor();\n        ad.checkAnimals(dogs);\n        ad.checkAnimals(cats);\n}\n}','Will not compile\n\nif the method parameter says ArrayList<Animal> then you\ncan only pass in an ArrayList of type <Animal>, \npolymorphism doesn\'t work for generic types','Generics',1,NULL),(2939,'Animal[] animals = new Animal[3];\nanimals[0] = new Cat();\nanimals[1] = new Dog();','fine','Generics',1,NULL),(2940,'List<Animal> animals = new ArrayList<Animal>();\nanimals.add(new Cat());\nanimals.add(new Dog());\n','fine you can add and instance of a subtype into an array or collection declared with a supertype.\n\nyou can addDogs and Cats to an Animal array or an Animal Collection. ','Generics',1,NULL),(2941,'public class Hello {\n    public static void main(String[] args){\n       \n      \n        \n    }\n    \n    public void foo() {\n	Dog[] dogs = { new Dog(), new Dog() };\n	addAnimal(dogs);\n    }\n    \n    public void addAnimal(Animal[] animals) {\n	animals[0] = new Dog();\n        animals[1] = new Cat();\n    }\n}','ok!','Generics',1,NULL),(2942,'public class Hello {\n    public static void main(String[] args){\n \n    }\n    \n    public void foo() {\n	Cat[] cats = { new Cat(), new Cat() };\n	addAnimal(cats);\n    }\n    \n    public void addAnimal(Animal[] animals) {\n	animals[0] = new Dog();\n        animals[1] = new Cat();\n    }\n}','ok !\n\nThe compiler thinks its ok to add a Dog to an Animal[] since a Dog can be assigned to an animal reference. B\n\nBut the compiler does not know if you passed in an array of an animal subtype. \n\nThe reason: at runtime the JVM knows the type of the array but not the type of the collection ','Generics',1,NULL),(2943,'public class Hello {\n    public static void main(String[] args){\n        List<Animal> animals = new ArrayList<Animal>();\n        animals.add(new Dog());\n        animals.add(new Cat());\n        \n        addAnimal(animals);\n    \n    }\n    public static void addAnimal(List<Animal> animals) {\n	animals.add(new Dog());\n    }\n}','comiles and runs just fine','Generics',1,NULL),(2944,'public class Hello {\n    public static void main(String[] args){\n        ArrayList<Animal> animals = new ArrayList<>();\n        animals.add(new Dog());\n        animals.add(new Cat());\n        \n        addAnimal(animals);\n    \n    }\n    public static void addAnimal(List<Animal> animals) {\n	animals.add(new Dog());\n    }\n}','comiles fine','Generics',1,NULL),(2945,'public class Hello {\n    public static void main(String[] args){\n        List<Dog> animals = new ArrayList<>();\n        animals.add(new Dog());\n        \n        \n        addAnimal(animals);\n    \n    }\n    public static void addAnimal(List<Animal> animals) {\n	animals.add(new Dog());\n    }\n}','will not compile, ','Generics',1,NULL),(2946,'public class Hello {\n    public static void main(String[] args){\n        ArrayList<Dog> animals = new ArrayList<>();\n        animals.add(new Dog());\n        \n        \n        addAnimal(animals);\n    \n    }\n    public static void addAnimal(List<Animal> animals) {\n	animals.add(new Dog());\n    }\n}','will not compile because of ArrayList<Dog> cant be applied to List<Animal>','Generics',1,NULL),(2947,'What mechanism is used to tell the compiler \" Hey, I\'m using the collection passed in just to invoke methods \non the elements  and I promise not to ADD anything into the collection\"','<?> wildcard\n\ntells the compiler you can take any generic subtype of the declared argument type because you won\'t\nbe putting anything in the collection. ','Generics',1,NULL),(2948,'public class Hello {\n    public static void main(String[] args){\n        ArrayList<Dog> animals = new ArrayList<>();\n        animals.add(new Dog());\n        \n        \n        addAnimal(animals);\n    \n    }\n    public static void addAnimal(List<? extends Animal> animals) {\n	animals.add(new Dog());\n    }\n}','wont compile \n\nadding to a collection is not compatible with ? notation','Generics',1,NULL),(2949,'public class Hello {\n    public static void main(String[] args){\n        ArrayList<Dog> animals = new ArrayList<>();\n        animals.add(new Dog());\n        \n        \n        addAnimal(animals);\n    \n    }\n    public static void addAnimal(List<? extends Animal> animals) {\n	for(Animal a : animals){\n            a.makesound();\n        }\n    }\n}','compiles fine!','Generics',1,NULL),(2950,'public class Hello {\n    public static void main(String[] args){\n        ArrayList<Dog> animals = new ArrayList<>();\n        animals.add(new Dog());\n        \n        \n        addAnimal(animals);\n    \n    }\n    public static void addAnimal(List<? extends Serializable> animals) {\n	for(Animal a : animals){\n            a.makesound();\n        }\n    }\n}\n\nclass Dog extends Animal{}\nclass Cat extends Animal{}\nclass Animal implements Serializable{\n    public void makesound(){ System.out.println(\"SOUND\"); }\n        \n}','will not compile because of for(Animal a : animals)\n\n	needs to be... \n		for(Serializable a : animals)','Generics',1,NULL),(2951,'public class Hello {\n    public static void main(String[] args){\n        ArrayList<Dog> animals = new ArrayList<>();\n        animals.add(new Dog());\n        \n        \n        addAnimal(animals);\n    \n    }\n    public static void addAnimal(List<? extends Serializable> animals) {\n	for(Serializable a : animals){\n            //call method form interface\n        }\n    }\n}\n\nclass Dog extends Animal{}\nclass Cat extends Animal{}\nclass Animal implements Serializable{\n    public void makesound(){ System.out.println(\"SOUND\"); }\n        \n}','compiles fine!','Generics',1,NULL),(2952,'What can you use to type a method parameter and still add to the collection','<? super Dog>\n\npublic class Hello {\n    public static void main(String[] args) {     \n\n        List<Animal> animals = new ArrayList<Animal>();\n        animals.add(new Dog());\n        animals.add(new Cat());\n        \n        addAnimal(animals);\n    \n    }\n    \n    public static void addAnimal(List<? super Dog> animals) {\n	animals.add(new Dog());\n    }\n}\n\nWhile you can now accept in List types of <? super Dog> you can still only\nadd type Dog to that list. This is created because its ok to add a Dog to List<Object>\n\n\n','Generics',1,NULL),(2953,'public class Hello {\n    public static void main(String[] args){\n        List<Animal> animals = new ArrayList<Animal>();\n        animals.add(new Dog());\n        animals.add(new Animal());\n        \n        addAnimal(animals);\n        \n    \n    }\n    public static void addAnimal(List<? super Dog> animals) {\n	animals.add(new Dog());\n    }\n}','this is fine\n\n\"Hey compiler, please accept any List with a generic type that is of type Dog or a supertype of Dog. \nNothing lower in the inheritance tree can come in, but anything higher than Dog is okay\"\n\nif you pass in a List of type Animal then it\'s perfectly fine to add a Dog to it. If you pass in a list of type Dog\nits still ok to add a Dog to it. if you pass in a list of type Object its still ok. \n\nHowever that doesn\'t give you the freedom to just add anything  you can still\nonly add the type after the super','Generics',1,NULL),(2954,'public class Hello {\n    public static void main(String[] args){\n        List<Animal> animals = new ArrayList<Animal>();\n        animals.add(new Dog());\n        animals.add(new Animal());\n        \n        addAnimal(animals);\n        \n    \n    }\n    public static void addAnimal(List<Object> animals) {\n	animals.add(new Dog());\n    }\n}','will not compile incompatible types ','Generics',1,NULL),(2955,'','','Generics',1,NULL),(2956,'whats the difference between\n\npublic void foo(List<?> list){ }\npublic void foo(List<Object> list) { }','? will mean that any type of list can be passed to this method however nothing will be allowed to be added to it\n\n<Object> will mean that only lists of type Object can be passed to this method and \nyou will be able to add pretty much anything to that list. ','Generics',1,NULL),(2957,'public class TestWildcards {\n	psvm(sa) {\n		List<Integer> myList = new ArrayList<Integer>();\n		Bar bar = new Bar();\n		bar.doInsert(MyList);\n	}\n}\n\nclass Bar {\n	void doInsert(List<Object> list) {\n		list.add(new Dog();	\n	}\n}\n\nwhich class fails compilation here ?','class Bar compiles fine\n\nTest is the class that fails. ','Generics',1,NULL),(2958,'public class TestWildcards {\n	psvm(sa) {\n		List<Integer> myList = new ArrayList<Integer>();\n		Bar bar = new Bar();\n		bar.doInsert(MyList);\n	}\n}\n\nclass Bar {\n	void doInsert(List<?> list) {\n		list.add(new Dog();	\n	}\n}\n\nwhich class fails compilation here ?','Bar','Generics',1,NULL),(2959,'whats the difference between \n\nList<?>\nList<? extends Object>','nothing they are identicle \n\nthey both say I can refer to any type of object. but you wont be able to addd to me. \n\nthis is very differenct from List<Object> ','Generics',1,NULL),(2960,'1 List<?> list = new ArrayList<Dog>();\n2 List<? extends Animal> alist = new ArrayList<Dog>();\n3  List<?> foo = new ArrayList<? extends Animal>();\n4 List<? extends Dog> cList = new ArrayList<Integer>();\n5 List<? super Dog> dList = new ArrayList<Animal>();\n6 List<? super Animal elist = new ArrayList<Dog>();\n\n','1 2  and 5 compile ','Generics',1,NULL),(2961,'Which interface close() is idempotent ?','AutoCloseable()\nyou can call close() mulitple times and nothing will happen the second time and beyond. \n\nCloseable() is not, something could go wrong the second time','Generics',1,NULL),(2962,'declare a generic method:\n\npublic <T> void makeArrayList(T t){ }\n\npublic void makeArrayList(T t) { }\n\npublic void <T> makeArrayList(T t){\n}','public <T> void makeArrayList(T t){ }\n\nYou have to define the type variable BEFORE the return type of the method\n\n','Generics',1,NULL),(2963,'public class Hello<T> {\n    public static void main(String[] args){\n        Printer<String> x = Printer.getInstance();\n\n    }\n    public static void addAnimal(List<T> animals) {\n	animals.add(new Dog());\n    }\n    \n    public <G> ArrayList<G> makeArrayList(G g){\n        ArrayList<G> genlist = new ArrayList();\n        genlist.add(g);\n        return genlist;\n        \n    }\n}\n\nclass Printer<T> {\n    private ArrayList<T> joblist = new ArrayList<>();\n    private static Printer instance = null;\n    \n    protected Printer(){\n        \n    }\n    \n    public static Printer getInstance(){\n        if(instance == null){\n            instance = new Printer();\n            return instance;\n        }\n        \n        return instance;\n        \n    }\n    \n    public void addJob(T t){\n        joblist.add(t);\n    }\n}','Will not compile \n\nNon static type variable cannot be referenced from static context. \n\nWhen T is defined for a new class it is appropriate for that instance there forfore static methods of that \nclass wont really know about the individualy typed instances. \n\nSingleton with generics doesn\'t make a whole lot of sense anyway....\n\npublic class SimpleSingleton {\nprivate Map<String, Object> counter = new HashMap<String, Object>();\n\npublic <T> T getInstance(Class<T> clazz) throws IllegalAccessException, InstantiationException {\n    T singleton = (T) counter.get(clazz.getName());\n    if (singleton == null) {\n        singleton = clazz.newInstance();\n        counter.put(clazz.getName(), singleton);\n    }\n    return singleton;\n}\n\n\nalso adding a Dog to an ArrayList typed for T will not compile \n','Generics',1,NULL),(2964,'public class Hello<T> {\n    public static void main(String[] args){\n        Printer<String> x = new Printer<>();\n        String y = x.instance;\n        System.out.println(y.length());\n\n    } \n    public <G> ArrayList<G> makeArrayList(G g){\n        ArrayList<G> genlist = new ArrayList();\n        genlist.add(g);\n        return genlist;\n        \n    }\n}\n\nclass Printer<T> {\n    private ArrayList<T> joblist = new ArrayList<>();\n    T instance;\n    \n    public Printer(){\n        \n    }\n    \n    public void addJob(T t){\n        joblist.add(t);\n    }\n    \n    public T getAnewT(){\n        return instance;\n    }\n}','NullPointerException\n\ninstance in class Printer is never intitialized','Generics',1,NULL),(2965,'class Printer<T> {\n    private ArrayList<T> joblist = new ArrayList<>();\n    private T instance;\n    \n    public Printer(){\n        \n    }\n    \n    public Printer(T b){\n        T = b;\n    }\n    \n    public void addJob(T t){\n        joblist.add(t);\n    }\n    \n    public T getAnewT(){\n        return instance;\n    }\n}','in the overloaded constructor T should be instance, remember a Type is an Object not an reference varialb.e','Generics',1,NULL),(2966,'class Printer<T extends Number> {\n    private ArrayList<T> joblist = new ArrayList<>();\n    private T instance;\n    \n    public Printer(){\n        \n    }\n    \n    public Printer(T b){\n       instance = b;\n    }\n    \n    public void addJob(T t){\n        joblist.add(t);\n    }\n    \n    public T getAnewT(){\n        return instance;\n    }\n}','a Class will be created with a type that extends number','Generics',1,NULL),(2967,'class Printer<? extends Number> {\n    private ArrayList<T> joblist = new ArrayList<>();\n    private T instance;\n    \n    public Printer(){\n        \n    }\n    \n    public Printer(T b){\n       instance = b;\n    }\n    \n    public void addJob(T t){\n        joblist.add(t);\n    }\n    \n    public T getAnewT(){\n        return instance;\n    }\n}','will not compile, a type variable is needed here not a wildcard.\n\nWildcards are never used in generic class definitions','Generics',1,NULL),(2968,'class Printer<T super Beagle> {\n    private ArrayList<T> joblist = new ArrayList<>();\n    private T instance;\n    \n    public Printer(){\n        \n    }\n    \n    public Printer(T b){\n       instance = b;\n    }\n    \n    public void addJob(T t){\n        joblist.add(t);\n    }\n    \n    public T getAnewT(){\n        return instance;\n    }\n}\n\nclass Animal{}\nclass Dog extends Animal{}\nclass Beagle extends Dog{}','Does not compile,\n\nyou cant use super when defining a generic class','Generics',1,NULL),(2969,'class Printer<T extends Animal> {\n    private ArrayList<T> joblist = new ArrayList<>();\n    private T instance;\n    \n    public Printer(){\n        \n    }\n    \n    public Printer(T b){\n       instance = b;\n    }\n    \n    public void addJob(T t){\n        joblist.add(t);\n    }\n    \n    public void makeSound() {\n        instance.makeSound();\n    }\n    \n    public T getAnewT(){\n        return instance;\n    }\n}\n\nclass Animal{public void makeSound(){\n            System.out.println(\"Sound!\");\n}\n}\nclass Dog extends Animal{}\nclass Beagle extends Dog{}','fine,\n\nyou use extends when creating a generic class to specify bounds','Generics',1,NULL),(2970,'public class Hello<T> {\n    public static void main(String[] args){\n        \n        Printer<String> x = new Printer<>();\n\n\n    } \n    public <G> ArrayList<G> makeArrayList(G g){\n        ArrayList<G> genlist = new ArrayList();\n        genlist.add(g);\n        return genlist;\n        \n    }\n}\n\nclass Printer<T extends Animal> {\n    private ArrayList<T> joblist = new ArrayList<>();\n    private T instance;\n    \n    public Printer(){\n        \n    }\n    \n    public Printer(T b){\n       instance = b;\n    }\n    \n    public void addJob(T t){\n        joblist.add(t);\n    }\n    \n    public void makeSound() {\n        instance.makeSound();\n    }\n    \n    public T getAnewT(){\n        return instance;\n    }\n}\n\nclass Animal{public void makeSound(){\n            System.out.println(\"Sound!\");\n}\n}\nclass Dog extends Animal{}\nclass Beagle extends Dog{}','will not compile type argument string is not within bound of class Printer','Generics',1,NULL),(2971,'public class Hello<T> {\n    public static void main(String[] args){\n\n        ArrayList x = makeArrayList(Dog d);\n        \n        ArrayList c = new ArrayList<String>();\n\n    } \n    public <G> ArrayList<G> makeArrayList(G g){\n        ArrayList<G> genlist = new ArrayList();\n        genlist.add(g);\n        return genlist;\n        \n    }\n}','will not compile because of (Dog d)','Generics',1,NULL),(2972,'public class Hello<T> {\n    public static void main(String[] args){\n        \n        Dog d = new Dog();\n        \n        ArrayList x = makeArrayList(d);\n        \n        ArrayList c = new ArrayList<String>();\n\n    } \n    public static <G> ArrayList<G> makeArrayList(G g){\n        ArrayList<G> genlist = new ArrayList();\n        genlist.add(g);\n        return genlist;\n        \n    }\n}','compiles fine.','Generics',1,NULL),(2973,'public class Hello<T> {\n    public static void main(String[] args){\n        \n        Dog d = new Dog();\n        \n        ArrayList x = makeArrayList(d);\n        \n        ArrayList c = new ArrayList<String>();\n        c.add(\"quick string\");\n        \n        x.add(new Dog());\n        \n        Dog a = x.get(0);\n        String stringa = c.get(0);\n \n    } \n    public static <G> ArrayList<G> makeArrayList(G g){\n        ArrayList<G> genlist = new ArrayList();\n        genlist.add(g);\n        return genlist;\n        \n    }\n}','neither Dog a nor stringa will compile. The Declared type of the arraylists is non generic so they return objects\n','Generics',1,NULL),(2974,'public class Hello<T> {\n    public static void main(String[] args){\n        \n        Dog d = new Dog();\n        \n        ArrayList<Dog> c = makeArrayList(d);\n \n    } \n    public static <G> ArrayList<G> makeArrayList(G g){\n        ArrayList<G> genlist = new ArrayList();\n        genlist.add(g);\n        return genlist;\n        \n    }\n}','compiles fine','Generics',1,NULL),(2975,'public class Hello<T> {\n    public static void main(String[] args){\n        \n        Dog d = new Dog();\n        \n        ArrayList<Dog> c = makeArrayList(d);\n        \n        c.add(new Beagle());\n \n    } \n    public static <G extends Animal> ArrayList<G> makeArrayList(G g){\n        ArrayList<G> genlist = new ArrayList();\n        genlist.add(g);\n        return genlist;\n        \n    }\n}\n\n\nclass Animal{public void makeSound(){\n            System.out.println(\"Sound!\");\n}\n}\nclass Dog extends Animal{}\nclass Beagle extends Dog{}','compiles fine','Generics',1,NULL),(2976,'public class Hello<T> {\n    public static void main(String[] args){\n        \n        Dog d = new Dog();\n        \n        ArrayList<Dog> c = makeArrayList(d);\n \n    } \n    public static <? extends Animal> ArrayList<?> makeArrayList(? g){\n        ArrayList<?> genlist = new ArrayList();\n        genlist.add(g);\n        return genlist;\n        \n    }\n}','Compilation fails ? wildcard is not valid here you need a type varialbe istead','Generics',1,NULL),(2977,'public class Hello<T> {\n    public static void main(String[] args){\n        \n        Dog d = new Dog();\n        \n        ArrayList<?> c = makeArrayList(d);\n \n    } \n    public static <G extends Animal> ArrayList<G> makeArrayList(G g){\n        ArrayList<G> genlist = new ArrayList();\n        genlist.add(g);\n        return genlist;\n        \n    }\n}','compiles fine, \n\nyou can define ArrayLIsts this way, you wont be able to add anything to it though','Generics',1,NULL),(2978,'public class Hello<T> {\n    public static void main(String[] args){\n        \n        Dog d = new Dog();\n        \n        ArrayList<?> c = makeArrayList(d);\n        c.add(new Animal());\n    } \n    public static <G extends Animal> ArrayList<G> makeArrayList(G g){\n        ArrayList<G> genlist = new ArrayList();\n        genlist.add(g);\n        return genlist;\n        \n    }\n}','compilation fails','Generics',1,NULL),(2979,'public class Hello<T> {\n    public static void main(String[] args){\n        \n        Dog d = new Dog();\n        \n        ArrayList<H extends Beagle> c = makeArrayList(d);\n        \n    } \n    public static <G extends Animal> ArrayList<G> makeArrayList(G g){\n        ArrayList<G> genlist = new ArrayList();\n        genlist.add(g);\n        return genlist;\n        \n    }\n}','does not compile because of H extends Beagle\n\nshould be ? extends Beagle','Generics',1,NULL),(2980,'public class Hello<T> {\n    public static void main(String[] args){\n        \n        Dog d = new Dog();\n        \n        ArrayList<? extends Beagle> c = makeArrayList(d);\n        \n    } \n    public static <G extends Animal> ArrayList<G> makeArrayList(G g){\n        ArrayList<G> genlist = new ArrayList();\n        genlist.add(g);\n        return genlist;\n        \n    }\n}\n\n\nclass Animal{public void makeSound(){\n            System.out.println(\"Sound!\");\n}\n}\nclass Dog extends Animal{}\nclass Beagle extends Dog{}','does not compile Beagle is the lowest type and nothing extends it,\n\nthe only type that would be acceptable here is a Beagle','Generics',1,NULL),(2981,'public class Hello<T> {\n    public static void main(String[] args){\n        \n        Dog d = new Dog();\n        \n        ArrayList<? extends Animal> c = makeArrayList(d);\n        \n    } \n    public static <G extends Animal> ArrayList<G> makeArrayList(G g){\n        ArrayList<G> genlist = new ArrayList();\n        genlist.add(g);\n        return genlist;\n        \n    }\n}\n\n\nclass Animal{public void makeSound(){\n            System.out.println(\"Sound!\");\n}\n}\nclass Dog extends Animal{}\nclass Beagle extends Dog{}','compiles fine','Generics',1,NULL),(2982,'PECS','\n\nPECS (short for \"Producer extends and Consumer super\") can be explained by : Get and Put Principle\nGet And Put Principle (From Java Generics and Collections)\n\nIt states,\n\n    use an extends wildcard when you only get values out of a structure\n    use a super wildcard when you only put values into a structure\n    and don’t use a wildcard when you both get and put.\n\nLet\'s understand it by example:\n\n1. For Extends Wildcard(get values i.e Producer extends)\n\nHere is a method, that takes a collection of numbers, converts each to a double, and sums them up\n\npublic static double sum(Collection<? extends Number> nums) {\n   double s = 0.0;\n   for (Number num : nums) \n      s += num.doubleValue();\n   return s;\n}\n\nLet\'s call the method :\n\nList<Integer>ints = Arrays.asList(1,2,3);\nassert sum(ints) == 6.0;\nList<Double>doubles = Arrays.asList(2.78,3.14);\nassert sum(doubles) == 5.92;\nList<Number>nums = Arrays.<Number>asList(1,2,2.78,3.14);\nassert sum(nums) == 8.92;\n\nSince, sum() method uses extends, all of the following calls are legal. The first two calls would not be legal if extends was not used.\n\nEXCEPTION : You cannot put anything into a type declared with an extends wildcard—except for the value null, which belongs to every reference type:\n\nList<Integer> ints = new ArrayList<Integer>();\nints.add(1);\nints.add(2);\nList<? extends Number> nums = ints;\nnums.add(null);  // ok\nassert nums.toString().equals(\"[1, 2, null]\");\n\n2. For Super Wildcard(put values i.e Consumer super)\n\nHere is a method, that takes a collection of numbers and an int n, and puts the first n integers, starting from zero, into the collection:\n\npublic static void count(Collection<? super Integer> ints, int n) {\n    for (int i = 0; i < n; i++) ints.add(i);\n}\n\nLet\'s call the method :\n\nList<Integer>ints = new ArrayList<Integer>();\ncount(ints, 5);\nassert ints.toString().equals(\"[0, 1, 2, 3, 4]\");\nList<Number>nums = new ArrayList<Number>();\ncount(nums, 5); nums.add(5.0);\nassert nums.toString().equals(\"[0, 1, 2, 3, 4, 5.0]\");\nList<Object>objs = new ArrayList<Object>();\ncount(objs, 5); objs.add(\"five\");\nassert objs.toString().equals(\"[0, 1, 2, 3, 4, five]\");\n\nSince, count() method uses super, all of the following calls are legal: The last two calls would not be legal if super was not used.\n\nEXCEPTION : you cannot get anything out from a type declared with a super wildcard—except for a value of type Object, which is a supertype of every reference type:\n\nList<Object> objs = Arrays.<Object>asList(1,\"two\");\nList<? super Integer> ints = objs;\nString str = \"\";\nfor (Object obj : ints) str += obj.toString();\nassert str.equals(\"1two\");\n\n3. When both Get and Put, don\'t Use wildcard\n\nWhenever you both put values into and get values out of the same structure, you should not use a wildcard.\n\npublic static double sumCount(Collection<Number> nums, int n) {\n   count(nums, n);\n   return sum(nums);\n}\n\n','Generics',1,NULL),(2983,'public class Hello<T> {\n    \n    public static void main(String[] args){\n        \n        Dog d = new Dog();\n        \n        ArrayList<? extends Animal> c = new ArrayList<Beagle>();\n        \n        c.add(new Beagle()); // does not compile\n        c.add(new Beagle()); // does not compile\n        \n        Animal a = c.get(0);\n    } ','PECS\n\nproducers extends consumers super','Generics',1,NULL),(2984,'public class Hello<T> {\n    \n    public static void main(String[] args){\n        \n        Dog d = new Dog();\n        \n        ArrayList<? super Beagle> c = new ArrayList<Beagle>();\n        \n        c.add(new Beagle());\n        c.add(new Beagle()); \n        \n        Beagle a = c.get(0);\n    } ','does not compile because of Beagle a = c.get(0);','Generics',1,NULL),(2985,'public class Hello<T> {\n    \n    public static void main(String[] args){\n        \n        Dog d = new Dog();\n        \n        ArrayList<Dog> c = makeArrayList(d);\n        \n        c.add(new Beagle());\n        c.add(new Beagle()); \n\n    } \n    public static <G extends Animal> ArrayList<G> makeArrayList(G g){\n        ArrayList<G> genlist = new ArrayList<>();\n        genlist.add(g);\n        return genlist;\n        \n    }\n}','compiles fine','Generics',1,NULL),(2986,'public class Hello<T> {\n    \n    public static void main(String[] args){\n        \n        Dog d = new Dog();\n        \n        ArrayList<Dog> c = makeArrayList(new Beagle());\n        \n        c.add(new Beagle());\n        c.add(new Beagle()); \n\n    } \n    public static <G extends Animal> ArrayList<G> makeArrayList(G g){\n        ArrayList<G> genlist = new ArrayList<>();\n        genlist.add(g);\n        return genlist;\n        \n    }\n}','compiles fine','Generics',1,NULL),(2987,'public class Hello<T> {\n    \n    public static void main(String[] args){\n        \n        Dog d = new Dog();\n        \n        ArrayList<Dog> c = makeArrayList(new Animal());\n        \n        c.add(new Beagle());\n        c.add(new Beagle()); \n\n    } \n    public static <G extends Animal> ArrayList<G> makeArrayList(G g){\n        ArrayList<G> genlist = new ArrayList<>();\n        genlist.add(g);\n        return genlist;\n        \n    }\n}','comilation fails\n\nArrayLIst<Animal> cannot be applied to ArrayList<Dog>','Generics',1,NULL),(2988,'\npublic class Hello<T> {\n    \n    public static void main(String[] args){\n        \n        Dog d = new Dog();\n        \n        ArrayList<?> c = makeArrayList(new Animal());\n        \n\n    } \n    public static <G extends Animal> ArrayList<G> makeArrayList(G g){\n        ArrayList<G> genlist = new ArrayList<>();\n        genlist.add(g);\n        return genlist;\n        \n    }\n}','comiles fine','Generics',1,NULL),(2989,'public class Test {\n\n    public class A {}\n\n    public class B extends A {}\n\n    public class C extends B {}\n\n    public void testCoVariance(List<? extends B> myBlist) {\n        B b = new B();\n        C c = new C();\n        myBlist.add(b); // does not compile\n        myBlist.add(c); // does not compile\n        A a = myBlist.get(0); \n    }\n\n    public void testContraVariance(List<? super B> myBlist) {\n        B b = new B();\n        C c = new C();\n        myBlist.add(b);\n        myBlist.add(c);\n        A a = myBlist.get(0); // does not compile\n    }\n}','','Generics',1,NULL),(2990,'PECS','\n\nJosh Bloch\'s mnemonic PECS is useful here. It stands for:\n\nProducer extends, Consumer super\n\nThis means that when a parameterized type being passed to a method will produce instances of T (they will be retrieved from it in some way), ? extends T should be used, since any instance of a subclass of T is also a T.\n\nWhen a parameterized type being passed to a method will consume instances of T (they will be passed to it to do something), ? super T should be used because an instance of T can legally be passed to any method that accepts some supertype of T. A Comparator<Number> could be used on a Collection<Integer>, for example. ? extends T would not work, because a Comparator<Integer> could not operate on a Collection<Number>.\n\nEdit: To clarify a little more on get/put (produce/consume):\n\npublic T something();\n       ^\n\nThe above is a method that produces T.\n\npublic void something(T t);\n                      ^\n\nThe above is a method that consumes T.\n\n\"Producer extends, Consumer super\" applies to how the method a parameterized object is being passed to is going to be using that object. In the case of Collections.max(), items will be retrieved from the Collection, so it is a producer. Those items will be passed as arguments to the method on Comparator, so it is a consumer.\n','Generics',1,NULL),(2991,'/ Source \n       List<Integer> intList = Arrays.asList(1,2,3);\n       List<Double> doubleList = Arrays.asList(2.78,3.14);\n       List<Number> numList = Arrays.asList(1,2,2.78,3.14,5);\n\n       // Destination\n       List<Integer> intList2 = new ArrayList<>();\n       List<Double> doublesList2 = new ArrayList<>();\n       List<Number> numList2 = new ArrayList<>();\n\n        // Works\n        copyElements1(intList,intList2);         // from int to int\n        copyElements1(doubleList,doublesList2);  // from double to double\n\n\n     static <T> void copyElements1(Collection<T> src, Collection<T> dest) {\n        for(T n : src){\n            dest.add(n);\n         }\n      }\n\n\n     // Let\'s try to copy intList to its supertype\n     copyElements1(intList,numList2); // error, method signature just says \"T\"\n                                      // and here the compiler is given \n                                      // two types: Integer and Number, \n                                      // so which one shall it be?\n\n     // PECS to the rescue!\n     copyElements2(intList,numList2);  // possible\n\n\n\n    // copy Integer (? extends T) to its supertype (Number is super of Integer)\n    private static <T> void copyElements2(Collection<? extends T> src, \n                                          Collection<? super T> dest) {\n        for(T n : src){\n            dest.add(n);\n        }\n    }','','Generics',1,NULL),(2992,'public class Hello<T> {\n    \n    public static void main(String[] args){\n        ArrayList<Animal> a;\n        ArrayList<Beagle> b;\n        \n        Hello<String> x = new Hello<>();\n        \n        x.copyColl(a,b);\n        \n\n    } \n    public <G> void copyColl(Collection<G> src, Collection<G> dest){\n        \n        for(G n : src)\n            dest.add(n);\n        \n    }\n}','does not compile Collection<G> is given two different types here\n\nalso a and b were not initialized, that is ok to do with instance variables\nbut not locals \n\nyou could say \n\nArrayList<Animal> a = null;\nand same for b;','Generics',1,NULL),(2993,'public class Hello<T> {\n    \n    public static void main(String[] args){\n        ArrayList<Dog> a = new ArrayList<>();\n        ArrayList<Dog> b = new ArrayList<>();\n        \n        Hello<String> x = new Hello<>();\n        \n        x.copyColl(a,b);\n        \n\n    } \n    public <G extends Animal> void copyColl(Collection<G> src, Collection<G> dest){\n        \n        for(G n : src)\n            dest.add(n);\n        \n    }\n}','compiles fine','Generics',1,NULL),(2994,'public class Hello<T> {\n    \n    public static void main(String[] args){\n        ArrayList<Dog> a = new ArrayList<>();\n        ArrayList<Dog> b = new ArrayList<>();\n        \n        Hello<String> x = new Hello<>();\n        \n        \n        \n        x.copyColl(a,b);\n        \n\n    } \n    public <G extends Animal> void copyColl(Collection<G> src, Collection<? extends G> dest){\n        \n        for(G n : src)\n            dest.add(n);\n        \n    }\n}','does not compile \n\nyou cant add to a collection declared with wildcard extends','Generics',1,NULL),(2995,'public class Hello<T> {\n    \n    public static void main(String[] args){\n        ArrayList<Dog> a = new ArrayList<>();\n        ArrayList<Dog> b = new ArrayList<>();\n        \n        Hello<String> x = new Hello<>();\n        \n        \n        \n        x.copyColl(a,b);\n        \n\n    } \n    public <G extends Animal> void copyColl(Collection<G> src, Collection<? super G> dest){\n        \n        for(G n : src)\n            dest.add(n);\n        \n    }\n}','compiles fine','Generics',1,NULL),(2996,'public class Hello<T> {\n    \n    public static void main(String[] args){\n        ArrayList<Animal> a = new ArrayList<>();\n        ArrayList<Dog> b = new ArrayList<>();\n        \n        Hello<String> x = new Hello<>();\n        \n        \n        \n        x.copyColl(a,b);\n        \n\n    } \n    public <G extends Animal> void copyColl(Collection<? extends G> src, Collection<? super G> dest){\n        \n        for(G n : src)\n            dest.add(n);\n        \n    }\n}','will not compiile at x.copyColl','Generics',1,NULL),(2997,'public class Hello<T> {\n    \n    public static void main(String[] args){\n        ArrayList<Beagle> a = new ArrayList<>();\n        ArrayList<Animal> b = new ArrayList<>();\n        \n        Hello<String> x = new Hello<>();\n        \n        \n        \n        x.copyColl(a,b);\n        \n\n    } \n    public <G extends Animal> void copyColl(Collection<? extends G> src, Collection<? super G> dest){\n        \n        for(G n : src)\n            dest.add(n);\n        \n    }\n}','compiles fine\n\nyou can easily take a beagle and add it to an Animal array','Generics',1,NULL),(2998,'','','blank',1,NULL),(2999,'','','blank',1,NULL),(3000,'','','blank',1,NULL),(3001,'','','blank',1,NULL),(3002,'','','blank',1,NULL),(3003,'public class Visit extends SimpleFileVisitor<Path> {\n\n	//insert here\n\n   public static void main(String[] args) throws Exception {\n	Visit v = new Visit();\n	Files.walkFileTree(Paths.get(\"/mydir\"),v);\n   }\n}\n\nwhat inserted here will print out the provided directory and all \nsubdirectories ?\n\n\n','public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs)\nthrows IOException {\n	sout( dir );\n	return FileVisitResult.CONTINUE;\n}\n\npublic FileVisitResult postVisitDirectory(Path dir, IOException e)\nthrows IOException {\n	sout( dir );\n	return FileVisitResult.CONTINUE;\n}\n\n**VisitFile is called only for Files and not directories','Input/Output',1,NULL),(3004,'','','blank',1,NULL),(3005,'','','blank',1,NULL),(3006,'class Bird {	\n	{ System.out.println(\"b1\"); }	\n	public Bird() { System.out.println(\"b2\"); }\n}\n\nclass Raptor extends Bird {\n	static {System.out.println(\"r1\"); }\n	public Raptor() { System.out.println(\"r2\"); }\n	{ System.out.println(\"r3\"); }\n	static { System.out.println(\"r4\"); }\n}\npublic class Hello extends Raptor {\n\n    public static void main(String[] args) {\n        System.out.println(\"pre \");\n        new Hello();\n        System.out.println(\"hawk\");\n    }\n}\n		','r1\nr4\npre \nb1\nb2\nr3\nr2\nhawk\n\nstatic init blocks run at class loading time. Instance init blocks run after\nthe constructors call to super()','OOP',1,NULL),(3007,'public static void makeFileCreatedOnMonday(Path d) throws IOException{\n        BasicFileAttributes ba = Files.readAttributes(d, BasicFileAttributes.class);\n        Calendar c = Calendar.getInstance();\n        //BasicFileAttributeView baView = Files.readAttributeView(d,BasicFileAttributes.class)\n        //BasicFileAttributeView baView = Files.getBasicAttributeView(d,BasicFileAttributes.class);\n        //BasicFileAttributeView baView = Files.getFileAttributeView(d,BasicFileAttributes.class);\n        //BasicFileAttributeView baView = Files.getFileAttributeView(d,BasicFileAttributeView.class);\n        \n	//void setTimes(FileTime lastModifiedTime,FileTime lastAccessTime,FileTime createTime)\n        \n        Date creationDate = new Date(ba.creationTime().toMillis());\n        c.setTime(creationDate);\n        \n        if(c.get(Calendar.DAY_OF_WEEK) == Calendar.MONDAY){\n            baView.setTimes(null,null,null);\n        } else {\n            //other fields are retained\n            c.set(Calendar.DAY_OF_WEEK,Calendar.MONDAY);\n            FileTime newDay = FileTime.fromMillis(c.getTimeInMillis());\n            \n            baView.setTimes(null,null,newDay);\n        }\n        \n    }\n\nHow do you create a FileAttributeView ?','BasicFileAttributeView baView = Files.getFileAttributeView(d,BasicFileAttributeView.class);','Strings',1,NULL),(3008,'','','blank',1,NULL),(3009,'psvm(SA){\n	List<Integer> list = new ArrayLIst<>();\n	list.add(5); //autoboxing\n	foo( list );\n}\n\nstatic void foo(List alist) {\n	alist.add(new Dog(\"Charly\"));\n}','compiles with warnings \n\nthe problems will arrise down the road when you get that dog out of a supposedly Integer array. ','Generics',1,NULL),(3010,'Generic type information does not exist at runtime - it is for compile-time safetly only.\nMixing generics with legacy code can create compiled code that may throw an excecption at runtime. ','','Generics',1,NULL),(3011,'polymorphic assingment rules apply everywhere an assignment can be made for generics,\n\nthe following are not allowed:\n	\n	void foo(List<Animal> alist {  }  //cannot take a List<Dog>\n\n	List<Animal> bar() {  }  // cannot return a List<Dog>','','Generics',1,NULL),(3012,'class Animal{\n    public void makeSound() throws InterruptedException {\n            System.out.println(\"Sound!\");\n    }\n}\nclass Dog extends Animal{\n    public void makeSound() throws InterruptedException {\n        System.out.println(\"Bark!\");\n        \n    }\n}\nclass BullDog extends Dog{\n    public void makeSound() throws InterruptedException {\n        System.out.println(\"Grumble!\");\n    }\n}','compiles fine','Generics',1,NULL),(3013,'class Animal{\n    public void makeSound() throws InterruptedException {\n            System.out.println(\"Sound!\");\n    }\n}\nclass Dog extends Animal{\n    public void makeSound(){\n        System.out.println(\"Bark!\");\n        \n    }\n}\nclass BullDog extends Dog{\n    public void makeSound() throws InterruptedException {\n        System.out.println(\"Grumble!\");\n    }\n}','BullDog does not compile, Dog\'s makeSound chose not to throw the exception but then when BullDog chose \nto override it didn\'t know that Animal used to throw that exception. ','General',1,NULL),(3014,'public class Hello<T> {\n    \n    public static void main(String[] args){\n      Hello<?> x = new Hello<>();\n      \n      List<?> readonlylist = x.dogs();\n      List<?> readonlyanimallist = x.animals();\n        \n\n    } \n    public ArrayList<Animal> animals(){\n        ArrayList<Animal> vetlist = new ArrayList<>();\n        vetlist.add(new Animal());\n        vetlist.add(new BullDog());\n        vetlist.add(new BullDog());\n        vetlist.add(new Dog());\n        vetlist.add(new Animal());\n        \n        return vetlist;\n  \n    }\n    \n    public ArrayList<Dog> dogs(){\n        ArrayList<Animal> vetlist = new ArrayList<>();\n        vetlist.add(new Dog());\n        vetlist.add(new BullDog());\n        vetlist.add(new BullDog());\n        vetlist.add(new Dog());\n        vetlist.add(new Dog());\n\n        return vetlist;\n    }','does not compile because you cannot return an Animal list from a method declaring a return statemnt\nof Dog list','Generics',1,NULL),(3015,'Wildcard syntax allows a generic method to accept subtypes or supertypes of the declared type\nof the method argument.\n\n	void addD(List<Dog> d) {  } //can take only <Dog>\n	\n	void addD(List<? extends Dog>) { } //take a <Dog> or <Beagle>','','Generics',1,NULL),(3016,'The wildcard keyword \'extends\' is used to mean either \" extends \" or \"implements\" \n\nso in <? extends Dog> Dog can be a class or interface. ','','Generics',1,NULL),(3017,'When using a wildcard List<? extends Dog>, the collection can be accessed but not modified','','Generics',1,NULL),(3018,'When using a wildcard List<?> any generic type can be assigned to the reference, but for access only\nno modifications.','','Generics',1,NULL),(3019,'List<Object> refers only to a List<Object>, while List<?> or List<? extends Object> can hold \nany type of object, but for access only. \n\n','','Generics',1,NULL),(3020,'The generic type identifier can be used in class, method, and variable declarations:\n\n	class Foo<t> { }\n	T anInstance;\n	Foo(T aRef) { } // a constructor argument\n	void bar(T aRef) {  }	//method argument\n	T baz() { }	//return type','got it ','Generics',1,NULL),(3021,'You can declare a generic method using a type not defined in the class:\n	\n	public <T> void makeList(T t) { }\n\n\n    This is not using T as a return type. This method has a void return type, but to use T within the argument you must declare the <T>\n	which happens before the return type. ','','Generics',1,NULL),(3022,'psvm(SA){\n	for(int i = 0; i<= 10; i++) {\n		List<Integer> row = new ArrayList<>();\n		for (int j = 0; j<= 10; j++)\n		         row.add(i*j);\n		table.add(row);\n	}\n	for(List<Integer> row : table)\n		sout(row);\n}\n\ndefine table','List<List<Integer>> table = new ArrayList<>();\n\nList<List<Integer>> table = new ArrayList<List<Integer>>();\n\n	not this:\n		List<List<Integer>> superlist1 = new ArrayList<ArrayList<Integer>>();\n\n	.... incompatible types','Generics',1,NULL),(3023,'Which statements are true about comparing two instances of the same class \ngiven that equals() and hashCode() have been properly overriden\n\n1 if the equals() returns true, the hashCode() comparison == might return false\n\n2 if the equals() returns false, the hashCode() comparison == might return true\n\n3 if the hashCode() comparison == returns true, the equals() method must return true\n\n4 if the hashCode() comparison == returns true, the equals() method might return true\n\n5 if the hashCode() comparison != returns true, the equals() method might return true','2 is true because often two dissiimilar objects can return the same hashcode value.\n\n4 is true because if the hashCode() comparison == returns true, might or might not be equal. \n\n3 is incorrect because often two dissimilar objects can return the same hashcode value. \n\n1 and 5 are a negation of the equals and hashCode() contract','Generics',1,NULL),(3024,'IF TWO OBJECTS ARE EQUAL ACCORDING TO THE EQUALS(OBJECT) METHOD, THE CALLING THE HASHCODE()\nMETHOD ON EACH OF THE TWO OBJECT MUST PRODUCE THE SAME INTEGER RESULT. ','got it\n','Generics',1,NULL),(3025,'It is not required that if two object are unequal according to the dquals method, the calling the hashCode()\non each of the two objects must produce distinct integer results. ','','Generics',1,NULL),(3026,'public static void before() {\n	Set set = new TreeSet();\n	set.add(\"2\");\n	set.add(3);\n	set.add(\"1);\n	Iterator it = set.iterator();\n		while(it.hasNext() )\n	sout( it.next() );\n}\n','ClassCastException','Generics',1,NULL),(3027,'interface Hungry<E> { void munch(E x); }\ninterface Carnivore<E extends Animal> extends Hungry<E> { }\ninterface Herbivore<E extends Plant> extends Hungry<E> { }\nabstract class Plant { }\nabstract class Animal { }\nclass Grass extends Plant { }\nclass Sheep extends Animal implements Herbivore<Sheep> {\n    public void munch (Sheep x){ }\n}\nclass Wolf extends Animal implements Carnivore<Sheep> {\n    public void munch(Sheep x) { }\n}\n\nwhat can you change to make this compile','Change Herbivore interface to\n	\n	 interface Herbivore<E extends Animal> extends Hungry<E> { }','Generics',1,NULL),(3028,'interface Hungry<E> { void munch(E x); }\ninterface Carnivore<E extends Animal> extends Hungry<E> { }\ninterface Herbivore<E extends Plant> extends Hungry<E> { }\nabstract class Plant { }\nabstract class Animal { }\nclass Grass extends Plant { }\nclass Sheep extends Animal implements Herbivore<Plant> {\n    public void munch (Sheep x){ }\n}\nclass Wolf extends Animal implements Carnivore<Sheep> {\n    public void munch(Sheep x) { }\n}','Sheep does not compile,\n\n	Sheep is not abstract and does not override abstract method munch(Plant) in Hungry','Generics',1,NULL),(3029,'public class Hello<T> {\n  public static void main(String[] args){\n      Sheep bella = new Sheep();\n      \n      bella.munch(new Grass());\n      \n  }\n      \n}\n\ninterface Hungry<E> { void munch(E x); }\ninterface Carnivore<E extends Animal> extends Hungry<E> { }\ninterface Herbivore<E extends Plant> extends Hungry<E> { }\nabstract class Plant { }\nabstract class Animal { }\nclass Grass extends Plant { }\nclass Sheep extends Animal implements Herbivore<Plant> {\n    public void munch (Plant x){ }\n}\nclass Wolf extends Animal implements Carnivore<Sheep> {\n    public void munch(Sheep x) { }\n}','compiles and runs no problem','Generics',1,NULL),(3030,'public class Hello<T> {\n\n   public static void main(String[] args){\n\n    Dog d = new Dog();\n\n    ArrayList<? super Beagle> c = makeArrayList(d);\n\n    c.add(new Beagle());\n    c.add(new Beagle());\n    c.add(new Dog());    \n  } \n\n  public static <G extends Animal> ArrayList<G> makeArrayList(G g){\n    ArrayList<G> genlist = new ArrayList<>();\n    genlist.add(g);\n    return genlist;\n\n }\n}\n\n\nclass Animal{public void makeSound(){\n        System.out.println(\"Sound!\");\n }\n}   \n class Dog extends Animal{}\nclass Beagle extends Dog{}','The variable c of type ArrayList<? super Beagle> could possibly hold an instance of \nArrayList<Beagle>, ArrayList<Dog>, ArrayList<Animal>, or ArrayList<Object>.\n If it happened to be set to an ArrayList<Beagle>, it would violate the generic type to add a Dog to it.\n The compiler can\'t track what you actually assign to the ArrayList<? super Beagle> variable over the course of the program, \nso it assumes the worst and prevents the possible type safety violation. ','Generics',1,NULL),(3031,'Let\'s test your understanding of generics. Is the following code snippet legal?\n\nList<String> ls = new ArrayList<String>(); // 1\nList<Object> lo = ls; // 2 \n\nLine 1 is certainly legal. The trickier part of the question is line 2. This boils down to the question: is a List of String a List of Object. Most people instinctively answer, \"Sure!\"\n\nWell, take a look at the next few lines:\n\nlo.add(new Object()); // 3\nString s = ls.get(0); // 4: Attempts to assign an Object to a String!\n\nHere we\'ve aliased ls and lo. Accessing ls, a list of String, through the alias lo, we can insert arbitrary objects into it. As a result ls does not hold just Strings anymore, and when we try and get something out of it, we get a rude surprise.\n\nThe Java compiler will prevent this from happening of course. Line 2 will cause a compile time error.\n\nIn general, if Foo is a subtype (subclass or subinterface) of Bar, and G is some generic type declaration, it is not the case that G<Foo> is a subtype of G<Bar>. This is probably the hardest thing you need to learn about generics, because it goes against our deeply held intuitions.\n\nWe should not assume that collections don\'t change. Our instinct may lead us to think of these things as immutable.','For example, if the department of motor vehicles supplies a list of drivers to the census bureau, this seems reasonable. We think that a List<Driver> is a List<Person>, assuming that Driver is a subtype of Person. In fact, what is being passed is a copy of the registry of drivers. Otherwise, the census bureau could add new people who are not drivers into the list, corrupting the DMV\'s records.','Generics',1,NULL),(3032,'static void fromArrayToCollection(Object[] a, Collection<?> c) {\n    for (Object o : a) { \n        c.add(o); // compile-time error\n    }\n}\n\nfix this with a generic method....','static <T> void fromArrayToCollection(T[] a, Collection<T> c) {\n    for (T o : a) {\n        c.add(o); // Correct\n    }\n}','Generics',1,NULL),(3033,'\n\nNo, a List<Dog> is not a List<Animal>. Consider what you can do with a List<Animal> - you can add any animal to it... including a cat. Now, can you logically add a cat to a litter of puppies? Absolutely not.\n\n// Illegal code - because otherwise life would be Bad\nList<Dog> dogs = new ArrayList<Dog>(); // ArrayList implements List\nList<Animal> animals = dogs; // Awooga awooga\nanimals.add(new Cat());\nDog dog = dogs.get(0); // This should be safe, right?\n\nSuddenly you have a very confused cat.\n\nNow, you can\'t add a Cat to a List<? extends Animal> because you don\'t know it\'s a List<Cat>. \nYou can retrieve a value and know that it will be an Animal, but you can\'t add arbitrary animals. \nThe reverse is true for List<? super Animal> - in that case you can add an Animal to it safely, but you don\'t know anything about what might be retrieved from it, because it could be a List<Object>.\n','','Generics',1,NULL),(3034,'public class Hello<T> {\n  public static void main(String[] args){\n      Sheep bella = new Sheep();\n      \n  }\n      \n}\n\ninterface Hungry<E> { void munch(E x); }\ninterface Carnivore<E extends Animal> extends Hungry<E> { }\ninterface Herbivore<Plant> extends Hungry<Plant> { }\nabstract class Plant { }\nabstract class Animal { }\nclass Grass extends Plant { }\nclass Sheep extends Animal implements Herbivore<Grass> {\n    public void munch (Grass x){ }\n}\nclass Wolf extends Animal implements Carnivore<Sheep> {\n    public void munch(Sheep x) { }\n}','compiles fine...\n\nHerbivore<Plant> extends Hungry<Plant> works because the type is a parameter just like the formal \nparameters. So it is not necessary that a subinterface has the same parameters as long as its indicated that\nit does in fact take a type parameter. \n\nIn a nutshell, generics enable types (classes and interfaces) to be parameters when defining classes, interfaces and methods. Much like the more familiar formal parameters used in method declarations, type parameters provide a way for you to re-use the same code with different inputs. The difference is that the inputs to formal parameters are values, while the inputs to type parameters are types.\n\nits the same reason why List<E>, an interface, has to be the same as = new ArrayList<E> but not the \nsame as all other Lists\n\nList<String> list = new ArrayList<String>();\n	\n	ArrayList implements List just like Herbivore extends Hungry.','Generics',1,NULL),(3035,'Raw Types\n\nA raw type is the name of a generic class or interface without any type arguments. For example, given the generic Box class:\n\npublic class Box<T> {\n    public void set(T t) { /* ... */ }\n    // ...\n}\n\nTo create a parameterized type of Box<T>, you supply an actual type argument for the formal type parameter T:\n\nBox<Integer> intBox = new Box<>();\n\nIf the actual type argument is omitted, you create a raw type of Box<T>:\n\nBox rawBox = new Box();\n\nTherefore, Box is the raw type of the generic type Box<T>. However, a non-generic class or interface type is not a raw type.\n\nRaw types show up in legacy code because lots of API classes (such as the Collections classes) were not generic prior to JDK 5.0. When using raw types, you essentially get pre-generics behavior — a Box gives you Objects. For backward compatibility, assigning a parameterized type to its raw type is allowed:\n\nBox<String> stringBox = new Box<>();\nBox rawBox = stringBox;               // OK\n\nBut if you assign a raw type to a parameterized type, you get a warning:\n\nBox rawBox = new Box();           // rawBox is a raw type of Box<T>\nBox<Integer> intBox = rawBox;     // warning: unchecked conversion\n\nYou also get a warning if you use a raw type to invoke generic methods defined in the corresponding generic type:\n\nBox<String> stringBox = new Box<>();\nBox rawBox = stringBox;\nrawBox.set(8);  // warning: unchecked invocation to set(T)\n\nThe warning shows that raw types bypass generic type checks, deferring the catch of unsafe code to runtime. Therefore, you should avoid using raw types.','','Generics',1,NULL),(3036,'class Driver<E>{\n    \n}\nabstract class Auto{}\nclass Truck extends Auto{}\nclass Car extends Auto{}\n\npublic class Hello<T> {\n  public static void main(String[] args){\n      Driver<Truck> truckdriver = new Driver<>();\n      Driver untypeddriver = truckdriver;\n      \n      List biglist = new ArrayList<String>();\n      \n  }\n      \n}','compiles fine \n\ngeneric typed objects can be assigned to raw types.','Generics',1,NULL),(3037,'public class Hello<T> {\n  public static void main(String[] args){\n      \n      List biglist = new ArrayList<String>();\n      \n      biglist.add(8);\n      biglist.add(\"bigdick\");\n      \n  }\n      \n}','compiles fine, raw type reerences that are assinged to typed objects still take objects.','Generics',1,NULL),(3038,'public class Hello<T> {\n  public static void main(String[] args){\n      Driver<Truck> truckdriver = new Driver<>();\n      Driver untypeddriver = truckdriver;\n      \n      List biglist = new ArrayList<Driver<Truck>>();\n      \n      biglist.add(8);\n      biglist.add(\"bigdick\");\n      \n  }\n      \n}','compiles fine,  but you can still add anything to biglist','Generics',1,NULL),(3039,'public class Hello {\n  public static void main(String[] args){\n      Driver<Truck> truckdriver = new Driver();\n      \n      testmethod(new Driver<Truck>());   \n  }\n  \n  public static void testmethod(Object x){\n      // do something\n  }\n      \n}','fine','Generics',1,NULL),(3040,'Generic Classes and Subtyping',' You can subtype a generic class or interface by extending or implementing it. The relationship between the type parameters of one class or interface and the type parameters of another are determined by the extends and implements clauses.\n\nUsing the Collections classes as an example, ArrayList<E> implements List<E>, and List<E> extends Collection<E>. So ArrayList<String> is a subtype of List<String>, which is a subtype of Collection<String>. So long as you do not vary the type argument, the subtyping relationship is preserved between the types.\ndiagram showing a sample collections hierarchy: ArrayList<String> is a subtype of List<String>, which is a subtype of Collection<String>.\nA sample Collections hierarchy\n\nNow imagine we want to define our own list interface, PayloadList, that associates an optional value of generic type P with each element. Its declaration might look like:\n\ninterface PayloadList<E,P> extends List<E> {\n  void setPayload(int index, P val);\n  ...\n}\n\nThe following parameterizations of PayloadList are subtypes of List<String>:\n\n    PayloadList<String,String>\n    PayloadList<String,Integer>\n    PayloadList<String,Exception>\n','Generics',1,NULL),(3041,'Generics, Inheritance, and Subtypes',' As you already know, it is possible to assign an object of one type to an object of another type provided that the types are compatible. For example, you can assign an Integer to an Object, since Object is one of Integer\'s supertypes:\n\nObject someObject = new Object();\nInteger someInteger = new Integer(10);\nsomeObject = someInteger;   // OK\n\nIn object-oriented terminology, this is called an \"is a\" relationship. Since an Integer is a kind of Object, the assignment is allowed. But Integer is also a kind of Number, so the following code is valid as well:\n\npublic void someMethod(Number n) { /* ... */ }\n\nsomeMethod(new Integer(10));   // OK\nsomeMethod(new Double(10.1));   // OK\n\nThe same is also true with generics. You can perform a generic type invocation, passing Number as its type argument, and any subsequent invocation of add will be allowed if the argument is compatible with Number:\n\nBox<Number> box = new Box<Number>();\nbox.add(new Integer(10));   // OK\nbox.add(new Double(10.1));  // OK\n\nNow consider the following method:\n\npublic void boxTest(Box<Number> n) { /* ... */ }\n\nWhat type of argument does it accept? By looking at its signature, you can see that it accepts a single argument whose type is Box<Number>. But what does that mean? Are you allowed to pass in Box<Integer> or Box<Double>, as you might expect? The answer is \"no\", because Box<Integer> and Box<Double> are not subtypes of Box<Number>.\n\nThis is a common misunderstanding when it comes to programming with generics, but it is an important concept to learn.\ndiagram showing that Box<Integer> is not a subtype of Box<Number>\nBox<Integer> is not a subtype of Box<Number> even though Integer is a subtype of Number.\nNote: Given two concrete types A and B (for example, Number and Integer), MyClass<A> has no relationship to MyClass<B>, regardless of whether or not A and B are related. The common parent of MyClass<A> and MyClass<B> is Object.','Generics',1,NULL),(3042,'List<? extends Integer> intList = new ArrayList<>();\nList<? extends Number>  numList = intList;  // OK. List<? extends Integer> is a subtype of List<? extends Number>','','Generics',1,NULL),(3043,'interface Hungry<E> { void munch(E x); }\ninterface Carnivore<E extends Animal> extends Hungry<E> { }\n\ninterface Herbivore<Plant> extends Hungry<Plant> { }\n\n\ninterface Pineavore<Pine> extends Herbivore<Plant> { }\n\n\n\nclass Panda implements Herbivore<Pine>{  \n    void munch(Pine x){\n            System.out.println(\"eat pines\");\n    };\n} \nclass Chamelion implements Herbivore<Flowers>{ \n    public void munch(Flowers x){ } \n}','compilation fails,\n\ninterface methods are implicityl public abstract so when you overid them like munch in Panda you have to say\npublic . ','Generics',1,NULL),(3044,'interface Hungry<E> { void munch(E x); }\n\nclass Driver<E> implements Hungry<T>{\n    public void munch(T food){\n        \n    }\n    \n}','will not compile, when you implement a generic interface, you must provide a type similarly you cannot say\nnew Thing<E>();','Generics',1,NULL),(3045,'interface Hungry<E> { void munch(E x); }\n\ninterface Herbivore<Grass> extends Hungry<Plant> { }\n\nclass Panda implements Herbivore<Grass>{  \n        public void munch(Grass x){\n            System.out.println(\"eat pines\");\n    };\n} \n\nabstract class Animal { }\nabstract class Plant { }\nclass Grass extends Plant { }','Panda does not compile \n\ndoes not override abstract method munch(Plant) in class Hungry.\n\n	','Generics',1,NULL),(3046,'Which collection class allows you to grow or shrink its size and provide indexed access to its elements,\nbut whose methods are not synhcronized ?','ArrayList','Generics',1,NULL),(3047,'public static <E extends Number> List<E> process(List<E> nums)\n\n// declare input and output\n\noutput = process(input);\n\n','1 ArrayList<Integer> input = null;\n   List<Integer> output = null;\n\n2 List<Number> input = null;\n    List<Number> output = null\n\n3  List<Integer> input = null\n   List<Integer> output = null;\n\n\nThe return type is List so the output has to be a list it cant be arraylist. \nwhatever the input is thats what the output will be so input and output have to be the same type\nand the type has to be something that extends Number','Generics',1,NULL),(3048,'public class Hello {\n  public static void main(String[] args){\n      PriorityQueue<String> pq = new PriorityQueue<String>();\n      pq.add(\"2\");\n      pq.add(\"4\");\n      System.out.println(pq.peek());\n      pq.offer(\"1\");\n      pq.add(\"3\");\n      pq.remove(\"1\");\n      System.out.println(pq.poll());\n      if(pq.remove(\"2\")) System.out.println(pq.poll());\n      System.out.println(pq.poll() + \" \" + pq.peek());\n  }\n   \n}','2\n2\n3 4\n\nfor the sake of the exam add and offer both add to naturally sorted collections \nso here the order becomes the natural order. \n\neven strings get sorted numerically.\n\n','Generics',1,NULL),(3049,'public class Hello {\n  public static void main(String[] args){\n      PriorityQueue<String> pq = new PriorityQueue<String>();\n      pq.add(\"2\");\n      pq.add(\"4\");\n\n      pq.offer(\"1\");\n      pq.add(\"3\");\n      \n      pq.add(\"2\");\n      pq.offer(\"5\");\n      \n      pq.add(\"67\");\n      pq.add(\"7\");\n      \n      for(String x : pq)\n          System.out.print(x+\" \");\n      \n      System.out.println(\"\");\n      \n      for(int x = 0; x <8; x++)\n          System.out.print(pq.poll()+\" \");\n\n  }\n   \n}','1 2 2 4 3 5 67 7 \n1 2 2 3 4 5 67 7\n\nString only looks at the first charater so 67 is the same as 6','Generics',1,NULL),(3050,'public class Hello {\n  public static void main(String[] args){\n      LinkedHashSet<Turtle> t = new LinkedHashSet<>();\n      t.add(new Turtle(1)); t.add( new Turtle(2)); t.add(new Turtle(1));\n      t.add(new Turtle(1)); t.add( new Turtle(2)); t.add(new Turtle(1));\n      t.add(new Turtle(1)); t.add(new Turtle(1)); t.add(new Turtle(1));\n      t.add(new Turtle(1)); t.add(new Turtle(1)); t.add(new Turtle(1));\n      \n      System.out.println(t.size());\n\n  }\n   \n}\n\ninterface Hungry<E> { void munch(E x); }\nabstract class Animal { }\nabstract class Plant { }\nclass Grass extends Plant { }\n\nclass Turtle {\n    int size;\n    public Turtle(int z){\n        size = z;\n    }\n    \n    public boolean equals(Object o){\n        return (this.size == ((Turtle)o).size);\n    }\n    \n    public int hashCode() { return size/5; }\n}','2\n\nthe size is two when hashCode is implementd this imp. will place all turtles with size 1 in the same bucket\n\nsize() counts the buckets.\n\nif hashCode was not implemented then every entry would go into its own bucket and the size would be\n12\n\n','Generics',1,NULL),(3051,'class Grass extends Plant { }\n\npublic class Hello {\n  public static void main(String[] args){\n     TreeSet<Grass> grassset = new TreeSet<>();\n     grassset.add(new Grass());\n\n  }\n   \n}','classcastexception','Generics',1,NULL),(3052,'public class GeoCache {\n	public static void main(String[ ]args) {\n		String[] s = {\"map\",\"pen\",\"marble\",\"key\"};\n		Othello o = new Othello();\n		Arrays.sort(s,o);\n		for(String s2: s) sout(s2+\" \");\n		sout( Arrays.binarySearch(s,\"map\");\n	}\n\n	static class Othello implements Comparator<String> {\n		public int compare(String a, String b) { return b.compareTo(a);l }\n	}\n}\n		','The output will contain a -1\n\n\"pen marble map key\" \n\n.binarySearch has to be invoked with the same Comparator that created it. \n	here it doesn\'t know how the array is sorted so it gives insertion point','Collections',1,NULL),(3053,'public class ArrayList<E> extends AbstractList<E>\n         implements List<E>, RandomAccess, Cloneable, java.io.Serializable {\n    ...\n    public Iterator<E> iterator() {\n         return new Itr();\n    }\n\n    private class Itr implements Iterator<E> {\n    ...\n    }\n\n    public ListIterator<E> listIterator() {\n         return new ListItr(0);\n    }\n\n    private class ListItr extends Itr implements ListIterator<E> {\n    ...\n    }\n}','One good usage of inner classes that comes into my mind is in java.util.ArrayList that hides its iterators implementations into private inner classes. You can\'t create them except by invoking iterator() or listIterator() on the list object.\n\nThis way the Iterator and ListIterator implementations for ArrayList are grouped with their related class and methods for enhanced readability (the implementations are pretty short), but hidden from others.\n\nThey can\'t be declared static as they need access to their enclosing instance object.','General',1,NULL),(3054,'public class Hello {\n    private int secretnum = 7;\n    \n  public static void main(String[] args){\n     Hello h = new Hello();\n     h.createInner();\n\n  }\n  \n  public void createInner(){\n      Hello.Inner a = new Hello.Inner();\n      a.foo(); a.seeOuter();\n  }\n  \n  \n  class Inner {\n      public void seeOuter(){\n          System.out.println(secretnum);\n      }\n      \n      void foo(){\n          System.out.println(\"Foo\");\n      }\n  }\n   \n}','foo 7\n\ncompiles fine, you need the outer classes reference for a regular inner class\n\nthe inner class can be created as such from within the enclosing class. \n\ncould also be Inner a = new Inner();','Inner Classes',1,NULL),(3055,'public class Hello {\n    private int secretnum = 7;\n    \n  public static void main(String[] args){\n     Hello h = new Hello();\n     h.createInner();\n\n  }\n  \n  public void createInner(){\n      Hello.Inner a = new Hello.Inner();\n      a.foo(); a.seeOuter();\n  }\n  \n  \n  class Inner {\n      private static int verysecret = 8;\n      \n      public void seeOuter(){\n          System.out.println(secretnum);\n      }\n      \n      void foo(){\n          System.out.println(\"Foo\");\n      }\n  }','WNC,\n\nNo static declarations are allowed in regular inner classes unless they \nare final.\n\nThe creation of a is legal though redundant, it could have been:\n\n	Inner a = new Inner();\n','Inner Classes',1,NULL),(3056,'public class Hello {\n    private int secretnum = 7;\n    \n  public static void main(String[] args){\n     Hello h = new Hello();\n     h.createInner();\n\n  }\n  \n  public void createInner(){\n      Hello.Inner a = new Hello.Inner();\n      a.foo(); a.seeOuter();\n  }\n  \n  \n  class Inner {\n      private static final int verysecret = 8;\n      \n      public void seeOuter(){\n          System.out.println(secretnum);\n      }\n      \n      void foo(){\n          System.out.println(\"Foo\");\n      }\n  }\n   \n}','compiles fine, if an inner class is going to have static member it has to be final','Inner Classes',1,NULL),(3057,'public class sequence {\n	psvm(sa){\n		ArrayList<String> list = new ArrayList<>();\n		list.add(\"apple\");\n		list.add(\"organe\");\n		list.add(\"plum\");\n		list.add(1,\"carrot\");\n		sout( list );\n	}\n}','apple carrot orange plum\n\nwith arraylist you can add(int index, object elemetn) to a specific index','Collections',1,NULL),(3058,'public class Hello {\n    private int secretnum = 7;\n    \n    public static void main(String[] args){\n        Inner in = new Inner();\n\n    }\n  \n     class Inner {\n        private static final int verysecret = 8;\n        void foo(){\n          System.out.println(\"Foo\");\n        } \n  }\n   \n}','will not compile,\n\ninner classes are the same as class instance variables so naturally you cannot access \nthem from a static context. ','Inner Classes',1,NULL),(3059,'public class Hello {\n    private int secretnum = 7;\n    \n    public static void main(String[] args){\n        Hello h = new Hello();\n        Hello.Inner in = h.new Inner();\n\n    }\n  \n     class Inner {\n        private static final int verysecret = 8;\n        void foo(){\n          System.out.println(\"Foo\");\n        } \n  }\n   \n}','compiles fine','Inner Classes',1,NULL),(3060,'public class Hello {\n    private int secretnum = 7;\n    private static Inner inner;\n    \n    public static void main(String[] args){\n        Hello h = new Hello();\n        Hello.Inner in = h.new Inner();\n        \n        Hello.Inner in2 = h.new Inner();\n        \n        Hello.Inner in3 = new Hello().new Inner();\n        \n        inner = h.new Inner();\n        \n        //Inner a = new Inner(); this would not work\n        \n\n    }\n    \n    public void instancemaker(){\n        Inner a = new Inner();\n        System.out.println(a.verysecret);\n    }\n  \n     class Inner {\n        private static final int verysecret = 8;\n        \n        public void Inner(int x){\n            \n        }\n        void foo(){\n          System.out.println(\"Foo\");\n        } \n  }\n   \n}','When instantiating from a static method You have to provide the Outer class name\n\nthe inner class is just a like an instance member. \n\nbut in the instance method its easy to create the inner class normally. \n\nits the same to create a new inner class in the static method as it is from another class.\n\n\nThis was one is also confusing because it has a mistakenly named method \nthat looks like a constructor. But its not. ','Inner Classes',1,NULL),(3061,'public class Hello {\n    private int secretnum = 7;\n    public static void main(String[] args) {}\n    class Inner {  private static final int verysecret = 8; }\n}\n\nclass Dog extends Hello.Inner {}\n\nchange this code so it compiles, and creates a class that extends Hello.Inner','public class Hello {\n    private int secretnum = 7;\n    public static void main(String[] args) {}\n    class Inner {  private static final int verysecret = 8; }\n}\n\nclass Dog extends Hello { class Innerdog extends Inner{ } }','Inner Classes',1,NULL),(3062,'public class Hello {\n    private int secretnum = 7;\n    public static void main(String[] args) {}\n    class Inner {  private static final int verysecret = 8; }\n}\n\nclass Dog extends Hello{ class Inner extends Inner { } }\n\nthis is illegal what could make it legal ?','class Dog extends Hello{ class Inner extends Hello.Inner { } }','Inner Classes',1,NULL),(3063,'public Iterator<String> iterator() {\n    return new Iterator<String>() {\n\n      private int index;\n\n      public boolean hasNext() {\n        return index < size();\n      }\n\n      public String next() {\n\n        if (hasNext()) {\n          return getToken(index++);\n        }\n        else {\n          throw new NoSuchElementException();\n        }\n      }\n\n      public void remove() {\n        throw new UnsupportedOperationException();\n      }\n\n    };\n  }','good example of an anonymous inner class from opennlp','Inner Classes',1,NULL),(3064,'public Iterator<String> iterator() {\n    return new Iterator<String>() {\n\n      private int index;\n\n      public boolean hasNext() {\n        return index < size();\n      }\n\n      public String next() {\n\n        if (hasNext()) {\n          return getToken(index++);\n        }\n        else {\n          throw new NoSuchElementException();\n        }\n      }\n\n      public void remove() {\n        throw new UnsupportedOperationException();\n      }\n\n    };\n  }','good example of anonymous inner class','Inner Classes',1,NULL),(3065,'public static Dictionary parseOneEntryPerLine(Reader in) throws IOException {\n    BufferedReader lineReader = new BufferedReader(in);\n\n    Dictionary dictionary = new Dictionary();\n\n    String line;\n\n    while ((line = lineReader.readLine()) != null) {\n      StringTokenizer whiteSpaceTokenizer = new StringTokenizer(line, \" \");\n\n      String[] tokens = new String[whiteSpaceTokenizer.countTokens()];\n\n      if (tokens.length > 0) {\n        int tokenIndex = 0;\n        while (whiteSpaceTokenizer.hasMoreTokens()) {\n          tokens[tokenIndex++] = whiteSpaceTokenizer.nextToken();\n        }\n\n        dictionary.put(new StringList(tokens));\n      }\n    }\n\n    return dictionary;\n  }','fine\ngood example of;\nStringTokenizer\nBufferedReader\n\n','General',1,NULL),(3066,'public static Dictionary parseOneEntryPerLine(Reader in)  {\n    BufferedReader lineReader = new BufferedReader(in);\n\n    Dictionary dictionary = new Dictionary();\n\n    String line;\n\n    while ((line = lineReader.readLine()) != null) {\n      StringTokenizer whiteSpaceTokenizer = new StringTokenizer(line, \" \");\n\n      String[] tokens = new String[whiteSpaceTokenizer.countTokens()];\n\n      if (tokens.length > 0) {\n        int tokenIndex = 0;\n        while (whiteSpaceTokenizer.hasMoreTokens()) {\n          tokens[tokenIndex++] = whiteSpaceTokenizer.nextToken();\n        }\n\n        dictionary.put(new StringList(tokens));\n      }\n    }\n\n    return dictionary;\n  }','will not compile \nreadLine() method throws IOException\n\nmust be caught or thrown!','Input/Output',1,NULL),(3067,'public class Hello {\n    private int secretnum = 7;\n    public static void main(String[] args) {\n        Map<Integer,String> hellomap = new HashMap();\n        hellomap.put(1,\"Bell\");\n        hellomap.put(3,\"Whistle\");\n        hellomap.put(5,\"Nic\");\n        \n        for(Entry<Integer,String> x : hellomap.entrySet()){\n            System.out.println(x);\n        }\n    \n    }\n    public class Inner {  private static final int verysecret = 8; }\n}','1=Bell\n3=Whistle\n5=Nic\n\ninner classes can have static members only if they are final','Inner Classes',1,NULL),(3068,'public class Hello {\n    private final static int SIZE = 25;\n    private int[] array = new int[SIZE];\n    \n    public Hello(){\n        for(int i = 0; i<SIZE; i++){\n            array[i] = i;\n        }\n    }\n    \n    public void printEven(){\n        \n    }\n    \n    interface DSIterator extends java.util.Iterator<Integer> { }\n    \n    private class EvenIterator implements DSIterator{\n        \n    }\n    \n\n    public static void main(String[] args) {\n\n    \n    }\n\n}','EvenIterator will not compile is not abstract and does not impelemnt next() in Iterator()\n\nThis shows that since DSIterator extends Iterator the first concrete class has to be the one to \nimplement the interfaces methods. ','General',1,NULL),(3069,'public class Hello {\n    private final static int SIZE = 100;\n    private int[] array = new int[SIZE];\n    \n    public Hello(){\n        for(int i = 0; i<SIZE; i++){\n            array[i] = i;\n        }\n    }\n    \n    public void print(){\n        ThirdIterator it = new ThirdIterator();\n        while(it.hasNext()){\n            System.out.print(it.next() +\" \");\n        }\n        \n    }\n    \n    interface DSIterator extends java.util.Iterator<Integer> { }\n    \n    private class ThirdIterator implements DSIterator{\n        private int nextIndex = 0;\n        \n        public boolean hasNext(){\n            return (nextIndex <= SIZE - 1);\n        }\n        \n        public Integer next(){\n            Integer retValue = Integer.valueOf(array[nextIndex]);\n            \n            nextIndex += 3;\n            return retValue;\n            \n        }\n        \n    }\n    \n\n    public static void main(String[] args) {\n        print();\n    \n    }\n\n}','will not compile print() cannot be called from a static context.','General',1,NULL),(3070,'public class Hello {\n    private final static int SIZE = 100;\n    private int[] array = new int[SIZE];\n    \n    public Hello(){\n        for(int i = 0; i<SIZE; i++){\n            array[i] = i;\n        }\n    }\n    \n    public void print(){\n        ThirdIterator it = new ThirdIterator();\n        while(it.hasNext()){\n            Object i = it.next();\n            //System.out.print(it.next() +\" \");\n        }\n        \n    }\n    \n    interface DSIterator extends java.util.Iterator { }\n    \n    private class ThirdIterator implements DSIterator{\n        private int nextIndex = 0;\n        \n        public boolean hasNext(){\n            return (nextIndex <= SIZE - 1);\n        }\n        \n        public Integer next(){\n            Integer retValue = Integer.valueOf(array[nextIndex]);\n            \n            nextIndex += 3;\n            return retValue;\n            \n        }\n        \n    }\n    \n\n    public static void main(String[] args) {\n        Hello h = new Hello();\n        h.print();\n    \n    }\n\n}','0 3 6 9 12 15 18 21 24 27 30 33 36 39 42 45 48 51 54 57 60 63 66 69 72 75 78 81 84 87 90 93 96 99','General',1,NULL),(3071,'public class Hello {\n    private final static int SIZE;\n    private int[] array;\n    \n    public Hello(int size){\n        this.SIZE = size;\n        \n        array = new int[SIZE];\n        \n        for(int i = 0; i<SIZE; i++){\n            array[i] = i;\n        }\n    }\n}','if a final variable is static it has be intitialized right away.\n\nWhere a final instance varialbe must be intitialized at some point either in the constructor or upon creation.\n\n','General',1,NULL),(3072,'public class Hello {\n    private final int SIZE;\n    private int[] array;\n    \n    public void print(){\n        ThirdIterator it = new ThirdIterator();\n        while(it.hasNext()){\n            Integer i = it.next();\n            //System.out.print(it.next() +\" \");\n        }\n        \n    }\n\n}','Will not compile \n\nfinal variable SIZE is never initialized in default constructor or otherwise and this is a compilererror','General',1,NULL),(3073,'public class Hello {\n    private final int SIZE;\n    private int[] array;\n    \n    interface DSIterator extends java.util.Iterator<Integer> { }\n    \n    private class ThirdIterator implements DSIterator{\n        private int nextIndex = 0;\n        public ThirdIterator(){\n            SIZE = 100;\n            for(int ix=0; ix<SIZE; ix++){\n                array[ix] = ix;\n            }\n        }\n        \n        public boolean hasNext(){\n            return (nextIndex <= SIZE - 1);\n        }\n        \n        public Integer next(){\n            Integer retValue = Integer.valueOf(array[nextIndex]);\n            \n            nextIndex += 3;\n            return retValue;\n            \n        }\n        \n    }\n    \n    private static class EveryFourth implements DSIterator{\n        private int nextIndex = 0;\n        private static final int SIZE = 1000;\n        private int[] array = new int[SIZE];\n        \n        public EveryFourth(){\n           for(int i =0; i<100; i++){\n               array[i] = i;\n           }\n        }\n        \n        public boolean hasNext(){\n            return (nextIndex <= SIZE-1);\n        }\n        \n        public Integer next() {\n            Integer retValue = Integer.valueOf(array[nextIndex]);\n            \n            nextIndex += 4;\n            return retValue;\n        }\n    }\n    \n\n    public static void main(String[] args) {\n        EveryFourth a = new EveryFourth();\n        ThirdIterator b = new ThirdIterator();\n        \n    \n    }\n\n}\n\nThere multiple problems here','final Variable SIZE in Hello is not intitialized in constructor \n\ncannot assign a value to final variable SIZE in innerclass ThirdIterator\n\nnon static third iterator class cannot be referenced from static main.\n\n','Inner Classes',1,NULL),(3074,'public class Hello {\n    private final int SIZE;\n    private int[] array;\n    \n    public Hello(){\n        ThirdIterator x = new ThirdIterator();\n    }\n    \n    interface DSIterator extends java.util.Iterator<Integer> { }\n    \n    private class ThirdIterator implements DSIterator{\n        private int nextIndex = 0;\n        public ThirdIterator(){\n            SIZE = 100;\n            for(int ix=0; ix<SIZE; ix++){\n                array[ix] = ix;\n            }\n        }\n......\n.........','you cant do this either\nfinal variable SIZE is not instantiated on creation or in the \nconstructor. Even though it is in the ThirdIterator class\nconstructor. that does not work. ','Inner Classes',1,NULL),(3075,'public class Hello {\n    private final int SIZE = 100;\n    private int[] array;\n\n    interface DSIterator extends java.util.Iterator<Integer> { }\n    \n    private class ThirdIterator implements DSIterator{\n        private int nextIndex = 0;\n        public ThirdIterator(){\n            for(int ix=0; ix<SIZE; ix++){\n                array[ix] = ix;\n            }\n        }  \n        public boolean hasNext(){\n            return (nextIndex <= SIZE - 1);\n        }\n        public Integer next(){\n            Integer retValue = Integer.valueOf(array[nextIndex]); \n            nextIndex += 3;\n            return retValue;    \n        }\n    }\n    private static class EveryFourth implements DSIterator{\n        private int nextIndex = 0;\n        private static final int SIZE = 1000;\n        private int[] array = new int[SIZE];\n        public EveryFourth(){\n           for(int i =0; i<100; i++){\n               array[i] = i;\n           }\n        }\n        public boolean hasNext(){\n            return (nextIndex <= SIZE-1);\n        }\n        \n        public Integer next() {\n            Integer retValue = Integer.valueOf(array[nextIndex]);\n            \n            nextIndex += 4;\n            return retValue;\n        }\n    }\n    public static void main(String[] args) {\n        EveryFourth a = new EveryFourth();\n        Hello.ThirdIterator b = new Hello().new ThirdIterator();\n    }\n\n}','compiles fine','Inner Classes',1,NULL),(3076,'public class Hello {\n    private final int SIZE = 100;\n    private int[] array;\n\n    \n    static interface DSIterator extends java.util.Iterator<Integer> { }\n    \n    private class ThirdIterator implements DSIterator{\n        private int nextIndex = 0;\n        public ThirdIterator(){\n            for(int ix=0; ix<SIZE; ix++){\n                array[ix] = ix;\n            }\n        }\n        \n        public boolean hasNext(){\n            return (nextIndex <= SIZE - 1);\n        }\n        \n     ......','A nested interface declared static is redundant. A nested interface is automatically static. \nstatic can be removed without and affect on semantics. Similar to public on interface methods \nor public final on interface fields. \n\nIt doen\'t change the fact that code without access to Foo wont have access to Foo.Bar interface.\n\nIt is acceptable to use if you excpect it only to be used from the enclosing class\n\npublic class Foo {\n	public interface Bar {\n		void callback();\n	}\n	public static void registerCallback(Bar bar){...}\n}\n//elsewhere\nFoo.registerCallback(new Foo.Bar() {\n	public void callback() {...}\n});','Inner Classes',1,NULL),(3077,'public class Hello {\n    private final int SIZE = 100;\n    private int[] array;\n\n    \n    interface DSIterator extends java.util.Iterator<Integer> { }\n    \n    interface Petable {\n        void speak();\n        void wag();\n    }\n    \n    private class ThirdIterator implements DSIterator{\n        private int nextIndex = 0;\n        public ThirdIterator(){\n            for(int ix=0; ix<SIZE; ix++){\n                array[ix] = ix;\n            }\n        }\n        \n        public boolean hasNext(){\n            return (nextIndex <= SIZE - 1);\n        }\n        \n        public Integer next(){\n            Integer retValue = Integer.valueOf(array[nextIndex]);\n            \n            nextIndex += 3;\n            return retValue;\n            \n        }\n        \n    }\n    \n    private static class EveryFourth implements DSIterator{\n        private int nextIndex = 0;\n        private static final int SIZE = 1000;\n        private int[] array = new int[SIZE];\n        \n        public EveryFourth(){\n           for(int i =0; i<100; i++){\n               array[i] = i;\n           }\n        }\n        \n        public boolean hasNext(){\n            return (nextIndex <= SIZE-1);\n        }\n        \n        public Integer next() {\n            Integer retValue = Integer.valueOf(array[nextIndex]);\n            \n            nextIndex += 4;\n            return retValue;\n        }\n    }\n    \n\n    public static void main(String[] args) {\n        \n        EveryFourth a = new EveryFourth();\n        Hello.ThirdIterator b = new Hello().new ThirdIterator();\n        \n    \n    }\n\n}\n\nclass Dog implements Petable {\n    \n    public void bark(){\n        \n    }\n\n    @Override\n    public void speak() {\n        throw new UnsupportedOperationException(\"Not supported yet.\"); //To change body of generated methods, choose Tools | Templates.\n    }\n\n    @Override\n    public void wag() {\n        throw new UnsupportedOperationException(\"Not supported yet.\"); //To change body of generated methods, choose Tools | Templates.\n    }\n    \n}','does not compile without outer reference for inner interface.\n\nshould be:\n\n	class Dog implements Hello.Petable {\n    \n ','Inner Classes',1,NULL),(3078,'class MyOuter{\n	private int x = 7;\n\n	class MyInner{\n	public void seeOuter(){\n		sout( x );\n	}\n\n}\n\nclass OCP{\n	public static void main(SA){\n		MyOuter mo = new MyOuter();\n		MYOuter.MyInner inner = mo.new MyInner();\n		inner.seeOuter();\n	}\n}','how to instantiate an inner class object from outside the outter class instance code.','Inner Classes',1,NULL),(3079,'psvm(SA){\n	MyOuter.MyInner inner = new MyOuter().new MyInner();\n	inner.seeOuter();\n}','one liner','Inner Classes',1,NULL),(3080,'class MyOuter{\n    private int x = 7;\n    public void makeInner() {\n        MyInner in = new MyInner();\n       in.seeOuter();\n   }\n\n    class MyInner {	\n           public void seeOuter {\n	sout( \"Outer x is \" + x );\n	sout(\"Inner class ref is \" + this);\n	sout( \"Outer class ref is \" + MyOuter.this );\n            }\n}\n\n      psvm(sa) {\n	MyOuter.MyInner inner = new MyOuter().new MyInner();\n	inner.seeOuter();\n     }\n}\n		','\n	The rules for an inner class to reference itself or the outer class instance are as follows:\n\n	To reference the inner class instance itself from within the inner class code,\n		use this\n\n	toreference the \"outer this\" from within the inner class code,\n		use MyOuter.this.','Inner Classes',1,NULL),(3081,'what member modifiers can be applied to an inner class	','final\nabstract\npublic \nprivate\nprotected\nstatic\nstrictfp','Inner Classes',1,NULL),(3082,'class MyOuter2 {\n	private String x = \"Outer2\";\n	void doStuff() {\n	        class MyInner {\n		public void seeOuter() {\n	                               sout(\" outer x is \" + x );\n		}\n	        }\n	\n	MyInner mi = new MyInner(); // THIS LINE MUST COME AFTER THE CLASS\n\n	mi.seeOuter();\n	}\n}\n\n	','How to properly use a method local inner class','Inner Classes',1,NULL),(3083,'public class Hello {\n   \n    public static void main(String[] args) {\n        Hello h = new Hello();\n        h.methodlocal();\n    }\n    \n    public void methodlocal(){\n        \n        class WayInner {\n            private int size;\n        \n            public WayInner(int x){ size = x;}\n            public void printDetail(){\n                System.out.println(\"WayInner: \"+ size);\n            }\n        }\n        \n        WayInner a = new WayInner(7);\n        a.printDetail();\n    }\n\n}','WayInner: 7\n\nthe proper way to use a method local inner ','Inner Classes',1,NULL),(3084,'public class Hello {\n   \n    public static void main(String[] args) {\n        Hello h = new Hello();\n        h.methodlocal();\n    }\n    \n    public void methodlocal(){\n        int y = 56;\n        \n        class WayInner {\n            public int size;\n        \n            public WayInner(int x){ size = x;}\n            public void printDetail(){\n                System.out.println(\"WayInner: \"+ size);\n            }\n            \n            public void showall(){\n                System.out.println(size+\" \"+y);\n            }\n        }\n        \n        WayInner a = new WayInner(7);\n        a.printDetail();\n        a.showall();\n        \n    }\n\n}','will not compile in java 7. \n\nlocal varialbe cannot be accesed from within inner class. \n\nLocal varialbe exist on the stack and only exist for the lifetime of the method. \n\nwhen the method ends the local varialbes are destroyed, however the inner class object might still live on\n ','Inner Classes',1,NULL),(3085,'public class Hello {\n   \n    public static void main(String[] args) {\n        Hello h = new Hello();\n        h.methodlocal();\n    }\n    \n    public void methodlocal(){\n        final int y = 56;\n        \n        class Zombie {\n            public int size;\n        \n            public Zombie(int x){ size = x;}\n            public void mone(){\n                System.out.println(\"ughhhg: \"+ size);\n            }\n            \n            public void accessTheLiving(){\n                System.out.println(\"local var: \"+y);\n            }\n            \n        }\n        \n        Zombie zom = new Zombie(7);\n        \n    }\n\n}','will compile method local inner class can only access local variables if they are marked final.','Inner Classes',1,NULL),(3086,'public class Hello {\n   \n    public static void main(String[] args) {\n        Hello h = new Hello();\n        h.methodlocal();\n    }\n    \n    public void methodlocal(){\n        final int y = 56;\n        \n        protected class Zombie {\n            public int size;\n        \n            public Zombie(int x){ size = x;}\n            public void mone(){\n                System.out.println(\"ughhhg: \"+ size);\n            }\n            \n            public void accessTheLiving(){\n                System.out.println(\"local var: \"+y);\n            }\n            \n        }\n        \n        Zombie zom = new Zombie(7);\n        \n    }\n\n}','will not compile method local inner classes cannot be marked public private protected static or transient.','Inner Classes',1,NULL),(3087,'public class Hello {\n   \n    public static void main(String[] args) {\n        Hello h = new Hello();\n        h.methodlocal();\n    }\n    \n    public void methodlocal(){\n        final int y = 56;\n        \n        static class Zombie {\n            public int size;\n        \n            public Zombie(int x){ size = x;}\n            public void mone(){\n                System.out.println(\"ughhhg: \"+ size);\n            }\n            \n            public void accessTheLiving(){\n                System.out.println(\"local var: \"+y);\n            }\n            \n        }\n        \n        Zombie zom = new Zombie(7);\n        \n    }\n\n}','will not compile ML inner class cannot be marked static. ','Inner Classes',1,NULL),(3088,'public class Hello {\n   \n    public static void main(String[] args) {\n        Hello h = new Hello();\n        h.methodlocal();\n    }\n    \n    public void methodlocal(){\n        final int y = 56;\n        \n        class Zombie {\n            public int size;\n        \n            public Zombie(int x){ size = x;}\n            public static void mone(){\n                System.out.println(\"ughhhg: \"+ size);\n            }\n            \n            public void accessTheLiving(){\n                System.out.println(\"local var: \"+y);\n            }\n            \n        }\n        \n        Zombie zom = new Zombie(7);\n        \n    }\n\n}','will not compile \n\nillegal static declaration in method local inner class. ','Inner Classes',1,NULL),(3089,'public class Hello {\n   \n    public static void main(String[] args) {\n        Hello h = new Hello();\n        h.methodlocal();\n    }\n    \n    public void methodlocal(){\n        final int y = 56;\n        \n        \n        class Zombie {\n            public int size;\n            public static int num = 5;\n        \n            public Zombie(int x){ size = x;}\n            public void mone(){\n                System.out.println(\"ughhhg: \"+ size);\n            }\n            \n            public void accessTheLiving(){\n                System.out.println(\"local var: \"+y);\n            }\n            \n        }\n        \n        Zombie zom = new Zombie(7);\n        \n    }\n\n}','will not compile\n\nillegal modifier static is only allowed in constant decalartations. \n\nto compile make num final','Inner Classes',1,NULL),(3090,'public class Hello {\n   \n    public static void main(String[] args) {\n        Hello h = new Hello();\n        h.methodlocal();\n    }\n    \n    public void methodlocal(){\n        final int y = 56;\n        \n        \n        class Zombie {\n            public int size;\n            public static final int num = 5;\n        \n            public Zombie(int x){ size = x;}\n            public void mone(){\n                System.out.println(\"ughhhg: \"+ size);\n            }\n            \n            public void accessTheLiving(){\n                System.out.println(\"local var: \"+y);\n            }\n            \n        }\n        \n        Zombie zom = new Zombie(7);\n        \n    }\n\n}','compiles fine.\n\nto use static in an inner class it must be marked final','Inner Classes',1,NULL),(3091,'For inner classes \'static\' is only allowed for constant variable declarations. ','','Inner Classes',1,NULL),(3092,'public class Hello {\n   \n    public static void main(String[] args) {\n        Hello h = new Hello();\n        h.methodlocal();\n    }\n    \n    public static void methodlocal(){\n        final int y = 56;\n        \n        \n        class Zombie {\n            public int size;\n            public static final int num = 5;\n        \n            public Zombie(int x){ size = x;}\n            public static final void mone(){\n                System.out.println(\"ughhhg: \"+ size);\n            }\n            \n            public void accessTheLiving(){\n                System.out.println(\"local var: \"+y);\n            }\n            \n        }\n        \n        Zombie zom = new Zombie(7);\n        \n    }\n\n}','does not compile, \n\neven if the method is static ML innner class cannot decalre staic unless it is a static final constant. ','Inner Classes',1,NULL),(3093,'public class Hello {\n    private String name = \"marco\";\n    private final static String gem = \"Gemini\";\n    private static String west = \"Eunech\";\n   \n    public static void main(String[] args) {\n        Hello h = new Hello();\n        h.methodlocal();\n    }\n    \n    public static void methodlocal(){\n        final int y = 56;\n        //System.out.println(name); //wouldnt compile\n        System.out.println(gem);\n        \n        \n        class Zombie {\n            public int size;\n            public static final int num = 5;\n        \n            public Zombie(int x){ size = x; System.out.println(gem); System.out.println(west); System.out.println(name); }\n            public void mone(){\n                System.out.println(\"ughhhg: \"+ size);\n            }\n            \n            public void accessTheLiving(){\n                System.out.println(\"local var: \"+y);\n            }\n            \n        }\n        \n        Zombie zom = new Zombie(7);\n        \n    }\n\n}','does not compile\n\na MLIC declared in a static method cannot access instance varialbes of the outerclass. \n\nso\n sout(name) does not compile here. \n\nit can however access those static variables, if it was just the statics \nit would print:\n\n	Gemini\n	Gemini\n	Eunech','Inner Classes',1,NULL),(3094,'public class Hello {\n    private String name = \"marco\";\n    private final static String gem = \"Gemini\";\n    private static String west = \"Eunech\";\n   \n    public static void main(String[] args) {\n        Hello h = new Hello();\n        h.methodlocal();\n    }\n    \n    public void methodlocal(){\n        final int y = 56;\n        //System.out.println(name); //wouldnt compile\n        System.out.println(gem);\n        \n        \n        class Zombie {\n            public int size;\n            public static final int num = 5;\n        \n            public Zombie(int x){ size = x; System.out.println(gem); System.out.println(west); System.out.println(name); }\n            public void mone(){\n                System.out.println(\"ughhhg: \"+ size);\n            }\n            \n            public void accessTheLiving(){\n                System.out.println(\"local var: \"+y);\n            }\n            \n        }\n        \n        Zombie zom = new Zombie(7);\n        \n    }\n\n}','this compiles fine \nMLIC in a instance method can access both static and instance variables','Inner Classes',1,NULL),(3095,'class Horse extends Animal {\n        void buck() { }\n}\n\nclass Animal {\n        void eat() { }\n}\nclass Test {\n        public static void main(String[] atrgs) {\n	Animal h = new Horse();\n	h.eat();\n	h.buck();\n       }\n}	','h.buck() will not compile because you can only call the superclasses methods on a polymorphic reference','Inner Classes',1,NULL),(3096,'public class Hello {\n   \n    public static void main(String[] args) {\n        Biggie smalls = new Biggie(){\n            public void getLoot(){\n                System.out.println(\"Gimmie the loot!\");\n            }\n            \n        };\n        \n        smalls.actFly();\n        smalls.getLoot();\n        \n      \n    }\n\n}\n\nclass Biggie {\n    public void actFly(){\n        System.out.println(\"Shit so fly\");\n    }\n    public static void getPaid(){\n        System.out.println(\"Its so easy!\");\n    }\n    public int getFemaleDigits(){\n        return 5556784;\n    }\n}','here smalls.actFly() compiles \n\nhowever, getLoot() is defined in the anonyous subclass so polynorphically it cannot compile.\n\nThe only way to use methods declared in the anonymous subclass is to override methods of \nthe super class where overriding rules still apply. ','Inner Classes',1,NULL),(3097,'public class Hello {\n   \n    public static void main(String[] args) {\n        Biggie smalls = new Biggie(){\n            private void getLoot(){\n                System.out.println(\"Gimmie the loot!\");\n            }\n            \n            public void actFly(){\n                System.out.println(\"Still acting fly\");\n            }\n            \n        };\n        \n        smalls.actFly();\n        smalls.actFly();\n    }\n\n}\n\nclass Biggie {\n    public void actFly(){\n        System.out.println(\"Shit so fly\");\n    }\n    public static void getPaid(){\n        System.out.println(\"Its so easy!\");\n    }\n    public int getFemaleDigits(){\n        return 5556784;\n    }\n}','proper override','Inner Classes',1,NULL),(3098,'public class Hello {\n   \n    public static void main(String[] args) {\n        Biggie smalls = new Biggie(){\n            private void getLoot(){\n                System.out.println(\"Gimmie the loot!\");\n            }\n            \n            public int actFly(){\n                int x = 66;\n                System.out.println(\"Still acting fly\");\n                return x;\n            }\n            \n        };\n        \n        smalls.actFly();\n        smalls.actFly();\n    }\n\n}\n\nclass Biggie {\n    public void actFly(){\n        System.out.println(\"Shit so fly\");\n    }\n    public static void getPaid(){\n        System.out.println(\"Its so easy!\");\n    }\n    public int getFemaleDigits(){\n        return 5556784;\n    }\n}','will not compile override methods cannot return a different type unless its a subtype','Inner Classes',1,NULL),(3099,'public class Hello {\n   \n    public static void main(String[] args) {\n        Biggie smalls = new Biggie(){\n            private void getLoot(){\n                System.out.println(\"Gimmie the loot!\");\n            }\n            \n            public void actFly(){\n                System.out.println(\"Still acting fly\");\n            }\n            \n            public Integer getFemalDigits(){\n                return 5671123;\n            }  \n        };\n        \n        smalls.actFly();\n        smalls.actFly();\n    }\n\n}\n\nclass Biggie {\n    protected void actFly(){\n        System.out.println(\"Shit so fly\");\n    }\n    public static void getPaid(){\n        System.out.println(\"Its so easy!\");\n    }\n    public Number getFemaleDigits(){\n        return 5556784;\n    }\n}','this will compile just fine. \n\nan override method is allowed to have less reestricted access but not more,\n\nan override method must have the same return type or it can return a subclass. ','Inner Classes',1,NULL),(3100,'public class Hello {\n   \n    public static void main(String[] args) {\n        Biggie smalls = new Biggie(){\n            private void getLoot(){\n                System.out.println(\"Gimmie the loot!\");\n            }\n            \n            public void actFly(){\n                System.out.println(\"Still acting fly\");\n            }\n            \n            public Integer getFemalDigits(){\n                return 5671123;\n            }  \n            \n            public void getPaid(){\n                System.out.println(\"Boy I get money!\");\n            }\n        };\n        \n        smalls.actFly();\n        smalls.actFly();\n    }\n\n}\n\nclass Biggie {\n    protected void actFly(){\n        System.out.println(\"Shit so fly\");\n    }\n    public static void getPaid(){\n        System.out.println(\"Its so easy!\");\n    }\n    public Number getFemaleDigits(){\n        return 5556784;\n    }\n}','will not compile, \n\nyou cannot override a method marked static. \n\nThe only way you could make this work is by making getPaid in the anonymous\nclass static which would \'hide\' the superclass static method not override it.\n\nunfortuanlytel you cannot put a static method in an anonymous class. \n\n\n\nOver-riding basically supports late binding . Therefore, which method will be called is decided at run time.It is for non-static methods. Hiding is for all other members (static methods , instance members, static members). It is based on the early binding . More clearly , the method or member to be called or used is decided during compile time.\n\nIn your example, the first call , Animal.testClassMethod() is a call to a static method,hence, it is pretty sure as to which method is going to be called.\n\nIn the second call,myAnimal.testInstanceMethod(), it calls a non-static method. It is what you call run-time polymorphism. It is not decided until run time which method is to be called.\n\nFor further clarification, read this.\n','Inner Classes',1,NULL),(3101,'public class Hello {\n   \n    public static void main(String[] args) {\n        Biggie smalls = new Biggie(){\n            private void getLoot(){\n                System.out.println(\"Gimmie the loot!\");\n            }\n            \n            public void actFly(){\n                System.out.println(\"Still acting fly\");\n            }\n            \n            public Integer getFemalDigits(){\n                return 5671123;\n            }  \n            \n            public static void getPaid(){\n                System.out.println(\"Boy I get money!\");\n            }\n        };\n        \n        smalls.actFly();\n        smalls.actFly();\n    }\n\n}\n\nclass Biggie {\n    protected void actFly(){\n        System.out.println(\"Shit so fly\");\n    }\n    public static void getPaid(){\n        System.out.println(\"Its so easy!\");\n    }\n    public Number getFemaleDigits(){\n        return 5556784;\n    }\n}','Will not compile\n\nstatic definitions not allowed in inner classes except for constant varaible definintions. ','Inner Classes',1,NULL),(3102,'class Biggie {\n    public static int thashitt = 568;\n    protected void actFly(){\n        System.out.println(\"Shit so fly\");\n    }\n    public static void getPaid(){\n        System.out.println(\"Its so easy!\");\n    }\n    public Number getFemaleDigits(){\n        return 5556784;\n    }\n}\n\nclass Benzino extends Biggie{\n    \n    public void printThaShitt(){\n        System.out.println(thashitt);\n    }\n    \n    public static void getPaid(){\n        System.out.println(\"It\'s somewhat difficult\");\n    }\n    \n    public Integer getFemaleDigits(){\n        return null;\n    }\n    \n}','this compiles fine,\n\n','Inner Classes',1,NULL),(3103,'public class Hello {\n   \n    public static void main(String[] args) {\n        Biggie smalls = new Biggie(){\n            private void getLoot(){\n                System.out.println(\"Gimmie the loot!\");\n            }\n            \n            public void actFly(){\n                System.out.println(\"Still acting fly\");\n            }\n            \n            public Integer getFemaleDigits(){\n                return 5671123;\n            }  \n\n        };\n        \n        smalls.actFly();\n        System.out.println(smalls.getFemaleDigits());\n        \n        Biggie benz = new Benzino();\n        benz.getPaid();\n    }\n\n}\n\nclass Biggie {\n    public static int thashitt = 568;\n    protected void actFly(){\n        System.out.println(\"Shit so fly\");\n    }\n    public static void getPaid(){\n        System.out.println(\"Its so easy!\");\n    }\n    public Number getFemaleDigits(){\n        return 5556784;\n    }\n}\n\nclass Benzino extends Biggie{\n    \n    public void printThaShitt(){\n        System.out.println(thashitt);\n    }\n    \n    public static void getPaid(){\n        System.out.println(\"It\'s somewhat difficult\");\n    }\n    \n    public Integer getFemaleDigits(){\n        return null;\n    }\n    \n}','Still acting fly\n5671123\nIts so easy!\n\nthe reference smalls is of type anonymous class so its methods are theoverriden methods in the anonymous \nclass\n\nwhen getPaid() is called on benz you are accessing a static method from a reference variable, so \nthe Biggie version is used because thats the type of the reference variable, \n\nstatic methods cannot be overridden but they can be hidden. ','Inner Classes',1,NULL),(3104,'public class Hello {\n   \n    public static void main(String[] args) {\n        Biggie smalls = new Biggie(){\n            private void getLoot(){\n                System.out.println(\"Gimmie the loot!\");\n            }\n            \n            public void actFly(){\n                System.out.println(\"Still acting fly\");\n            }\n            \n            public Integer getFemaleDigits(){\n                return 5671123;\n            }  \n\n        };\n        \n        smalls.actFly();\n        System.out.println(smalls.getFemaleDigits());\n        \n        Benzino benz = new Benzino();\n        benz.getPaid();\n    }\n\n}\n\nclass Biggie {\n    public static int thashitt = 568;\n    protected void actFly(){\n        System.out.println(\"Shit so fly\");\n    }\n    public static void getPaid(){\n        System.out.println(\"Its so easy!\");\n    }\n    public Number getFemaleDigits(){\n        return 5556784;\n    }\n}\n\nclass Benzino extends Biggie{\n    \n    public void printThaShitt(){\n        System.out.println(thashitt);\n    }\n    \n    public static void getPaid(){\n        System.out.println(\"It\'s somewhat difficult\");\n    }\n    \n    public Integer getFemaleDigits(){\n        return null;\n    }\n    \n}','Still acting fly\n5671123\nIt\'s somewhat difficult','Inner Classes',1,NULL),(3105,'class Popcorn {\n	public void pop(){\n		sout(\"popcorn\");\n	}\n}\n\nclass Food {\n	Popcorn p = new Popcorn() {\n		public void sizzle(){\n			sout(\"anonymouse sizzling popcorn\");\n		}\n\n		public void pop(){\n			sout(\"anonumous popcorn\");\n		}\n	};\n\n	public void popIt(){\n		p.pop();\n		p.sizzle();\n	}\n}','p.pop(); is ok because popcorn has a pop method\n\np.sizzle();  is illegal because popcorn does not have sizzle().\n\n','Inner Classes',1,NULL),(3106,'public class Hello {\n   \n    public static void main(String[] args) {\n        Biggie benz = new Benzino();\n        benz.printThaShitt();\n    }\n\n}\n\nclass Biggie {\n    public static int thashitt = 568;\n    protected void actFly(){\n        System.out.println(\"Shit so fly\");\n    }\n    public static void getPaid(){\n        System.out.println(\"Its so easy!\");\n    }\n    public Number getFemaleDigits(){\n        return 5556784;\n    }\n}\n\nclass Benzino extends Biggie{\n    \n    public void printThaShitt(){\n        System.out.println(thashitt);\n        getPaid();\n        super.getPaid();\n        Biggie.getPaid();\n    }\n    \n    public static void getPaid(){\n        System.out.println(\"It\'s somewhat difficult\");\n    }\n    \n    public Integer getFemaleDigits(){\n        return null;\n    }\n    \n}','will not compile class Benzino does not have that method. ','Inner Classes',1,NULL),(3107,'public class Hello {\n   \n    public static void main(String[] args) {\n        Benzino benz = new Benzino();\n        benz.printThaShitt();\n    }\n\n}\n\nclass Biggie {\n    public static int thashitt = 568;\n    protected void actFly(){\n        System.out.println(\"Shit so fly\");\n    }\n    public static void getPaid(){\n        System.out.println(\"Its so easy!\");\n    }\n    public Number getFemaleDigits(){\n        return 5556784;\n    }\n}\n\nclass Benzino extends Biggie{\n    \n    public void printThaShitt(){\n        System.out.println(thashitt);\n        getPaid();\n        super.getPaid();\n        Biggie.getPaid();\n    }\n    \n    public static void getPaid(){\n        System.out.println(\"It\'s somewhat difficult\");\n    }\n    \n    public Integer getFemaleDigits(){\n        return null;\n    }\n    \n}\n','568\nIt\'s somewhat difficult\nIts so easy!\nIts so easy!\n\n\ngetPaid() is used plainly as is it calls Benzinos static method, \n\nall the others access the super class. \n\nStatic variables in Java are not inherited, they exist only in the class which declares them; \nhowever, they can be accessed implicitly by referring to an instance or subclass (or subclass instance) of the class which defines the \nstatic variable. \n(Static variable handling is one of the few confusing parts of the Java language, IMHO.)','Inner Classes',1,NULL),(3108,'public class Test {\n    public static void foo() {\n        System.out.println(\"Test.foo() called \");\n    }\n    public static void foo(int a) { \n        System.out.println(\"Test.foo(int) called \");\n    }\n    public static void main(String args[])\n    { \n        Test.foo();\n        Test.foo(10);\n    }\n}','this shows that static methods can be overloaded','Inner Classes',1,NULL),(3109,'public class Test {\n    public static void foo() {\n        System.out.println(\"Test.foo() called \");\n    }\n    public void foo() { \n        System.out.println(\"Test.foo(int) called \");\n    }\n    public static void main(String args[]) { \n        Test.foo();\n    }\n}','will not compile, you cannot overload based on static keyword alone','Inner Classes',1,NULL),(3110,'public class Hello {\n\n   \n    public static void main(String[] args) {\n        Burnable stick = new Burnable(){\n            \n        };\n    }\n\n}\n\ninterface Burnable{\n    int people = 10;\n    void burn();\n    void shakeoff();\n    int unburn();\n    \n}','will not compile, \n\nanonymous class of stick is not abstract and does not overrride interface\nmethods\n\n','Inner Classes',1,NULL),(3111,'public class Hello {\n\n   \n    public static void main(String[] args) {\n        Burnable stick = new Burnable(){\n            public void burn(){\n                System.out.println(\"Theres \"+people+\" people here so get the fire going\");\n            }\n            \n        };\n    }\n\n}\n\ninterface Burnable{\n    int people = 10;\n    void burn();\n    void shakeoff();\n    int unburn();\n    \n}','does not compile, \n\nanonymous subclass does not impelement all abstract methods ','Inner Classes',1,NULL),(3112,'public class Hello {\n\n    public static void main(String[] args) {\n        \n        Burnable stick = new Burnable(){\n            public void burn(){\n                System.out.println(\"Theres \"+people+\" people here so get the fire going\");\n            }\n            \n            public int unburn(){\n                System.out.println(\"That\'s impossible\");\n                return 0;\n            }\n            \n            public void shakeoff(){\n                System.out.println(\"That was my shoe!\");\n            }\n            \n        };\n    }\n\n}\n\ninterface Burnable{\n    int people = 10;\n    void burn();\n    void shakeoff();\n    int unburn();\n}\n','This type of anonomuous inner class implemtents an interface\n\nThis is the only time you can use new with an interface.\n\nIt compiles because all of the abstract methods are implemented\n\n','Inner Classes',1,NULL),(3113,'interface Burnable{\n    int people = 10;\n    void burn();\n    void shakeoff();\n    int unburn();\n    void people(){\n        System.out.println(people+\" \");\n    }\n}','will not compile interfaces are 100% abstract, they can have nothing\nconcrete','Inner Classes',1,NULL),(3114,'public class Hello {\n\n    public static void main(String[] args) {\n        \n        Burnable stick = new Burnable(){\n            int people = 8;\n            public void burn(){\n                System.out.println(\"Theres \"+people+\" people here so get the fire going\");\n            }\n            \n            public int unburn(){\n                System.out.println(\"That\'s impossible\");\n                return 0;\n            }\n            \n            public void shakeoff(){\n                System.out.println(\"That was my shoe!\");\n            }\n            \n        };\n        \n        stick.burn();\n    }\n\n}\n\ninterface Burnable{\n    int people = 10;\n    void burn();\n    void shakeoff();\n    int unburn();\n}\n','Theres 8 people here so get the fire going','Inner Classes',1,NULL),(3115,'public class Hello {\n\n    public static void main(String[] args) {\n        \n        Burnable stick = new Burnable(){\n            int people = 8;\n            public void burn(){\n                System.out.println(\"Theres \"+people+\" people here so get the fire going\");\n            }\n            \n            public int unburn(){\n                System.out.println(\"That\'s impossible\");\n                return 0;\n            }\n            \n            public void shakeoff(int x){\n                System.out.println(\"That was my shoe!\"+x);\n            }\n            \n            public void shakeoff(){\n                System.out.println(\"its off\");\n            }\n            \n            \n            \n        };\n        \n        stick.burn();\n        stick.shakeoff();\n    }\n\n}\n\ninterface Burnable{\n    int people = 10;\n    void burn();\n    void shakeoff(int z);\n    int unburn();\n}','Will not compile, shakeoff() is overloaded in anonymous subclass. \n\nThe overload is legal using it outside the inner class is not\n\nthat method is an overload it is created in the anonnymous subclass and\ncant be used on the Burnable refernence','Inner Classes',1,NULL),(3116,'public class Hello {\n\n    public static void main(String[] args) {\n        Gym.BasketBallCourt bc = new Gym.BasketBallCourt();\n        bc.collectBalls();\n    }\n\n}\n\nclass Gym{\n    public int weights = 8000;\n    public String name = \"Max\'s gym\";\n    public int price = 50;\n    \n    public void pitch(){\n        System.out.println(\"Were the best gym\");\n    }\n    \n    static class BasketBallCourt {\n        private int courts = 2;\n        \n        public void collectBalls(){\n            System.out.println(\"gimmmie all the balls!\");\n        }\n        \n        public int Scoreboard(){\n            return 114;\n        }\n    }\n}','gimmie all the balls!','Inner Classes',1,NULL),(3117,'class Gym{\n    public int weights = 8000;\n    public String name = \"Max\'s gym\";\n    public int price = 50;\n    \n    public void pitch(){\n        System.out.println(\"Were the best gym\");\n    }\n    \n    static class BasketBallCourt {\n        private int courts = 2;\n        \n        public void collectBalls(){\n            System.out.println(\"gimmmie all the balls!\");\n        }\n        \n        public void gymPrice(){\n            System.out.println(name+\" \"+price);\n        }\n        \n        public int Scoreboard(){\n            return 114;\n        }\n    }','will not compile, static classes are like static members of the enclosing\nclass they cannot access instance varialbes','Inner Classes',1,NULL),(3118,'class Gym{\n    public int weights = 8000;\n    public String name = \"Max\'s gym\";\n    public int price = 50;\n    \n    public void pitch(){\n        System.out.println(\"Were the best gym\");\n    }\n    \n    static class BasketBallCourt {\n        private static int courts = 2;\n        \n        public void collectBalls(){\n            System.out.println(\"gimmmie all the balls!\");\n        }\n        \n        public void gymPrice(){\n            Gym g = new Gym();\n            System.out.println(g.price);\n        }\n        \n        public int Scoreboard(){\n            return 114;\n        }\n    }\n}','This compiles fine static inner classes can have static fields and methods\n','Inner Classes',1,NULL),(3119,'public class Hello {\n\n    public static void main(String[] args) {\n        Gym.BasketBallCourt bc = new Gym.BasketBallCourt();\n        bc.collectBalls();\n    }\n\n}\n\nclass Gym{\n    public int weights = 8000;\n    public String name = \"Max\'s gym\";\n    public int price = 50;\n    \n    public void pitch(){\n        BasketBallCourt bc = new BasketBallCourt();\n        System.out.println(\"Were the best gym\");\n        System.out.println(\"Our court is huge too! \"+bc.courts());\n    }\n    \n    static class BasketBallCourt {\n        private static int courts = 2;\n        \n        public static void collectBalls(){\n            System.out.println(\"gimmmie all the balls!\");\n        }\n        public int courts(){\n            return courts;\n        }\n        \n        public void gymPrice(){\n            Gym g = new Gym();\n            System.out.println(g.price);\n        }\n        \n        public int Scoreboard(){\n            return 114;\n        }\n    }\n}','this compiles fine, shows how to properly instantiate static nested clases','Inner Classes',1,NULL),(3120,'public class Hello {\n\n    public static void main(String[] args) {\n        Gym.BasketBallCourt bc = new Gym.BasketBallCourt();\n        Gym g = new Gym();\n        \n        Gym.BasketBallCourt bc3 = g.new BasketBallCourt();\n        \n        g.pitch();\n        \n    }\n\n}\n\nclass Gym{\n    public int weights = 8000;\n    public String name = \"Max\'s gym\";\n    public int price = 50;\n    \n    public void pitch(){\n        BasketBallCourt bc = new BasketBallCourt();\n        System.out.println(\"Were the best gym\");\n        System.out.println(\"Our court is huge too! \"+bc.courts());\n    }\n    \n    static class BasketBallCourt {\n        private static int courts = 2;\n        \n        public static void collectBalls(){\n            System.out.println(\"gimmmie all the balls!\");\n        }\n        public int courts(){\n            return courts;\n        }\n        \n        public void gymPrice(){\n            Gym g = new Gym();\n            System.out.println(g.price);\n        }\n        \n        public int Scoreboard(){\n            return 114;\n        }\n    }\n}','will not compile, that is not the right instantiation of a static nested class','Inner Classes',1,NULL),(3121,'public class Hello {\n\n    public static void main(String[] args) {\n        Gym.BasketBallCourt bc = new Gym.BasketBallCourt();\n        Gym g = new Gym();\n        \n        Gym.BasketBallCourt bc3 = new Gym.BasketBallCourt();\n        \n        bc3.Scoreboard();\n        \n        Gym.BasketBallCourt.collectBalls();\n        \n    }\n\n}\n\nclass Gym{\n    public int weights = 8000;\n    public String name = \"Max\'s gym\";\n    public int price = 50;\n    \n    public void pitch(){\n        BasketBallCourt bc = new BasketBallCourt();\n        System.out.println(\"Were the best gym\");\n        System.out.println(\"Our court is huge too! \"+bc.courts());\n    }\n    \n    static class BasketBallCourt {\n        private static int courts = 2;\n        \n        public static void collectBalls(){\n            System.out.println(\"gimmmie all the balls!\");\n        }\n        public int courts(){\n            return courts;\n        }\n        \n        public void gymPrice(){\n            Gym g = new Gym();\n            System.out.println(g.price);\n        }\n        \n        public int Scoreboard(){\n            return 114;\n        }\n    }\n}','114\ngimmie all the balls','Inner Classes',1,NULL),(3122,'public class Hello {\n\n    public static void main(String[] args) {\n        Gym.BasketBallCourt gbg = new Gym().new BasketBallCourt();\n        System.out.println(gbg.Scoreboard());\n        \n    }\n\n}\n\nclass Gym{\n    public int weights = 8000;\n    public String name = \"Max\'s gym\";\n    public int price = 50;\n    \n    public void pitch(){\n        BasketBallCourt bc = new BasketBallCourt();\n        System.out.println(\"Were the best gym\");\n    }\n    \n    class BasketBallCourt {\n        \n        public void collectBalls(){\n            System.out.println(\"gimmmie all the balls!\");\n        }\n        \n        public void gymPrice(){\n            Gym g = new Gym();\n            System.out.println(g.price);\n        }\n        \n        public int Scoreboard(){\n            return 114;\n        }\n    }\n}','114','Inner Classes',1,NULL),(3123,'public class Hello {\n\n    public static void main(String[] args) {\n        Gym.BasketBallCourt gbg = new Gym().new BasketBallCourt();\n        \n    }\n\n}\n\nclass Gym{\n    public int weights = 8000;\n    public String name = \"Max\'s gym\";\n    public int price = 50;\n    \n    public void pitch(){\n        BasketBallCourt bc = new BasketBallCourt();\n        System.out.println(\"Were the best gym\");\n    }\n    \n    private class BasketBallCourt {\n        \n        public void collectBalls(){\n            System.out.println(\"gimmmie all the balls!\");\n        }\n        \n        public void gymPrice(){\n            Gym g = new Gym();\n            System.out.println(g.price);\n        }\n        \n        public int Scoreboard(){\n            return 114;\n        }\n    }\n}','does not compile because of private modifier','Inner Classes',1,NULL),(3124,'public class Hello {\n\n    public static void main(String[] args) {\n        Gym.BasketBallCourt gbg = new Gym().new BasketBallCourt();\n        \n    }\n\n}\n\nclass Gym{\n    public int weights = 8000;\n    public String name = \"Max\'s gym\";\n    public int price = 50;\n    \n    public void pitch(){\n        BasketBallCourt bc = new BasketBallCourt();\n        System.out.println(\"Were the best gym\");\n    }\n    \n    protected class BasketBallCourt {\n        \n        public void collectBalls(){\n            System.out.println(\"gimmmie all the balls!\");\n        }\n        \n        public void gymPrice(){\n            Gym g = new Gym();\n            System.out.println(g.price);\n        }\n        \n        public int Scoreboard(){\n            return 114;\n        }\n    }\n}','this compiles fine','Inner Classes',1,NULL),(3125,'public class Hello {\n\n    public static void main(String[] args) {\n        LifeTime lt = new LifeTime();\n        lt.showLifeTimesCourt();    \n    }\n\n}\n\nclass Gym{\n    public int weights = 8000;\n    public String name = \"Max\'s gym\";\n    public int price = 50;\n    \n    public void pitch(){\n        BasketBallCourt bc = new BasketBallCourt();\n        System.out.println(\"Were the best gym\");\n    }\n    \n    protected class BasketBallCourt {\n        \n        public void collectBalls(){\n            System.out.println(\"gimmmie all the balls!\");\n        }\n        \n        public void showCourt(){\n            System.out.println(\"oooh ahhh\");\n        }\n        \n        public void gymPrice(){\n            Gym g = new Gym();\n            System.out.println(g.price);\n        }\n        \n        public int Scoreboard(){\n            return 114;\n        }\n    }\n}\n\nclass LifeTime extends Gym{\n    public void showLifeTimesCourt(){\n        BasketBallCourt b = new BasketBallCourt();\n        b.showCourt();\n    }\n}','oooh ahhh\n\nsince inner classes are members of the enclsoing class just like anything else\nthey are inherited too.','Inner Classes',1,NULL),(3126,'public class Hello {\n\n    public static void main(String[] args) {\n       LifeTime lt = new LifeTime();\n       Gym.BasketBallCourt bc = lt.new BasketBallCourt();\n       \n    }\n\n}\n\nclass Gym{\n    public int weights = 8000;\n    public String name = \"Max\'s gym\";\n    public int price = 50;\n    \n    public void pitch(){\n        BasketBallCourt bc = new BasketBallCourt();\n        System.out.println(\"Were the best gym\");\n    }\n    \n    protected class BasketBallCourt {\n        \n        public void collectBalls(){\n            System.out.println(\"gimmmie all the balls!\");\n        }\n        \n        public void showCourt(){\n            System.out.println(\"oooh ahhh\");\n        }\n        \n        public void gymPrice(){\n            Gym g = new Gym();\n            System.out.println(g.price);\n        }\n        \n        public int Scoreboard(){\n            return 114;\n        }\n    }\n}\n\nclass LifeTime extends Gym{\n    public void showLifeTimesCourt(){\n        BasketBallCourt b = new BasketBallCourt();\n        b.showCourt();\n    }\n}','this compiles and runs','Inner Classes',1,NULL),(3127,'public class Hello {\n\n    public static void main(String[] args) {\n       Gym lt = new Gym();\n       Gym.BasketBallCourt bc = lt.new BasketBallCourt();\n       \n    }\n\n}\n\nclass Gym{\n    public int weights = 8000;\n    public String name = \"Max\'s gym\";\n    public int price = 50;\n    \n    public void pitch(){\n        BasketBallCourt bc = new BasketBallCourt();\n        System.out.println(\"Were the best gym\");\n    }\n    \n    protected class BasketBallCourt {\n        public String name = \"Maxs court\";\n        \n        public void collectBalls(){\n            System.out.println(\"gimmmie all the balls!\");\n        }\n        \n        public void showCourt(){\n            System.out.println(\" \"+name);\n            System.out.println(\"oooh ahhh\");\n        }\n        \n        public void gymPrice(){\n            System.out.println(\" \"+Gym.this.name);\n            System.out.println(Gym.this.price);\n        }\n        \n        public int Scoreboard(){\n            return 114;\n        }\n    }\n}','How to access this reference of outer class','Inner Classes',1,NULL),(3128,'public class Hello {\n\n    public static void main(String[] args) {\n       LifeTime lt = new LifeTime();\n       Gym.BasketBallCourt bc = lt.new BasketBallCourt();\n       \n    }\n\n}\n\nclass Gym{\n    public int weights = 8000;\n    public String name = \"Max\'s gym\";\n    public int price = 50;\n    \n    public void pitch(){\n        BasketBallCourt bc = new BasketBallCourt();\n        System.out.println(\"Were the best gym\");\n    }\n    \n    protected class BasketBallCourt {\n        public String name = \"Maxs court\";\n        \n        public void collectBalls(){\n            System.out.println(\"gimmmie all the balls!\");\n        }\n        \n        public void showCourt(){\n            System.out.println(\" \"+name);\n            System.out.println(\"oooh ahhh\");\n        }\n        \n        public void gymPrice(){\n            System.out.println(\" \"+Gym.this.name);\n            System.out.println(Gym.this.price);\n        }\n        \n        public int Scoreboard(){\n            return 114;\n        }\n    }\n}\n\nclass LifeTime extends Gym{\n    public void showLifeTimesCourt(){\n        final int time = 530;\n        class SalesRep{\n            public void appointment(){\n                System.out.println(\"The time of our appointment is: \"+time);\n            }\n            \n        }\n        SalesRep sr = new SalesRep();\n        sr.appointment();\n        BasketBallCourt b = new BasketBallCourt();\n        b.showCourt();\n    }\n}','compiles fine','Inner Classes',1,NULL),(3129,'package hello;\n\nimport java.awt.Container;\nimport java.awt.EventQueue;\nimport java.awt.event.ActionEvent;\nimport java.awt.event.InputEvent;\nimport java.awt.event.KeyEvent;\nimport java.io.IOException;\nimport java.io.Serializable;\nimport java.nio.file.DirectoryStream;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Hashtable;\nimport java.util.Iterator;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.NavigableMap;\nimport java.util.PriorityQueue;\nimport java.util.Set;\nimport java.util.SortedMap;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport javax.swing.AbstractAction;\nimport javax.swing.GroupLayout;\nimport javax.swing.InputMap;\nimport javax.swing.JButton;\nimport javax.swing.JComponent;\nimport javax.swing.JFrame;\nimport javax.swing.JPanel;\nimport javax.swing.KeyStroke;\n\npublic class Hello {\n\n    public static void main(String[] args) {\n       LifeTime lt = new LifeTime();\n       Gym.BasketBallCourt bc = lt.new BasketBallCourt();\n       \n    }\n\n}\n\nclass Gym{\n    public int weights = 8000;\n    public String name = \"Max\'s gym\";\n    public int price = 50;\n    \n    public void pitch(){\n        BasketBallCourt bc = new BasketBallCourt();\n        System.out.println(\"Were the best gym\");\n    }\n    \n    protected class BasketBallCourt {\n        public String name = \"Maxs court\";\n        \n        public void collectBalls(){\n            System.out.println(\"gimmmie all the balls!\");\n        }\n        \n        public void showCourt(){\n            System.out.println(\" \"+name);\n            System.out.println(\"oooh ahhh\");\n        }\n        \n        public void gymPrice(){\n            System.out.println(\" \"+Gym.this.name);\n            System.out.println(Gym.this.price);\n        }\n        \n        public int Scoreboard(){\n            return 114;\n        }\n    }\n}\n\nclass LifeTime extends Gym{\n    public void showLifeTimesCourt(){\n        int time = 530;\n        class SalesRep{\n            public void appointment(){\n                System.out.println(\"The time of our appointment is: \"+time);\n            }\n            \n        }\n        SalesRep sr = new SalesRep();\n        sr.appointment();\n        BasketBallCourt b = new BasketBallCourt();\n        b.showCourt();\n    }\n}\n\n\n','compilation fails, non final local variable is access from Method local inner \nclass.','Inner Classes',1,NULL),(3130,'class Gym{\n    public int weights = 8000;\n    public String name = \"Max\'s gym\";\n    public int price = 50;\n    \n    public void pitch(){\n        BasketBallCourt bc = new BasketBallCourt();\n        System.out.println(\"Were the best gym\");\n    }\n    \n    protected class BasketBallCourt {\n        public String name = \"Maxs court\";\n        \n        public void collectBalls(){\n            System.out.println(\"gimmmie all the balls!\");\n        }\n        \n        public void showCourt(){\n            System.out.println(\" \"+name);\n            System.out.println(\"oooh ahhh\");\n        }\n        \n        public void gymPrice(){\n            System.out.println(\" \"+Gym.this.name);\n            System.out.println(Gym.this.price);\n        }\n        \n        public int Scoreboard(){\n            return 114;\n        }\n    }\n}\n\nclass LifeTime extends Gym{\n    public void showLifeTimesCourt(){\n        int time = 530;\n        protected class SalesRep{\n            public void appointment(){\n                System.out.println(\"The time of our appointment is: \"+time);\n            }\n            \n        }\n        SalesRep sr = new SalesRep();\n        sr.appointment();\n        BasketBallCourt b = new BasketBallCourt();\n        b.showCourt();\n    }\n}','Method inner classes cannot be declared protected public private or static','Inner Classes',1,NULL),(3131,'public class Hello {\n    public static void main(String[] args) {\n       Gym g = new LifeTime() {\n           public void showLifeTimeCourt(){\n               System.out.println(\"LT on meridean\");\n           }\n       };\n    }\n}\n\nclass Gym{\n    public int weights = 8000;\n    public String name = \"Max\'s gym\";\n    public int price = 50;\n    \n    public void pitch(){\n        BasketBallCourt bc = new BasketBallCourt();\n        System.out.println(\"Were the best gym\");\n    }\n    \n    static class BasketBallCourt {\n        public String name = \"Maxs court\";\n        \n        public void collectBalls(){\n            System.out.println(\"gimmmie all the balls!\");\n        }\n        \n        public void showCourt(){\n            System.out.println(\" \"+name);\n            System.out.println(\"oooh ahhh\");\n        }\n        \n        public void gymPrice(){\n\n        }\n        \n        public int Scoreboard(){\n            return 114;\n        }\n    }\n}\n\nclass LifeTime extends Gym{\n    \n    public void showLifeTimesCourt(){\n        final int time = 530;\n        BasketBallCourt bc = new BasketBallCourt();\n        bc.collectBalls();\n    }\n}','This compiles fine, you can create an anonymous inner class with a subclass\nthen assign it to a superclass reference. ','Inner Classes',1,NULL),(3132,'public class Hello {\n    public static void main(String[] args) {\n        \n        AquaticLife shark = new Shark(){\n            String unknown = \"unknown species\";\n            public void species(){\n                System.out.println(unknown);\n            }\n        };\n        \n        shark.swim();\n        shark.devourSeal();\n  \n    }\n}\n\nclass AquaticLife{ \n    public void swim(){ \n        System.out.println(\"Bubbles\");\n    }\n     \n    public void useGills(){\n        System.out.println(\"ahhh\");\n    }\n}\n\nclass Shark extends AquaticLife{\n    public void devourSeal(){\n        System.out.println(\"chomp\");\n    }\n    \n    public void swin(){\n        System.out.println(\"Swims up to 60mph\");\n    }\n    public void electricSense(){\n        System.out.println(\"I can feel you in the water\");\n    }\n}','shark.devourSeal() does not compile. \n\nthe anonymous class is declared with a reference type of AquaticLife\nso you can only use methods of that class','Inner Classes',1,NULL),(3133,'class AquaticLife{ \n    public void swim(){ \n        System.out.println(\"Bubbles\");\n    }\n     \n    public void useGills(){\n        System.out.println(\"ahhh\");\n    }\n    \n    class BottomFeeder extends AquaticLife {\n        public void useGills(){\n            System.out.println(\"I dont have gills\");\n        }\n    }\n}','an inner class can extend the outlying classs','Inner Classes',1,NULL),(3134,'which are true about a method local inner class ?\n\nIt must be marked final\nIt can be marked abstract\nIt can be marked public \nIt can be marked static \nIt can access private members of the enclosing class','It can be abstract,\n	that would mean a concrete class would have to be created in the \n	method so that would probably not be very useful\n\nIt can access private members of the enclosing class\n--------------------------------------------------------\nIt can be marked final but it doesnt\' have to be\n\na method local inner class cannot be marked public, or static','Inner Classes',1,NULL),(3135,'public class TestObj {\n	public static void main(SA){\n		Object ob = new Object() {\n			public boolean equals(Object ob){\n				return true;\n			}\n		}\n		sout(ob.equals(\"FRED\");\n	}\n}','Compilation fails with an error at the line where the semicolon should be \nafter the inner class','Inner Classes',1,NULL),(3136,'public class HorseTest {\n	public static void main(SA){\n		class Horse {\n			public String name;\n			public Horse(String s) {\n				name = s;\n			}\n		}\n		Object ob = new Horse(\"Zippo\");\n		sout(ob.name);\n	}\n}','compilation fails at sout(ob.name);\n\nif the reference variable is of type Object you can only access members \ndefined class Object','Inner Classes',1,NULL),(3137,'public abstract class AbstractTest {\n	public int getNum(){\n		return 45;\n	}\n	public abstract class Bar {\n		public int getNum(){\n			return 38;\n		}\n	}\n	public staic void main(String[] args) {\n		AbstractTest t = new AbstractTest(){\n			public int getNum() {\n				return 22;\n			}\n		};\n		AbstractTest.Bar f = t.new Bar() {\n			public int getNum(){\n				return 57;\n			}\n		};\n		sout(f.getNum() + \" \" + t.getNum() );\n	}\n}','57 22\n\nto create an instance of an inner class you have to create it with an \nouter class reference here AbstractTest is abstract so it had to be\ninstantiated with an anonymous inner class to have a concrete reference\nto tie the new anonymous class of type Bar to. ','Inner Classes',1,NULL),(3138,'public class Tour {\n	public static void main(SA){\n		Cathedral c = new Cathedral();\n		// insert code\n		s.go();\n	}\n}\n\nclass Cathedral {\n	class Sanctum {\n		void go() { sout(\"spooky\"); }\n	}\n}\n\nproperly instantiate Sanctume','Cathedral.Sanctum s = c.new Sanctum();\n\nor\n\nCathedral.Sanctum s1 = new Cathedral().new Sanctum();','Inner Classes',1,NULL),(3139,'public abstract class Hello {\n    public static void main(String[] args) {\n        new Hello().test();\n        \n    }\n    \n    void test() {\n        class Breaker{ void foo(){ System.out.println(\"Inner\"); } }\n    }\n    \n    class Breaker {\n        void foo(){\n            System.out.println(\"middle\");\n        }\n    }\n}\n\nclass Breaker{\n    void foo(){\n        System.out.println(\"Outer\");\n    }\n    \n}','Will not compile Hello is abstract cannot be instantiated lol ','Inner Classes',1,NULL),(3140,'public class Hello {\n    public static void main(String[] args) {\n        new Hello().test();\n        \n    }\n    \n    void test() {\n        new Breaker().foo();\n        class Breaker{ void foo(){ System.out.println(\"Inner\"); } }\n    }\n    \n    class Breaker {\n        void foo(){\n            System.out.println(\"middle\");\n        }\n    }\n}\n\nclass Breaker{\n    void foo(){\n        System.out.println(\"Outer\");\n    }\n    \n}','middle\n\nThe closest scoped class is middle. The inner class is declared after the\ncall to foo() and the Outer class comes after any inner classes','Inner Classes',1,NULL),(3141,'public class Hello {\n    public static void main(String[] args) {\n        blue.biteHook();\n        \n        BlueGill blue = new BlueGill(){\n            public void biteHook(){\n                System.out.println(\"Not This Time\");\n            }\n        }\n        \n    }\n    \n    BlueGill bigBlue = new BlueGill(){\n        public int bubble() throws IOException {\n            System.out.println(\"Big Bubbles\");\n            return 5;\n        }\n        \n    };\n}\n\nabstract class Fish {\n    public abstract void swim();\n    private abstract int numberOfFins();\n    \n}\n\nclass BlueGill extends Fish {\n    public void swim(){\n        System.out.println(\"Swims in lakes\");\n    }\n    \n    public void biteHook() throws IOException {\n        System.out.println(\"What the hell\");\n    }\n    \n    public int bubble() throws Exception{\n        System.out.println(\"bubble bubble\");\n        return 2;\n    }\n}','the call to blue in main fails because it is called before the anon class\nis created. \n\nanonymous class bigBlue works fine, you can define anonymous classes as\nmembers \n\nalso anon class blue forgets to end with a ; \n\nabsract classes cannnot have private abstract members, how would they\nbe instantiated ?\n\nbecaue of that BlueGill cannot properly override method numberOfFins()\n\nan overriding method can choose not to throw the same exception or can \nthrow a narrower one. \n','Inner Classes',1,NULL),(3142,'public class Hello {\n    public static void main(String[] args) {     \n        BlueGill blue = new BlueGill(){\n            public void biteHook() throws IOException{\n                System.out.println(\"Not This Time\");\n            }\n            public void biteHook(boolean yesno) throws NullPointerException{\n                System.out.println(\"That worm looks so tasty\");\n            }\n            \n        };\n        \n    }\n}\n\nabstract class Fish {\n    public abstract void swim() throws Exception;\n    public abstract int numberOfFins();\n    public static void breathe(){\n        System.out.println(\"ahhh\");\n    }\n    \n    \n}\n\nclass BlueGill extends Fish {\n    public void swim(){\n        breathe();\n        System.out.println(\"Swims in lakes\");\n    }\n    \n    public void biteHook() throws IOException {\n        System.out.println(\"What the hell\");\n    }\n    \n    public int numberOfFins() throws SQLException {\n        return 4;\n    }\n    \n    public int bubble() throws Exception{\n        System.out.println(\"bubble bubble\");\n        return 2;\n    }\n}','numberOfFins() in abstract class Fish does not throw SQLException\n	so the override in BlueGill cannot throw a new Exception.\n\nbiteHook is declared in BlueGill then overriden in the annon class with\nthe same exception so its ok.\n\nthen the anon class does not override the method numberOfFins which was \nnot properly overriden in the abstract class so that makes the anon class\nnot compile. If it had overriden numberOfFins() then it could have compiled\n\nstill though the NOF in BlueGill threw that SQLException so it wont ever compile..','Inner Classes',1,NULL),(3143,'public class  Car {\n	class Engine {\n		// insert here\n	}\n	public static void main(SA){\n		new Car().go();\n	}\n	void go() {\n		new Engine();\n	}\n	void drive() { sout(\"hi\"); }\n}\n\n// what can be given at insert here to produce \"hi\" ?\n','{ Car.this.drive(); }\n\nEngine() { Car.this.drive(); }','Inner Classes',1,NULL),(3144,'public class City {\n	class Manhattan {\n		void doStuff() throws Exception { sout(\"x \"); }\n	}\n	class Timesquare extends Manhattan {\n		void doStuff throws Exception {  }\n	}\n\n	public static void main(Stringp]] args) throws Exception{\n		new City().go();\n	}\n	void go() throws Exception { new Timesquare().doStuff(); }\n}','no output is produced, the inner classes are valid and the exceptions are \nthrown properly','Inner Classes',1,NULL),(3145,'public class Navel {\n	private int size = 7;\n	private static int length = 3;\n	public static void main(String[] args) {\n		new Navel().go();\n	}\n	void go(){\n		int size = 5;\n		sout( new Gazer().adder() );\n	}\n	class Gazer {\n		int adder() { return size * length; }\n	}\n}	','21','Inner Classes',1,NULL),(3146,'public class Hello {\n    public static void main(String[] args) {     \n        BlueGill blue = new BlueGill();\n        blue.breathe();\n        blue.swim();\n        \n    }\n}\n\nabstract class Fish {\n    public abstract void swim() throws Exception;\n    public abstract int numberOfFins();\n    public static void breathe(){\n        System.out.println(\"ahhh\");\n    }   \n}\n\nclass BlueGill extends Fish {\n    public void swim(){\n        breathe();     \n        System.out.println(\"Swims in a lake\");\n    }\n    \n    public int numberOfFins(){\n        return 5;    \n    }   \n}','ahhh\nahhh\nSwims in a lake','Inner Classes',1,NULL),(3147,'public class Hello {\n    public static void main(String[] args) {     \n        BlueGill blue = new BlueGill();\n        \n        Fish.breathe();\n        \n    }\n}\n\nabstract class Fish {\n    public abstract void swim() throws Exception;\n    public abstract int numberOfFins();\n    public static void breathe(){\n        System.out.println(\"ahhh\");\n    }   \n}\n\nclass BlueGill extends Fish {\n    public void swim(){\n        breathe();     \n        System.out.println(\"Swims in a lake\");\n    }\n    \n    public int numberOfFins(){\n        return 5;    \n    }   \n}','ahhh','Inner Classes',1,NULL),(3148,'abstract class Fish {\n    public static int species = 100;\n    public abstract void swim() throws Exception;\n    public abstract int numberOfFins();\n    public static void breathe(){\n        System.out.println(\"ahhh\");\n    }   \n}\n\nclass BlueGill extends Fish {\n    public void swim(){\n        breathe();     \n        System.out.println(species);\n        System.out.println(\"Swims in a lake\");\n    }\n    \n    public int numberOfFins(){\n        return 5;    \n    }   \n}','compiles','Inner Classes',1,NULL),(3149,'public class Pockets {\n	public static void main(SA){\n		String[] sa = {\"nickle\",\"button\", \"key\", \"lint\" };\n		Sorter s = new Sorter();\n		for(String s2: sa) sout( s2+\" \" );\n		Arrays.sort(sa,s);\n		sout();\n		for(String s2 : sa) sout( s2+\" \" );\n		\n	}\n	class Sorter implements Comparator<String> {	\n		public int compare(String a, String b) {\n			return b.compareTo(a);\n		}\n	}\n}','compilation fails, \nClass sorter must be delcared static to be used in static methood main. ','Collections',1,NULL),(3150,'public class Hello {\n    public static void main(String[] args) {     \n        BlueGill blue = new BlueGill();\n        blue.swim();\n        \n    }\n}\nclass BlueGill extends Fish {\n    public void swim(){\n        breathe();     \n        System.out.println(species);\n        System.out.println(\"Swims in a lake\");\n    }\n    \n    public int numberOfFins(){\n        return 5;    \n    }   \n}\n\nabstract class Fish {\n    public static int species = 100;\n    public abstract void swim() throws Exception;\n    public abstract int numberOfFins();\n    public static void breathe(){\n        System.out.println(\"ahhh\");\n    }   \n}\n   ','ahhh\n100\nSwims in a lake','Inner Classes',1,NULL),(3151,'public class Hello {\n    public static void main(String[] args) {     \n        BlueGill blue = new BlueGill();\n        blue.swim();\n        \n    }\n class BlueGill extends Fish {\n    public void swim(){\n        breathe();     \n        System.out.println(species);\n        System.out.println(\"Swims in a lake\");\n    }\n    \n    public int numberOfFins(){\n        return 5;    \n    }   \n}\n}\n\nabstract class Fish {\n    public static int species = 100;\n    public abstract void swim() throws Exception;\n    public abstract int numberOfFins();\n    public static void breathe(){\n        System.out.println(\"ahhh\");\n    }   \n}','will not compile, BlueGill is an inner class therefor must be declared static\nto be used in static method main. ','Inner Classes',1,NULL),(3152,'public class Hello {\n    public static void main(String[] args) {     \n        BlueGill blue = new BlueGill();\n        blue.swim();\n        \n    }\n static class BlueGill extends Fish {\n    public void swim(){\n        breathe();     \n        System.out.println(species);\n        System.out.println(\"Swims in a lake\");\n    }\n    \n    public int numberOfFins(){\n        return 5;    \n    }   \n}\n}\n\nabstract class Fish {\n    public static int species = 100;\n    public abstract void swim() throws Exception;\n    public abstract int numberOfFins();\n    public static void breathe(){\n        System.out.println(\"ahhh\");\n    }   \n}','ahhh\n100\nSwims in lake','Inner Classes',1,NULL),(3153,'public class Hello {\n    public static void main(String[] args) {     \n        Locker<SchoolSupplies> locker = new Locker<>();\n        locker.stuff.add(new Book(\"AAA\"));\n        locker.stuff.add(new Book(\"BBB\"));\n        \n        System.out.println(locker.getOut(new Book(\"AAA\")));\n        \n    }\n}\n\nclass Locker<T> {\n    ArrayList<T> stuff = new ArrayList<T>();\n    public T getOut(T that){\n        return stuff.get(that);\n    }\n}\n\nabstract class SchoolSupplies{\n    public abstract void use();\n    public abstract int lend();\n    public abstract boolean isCool();\n}\n\nclass Book extends SchoolSupplies{\n    private String name;\n    Book(String n){\n        name = n;\n    }\n    public void use(){\n        System.out.println(\"Read it\");\n    }\n    \n    public int lend(){\n        System.out.println(\"I need back by 4th\");\n        return 4;\n    }\n    \n    public boolean isCool(){\n        return false;\n    }\n}\n\nclass Pen extends SchoolSupplies {\n    public void use(){\n        System.out.println(\"doodle\");\n    }\n    \n    public int lend(){\n        System.out.println(\"just have it\");\n        return null;\n    }\n    \n    public boolean isCool(){\n        return true;\n    }\n}','Arraylist doesn\'t have a method that returns the given object. \n\nalso you cannot return null when the return type is primitive.','Inner Classes',1,NULL),(3154,'public class Hello {\n    public static void main(String[] args) {     \n\n        List<Animal> animals = new ArrayList<Animal>();\n        animals.add(new Dog());\n        animals.add(new Cat());\n        \n        addAnimal(animals);\n    \n    }\n    \n    public static void addAnimal(List animals) {\n	animals.add(new Object());\n    }\n}','compiles with a warning','Generics',1,NULL),(3155,'public class Hello {\n    public static void main(String[] args) {     \n\n        Animal a = new Animal(6,\"dog\");\n        System.out.println(a.getSize());\n    \n    }\n\n}\n        \nclass Animal implements Comparable<Animal>{\n    private int size;\n    private String name;\n    public Animal(int s, String n){\n        size = s;\n        name = n;\n        \n    }\n    public int getSize(){\n        return size;\n    }\n    public int compareTo(Animal a){\n        int asize = a.getSize();\n        int bsize = this.size;\n        \n        if(asize < bsize)\n            return 1;\n        else if(asize == bsize)\n            return 0;\n        else\n            return -1;\n        \n        \n    }\n    \n    public String toString(){\n        return name;\n    }\n}\n\nclass Dog extends Animal{}\nclass Cat extends Animal{} ','will not compile,\n\ndefault constructors in Dog and Cat do not give proper calls to super()\nanimal non-defautl constructor','General',1,NULL),(3156,'public class Hello {\n    public static void main(String[] args) {     \n        List<Spankable> spanklist = new ArrayList<>();\n        spanklist.add(new Doll());\n        spanklist.add(new Doll());\n        \n    }\n    \n    public static void runit(List<? extends Shaveable> sList){\n        for(Spankable s : sList){\n            s.shave();\n        }\n    }\n\n}\n\ninterface Shaveable{\n    public void shave();\n}\n\ninterface Spankable extends Shaveable{\n    public void spank();\n}\n\nclass Doll implements Spankable{\n    public void spank(){\n        System.out.println(\"OW!\");\n    }\n    \n    public void shave(){\n        System.out.println(\"HMMM : O\");\n    }\n}','will not compile,\n\n	should be...\n		for(Shaveable s : sList){\n			...','General',1,NULL),(3157,'public class Hello {\n    public static void main(String[] args) {     \n        List<Spankable> spanklist = new ArrayList<>();\n        spanklist.add(new Doll());\n        spanklist.add(new Doll());\n        \n    }\n    \n    public static void runit(List<? extends Shaveable> sList){\n        for(Shaveable s : sList){\n            s.shave();\n        }\n    }\n\n}\n\ninterface Shaveable{\n    public void shave();\n}\n\ninterface Spankable extends Shaveable{\n    public void spank();\n}\n\nclass Doll implements Spankable{\n    public void spank(){\n        System.out.println(\"OW!\");\n    }\n    \n    public void shave(){\n        System.out.println(\"HMMM : O\");\n    }\n}','compiles\n\nhmmm : O\nhmmm : O','General',1,NULL),(3158,'public class Hello {\n    public static void main(String[] args) {     \n        List<Spankable> spanklist = new ArrayList<>();\n        spanklist.add(new Doll());\n        spanklist.add(new Doll());\n        \n        runit(spanklist);\n        \n    }\n    \n    public static void runit(List<? extends Spankable> sList){\n        for(Shaveable s : sList){\n            s.shave();\n        }\n    }\n\n}\n\ninterface Shaveable{\n    public void shave();\n}\n\ninterface Spankable extends Shaveable{\n    public void spank();\n}\n\nclass Doll implements Spankable{\n    public void spank(){\n        System.out.println(\"OW!\");\n    }\n    \n    public void shave(){\n        System.out.println(\"HMMM : O\");\n    }\n}','HMMM : O\nHMMM : O\n\n','General',1,NULL),(3159,'class Hello {\n    public static void main(String[] args) {     \n        List<Spankable> spanklist = new ArrayList<>();\n        spanklist.add(new Doll());\n        spanklist.add(new Doll());\n        \n        runit(spanklist);\n        \n    }\n    \n    public static void runit(List<? extends Shaveable> sList){\n        for(Shaveable s : sList){\n            s.shave();\n        }\n    }\n\n}\n\ninterface Shaveable{\n    public void shave();\n}\n\ninterface Spankable extends Shaveable{\n    public void spank();\n}\n\nclass Doll implements Spankable{\n    public void spank(){\n        System.out.println(\"OW!\");\n    }\n    \n    public void shave(){\n        System.out.println(\"HMMM : O\");\n    }\n}                     ','HMMM : O\nHMMM : O','General',1,NULL),(3160,'class Hello {\n    public static void main(String[] args) {     \n        List<Doll> spanklist = new ArrayList<>();\n        spanklist.add(new Doll());\n        spanklist.add(new Doll());\n        \n        runit(spanklist);\n        \n    }\n    \n    public static void runit(List<? extends Shaveable> sList){\n        for(Shaveable s : sList){\n            s.shave();\n        }\n    }\n\n}\n\ninterface Shaveable{\n    public void shave();\n}\n\ninterface Spankable extends Shaveable{\n    public void spank();\n}\n\nclass Doll implements Spankable{\n    public void spank(){\n        System.out.println(\"OW!\");\n    }\n    \n    public void shave(){\n        System.out.println(\"HMMM : O\");\n    }\n}                  ','HMMM : O\nHMMM : O','General',1,NULL),(3161,'class Hello {\n    public static void main(String[] args) {     \n        Path p1 = Paths.get(\"/home/max/tmp\");\n        Path p2 = Paths.get(\"/tmp/google/file.txt\");\n        System.out.println(p1.resolve(p2));\n        \n    }\n\n}','/tmp/google/file.txt','General',1,NULL),(3162,'class Hello {\n    public static void main(String[] args) {     \n        Path p1 = Paths.get(\"/home/max/tmp\");\n        Path p2 = Paths.get(\"tmp/google/file.txt\");\n        System.out.println(p1.resolve(p2));\n        \n    }\n\n}','/home/max/tmp/tmp/google/file.txt','Input/Output',1,NULL),(3163,'class Hello {\n    public static void main(String[] args) {     \n        Path p1 = Paths.get(\"/home/max/tmp\");\n        Path p2 = Paths.get(\"google/file.txt\");\n        System.out.println(p1.resolve(p2));\n        \n    }\n\n}','/home/max/tmp/google/file.txt','Input/Output',1,NULL),(3164,'class Hello {\n    public static void main(String[] args) {     \n        Path p1 = Paths.get(\"/home/max/tmp\");\n        Path p2 = Paths.get(\"file.txt\");\n        System.out.println(p1.resolve(p2));\n        \n    }\n\n}','/home/max/tmp/file.txt','General',1,NULL),(3165,'class Hello {\n    public static void main(String[] args) {     \n        Path p1 = Paths.get(\"home/max/tmp\");\n        Path p2 = Paths.get(\"file.txt\");\n        System.out.println(p1.resolve(p2));\n        \n    }\n\n}','home/max/tmp/file.txt','General',1,NULL),(3166,'class Hello {\n    public static void main(String[] args) {     \n        Path p1 = Paths.get(\"home/max/tmp/file.txt\");\n        Path p2 = Paths.get(\"file.txt\");\n        System.out.println(p1.resolve(p2));\n        \n    }\n\n}','home/max/tmp/file.txt/file.txt','General',1,NULL),(3167,'class Hello {\n    public static void main(String[] args) {     \n        Path p1 = Paths.get(\"\");\n        Path p2 = Paths.get(\"file.txt\");\n        System.out.println(p1.resolve(p2));\n        \n    }\n\n}','file.txt','General',1,NULL),(3168,'class Hello {\n    public static void main(String[] args) {     \n        Path p1 = Paths.get(\"home/max/tmp/file.txt\");\n        Path p2 = Paths.get(\"\");\n        System.out.println(p1.resolve(p2));\n        \n    }\n\n}','home/max/tmp/file.txt','General',1,NULL),(3169,'class Hello {\n    public static void main(String[] args) {     \n        Path p1 = Paths.get(\"home/max/tmp/file.txt\");\n        Path p2 = Paths.get(\"file.txt\");\n        System.out.println(p2.resolve(p1));\n        \n    }\n\n}','file.txt/home/max/tmp/file.txt','General',1,NULL),(3170,'public class Hello<T> {\n    public static void main(String[] args){\n\n        ArrayList<? extends Animal> c = makeArrayList(new Animal(5));\n        \n        Animal max = new Animal(100);\n        Animal bear = new Animal(45);\n        Animal Hippo = new Animal(45);\n        \n        System.out.println(bear.equals(Hippo));    \n    } \n    public static <G extends Animal> ArrayList<G> makeArrayList(G g){\n        ArrayList<G> genlist = new ArrayList();\n        genlist.add(g);\n        return genlist;\n        \n    }\n}\n\nclass Animal{\n    private int size;\n    public Animal(int s){\n        size = s;\n    }\n    public void makeSound(){\n            System.out.println(\"Sound!\");\n            \n    }\n    \n    public int getSize(){\n        return size;\n    }\n\n    public boolean equals(Object o){\n        // equals without instanceof \n        if(((Animal)o).getSize() == this.size){\n            return true;\n        } else {\n            return false;\n        }\n        \n    }\n}\n\nclass Flower {\n    public void pretty(){\n        System.out.println(\"i look so pretty\");\n    }\n}','true\n\nHowever Animal does not have an instanceof test in its boolean so be \ncareful you could get a classcastexception','General',1,NULL),(3171,'public class Hello<T> {\n    public static void main(String[] args){\n\n        ArrayList<? extends Animal> c = makeArrayList(new Animal(5));\n        \n        Animal max = new Animal(100);\n        Animal bear = new Animal(45);\n        Animal Hippo = new Animal(45);\n        Flower flower = new Flower();\n        \n        System.out.println(bear.equals(Hippo));  \n        System.out.println(max.equals(flower));\n    } \n    public static <G extends Animal> ArrayList<G> makeArrayList(G g){\n        ArrayList<G> genlist = new ArrayList();\n        genlist.add(g);\n        return genlist;\n        \n    }\n}\n\nclass Animal{\n    private int size;\n    public Animal(int s){\n        size = s;\n    }\n    public void makeSound(){\n            System.out.println(\"Sound!\");\n            \n    }\n    \n    public int getSize(){\n        return size;\n    }\n\n    public boolean equals(Object o){\n        // equals without instanceof \n        if(((Animal)o).getSize() == this.size){\n            return true;\n        } else {\n            return false;\n        }\n        \n    }\n}\n\nclass Flower {\n    public void pretty(){\n        System.out.println(\"i look so pretty\");\n    }\n}','ClassCastException','General',1,NULL),(3172,'class Foo {\n    public static void classMethod() {\n        System.out.println(\"classMethod() in Foo\");\n    }\n \n    public void instanceMethod() {\n        System.out.println(\"instanceMethod() in Foo\");\n    }\n}\n \nclass Bar extends Foo {\n    public static void classMethod() {\n        System.out.println(\"classMethod() in Bar\");\n    }\n \n    public void instanceMethod() {\n        System.out.println(\"instanceMethod() in Bar\");\n    }\n}\n  \nclass Test {\n    public static void main(String[] args) {\n        Foo f = new Bar();\n        f.instanceMethod();\n        f.classMethod();\n    }\n}','instanceMethod() in Bar\nclassMethod() in Foo\n\nBriefly, when you override a method, you still get the benefits of run-time polymorphism, and when you hide, you don\'t\n\nWhy do we get instanceMethod from Bar, but classMethod() from Foo? Aren\'t we using the same instance f to access both of these? Yes we are - but since one is overriding and the other is hiding, we see different behavior.\n\nSince instanceMethod() is (drum roll please...) an instance method, in which Bar overrides the method from Foo, at run time the JVM uses the actual class of the instance f to determine which method to run. Although f was declared as a Foo, the actual instance we created was a new Bar(). So at runtime, the JVM finds that f is a Bar instance, and so it calls instanceMethod() in Bar rather than the one in Foo. That\'s how Java normally works for instance methods.\n\nWith classMethod() though. since (ahem) it\'s a class method, the compiler and JVM don\'t expect to need an actual instance to invoke the method. And even if you provide one (which we did: the instance referred to by f) the JVM will never look at it. The compiler will only look at the declared type of the reference, and use that declared type to determine, at compile time, which method to call. Since f is declared as type Foo, the compiler looks at f.classMethod() and decides it means Foo.classMethod. It doesn\'t matter that the instance reffered to by f is actually a Bar - for static methods, the compiler only uses the declared type of the reference. That\'s what we mean when we say a static method does not have run-time polymorphism.\n\nBecause instance methods and class methods have this important difference in behavior, we use different terms - \"overriding\" for instance methods and \"hiding\" for class methods - to distinguish between the two cases. And when we say you can\'t override a static method, what that means is that even if you write code that looks like it\'s overriding a static method (like the first Foo and Bar at the top of this page) - it won\'t behave like an overridden method. ','General',1,NULL),(3173,'class Bear extends Animal{\n    private static int ALLBEARSAREBIG = 100;\n    \n    public Bear(){\n        super(ALLBEARSAREBIG);\n        \n    }\n    \n    public static void eat(){\n        System.out.println(\"Eat salmon\");\n    }\n    \n}\n\nclass Animal{\n    private int size;\n    public Animal(int s){\n        size = s;\n    }\n    public static void eat(){\n        System.out.println(\"all animals eat\");\n    }\n    public void makeSound(){\n            System.out.println(\"Sound!\");\n            \n    }\n    \n    public int getSize(){\n        return size;\n    }\n\n    public boolean equals(Object o){\n        // equals without instanceof \n        if(((Animal)o).getSize() == this.size){\n            return true;\n        } else {\n            return false;\n        }\n        \n    }\n}\n\npublic class Hello<T> {\n    public static void main(String[] args){\n        Animal cat = new Animal(5);\n        Animal bear = new Bear();\n        \n        cat.eat();\n        Animal.eat();\n        bear.eat();\n        Bear.eat();\n\n    } \n }','all animals eat\nall animals eat\nall animals eat\nEat salmon\n\nIt is allowed to call a static method of the class on an instance \nvariable, but it is confusing and not recomneded. \n\nstatic variables are not overriden by subclass methods they are hidden\n\nso, at runtime there will be no polymorphism for static methods','General',1,NULL),(3174,'public class Hello<T> {\n    public static void main(String[] args){\n        Animal cat = new Animal(5);\n        Animal bear = new Bear();\n        \n        cat.eat();\n        Animal.eat();\n        bear.eat();\n        Bear.eat();\n\n    } \n }\n\nclass Animal{\n    private int size;\n    public Animal(int s){\n        size = s;\n    }\n    public static void eat(){\n        System.out.println(\"all animals eat\");\n    }\n    public void makeSound(){\n            System.out.println(\"Sound!\");\n            \n    }\n    \n    public int getSize(){\n        return size;\n    }\n\n    public boolean equals(Object o){\n        // equals without instanceof \n        if(((Animal)o).getSize() == this.size){\n            return true;\n        } else {\n            return false;\n        }\n        \n    }\n}\n\nclass Bear extends Animal{\n    private static int ALLBEARSAREBIG = 100;\n    \n    public Bear(){\n        super(ALLBEARSAREBIG);\n        \n    }\n    \n    public void eat(){\n        System.out.println(\"Eat salmon\");\n    }\n    \n}','will not compile you cannot override a static method\n\nto fix change eat in Bear to static or do something else with the other class\nand varialbes','General',1,NULL),(3175,'public class Hello<T> {\n    public static void main(String[] args){\n        Animal cat = new Animal(5);\n        Animal bear = new Bear();\n        \n        cat.eat();\n        Animal.eat();\n        bear.eat();\n        Bear.eat();\n\n    } \n }\n\nclass Animal{\n    private int size;\n    public Animal(int s){\n        size = s;\n    }\n    public static void eat(){\n        System.out.println(\"all animals eat\");\n    }\n    public void makeSound(){\n            System.out.println(\"Sound!\");\n            \n    }\n    \n    public int getSize(){\n        return size;\n    }\n\n    public boolean equals(Object o){\n        // equals without instanceof \n        if(((Animal)o).getSize() == this.size){\n            return true;\n        } else {\n            return false;\n        }\n        \n    }\n}\n\nclass Bear extends Animal{\n\n    \n    public Bear(){\n        \n    }\n    \n    public static void eat(){\n        System.out.println(\"Eat salmon\");\n    }\n    \n}\n\nclass Flower {\n    public void pretty(){\n        System.out.println(\"i look so pretty\");\n    }\n}','will not compile,\n\ncall to super in Bear defautl constructor does not fit with ANimal int constructor\n\nremeber if you provide a parameterized constructor the implicit defautl one\ngoes away','General',1,NULL),(3176,'Path p1 = Paths.get(\"/home/maxbisesi/file.txt\");\n        System.out.println(p1.resolve(null));','Will not compile, reference to resolve is ambiguous. \n\nboth resolve(String) and resolve(Path) match','Input/Output',1,NULL),(3177,'public class Hello {\n\n    public static void main(String[] args) {\n        \n        Burnable stick = new Burnable(){\n            int people = 8;\n            public void burn(){\n                System.out.println(\"Theres \"+people+\" people here so get the fire going\");\n            }\n            \n            public int unburn(){\n                System.out.println(\"That\'s impossible\");\n                return 0;\n            }\n            \n            public void shakeoff(int x){\n                System.out.println(\"That was my shoe!\"+x);\n            }\n            \n            public void shakeoff(){\n                \n                this.shakeoff(4);\n                System.out.println(\"its off\");\n            }\n            \n            \n            \n        };\n        \n        stick.burn();\n    }\n\n}\n\ninterface Burnable{\n    int people = 10;\n    void burn();\n    void shakeoff(int z);\n    int unburn();\n}','Compiles fine! you can use the overloaded method within the inner class\n\nTheres 8 people here so get the fire going','Inner Classes',1,NULL),(3178,'The thread is the worker and the runnable is the job to be done','','Threads',1,NULL),(3179,'Thread Constructors','Thread()\nThread(Runnable target)\nThread(Runnable target, String name)\nThread(String name)','Threads',1,NULL),(3180,'When is a thread considered dead?','after the run() is complete','Threads',1,NULL),(3181,'Nothing is guarenteed in threading other than Each thread will start and each thread\nwill run to completion. ','It is not guarenteed that the threads will be started in the order that\nthey are declared. Or that they will finish and start at the same time\n\nor that a loop will complete once it has begun.','Threads',1,NULL),(3182,'The order in which runnable threads are chosen to run is not guarenteed.','','Threads',1,NULL),(3183,'public class Hello {\n    public static void main(String[] dicks){\n       Thread t = new Thread(new FooRunnable());\n       t.start();\n              \n\n    }\n}\n\nclass FooRunnable implements Runnable {\n    public void run(){\n        for(int x = 1; x <= 100; x++){\n            if((x % 10) == 0){\n                System.out.println(\"next 10\");\n            }\n            System.out.println(x+\" \");\n            Thread.sleep(1000); \n            }\n            \n        }\n    }\n}','Will not compile, unreported Exception InteruptedException must be caught\nor thrown. ','Threads',1,NULL),(3184,'A thread gets a default priority that is the default priority of the thread of\nexecution that creates it. ','','Threads',1,NULL),(3185,'FooRunnable r = new FooRunnable();\nThread t = new Thread(r);\nt.setPriority(8);\nt.start();\n','default thread priority is 5','Threads',1,NULL),(3186,'Thread class constants ','Thread.MIN_PRIORITY (1)\nThread.NORM_PRIORITY (5)\nThread.MAX_PRIORITY (10)\n','Threads',1,NULL),(3187,'Thread.yeild()','will cause a thread to go from running to runnable, but it might not do\nanything at all. ','Threads',1,NULL),(3188,'join() is static','FALSE','Threads',1,NULL),(3189,'Thread t = new Thread();\nt.start();\nt.join();','takes the currently running thread(if this were in the main method then that\nwould be the main thread) and joins it onto the end of the thread\nreferenced by t. \n\n','Threads',1,NULL),(3190,'public class Hello implements Runnable{\n    private synchronized Account acct = new Account(50);\n    \n    public static void main(String[] dicks){\n       Hello h = new Hello();\n       Thread one = new Thread(h);\n       Thread two = new Thread(h);\n       one.setName(\"Max\");\n       two.setName(\"Angela\");\n       \n       one.start();\n       two.start();\n\n    }\n    \n    public void run(){\n        for(int x = 0; x < 5; x++){\n            makeWithdrawl(10);\n            if(acct.getBalance() < 0){\n                System.out.println(\"account is overdrawn\");\n            }\n        }\n    }\n    \n    private synchronized void makeWithdrawl(int amt){\n        //this operation is not atomic\n        if(acct.getBalance() >= amt){\n            System.out.println(Thread.currentThread().getName()+\" is going to withdraw\");\n            \n            try{\n                Thread.sleep(500);\n            } catch(InterruptedException e){\n                \n            }\n            \n            acct.withdraw(amt);\n            System.out.println(Thread.currentThread().getName() + \" completes the withdraw\");\n        } else {\n            System.out.println(\"insufficinet funds for: \" + Thread.currentThread().getName() );\n        }\n    }\n}','will not compile, only methods or blocks can be synchronized not variables\nor classes','Threads',1,NULL),(3191,'If a thread goes to sleeep it holds any locks it has','','Threads',1,NULL),(3192,'private JPanel createAddFlashCardPanel() {\n        JPanel jp = new JPanel(new FlowLayout());\n        \n        \n        JTextArea ja = new JTextArea(17,78);\n        ja.setWrapStyleWord(true);\n        JScrollPane question = new JScrollPane(ja);\n        ja.setTabSize(5);\n        ja.setFont(textfont);\n        \n        \n        AbstractDocument doc = (AbstractDocument) ja.getDocument();\n        doc.addDocumentListener(new TextChanger());\n        \n        class TextChanger implements DocumentListener {\n\n        @Override\n        public void insertUpdate(DocumentEvent e) {\n            try{\n                String addedtext = doc.getText(e.getOffset(), e.getLength());\n                System.out.println(addedtext);\n            } catch(BadLocationException blexc){\n                \n            }\n        }\n        @Override\n        public void removeUpdate(DocumentEvent e) {\n            \n        }\n        @Override\n        public void changedUpdate(DocumentEvent e) {\n            \n        }\n       \n    }\n  \n    ','will not compile, method local inner classes must be declared before they \nare used. ','Threads',1,NULL),(3193,' private SwingWorker<String, String> worker = new SwingWorker<String, String>() {\n        public String doInBackground() {\n            while (!searchwords.isEmpty()) {\n                String word = searchwords.poll();\n                if(word == null){\n                    continue;\n                }\n                \n                try{\n                    ArrayList<Card> foundcards = Database.searchDatabase(word);\n                } catch (IOException e){\n                    System.out.println(\"problem serarch db\");\n                }\n\n                for (Card c : foundcards) {\n\n                }\n\n            }\n        }','will not compile, foundcards is defined only in the scope of the try{}\n\nto fix \n\nput it above try{ } ','Threads',1,NULL),(3194,'public static synchronized int getCount() {\n	return count;\n}\n\nhow to could this method be re made excactly using a synchronized block ?','public static int getCount() {\n	synchronized(MyClass.class) {\n		return count;\n	}\n}\n\n- there is only one copyy of static data you\'re trying to protect so you\nonly need one lock per class to synchronize static methods- a lock for the whole class.\n\nevery class loaded in java has a corresponding instance of java.lang.Class\nrepresenting that Class. It\'s that Class instance used to lock on \nstatic methods. ','Threads',1,NULL),(3195,'public class Hello extends Thread {\n   StringBuilder sb;\n    \n    public Hello(StringBuilder stb){\n        sb = stb;\n    }\n   \n    \n    public static void main(String[] dicks){\n        StringBuilder sbmain = new StringBuilder(\"A\");  \n        Hello a = new Hello(sbmain);\n        Hello b = new Hello(sbmain);\n        Hello c = new Hello(sbmain);\n        a.start();\n        b.start();\n        c.start();\n    }\n    \n    public void run(){\n        \n        synchronized(sb){\n            for(int i = 0; i < 100; i++){\n                System.out.println(sb);\n            }\n            sb.append(\"A\");  \n        }\n    }\n}','100x A\n\n100x AA\n\n100x AAA\n\nall these threads synchronize onto the same object','Threads',1,NULL),(3196,'public class Hello extends Thread {\n   StringBuilder sb;\n    \n    public Hello(StringBuilder stb){\n        sb = stb;\n    }\n   \n    public static void main(String[] dicks){\n        StringBuilder sbmain = new StringBuilder(\"A\");  \n        Hello a = new Hello(sbmain);\n        Hello b = new Hello(sbmain);\n        Hello c = new Hello(sbmain);\n        a.start();\n        b.start();\n        c.start();\n    }  \n    public void run(){\n            for(int i = 0; i < 1000; i++){\n                System.out.println(i+\" \"+sb);\n            }\n            sb.append(\"A\");   \n    }\n}','un predicatable results - without synch. you cannot be sure what thread will\nwill be executing when. ','Threads',1,NULL),(3197,'Threads calling non-static synchronized methods in the same class will only\nblock each other if they\'re invoked using THE SAME INSTANCE. that\'s because theyeach\nlock on this instance, and if they\'re called using two differenct instances,\nthey get two locks, which do not interfere with each other. ','got it','Threads',1,NULL),(3198,'Threads calling static synchronized methods in the same class will always \nblock each other- they all lock on the same class instance. ','got it ','Threads',1,NULL),(3199,'a static synchronized method and a non-static synhcronized method will not block\neach other, ever. the static method locks on a Class instance, while the non\nstatic locks on this instance. These actions do not interfere with each other.','','Threads',1,NULL),(3200,'Generally use synchronization anytime more than one thread is accessing mutable\ndata. Dont worry about local varialbes each thread gets its own copy of those\nTwo threads executing the same method at the same time will use different\ncopiies of local variables.\n	However:\n		do worry about static and non sttaic fields if they contain data that \n		can be changed. ','','Threads',1,NULL),(3201,'public class Hello {\n    \n   public static void main (String [] args){\n       Thing thing = new Thing();\n       \n       new Thread(new Accessor(thing),\"Max\").start();\n       new Thread(new Accessor(thing),\"Bart\").start();\n       new Thread(new Accessor(thing),\"Thread C\").start();\n \n   }\n}\n\nclass Accessor implements Runnable{\n    private Thing thisthing;\n    \n    public Accessor(Thing x){\n        thisthing = x;\n    }\n    \n    public void run(){\n        thisthing.setNonstaticField(5);\n        System.out.println(thisthing.getNonstaticField());\n    }\n}\n\nclass Thing {\n    private static int staticField;\n    private int nonstaticField;\n    \n    public static synchronized int getStaticField(){\n        return staticField;\n    }\n    \n    public static synchronized void setStaticField(int x){\n        //use class not this\n        Thing.staticField = x;\n    }\n    \n    public synchronized int getNonstaticField(){\n        return nonstaticField;\n    }\n    \n    public synchronized void setNonstaticField(int y){\n        this.nonstaticField = y;\n    }\n}','5\n5\n5','Threads',1,NULL),(3202,'public class Hello {\n    \n   public static void main (String [] args){\n       Thing thing = new Thing();\n       \n       new Thread(new Accessor(thing),\"Max\").start();\n       new Thread(new Accessor(thing),\"Bart\").start();\n       new Thread(new Accessor(thing),\"Thread C\").start();\n \n   }\n}\n\nclass Accessor implements Runnable{\n    private Thing thisthing;\n    \n    public Accessor(Thing x){\n        thisthing = x;\n    }\n    \n    public void run(){\n        for(int i = 1; i <= 10; i++){\n            thisthing.setNonstaticField(i);\n            System.out.println(thisthing.getNonstaticField());\n        }\n    }\n}\n\nclass Thing {\n    private static int staticField;\n    private int nonstaticField;\n    \n    public static synchronized int getStaticField(){\n        return staticField;\n    }\n    \n    public static synchronized void setStaticField(int x){\n        //use class not this\n        Thing.staticField = x;\n    }\n    \n    public synchronized int getNonstaticField(){\n        return nonstaticField;\n    }\n    \n    public synchronized void setNonstaticField(int y){\n        this.nonstaticField = y;\n    }\n}','un predictable results, to make predictable\n\nput loop code inside a synhcronized block that locks onto thisthing!','Threads',1,NULL),(3203,'public class Hello {\n    \n   public static void main (String [] args){\n       Thing thing = new Thing();\n       \n       new Thread(new Accessor(thing),\"Max\").start();\n       new Thread(new Accessor(thing),\"Bart\").start();\n       new Thread(new Accessor(thing),\"Thread C\").start();\n \n   }\n}\n\nclass Accessor implements Runnable{\n    private Thing thisthing;\n    \n    public Accessor(Thing x){\n        thisthing = x;\n    }\n    \n    public void run(){\n        synchronized(thisthing){\n            for(int i = 1; i <= 10; i++){\n              thisthing.setNonstaticField(i);\n             System.out.println(thisthing.getNonstaticField());\n         }\n        }\n    }\n}\n\nclass Thing {\n    private static int staticField;\n    private int nonstaticField;\n    \n    public static synchronized int getStaticField(){\n        return staticField;\n    }\n    \n    public static synchronized void setStaticField(int x){\n        //use class not this\n        Thing.staticField = x;\n    }\n    \n    public synchronized int getNonstaticField(){\n        return nonstaticField;\n    }\n    \n    public synchronized void setNonstaticField(int y){\n        this.nonstaticField = y;\n    }\n}','run:\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n','Threads',1,NULL),(3204,'class SynchronizedRGB {\n\n    // Values must be between 0 and 255.\n    private int red;\n    private int green;\n    private int blue;\n    private String name;\n\n    private void check(int red,\n                       int green,\n                       int blue) {\n        if (red < 0 || red > 255\n            || green < 0 || green > 255\n            || blue < 0 || blue > 255) {\n            throw new IllegalArgumentException();\n        }\n    }\n\n    public SynchronizedRGB(int red,\n                           int green,\n                           int blue,\n                           String name) {\n        check(red, green, blue);\n        this.red = red;\n        this.green = green;\n        this.blue = blue;\n        this.name = name;\n    }\n\n    public void set(int red,\n                    int green,\n                    int blue,\n                    String name) {\n        check(red, green, blue);\n        synchronized (this) {\n            this.red = red;\n            this.green = green;\n            this.blue = blue;\n            this.name = name;\n        }\n    }\n\n    public synchronized int getRGB() {\n        return ((red << 16) | (green << 8) | blue);\n    }\n\n    public synchronized String getName() {\n        return name;\n    }\n\n    public synchronized void invert() {\n        red = 255 - red;\n        green = 255 - green;\n        blue = 255 - blue;\n        name = \"Inverse of \" + name;\n    }\n}','SynchronizedRGB must be used carefully to avoid being seen in an inconsistent state. Suppose, for example, a thread executes the following code:\n\nSynchronizedRGB color =\n    new SynchronizedRGB(0, 0, 0, \"Pitch Black\");\n...\nint myColorInt = color.getRGB();      //Statement 1\nString myColorName = color.getName(); //Statement 2\n\nIf another thread invokes color.set after Statement 1 but before Statement 2, the value of myColorInt won\'t match the value of myColorName. To avoid this outcome, the two statements must be bound together:\n\nsynchronized (color) {\n    int myColorInt = color.getRGB();\n    String myColorName = color.getName();\n} \n\nThis kind of inconsistency is only possible for mutable objects — it will not be an issue for the immutable version of SynchronizedRGB.','Threads',1,NULL),(3205,'public class Hello {\n    \n   public static void main (String [] args){\n       Thing thing = new Thing();\n       \n       new Thread(new Accessor(thing),\"Max\").start();\n       new Thread(new Accessor(thing),\"Bart\").start();\n       new Thread(new Accessor(thing),\"Thread C\").start();\n       new Thread(new staticAccessor(),\"stat Max\").start();\n       new Thread(new staticAccessor(),\"stat bart\").start();\n       new Thread(new staticAccessor(),\"stat c\").start();\n \n   }\n}\n\nclass Accessor implements Runnable{\n    private Thing thisthing;\n    \n    public Accessor(Thing x){\n        thisthing = x;\n    }\n    \n    public void run(){\n        synchronized(thisthing){\n            for(int i = 1; i <= 10; i++){\n              thisthing.setNonstaticField(i);\n             System.out.println(thisthing.getNonstaticField());\n         }\n        }\n    }\n}\n\nclass staticAccessor implements Runnable {\n    \n    public void run(){\n        synchronized(Thing.class){\n            for(int i = 30; i > 10; i--){\n                Thing.setStaticField(i);\n                System.out.println(Thing.getStaticField()+\" \");\n            }\n        }\n    }\n    \n}','run:\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n30 \n29 \n28 \n27 \n26 \n25 \n24 \n23 \n22 \n21 \n20 \n19 \n18 \n17 \n16 \n15 \n14 \n13 \n12 \n11 \n30 \n29 \n28 \n27 \n26 \n25 \n24 \n23 \n22 \n21 \n20 \n19 \n18 \n17 \n16 \n15 \n14 \n13 \n12 \n11 \n30 \n29 \n28 \n27 \n26 \n25 \n24 \n23 \n22 \n21 \n20 \n19 \n18 \n17 \n16 \n15 \n14 \n13 \n12 \n11 \n\n','Threads',1,NULL),(3206,'class DeadlockRisk {\n    private static class Resource {\n        public int value;\n    }\n    \n    private Resource resA = new Resource();\n    private Resource resB = new Resource();\n    \n    public int read() {\n        synchronized(resA) { // may deadlock\n            synchronized(resB) {\n                return resB.value + resA.value;\n            }\n        }\n    }\n    \n    public void write(int a, int b){\n        synchronized(resB){//may deadlock\n            synchronized(resA){\n                resA.value = a;\n                resB.value = b;\n            }\n        }\n    }\n}','this class may deadlock','Threads',1,NULL),(3207,'wait() notify() and notifyAll() must be called from within a synhcronized\ncontext! A thread can\'t invoke a wait or notify method on an object unless it owns \nthat object\'s lock','','Threads',1,NULL),(3208,'public class Hello {\n    \n   public static void main (String [] args){\n       \n       ThreadB b = new ThreadB();\n       b.start();\n       \n       synchronized(b) {\n           try {\n               System.out.println(\"waiting for b to complete...\");\n               b.wait();\n           } catch(InterruptedException e) { }\n           \n           System.out.println(\"Total is \" + b.total);\n       }\n \n   }\n  \n}\n\nclass ThreadB extends Thread {\n       int total;\n       \n       public void run() {\n           synchronized(this) {\n               for(int i = 0; i<100; i++){\n                   total += i;\n               }\n               \n               notify();\n           }\n       }\n   }','run:\nwaiting for b to complete...\nTotal is 4950\n\n','Threads',1,NULL),(3209,'public class Hello {\n    \n   public static void main (String [] args){\n       \n       ThreadB b = new ThreadB();\n       b.start();\n       \n       synchronized(this) {\n           try {\n               System.out.println(\"waiting for b to complete...\");\n               b.wait();\n           } catch(InterruptedException e) { }\n           \n           System.out.println(\"Total is \" + b.total);\n       }\n \n   }\n  \n}','will not compile non static variable this cannot be referenced from\na static context. ','Threads',1,NULL),(3210,'use notifyAll() to signal all waiting threads,\nnotify() will only signal one unspecified thread.','','Threads',1,NULL),(3211,'public class Hello {\n    \n   public static void main (String [] args){\n      \n        Calculator cal = new Calculator();\n        new Reader(cal).start();\n        new Reader(cal).start();\n        new Reader(cal).start();\n\n   }\n  \n}\n\nclass Reader extends Thread {\n    Calculator c;\n    \n    public Reader(Calculator calc) {\n        c = calc;\n    }\n    \n    public void run(){\n        synchronized(c) {\n            try {\n                System.out.println(\"Waiting for calc\");\n                    c.wait();\n            } catch(InterruptedException e){ }\n                \n            System.out.println(\"Total is: \"+ c.total);\n            \n        }\n    }\n}\n\nclass Calculator implements Runnable {\n    int total;\n    \n    public void run() {\n        synchronized(this) {\n            for(int i = 0; i < 100; i++){\n                total += i;\n            }\n            notifyAll();\n        }\n    }\n}','this programm will wait indefinately, \nbecause the calculator was never started so the threads will continuously\nwait for it. ','Threads',1,NULL),(3212,'public class Hello {\n    \n   public static void main (String [] args){\n      \n        Calculator cal = new Calculator();\n        new Reader(cal).start();\n        new Reader(cal).start();\n        new Reader(cal).start();\n        new Thread(cal).start();\n\n   }\n  \n}\n\nclass Reader extends Thread {\n    Calculator c;\n    \n    public Reader(Calculator calc) {\n        c = calc;\n    }\n    \n    public void run(){\n        synchronized(c) {\n            try {\n                System.out.println(\"Waiting for calc\");\n                    c.wait();\n            } catch(InterruptedException e){ }\n                \n            System.out.println(\"Total is: \"+ c.total);\n            \n        }\n    }\n}\n\nclass Calculator implements Runnable {\n    int total;\n    \n    public static void run() {\n        synchronized(this) {\n            for(int i = 0; i < 100; i++){\n                total += i;\n            }\n            notifyAll();\n        }\n    }\n}','will not compile, run() in Calculator cannot override run() in Runnable\noverriding method is static','Threads',1,NULL),(3213,'public String getSection(){\n	String[] sections = {\"ABD\",\"AfG\",\"HTL\",\"AtL\",\"MAX\",\"AKH\",\"TYU\"};	\n     List<String> sectionList = Collections.asList(sections);\n     Collections.shuffle(sectionList);\n     String ret = sectionList.get(counter);\n	counter++;\n	return ret;\n}','Will not compile Collections.asList() does not exist \n\nyour thinking of Arrays.asList();','Threads',1,NULL),(3214,' public String getSection(){\n            String[] sections = {\"ABD\",\"AfG\",\"HTL\",\"AtL\",\"MAX\",\"AKH\",\"TYU\"};\n            ArrayList sectionList = Arrays.asList(sections); \n            Collections.shuffle(sectionList);\n            String ret = sectionList.get(counter);\n            counter++;\n            return ret;\n        }','will not compile, \n\nList<String> coming from Arrays.asList cannot be converted to ArrayList.\n\nTherefore secionList should be a List<String>\n','Threads',1,NULL),(3215,'class CodeMaker{\n    private String code = \": \";\n    private static int counter = 0;\n    private String[] sections = {\"ABD\",\"AfG\",\"HTL\",\"AtL\",\"MAX\",\"AKH\",\"TYU\"};\n    \n    \n    class SectionGenerator implements Runnable{\n        //private static int counter = 0; cannot have static members in inner class\n           \n        public String getSection(){\n            \n            synchronized(CodeMaker.class){\n                //sections.size()\n                if(counter < sections.length){\n                    String sec = sections[counter];\n                    counter++;\n                    return sec;\n                }\n            }\n            return null;\n        }\n        \n        public void run() {\n            code += getSection() + \" : \";\n        }\n\n    }\n    \n    public void coder(){\n        for(int i = 0; i < 7; i++){\n            new Thread(new SectionGenerator()).start();\n        }\n        System.out.println(\"code: \"+code);\n    }\n    \n    \n}','It will print an undeterminable series of codes though they will be in order,\n\nthe getSection() method has a block that is synchronized on the CodeMake.class\nobject but that only protects static methods.\n\nso when one thread is synched on CodeMaker.class no other thread can execute \nthat same block of code, here it is no applicable because all the threads \nhave the same block of code. That counter is the same for all threads,\nwhile the sections array is copied across all instances. The array is \nnot mutated in any way though. ','Threads',1,NULL),(3216,'class CodeMaker{\n    private String code = \": \";\n    private String[] sections = {\"ABD\",\"AfG\",\"HTL\",\"AtL\",\"MAX\",\"AKH\",\"TYU\"};\n    \n    \n    class SectionGenerator implements Runnable{\n        private static int counter = 0;\n           \n        public String getSection(){\n            \n            synchronized(CodeMaker.class){\n                //sections.size()\n                if(counter < sections.length){\n                    String sec = sections[counter];\n                    counter++;\n                    return sec;\n                }\n            }\n            return null;\n        }\n        \n        public void run() {\n            code += getSection() + \" : \";\n        }\n\n    }\n    \n    public void coder(){\n        for(int i = 0; i <= 7; i++){\n            new Thread(new SectionGenerator()).start();\n        }\n        System.out.println(\"code: \"+code);\n    }\n    \n    \n}','will not compile illegal modifier static in inner class, \n\nto fix you would have to make counter final but that would defeat the\npurpose of having a counter!','Threads',1,NULL),(3217,'class CodeMaker{\n    private String code = \": \";\n    private static int counter = 0;\n    private String[] sections = {\"ABD\",\"AfG\",\"HTL\",\"AtL\",\"MAX\",\"AKH\",\"TYU\"};\n    \n    \n    class SectionGenerator implements Runnable{\n           \n        public String getSection(){\n            \n            synchronized(CodeMaker.class){\n                if(counter < sections.size()){\n                    String sec = sections[counter];\n                    counter++;\n                    return sec;\n                }\n            }\n            return null;\n        }\n        \n        public void run() {\n            code += getSection() + \" : \";\n        }\n\n    }\n    \n    public void coder(){\n        for(int i = 0; i <= 7; i++){\n            new Thread(new SectionGenerator()).start();\n        }\n        System.out.println(\"code: \"+code);\n    }\n    \n    \n}','will not compile, an array does not have a size() method \nit has a length attribute','Threads',1,NULL),(3218,'class CodeMaker{\n    private String code = \": \";\n    private static int counter = 0;\n    private String[] sections = {\"ABD\",\"AfG\",\"HTL\",\"AtL\",\"MAX\",\"AKH\",\"TYU\"};\n    \n    \n    class SectionGenerator implements Runnable{\n           \n        public String getSection(){\n            \n                if(counter < sections.length){\n                    String sec = sections[counter];\n                    counter++;\n                    return sec;\n                }\n            \n            return null;\n        }\n        \n        public void run() {\n            code += getSection() + \" : \";\n        }\n\n    }\n    \n    public void coder(){\n        for(int i = 0; i <= 7; i++){\n            new Thread(new SectionGenerator()).start();\n        }\n        System.out.println(\"code: \"+code);\n    }\n    \n    \n}','code: : AfG : HTL : AtL : MAX : \ncode: : ABD : AfG : HTL : AtL : MAX : AKH : TYU : \ncode: : ABD : AfG : HTL : AtL : MAX : AKH : TYU :\ncode: : ABD : HTL : AtL : MAX : AKH : TYU : \ncode: : ABD : AfG : HTL : AtL : MAX : AKH : TYU : \n\n...results from a few different runs. Without synchronization you cannot\nbe sure what will print because one thread could come in bewteen execution\nof getSection() and disrupt the results. This however will not change the\norder in which the code are retrieved because no matter \nhow choatic the threads execute there is no code that will\ncause static int counter to decrease or increase more than one. \n','Threads',1,NULL),(3219,'class CodeMaker{\n    private String code = \": \";\n    private int counter = 0;\n    private static String[] sections = {\"ABD\",\"AfG\",\"HTL\",\"AtL\",\"MAX\",\"AKH\",\"TYU\"};\n    \n    \n    class SectionGenerator implements Runnable{\n           \n        public String getSection(){\n            \n            synchronized(CodeMaker.class){\n            \n                if(counter < sections.length){\n                    String sec = sections[counter];\n                    counter++;\n                    return sec;\n                }\n                \n                return null;\n                \n            }\n            \n            \n        }\n        \n        public void run() {\n            code += getSection() + \" : \";\n        }\n\n    }\n    \n    public void coder(){\n        for(int i = 0; i <= 7; i++){\n            new Thread(new SectionGenerator()).start();\n        }\n        System.out.println(\"code: \"+code);\n    }\n    \n    \n}\n\npublic class Hello {\n    \n   public static void main (String [] args){\n      new CodeMaker().coder();\n\n   }\n  \n}','This code will not print accurate results as in it will not reliably\nprint all the sections. \n\nThis is becaue the reading of a code and tacking it into the complete \ncode is not an atomic operation. \n\nto uniformly print all the codes you would do this:\n\n	class SectionGenerator implements Runnable{\n\n        public void run() {\n            synchronized(CodeMaker.class){\n            \n                if(counter < sections.length){\n                    String sec = sections[counter];\n                    counter++;\n                    code += sec + \" : \";\n                }\n\n                \n            }\n        }\n\n    }','Threads',1,NULL),(3220,'class CodeMaker{\n    private String code = \": \";\n    private int counter = 0;\n    private static String[] sections = {\"ABD\",\"AfG\",\"HTL\",\"AtL\",\"MAX\",\"AKH\",\"TYU\"};\n    \n    \n    class SectionGenerator implements Runnable{\n\n        public void run() {\n            synchronized(CodeMaker.class){\n            \n                if(counter < sections.length){\n                    String sec = sections[counter];\n                    counter++;\n                    code += sec + \" : \";\n                }\n\n                \n            }\n        }\n\n    }\n    \n    public void coder(){\n        for(int i = 0; i <= 7; i++){\n            new Thread(new SectionGenerator()).start();\n        }\n        System.out.println(\"code: \"+code);\n    }\n    \n    \n}\n\npublic class Hello {\n    \n   public static void main (String [] args){\n      new CodeMaker().coder();\n\n   }\n  \n}','will print:\n\ncode: : ABD : AfG : HTL : AtL : MAX : AKH : TYU :\n\nevery time. \n\nin previous questions counter was not static, if that were the case here\nresults would not be predictable. ','Threads',1,NULL),(3221,'public class Hello {\n    \n   public static void main (String [] args){\n      new CodeMaker().coder();\n\n   }\n  \n}\n\nclass CodeMaker{\n    private String code = \": \";\n    private int counter = 0;\n    private static String[] sections = {\"ABD\",\"AfG\",\"HTL\",\"AtL\",\"MAX\",\"AKH\",\"TYU\"};\n    \n    \n    class SectionGenerator implements Runnable{\n\n        public void run() {\n            synchronized(CodeMaker.class){\n            \n                if(counter < sections.length){\n                    String sec = sections[counter];\n                    counter++;\n                    code += sec + \" : \";\n                }\n                \n            }\n        }\n\n    }\n    \n    public void coder(){\n        for(int i = 0; i <= 7; i++){\n            new Thread(new SectionGenerator()).start();\n        }\n        System.out.println(\"code: \"+code);\n    }\n    \n    \n}','will produce unpredictable results because counter is not static, so\nits access is not locked by synchronization onto CodeMaker.class\n','Threads',1,NULL),(3222,'class statPrinter {\n    private int counter = 0;\n    \n    class Adder implements Runnable {\n        \n        public void run(){\n                //Thread.sleep(1000); with no try\n                counter++;\n                System.out.println(counter + \", Adder +1 \");  \n        }\n    }\n    \n    class Minuser implements Runnable {\n        public void run() {\n                counter--;\n                System.out.println(counter+\", Minuser -1 \");    \n        }\n    }\n    \n    public void test(){\n        for(int i = 0; i < 100; i++){\n            new Thread(new Adder()).start();\n            new Thread(new Minuser()).start();\n            \n        }\n    }\n}','without synchronization here the results will be wildly unpredictable.','Threads',1,NULL),(3223,'class statPrinter {\n    private int counter = 0;\n    \n    class Adder implements Runnable {\n        \n        public void run(){\n                Thread.sleep(1000); \n                counter++;\n                System.out.println(counter + \", Adder +1 \");  \n        }\n    }\n    \n    class Minuser implements Runnable {\n        public void run() {\n                Thread.sleep(500);\n                counter--;\n                System.out.println(counter+\", Minuser -1 \");    \n        }\n    }\n    \n    public void test(){\n        for(int i = 0; i < 100; i++){\n            new Thread(new Adder()).start();\n            new Thread(new Minuser()).start();\n            \n        }\n    }\n}','will not compile, unreported interrupt exception coming from \nThread.sleep();\n\nmust wrap in try catch or declare it to be thrown','Threads',1,NULL),(3224,'class statPrinter {\n    private int counter = 0;\n    \n    class Adder implements Runnable {\n        \n        public synchronized void run(){\n                counter++;\n                System.out.println(counter + \", Adder +1 \");  \n        }\n    }\n    \n    class Minuser implements Runnable {\n        public synchronized void run() {\n                counter--;\n                System.out.println(counter+\", Minuser -1 \");    \n        }\n    }\n    \n    public void test(){\n        for(int i = 0; i < 100; i++){\n            new Thread(new Adder()).start();\n            new Thread(new Minuser()).start();\n            \n        }\n    }\n}','These results are unpredicatable, \n\nyes run() can be synched, these two methods synchronize on the current\nobject, all that means is that theyre code \n\n	counter++;\n     System.out.println(counter+\", Minuser -1 \"); \n\n	counter--;\n      System.out.println(counter+\", Minuser -1 \"); 	\n\nwill run in order completely without being interrupted by another thread.\n\nhowever that does not stop another thread from jumping the gun and being\nrun twice though!\n\n','Threads',1,NULL),(3225,'class statPrinter {\n    private int counter = 0;\n    \n    class Adder implements Runnable {\n        \n        public void run(){\n            synchronized(this){\n                counter++;\n                System.out.println(counter + \", Adder +1 \");  \n            }\n        }\n    }\n    \n    class Minuser implements Runnable {\n        public void run() {\n            synchronized(this){\n                counter--;\n                System.out.println(counter+\", Minuser -1 \");   \n            }\n        }\n    }\n    \n    public void test(){\n        for(int i = 0; i < 100; i++){\n            new Thread(new Adder()).start();\n            new Thread(new Minuser()).start();\n            \n        }\n    }\n}','this will give unpredictable results, \n\npublic void run() {\n            synchronized(this){\n                counter--;\n                System.out.println(counter+\", Minuser -1 \");   \n            }\n        }\n\nis the same as\n\npublic synchronized void run(){\n	...\n}\n\n\nthey both lock onto the current obejct, meaning no other thread can\naccess that object. The variable of concern here though is counter which\nis a variable of the statPrinter object. ','Threads',1,NULL),(3226,'class CodeMaker{\n    private String code;\n    private int counter;\n    private static String[] sections;\n    private ArrayList<String> al;\n    \n    public CodeMaker(){\n        code = \": \";\n        counter = 0;\n        sections = {\"ABD\",\"AfG\",\"HTL\",\"AtL\",\"MAX\",\"AKH\",\"TYU\"};\n        al = new ArrayList<>();\n    }\n    \n    \n    class SectionGenerator implements Runnable{\n\n        public void run() {\n            synchronized(CodeMaker.class){\n            \n                if(counter < sections.length){\n                    String sec = sections[counter];\n                    counter++;\n                    code += sec + \" : \";\n                }\n                \n            }\n        }\n\n    }\n    \n    public void coder(){\n        for(int i = 0; i <= 10; i++){\n            new Thread(new SectionGenerator()).start();\n        }\n        System.out.println(\"code: \"+code);\n    }\n    \n    \n}','Will not compile you cannot intitialize an array with shorthand like that.\nBecause, at the time of creation java wants to know excactly how \nmuch memory to allocate when you jsut create the reference you basically\ncreate nothing.\n\nin the constructor you whene you initialize you have to excplicitly\ncreate the memory with the new array using new. \n\nto compile do this:\n	\n	sections = new String[]{\"ABD\",\"AfG\",\"HTL\",\"AtL\",\"MAX\",\"AKH\",\"TYU\"};','Threads',1,NULL),(3227,'class CodeMaker{\n    private String code;\n    private int counter;\n    private static String[] sections;\n    private ArrayList<String> al;\n    \n    public synchronized CodeMaker(){\n        code = \": \";\n        counter = 0;\n        sections = new String[]{\"ABD\",\"AfG\",\"HTL\",\"AtL\",\"MAX\",\"AKH\",\"TYU\"};\n        al = new ArrayList<>();\n    }\n    \n    \n    class SectionGenerator implements Runnable{\n\n        public void run() {\n            synchronized(CodeMaker.class){\n            \n                if(counter < sections.length){\n                    String sec = sections[counter];\n                    counter++;\n                    code += sec + \" : \";\n                }\n                \n            }\n        }\n\n    }\n    \n    public void coder(){\n        for(int i = 0; i <= 10; i++){\n            new Thread(new SectionGenerator()).start();\n        }\n        System.out.println(\"code: \"+code);\n    }\n    \n    \n}','will not compile, Constructors cannot be synchronized. ','Threads',1,NULL),(3228,'class CodeMaker  extends Thread {\n    private String code;\n    private int counter;\n    private ArrayList<String> al;\n    private char[] letters = {\'A\',\'B\',\'C\',\'D\',\'E\',\'F\',\'G\',\'H\',\'I\'};\n    \n    public CodeMaker(){\n        counter = 0;\n        al = new ArrayList<>();\n    }\n\n    class SectionGenerator implements Runnable{\n        private String sec = \"\";\n        private Random ran;\n\n        public void run() {\n            //tried to use notify outside of synchronized context\n            synchronized(this){\n                int x = ran.nextInt(3);\n                int y = ran.nextInt(3);\n                int z = ran.nextInt(3);\n            \n            \n                sec += letters[x];\n                sec += letters[y];\n                sec += letters[z];\n                notifyAll();\n            }\n        }\n        \n        public synchronized String section(){\n            return sec;\n        }\n\n    }\n    \n    class NumberGenerator implements Runnable{\n        private String number = \"\";\n        private Random ran;\n        \n        public void run(){\n            //tried to use notify outside of synchronized context\n            synchronized(this){\n                int x1 = ran.nextInt(100);\n                int x2 = ran.nextInt(100);\n                int x3 = ran.nextInt(100);\n            \n                number+= x1+\".\"+x2+\".\"+x3;\n                notifyAll();\n            }\n        }\n        \n        public synchronized String Number(){\n            return number;\n        }\n    }\n    \n   public void run(){\n       \n       SectionGenerator sg1 = new SectionGenerator();\n       NumberGenerator ng1 = new NumberGenerator();\n       Thread t1 = new Thread(sg1);\n       Thread t2 = new Thread(ng1);\n       \n       t1.start();\n       t2.start();\n       \n       t1.wait();\n       code += sg1.section();\n       t2.wait();\n       code += ng1.Number();\n       \n       System.out.println(code);\n\n       \n   }\n    \n    \n}\n','will not compile becaue of wait(),\n\nureported exception, interruptedexception, must be caught or thrown\n\n','Threads',1,NULL),(3229,'class CodeMaker  extends Thread {\n    private String code;\n    private int counter;\n    private ArrayList<String> al;\n    private char[] letters = {\'A\',\'B\',\'C\',\'D\',\'E\',\'F\',\'G\',\'H\',\'I\'};\n    \n    public CodeMaker(){\n        counter = 0;\n        al = new ArrayList<>();\n    }\n\n    class SectionGenerator implements Runnable{\n        private String sec = \"\";\n        private Random ran;\n\n        public void run() {\n            //tried to use notify outside of synchronized context\n            synchronized(this){\n                int x = ran.nextInt(3);\n                int y = ran.nextInt(3);\n                int z = ran.nextInt(3);\n            \n            \n                sec += letters[x];\n                sec += letters[y];\n                sec += letters[z];\n                notifyAll();\n            }\n        }\n        \n        public synchronized String section(){\n            return sec;\n        }\n\n    }\n    \n    class NumberGenerator implements Runnable{\n        private String number = \"\";\n        private Random ran;\n        \n        public void run(){\n            //tried to use notify outside of synchronized context\n            synchronized(this){\n                int x1 = ran.nextInt(100);\n                int x2 = ran.nextInt(100);\n                int x3 = ran.nextInt(100);\n            \n                number+= x1+\".\"+x2+\".\"+x3;\n                notifyAll();\n            }\n        }\n        \n        public synchronized String Number(){\n            return number;\n        }\n    }\n    \n   public void run() throws InterruptedException {\n       \n       SectionGenerator sg1 = new SectionGenerator();\n       NumberGenerator ng1 = new NumberGenerator();\n       Thread t1 = new Thread(sg1);\n       Thread t2 = new Thread(ng1);\n       \n       t1.start();\n       t2.start();\n       \n       t1.wait();\n       code += sg1.section();\n       t2.wait();\n       code += ng1.Number();\n       \n       System.out.println(code);\n\n       \n   }\n    \n    \n}','will not compile, not a proper override of run(),\n\noverrides cannot throw new or broader checked exceptions','Threads',1,NULL),(3230,'public class Hello extends Thread {\n    public static void main(String[] args){\n        new CodeMaker().start();\n    }\n}\n\nclass CodeMaker  extends Thread {\n    private String code;\n    private int counter;\n    private ArrayList<String> al;\n    private char[] letters = {\'A\',\'B\',\'C\',\'D\',\'E\',\'F\',\'G\',\'H\',\'I\'};\n    \n    public CodeMaker(){\n        counter = 0;\n        al = new ArrayList<>();\n    }\n\n    class SectionGenerator implements Runnable{\n        private String sec = \"\";\n        private Random ran;\n\n        public void run() {\n            //tried to use notify outside of synchronized context\n            synchronized(this){\n                int x = ran.nextInt(3);\n                int y = ran.nextInt(3);\n                int z = ran.nextInt(3);\n            \n            \n                sec += letters[x];\n                sec += letters[y];\n                sec += letters[z];\n                notifyAll();\n            }\n        }\n        \n        public synchronized String section(){\n            return sec;\n        }\n\n    }\n    \n    class NumberGenerator implements Runnable{\n        private String number = \"\";\n        private Random ran;\n        \n        public void run(){\n            //tried to use notify outside of synchronized context\n            synchronized(this){\n                int x1 = ran.nextInt(100);\n                int x2 = ran.nextInt(100);\n                int x3 = ran.nextInt(100);\n            \n                number += x1+\".\"+x2+\".\"+x3;\n                notifyAll();\n            }\n        }\n        \n        public synchronized String Number(){\n            return number;\n        }\n    }\n    \n   public synchronized void run(){\n       \n       SectionGenerator sg1 = new SectionGenerator();\n       NumberGenerator ng1 = new NumberGenerator();\n       Thread t1 = new Thread(sg1);\n       Thread t2 = new Thread(ng1);\n       \n       t1.start();\n       t2.start();\n       \n       try{\n        t1.wait();\n        code += sg1.section();\n        t2.wait();\n        code += ng1.Number();\n       } catch(InterruptedException e){\n           \n       }\n       System.out.println(code);\n\n       \n   }\n    \n    \n}','NPE, ran is nevere intitialized. ','Threads',1,NULL),(3231,'public class Hello extends Thread {\n    public static void main(String[] args){\n        new CodeMaker().start();\n    }\n}\n\nclass CodeMaker  extends Thread {\n    private String code;\n    private int counter;\n    private ArrayList<String> al;\n    private char[] letters = {\'A\',\'B\',\'C\',\'D\',\'E\',\'F\',\'G\',\'H\',\'I\'};\n    \n    public CodeMaker(){\n        counter = 0;\n        al = new ArrayList<>();\n    }\n\n    class SectionGenerator implements Runnable{\n        private String sec = \"\";\n        private Random ran = new Random();\n\n        public void run() {\n            //tried to use notify outside of synchronized context\n            synchronized(this){\n                int x = ran.nextInt(3);\n                int y = ran.nextInt(3);\n                int z = ran.nextInt(3);\n            \n            \n                sec += letters[x];\n                sec += letters[y];\n                sec += letters[z];\n                notifyAll();\n            }\n        }\n        \n        public synchronized String section(){\n            return sec;\n        }\n\n    }\n    \n    class NumberGenerator implements Runnable{\n        private String number = \"\";\n        private Random ran = new Random();\n        \n        public void run(){\n            //tried to use notify outside of synchronized context\n            synchronized(this){\n                int x1 = ran.nextInt(100);\n                int x2 = ran.nextInt(100);\n                int x3 = ran.nextInt(100);\n            \n                number += x1+\".\"+x2+\".\"+x3;\n                notifyAll();\n            }\n        }\n        \n        public synchronized String Number(){\n            return number;\n        }\n    }\n    \n   public synchronized void run(){\n       \n       SectionGenerator sg1 = new SectionGenerator();\n       NumberGenerator ng1 = new NumberGenerator();\n       Thread t1 = new Thread(sg1);\n       Thread t2 = new Thread(ng1);\n       \n       t1.start();\n       t2.start();\n       \n       try{\n        t1.wait();\n        code += sg1.section();\n        t2.wait();\n        code += ng1.Number();\n       } catch(InterruptedException e){\n           \n       }\n       System.out.println(code);\n\n       \n   }\n    \n    \n}','IllegalMonitorStateException, ','Threads',1,NULL),(3232,'public class Hello extends Thread {\n    public static void main(String[] args){\n        \n    }\n    \n    class Operator extends Thread {\n        Machine machine = new Machine();\n        Machine.MachineInstructions job;\n        \n        public void run(){\n            while(true){\n                String shape = getShapeFromUser();\n                job = calculateNewInstructionsFor(shape);\n                \n                machine.addJob(job);\n            }\n        }\n        \n        public Machine.MachineInstructions calculateNewInstructionsFor(String x){\n            // dah duh duu da du\n            return machine.new MachineInstructions();\n        }\n        \n        public String getShapeFromUser(){\n            System.out.println(\"What shape? square ok thanks\");\n            return \"Square\";\n        }\n        \n    }\n    \n    class Machine extends Thread {\n        List<MachineInstructions> joblist = new ArrayList<>(0);\n        \n        public void addJob(MachineInstructions job){\n            synchronized(joblist){\n                joblist.add(job);\n                joblist.notify();\n            }\n        }\n        \n        public void run(){\n            while(true) {\n                synchronized(joblist) {\n                    //wait until at least one job is available\n                    while(joblist.isEmpty()) {\n                        try{\n                            joblist.wait();\n                        } catch(InterruptedException ei){\n                            \n                        }\n                        \n                        //if we get here you know the list is\'nt empty\n                        MachineInstructions inst = joblist.remove(0);\n                        \n                    }\n                }\n            }\n        }\n        \n        \n        static class MachineInstructions {\n            \n        }\n    }\n}','will not compile, static classes are not allowed in inner classes,\n\nonly static final varialbe definitions is allowed.','Threads',1,NULL),(3233,'public class Hello extends Thread {\n    public static void main(String[] args){\n        new Operator().start();\n        new Machine().start();\n    }\n    \n    class Operator extends Thread {\n        Machine machine = new Machine();\n        Machine.MachineInstructions job;\n        \n        public void run(){\n            while(true){\n                String shape = getShapeFromUser();\n                job = calculateNewInstructionsFor(shape);\n                \n                machine.addJob(job);\n            }\n        }\n        \n        public Machine.MachineInstructions calculateNewInstructionsFor(String x){\n            // dah duh duu da du\n            return machine.new MachineInstructions(x);\n        }\n        \n        public String getShapeFromUser(){\n            System.out.println(\"What shape? square ok thanks\");\n            return \"Square\";\n        }\n        \n    }\n    \n    class Machine extends Thread {\n        List<MachineInstructions> joblist = new ArrayList<>();\n        \n        public void addJob(MachineInstructions job){\n            synchronized(joblist){\n                joblist.add(job);\n                joblist.notify();\n            }\n        }\n        \n        public void run(){\n            while(true) {\n                synchronized(joblist) {\n                    //wait until at least one job is available\n                    while(joblist.isEmpty()) {\n                        try{\n                            joblist.wait();\n                        } catch(InterruptedException ei){\n                            \n                        }\n                        \n                        //if we get here you know the list is\'nt empty\n                        MachineInstructions inst = joblist.remove(0);\n                        \n                        \n                    }\n                }\n            }\n        }\n        \n        \n        class MachineInstructions {\n            private String shape;\n            \n            public MachinInstructions(String shape){\n                this.shape = shape;\n            }\n            public void produceShape(){\n                System.out.println(\"Here\'s your :\"+shape);\n            }\n            \n        }\n    }\n}','will not compile, non static inner classes cannot be accessed from static\nmain','Threads',1,NULL),(3234,'public class Hello extends Thread {\n    Operator op = new Operator();\n    Machine m = new Machine();\n    public static void main(String[] args){\n        op.start();\n        m.start();\n    }\n    \n    class Operator extends Thread {\n        Machine machine = new Machine();\n        Machine.MachineInstructions job;\n        \n        public void run(){\n            while(true){\n                String shape = getShapeFromUser();\n                job = calculateNewInstructionsFor(shape);\n                \n                machine.addJob(job);\n            }\n        }\n        \n        public Machine.MachineInstructions calculateNewInstructionsFor(String x){\n            // dah duh duu da du\n            return machine.new MachineInstructions(x);\n        }\n        \n        public String getShapeFromUser(){\n            System.out.println(\"What shape? square ok thanks\");\n            return \"Square\";\n        }\n        \n    }\n    \n    class Machine extends Thread {\n        List<MachineInstructions> joblist = new ArrayList<>();\n        \n        public void addJob(MachineInstructions job){\n            synchronized(joblist){\n                joblist.add(job);\n                joblist.notify();\n            }\n        }\n        \n        public void run(){\n            while(true) {\n                synchronized(joblist) {\n                    //wait until at least one job is available\n                    while(joblist.isEmpty()) {\n                        try{\n                            joblist.wait();\n                        } catch(InterruptedException ei){\n                            \n                        }\n                        \n                        //if we get here you know the list is\'nt empty\n                        MachineInstructions inst = joblist.remove(0);\n                        \n                        \n                    }\n                }\n            }\n        }\n        \n        \n        class MachineInstructions {\n            private String shape;\n            \n            public MachinInstructions(String shape){\n                this.shape = shape;\n            }\n            public void produceShape(){\n                System.out.println(\"Here\'s your :\"+shape);\n            }\n            \n        }\n    }\n}','will not compile non static instance variable cannot be referenced \nfrom static main','Threads',1,NULL),(3235,'public class Hello extends Thread {\n    private static Operator op = new Operator();\n    private static Machine m = new Machine();\n    public static void main(String[] args){\n        op.start();\n        m.start();\n    }\n    \n    class Operator extends Thread {\n        Machine machine = new Machine();\n        Machine.MachineInstructions job;\n        \n        public void run(){\n            while(true){\n                String shape = getShapeFromUser();\n                job = calculateNewInstructionsFor(shape);\n                \n                machine.addJob(job);\n            }\n        }\n        \n        public Machine.MachineInstructions calculateNewInstructionsFor(String x){\n            // dah duh duu da du\n            return machine.new MachineInstructions(x);\n        }\n        \n        public String getShapeFromUser(){\n            System.out.println(\"What shape? square ok thanks\");\n            return \"Square\";\n        }\n        \n    }\n    \n    class Machine extends Thread {\n        List<MachineInstructions> joblist = new ArrayList<>();\n        \n        public void addJob(MachineInstructions job){\n            synchronized(joblist){\n                joblist.add(job);\n                joblist.notify();\n            }\n        }\n        \n        public void run(){\n            while(true) {\n                synchronized(joblist) {\n                    //wait until at least one job is available\n                    while(joblist.isEmpty()) {\n                        try{\n                            joblist.wait();\n                        } catch(InterruptedException ei){\n                            \n                        }\n                        \n                        //if we get here you know the list is\'nt empty\n                        MachineInstructions inst = joblist.remove(0);\n                        \n                        \n                    }\n                }\n            }\n        }\n        \n        \n        class MachineInstructions {\n            private String shape;\n            \n            public MachinInstructions(String shape){\n                this.shape = shape;\n            }\n            public void produceShape(){\n                System.out.println(\"Here\'s your :\"+shape);\n            }\n            \n        }\n    }\n}','will not compile non static variable this cannot be reference from a static\ncontext. \n\nthe inner classes are instance classes so, even though you define \nthe variables as static they have to use this to access the inner class\n\nso it will still not compile','Threads',1,NULL),(3236,'public class Hello extends Thread {\n \n    public static void main(String[] args){\n        Hello h = new Hello();\n        h.new Operator().start();\n        h.new Machine().start();\n    }\n    \n    class Operator extends Thread {\n        Machine machine = new Machine();\n        Machine.MachineInstructions job;\n        \n        public void run(){\n            while(true){\n                String shape = getShapeFromUser();\n                job = calculateNewInstructionsFor(shape);\n                \n                machine.addJob(job);\n            }\n        }\n        \n        public Machine.MachineInstructions calculateNewInstructionsFor(String x){\n            // dah duh duu da du\n            return machine.new MachineInstructions(x);\n        }\n        \n        public String getShapeFromUser(){\n            System.out.println(\"What shape? square ok thanks\");\n            return \"Square\";\n        }\n        \n    }\n    \n    class Machine extends Thread {\n        List<MachineInstructions> joblist = new ArrayList<>();\n        \n        public void addJob(MachineInstructions job){\n            synchronized(joblist){\n                joblist.add(job);\n                joblist.notify();\n            }\n        }\n        \n        public void run(){\n            while(true) {\n                synchronized(joblist) {\n                    //wait until at least one job is available\n                    while(joblist.isEmpty()) {\n                        try{\n                            joblist.wait();\n                        } catch(InterruptedException ei){\n                            \n                        }\n                        \n                        //if we get here you know the list is\'nt empty\n                        MachineInstructions inst = joblist.remove(0);\n                        \n                        \n                    }\n                }\n            }\n        }\n        \n        \n        class MachineInstructions {\n            private String shape;\n            \n            public MachineInstructions(String shape){\n                this.shape = shape;\n            }\n            public void produceShape(){\n                System.out.println(\"Here\'s your :\"+shape);\n            }\n            \n        }\n    }\n}','will produce: \n	What shape? square ok thanks\n	What shape? square ok thanks\n	What shape? square ok thanks\n	What shape? square ok thanks\n...ad infinum\n\nThe conintinuos loops are meant to keep checking for new shapes. \n\nnotice that one of the threads is alwasy synched in with the jobslist\n\nthey then use wait and notify to bounce back and forth.','Threads',1,NULL),(3237,'public class Hello extends Thread {\n \n    public static void main(String[] args){\n        Hello h = new Hello();\n        h.new Operator().start();\n        h.new Machine().start();\n    }\n    \n    class Operator extends Thread {\n        Machine machine = new Machine();\n        Machine.MachineInstructions job;\n        \n        public void run(){\n            while(true){\n                String shape = getShapeFromUser();\n                job = calculateNewInstructionsFor(shape);\n                \n                machine.addJob(job);\n            }\n        }\n        \n        public Machine.MachineInstructions calculateNewInstructionsFor(String x){\n            // dah duh duu da du\n            return machine.new MachineInstructions(x);\n        }\n        \n        public String getShapeFromUser(){\n            System.out.println(\"What shape? square ok thanks\");\n            return \"Square\";\n        }\n        \n    }\n    \n    class Machine extends Thread {\n        List<MachineInstructions> joblist = new ArrayList<>();\n        \n        public void addJob(MachineInstructions job){\n            synchronized(joblist){\n                joblist.add(job);\n                joblist.notify();\n            }\n        }\n        \n        public void run(){\n            while(true) {\n                    //wait until at least one job is available\n                    while(joblist.isEmpty()) {\n                        try{\n                            joblist.wait();\n                        } catch(InterruptedException ei){\n                            \n                        }\n                        \n                        //if we get here you know the list is\'nt empty\n                        MachineInstructions inst = joblist.remove(0);\n                        \n                        \n                    }\n            }\n        }\n        \n        \n        class MachineInstructions {\n            private String shape;\n            \n            public MachineInstructions(String shape){\n                this.shape = shape;\n            }\n            public void produceShape(){\n                System.out.println(\"Here\'s your :\"+shape);\n            }\n            \n        }\n    }\n}','IllegalMonitorStateException\n\nwait in thread machine is called from outside a synchronized context\n\nyou have to synchronized on an object to wait on it. ','Threads',1,NULL),(3238,'public class Hello extends Thread {\n \n    public static void main(String[] args){\n        Hello h = new Hello();\n        h.new Operator().start();\n        h.new Machine().start();\n    }\n    \n    class Operator extends Thread {\n        Machine machine = new Machine();\n        Machine.MachineInstructions job;\n        \n        public void run(){\n            while(true){\n                String shape = getShapeFromUser();\n                job = calculateNewInstructionsFor(shape);\n                \n                machine.addJob(job);\n            }\n        }\n        \n        public Machine.MachineInstructions calculateNewInstructionsFor(String x){\n            // dah duh duu da du\n            return machine.new MachineInstructions(x);\n        }\n        \n        public String getShapeFromUser(){\n            System.out.println(\"What shape? square ok thanks\");\n            return \"Square\";\n        }\n        \n    }\n    \n    class Machine extends Thread {\n        List<MachineInstructions> joblist = new ArrayList<>();\n        \n        public void addJob(MachineInstructions job){\n                joblist.add(job);\n                joblist.notify();\n        }\n        \n        public void run(){\n            while(true) {\n                synchronized(joblist) {\n                    //wait until at least one job is available\n                    while(joblist.isEmpty()) {\n                        try{\n                            joblist.wait();\n                        } catch(InterruptedException ei){\n                            \n                        }\n                        \n                        //if we get here you know the list is\'nt empty\n                        MachineInstructions inst = joblist.remove(0);\n                        \n                        \n                    }\n                }\n            }\n        }\n        \n        \n        class MachineInstructions {\n            private String shape;\n            \n            public MachineInstructions(String shape){\n                this.shape = shape;\n            }\n            public void produceShape(){\n                System.out.println(\"Here\'s your :\"+shape);\n            }\n            \n        }\n    }\n}','IllegalMonitorStateException, \n\nnotify() in addJob is called without being synched with joblist.\n\nyou have to be synched on an object to wait on it or notify it.\n\nRemember you wait and notify objects not threads. ','Threads',1,NULL),(3239,'//ignore the answer try to figure out what wrong with this thin\npublic class Hello extends Thread {\n \n    public static void main(String[] args){\n        Hello h = new Hello();\n        h.new Operator().start();\n        h.new Machine().start();\n        new ButterFinger().start();\n    }\n    \n    class Operator extends Thread {\n        Machine machine = new Machine();\n        Machine.MachineInstructions job;\n        \n        public void run(){\n            while(true){\n                String shape = getShapeFromUser();\n                job = calculateNewInstructionsFor(shape);\n                \n                machine.addJob(job);\n            }\n        }\n        \n        public Machine.MachineInstructions calculateNewInstructionsFor(String x){\n            // dah duh duu da du\n            return machine.new MachineInstructions(x);\n        }\n        \n        public String getShapeFromUser(){\n            System.out.println(\"What shape? square ok thanks\");\n            return \"Square\";\n        }\n        \n    }\n    \n    class Machine extends Thread {\n        private List<MachineInstructions> joblist = new ArrayList<>();\n        \n        public void addJob(MachineInstructions job){\n            synchronized(joblist){\n                joblist.add(job);\n                joblist.notifyAll();\n            }\n        }\n        \n        public void run(){\n            while(true) {\n                synchronized(joblist) {\n                    //wait until at least one job is available\n                    while(joblist.isEmpty()) {\n                        try{\n                            joblist.wait();\n                        } catch(InterruptedException ei){\n                            \n                        }\n                        \n                        //if we get here you know the list is\'nt empty\n                        MachineInstructions inst = joblist.remove(0);\n                        \n                        \n                    }\n                }\n            }\n        }\n        \n        \n        class MachineInstructions {\n            private String shape;\n            \n            public MachineInstructions(String shape){\n                this.shape = shape;\n            }\n            public void produceShape(){\n                System.out.println(\"Here\'s your :\"+shape);\n            }\n            \n        }\n    }\n     \n}\n\nclass ButterFinger extends Thread {\n    private Hello h = new Hello();\n    private Hello.Machine machine = h.new Machine();\n    \n        public void run(){\n            while(true){\n                machine.addJob(machine.new MachineInstructions(\"Whoops I fucked up\"));\n            }\n            \n        }\n}','Here butterfingers is unable to get his meaty claws on the same machine \nthe operator is using becasue those two are instance classes created \nin static main, joblist is an instance variable so the one they are \nusing belongs to the instance created in main. \n\nButterFinger created his own seperated machine to fuck with here, good\nso the output will be \n\nWhat shape? square ok thanks\nWhat shape? square ok thanks\nWhat shape? square ok thanks\nWhat shape? square ok thanks     for ever and ever. ','Threads',1,NULL);
INSERT INTO `FlashCards` VALUES (3240,'public class Hello extends Thread {\n    Operator op = new Operator();\n    Machine m = new Machine();\n \n    public static void main(String[] args){\n       Hello h = new Hello();\n       h.op.start();\n       h.m.start();\n    }\n    \n    class Operator extends Thread {\n        Machine machine = new Machine();\n        Machine.MachineInstructions job;\n        \n        public void run(){\n            while(true){\n                String shape = getShapeFromUser();\n                job = calculateNewInstructionsFor(shape);\n                \n                machine.addJob(job);\n            }\n        }\n        \n        public Machine.MachineInstructions calculateNewInstructionsFor(String x){\n            // dah duh duu da du\n            return machine.new MachineInstructions(x);\n        }\n        \n        public String getShapeFromUser(){\n            System.out.println(\"What shape? square ok thanks\");\n            return \"Square\";\n        }\n        \n    }\n    \n    class Machine extends Thread {\n        private List<MachineInstructions> joblist = new ArrayList<>();\n        \n        public void addJob(MachineInstructions job){\n            synchronized(joblist){\n                joblist.add(job);\n                joblist.notifyAll();\n            }\n        }\n        \n        public void run(){\n            while(true) {\n                synchronized(joblist) {\n                    //wait until at least one job is available\n                    while(joblist.isEmpty()) {\n                        try{\n                            joblist.wait();\n                        } catch(InterruptedException ei){\n                            \n                        }\n                        \n                        //if we get here you know the list is\'nt empty\n                        MachineInstructions inst = joblist.remove(0);\n                        \n                        \n                    }\n                }\n            }\n        }\n        \n        \n        class MachineInstructions {\n            private String shape;\n            \n            public MachineInstructions(String shape){\n                this.shape = shape;\n            }\n            public void produceShape(){\n                System.out.println(\"Here\'s your :\"+shape);\n            }\n            \n        }\n    }\n     \n}\n\nclass ButterFinger extends Thread {\n    private Hello h = new Hello();\n    \n        public void run(){\n            while(true){\n                h.m.addJob(h.m.new MachineInstructions(\"Whoops I fucked up\"));\n            }\n            \n        }\n}','Butterfinger now has the right machine however the main method never\nstarts him so the output is still \n\nwhat shape? square ok thanks\nWhat shape? square ok thanks\nWhat shape? square ok thanks\nWhat shape? square ok thanks    forever...\n\nno,\n\n	Operator and Machine have no way to connect. Operator has its own\n	version of machine and therefore does not connect with the machine\n	thread that was started in main. ','Threads',1,NULL),(3241,'public class Hello {\n    public static void main(String[] args){\n        CodeMaker cm = new CodeMaker();\n        \n        for(int i = 0; i<10; i++){\n            cm.start();\n        }\n        \n    }\n}\n\nclass CodeMaker  extends Thread {\n    private String code;\n    private int counter;\n    private ArrayList<String> al;\n    private char[] letters = {\'A\',\'B\',\'C\',\'D\',\'E\',\'F\',\'G\',\'H\',\'I\'};\n    \n    public CodeMaker(){\n        counter = 0;\n        al = new ArrayList<>();\n    }\n\n    class SectionGenerator implements Runnable{\n        private String sec = \"\";\n        private Random ran = new Random();\n\n        public void run() {\n            //tried to use notify outside of synchronized context\n            synchronized(this){\n                int x = ran.nextInt(3);\n                int y = ran.nextInt(3);\n                int z = ran.nextInt(3);\n            \n            \n                sec += letters[x];\n                sec += letters[y];\n                sec += letters[z];\n                notifyAll();\n            }\n        }\n        \n        public synchronized String section(){\n            return sec;\n        }\n\n    }\n    \n    class NumberGenerator implements Runnable{\n        private String number = \"\";\n        private Random ran = new Random();\n        \n        public void run(){\n            //tried to use notify outside of synchronized context\n            synchronized(this){\n                int x1 = ran.nextInt(100);\n                int x2 = ran.nextInt(100);\n                int x3 = ran.nextInt(100);\n            \n                number += x1+\".\"+x2+\".\"+x3;\n                notifyAll();\n            }\n        }\n        \n        public synchronized String Number(){\n            return number;\n        }\n    }\n    \n    \n   public synchronized void run(){\n       \n       SectionGenerator sg1 = new SectionGenerator();\n       NumberGenerator ng1 = new NumberGenerator();\n       Thread t1 = new Thread(sg1);\n       Thread t2 = new Thread(ng1);\n       \n       t1.start();\n       t2.start();\n       \n       try{\n        t1.wait();\n        code += sg1.section();\n        t2.wait();\n        code += ng1.Number();\n       } catch(InterruptedException e){\n           \n       }\n       System.out.println(code);\n   }    ','IllegalMonitorStateException\n\nyou cannot call start() on a thread more than once. ','Threads',1,NULL),(3242,'You can call start() on a Thread object only once, otherwise you get an\nIllegalThreadStateException\n\nyou can however create many threads from the same runnable','','Threads',1,NULL),(3243,'public class Hello implements Runnable {\n\n    public static void main(String[] args) {\n        Thread t = new Thread(new Hello());\n    }\n    \n    public void run() {\n        System.out.println(\"run once\");\n    }\n}\n\n\nwhat state is this thread in ?\n\n','New State\n\nA thread that is created but not yet started is in the new state and not yet alive','Threads',1,NULL),(3244,'Once a thread is started it goes into the runnable state,\n\nThe schedular can move a thread back and forth between the runnable state and \nthe running state. \n\nA running thread may enter a blocked / waiting state by a wait, sleep, or join \ncall\n\na running thread can enter the blocked/ waiting state because it cant acquire the lock \nfor a synchroized block\n\na dead thread cannot be started again.',' got it ? ','Threads',1,NULL),(3245,'sleeping is used to delay execution for a period of time and .. \n\nno locks are released when a thread goes to sleep','','Threads',1,NULL),(3246,'A sleeping thread is thread is guarenteed to sleep for at least the time specified\nin the argument to sleep() but there is not guarentee is actually return to running\n\nthe sleep mehtod is static so it only affects the currently running thread. ','','Threads',1,NULL),(3247,'unless explicitly set a thread\'s priority will have the same priority as the thread\nthat created it. ','','Threads',1,NULL),(3248,'when one thread call join() on another thread, the currently running thhread\nwill wait until the thread it joins with has completed. Think of join() as saying\n\n\"Hey thread I want to join on to the end of you. let me know when you\'re done, so \nI can enter the runnable state\"','','Threads',1,NULL),(3249,'While only one thread can be accessing synchronized code of a particular\ninstance, multiple threads can still access the same object\'s unsynchronized code.\n\nWhen a thread goes to sleep its locks will be unavailable to other threads.','','Threads',1,NULL),(3250,'Object.wait() = add me to your waiting list.','','Threads',1,NULL),(3251,'notify() is used to send a signal to onne and onnly one of the threads that \nare waiting, it cannot specify which thread will be notified.','','Threads',1,NULL),(3252,'wait() notify() and notifyAll() must called from within a synchronized context\nthe synchronization must be with the object that the thread is calling one of these\nmethhods on !','','Threads',1,NULL),(3253,'Runnable target = new MyRunnable();\nThread myThread = new Thread(target);\n\n\npublic class MyRunnable extends Runnable{public void run(){}}\npublic class MyRunnable implements Runnable{public void start{}}\npublic class MyRunnable implements Runnable{public void run(){}}\n','the third one','Threads',1,NULL),(3254,'public class Hello extends Thread {\n    public static void main(String[] args){\n       Hello h = new Hello();\n       Thread x = new Thread(h);\n       h.start();\n        \n    }\n    \n    public void run() {\n        for(int i=0; i<3; ++i)\n            System.out.print(i+\"...\");\n    }\n}','0..1..2..','Threads',1,NULL),(3255,'public class Hello {\n    public static void main(String[] args){\n       printAll(args);\n        \n    }\n    \n    public static void printAll(String[] lines){\n        for(int i = 0; i<lines.length; i++){\n            System.out.println(lines[i]);\n            Thread.currentThread().sleep(1000);\n        }\n    }\n}\n\nwhat is the result','will not compile .sleep() must be enclosed in a try block to catch its\nInterruptedException','Threads',1,NULL),(3256,'you have two private variables a and b. prevent concurrent access problems using\ntheir read() and set(int a, int b){} methods.','public synchronized int read() { return a+b; }\npublic synchronized void set(int a, int b){this.a = a; this.b = b;}\n\npublic int read(){ synchronized(this){ return a+b; } }\npublic void set(int a, int b){synchronized(this){ this.a = a; this.b = b;} }\n\n\n','Threads',1,NULL),(3257,'public class WaitTest {\n	public static void main(String[] args){\n		sout(\"1\");\n		synchronized(args){\n			sout(\"2\");\n			try{\n				args.wait();\n			} catch(InterruptedException e) {\n			}\n		}\n		sout(\"3\");\n	}\n}\n\n1. IllegalMonitorStateException\n2. will not compile\n3. 1 2 3\n4. 1 2\n5. fails to compile because of wait() illegalMonitorstatexception','1 2 \n\nIllegalMonitorStateException is unchecked and thrown by trying to wait\nsomething yyou do not own the lock to!','Threads',1,NULL),(3258,'the following method is called from thread A on an object B and it is properly synchronized\n\nwait(2000);\n\nafter calling the method when will thread A becoma a canidate to get another \nturn at the CPU ?\n','After object B is notified, or after two seconds. ','Threads',1,NULL),(3259,'which are true ?\n\n1 the notifyAll() must be called from a synchronized context\n2 to call wati() an object must own the lock on the thread\n3 the notify() method is defined in class java.lang.thread\n4 when a thread is waiting as a result of wait() it releases its lock\n5 notify() method causes a thread to imeediately release its lock\n6 the difference between notify() and notifyAll() is that notifyAll() notifies\nall waiting threads regardless of the object theyre waiting on','1 4','Threads',1,NULL),(3260,'public class Logger {\n	private StringBuilder contents = new StringBuilder();\n	public void log(String mess){\n		contents.append(System.currentTimeMillis());\n		contents.append(\": \");\n		contents.append(Thread.currentThread().getName());\n		contents.append(mess);\n	}\n\n	public String getContents() { return contents.toString(); }\n}\n\nhow can you enxure that instances of this class can be safely used by multiple \nthreads ?\n\nreplace StringBuilder with thread-safe StringBuffer ?','synchronize both log() and getContents()\n\neven though stringbuffer is synchronized internally, append is called \nmultiple times so anythread could get in there in between calls','Threads',1,NULL),(3261,'public static synchronized void main(Stirng[] args) throws InterruptedException {\n	Thread t = new Thread();\n	t.start();\n	sout(\"X\");\n	t.wait(10000);\n	sout(\"y\");\n}','IllegalMonitorStateException is thrown because the main thread does not \nhave a lock on t before it decides to wait on it. ','Threads',1,NULL),(3262,'class MyThread extends Thread {\n	MyThread() {\n		sout(\"MyThread\");\n	}\n	public void run(){\n		sout(\"bar\");\n	}\n\n	public void run(String s){\n		sout(\"baz\");\n	}\n}\n\npublic class Test {\n	psvm(sa){\n		Thread t = new MyThread(){\n			public void run(){\n				sout(\"foo\");\n			}\n		};\n		t.start();\n	}\n}\n		','MyThread foo','Threads',1,NULL),(3263,'public class Hello {\n    public static void main(String[] args){\n       WatchService watchService\n          = FileSystems.getDefault().newWatchService();\n \n        Path path = Paths.get(System.getProperty(\"user.home\"));\n \n        path.register(\n          watchService, \n            StandardWatchEventKinds.ENTRY_CREATE, \n              StandardWatchEventKinds.ENTRY_DELETE, \n                StandardWatchEventKinds.ENTRY_MODIFY);\n \n        WatchKey key;\n        while ((key = watchService.take()) != null) {\n            for (WatchEvent<?> event : key.pollEvents()) {\n                System.out.println(\n                  \"Event kind:\" + event.kind() \n                    + \". File affected: \" + event.context() + \".\");\n            }\n            key.reset();\n        }\n        \n    }\n    \n    \n}','will not compile unreported IOException from newWatchService() and \npath.register()','Input/Output',1,NULL),(3264,'public class Hello {\n    public static void main(String[] args) throws IOException{\n       WatchService watchService\n          = FileSystems.getDefault().newWatchService();\n \n        Path path = Paths.get(System.getProperty(\"user.home\"));\n \n        path.register(\n          watchService, \n            StandardWatchEventKinds.ENTRY_CREATE, \n              StandardWatchEventKinds.ENTRY_DELETE, \n                StandardWatchEventKinds.ENTRY_MODIFY);\n \n        WatchKey key;\n        while ((key = watchService.take()) != null) {\n            for (WatchEvent<?> event : key.pollEvents()) {\n                System.out.println(\n                  \"Event kind:\" + event.kind() \n                    + \". File affected: \" + event.context() + \".\");\n            }\n            key.reset();\n        }\n        \n    }\n    \n    \n}','will not compile take() throws an InterruptedException because \nit will wait if there are no events present','Input/Output',1,NULL),(3265,'public class Hello {\n    public static void main(String[] args) throws IOException, InterruptedException {\n       WatchService watchService\n          = FileSystems.getDefault().newWatchService();\n \n        Path path = Paths.get(System.getProperty(\"user.home\"));\n \n        path.register(\n          watchService, \n            StandardWatchEventKinds.ENTRY_CREATE, \n              StandardWatchEventKinds.ENTRY_DELETE, \n                StandardWatchEventKinds.ENTRY_MODIFY);\n \n        WatchKey key;\n        while ((key = watchService.take()) != null) {\n            for (WatchEvent<?> event : key.pollEvents()) {\n                System.out.println(\n                  \"Event kind:\" + event.kind() \n                    + \". File affected: \" + event.context() + \".\");\n            }\n            key.reset();\n        }\n        \n    }\n    \n    \n}','compiles fine if you were to delete a file from home directory \nyou would get a notice like this: \n	\n	Event kind:ENTRY_CREATE. File affected: Untitled Document.\n\n','Input/Output',1,NULL),(3266,'public class Hello {\n    public static void main(String[] args) throws IOException {\n       WatchService watchService\n          = FileSystems.getDefault().newWatchService();\n \n        Path path = Paths.get(System.getProperty(\"user.home\"));\n \n        path.register(\n          watchService, \n            StandardWatchEventKinds.ENTRY_CREATE, \n              StandardWatchEventKinds.ENTRY_DELETE, \n                StandardWatchEventKinds.ENTRY_MODIFY);\n \n        WatchKey key;\n        while ((key = watchService.poll()) != null) {\n            for (WatchEvent<?> event : key.pollEvents()) {\n                System.out.println(\n                  \"Event kind:\" + event.kind() \n                    + \". File affected: \" + event.context() + \".\");\n            }\n            key.reset();\n        }\n        \n    }\n    \n    \n}','this would run one time, if there were no WatchEvents immediately available\nit would end.\nPoll() gets events and does not wait. \n\n','Input/Output',1,NULL),(3267,'Path path = Paths.get(\"/home\");\nWatchService watchService = FileSystems.getDefault().newWatchService();\nWatchKey watchKey = path.register(watchService,ENTRY_CREATE,ENTRY_DELETE,ENTRY_MODIFY);\n\nprivate boolean notDone = true;\nwhile(notDone){\n    try{\n         WatchKey watchKey = watchService.poll(60,TimeUnit.SECONDS);\n         List<WatchEvent.Kind<?>> events = watchKey.pollEvents();\n         for(WatchEvent event : events){\n            ...process the events\n         }\n         if(!watchKey.reset()){\n            ...handle situation no longer valid\n         }\n     }catch(InterruptedException e){\n            Thread.currentThread().interrupt();\n     }','...just a good example','Input/Output',1,NULL),(3268,'public class Hello {\n    public static void main(String[] dicks){\n        Thread t1 = new Thread(new Advertiser());\n        Thread t2 = new Thread(new Subleaser());\n    }\n\n}    \n\nclass MessageBoard {\n    private StringBuilder contents = new StringBuilder();\n    \n    public synchronized void postMessage(String s){\n        contents.append(s + \" \");\n    }\n    \n    public synchronized String readBoard(){\n        return contents.toString();\n    }\n    \n    public StringBuilder takeTurnAtBoard(){\n        return contents;\n    }\n}\n\nclass Advertiser implements Runnable{\n    protected MessageBoard mb = new MessageBoard();\n    public void run(){\n        synchronized(mb){\n            mb.postMessage(\"Attention!\");\n            mb.postMessage(\"Platonics\");\n            mb.postMessage(\"Lost Dog! 1000$ reward\");\n            mb.postMessage(\"Sex Change coupon\");\n            \n            System.out.println(mb.readBoard());\n        } \n    }\n}\n\nclass Subleaser{\n    private MessageBoard mb = new MessageBoard();\n    \n    public void run(){\n        synchronized(mb){\n            mb.postMessage(\"1000 a month!\");\n            mb.postMessage(\"two br\");\n            mb.postMessage(\"no dogs allowed!\");\n        }\n    }\n}','will not compile, Subleaser does not implemnet runnable!\n\nAlso the two threads synchronize on their very own messageboards so \nthey have no problem getting access to them and printing their messages.\n\nSecondly Nothing is ever printed from the MessageBoard.','Threads',1,NULL),(3269,'public class Hello {\n    public static void main(String[] dicks){\n        Thread t1 = new Thread(new Advertiser(),\"advertiser\");\n        Thread t2 = new Thread(new Subleaser(),\"subleaser\");\n        \n        t1.start();\n        t2.start();\n    }\n\n}    \n\nclass MessageBoard {\n    private StringBuilder contents = new StringBuilder();\n    \n    public synchronized void postMessage(String s){\n        contents.append(s);\n        contents.append(\" \");\n    }\n    \n    public synchronized String readBoard(){\n        return contents.toString();\n    }\n    \n    public StringBuilder takeTurnAtBoard(){\n        return contents;\n    }\n}\n\nclass Advertiser implements Runnable{\n    protected MessageBoard mb = new MessageBoard();\n    public void run(){\n            //Thread.getName() static method cannot be called from non static\n            mb.postMessage(Thread.currentThread().getName()+\" \");\n            mb.postMessage(\"Attention!\");\n            mb.postMessage(\"Platonics\");\n            mb.postMessage(\"Lost Dog! 1000$ reward\");\n            mb.postMessage(\"Sex Change coupon\");\n            \n            System.out.println(mb.readBoard());\n        \n    }\n}\n\nclass Subleaser implements Runnable{\n    private MessageBoard mb = new MessageBoard();\n    \n    public void run(){\n            mb.postMessage(Thread.currentThread().getName()+\" \");\n            mb.postMessage(\"1000 a month!\");\n            mb.postMessage(\"two br\");\n            mb.postMessage(\"no dogs allowed!\");\n            \n            System.out.println(mb.readBoard());\n        }\n}','subleaser  1000 a month! two br no dogs allowed! \nadvertiser  Attention! Platonics Lost Dog! 1000$ reward Sex Change coupon \n\nadvertiser  Attention! Platonics Lost Dog! 1000$ reward Sex Change coupon \nsubleaser  1000 a month! two br no dogs allowed!\n\nthese results can be unpredictable, though the methods are synched\nnothing is stopping another thread from coming in between append calls.\n\nto make the ressults truly predictable synchronized the postmessage calls in a block\non mb','Input/Output',1,NULL),(3270,'public class Hello {\n    public static void main(String[] dicks){\n        MessageBoard mb = new MessageBoard();\n        Thread t1 = new Thread(new Advertiser(mb),\"advertiser\");\n        Thread t2 = new Thread(new Subleaser(mb),\"subleaser\");\n        \n        t1.start();\n        t2.start();\n    }\n\n}    \n\nclass MessageBoard {\n    private StringBuilder contents = new StringBuilder();\n    \n    public synchronized void postMessage(String s){\n        contents.append(s);\n        contents.append(\" \");\n    }\n    \n    public synchronized String readBoard(){\n        return contents.toString();\n    }\n    \n    public StringBuilder takeTurnAtBoard(){\n        return contents;\n    }\n}\n\nclass Advertiser implements Runnable{\n    protected MessageBoard mb;\n    \n    public Advertiser(MessageBoard mb){\n        this.mb = mb;\n    }\n    public void run(){\n            //Thread.getName() static method cannot be called from non static\n            mb.postMessage(Thread.currentThread().getName()+\" \");\n            mb.postMessage(\"Attention!\");\n            mb.postMessage(\"Lost Dog! 1000$ reward\");\n            mb.postMessage(\"Sex Change coupon\");\n            \n            System.out.println(mb.readBoard());\n        \n    }\n}\n\nclass Subleaser implements Runnable{\n    private MessageBoard mb;\n    \n    public Subleaser(MessageBoard mb){\n        this.mb = mb;\n    }\n    \n    public void run(){\n            mb.postMessage(Thread.currentThread().getName()+\" \");\n            mb.postMessage(\"two br\");\n            mb.postMessage(\"no dogs allowed!\");\n            mb.postMessage(\"1200$ a month\");\n            \n            System.out.println(mb.readBoard());\n        }\n}\n','these can be quiet unpredictable:\n\n	subleaser  two br no dogs allowed! 1200$ a month advertiser  Attention! Lost Dog! 1000$ reward Sex Change coupon \nsubleaser  two br no dogs allowed! 1200$ a month advertiser  Attention! Lost Dog! 1000$ reward Sex Change coupon \n\nBoth threads are operating on the same instance, that instances objects\nmethods are synchronized but that doesn\'t stop the other thread from coming\ninbetween calls to postMessage()','Input/Output',1,NULL),(3271,'public class Hello {\n    public static void main(String[] dicks){\n        MessageBoard mb = new MessageBoard();\n        Thread t1 = new Thread(new Advertiser(mb),\"advertiser\");\n        Thread t2 = new Thread(new Subleaser(mb),\"subleaser\");\n        \n        t1.start();\n        t2.start();\n    }\n\n}    \n\nclass MessageBoard {\n    private StringBuilder contents = new StringBuilder();\n    \n    public synchronized void postMessage(String s){\n        contents.append(s);\n        contents.append(\" \");\n    }\n    \n    public synchronized String readBoard(){\n        return contents.toString();\n    }\n    \n    public StringBuilder takeTurnAtBoard(){\n        return contents;\n    }\n}\n\nclass Advertiser implements Runnable{\n    protected MessageBoard mb;\n    \n    public Advertiser(MessageBoard mb){\n        this.mb = mb;\n    }\n    public void run(){\n        synchronized(mb){\n            //Thread.getName() static method cannot be called from non static\n            mb.postMessage(Thread.currentThread().getName()+\" \");\n            mb.postMessage(\"Attention!\");\n            mb.postMessage(\"Lost Dog! 1000$ reward\");\n            mb.postMessage(\"Sex Change coupon\");\n            \n            System.out.println(mb.readBoard());\n        }\n    }\n}\n\nclass Subleaser implements Runnable{\n    private MessageBoard mb;\n    \n    public Subleaser(MessageBoard mb){\n        this.mb = mb;\n    }\n    \n    public void run(){\n        synchronized(mb){\n            mb.postMessage(Thread.currentThread().getName()+\" \");\n            mb.postMessage(\"two br\");\n            mb.postMessage(\"no dogs allowed!\");\n            mb.postMessage(\"1200$ a month\");\n            \n            System.out.println(mb.readBoard());\n        }\n        }\n        \n}\n','You can be assured that these results will be predictable,\n\nThe synchronized blocks get a hold of the lock so it is just a compettion\nof which thread will lock first. ','Input/Output',1,NULL),(3272,'public class Hello {\n    public static void main(String[] dicks) throws InterruptedException {\n        try{\n            WatchService watcher = FileSystems.getDefault().newWatchService();\n            Path home = Paths.get(\"/home/maxbisesi\");\n            home.register(watcher, StandardWatchEventKinds.ENTRY_CREATE,StandardWatchEventKinds.ENTRY_DELETE);\n            \n            WatchKey key;\n            \n            //throws interruptedException \n            while((key = watcher.take()) != null) {\n                for(WatchEvent<?> event : key.pollEvents()){\n                    System.out.println(event.context() + \" \" + event.kind());\n              }\n           }\n        } catch(IOException ei){\n            \n        }    \n    }\n\n}    \n\nI delete foo.txt out of the home directory then go into Documents and delete\nindex.html. What is the result ?','foo.txt ENTRY_DELETE\n\n... Watcher only watches one directory at a time, not subdirectories','Input/Output',1,NULL),(3273,'public class Starter implements Runnable {\n	void go(long id) {\n		sout(id);\n	}\n\n	public static void main(String[] args){\n		sout(Thread.currentThread().getId() + \" \");\n		//insert code\n	}\n	public void run() { go(Thread.currentThread().getId()); }\n}\n\n1. new Starter().run();\n2. new Starter().start();\n3. new Thread(new Starter());\n4. new Thread(new Starter()).run();\n5. new Thread(new Starter()).start();','1. 4 4 \n2. does not compile\n3. prints nothign , but starts a new thread\n4. creates a new thread and invokes run() directlyy\n5. creates and starts a new thread. ','Input/Output',1,NULL),(3274,'public class Hello implements Runnable {\n    public void run(){\n        System.out.println(\"r1 \");\n        System.out.println(\"r2 \");\n    }\n    public static void main(String[] args){\n        Thread t = new Thread(new Hello());\n        t.start();\n        System.out.println(\"m1 \");\n        t.join();\n        System.out.println(\"m2 \");\n    }\n}','will not commpile, join throws interruptedexception ','Input/Output',1,NULL),(3275,'public class Hello implements Runnable {\n    public void run(){\n        System.out.println(\"r1 \");\n        System.out.println(\"r2 \");\n    }\n    public static void main(String[] args){\n        Thread t = new Thread(new Hello());\n        t.start();\n        System.out.println(\"m1 \");\n        try{\n            t.join();\n        } catch(InterruptedException e){\n            \n        }\n        System.out.println(\"m2 \");\n    }\n}','could be:\n\nm1 r1 r2 m2\nr1 m1 r2 m2\nr1 r2 m1 m2\n\njoin throws interruptedexception, it causes main to join onto the end\nof the thread t and wait till its done to continue. ','Input/Output',1,NULL),(3276,'public class Hello implements Runnable {\n    Chicks c;\n    public void run(){\n       c.yack(Thread.currentThread().getId());\n    }\n    public static void main(String[] args){\n        new Hello().go();\n       \n    }\n    \n    void go(){\n        c = new Chicks();\n        new Thread(new Hello()).start();\n        new Thread(new Hello()).start();\n    }\n}\n\nclass Chicks {\n    synchronized void yack(long id){\n        for(int x = 1; x <3; x++){\n            System.out.println(id + \" \");\n            Thread.yield();\n        }\n    }\n}','NullpointerException,\n\nthis one is hard to spot but c is initialized in the go method, an \ninstance method. The two threads start their own new instance and go\ndirectly to the run() method, without go() c never gets initialized. \n\nfor this to work c would have to be static. \n','Input/Output',1,NULL),(3277,'public class Hello implements Runnable {\n    static Chicks c;\n    public void run(){\n       c.yack(Thread.currentThread().getId());\n    }\n    public static void main(String[] args){\n        new Hello().go();\n       \n    }\n    \n    void go(){\n        c = new Chicks();\n        new Thread(new Hello()).start();\n        new Thread(new Hello()).start();\n    }\n}\n\nclass Chicks {\n    synchronized void yack(long id){\n        for(int x = 1; x <3; x++){\n            System.out.println(id + \" \");\n            Thread.yield();\n        }\n    }\n}','8\n8\n9\n9','Input/Output',1,NULL),(3278,'public class Hello implements Runnable {\n    static Chicks c;\n    public void run(){\n       c.yack(Thread.currentThread().getId());\n    }\n    public static void main(String[] args){\n        new Hello().go();\n       \n    }\n    \n    void go(){\n        c = new Chicks();\n        new Thread(new Hello()).start();\n        new Thread(new Hello()).start();\n    }\n}\n\nclass Chicks {\n    static long flag = 0;\n    synchronized void yack(long id){\n        if(flag == 0) flag = id;\n        for(int x = 1; x <3; x++){\n            if(flag == id) System.out.println(\"yada yada \");\n            else System.out.println(\"ehh \");\n        }\n    }\n}','','Input/Output',1,NULL),(3279,'public class Hello implements Runnable {\n    public void run(){\n       move(Thread.currentThread().getId());\n    }\n    \n    void move(long id){\n        System.out.println(id + \" \");\n        System.out.println(id + \" \");\n    }\n    public static void main(String[] args){\n        Hello h = new Hello();\n        new Thread(h).start();\n        new Thread(new Hello()).start();\n    }\n}','the output could be 8 9 8 9\n\n..it could be anything really','Input/Output',1,NULL),(3280,'public class Hello implements Runnable {\n    public void run(){\n       move(Thread.currentThread().getId());\n    }\n    \n    synchronized void move(long id){\n        System.out.println(id + \" \");\n        System.out.println(id + \" \");\n    }\n    public static void main(String[] args){\n        Hello h = new Hello();\n        new Thread(h).start();\n        new Thread(new Hello()).start();\n    }\n}','the output could be 4 2 4 2\n\nWhile the method is synhcronized it is being invoked by two different\nobjects so they could print in any order still \n\n','Input/Output',1,NULL),(3281,'test	','test','Input/Output',1,NULL),(3282,'Which method from a CopyOnWriteArrayList will caue a new copy of the internal\narray to be created ?','add  and  remove','Input/Output',1,NULL),(3283,'public class Hello {\n    public static void main(String[] args){\n        new ReentrantLockingDemo().go();\n    }\n}\n\nclass ReentrantLockingDemo {\n\n    final Lock lock = new ReentrantLock();\n\n    public void go() {\n\n        Runnable run1 = newRunable();\n        Thread t1 = new Thread(run1, \"Thread1\");\n        System.out.println(run1.hashCode());\n        t1.start();\n\n        Runnable run2 = newRunable();\n        Thread t2 = new Thread(run2, \"Thread2\");\n        System.out.println(run2.hashCode());\n        t2.start();\n\n    }\n\n    private Runnable newRunable() {\n        return new Runnable() {\n            public int hashCode() {\n                return super.hashCode();\n            }\n            public void run() {\n                do {\n                    try {\n                        if (lock.tryLock(500, TimeUnit.MILLISECONDS)) {\n                            try {\n                                System.out.println(\"locked thread \"\n                                        + Thread.currentThread().getName());\n                                Thread.sleep(1000);\n                            } finally {\n                                lock.unlock();\n                                System.out.println(\"unlocked locked thread \"\n                                        + Thread.currentThread().getName());\n                            }\n                            break;\n                        } else {\n                            System.out.println(\"unable to lock thread \"\n                                    + Thread.currentThread().getName()\n                                    + \" will re try again\");\n                        }\n                    } catch (InterruptedException e) {\n                        e.printStackTrace();\n                    }\n                } while (true);\n            }     \n        };\n    }\n\n}','2018699554\n1311053135\nlocked thread Thread1\nunable to lock thread Thread2 will re try again\nunlocked locked thread Thread1\nlocked thread Thread2\nunlocked locked thread Thread2\n\nThe two threads use two different Runnables, but they are both vying for the same\nlock. ','Input/Output',1,NULL),(3284,'public class ThreadTest {\n	class InnerRun implements Runnable {\n		public void run() {\n			for(int x = 0; x < 100; x++){\n				try{\n					Thread.sleep(5);\n				} catch(Exception e) {}\n				sout( \"Ren\" );\n			}\n		}\n	}\n\n	class InnerRunTwo implements Runnable {\n		Thread other;\n		public InnerRunTwo(Thread x){ other = x; }\n		public void run() {\n			try{\n				other.join();\n			} catch(Exception e) { }\n			for(int x = 0; x < 100; x++){\n			   try{\n				Thread.sleep(5);\n			   } catch( Exception e) { }\n			   sout( \"stimpy\" );\n			}\n		}	\n	}\nvoid start(){\n	InnerRun ir = new InnerRun();\n	Thread t = new Thread(ir);\n	InnerRunTwo irr = new InnerRunTwo(t);\n	Thread u = new Thread(irr);\n		t.start();	\n		u.start();\n}\npsvm(SA){ ThreadTest tt = new ThreadTest(); tt.start(); }\n}','How a join should be used and implemented. \n\n100 Rens followed by 100 stimpys','Input/Output',1,NULL),(3285,'public class Hello {\n    public static void main(String[] args){\n        Data data = new Data();\n        DataThread dt = new DataThread(data);\n        Thread t1 = new Thread(dt);\n        Thread t2 = new Thread(dt);\n        Thread t3 = new Thread(dt);\n        Thread t4 = new Thread(dt);\n        Thread t5 = new Thread(dt);\n        \n        t1.start();\n        t2.start();\n        t3.start();\n        t4.start();\n        t5.start();\n        \n    }\n}\n\nclass Data {\n    public Object lock = new Object();\n    public static Object staticLock = new Object();\n    \n    public synchronized void instanceLocked(){\n        System.out.println(\"Instance locked by: \"+Thread.currentThread().getName());\n    }\n    \n    public static synchronized void classLocked(){\n        System.out.println(\"class locked by: \"+Thread.currentThread().getName());\n        while(true){\n            \n        }\n    }\n}\n\nclass DataThread implements Runnable {\n    private Data data;\n    \n    public DataThread(Data data){\n        this.data = data;\n    }\n    public void run(){\n        synchronized(data.lock){\n            \n            for(int i = 0; i<100; i++){\n                data.instanceLocked();\n                System.out.println(i);\n                \n                try{\n                    Thread.sleep(1000);\n                } catch(InterruptedException e){\n                    \n                }\n            }\n            \n        }\n    }\n    \n}','run:\nInstance locked by: Thread-0\n0\nInstance locked by: Thread-0\n1\nInstance locked by: Thread-0\n2\nInstance locked by: Thread-0\n3\nInstance locked by: Thread-0\n4\nInstance locked by: Thread-0\n5\nInstance locked by: Thread-0\n6\nInstance locked by: Thread-0\n7\nInstance locked by: Thread-0\n8\nInstance locked by: Thread-0\n9\nInstance locked by: Thread-0\n10\nBUILD STOPPED (total time: 10 seconds)\n','Input/Output',1,NULL),(3286,'public class Hello {\n    public static void main(String[] args){\n         final Safelock.Friend alphonse =\n            new Safelock.Friend(\"Alphonse\");\n        final Safelock.Friend gaston =\n            new Safelock.Friend(\"Gaston\");\n        new Thread(new Safelock.BowLoop(alphonse, gaston)).start();\n        new Thread(new Safelock.BowLoop(gaston, alphonse)).start();\n    }\n}\n\nclass Safelock {\n    static class Friend {\n        private final String name;\n        private final Lock lock = new ReentrantLock();\n\n        public Friend(String name) {\n            this.name = name;\n        }\n\n        public String getName() {\n            return this.name;\n        }\n\n        public boolean impendingBow(Friend bower) {\n            Boolean myLock = false;\n            Boolean yourLock = false;\n            try {\n                myLock = lock.tryLock();\n                yourLock = bower.lock.tryLock();\n            } finally {\n                if (! (myLock && yourLock)) {\n                    if (myLock) {\n                        lock.unlock();\n                    }\n                    if (yourLock) {\n                        bower.lock.unlock();\n                    }\n                }\n            }\n            return myLock && yourLock;\n        }\n            \n        public void bow(Friend bower) {\n            if (impendingBow(bower)) {\n                try {\n                    System.out.format(\"%s: %s has\"\n                        + \" bowed to me!%n\", \n                        this.name, bower.getName());\n                    bower.bowBack(this);\n                } finally {\n                    lock.unlock();\n                    bower.lock.unlock();\n                }\n            } else {\n                System.out.format(\"%s: %s started\"\n                    + \" to bow to me, but saw that\"\n                    + \" I was already bowing to\"\n                    + \" him.%n\",\n                    this.name, bower.getName());\n            }\n        }\n\n        public void bowBack(Friend bower) {\n            System.out.format(\"%s: %s has\" +\n                \" bowed back to me!%n\",\n                this.name, bower.getName());\n        }\n    }\n\n    static class BowLoop implements Runnable {\n        private Friend bower;\n        private Friend bowee;\n\n        public BowLoop(Friend bower, Friend bowee) {\n            this.bower = bower;\n            this.bowee = bowee;\n        }\n    \n        public void run() {\n            Random random = new Random();\n            for (;;) {\n                try {\n                    Thread.sleep(random.nextInt(10));\n                } catch (InterruptedException e) {}\n                bowee.bow(bower);\n            }\n        }\n    }\n}','Gaston: Alphonse has bowed to me!\nAlphonse: Gaston started to bow to me, but saw that I was already bowing to him.\nAlphonse: Gaston has bowed back to me!\nAlphonse: Gaston has bowed to me!\nGaston: Alphonse has bowed back to me!\nAlphonse: Gaston has bowed to me!\nGaston: Alphonse has bowed back to me!\nGaston: Alphonse has bowed to me!\nAlphonse: Gaston has bowed back to me!\nAlphonse: Gaston has bowed to me!\nGaston: Alphonse has bowed back to me!\nGaston: Alphonse has bowed to me!\nAlphonse: Gaston has bowed back to me!\nAlphonse: Gaston has bowed to me!\nGaston: Alphonse has bowed back to me!\nGaston: Alphonse has bowed to me!\nAlphonse: Gaston has bowed back to me!\nAlphonse: Gaston has bowed to me!\nGaston: Alphonse has bowed back to me!\nGaston: Alphonse has bowed to me!\nAlphonse: Gaston has bowed back to me!\nGaston: Alphonse has bowed to me!\nAlphonse: Gaston has bowed back to me!\nAlphonse: Gaston has bowed to me!\nGaston: Alphonse has bowed back to me!\nAlphonse: Gaston has bowed to me!\nGaston: Alphonse has bowed back to me!\nGaston: Alphonse has bowed to me!\nAlphonse: Gaston has bowed back to me!\nAlphonse: Gaston has bowed to me!\nGaston: Alphonse has bowed back to me!\nGaston: Alphonse started to bow to me, but saw that I was already bowing to him.\nAlphonse: Gaston has bowed to me!\nGaston: Alphonse has bowed back to me!\nAlphonse: Gaston has bowed to me!\nGaston: Alphonse has bowed back to me!','Input/Output',1,NULL),(3287,'class BoundedBuffer {\n   final Lock lock = new ReentrantLock();\n   final Condition notFull  = lock.newCondition(); \n   final Condition notEmpty = lock.newCondition(); \n\n   final Object[] items = new Object[100];\n   int putptr, takeptr, count;\n\n   public void put(Object x) throws InterruptedException {\n     lock.lock();\n     try {\n       while (count == items.length)\n         notFull.await();\n       items[putptr] = x;\n       if (++putptr == items.length) putptr = 0;\n       ++count;\n       notEmpty.signal();\n     } finally {\n       lock.unlock();\n     }\n   }\n\n   public Object take() throws InterruptedException {\n     lock.lock();\n     try {\n       while (count == 0)\n         notEmpty.await();\n       Object x = items[takeptr];\n       if (++takeptr == items.length) takeptr = 0;\n       --count;\n       notFull.signal();\n       return x;\n     } finally {\n       lock.unlock();\n     }\n   }\n }','good example of Conditions','Input/Output',1,NULL),(3288,'class DataThread implements Runnable {\n    private Data data;\n    private ArrayList listData;\n    \n    public DataThread(Data data){\n        this.data = data;\n    }\n    public void run(){\n            data.lock.lock();\n            try{\n                listData = data.produceData();\n            try{\n               data.done.await();\n            } catch(InterruptedException e){\n                \n            }\n            \n            for(Integer i : listData){\n                System.out.println(i);\n            }\n            } finally {\n                data.lock.unlock();\n            }\n    }\n    \n}','Will not compile, ArrayList listData is a raw type so in the foreach loop\nyou assign them to an Integer, you would have had to cast','Input/Output',1,NULL),(3289,'public class Hello {\n    private List<Integer> integers = new ArrayList<>();\n    private ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();\n    \n    public void add(Integer i){\n        rwl.writeLock().lock();\n        try {\n            integers.add(i);\n        } finally {\n            rwl.writeLock().unlock();\n        }\n    }\n    \n    public int findMax() {\n        rwl.readLock().lock();\n        try {\n            return Collections.max(integers);\n        } finally {\n            rwl.readLock().unlock();\n        }\n    }\n    public static void main(String[] args){\n      \n    }\n\n}','With ReentrantReadWriteLock you can grant write access to only one thread, but\nit is possible to allow many threads to be reading at the same time. ','Input/Output',1,NULL),(3290,'read-only(immutabel) objects are always thread safe. ','','Input/Output',1,NULL),(3291,'Use copy on write collections when...','your data sets remain small and the number of read operations and traversals greatly outnumber\nmodifications to the collection. \n\nCopy on write collections work by copying their internal array of data with\nany mutating operation. This copied array will replace the original read only\narrray. \n\nThis allows it to be safely shared between multiple threads. ','Input/Output',1,NULL),(3292,'Just because a collection is thread safe does not make the elements stored within\nthread safe','','Input/Output',1,NULL),(3293,'The Iterator for a concurrent collection is weakly consistent; it can return elements \nfrom the point in time the Iterator was created or LATER. This means that \nwhile looping through a concurrent collection, you might observel elements that\nare being inserted by other threads. also you might see only some of the elements\nthat another thread is inserting. ','','Input/Output',1,NULL),(3294,'Which concurrent Collections are sorted ?','ConcurrentSkipListMap and ConcurrentSkipListSet \n\n-They require the use of comparable and comparotr to enable ordering. ','Input/Output',1,NULL),(3295,'copy on write and concurrent collections are centered on the idea of multiple\nthreads sharing data. \n\nA BlockingQueue is used to exchnage data between two or more threads while causing\nsome of the threads to wait until the point in time when the data can be \ntransfered. ','','Input/Output',1,NULL),(3296,'class Hello {\n    public static void main(String[] args) {     \n        Pattern p = Pattern.compile(\"\\\\B\\\\d\\\\B\");\n        Matcher m = p.matcher(\"Th4t\'ll b3 the d4y, on th3 v3ry l6ast d8y\");\n        \n        while(m.find()){\n            System.out.println(m.group());\n        }\n        \n    }\n\n}','4\n4\n3\n6\n8\n\nto indicate that you want a pattern to be surrounded by other similar characteres\nsurround it with non word boundaries. If you did want the character to \nbee alone surround it with word boudaries.','Strings',1,NULL),(3297,'BlockingQueue implementations','ArrayBlockingQueue\nLinkedBlockingQueue\nLinkedBlockingQueue\nPriorityBlockingQueue\nDelayQueue\nLinkedTransferQueue\nSynchronousQueue\n','Concurrency',1,NULL),(3298,'A blocking collection, depending on the method being called, may cause a thread to block\nuntil another threads calls a corresponding method on the collection. \n\nif you attempt to reemove an element() by calling take() on any BlockingQueue\nthat is empty, the operation will block until another thread inserts an element.\n','','Concurrency',1,NULL),(3299,'BlockingQueue method:\n\nadd(E e)','Returns true if object added,\n\nfalse if duplicate objects are not allowed.\n\nThrows IllegalStateException if the queue is bounded and full','Concurrency',1,NULL),(3300,'BlockingQueue method:\n\noffer(E e)','returns true if object added, false if the queue is bounded and full','Concurrency',1,NULL),(3301,'BlockingQueue method:\n\nput(E e)','returns void.\n\nwill block until space in the queue becomes available if needed ','Concurrency',1,NULL),(3302,'offer(E e, long timeout, TimeUnit unit)','returns false if the object was not able to be inserted before the time idicated,\n','Concurrency',1,NULL),(3303,'BlockingQueue method:\n\nremove(Object o)','returns true if an equal object was found in the queue and removed; \notherwise returns false.','Concurrency',1,NULL),(3304,'BlockingQueue method:\n\npoll(long timeout, TimeUnit unit)','removes the first object in the queue and returns it. \n\nif the timeout expires before an object can be removed becaue the queue is empty\nthen a null will be returned. ','Concurrency',1,NULL),(3305,'BlockingQueue method:\n\ntake()','Removes and returns the first object in the queue, blocking if needed until the \nobject becomes available. \n\nonly throws InterruptedException','Concurrency',1,NULL),(3306,'BlockingQueue method:\n\npoll()','removes and returns the first object in the queue and returns null if the queue is empty\n','Concurrency',1,NULL),(3307,'BlockingQueue method:\n\nelement()','Gets the head of the queue without removing it, Throws a NoSuchElementException\nif the queue is empty. ','Concurrency',1,NULL),(3308,'BlockingQueue method:\n\npeek()','gets the head of the queue without removing it, Returns a null if the queue is \nempty. ','Concurrency',1,NULL),(3309,'BlockingQueue<Integer> bq = new ArrayBlockingQueue<>(1);\n\ntry{\n	bq.put(34);\n	bq.put(35);\n} catch(InterruptedException e) {}','The second put(35) will block until previous values is removed by another thread.','Concurrency',1,NULL),(3310,'SynchronousQueue','...is a speciel type of bounded blocking queue; it has a capacity of \nzero. The first thread to attempt either an insert or remvoe operaion\non a synchronousQueue will block until another thread performs the opposite \noperation. USe this when you need threads to meet up and exchange an object.','Concurrency',1,NULL),(3311,'public class Hello {\n    public static void main(String[] args){\n       CopyOnWriteArrayList<Integer> list = new CopyOnWriteArrayList<>();\n       \n       list.add(5);\n       list.add(9);\n       Iterator<Integer> it = list.iterator();\n       \n       list.add(3);\n       \n       while(it.hasNext()){\n           System.out.println(it.next());\n       }\n    }\n}','5\n9\n\nThe iterator was obtained before the 3 was added. As long as the reference to \nthe iterator is maintained it will only provide access to 5 9.\n\nIt is ConcurrentCollections that will remain weakly consistant with the changes\nmade by other threads, This is a copyonwrite array list which is thread safe but\nnot concurrent.','Concurrency',1,NULL),(3312,'public class Hello {\n    public static void main(String[] args){\n       CopyOnWriteArrayList<Integer> cowlist = new CopyOnWriteArrayList<>();\n       \n       cowlist.add(5);\n       cowlist.add(9);\n       cowlist.add(4);\n       \n       Iterator<Integer> it = cowlist.iterator();\n       \n       cowlist.remove(2);\n       \n       while(it.hasNext()){\n           System.out.println(it.next());\n       }\n       \n    }\n}','5\n9\n4\n\nThe iterator is obtained before the element at index 2 is removed.','Concurrency',1,NULL),(3313,'public class Hello {\n    public static void main(String[] args){\n       CopyOnWriteArrayList<Integer> cowlist = new CopyOnWriteArrayList<>();\n       \n       cowlist.add(5);\n       cowlist.add(9);\n       cowlist.add(4);\n       \n       Iterator<Integer> it = cowlist.iterator();\n       \n       cowlist.remove(5);\n       \n       while(it.hasNext()){\n           System.out.println(it.next());\n       }\n       \n    }\n}','IndexOutofBoundsException \n\nthis can be confusing here the remove(int index) is being used. \n\nto fix do this\n\ncowlist.remove(new Integer(5));','Concurrency',1,NULL),(3314,'Which methods from copyonwritearraylist will cause a new copy of the internal\narray to be created\n\nadd\nget\niterator\nremove','add and remove. These are the only methods shown that modify the list','Concurrency',1,NULL),(3315,'ArrayBlockingQueue<Integer> abq = new ArrayBlockingQueue<>(10);\n\nwhich operation can block indefinitely\n\nabq.add(1);\nabq.offer(1);\nabq.put(1);\nabq.offer(1,5,TimeUnit.SECONDS);','only put()','Concurrency',1,NULL),(3316,'public class Hello implements Runnable {\n    private static ArrayBlockingQueue<Integer> abq = new ArrayBlockingQueue<>(10);\n    public static void main(String[] args){\n       Hello h = new Hello();\n       Thread t1 = new Thread(h);\n       Thread t2 = new Thread(h);\n       Thread t3 = new Thread(h);\n       Thread t4 = new Thread(h);\n       \n       t1.start();\n       t2.start();\n       t3.start();\n       t4.start();\n       \n    }\n    public void run(){\n        for(int i = 0; i<5; i++){\n            abq.add(i);\n        }\n    }\n}','IllegalStateEXception queue is full','Concurrency',1,NULL),(3317,'public class Hello implements Runnable {\n    private static ArrayBlockingQueue<Integer> abq = new ArrayBlockingQueue<>(10);\n    public static void main(String[] args){\n       Hello h = new Hello();\n       Thread t1 = new Thread(h);\n       Thread t2 = new Thread(h);\n       Thread t3 = new Thread(h);\n       Thread t4 = new Thread(h);\n       \n       t1.start();\n       t2.start();\n       t3.start();\n       t4.start();\n       \n    }\n    public void run(){\n        for(int i = 0; i<5; i++){\n            System.out.println(abq.add(i));\n        }\n    }\n}','true\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\nException in thread \"Thread-2\" java.lang.IllegalStateException: Queue full\n	at java.util.AbstractQueue.add(AbstractQueue.java:98)\n	at java.util.concurrent.ArrayBlockingQueue.add(ArrayBlockingQueue.java:312)\n	at hello.Hello.run(Hello.java:27)\n	at java.lang.Thread.run(Thread.java:745)\nException in thread \"Thread-3\" java.lang.IllegalStateException: Queue full\n	at java.util.AbstractQueue.add(AbstractQueue.java:98)\n	at java.util.concurrent.ArrayBlockingQueue.add(ArrayBlockingQueue.java:312)\n	at hello.Hello.run(Hello.java:27)\n	at java.lang.Thread.run(Thread.java:745)','Concurrency',1,NULL),(3318,'public class Hello implements Runnable {\n    private static ArrayBlockingQueue<Integer> abq = new ArrayBlockingQueue<>(10);\n    public static void main(String[] args){\n       Hello h = new Hello();\n       Thread t1 = new Thread(h);\n       Thread t2 = new Thread(h);\n       Thread t3 = new Thread(h);\n       Thread t4 = new Thread(h);\n       \n       t1.start();\n       t2.start();\n       t3.start();\n       t4.start();\n       \n    }\n    public void run(){\n        for(int i = 0; i<5; i++){\n            System.out.println(abq.offer(i));\n        }\n    }\n}','offer() Inserts the specified element at the tail of this queue if \nit is possible to do so immediately \nwithout exceeding the queue\'s capacity, \nreturning true upon success and false if this queue is full. \nThis method is generally preferable to method add(E), which can fail to insert an element \nonly by throwing an exception.\n\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\nfalse\nfalse\nfalse\nfalse\nfalse\nfalse\nfalse\nfalse\nfalse\nfalse','Concurrency',1,NULL),(3319,'public class Hello implements Runnable {\n    private static ArrayBlockingQueue<Integer> abq = new ArrayBlockingQueue<>(10);\n    public static void main(String[] args){\n       Hello h = new Hello();\n       Thread t1 = new Thread(h);\n       Thread t2 = new Thread(h);\n       Thread t3 = new Thread(h);\n       Thread t4 = new Thread(h);\n       \n       t1.start();\n       t2.start();\n       t3.start();\n       t4.start();\n       \n    }\n    public void run(){\n        for(int i = 0; i<5; i++){\n            System.out.println(abq.put(i));\n        }\n    }\n}','will not compile, .put() return void and blocks until space becomes available\n\n\'void\' is not allowed is sout();','Concurrency',1,NULL),(3320,'public class Hello implements Runnable {\n    private static ArrayBlockingQueue<Integer> abq = new ArrayBlockingQueue<>(10);\n    public static void main(String[] args){\n       Hello h = new Hello();\n       Thread t1 = new Thread(h);\n       Thread t2 = new Thread(h);\n       Thread t3 = new Thread(h);\n       Thread t4 = new Thread(h);\n       \n       t1.start();\n       t2.start();\n       t3.start();\n       t4.start();\n       \n    }\n    public void run(){\n        for(int i = 0; i<5; i++){\n            abq.put(i);\n        }\n    }\n}','Will not compile,\n\nput will block, therefore it may throw an interruptedException\n\nsurround with try catch','Concurrency',1,NULL),(3321,'public class Hello implements Runnable {\n    private static ArrayBlockingQueue<Integer> abq = new ArrayBlockingQueue<>(10);\n    public static void main(String[] args){\n       Hello h = new Hello();\n       Thread t1 = new Thread(h);\n       Thread t2 = new Thread(h);\n       Thread t3 = new Thread(h);\n       Thread t4 = new Thread(h);\n       \n       t1.start();\n       t2.start();\n       t3.start();\n       t4.start();\n       \n    }\n    public void run(){\n        for(int i = 0; i<5; i++){\n            try{\n                abq.put(i);\n            } catch(InterruptedException e){}\n        }\n    }\n}','will run indefinitely, put will block until space becomes available, here \nit will never become available because there is no code removing objects','Concurrency',1,NULL),(3322,'public class Hello implements Runnable {\n    private static ArrayBlockingQueue<Integer> abq = new ArrayBlockingQueue<>(10);\n    public static void main(String[] args){\n        for(int i = 0; i<10; i++)\n                abq.add(i);\n  \n       Hello h = new Hello();\n       Thread t1 = new Thread(h);\n       Thread t2 = new Thread(h);\n       Thread t3 = new Thread(h);\n       Thread t4 = new Thread(h);\n       \n       t1.start();\n       t2.start();\n       t3.start();\n       t4.start();\n       \n    }\n    public void run(){\n        for(int i = 0; i<5; i++){\n            System.out.println(Thread.currentThread().getName()+\"removed element: \"+abq.peek());\n        }\n        \n    }\n}','peek() returns the head without removing it. returns null if empty\nThread-0removed element: 0\nThread-0removed element: 0\nThread-0removed element: 0\nThread-0removed element: 0\nThread-0removed element: 0\nThread-2removed element: 0\nThread-2removed element: 0\nThread-2removed element: 0\nThread-2removed element: 0\nThread-2removed element: 0\nThread-3removed element: 0\nThread-3removed element: 0\nThread-3removed element: 0\nThread-3removed element: 0\nThread-3removed element: 0\nThread-1removed element: 0\nThread-1removed element: 0\nThread-1removed element: 0\nThread-1removed element: 0\nThread-1removed element: 0\n','Concurrency',1,NULL),(3323,'ArrayBlockingQueue<E>\n\nA bounded blocking queue backed by an array. \nThis queue orders elements FIFO (first-in-first-out). \nThe head of the queue is that element that has been on the queue the longest time. \nThe tail of the queue is that element that has been on the queue the shortest time. \nNew elements are inserted at the tail of the queue, and the queue retrieval operations obtain elements at the head of the queue.\n\nThis is a classic \"bounded buffer\", in which a fixed-sized array holds elements inserted by producers and extracted by consumers. \nOnce created, the capacity cannot be changed. Attempts to put an element into a full queue will result in the operation blocking; \nattempts to take an element from an empty queue will similarly block. ','','Concurrency',1,NULL),(3324,'public class Hello {\n    public static void main(String[] args){\n        SynchronousQueue<String> sq = new SynchronousQueue<String>();\n        Thread putThread = new Thread(new PutRunnable<String>(sq, \"One\"), \"PutThread\");\n        putThread.start();\n        Thread takerThread = new Thread(new TakerRunnable<String>(sq), \"TakerThread\");\n        takerThread.start();\n\n    }\n}\n\n class PutRunnable<T> implements Runnable {\n    private T value;\n    private SynchronousQueue<T> syncQ;\n    PutRunnable(SynchronousQueue<T> syncQ, T value) {\n        this.syncQ = syncQ;\n        this.value = value;\n    }\n    public void run() {\n        try {\n            PrintUtils.print(\"Put \" + value);\n            syncQ.put(value);\n            PrintUtils.print(\"Returned from put\");\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n \n}\nclass TakerRunnable<T> implements Runnable {\n    private T value;\n    private SynchronousQueue<T> syncQ;\n    TakerRunnable(SynchronousQueue<T> syncQ) {\n        this.syncQ = syncQ;\n    }\n    public void run() {\n        try {\n            PrintUtils.print(\"Retrieve using take\");\n            value = syncQ.take();\n            PrintUtils.print(\"take() returned \" + value);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n    public T getValue() {\n        return value;\n    }\n}\n\nclass PrintUtils {\n    public static void print(String s) {\n        System.out.println(Thread.currentThread().getName() + \":\" + s);\n    }\n}','PutThread:Put One\nTakerThread:Retrieve using take\nTakerThread:take() returned One\nPutThread:Returned from put\n\nSyncQueue is used to make two threads meet up and hand off an object. \n\nBoth insertion and removal operations will block until the other thread\ndoes the inverse thus making the threads meet and exchange. ','Concurrency',1,NULL),(3325,'public class Hello {\n    \n    private static TransferQueue<Integer> tq = new LinkedTransferQueue<>();\n\n    public static void main(String[] args){\n        boolean b1 = tq.add(1); // true if added, IllegalStateException if full\n        \n        try{\n            //both of these throw interruptedExceptions because they block and wait\n            \n            tq.put(2);  //blocks if bounded or full\n        \n            tq.transfer(88); //blocks until element is consumed\n            \n        } catch(InterruptedException e){ }\n        \n        tq.tryTransfer(7); // returns true if consumed by the awaiting thread, or false without adding if there was no awaiting consumer.\n            // does not block therefore does not throw interruptedException\n        \n        try {\n            \n            //will wait the given time, blocking, then will return if not consumed\n            boolean b7 = tq.tryTransfer(99,10,TimeUnit.SECONDS);\n            \n        } catch(InterruptedException e){ }\n\n    }\n    \n    public static void methodsToRetrieve(){\n        Integer i1 = tq.element(); // gets without removing, throws NoSuchElementException if empty\n        \n        Integer i2 = tq.peek(); // gets without removing, null if empty\n        \n        Integer i3 = tq.poll(); //returns and removes the head, null if empty\n        \n        try{\n            Integer i4 = tq.poll(10,TimeUnit.MILLISECONDS); // removes the head, waits the specified time beffore returning null if empty\n        } catch(InterruptedException e) { }\n        \n        Integer i5 = tq.remove(); // removes the head of the queue throws NoSuchElementException if empty\n                \n        try{\n            Integer i6 = tq.take(); //removes the head blocks until an element is ready,\n        } catch(InterruptedException e) { }\n                \n    }','LinkedTranserQueue implements the BlockingQueue, TransferQueue, and Queue interfaces\n\nit is used here to demonstrate all the inserting and removing methods.','Concurrency',1,NULL),(3326,'public class Hello {\n    \n    private static TransferQueue<Integer> tq = new LinkedTransferQueue<>(45);\n\n    public static void main(String[] args){\n        boolean b1 = tq.add(1); // true if added, IllegalStateException if full\n        \n        try{\n            //both of these throw interruptedExceptions because they block and wait\n            \n            tq.put(2);  //blocks if bounded or full\n        \n            tq.transfer(88); //blocks until element is consumed\n            \n        } catch(InterruptedException e){ }\n        \n        tq.tryTransfer(7); // returns true if consumed by the awaiting thread, or false without adding if there was no awaiting consumer.\n            // does not block therefore does not throw interruptedException\n        \n        try {\n            \n            //will wait the given time, blocking, then will return if not consumed\n            boolean b7 = tq.tryTransfer(99,10,TimeUnit.SECONDS);\n            \n        } catch(InterruptedException e){ }\n\n    }\n    \n    public static void methodsToRetrieve(){\n        Integer i1 = tq.element(); // gets without removing, throws NoSuchElementException if empty\n        \n        Integer i2 = tq.peek(); // gets without removing, null if empty\n        \n        Integer i3 = tq.poll(); //returns and removes the head, null if empty\n        \n        try{\n            Integer i4 = tq.poll(10,TimeUnit.MILLISECONDS); // removes the head, waits the specified time beffore returning null if empty\n        } catch(InterruptedException e) { }\n        \n        Integer i5 = tq.remove(); // removes the head of the queue throws NoSuchElementException if empty\n                \n        try{\n            Integer i6 = tq.take(); //removes the head blocks until an element is ready,\n        } catch(InterruptedException e) { }\n                \n    }','will not compile, LinkedTransferQueue is not bounded and cannot be supplied with\na size argument','Concurrency',1,NULL),(3327,'public class Hello {\n    \n    private static TransferQueue<Integer> tq = new LinkedTransferQueue<>();\n\n    public static void main(String[] args){\n        boolean b1 = tq.add(1); // true if added, IllegalStateException if full\n            \n        tq.put(2);  //blocks if bounded or full\n        \n        tq.transfer(88); //blocks until element is consumed\n        \n        tq.tryTransfer(7); // returns true if consumed by the awaiting thread, or false without adding if there was no awaiting consumer.\n            // does not block therefore does not throw interruptedException\n        \n        try {\n            \n            //will wait the given time, blocking, then will return if not consumed\n            boolean b7 = tq.tryTransfer(99,10,TimeUnit.SECONDS);\n            \n        } catch(InterruptedException e){ }\n\n    }\n    \n    public static void methodsToRetrieve(){\n        Integer i1 = tq.element(); // gets without removing, throws NoSuchElementException if empty\n        \n        Integer i2 = tq.peek(); // gets without removing, null if empty\n        \n        Integer i3 = tq.poll(); //returns and removes the head, null if empty\n        \n        try{\n            Integer i4 = tq.poll(10,TimeUnit.MILLISECONDS); // removes the head, waits the specified time beffore returning null if empty\n        } catch(InterruptedException e) { }\n        \n        Integer i5 = tq.remove(); // removes the head of the queue throws NoSuchElementException if empty\n                \n        try{\n            Integer i6 = tq.take(); //removes the head blocks until an element is ready,\n        } catch(InterruptedException e) { }\n                \n    }','will not compile, put and transfer block and wait, therefore they throw \nInterruptedExceptions','Concurrency',1,NULL),(3328,'public class Hello {\n    \n    public static void main(String[] args){\n        Library library = new Library();\n        \n        new Thread(library).start();\n        \n        new Thread(new Renter(library,\"Mike\")).start();\n        new Thread(new Renter(library,\"Max\")).start();\n        new Thread(new Renter(library,\"Priebe\")).start();\n        new Thread(new Renter(library,\"Dom\")).start();\n    }\n}\n\nclass Library implements Runnable{\n    private TransferQueue<Book> shelves = new LinkedTransferQueue<>();\n    \n    public Library() {\n        shelves.add(new Book(\"Topics of Destruction\"));\n        shelves.add(new Book(\"War what is it good for\"));\n        shelves.add(new Book(\"LOTR\"));\n        shelves.add(new Book(\"Manson, the secret life\"));\n    }\n    \n    public void run(){\n        while(true){ }\n    }\n    \n    public Book lend(){\n        \n        try {\n            Book book = shelves.take();\n            System.out.println(\"This ones good try \"+book.getName()+\". Enjoy!\");\n            return book;\n        } catch(InterruptedException e){ }\n        \n        return new Book(\"Free Library Pamphlet on plagarism\");\n    }\n    \n    public void accept(Book book){\n        shelves.offer(book);\n       \n    }\n}\n\nclass Renter implements Runnable {\n    private Library lib;\n    private String name;\n    public Renter(Library lib,String x){\n        name = x;\n        this.lib = lib;\n    }\n    public void run(){\n        while(true){\n            Book book = lib.lend();\n            System.out.println(name+\" chekced out \"+book.getName());\n            try{\n                Thread.sleep(ThreadLocalRandom.current().nextInt(1000,5000));\n            } catch(InterruptedException e) { }\n            \n            System.out.println(name+\": Im done with \"+book.getName()+\" here take it back!\");\n            lib.accept(book);\n        }\n    }\n}\n\n\nclass Book{\n    private String name;\n    public Book(String x ){\n        name = x;\n    }\n    \n    public String getName(){\n        return name;\n    }\n    \n}','This shows the proper use of take() which will block until a book is available,\noffer is also properlyy used becaue it will only add if the queue is not full\nif it is it simply doesn\'t add it and doesn\'t throw an exception or anything.\n\nThis ones good try Topics of Destruction. Enjoy!\nMike chekced out Topics of Destruction\nThis ones good try War what is it good for. Enjoy!\nMax chekced out War what is it good for\nThis ones good try LOTR. Enjoy!\nPriebe chekced out LOTR\nThis ones good try Manson, the secret life. Enjoy!\nDom chekced out Manson, the secret life\nMike: Im done with Topics of Destruction here take it back!\nThis ones good try Topics of Destruction. Enjoy!\nMike chekced out Topics of Destruction\nPriebe: Im done with LOTR here take it back!\nThis ones good try LOTR. Enjoy!\nPriebe chekced out LOTR\nDom: Im done with Manson, the secret life here take it back!\nThis ones good try Manson, the secret life. Enjoy!\nDom chekced out Manson, the secret life\nMike: Im done with Topics of Destruction here take it back!\nThis ones good try Topics of Destruction. Enjoy!\nMike chekced out Topics of Destruction\nMax: Im done with War what is it good for here take it back!\nThis ones good try War what is it good for. Enjoy!\nMax chekced out War what is it good for\nPriebe: Im done with LOTR here take it back!\nThis ones good try LOTR. Enjoy!\nPriebe chekced out LOTR\nMike: Im done with Topics of Destruction here take it back!\nThis ones good try Topics of Destruction. Enjoy!\nMike chekced out Topics of Destruction\nPriebe: Im done with LOTR here take it back!\nThis ones good try LOTR. Enjoy!\nPriebe chekced out LOTR','Concurrency',1,NULL),(3329,'public class Hello {\n    \n    public static void main(String[] args){\n        Library library = new Library();\n        \n        new Thread(library).start();\n        \n        new Thread(new Renter(library,\"Mike\")).start();\n        new Thread(new Renter(library,\"Max\")).start();\n        new Thread(new Renter(library,\"Priebe\")).start();\n        new Thread(new Renter(library,\"Dom\")).start();\n    }\n}\n\nclass Library implements Runnable{\n    private TransferQueue<Book> shelves = new LinkedTransferQueue<>();\n    \n    public Library() {\n        shelves.add(new Book(\"Capulets and Montagues, the unknown link\"));\n        shelves.add(new Book(\"War What is it Good For\"));\n        shelves.add(new Book(\"Virtuous Villians\"));\n        shelves.add(new Book(\"Love in the Water\"));\n    }\n    \n    public void run(){\n        while(true){ }\n    }\n    \n    public Book lend(){\n        \n        try {\n            Book book = shelves.element();\n            System.out.println(\"This ones good try \"+book.getName()+\". Enjoy!\");\n            return book;\n        } catch(NoSuchElementException e){System.out.println(\"I\'m sorry sir we dont have that book right now\"); }\n        \n        return new Book(\"Free Library Pamphlet on plagarism\");\n    }\n    \n    public void accept(Book book){\n        shelves.offer(book);\n       \n    }\n}\n\nclass Renter implements Runnable {\n    private Library lib;\n    private String name;\n    public Renter(Library lib,String x){\n        name = x;\n        this.lib = lib;\n    }\n    public void run(){\n        while(true){\n            Book book = lib.lend();\n            System.out.println(name+\" chekced out \"+book.getName());\n            try{\n                Thread.sleep(ThreadLocalRandom.current().nextInt(1000,5000));\n            } catch(InterruptedException e) { }\n            \n            System.out.println(name+\": Im done with \"+book.getName()+\" here take it back!\");\n            lib.accept(book);\n        }\n    }\n}\n\nclass Book{\n    private String name;\n    public Book(String x ){\n        name = x;\n    }\n    \n    public String getName(){\n        return name;\n    }\n    \n}','element() throws NoSuchElementException,\n\n','Concurrency',1,NULL),(3330,'public class Hello {\n    \n    public static void main(String[] args){\n        Library library = new Library();\n        \n        new Thread(library).start();\n        \n        new Thread(new Renter(library,\"Mike\")).start();\n        new Thread(new Renter(library,\"Max\")).start();\n        new Thread(new Renter(library,\"Priebe\")).start();\n        new Thread(new Renter(library,\"Dom\")).start();\n    }\n}\n\nclass Library implements Runnable{\n    private TransferQueue<Book> shelves = new LinkedTransferQueue<>();\n    \n    public Library() {\n        shelves.add(new Book(\"Capulets and Montagues, the unknown link\"));\n        shelves.add(new Book(\"War What is it Good For\"));\n        shelves.add(new Book(\"Virtuous Villians\"));\n        shelves.add(new Book(\"Love in the Water\"));\n    }\n    \n    public void run(){\n        while(true){ }\n    }\n    \n    public Book lend(){\n\n            Book book = shelves.peek();\n            System.out.println(\"This ones good try \"+book.getName()+\". Enjoy!\");\n        \n            if(book == null){\n                return new Book(\"Free Library Pamphlet on plagarism\");\n            } else {\n                return book;\n            }\n    }\n    \n    public void accept(Book book){\n        shelves.offer(book);\n       \n    }\n}\n\nclass Renter implements Runnable {\n    private Library lib;\n    private String name;\n    public Renter(Library lib,String x){\n        name = x;\n        this.lib = lib;\n    }\n    public void run(){\n        while(true){\n            Book book = lib.lend();\n            System.out.println(name+\" chekced out \"+book.getName());\n            try{\n                Thread.sleep(ThreadLocalRandom.current().nextInt(1000,5000));\n            } catch(InterruptedException e) { }\n            \n            System.out.println(name+\": Im done with \"+book.getName()+\" here take it back!\");\n            lib.accept(book);\n        }\n    }\n}\n\nclass Book{\n    private String name;\n    public Book(String x ){\n        name = x;\n    }\n    \n    public String getName(){\n        return name;\n    }\n    \n}','The same book keeps getting checked out because peek()\nreturns but does not remove the element\n\nThis ones good try Capulets and Montagues, the unknown link. Enjoy!\nMike chekced out Capulets and Montagues, the unknown link\nThis ones good try Capulets and Montagues, the unknown link. Enjoy!\nMax chekced out Capulets and Montagues, the unknown link\nThis ones good try Capulets and Montagues, the unknown link. Enjoy!\nPriebe chekced out Capulets and Montagues, the unknown link\nThis ones good try Capulets and Montagues, the unknown link. Enjoy!\nDom chekced out Capulets and Montagues, the unknown link\nDom: Im done with Capulets and Montagues, the unknown link here take it back!\nThis ones good try Capulets and Montagues, the unknown link. Enjoy!\nDom chekced out Capulets and Montagues, the unknown link\nMike: Im done with Capulets and Montagues, the unknown link here take it back!\nThis ones good try Capulets and Montagues, the unknown link. Enjoy!\nMike chekced out Capulets and Montagues, the unknown link\nPriebe: Im done with Capulets and Montagues, the unknown link here take it back!\nThis ones good try Capulets and Montagues, the unknown link. Enjoy!\nPriebe chekced out Capulets and Montagues, the unknown link\nMax: Im done with Capulets and Montagues, the unknown link here take it back!\nThis ones good try Capulets and Montagues, the unknown link. Enjoy!\nMax chekced out Capulets and Montagues, the unknown link\nDom: Im done with Capulets and Montagues, the unknown link here take it back!','Concurrency',1,NULL),(3331,'public class Hello {\n    \n    public static void main(String[] args){\n        Library library = new Library();\n        \n        new Thread(library).start();\n        \n        new Thread(new Renter(library,\"Mike\")).start();\n        new Thread(new Renter(library,\"Max\")).start();\n        new Thread(new Renter(library,\"Priebe\")).start();\n        new Thread(new Renter(library,\"Dom\")).start();\n    }\n}\n\nclass Library implements Runnable{\n    private TransferQueue<Book> shelves = new LinkedTransferQueue<>();\n    \n    public Library() {\n        shelves.add(new Book(\"Capulets and Montagues, the unknown link\"));\n        shelves.add(new Book(\"War What is it Good For\"));\n        shelves.add(new Book(\"Virtuous Villians\"));\n        shelves.add(new Book(\"Love in the Water\"));\n    }\n    \n    public void run(){\n        while(true){ }\n    }\n    \n    public Book lend(){\n\n            Book book = shelves.poll();\n            System.out.println(\"This ones good try \"+book.getName()+\". Enjoy!\");\n        \n            if(book == null){\n                return new Book(\"Free Library Pamphlet on plagarism\");\n            } else {\n                return book;\n            }\n    }\n    \n    public void accept(Book book){\n        shelves.put(book);\n       \n    }\n}\n\nclass Renter implements Runnable {\n    private Library lib;\n    private String name;\n    public Renter(Library lib,String x){\n        name = x;\n        this.lib = lib;\n    }\n    public void run(){\n        while(true){\n            Book book = lib.lend();\n            System.out.println(name+\" chekced out \"+book.getName());\n            try{\n                Thread.sleep(ThreadLocalRandom.current().nextInt(1000,5000));\n            } catch(InterruptedException e) { }\n            \n            System.out.println(name+\": Im done with \"+book.getName()+\" here take it back!\");\n            lib.accept(book);\n        }\n    }\n}\n\nclass Book{\n    private String name;\n    public Book(String x ){\n        name = x;\n    }\n    \n    public String getName(){\n        return name;\n    }\n    \n}','does not compile, \n\nput() will block if there is no space available therefor it throws an\n\nInterruptedException','Concurrency',1,NULL),(3332,'Which BlockingCollection method will block if needed until an object becomes\navailabel','take()','Concurrency',1,NULL),(3333,'Which BlockingCollection method throws nosuchelementexception','element()','Concurrency',1,NULL),(3334,'Which BlockingQueue method throws an illegalstateexception if the queueu is bounded and full ? ','add()','Concurrency',1,NULL),(3335,'Whic BlockingQueue method returns true if it was added and false if \nthe queueu was full but also provides a timeout overloaded option','offer() and offer(e, long timeout, timeunit)','Concurrency',1,NULL),(3336,'','','blank',1,NULL),(3337,'	String a = \"String\";\n        int b = 4;\n        int c = 3;\n        System.out.println(a+b+c);\n        System.out.println(a+(b+c));\n        System.out.println(\"\" + b + 3);\n        System.out.println(b+3);\n        System.out.println(++b + \"\" + c--);\n        System.out.println(c);','String43\nString7\n43\n7\n53\n2','Strings',1,NULL),(3338,'','','blank',1,NULL),(3339,'ExecutorService ex = Executors.newCachedThreadPool();','Cached thread pools will create new threads as needed and reuse threads that \nhave become free. Thread that have been idle for 60 seconds are removed.\n\nCan create more threads than system can handle so watch out. ','Executors',1,NULL),(3340,'ExecutorService ex = Executors.newFixedThreadPool(4);\n','constructed with an int argument that specifies the number of threads to use\nto execute the tasks. Most common. Prevents system from being overloaded\nwith too many threads. \n\nBase number of threads on some kind of system resource. \n\nuse java.lang.Runtime\n\nRuntime rt = Runtime.getRuntime();\nint cpus = rt.availabeProcessors();','Executors',1,NULL),(3341,'How to adust the thread count of a pool at runtime\n\n','ThreadPoolExecutor tpe = (ThreadPoolExecutor) Executors.newFixedThreadPool(4);\ntpe.setCorePoolSize(8);\ntpe.setMaximumPoolSize(8);','Executors',1,NULL),(3342,'public class Hello {\n    public static void main(String[] args){\n        ExecutorService ex = Executors.newSingleThreadPool();\n\n        Future<Integer> futint = ex.submit(new FileCounter());\n        \n        System.out.println(\"Do other things while the files are getting counted\");\n        \n        try{\n            int count = futint.get();\n            System.out.println(count);\n            futint.shutdown();\n        }catch(ExecutionException | InterruptedException e){\n            \n        }\n        \n    }\n    \n    \n}\n\nclass FileCounter implements Callable<Integer>{\n    private int fileCount = 0;\n    public Integer call() throws IOException{\n        fileCount = count(Paths.get(\"/home/maxbisesi/Documents\"));\n        return fileCount; \n    }\n    \n    public Integer count(Path d) throws IOException {\n        int count = 0;\n	try(DirectoryStream<Path> stream = Files.newDirectoryStream(d)){\n		for(Path path: stream){\n			count++;\n		}\n	}\n        return count;\n    }\n}','        ExecutorService ex = Executors.newSingleThreadExecutor(); \n\nwil not compile, it is singlethreadexecutor not singlethreadPool\n\n**Also you shutdown the ExecutorService not the Future!','Executors',1,NULL),(3343,'Scheduled Thread pool:\n	scheduled after a delay or at repeating intervals\n\npublic class Hello {\n    \n    public static void main(String[] args){\n     ScheduledExecutorService ftses = Executors.newScheduledThreadPool(4);\n     \n     ftses.schedule(r, 5, TimeUnit.SECONDS); //run once after a delay\n     \n     ftses.scheduleAtFixedRate(r, 2,5,TimeUnit.SECONDS); //begin after 2 sec delay and begin again every 5\n     \n     ftses.scheduleWithFixedDelay(r, 2, 5, TimeUnit.SECONDS); //begin after 2 sec delay and again 5 seconds after the last exection\n}','','Executors',1,NULL),(3344,'an ExecutorService can take what two kinds of objects ?','Callable and Runnable','Executors',1,NULL),(3345,'What is the primary benifit of using a Callable ?','being able to return a result','Executors',1,NULL),(3346,'submitting a Callable to an ExecutorService returns a Future reference.\n\nwhat are two possible exceptions that could result ?','InterruptedException and ExecutionException','Executors',1,NULL),(3347,'ExecutionException','raised when an exception was thrown during the execution of the callable\'s\ncall()','Executors',1,NULL),(3348,'public class Hello {\n    \n    public static void main(String[] args){\n        Callable<Integer> c = new LoopCounter();\n        \n        ExecutorService ex = Executors.newCachedThreadPool();\n        \n        Future<Integer> f = ex.submit(c); //finishes in the future\n        \n        try{\n            Integer v = f.get(); // will block until done\n            System.out.println(\"Ran: \" + v);\n        } catch(InterruptedException | ExecutionException iex){\n            System.out.println(\"Failed\");\n        }\n        \n        for(int i = 0; i<10; i++){\n            System.out.println(\"main: \"+ i);\n        }\n    }\n}\n\nclass LoopCounter implements Callable<Integer> {\n    \n    public Integer call(){\n        int count = ThreadLocalRandom.current().nextInt(1,11);\n        for(int i = 1; i <= count; i++){\n                System.out.println(\"running...\" + i);\n        }\n        return count;\n    }\n}','When a callable task is submitted to an executor the task will go run,\ncalling for its return value will block until it is done so otherwise go on \nwith your program until you are ready to use that result. In this code the rest\nof main is executed only after the future is returned.\nrunning...1\nrunning...2\nrunning...3\nrunning...4\nrunning...5\nrunning...6\nrunning...7\nrunning...8\nrunning...9\nrunning...10\nRan: 10\nmain: 0\nmain: 1\nmain: 2\nmain: 3\nmain: 4\nmain: 5\nmain: 6\nmain: 7\nmain: 8\nmain: 9\n','Executors',1,NULL),(3349,'Using Executors takes away the need for synchronization, waiting, joining and \nnotifying','got it ','Executors',1,NULL),(3350,'public class Hello {\n    \n    public static void main(String[] args){\n        Callable<Integer> c = new LoopCounter();\n        \n        ExecutorService ex = Executors.newCachedThreadPool();\n        \n        Future<Integer> f = ex.submit(c); //finishes in the future\n        \n        try{\n            Integer v = f.get(); // will block until done\n            System.out.println(\"Ran: \" + v);\n        } catch(InterruptedException | ExecutionException iex){\n            System.out.println(\"Failed\");\n        }\n        \n        for(int i = 0; i<10; i++){\n            System.out.println(\"main: \"+ i);\n        }\n        \n        ex.shutdown();\n    }\n}\n\nclass LoopCounter implements Callable<Integer> {\n    \n    public Integer call(){\n        int count = ThreadLocalRandom.current().nextInt(1,11);\n        for(int i = 1; i <= count; i++){\n                System.out.println(\"running...\" + i);\n        }\n        return count;\n    }\n}','The program will complete normally, without shutdown() it would continue to run,\nit is best to shutdown an executor service in order to free up threads.','Executors',1,NULL),(3351,'ExecutorService ex = ...\n//......\n\nex.shutdown(); // no more new tasks but finish existing tasks\n\ntry{\n	boolean term = ex.awaitTermination(2,TimeUnit.SECONDS);\n		//wait two seconds for running tasks to finsish\n} catch(InterruptedException ex) {\n	//did not wait full two seconds\n} finally {\n   if(!ex.isTerminated()) // are all tasks done ?\n   {\n	List<Runnable> unfinished = ex.shutdownNow();\n		// a collection of unfished tasks\n   }\n}','','Executors',1,NULL),(3352,'class RandomInitRA extends RecursiveAction {\n    private static final int THRESHOLD = 10000;\n    private int[] data;\n    private int start;\n    private int end;\n    \n    public RandomInitRA(int[] data, int start, int end) {\n        this.data = data;\n        this.start = start;\n        this.end = end;\n    }\n    \n    protected void compute() {\n        if(end - start <= THRESHOLD) {\n            // if this is a manageable amount of work do the task\n            for(int i = start; i<end; i++){\n                data[i] = ThreadLocalRandom.current().nextInt();\n            }\n        } else { //task too big\n            int halfway = ((end - start) / 2) + start;\n            RandomInitRA a1 = new RandomInitRA(data,start,halfway);\n            a1.fork();\n            RandomInitRA a2 = new RandomInitRA(data,halfway,end);\n            a2.compute();\n            a1.join();\n        }\n    }\n}','breaks a big task down into smaller parts\n\n','Executors',1,NULL),(3353,'class RandomInitRA extends RecursiveAction {\n    private static final int THRESHOLD = 10000;\n    private int[] data;\n    private int start;\n    private int end;\n    \n    public RandomInitRA(int[] data, int start, int end) {\n        this.data = data;\n        this.start = start;\n        this.end = end;\n    }\n    \n    protected void compute() {\n        if(end - start <= THRESHOLD) {\n            // if this is a manageable amount of work do the task\n            for(int i = start; i<end; i++){\n                data[i] = ThreadLocalRandom.current().nextInt();\n            }\n        } else { //task too big\n            int halfway = ((end - start) / 2) + start;\n            RandomInitRA a1 = new RandomInitRA(data,start,halfway);\n            RandomInitRA a2 = new RandomInitRA(data,halfway,end);\n            invokeAll(a1,a2);\n        }\n    }\n}','use invokeAll instead of the fork join compute, \nRecursiveAction does not reutrn a value so you should not excpect a value\nfrom invoke all. ','Executors',1,NULL),(3354,'class RandomInitRA extends RecursiveAction {\n    private static final int THRESHOLD = 10000;\n    private int[] data;\n    private int start;\n    private int end;\n    \n    public RandomInitRA(int[] data, int start, int end) {\n        this.data = data;\n        this.start = start;\n        this.end = end;\n    }\n    \n    protected int compute() {\n        if(end - start <= THRESHOLD) {\n            // if this is a manageable amount of work do the task\n            for(int i = start; i<end; i++){\n                data[i] = ThreadLocalRandom.current().nextInt();\n            }\n        } else { //task too big\n            int halfway = ((end - start) / 2) + start;\n            RandomInitRA a1 = new RandomInitRA(data,start,halfway);\n            RandomInitRA a2 = new RandomInitRA(data,halfway,end);\n            invokeAll(a1,a2);\n        }\n    }\n}','will not compile, return type of compute from RecursiveAction is void as\nRAs do not return values. ','Executors',1,NULL),(3355,'public class Hello{\n    public static void main(String[]  args){\n        \n        \n        \n    }\n}\n \nclass RandomInitRA extends RecursiveAction {\n    private static final int THRESHOLD = 10000;\n    private int[] data;\n    private int start;\n    private int end;\n    \n    public RandomInitRA(int[] data, int start, int end) {\n        this.data = data;\n        this.start = start;\n        this.end = end;\n    }\n    \n    protected void compute() {\n        if(end - start <= THRESHOLD) {\n            // if this is a manageable amount of work do the task\n            for(int i = start; i<end; i++){\n                data[i] = ThreadLocalRandom.current().nextInt();\n            }\n        } else { //task too big\n            int halfway = ((end - start) / 2) + start;\n            RandomInitRA a1 = new RandomInitRA(data,start,halfway);\n            RandomInitRA a2 = new RandomInitRA(data,halfway,end);\n            invokeAll(a1,a2);\n        }\n    }\n}\n\n//given that the task of this RA is to fill a big array with random numbers\n// how would you start it in main given int[] data = new int[10_000_000];','int[] data = new int[10_000_000];\nForkJoinPool fjpool = new ForkJoinPool();\nRandomInitRA ra = new RandomInitRA(data,0,data.length);\n        \nfjpool.invoke(ra);','Executors',1,NULL),(3356,'public class Hello{\n    public static void main(String[]  args){\n        int[] data = new int[10_000_000];\n        ForkJoinPool fjpool = new ForkJoinPool();\n        RandomInitRA ra = new RandomInitRA(data,0,data.length);\n        \n        fjpool.invokeAll(ra);\n    }\n}\n \nclass RandomInitRA extends RecursiveAction {\n    private static final int THRESHOLD = 10000;\n    private int[] data;\n    private int start;\n    private int end;\n    \n    public RandomInitRA(int[] data, int start, int end) {\n        this.data = data;\n        this.start = start;\n        this.end = end;\n    }\n    \n    protected void compute() {\n        if(end - start <= THRESHOLD) {\n            // if this is a manageable amount of work do the task\n            for(int i = start; i<end; i++){\n                data[i] = ThreadLocalRandom.current().nextInt();\n            }\n        } else { //task too big\n            int halfway = ((end - start) / 2) + start;\n            RandomInitRA a1 = new RandomInitRA(data,start,halfway);\n            RandomInitRA a2 = new RandomInitRA(data,halfway,end);\n            invokeAll(a1,a2);\n        }\n    }\n}','the forkjoinpool method is invoke() not invokeAll()\n\nit should be:\n\n	fjpool.invoke(ra);\n\nThere is an invokeAll() but it takes a collection of callable and returns \na list of futures. \n\nnotice too that it doesn\'t return a value, technically it is of type Void, and\nnull is the only valid type for Void','Executors',1,NULL),(3357,'Two subclasses of ForkJoinTask<V>','RecursiveAction RecursiveTask','Executors',1,NULL),(3358,'class RandomInitRA extends RecursiveAction {\n    private static final int THRESHOLD = 10000;\n    private int[] data;\n    private int start;\n    private int end;\n    \n    public RandomInitRA(int[] data, int start, int end) {\n        this.data = data;\n        this.start = start;\n        this.end = end;\n    }\n    \n    public void compute() {\n        if(end - start <= THRESHOLD) {\n            // if this is a manageable amount of work do the task\n            for(int i = start; i<end; i++){\n                data[i] = ThreadLocalRandom.current().nextInt();\n            }\n        } else { //task too big\n            int halfway = ((end - start) / 2) + start;\n            RandomInitRA a1 = new RandomInitRA(data,start,halfway);\n            RandomInitRA a2 = new RandomInitRA(data,halfway,end);\n            invokeAll(a1,a2);\n        }\n    }\n}','this will compile \n\nan overriden method CAN have less restrive access, but not more restrictive.\n\ncompute() is protected in abstract class','Executors',1,NULL),(3359,'','','Executors',1,NULL),(3360,'class RandomInitRA extends RecursiveAction {\n    private static final int THRESHOLD = 10000;\n    private int[] data;\n    private int start;\n    private int end;\n    \n    public RandomInitRA(int[] data, int start, int end) {\n        this.data = data;\n        this.start = start;\n        this.end = end;\n    }\n    \n    private void compute() {\n        if(end - start <= THRESHOLD) {\n            // if this is a manageable amount of work do the task\n            for(int i = start; i<end; i++){\n                data[i] = ThreadLocalRandom.current().nextInt();\n            }\n        } else { //task too big\n            int halfway = ((end - start) / 2) + start;\n            RandomInitRA a1 = new RandomInitRA(data,start,halfway);\n            RandomInitRA a2 = new RandomInitRA(data,halfway,end);\n            invokeAll(a1,a2);\n        }\n    }\n}','will not compile an overriden method CAN have more restrictive access but not \nless. private is less than public.','Executors',1,NULL),(3361,'class RandomInitRA extends RecursiveAction {\n    private static final int THRESHOLD = 10000;\n    private int[] data;\n    private int start;\n    private int end;\n    \n    public RandomInitRA(int[] data, int start, int end) {\n        this.data = data;\n        this.start = start;\n        this.end = end;\n    }\n    \n    void compute() {\n        if(end - start <= THRESHOLD) {\n            // if this is a manageable amount of work do the task\n            for(int i = start; i<end; i++){\n                data[i] = ThreadLocalRandom.current().nextInt();\n            }\n        } else { //task too big\n            int halfway = ((end - start) / 2) + start;\n            RandomInitRA a1 = new RandomInitRA(data,start,halfway);\n            RandomInitRA a2 = new RandomInitRA(data,halfway,end);\n            invokeAll(a1,a2);\n        }\n    }\n}','will not compile, an overriden method cannot have more restrictive access\ndefault is more restrictive than protected.','Executors',1,NULL),(3362,'class FindMaxPosition extends RecursiveTask<Integer> {\n     private static final int THRESHOLD = 10000;\n    private int[] data;\n    private int start;\n    private int end;\n    \n    public FindMaxPosition(int[] data, int start, int end) {\n        this.data = data;\n        this.start = start;\n        this.end = end;\n    }\n    \n    public Integer compute() {\n        if (end - start <= THRESHOLD){\n            int position = 0;\n            for(int i = start; i < end; i++){\n                 if(data[i] > data[position]) {\n                     position = i;\n                 }\n            }\n            \n            return position;\n        } else { //task is too big, split it\n            int halfway = ((end - start) / 2) + start;\n            FindMaxPosition p1 = new FindMaxPosition(data,start,halfway);\n            p1.fork();\n            FindMaxPosition p2 = new FindMaxPosition(data,start,halfway);\n            int pos2 = p2.compute();\n            int pos1 = p1.join();\n            \n            //these forked tasks found the greatest value in their subsections now compare the two results \n            \n            if(data[pos1] > data[pos2]) {\n                return pos1;\n            } else if(data[pos1] < data[pos2]){\n                return pos2;\n            } else {\n                return pos1 < pos2 ? pos1 : pos2;\n            }\n        }\n        \n    }\n}','RecursiveTask<V> returns a value\n\nfor this particular example you should initialize the array with random \nnumber using RandomInitRecursiveAction that doesn\'t return a result. \n\npublic static void main(String[] args) {\n        int[] bigdata = new int[20000];\n        ForkJoinPool fj = new ForkJoinPool();\n        FindMaxPosition fmp = new FindMaxPosition(bigdata,0,bigdata.length);\n        Integer i = fj.invoke(fmp);\n        \n    }','Executors',1,NULL),(3363,'public class Hello{\n    public static void main(String[]  args){\n        int[] data = new int[10_000_000];\n        ForkJoinPool fjpool = new ForkJoinPool();\n        RandomInitRA ra = new RandomInitRA(data,0,data.length);\n        fjpool.invoke(ra);\n        \n        FindMaxPosition task = new FindMaxPosition(data,0,data.length);\n        Integer position = fjpool.invoke(task);\n        System.out.println(\"Bigggest value:;\"+ data[position]);\n    }\n}\n\nclass FindMaxPosition extends RecursiveTask<Integer> {\n     private static final int THRESHOLD = 10000;\n    private int[] data;\n    private int start;\n    private int end;\n    \n    public FindMaxPosition(int[] data, int start, int end) {\n        this.data = data;\n        this.start = start;\n        this.end = end;\n    }\n    \n    public Integer compute() {\n        if (end - start <= THRESHOLD){\n            int position = 0;\n            for(int i = start; i < end; i++){\n                 if(data[i] > data[position]) {\n                     position = i;\n                 }\n            }\n            \n            return position;\n        } else { //task is too big, split it\n            int halfway = ((end - start) / 2) + start;\n            FindMaxPosition p1 = new FindMaxPosition(data,start,halfway);\n            p1.fork();\n            FindMaxPosition p2 = new FindMaxPosition(data,start,halfway);\n            int pos2 = p2.compute();\n            int pos1 = p1.join();\n            \n            //these forked tasks found the greatest value in their subsections now compare the two results \n            \n            if(data[pos1] > data[pos2]) {\n                return pos1;\n            } else if(data[pos1] < data[pos2]){\n                return pos2;\n            } else {\n                return pos1 < pos2 ? pos1 : pos2;\n            }\n        }\n        \n    }\n}\n \nclass RandomInitRA extends RecursiveAction {\n    private static final int THRESHOLD = 10000;\n    private int[] data;\n    private int start;\n    private int end;\n    \n    public RandomInitRA(int[] data, int start, int end) {\n        this.data = data;\n        this.start = start;\n        this.end = end;\n    }\n    \n    protected void compute() {\n        if(end - start <= THRESHOLD) {\n            // if this is a manageable amount of work do the task\n            for(int i = start; i<end; i++){\n                data[i] = ThreadLocalRandom.current().nextInt();\n            }\n        } else { //task too big\n            int halfway = ((end - start) / 2) + start;\n            RandomInitRA a1 = new RandomInitRA(data,start,halfway);\n            RandomInitRA a2 = new RandomInitRA(data,halfway,end);\n            invokeAll(a1,a2);\n        }\n    }\n}','This will create an array of 10000000 elements then, find the biggest value in it\n','Executors',1,NULL),(3364,'ConcurrentMap<String,Integer> ages = new ConcurrentHashMap<>();\nages.put(\"John\",23);\n\nWhich method would delete Joh from the map only if his value was still equal \nto 23','ages.remove(\"John\",23);\n\npublic boolean remove(Object key,\n             Object value)\n\nRemoves the entry for a key only if currently mapped to a given value. This is equivalent to\n\n   if (map.containsKey(key) && map.get(key).equals(value)) {\n       map.remove(key);\n       return true;\n   } else return false;\n\nexcept that the action is performed ATOMICALLY.\n\nThere is another remove method that comes from the map Interface...\nthat is the standard remove function.\n\npublic V remove(Object key)\n\nRemoves the key (and its corresponding value) from this map. This method does nothing if the key is not in the map.\n\nSpecified by:\n    remove in interface Map<K,V>\nOverrides:\n    remove in class AbstractMap<K,V>\nParameters:\n    key - the key that needs to be removed\nReturns:\n    the previous value associated with key, or null if there was no mapping for key','Concurrency',1,NULL),(3365,'AtomicInteger i = new AtomicInteger();\ntwo methods to atomically increment by 9?','i.addAndGet(9);\ni.getAndAdd(9);','Concurrency',1,NULL),(3366,'class LeaderBoard {\n    private ReadWriteLock rwl = new ReentrantReadWriteLock();\n    private List<Integer> highScores = new ArrayList<Integer>();\n    public void addScore(Integer score){\n        Lock lock = rwl.writeLock();\n        lock.lock();\n        \n        try{\n            if(highScores.size() < 10) {\n                highScores.add(score);\n            } else if(highScores.get(highScores.size() - 1) < score) {\n                highScores.set(highScores.size() - 1, score);\n            } else {\n                return;\n            }\n            \n            Collections.sort(highScores,Collections.reverseOrder());\n        } finally{\n            lock.unlock();\n        }\n    }\n    \n    public List getHighScores(){\n        Lock lock = rwl.readLock();\n        lock.lock();\n        try{\n            return Collections.unmodifiableList(highScores);\n        } finally {\n            lock.unlock();\n        }\n    }\n}','only one thread at a time can access the write lock where multiple threads\ncan access the readLock','Concurrency',1,NULL),(3367,'public class Hello {\n\n    public static void main(String[] args) {\n       LeaderBoard lb = new LeaderBoard();\n       lb.addScore(56);\n    }\n    \n}\n\nclass LeaderBoard {\n    private ReadWriteLock rwl = new ReentrantReadWriteLock();\n    private List<Integer> highScores = new ArrayList<Integer>();\n    public void addScore(Integer score){\n        Lock lock = rwl.writeLock();\n        \n        try{\n            if(highScores.size() < 10) {\n                highScores.add(score);\n            } else if(highScores.get(highScores.size() - 1) < score) {\n                highScores.set(highScores.size() - 1, score);\n            } else {\n                return;\n            }\n            \n            Collections.sort(highScores,Collections.reverseOrder());\n        } finally{\n            lock.unlock();\n        }\n    }\n    \n    public List getHighScores(){\n        Lock lock = rwl.readLock();\n        lock.lock();\n        try{\n            return Collections.unmodifiableList(highScores);\n        } finally {\n            lock.unlock();\n        }\n    }\n}','IllegalMonitorStateExcetion rwl.writeLock() was not locked before it was unloked\n','Concurrency',1,NULL),(3368,'public class Hello {\n\n    public static void main(String[] args) {\n       LeaderBoard lb = new LeaderBoard();\n       lb.addScore(5);\n    }\n    \n}\n\nclass LeaderBoard {\n    private ReadWriteLock rwl = new ReentrantReadWriteLock();\n    private List<Integer> highScores = new ArrayList<Integer>();\n    public void addScore(Integer score){\n        Lock lock = rwl.writeLock();\n        lock.lock();\n        try{\n            if(highScores.size() < 10) {\n                highScores.add(score);\n            } else if(highScores.get(highScores.size() - 1) < score) {\n                highScores.set(highScores.size() - 1, score);\n            } else {\n                return;\n            }\n            \n            Collections.sort(highScores,Collections.reverseOrder());\n        } finally{\n\n        }\n    }\n    \n    public List getHighScores(){\n        Lock lock = rwl.readLock();\n        lock.lock();\n        try{\n            return Collections.unmodifiableList(highScores);\n        } finally {\n            lock.unlock();\n        }\n    }\n}','compiles fine, The writeLock is locked but never unlocked,that will not throw\nan exception.','Concurrency',1,NULL),(3369,'public class Hello {\n\n    public static void main(String[] args) {\n       LeaderBoard lb = new LeaderBoard();\n       Player a = new Player(lb);\n       Player b = new Player(lb);\n       Player c = new Player(lb);\n       \n       a.start();\n       b.start();\n       c.start();\n    }\n    \n}\n\nclass LeaderBoard {\n    private ReadWriteLock rwl = new ReentrantReadWriteLock();\n    private List<Integer> highScores = new ArrayList<Integer>();\n    public void addScore(Integer score){\n        Lock lock = rwl.writeLock();\n        lock.lock();\n        try{\n            if(highScores.size() < 10) {\n                highScores.add(score);\n            } else if(highScores.get(highScores.size() - 1) < score) {\n                highScores.set(highScores.size() - 1, score);\n            } else {\n                return;\n            }\n            \n            Collections.sort(highScores,Collections.reverseOrder());\n        } finally{\n            lock.unlock();\n        }\n    }\n    \n    public List getHighScores(){\n        Lock lock = rwl.readLock();\n        lock.lock();\n        try{\n            return Collections.unmodifiableList(highScores);\n        } finally {\n\n        }\n    }\n}\n\nclass Player extends Thread {\n    private LeaderBoard lb;\n    public Player(LeaderBoard x){\n        lb = x;\n        \n    }\n    public void run(){\n        System.out.println(Thread.currentThread().getName()+\" \"+lb.getHighScores());\n        for(int i = 0; i<3; i++){\n            postHighScore();\n        }    \n    }\n    \n    public void postHighScore(){\n        lb.addScore(ThreadLocalRandom.current().nextInt());\n    }\n}\n','Thread-0 []\nThread-2 []\nThread-1 []\n... and will keep running\n\nsince the readlock is never unlocked() in getHighScores() the three threads will\nacquire the read lock but never release it. \n\nThat will prevent any of them from getting the write lock. RRWL allows multiple\nthreads to read at the same time but will wait for an exclusive lock before\nallowing threads to write to it. meaning no other thread can be reading while\nanother thread is writing to the locked object!','Concurrency',1,NULL),(3370,'I can\'t seem to determine any difference between InputStreamReader and FileReader besides the way the two are initialized. \nIs there any benefit to using one or the other? \nMost other articles cover FileInputStream vs InputStreamReader, but I am contrasting with FileReader instead. \nSeems to me they both have the same purpose.','\n\nFirst, InputStreamReader can handle all input streams, not just files. Other examples are network connections, classpath resources and ZIP files.\n\nSecond, FileReader does not allow you to specify an encoding and instead uses the plaform default encoding, which makes it pretty much useless as using it will result in corrupted data when the code is run on systems with different platform default encodings.\n\nIn short, forget that FileReader exists.\n','General',1,NULL),(3371,'while (scanNumOfLines.hasNextLine())    \n    {\n    NumOfLines ++;\n    scanNumOfLines.nextLine();\n    }\n    System.out.println(\"NumOfLines = \"+NumOfLines);\n\nSo it counts fine, but I want to re-use the scanner for another purpose, but the nextLine has moved to the last line of the file, and I want to reset it back to the first line.\n\n(Instead, I had to use another scanner for the other purpose, and to me this seems less elegant than it should be.)\n\nI\'m sure there must be a scanner method that resets the counter to zero?','-This is impossible to do.\n The reason to not include it, is the wide range of input types it supports. One example is streams. These don\'t store the results after they have been passed on,\n so they don\'t support resetting.\n So the elegant way is to create a new Scanner. \n If you give it many custom settings, create a factory method.\n\n-There is no \"counter\" in the Scanner object. \n Instead think of it as more like a conveyor belt. \n The belt has no knowledge or care about what\'s on it. \n It just keeps spitting things out at you while there are items left on it. \n And once you take them, they\'re gone from it for good.\n','General',1,NULL),(3372,'What difference that final makes between the code below. Is there any advantage in declaring the arguments as final.\n\npublic String changeTimezone( Timestamp stamp, Timezone fTz, Timezone toTz){  \n    return ....\n}\n\npublic String changeTimezone(final Timestamp stamp, final Timezone fTz, \n        final Timezone toTz){\n    return ....\n}\n\n','- \n\nAs a formal method parameter is a local variable, you can access them from inner anonymous classes only if they are declared as final.\n\nThis saves you from declaring another local final variable in the method body:\n\n void m(final int param) {\n        new Thread(new Runnable() {\n            public void run() {\n                System.err.println(param);\n            }\n        }).start();\n    }\n\n\n\n\n- final is used here to ensure the two indexes i and j won\'t accidentally be reset by the method. It\'s a handy way to protect against an insidious bug that erroneously changes the value of your parameters. \nGenerally speaking, short methods are a better way to protect from this class of errors,\nbut final parameters can be a useful addition to your coding style.\nNote that final parameters are not considered part of the method signature, and are ignored by the compiler when resolving method calls. Parameters can be declared final (or not) with no influence on how the method is overriden.\n\n-Might be better to use objects rather than primitives for this example, as primitive changes will always only be visible inside the method. \nAnd in the case of objects, you can still change them. You just can\'t point at a new object. In fact now I think about it, final doesn\'t really change anything \ncompared to leaving it out, other than saving a variable declaration with AICs and having the compiler point out accidental modifications of parameters that \nyou didn\'t want to modify for some reason.\n\n\n\nThe final prevents you from assining a new value to the variable, and this can be helpful in catching typos. \nStylistically you might like to keep the parameters received unchanged and assign only to local variables, \nso final would help to enforce that style.\n\npublic int example(final int basicRate){\n    int discountRate;\n\n    discountRate = basicRate - 10;\n    // ... lots of code here \n    if ( isGoldCustomer ) {\n        basicRate--;  // typo, we intended to say discountRate--, final catches this\n    }\n    // ... more code here\n\n    return discountRate;\n}\n\n','General',1,NULL),(3373,'abstract class A {\n    public abstract void foo(final String s);\n}\n\nclass B extends A {\n    public void foo(String x){\n        System.out.println(x);\n    }\n}','compiles fine','General',1,NULL),(3374,'Executor ex = Executors.newFixedThreadPool(9);\nExecutor ex2 = Executors.newFixedThreadPool();\nExecutor ex3 = Executor.newFixedThreadPool(9);\nExecutor ex4 = Executors.newCachedThreadPool(7);\n\nwhich can compile ?','only the first,\n\nthe only argument constructor for cachedthreadpool takes a threadfactory.\n\na fixed thread pool has to have a size.','Executors',1,NULL),(3375,'private Integer executeTask (ExecutorService service, Callable<Integer> task){\n        try{\n            Future<Integer> future = service.submit(task);\n            return future.get();\n        } catch(InterruptedException e){\n            return null;\n        }\n    }','will not compile, unreported exception ExecutionException thrown by .get()','Executors',1,NULL),(3376,'private Integer executeTask (ExecutorService service, Callable<Integer> task){\n        try{\n            Future<Integer> future = service.submit(task);\n            return future.get();\n        } catch(ExecutionException e){\n            return null;\n        }\n    }','will not compile, unreported Exeption InterruptedException thrown by .get()\n\nshould be :\n\n	catch(ExecutionException | InterruptedException e){\n            return null;\n        }','Executors',1,NULL),(3377,' private Integer executeTask (ExecutorService service, Callable<Integer> task){\n        try{\n            Future<Integer> future = service.submit(task);\n            return future.get();\n        } catch(InterruptedException | ExecutionException e){\n            return null;\n        }\n    }','will execute the submitted task\n\nfuture.get() will block until the activity is done.','Executors',1,NULL),(3378,' private Integer executeTask (ExecutorService service, Callable<Integer> task){\n        // insert code \n    }\n\nwhat code could you insert here to execute the task using the service','try{\n	Future<Integer> future = service.submit(task);\n	return future.get();\n} catch(InterruptedException | ExecutionException e){\n   	return null;\n}\n\nor ...\n\ntry{\n	Future<Integer> future = service.submit(task);\n	return future.get();\n} catch(Exception e){\n   	return null;\n}\n\n.get() will block until a result is available','Executors',1,NULL),(3379,'A runnable can return a result and throw an exception','FALSE, A Callable<E> can do that a runnable cannot do either of those things.','Executors',1,NULL),(3380,'With RecursiveTask subclasses which are true ?\n\n1.fork() and join() should be called on the same task.\n2.fork() and compute() should be called on the same task.\n3.compute() and join() should be called on the same task.\n4.compute() should be called before fork()\n5.fork() should be called before compute()\n6.join() should be called after fork() but before compute()','1 and 5\n\nWhen creating multiple forkjointask instances all tasks except one shuld be forked\nfirst so that they can be picked up by other forkjoin worker threads.\nThe final task should then be executed within the same thread by calling compute()\nbefore calling join on all the forked threads to await their results. \n\ncallin methods in the wrong order will not cause compiler error so care must be taken','Concurrency',1,NULL),(3381,'public class Hello {\n\n    public static void main(String[] args) {\n        Fibonacci fibonacci = new Fibonacci(10);\n        ForkJoinPool pool = new ForkJoinPool();\n        System.out.println(pool.invoke(fibonacci));\n    }\n}\n\nclass Fibonacci extends RecursiveTask<Long> {\n    final long n;\n    \n    Fibonacci(long n) {\n        this.n = n;\n    }\n    \n    public Long compute() {\n        if (n<=10) {\n            return do_fibonacci(n);\n        }\n        ForkJoinTask<Long> subTask = new Fibonacci(n-1).fork();\n        return new Fibonacci(n-2).compute() + subTask.join();\n    }\n    \n    static long do_fibonacci(long n) {\n        if ( n<=1 ) return n;\n        return do_fibonacci(n-1) + do_fibonacci(n-2);\n    }\n}','55','Concurrency',1,NULL),(3382,'public class Hello {\n\n    public static void main(String[] args) {\n        Fibonacci fibonacci = new Fibonacci(10);\n        ForkJoinPool pool = new ForkJoinPool();\n        System.out.println(pool.invoke(fibonacci));\n    }\n}\n\nclass Fibonacci extends RecursiveTask<Long> {\n    final long n;\n    \n    Fibonacci(long n) {\n        this.n = n;\n    }\n    \n    public Long compute() {\n        if (n<=10) {\n            return do_fibonacci(n);\n        }\n        //ForkJoinTask<Long> subTask = new Fibonacci(n-1).fork();\n        //return new Fibonacci(n-2).compute() + subTask.join();\n        //same as ...\n        ForkJoinTask<Long> f1 = new Fibonacci(n-1);\n        Fibonacci f2 = new Fibonacci(n-2);\n        f1.fork();\n        Long l1 = f2.compute();\n        Long l2 = f1.join();\n        return l1+l2;\n    }\n    \n    static long do_fibonacci(long n) {\n        if ( n<=1 ) return n;\n        return do_fibonacci(n-1) + do_fibonacci(n-2);\n    }\n}','55, join() returns the result of the forked procedure. \n\nfork() and join() should be called on the same, Task','Concurrency',1,NULL),(3383,'class Fibonacci extends RecursiveTask<Long> {\n    final long n;\n    \n    Fibonacci(long n) {\n        this.n = n;\n    }\n    \n    public Long compute() {\n        if (n<=10) {\n            return do_fibonacci(n);\n        }\n        //ForkJoinTask<Long> subTask = new Fibonacci(n-1).fork();\n        //return new Fibonacci(n-2).compute() + subTask.join();\n        //same as ...\n        ForkJoinTask<Long> f1 = new Fibonacci(n-1);\n        ForkJoinTask<Long> f2 = new Fibonacci(n-2);\n        f1.fork();\n        Long l1 = f2.compute();\n        Long l2 = f1.join();\n        return l1+l2;\n    }\n    \n    static long do_fibonacci(long n) {\n        if ( n<=1 ) return n;\n        return do_fibonacci(n-1) + do_fibonacci(n-2);\n    }\n}','Polymorphism bites you in the ass here again,\nclass Fibonacci has a compute method not FJT','Concurrency',1,NULL),(3384,'public class Hello {\n\n    public static void main(String[] args) {\n        Fibonacci fibonacci = new Fibonacci(10);\n        ForkJoinPool pool = new ForkJoinPool();\n        System.out.println(pool.invoke(fibonacci));\n    }\n}\n\nclass Fibonacci extends RecursiveTask<Long> {\n    final long n;\n    \n    Fibonacci(long n) {\n        this.n = n;\n    }\n    \n    public Long compute() {\n        if (n<=10) {\n            return do_fibonacci(n);\n        }\n        //ForkJoinTask<Long> subTask = new Fibonacci(n-1).fork();\n        //return new Fibonacci(n-2).compute() + subTask.join();\n        //same as ...\n        ForkJoinTask<Long> f1 = new Fibonacci(n-1);\n        Fibonacci<Long> f2 = new Fibonacci(n-2);\n        f1.fork();\n        Long l1 = f2.compute();\n        Long l2 = f1.join();\n        return l1+l2;\n    }\n    \n    static long do_fibonacci(long n) {\n        if ( n<=1 ) return n;\n        return do_fibonacci(n-1) + do_fibonacci(n-2);\n    }\n}','type fibonacci does not take parameters','General',1,NULL),(3385,'public class Hello {\n\n    public static void main(String[] args) {\n         Fibonacci fibonacci = new Fibonacci(15);\n         ForkJoinPool pool = new ForkJoinPool();\n         System.out.println(pool.invoke(fibonacci));\n    }\n}\n\n\nclass Fibonacci extends RecursiveTask<Long> {\n    final long n;\n    public static Long[] result = new Long[2];\n    public static int max_num = 1;\n    \n    public static void set_max(int num) {\n        result[0] = new Long(1);\n        result[1] = new Long(1);\n        if ( num > max_num ) {\n            Long[] new_result = new Long[num+1];\n            \n            for (int i=0; i<=max_num; i++) {\n                new_result[i] = result[i];\n            }\n            \n            result = new_result;\n            \n            for (int i=max_num+1; i<=num; i++) {\n                result[i] = new Long(0);\n            }\n            max_num = num;            \n        }\n    }\n    \n    Fibonacci(long n) {\n        this.n = n;\n        if ( n > 1 )\n            set_max((int)n);\n    }\n        \n    public Long compute() {\n        Long ret;\n        if ( result[(int)n].longValue() != 0 ) {\n            return result[(int)n];\n        }\n        if (n<=10) {\n            return do_fibonacci(n);\n        }\n        ForkJoinTask<Long> subTask = new Fibonacci(n-1);\n        ret = new Fibonacci(n-2).compute() + subTask.join();\n        result[(int)n] = new Long(ret);\n        return ret;\n    }\n    \n    static long do_fibonacci(long n) {\n        long ret;\n        if (result[(int)n].longValue() != 0) {\n            ret = result[(int)n].longValue();\n        } else {\n            long ret_n_1 = do_fibonacci(n-1);\n            long ret_n_2 = do_fibonacci(n-2);\n            ret = ret_n_1 + ret_n_2;\n            result[(int)n] = new Long(ret);\n        }\n        return ret;\n    }\n}','this program will never complete subtask is never forked so using join() will \nnever be able to return a result and it will block forever. \n\nto fix \n\nsubtask.fork();\n\n	ForkJoinTask<Long> subTask = new Fibonacci(n-1).fork();\n        ret = new Fibonacci(n-2).compute() + subTask.join();\n        result[(int)n] = new Long(ret);\n        return ret;','General',1,NULL),(3386,'public class Hello {\n\n    public static void main(String[] args) {\n         Fibonacci fibonacci = new Fibonacci(15);\n         ForkJoinPool pool = new ForkJoinPool();\n         System.out.println(pool.invoke(fibonacci));\n    }\n}\n\n\nclass Fibonacci extends RecursiveTask<Long> {\n    final long n;\n    public static Long[] result = new Long[2];\n    public static int max_num = 1;\n    \n    public static void set_max(int num) {\n        result[0] = new Long(1);\n        result[1] = new Long(1);\n        if ( num > max_num ) {\n            Long[] new_result = new Long[num+1];\n            \n            for (int i=0; i<=max_num; i++) {\n                new_result[i] = result[i];\n            }\n            \n            result = new_result;\n            \n            for (int i=max_num+1; i<=num; i++) {\n                result[i] = new Long(0);\n            }\n            max_num = num;            \n        }\n    }\n    \n    Fibonacci(long n) {\n        this.n = n;\n        if ( n > 1 )\n            set_max((int)n);\n    }\n        \n    public Long compute() {\n        Long ret;\n        if ( result[(int)n].longValue() != 0 ) {\n            return result[(int)n];\n        }\n        if (n<=10) {\n            return do_fibonacci(n);\n        }\n        ForkJoinTask<Long> subTask = new Fibonacci(n-1);\n        ret = new Fibonacci(n-2).compute() + subTask.join();\n        subTask.fork();\n        result[(int)n] = new Long(ret);\n        return ret;\n    }\n    \n    static long do_fibonacci(long n) {\n        long ret;\n        if (result[(int)n].longValue() != 0) {\n            ret = result[(int)n].longValue();\n        } else {\n            long ret_n_1 = do_fibonacci(n-1);\n            long ret_n_2 = do_fibonacci(n-2);\n            ret = ret_n_1 + ret_n_2;\n            result[(int)n] = new Long(ret);\n        }\n        return ret;\n    }\n}','will wait forever a subtask has to be fork()ed before it can rejoin the \nmain task. ','General',1,NULL),(3387,'private final ReentrantReadWriteLock    rwl         = new ReentrantReadWriteLock();\nprotected final Lock                    readLock    = rwl.readLock();\nprotected final Lock                    writeLock   = rwl.writeLock();\nprotected final Condition               hasData     = writeLock.newCondition();\n\n\npublic void write() {\n\n    writeLock.lock();\n    try {\n        // write data\n        // ...\n        if (something_written) {\n            hasData.signalAll();\n        }\n    }\n    finally {\n        writeLock.unlock();\n    }\n}\n\n// replace Object by something else\npublic Object read() throws InterruptedException {\n\n    Object data = tryRead();\n\n    while (data == null) {\n        waitForData();\n        data = tryRead();\n    }\n\n    return data;\n}\n\n// replace Object by something else\nprivate Object tryRead() {\n\n    readLock.lock();\n    try {\n        Object data = null;\n        // read data\n        // ...\n        // if there no data available, return null\n        return data;\n    }\n    finally {\n        readLock.unlock();\n    }\n}\n\nprivate void waitForData() throws InterruptedException {\n\n    writeLock.lock();\n    try {\n        boolean data_available = // check data\n        while (!data_available) {\n            hasData.await(1000L, TimeUnit.MILLISECONDS);\n            data_available = // check data\n        }\n    }\n    finally {\n        writeLock.unlock();\n    }\n}\n','This is the same behavior of your typical ReadWriteLock usage case if there\n is available data for reading. If no data exists, then a reader becomes a\n \"writer\" (in the lock sense) and waits until some data is available. The \ncycle repeats until some available data is returned (or until an interrupt \noccurs).\n\nSince you\'re using a ReadWriteLock, it means you\'re expecting a much \ngreater number of reads than writes and so you chose a lock that minimizes \ncontention between reader threads (the readLock).\n\nThe method waitForData() turns readers into \"writers\" because they lock on\n the writeLock instead, resulting in an increased contention between all\n threads (readers and writers). However, since writes are assumed to be \nmuch rarer than reads, a situation where data keeps toggling fast \nbetween \"available\" and \"unavailable\" is not expected. In other words, \nassuming writes are rare:\n\n    If there is no available data for reading, then virtually all readers\n will typically block in the method waitForData() after some time, and\n will all be notified at the same time when some new data is written.\n\n    If there is some available data for reading, then all readers will\n simply read it without creating any contention among the threads when \nlocking the readLock.\n','Concurrency',1,NULL),(3388,'private final ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();\nprotected final Lock readLock = rwl.readLock();\nprotected final Lock writeLock = rwl.writeLock();\nprotected final Condition hasData = writeLock.newCondition();\nprivate HashMap myData = new HashMap(); //example structure to read and write\n\nprivate final ReentrantLock dataArrivalLock = new ReentrantLock();\nprivate final Condition dataArrivalSignal = dataArrivalLock.newCondition();\n\nYour writer method pattern :\n\ntry {\n   writeLock.lock();    \n\n   //...\n   myData.put(\"foo\",\"ffoo\"); //write something !!\n   if( something_written ) {\n      hasData.signalAll();\n   }\n\n}\nfinally {\n   writeLock.unlock();\n}\n  try {\n                //signal other threads that data has been put in\n                dataArrivalLock.lock();\n                dataArrivalSignal.signalAll();\n\n            } finally {\n                dataArrivalLock.unlock();\n            }\n\nYour reader method pattern\n\ntry {\n            boolean gotData = false;\n            while (!gotData) {\n                try {\n                    readLock.lock();\n                    if (myData.size() > 0) {\n                        gotData = true;\n                        //retrieve the data that is written by writer thred!!\n                        myData.get(\"foo\");\n                    }\n                } finally {\n                    readLock.unlock();\n                }\n                if(!gotData) {\n //sleep the reader thread for x milliseconds. x depends on your application requirement\n                  //   Thread.sleep(250);\n                    try {\n                        //instead of Thread.sleep(), use the dataArrivalLock signal to wakeup\n                        dataArrivalLock.lock();\n                        dataArrivalSignal.await();\n                        //based on how the application works a timed wait might be better !!\n                        //dataArrivalSignal.await(250);\n                    } finally {\n                        dataArrivalLock.unlock();\n                    }\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        } ','What this does is force your reader thread to sleep until some data is written by the writer thread .','Concurrency',1,NULL),(3389,'class CarRadio extends Thread {\n    \n    public void run(){\n      while(true){  \n        Song nextSong = DJ.spinNextTrack();\n        play(nextSong);\n        try{ Thread.sleep(2000); } catch(InterruptedException e) { }\n      }\n    }\n    public void play(Song song){\n        System.out.println(\"CarRadio: \"+song.getClip());\n    }\n    \n}\n\nclass DJ {\n    private final static LinkedList<Song> queue = new LinkedList<>();\n    private final static ReentrantReadWriteLock queueLock = new ReentrantReadWriteLock();\n    private final static Lock readLock = queueLock.readLock();\n    private final static Lock writeLock = queueLock.writeLock();\n    private final static Condition newSong = writeLock.newCondition();\n    private final static Condition readSong = readLock.newCondition();\n    private final static DJ INSTANCE = new DJ();\n    \n    private DJ(){\n\n    }\n    \n    public static DJ callDJ(){\n        return INSTANCE;\n    }\n\n    public static Song spinNextTrack(){\n        readLock.lock();\n        try{\n            if(queue.isEmpty()){\n                try { newSong.await(); }catch(InterruptedException e) { }\n            }\n            return queue.poll(); \n        } finally {\n            readLock.unlock();\n        }      \n    }\n\n    public static void addToQueue(Song song){\n        writeLock.lock();\n        try{\n            //this lock blocks until acquired\n            //queueLock.writeLock().lock();\n            queue.add(song);\n            newSong.signalAll();\n        } finally{\n            writeLock.unlock();\n        }\n    }\n}\n\nclass ConstantPop extends Thread {\n    private String[] sounds = {\" Lah \", \" La La \", \" Naaahh \", \" YOLO \" };\n    private static int songCounter = 0;\n    \n    public void run(){\n        while(true){\n            Song hotNewSong = studio();\n            DJ.addToQueue(hotNewSong);\n            try { Thread.sleep(2000); } catch(InterruptedException e) { }  \n        }\n    }\n    private Song studio(){\n        StringBuilder sb = new StringBuilder();\n        for(int i = 0; i<=3; i++){\n            sb.append(sounds[ThreadLocalRandom.current().nextInt(0,3)]);\n        }\n        songCounter++;\n        return new Song(\"PopSong.\"+songCounter,sb.toString());\n    }\n}','Read lock does not support Conditions so calling newCondition() will cause \nan UnsupportedOperationException','Concurrency',1,NULL),(3390,'Which Collection from java.util.concurrent is best when there are more reads\nthan writes','Copy on write, because they mkae a new copy of the collection for each write.','Concurrency',1,NULL),(3391,'ConcurrentSkipListMap and concurrentMap atomic methods','putIfAbsent(K key, V value)\n\nremove(Object key, Object value)\n\nreplace(K key, V value)\n\nreplace(K key, V oldValue, V newValue)','Concurrency',1,NULL),(3392,'Factory patter:','a concrete class with static methods is used to create instances of objects \nthat implement an interface.','Concurrency',1,NULL),(3393,'what pattern ?\n\npublic interface Vehicle {\n	public void start();\n	public void stop();\n}\n\npublic class Car implements Vehicle {\n	public void start() { }\n	public void stop() { }\n}\n\npublic class CarManufacturer {\n	public static Vehicle getVehicle(String type) {\n		//create an instance of the type passed in\n	}\n}\n\nclass MyClass {\n	psmv(sa) {\n		Vehicle ferrari = CarManufacturer.getVehicle(\"Ferrari\");\n	\n		ferrari.start();\n	}\n}','Factory,\n\nfactory is used to create instances of classes that implement an interface.\nCan be used at runtime to decide which object to create at runtime','Concurrency',1,NULL),(3394,'for jdbc 3.0 drivers and earlier you are responsible for loading the class\nusing static forName(). Later driver classes are loaded automatically.','','Concurrency',1,NULL),(3395,'public class Hello {\n    public static void main(String[] args){\n        try {\n            Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\");\n            Statement st = conn.createStatement();\n            String query = \"Select * From employees limit 10\";\n            ResultSet rs = st.executeQuery(query);\n            while(rs.next()){\n                System.out.println(rs.getInt(\"emp_no\"));\n                System.out.println(rs.getString(\"first_name\"));\n                System.out.println(rs.getString(\"last_name\"));\n            } \n            \n        } catch(SQLException e){ }\n        \n    }\n}\n','10001\nGeorgi\nFacello\n10002\nBezalel\nSimmel\n10003\nParto\nBamford\n10004\nChirstian\nKoblick\n10005\nKyoichi\nMaliniak\n10006\nAnneke\nPreusig\n10007\nTzvetan\nZielinski\n10008\nSaniya\nKalloufi\n10009\nSumant\nPeac\n10010\nDuangkaew\nPiveteau','Concurrency',1,NULL),(3396,'public class Hello {\n    public static void main(String[] args){\n        try {\n            Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\");\n            Statement st = conn.createStatement();\n            String update = \"update employee set emp_no = 11111 where first_name = Georgi\";\n            ResultSet rs = st.executeUpdate(update);\n            while(rs.next()){\n                System.out.println(rs.getInt(\"emp_no\"));\n                System.out.println(rs.getString(\"first_name\"));\n                System.out.println(rs.getString(\"last_name\"));\n            } \n            \n        } catch(SQLException e){ }\n        \n    }\n}','will not compile, executeUPdate returns an int of updated rows.','Concurrency',1,NULL),(3397,'what jdbc method would you use when you are unsure of the result of a query\nor update','execute(String sql) \n\nthe return value is true if the result is a result set and false if the \nquery is an update count or no results. \n\n','Concurrency',1,NULL),(3398,'public class Hello {\n    public static void main(String[] args){\n        try {\n            Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\");\n            Statement st = conn.createStatement();\n            String update = \"Update employees Set first_name = \'Big John\' where first_name = \'Georgi\'\";\n            boolean b = st.execute(update);\n            System.out.println(b);\n        } catch(SQLException e){System.out.println(\"something went wrong\"); }\n        \n    }\n}','false \n\nexecute returns true if it returns a result set and false for an update count','Concurrency',1,NULL),(3399,'public class Hello {\n    public static void main(String[] args){\n        try {\n            Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\");\n            Statement st = conn.createStatement();\n            String update = \"Update employees Set first_name = \'Big John\' where first_name = \'Georgi\'\";\n            boolean b = st.execute(update);\n            if(b){\n                //ResultSet res = update.getResultSet();\n                ResultSet res = st.getResultSet();\n            } else {\n                int numrows = st.getUpdateCount();\n                if(numrows == -1){\n                    System.out.println(\"No Results\");\n                }\n            }\n        } catch(SQLException e){System.out.println(\"something went wrong\"); }\n        \n    }\n}','if getUpdateCount() returns -1 then there were no results.','Concurrency',1,NULL),(3400,'public class Hello {\n    public static void main(String[] args){\n        try {\n            Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\");\n            Statement st = conn.createStatement();\n            String update = \"Update employees Set first_name = \'Big John\' where first_name = \'Georgi\'\";\n            boolean b = st.execute(update);\n            if(b){\n                ResultSet res = update.getResultSet();\n            } else {\n                int numrows = st.getUpdateCount();\n                if(numrows == -1){\n                    System.out.println(\"No Results\");\n                }\n            }\n        } catch(SQLException e){System.out.println(\"something went wrong\"); }\n        \n    }\n}','will not compiles, getResultSet is from a statement object','Concurrency',1,NULL),(3401,'public class Hello {\n    public static void main(String[] args){\n        try {\n            Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\");\n            Statement st = conn.createStatement();\n            String update = \"Select first_name from employees\";\n            boolean b = st.execute(update);\n            if(b){\n                //ResultSet res = update.getResultSet();\n                ResultSet res = st.getResultSet();\n                System.out.println(res.getString(\"first_name\"));\n            } else {\n                int numrows = st.getUpdateCount();\n                if(numrows == -1){\n                    System.out.println(\"No Results\");\n                }\n            }\n            \n            \n        } catch(SQLException e){System.out.println(\"something went wrong\"); }\n        \n    }\n}','something went wrong\n\nyou have to always call next() before processing a rown from a result set \nthe cursors starts out as before the first row.\n\nIt is a sqlexception to try to get a row when it is before the first row.','Concurrency',1,NULL),(3402,'public class Hello {\n    public static void main(String[] args){\n        try {\n            Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\");\n            Statement st = conn.createStatement();\n            String update = \"Select first_name from employees\";\n            boolean b = st.execute(update);\n            if(b){\n                //ResultSet res = update.getResultSet();\n                ResultSet res = st.getResultSet();\n                res.next();\n                System.out.println(res.getString(\"first_name\"));\n            } else {\n                int numrows = st.getUpdateCount();\n                if(numrows == -1){\n                    System.out.println(\"No Results\");\n                }\n            }\n            \n            \n        } catch(SQLException e){System.out.println(\"something went wrong\"); }\n        \n    }\n}\n','Big John','Concurrency',1,NULL),(3403,'ublic class Hello {\n    public static void main(String[] args){\n        try {\n            Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\");\n            Statement st = conn.createStatement();\n            String update = \"Select first_name from employees\";\n            boolean b = st.execute(update);\n            if(b){\n                ResultSet res = st.getResultSet();\n                res.next();\n                System.out.println(res.getInt(1));\n                System.out.println(res.getDate(2));\n                System.out.println(res.getString(3));\n                \n            } else {\n                int numrows = st.getUpdateCount();\n                if(numrows == -1){\n                    System.out.println(\"No Results\");\n                }\n            }\n            \n            \n        } catch(SQLException e){System.out.println(e); }\n        \n    }\n}','SQLException invalid value for getInt()\n\nyour sql query only selected the firstnames, there are no other coluns to get\ninfo from. ','JDBC',1,NULL),(3404,'public class Hello {\n    public static void main(String[] args){\n        try {\n            Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\");\n            Statement st = conn.createStatement();\n            String update = \"Select * from employees\";\n            boolean b = st.execute(update);\n            if(b){\n                ResultSet res = st.getResultSet();\n                res.next();\n                System.out.println(res.getInt(1));\n                System.out.println(res.getDate(2));\n                System.out.println(res.getString(3));\n                \n            } else {\n                int numrows = st.getUpdateCount();\n                if(numrows == -1){\n                    System.out.println(\"No Results\");\n                }\n            }\n            \n            \n        } catch(SQLException e){System.out.println(e); }\n        \n    }\n}','run:\n10001\n1953-09-02\nBig John\nBUILD SUCCESSFUL (total time: 1 second)\n','JDBC',1,NULL),(3405,'public class Hello {\n    public static void main(String[] args){\n        try {\n            Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\");\n            Statement st = conn.createStatement();\n            String update = \"Select * from employees\";\n            boolean b = st.execute(update);\n            if(b){\n                ResultSet res = st.getResultSet();\n                res.next();\n                System.out.println(res.getInt(0));\n                System.out.println(res.getDate(1));\n                System.out.println(res.getString(2));\n                \n            } else {\n                int numrows = st.getUpdateCount();\n                if(numrows == -1){\n                    System.out.println(\"No Results\");\n                }\n            }\n            \n            \n        } catch(SQLException e){System.out.println(e); }\n        \n    }\n}','sql exception index out of range,\n\nindexs range from 1 to the size','JDBC',1,NULL),(3406,'public class Hello {\n    public static void main(String[] args){\n        try {\n            Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\");\n            Statement st = conn.createStatement();\n            String update = \"Select * from employees\";\n            boolean b = st.execute(update);\n            if(b){\n                ResultSet res = st.getResultSet();\n                System.out.println(res.getInt(1));\n                System.out.println(res.getDate(2));\n                System.out.println(res.getString(3));\n                \n            } else {\n                int numrows = st.getUpdateCount();\n                if(numrows == -1){\n                    System.out.println(\"No Results\");\n                }\n            }\n            \n            \n        } catch(SQLException e){System.out.println(e); }\n        \n    }\n}\n','sqlexception, next() was not called before processing a result set','JDBC',1,NULL),(3407,'java.sql.Date extends java.util.Date\n\nwhats the main difference\n\njava.sql.Date pubDate = rs.getDate(\"PubDate\");','sql Date stores in the form yyyy mm dd','JDBC',1,NULL),(3408,'java.sql.Time time = rs.getTime(\"FinishTime\");\n\nwhat form does this kind of Time take ?','\"hh:mm:ss\"','JDBC',1,NULL),(3409,'use getObject for a general purpose get()\n\njdbc will return a wrapper for the appropriate sql type.\n\nso a sql int would return integer\n\nObject o = rs.getObject(\"AuthorID\");\nif( o instanceof Integer){\n	//do\n}','','JDBC',1,NULL),(3410,'How can you figure out the number of columns in a ResultSet ?','String query = \"  \";\nResultSet res = stmt.executeQuery(query);\nReslutSetMetaData rsmd = rs.getMetaData();\nrs.next();\nint colCount = rsmd.getColumnCount();','JDBC',1,NULL),(3411,'public class Hello {\n    public static void main(String[] args){\n        try {\n            Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\");\n            Statement st = conn.createStatement();\n            String q = \"Select * from employees\";\n            \n            ResultSet rs = st.executeQuery(q);\n            ResultSetMetaData rmd = rs.getMetaData();\n            int cols = rmd.getColumnCount();\n            \n            for(int i = 1; i <= cols; i++){\n                System.out.println(rmd.getTableName(i));\n                System.out.println(rmd.getColumnName(i));\n                System.out.println(rmd.getColumnDisplaySize(i));\n            } \n        } catch(SQLException e){System.out.println(e); }\n        \n    }\n}','employees\nemp_no\n11\nemployees\nbirth_date\n10\nemployees\nfirst_name\n14\nemployees\nlast_name\n16\nemployees\ngender\n1\nemployees\nhire_date\n10','JDBC',1,NULL),(3412,'public class Hello {\n    public static void main(String[] args){\n        try {\n            Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\");\n            Statement st = conn.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE,ResultSet.CONCUR_READ_ONLY);\n            String q = \"Select * From employees limit 100\";\n            ResultSet rs = st.executeQuery(q);\n            \n            rs.first();\n            System.out.println(\"First entry:\");\n            System.out.println(rs.getString(\"first_name\") + \" \" +rs.getString(\"last_name\"));\n            \n            rs.last();\n            System.out.println(\"Last entry:\");\n            System.out.println(rs.getString(\"first_name\") + \" \" +rs.getString(\"last_name\"));\n            \n            rs.absolute(20);\n            System.out.println(\"row: \"+ rs.getRow());\n            System.out.println(rs.getString(\"first_name\") + \" \" +rs.getString(\"last_name\"));\n            \n            rs.relative(10);\n            System.out.println(\"row: \"+ rs.getRow());\n            System.out.println(rs.getString(\"first_name\") + \" \" +rs.getString(\"last_name\"));  \n        } catch(SQLException e){System.out.println(e); }\n        \n    }\n}','First entry:\nMicheal Boyd\nLast entry:\nKenroku Malabarba\nrow: 20\nKyoichi Maliniak\nrow: 30\nGuoxiang Nooteboom','JDBC',1,NULL),(3413,'Once created you cannot change the concurrency or Cursor type of an existing\nstatement object.','true','JDBC',1,NULL),(3414,'if cursor or concurrency settings are not supported then the driver will show\na warning and silently revert to default settings. ','','JDBC',1,NULL),(3415,'public class Hello {\n    public static void main(String[] args){\n       int a = 8;\n        System.out.println(\"what is b? :\"+a++);\n    }\n}','what is b? :8\n','JDBC',1,NULL),(3416,'public class Hello {\n   \n    public static void main(String[] args) {\n        Hello h = new Hello();\n        h.methodlocal();\n    }\n    \n    public void methodlocal(){\n        int y = 56;\n        \n        private class Zombie {\n            public int size;\n        \n            public Zombie(int x){ size = x;}\n            public void mone(){\n                System.out.println(\"ughhhg: \"+ size);\n            }\n            \n            public void accessTheLiving(){\n                System.out.println(\"local var: \"+y);\n            }\n            \n        }\n        \n        Zombie zom = new Zombie(7);\n        \n    }\n\n}','method local inner classes cannot access non final local variables,\n\nalso method local classes are just like local variables they cannot be \n	static private public protected or anything else','JDBC',1,NULL),(3417,'public class Hello {\n    public static void main(String[] args){\n        List<Animal> animals = new ArrayList<Animal>();\n        animals.add(new Dog());\n        animals.add(new Animal());\n    }\n    public static void addAnimal(List<Object> animals) {\n	animals.add(new Dog());\n    }\n}\n\nclass Dog extends Animal {}\nclass Animal { }','compiles fine','JDBC',1,NULL),(3418,'public class Hello<T> {\n    \n    public static void main(String[] args){\n        ArrayList<Beagle> a = new ArrayList<>();\n        ArrayList<Animal> b = new ArrayList<>();\n        \n        Hello<String> x = new Hello<>();\n        \n        \n        \n        x.copyColl(a,b);\n        \n\n    } \n    public <G extends Being> void copyColl(Collection<? extends G> src, Collection<? super G> dest){\n        \n        for(G n : dest)\n            src.add(n);\n        \n    }\n}\n\nclass Beagle extends Animal { }\nclass Animal extends Being {} \nclass Being { }','will not compile, \n\nfirst you cant add to a collection defined with ? extends. \n\nsecond, since dest is defined with ? super it is saying that that collection\ncan be of any type of super class of G,thouhg you can still add only G. \n\nTherefore the iterator will return objects not Gs.\n\nYou are taking from dest and adding to src. dest is the producer and src is the\nconsumer. Producers extend Consumers Super. ITs backward here. ','Collections',1,NULL),(3419,'public class Hello<T> {\n    \n    public static void main(String[] args){\n        ArrayList<RedWolf> a = new ArrayList<>();\n        ArrayList<Animal> b = new ArrayList<>();\n        \n        Hello<String> x = new Hello<>();\n        \n        \n        \n        x.copyColl(a,b);\n        \n\n    } \n    public <G extends Beagle> void copyColl(Collection<? extends G> src, Collection<? super G> dest){\n        \n        for(G g : src)\n            dest.add(g);\n        \n    }\n}\n\n\nclass GoodBeagles extends Beagle { }\nclass Beagle extends Animal { }\nclass Animal extends Being {} \nclass Being { }\nclass Wolf { } \nclass RedWolf{ }','will not compile redwolf does not extend beagle','Collections',1,NULL),(3420,'public class Hello {\n    public static void main(String[] dicks){\n         try {\n            Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\");\n            Statement st = conn.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_UPDATABLE);\n            String q = \"Select * from employees\";\n            ResultSet rs = st.executeQuery(q);\n            \n            if(rs.last()){\n               int rowCount = rs.getRow();\n               rs.beforeFirst();\n                System.out.println(rowCount);\n            }\n            \n            \n        } catch(SQLException e){System.out.println(e); }\n    }\n}','shows the number of rows ','Collections',1,NULL),(3421,'public class Hello {\n    public static void main(String[] dicks){\n         try {\n            Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\");\n            Statement st = conn.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_UPDATABLE);\n            String q = \"Select * from employees limit 100\";\n            ResultSet rs = st.executeQuery(q);\n            rs.absolute(-10);\n             System.out.println(rs.getRow()); \n        } catch(SQLException e){System.out.println(e); }\n    }\n}','91\n\nif absolute takes a - number it starts from the last row and works backward. \n\nreturns false if the cursor is beyond the lst row or beffore the first','Collections',1,NULL),(3422,'public class Hello extends Thread {\n    public static void main(String[] args){\n        try(Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees\", \"root\", \"Basketball12\")){\n            String getAllEmployeeNames = \"select first_name,last_name from employees\";\n            Statement st1 = conn.createStatement();\n            \n            ResultSet empnames = st1.executeQuery(getAllEmployeeNames);\n            \n            empnames.last();\n            \n            System.out.println(empnames.getString(\"first_name\")+\" \"+empnames.getString(\"last_name\"));\n            \n        }catch(SQLException e){\n            System.out.println(e);\n        }\n    }\n}','Sachin Tsukuda','JDBC',1,NULL),(3423,'public class Hello {\n    public static void main(String[] dicks){\n         try {\n            Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\");\n            Statement st = conn.createStatement(ResultSet.TYPE_FORWARD_ONLY,ResultSet.CONCUR_UPDATABLE);\n            String q = \"Select * from employees limit 100\";\n            ResultSet rs = st.executeQuery(q);\n            System.out.println(rs.getRow()); \n        } catch(SQLException e){System.out.println(e); }\n    }\n}','0','JDBC',1,NULL),(3424,'public class Hello {\n    public static void main(String[] dicks){\n         try {\n            Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\");\n            Statement st = conn.createStatement(ResultSet.TYPE_FORWARD_ONLY,ResultSet.CONCUR_UPDATABLE);\n            String q = \"Select * from employees limit 100\";\n            ResultSet rs = st.executeQuery(q);\n            rs.afterLast();\n            System.out.println(rs.getRow()); \n        } catch(SQLException e){System.out.println(e); }\n    }\n}','also 0','JDBC',1,NULL),(3425,'public class Hello {\n    public static void main(String[] dicks){\n         try {\n            Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\");\n            Statement st = conn.createStatement(ResultSet.TYPE_FORWARD_ONLY,ResultSet.CONCUR_UPDATABLE);\n            String q = \"Select * from employees limit 100\";\n            String q2 = \"Select * from salaries limit 100\";\n            ResultSet rs = st.executeQuery(q);\n            rs.afterLast();\n            System.out.println(rs.getRow()); \n            conn.close();\n            rs = st.executeQuery(q2);\n            while(rs.next()){\n                System.out.println(rs.getInt(\"salary\"));\n            }\n        } catch(SQLException e){System.out.println(e); }\n    }\n}','run:\n0\njava.sql.SQLException: No operations allowed after statement closed.\nBUILD SUCCESSFUL (total time: 0 seconds)\n\nit is not an exception to call getRow after the last row or before the first.\nit will simply give zero. \n','JDBC',1,NULL),(3426,'public class Hello {\n    public static void main(String[] dicks){\n         try(Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\");\n            Statement st = conn.createStatement(ResultSet.TYPE_FORWARD_ONLY,ResultSet.CONCUR_UPDATABLE);) {\n            String q = \"Select * from employees limit 100\";\n            String q2 = \"Select * from salaries limit 100\";\n            ResultSet rs = st.executeQuery(q);\n            rs.afterLast();\n            System.out.println(rs.getRow()); \n        } catch(SQLException e){System.out.println(e); }\n    }\n}','0','JDBC',1,NULL),(3427,'String url = \"   \";\nString user = \"  \";\nString pwd = \"    \";\n\n// insert here\nConnection conn = DriverManaget.getConnection(url,user,pwd);\n\nwhat would you use to load a JDBC 3.0 driver class','Class.forName(\"org.abc.mmmysql.Driver\");','JDBC',1,NULL),(3428,'What does it take for a driver to be jdbc 4.0 compliant ?	','Must include a MEAT-INF file, this allows the driver to autoload.\n\nMust provide implementations of Driver, Connection, Statement, ResultSet\ninterfaces\n\nMust support transactions\n\n','JDBC',1,NULL),(3429,'What three are availabe through an instance of DatabaseMetaData ?\n\n1 number of columns returned\n2 number of rows returned\n3 name of jdbc driver\n4 default transaciton isolation level\n5 last query used\n6 names of stored procedures\n7 current Savepoint name','3\n4\n6','JDBC',1,NULL),(3430,'try {\n	Statement st = conn.createStatement();\n	String query = \"Select * From Author Where LastName Like \'Rand%\'\";\n	Resultset rs = st.executeQuery(query);\n	if(rs == null) {\n		sout( \"no results\" );\n	} else {\n		sout(rs.getString(\"FirstName\");\n	}\n} catch(SQLException se) {\n	sout(\"SQLException\");\n}','SQLException, next() wass not called the cursors starts of pointing to BEFORE\nthe first row. ','JDBC',1,NULL),(3431,'public class Hello {\n    public static void main(String[] dicks){\n         try(Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employee?useSSL=false\", \"root\", \"Basketball12\")){\n             String query = \"Update employees set first_name = \'Hefty\' where emp_no = 10001\"; \n             Statement st = conn.createStatement();\n             st.executeQuery(query);\n         } catch(SQLException e){\n             System.out.println(\"SQLException\");\n         }\n    }\n \n}','SQLException\n\nexecuteQuery cannot be used to execute update insrt delete or ddl statements \nor it will throw a sqlexception. \n','JDBC',1,NULL),(3432,'try {\n	ResultSet rs = null;\n	try (Statement st = conn.createStatement()) {\n		String query = \"Select * From Customer\";\n		rs = st.executeQuery(query);\n	} catch(SQLException se) {\n		sout(\"Illegal query\");	\n	}\n\n	while (rs.next()) {\n		//process customers \n	}\n} catch(SQLException e) {\n	sout(\"SQLException\");\n}','SQLException\n\ntrying to access a closed ResultSet. ','JDBC',1,NULL),(3433,'Statement st = conn.createStatement();\nResultSet rs;\nString query = \"<QUERY HERE>\";\nst.execute(query);\nif ((Rs = st.getResultSet()) != null) {\n	sout(\"Results\");\n}\nif (st.getUpdateCount() > -1) {\n	sout(\"update\");\n}\n\nSelect * from customer\ninsert into ...\nupdate...\ndelete...','these would all produce their indicated rsults, update will produce and update count\neven if no rows are affected','JDBC',1,NULL),(3434,'String q = \"update customer set Last_name = ? Where Customer_id = ?\";\ntry {\n	PreparedStatement pt = conn.prepareStatement(q);\n	pt.setString(0,\"Smith\");\n	pt.setString(1,\"5001\");\n	int result = pt.executeUpdate();\n	if(result != 1) sout(\"error\");\n} catch(SQLException e) {\n	sout(\"Exception\");\n}','exception\n\nparameters are numbered starting from 1 not 0.','JDBC',1,NULL),(3435,'try {\n	String[] searchPair = {\"%a%\", \"%b%\",\"%c%\",\"%d%\" };\n	String query = \"Sleect ... ? ... ?\";\n	PreparedStatement pt = conn.PrepareStatement(query);\n	for(int i = 0; i < searchPair.length; i+=2) {\n		pt.setString(i+1, searchPAir[i]);\n		pt.setString(i+2, searchPair[i++]);\n		ResultSet rs = pt.executeQuery();\n		while(rs.next()) {\n			sout(\"yes\");\n		}\n	}\n} catch(Sqlexcepiton ee) {\n	sout	(\"SQLException\");\n}\n			','yes yes sqlexception everything is smooth on the first iteration, but \nthe second the preparedstatement index paramenters will be 3 and 4 when there\nare only two parameters, this will cause the exc.','JDBC',1,NULL),(3436,'public class Hello {\n    public static void main(String[] dicks){\n         List<?> list = new ArrayList<Dog>();\n         list.add(new Dog());\n         list.add(new Dog());\n         list.add(new Dog());\n    }\n \n}\n\nclass Dog {\n    \n}','Collections of type ? can be assigned to by any type of list but cannot be\nadded to. ','Collections',1,NULL),(3437,'public class Hello {\n    public static void main(String[] dicks){\n         List<Dog> Doglist = new ArrayList<Dog>();\n         Doglist.add(new Dog(\"Charly\"));\n         Doglist.add(new Dog(\"Baily\"));\n         Doglist.add(new Dog(\"Wiley\"));\n         \n         List<?> unmodifiableDogList = Doglist;\n         \n         for(Dog d : unmodifiableDogList){\n             System.out.println(d.getName());\n         }\n    }\n \n}\n\nclass Dog {\n    private String name;\n    public Dog(String s ){\n        name = s;\n    }\n    \n    public String getName(){\n        return name;\n    }\n    \n}','will not compile, object cannot be converted to Dog.\nThe objects comming out of a List<?> are Objects.','Collections',1,NULL),(3438,'public class Hello {\n    public static void main(String[] dicks){\n         List<Dog> Doglist = new ArrayList<Dog>();\n         Doglist.add(new Dog(\"Charly\"));\n         Doglist.add(new Dog(\"Baily\"));\n         Doglist.add(new Dog(\"Wiley\"));\n         \n         ArrayList<?> unmodifiableDogList = Doglist;\n         \n         for(Object d : unmodifiableDogList){\n             System.out.println(d.getName());\n         }\n    }\n \n}\n\nclass Dog {\n    private String name;\n    public Dog(String s ){\n        name = s;\n    }\n    \n    public String getName(){\n        return name;\n    }\n    \n}','althought the base type here is ArrayList Doglist is defined as a list \nso it cannot be assigned to an ArrayList ','Collections',1,NULL),(3439,'public class Hello<T> {\n    public static void main(String[] args){\n        \n        Dog d = new Dog();\n        \n        ArrayList x = makeArrayList(d);\n        \n        ArrayList c = new ArrayList<String>();\n        c.add(new Dog());\n        c.add(90);\n\n    } \n    public static <G> ArrayList<G> makeArrayList(G g){\n        ArrayList<G> genlist = new ArrayList();\n        genlist.add(g);\n        return genlist;\n        \n    }\n}\n\nclass Dog {\n    \n}','compiles fine the reference type is still defined as a raw type','Collections',1,NULL),(3440,'public class Hello {\n    public static void main(String[] args){\n       File file1 = new File(\"~/Public/TestDir/file1\");\n       File file2 = new File(\"~/Public/TestDir/file2\");\n       File dir = new File(\"~/Public/TestDir\");\n       \n       if(dir.exists() && dir.isDirectory()){\n           file1.createNewFile();\n           file2.createNewFile();\n       } else {\n           dir.mkdir();\n           file1.createNewFile();\n           file2.createNewFile();\n       }\n    } \n}','will not compile, all those methods throw IOExceptions','Input/Output',1,NULL),(3441,'public class Hello<T> {\n    \n    public static void main(String[] args){\n        \n        Dog d = new Dog();\n        \n        ArrayList<? extends Dog> c = new ArrayList<Beagle>();\n        Animal a = c.get(0);\n    } \n}\n\nclass Animal{}\nclass Dog extends Animal { }\nclass Beagle extends Dog { }','fine','Generics',1,NULL),(3442,'public class Hello<T> {\n    \n    public static void main(String[] args){\n        ArrayList<Animal> a;\n        ArrayList<Beagle> b;\n        \n        Hello<String> x = new Hello<>();\n        \n        x.copyColl(a,b);\n        \n\n    } \n    public <G> void copyColl(Collection<G extends Animal> src, Collection<G> dest){\n        \n        for(G n : src)\n            dest.add(n);\n        \n    }\n}\n\nclass Animal{}\nclass Dog extends Animal { }\nclass Beagle extends Dog { }','will not compile wrong number of type arguments, \nthis is a generic method, \n\nit should be <? extends Animal>','Generics',1,NULL),(3443,'public class Hello<T> {\n    \n    public static void main(String[] args) {\n        Cat cat = parse(\"cat\");\n        Dog dog = parse(\"dog\");\n        System.out.println(\"the cat object is a \" + cat);\n        System.out.println(\"the dog object is a \" + dog);\n    }\n\n    private static class Dog {\n        public String toString() { return \"dog\"; }\n    }\n\n    private static class Cat {\n        public String toString() { return \"cat\"; }\n    }\n\n    private static Object untypedParse(String stringToParse) {\n        if(stringToParse.equals(\"dog\")) {\n            return new Dog();\n        } else if(stringToParse.equals(\"cat\")) {\n            return new Cat();\n        } else {\n            throw new RuntimeException(\"not expected\");\n        }\n    }\n\n    public static <T> T parse(String stringToParse) {\n        return (T)untypedParse(stringToParse);\n    }\n\n}','in java 7 and beyond the compiler can infer the type from the return type !','Generics',1,NULL),(3444,'//How to fix this\npublic static T fromXml<T>(String xml) {\n  try {\n    JAXBContext context = JAXBContext.newInstance(T.class);\n    Unmarshaller um = context.createUnmarshaller();\n    return (T)um.unmarshal(new StringReader(xml));\n  } catch (JAXBException je) {\n    throw new RuntimeException(\"Error interpreting XML response\", je);\n  }\n}\n\n//Also the call doesn\'t work...\nfromXml<SomeSubObject>(\"<xml/>\");','First it should be: public static <T> T fromXML<T>(String xml)\n\nIn Java, generics are compile-time only data, which are lost at run time. \nSo, if you called a method like that, the JVM would have no way of knowing what T.class was. \nThe normal way to get around this is to pass a class instance object as a parameter to the method, \nlike this:\n\npublic static <T> T fromXml(Class<T> clazz, String xml) {\n  try {\n    JAXBContext context = JAXBContext.newInstance(clazz);\n    Unmarshaller um = context.createUnmarshaller();\n    return (T)um.unmarshal(new StringReader(xml));\n  } catch (JAXBException je) {\n    throw new RuntimeException(\"Error interpreting XML response\", je);\n  }\n}\n\nfromXml(SomeSubObject.class, \"<xml/>\");\n\n','Generics',1,NULL),(3445,'public class Hello<T> {\n    \n    public static void main(String[] args){\n        try (Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\")){\n            String prepInsert = \"Insert into employees values(?,\'1962-11-07\',?,?,\'F\',\'1962-11-07\')\";\n            PreparedStatement ps = conn.prepareStatement(prepInsert,ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_UPDATABLE);\n            ps.setInt(1,555);\n            ps.setString(3,\"Angela\");\n            ps.setString(4,\"Horton\");\n            \n            int rowsupdated = ps.executeUpdate();\n            \n            System.out.println(rowsupdated);\n\n        }catch(Exception e){\n            System.out.println(e);\n            \n        }\n        \n    }\n}','java.sql.SQLException: Parameter index out of range (4 > number of parameters, which is 3).','JDBC',1,NULL),(3446,'public class Hello<T> {\n    \n    public static void main(String[] args){\n        try (Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\")){\n            String prepInsert = \"Insert into employees values(?,\'1962-11-07\',?,?,\'F\',\'1962-11-07\')\";\n            PreparedStatement ps = conn.prepareStatement(prepInsert,ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_UPDATABLE);\n            ps.setInt(1,556);\n            ps.setString(2,\"Angela\");\n            ps.setString(3,\"Horton2\");\n            \n            int rowsupdated = ps.executeUpdate();\n            System.out.println(rowsupdated);\n            \n            ps.setInt(1,666);\n            ps.setString(2,\"MAX\");\n            ps.setString(3,\"AMILLION\");\n            \n            rowsupdated = ps.executeUpdate();\n            \n            System.out.println(rowsupdated);\n\n        }catch(Exception e){\n            System.out.println(e);\n            \n        }\n        \n    }\n}','1\n1\n\nyou can use a prepared statement multiple times','JDBC',1,NULL),(3447,'public class Hello<T> {\n    \n    public static void main(String[] args){\n        try (Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\")){\n            String prepInsert = \"Select * from employees where first_name = ? OR last_name = ?\";\n            PreparedStatement ps = conn.prepareStatement(prepInsert,ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_UPDATABLE);\n            ps.setString(1,\"Georgi\");\n            ps.setString(2,\"Horton\");\n            \n            ResultSet rs = ps.executeQuery();\n            \n            while(rs.next()){\n                System.out.println(rs.getString(\"first_name\")+\" \"+rs.getString(\"emp_no\"));\n            }\n        }catch(Exception e){\n            System.out.println(e);           \n        }\n    }\n}','Angela 555','JDBC',1,NULL),(3448,'public class Hello<T> {\n    \n    public static void main(String[] args){\n        try (Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\")){\n            String prepInsert = \"Select * from employees where first_name = ? OR last_name = ?\";\n            PreparedStatement ps = conn.prepareStatement(prepInsert,ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_UPDATABLE);\n            ps.setString(1,\"Georgi\");\n            ps.setString(2,\"Horton\");\n            \n            ResultSet rs = ps.executeQuery(prepInsert);\n            \n            while(rs.next()){\n                System.out.println(rs.getString(\"first_name\")+\" \"+rs.getString(\"emp_no\"));\n            }\n        }catch(Exception e){\n            System.out.println(e);           \n        }\n    }\n}','com.mysql.jdbc.exceptions.jdbc4.MySQLSyntaxErrorException: You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near \'? OR last_name = ?\' at line 1\n\npreparedstatement execute query does not take a String parameter, it already\nknows the query to execute. ','JDBC',1,NULL),(3449,'int customerID = 5001;\njava.sql.Date fromDate = ...;\njava.sql.Date toDate = ...;\nString getBooksInDateRange = \"{call getBooksDateRange(?,?,?)}\";\n\nCallableStatement cstmt = conn.prepareCall(getBooksInDateRange,ResultSet.TYPE_SCROLL_INSESNSITIVE,ResultSet.CONCUR_UPDATABLE);\n\ncstmt.setInt(1,customerID);\ncstmt.setDate(2,fromDate);\ncstmt.setDate(3,toDate);\nResultSet rs = cstmt.executeQuery();\n\n\n','calls the stored proceudre getBooksInDateRange','JDBC',1,NULL),(3450,'int customerID = 5001;\njava.sql.Date fromDate = ...;\njava.sql.Date toDate = ...;\nString getBooksInDateRange = \"{? =call customerTotal (?)}\";\n\nCallableStatement cstmt = conn.prepareCall(getBooksInDateRange,ResultSet.TYPE_SCROLL_INSESNSITIVE,ResultSet.CONCUR_UPDATABLE);\n\ncstmt.registerOutParameter(1,java.sql.Types.DOUBLE);\n\ncstmt.setInt(2,customerID);\n\ncstmt.execute(); // not returning a resultset\n\nint total = cstmt.getDouble(1);\n','to use a stored procedure you have to register the out parameter \nfirst. As shown here. ','JDBC',1,NULL),(3451,'int customerID = 5001;\njava.sql.Date fromDate = ...;\njava.sql.Date toDate = ...;\nString getBooksInDateRange = \"{? =call customerTotal (?)}\";\n\nCallableStatement cstmt = conn.prepareCall(getBooksInDateRange,ResultSet.TYPE_SCROLL_INSESNSITIVE,ResultSet.CONCUR_UPDATABLE);\n\ncstmt.registerOutParameter(1,java.sql.Types.DOUBLE);\n\ncstmt.setInt(2,customerID);\n\ncstmt.execute(getBookInDateRange); // not returning a resultset\n\nint total = cstmt.getDouble(1);\n                                  ','sqlexception execute doesn\'t take a parameter','JDBC',1,NULL),(3452,'int customerID = 5001;\nint numberOfOrders;\nCallableStatement ct = conn.prepareCall(\"{call customerOrderCount (?) }\");\nct.setInt(1,customerID);\nct.registerOutParameter(1.java.sql.Types.INTEGER);  // the out\n\nct.execute();\n\nint numberoforders = ct.getInt(1);','registers an INOUT parameter','JDBC',1,NULL),(3453,'int customerID = 5001;\nint numberOfOrders;\nCallableStatement ct = conn.prepareCall(\"{call customerOrderCount (?) }\");\nct.setInt(1,customerID);\nct.registerOutParameter(1.java.sql.Types.INTEGER);  // the out\n\nct.executeQuery();\n\nint numberoforders = ct.getInt(1);','storedprocedures is code thta you dont have insight to and if you invoke executeQuery()\non a procedure that doesn\'t return a result set you get a sqlException\n\nso its best to use execute()','JDBC',1,NULL),(3454,'int customerID = 5001;\nint numberOfOrders;\nCallableStatement ct = conn.prepareCall(\"{call customerOrderCount (?) }\");\nct.setInt(1,customerID);\nct.registerOutParameter(1.java.sql.Types.INTEGER);  // the out\n\nct.execute();\n\nint numberoforders = ct.getInt(1);\n\nif(ct.getMoreResults()) // returns true if there is a resultset to get. ','','JDBC',1,NULL),(3455,'RowSetFactory rsf = RowSetProvider.newFactory();\nJdbcRowSet jrs = rsf.createJdbcRowSet();\n// Provider returns a facotry that will create Rowset objects from\n// the reference implementation\n\n//with the factory it is easy to swap out the implementation\n\nRowSetFactorys rsf2 = RowSetProvider.newFactory(\"com.example.MyRowSetProvider\",null);\nJdbcRowSet jrs = rsf.createJdbcRowSet();','','JDBC',1,NULL),(3456,'public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n        try(JdbcRowSet jrs = RowSetProvider.newFactory().createJdbcRowSet()){\n            String query = \"Select * from employees limit 100\";\n            jrs.setCommand(query);\n            jrs.setUrl(url);\n            jrs.setUsername(user);\n            jrs.setPassword(pw);\n            jrs.execute();\n            while(jrs.next()){\n                System.out.println(jrs.getString(\"first_name\") + \" \" + jrs.getString(\"last_name\"));\n            }    \n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n}','prints the first 100 employees\' full names\n\nyou construct a JdbcRowSet from a RowSetProvider.newFactory().createJdbcRowSet();\n\ninstead of statement conncection and resultSet you use RowSet commands\nto set the uname, pw and url. \n\nthen simply execute it. ','JDBC',1,NULL),(3457,'public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n        try(JdbcRowSet jrs = RowSetProvider.createJdbcRowSet()){\n            String query = \"Select * from employees limit 100\";\n            jrs.setCommand(query);\n            jrs.setUrl(url);\n            jrs.setUsername(user);\n            jrs.setPassword(pw);\n            jrs.execute();\n            while(jrs.next()){\n                System.out.println(jrs.getString(\"first_name\") + \" \" + jrs.getString(\"last_name\"));\n            }    \n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n}','will not compile the proper way to create a JdbcRowSet is\n\n	JdbcRowSet jrs = RowSetProvider.newFactory().createJdbcRowSet()','JDBC',1,NULL),(3458,'public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n            JdbcRowSet jrs = RowSetProvider.newFactory().createJdbcRowSet();\n            String query = \"Select * from employees limit 100\";\n            jrs.setCommand(query);\n            jrs.setUrl(url);\n            jrs.setUsername(user);\n            jrs.setPassword(pw);\n            jrs.execute();\n            while(jrs.next()){\n                System.out.println(jrs.getString(\"first_name\") + \" \" + jrs.getString(\"last_name\"));\n            }    \n    }\n}','Will not compil creating a JdbcRowSet throws an sql exception so it is usually\ncreated in a try() - catch block, \n\nNot to mention every other of those commands throws an sqlexception','JDBC',1,NULL),(3459,'public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n        try(JdbcRowSet jrs = RowSetProvider.newFactory().createJdbcRowSet()){\n            String query = \"Select * from employee limit 100\";\n            jrs.setCommand(query);\n            jrs.execute();\n            while(jrs.next()){\n                System.out.println(jrs.getString(\"first_name\") + \" \" + jrs.getString(\"last_name\"));\n            }    \n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n}','NullPointerException, the username and password and url were not set, \n\nIT could Also throw an sqlexception for this,\n\nexecute fills the rowset with data. Just alswyas make sure that data is set.','JDBC',1,NULL),(3460,'public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n        try(JdbcRowSet jrs = RowSetProvider.newFactory().createJdbcRowSet()){\n            String query = \"Select * from employees limit 100\";\n            jrs.setCommand(query);\n            jrs.setUrl(url);\n            jrs.setUsername(user);\n            jrs.setPassword(pw);\n            jrs.setType(ResultSet.TYPE_SCROLL_INSENSITIVE);\n            jrs.execute();\n            while(jrs.next()){\n                System.out.println(jrs.getString(\"first_name\") + \" \" + jrs.getString(\"last_name\"));\n            }    \n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n}','RowSet extends Result set so it is a result set\n\nseting the type still uses the resultset types. ','JDBC',1,NULL),(3461,'public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n        try(JdbcRowSet jrs = RowSetProvider.newFactory().createJdbcRowSet()){\n            String query = \"Select * from employees limit 100\";\n            jrs.setCommand(query);\n            jrs.setUrl(url);\n            jrs.setUsername(user);\n            jrs.setPassword(pw);\n            jrs.setType(RowSet.TYPE_SCROLL_INSENSITIVE);\n            jrs.execute();\n            while(jrs.next()){\n                System.out.println(jrs.getString(\"first_name\") + \" \" + jrs.getString(\"last_name\"));\n            }    \n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n}','will not compile,\n\nResultSet.TYPE_SCROLL_INSENSITIVE\n\nThose fields are inherited from ResultSet. \n\nFields inherited from interface java.sql.ResultSet\nCONCUR_READ_ONLY, \nCONCUR_UPDATABLE, \nTYPE_FORWARD_ONLY, \nTYPE_SCROLL_INSENSITIVE, \nTYPE_SCROLL_SENSITIVE','JDBC',1,NULL),(3462,'public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n        try(JdbcRowSet jrs = RowSetProvider.newFactory().createJdbcRowSet()){\n            String query = \"Update employees set first_name = \'Mike\' where emp_no = 789\";\n            jrs.setCommand(query);\n            jrs.setUrl(url);\n            jrs.setUsername(user);\n            jrs.setPassword(pw);\n            jrs.setType(ResultSet.TYPE_SCROLL_INSENSITIVE);\n            jrs.execute();\n            while(jrs.next()){\n                System.out.println(jrs.getString(\"first_name\") + \" \" + jrs.getString(\"last_name\"));\n            }    \n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n}','SQLException, you cannot Update insert or delete with execute() on a RowSet.\n\nto update the data you just update the data on your JdbcRowSet.\n\nthere are no executeQuery() or executeUpdate methods for RowSets. ','JDBC',1,NULL),(3463,'public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n        try(JdbcRowSet jrs = RowSetProvider.newFactory().createJdbcRowSet()){\n            String query = \"Update employees set first_name = \'Mike\' where emp_no = 789\";\n            jrs.setCommand(query);\n            jrs.setUrl(url);\n            jrs.setUsername(user);\n            jrs.setPassword(pw);\n            jrs.setType(ResultSet.TYPE_SCROLL_INSENSITIVE);\n            jrs.executeUpdate();\n            while(jrs.next()){\n                System.out.println(jrs.getString(\"first_name\") + \" \" + jrs.getString(\"last_name\"));\n            }    \n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n}','will not compile there is no executeUpdate() for RowSets,\nbecause you do not update insert or delete in this way. You use the update api.\n\nThis would be a sql exception anyway because you cannot perform update \ninsert or deletes with a sql command and a jdbc rowset.','JDBC',1,NULL),(3464,'public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n        try(JdbcRowSet jrs = RowSetProvider.newFactory().createJdbcRowSet()){\n            String query = \"Select * from employees limit 100\";\n            jrs.setCommand(query);\n            jrs.setUrl(url);\n            jrs.setUsername(user);\n            jrs.setPassword(pw);\n            jrs.setType(ResultSet.TYPE_SCROLL_INSENSITIVE);\n            jrs.executeQuery();\n            while(jrs.next()){\n                System.out.println(jrs.getString(\"first_name\") + \" \" + jrs.getString(\"last_name\"));\n            }    \n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n}','will not compiles there is no executeQuery() with Jdbcrowsets. The Command is \nexecute()','JDBC',1,NULL),(3465,'How do you execute a query with a JdbcRowSet object ? ','first set the user pw and url with:\n\n	       jrs.setUrl(url);\n            jrs.setUsername(user);\n            jrs.setPassword(pw);\n\nthen set the command: \n		String query = \"Select * from employees limit 100\";\n            jrs.setCommand(query);\n\nthen use the only command to execute:\n\nexecute()','JDBC',1,NULL),(3466,'public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n        try(JdbcRowSet jrs = RowSetProvider.newFactory().createJdbcRowSet()){\n            String query = \"Select * from employees limit 100\";\n            jrs.setUrl(url);\n            jrs.setUsername(user);\n            jrs.setPassword(pw);\n            jrs.setType(ResultSet.TYPE_SCROLL_INSENSITIVE);\n            jrs.execute();\n            while(jrs.next()){\n                System.out.println(jrs.getString(\"first_name\") + \" \" + jrs.getString(\"last_name\"));\n            }    \n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n}','NullpointerExeption you never set the command, could be an sqlException too\n\ndont forget to:\n\nsetCommand(query);','JDBC',1,NULL),(3467,'public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n        try(JdbcRowSet jrs = RowSetProvider.newFactory().createJdbcRowSet()){\n            String query = \"Select * from employees limit 100\";\n            jrs.setQuery(query);\n            jrs.setUrl(url);\n            jrs.setUsername(user);\n            jrs.setPassword(pw);\n            jrs.execute();\n            while(jrs.next()){\n                System.out.println(jrs.getString(\"first_name\") + \" \" + jrs.getString(\"last_name\"));\n            }    \n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n}','will not copile the method is setCommand not setQuery','JDBC',1,NULL),(3468,'You can update data in the database with a resultset but thats not on the \nexam so DONT WORRY ABOUT IT. \n\nyou can do the same with RowSet and that IS on the exam so thats what you shuld focus on','','JDBC',1,NULL),(3469,'public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n        try(JdbcRowSet jrs = RowSetProvider.newFactory().createJdbcRowSet()){\n            String query = \"Select * from employees limit 100\";\n            jrs.setCommand(query);\n            jrs.setUrl(url);\n            jrs.setUsername(user);\n            jrs.setPassword(pw);\n            jrs.execute();\n            while(jrs.next()){\n                System.out.println(jrs.getString(\"first_name\") + \" \" + jrs.getString(\"last_name\"));\n            }\n            jrs.last();\n            jrs.updateString(\"first_name\",\"Big Max\");\n            jrs.updateRow();\n            \n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n}','change the last employees first name to \'Big Max\'','JDBC',1,NULL),(3470,'public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n        try(JdbcRowSet jrs = RowSetProvider.newFactory().createJdbcRowSet()){\n            String query = \"Select * from employees limit 100\";\n            jrs.setCommand(query);\n            jrs.setUrl(url);\n            jrs.setUsername(user);\n            jrs.setPassword(pw);\n            jrs.execute();\n            \n            jrs.last();\n            jrs.updateString(\"first_name\",\"Big Max\");\n            jrs.updateRow();\n\n            while(jrs.next()){\n                System.out.println(jrs.getString(\"first_name\") + \" \" + jrs.getString(\"last_name\"));\n            }\n            \n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n}','This will print nothing, the cursor is already at the last poisiton so\nthere is not next for jrs to go to to fix add \n\n	jrs.first()\n\njust before the while loop.','JDBC',1,NULL),(3471,'public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n        try(JdbcRowSet jrs = RowSetProvider.newFactory().createJdbcRowSet()){\n            String query = \"Select * from employees limit 100\";\n            jrs.setCommand(query);\n            jrs.setUrl(url);\n            jrs.setUsername(user);\n            jrs.setPassword(pw);\n            jrs.execute();\n            \n            jrs.last();\n            jrs.updateString(\"first_name\",\"Big Max\");\n            jrs.updateRow();\n            jrs.first();\n            while(jrs.next()){\n                System.out.println(jrs.getString(\"first_name\") + \" \" + jrs.getString(\"last_name\"));\n            }\n            \n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n}','will show the updated rows ','JDBC',1,NULL),(3472,'public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n        try(JdbcRowSet jrs = RowSetProvider.newFactory().createJdbcRowSet()){\n            String query = \"Select * from employees limit 100\";\n            jrs.setCommand(query);\n            jrs.setUrl(url);\n            jrs.setUsername(user);\n            jrs.setPassword(pw);\n            jrs.execute();\n            jrs.first();\n            jrs.updateString(\"first_name\",\"Big Max\");\n            jrs.updateString(\"last_name\",\"Big Dick Bisesi\");\n            jrs.updateRow();\n            System.out.println(jrs.getString(\"first_name\") + \" \" + jrs.getString(\"last_name\"));\n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n}','will update the first row of the RowSet and write teh changes to the database\n\nprints: Big Max Big Dick Bisesi','JDBC',1,NULL),(3473,'public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n        try(JdbcRowSet jrs = RowSetProvider.newFactory().createJdbcRowSet()){\n            String query = \"Select * from employees limit 100\";\n            jrs.setCommand(query);\n            jrs.setUrl(url);\n            jrs.setUsername(user);\n            jrs.setPassword(pw);\n            jrs.first();\n            jrs.updateString(\"first_name\",\"Big Max\");\n            jrs.updateString(\"last_name\",\"Big Dick Bisesi\");\n            jrs.updateRow();\n            System.out.println(jrs.getString(\"first_name\") + \" \" + jrs.getString(\"last_name\"));\n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n}','SQLException: Invalid State\n\nexecute() was never used.','JDBC',1,NULL),(3474,'public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n        try(JdbcRowSet jrs = RowSetProvider.newFactory().createJdbcRowSet()){\n            String query = \"Select * from employees limit 100\";\n            jrs.setCommand(query);\n            jrs.setUrl(url);\n            jrs.setUsername(user);\n            jrs.setPassword(pw);\n            jrs.execute();\n            jrs.beforeFirst();\n            jrs.updateString(\"first_name\",\"Big Max\");\n            jrs.updateString(\"last_name\",\"Big Dick Bisesi\");\n            jrs.updateRow();\n            System.out.println(jrs.getString(\"first_name\") + \" \" + jrs.getString(\"last_name\"));\n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n}','NullPointerException the cursor is before the first row','JDBC',1,NULL),(3475,'public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n        try(JdbcRowSet jrs = RowSetProvider.newFactory().createJdbcRowSet()){\n            String query = \"Select * from employees limit 100\";\n            jrs.setCommand(query);\n            jrs.setUrl(url);\n            jrs.setUsername(user);\n            jrs.setPassword(pw);\n            jrs.execute();\n            jrs.absolute(0);\n            jrs.updateString(\"first_name\",\"Big Max\");\n            jrs.updateString(\"last_name\",\"Big Dick Bisesi\");\n            jrs.updateRow();\n            System.out.println(jrs.getString(\"first_name\") + \" \" + jrs.getString(\"last_name\"));\n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n}','NPE moving to absolute(0) moves to before the first row. \n\nmoving abosolute(-n) starts at the last row and moves the cursor backward','JDBC',1,NULL),(3476,'public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n        try(JdbcRowSet jrs = RowSetProvider.newFactory().createJdbcRowSet()){\n            String query = \"Select * from employees limit 100\";\n            jrs.setCommand(query);\n            jrs.setUrl(url);\n            jrs.setUsername(user);\n            jrs.setPassword(pw);\n            jrs.execute();\n            jrs.absolute(5);\n            jrs.updateString(\"first_name\",\"Angela\");\n            jrs.updateString(\"last_name\",\"Big Butt Horton\");\n            jrs.updateRow();\n            System.out.println(jrs.getString(\"first_name\") + \" \" + jrs.getString(\"last_name\"));\n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n}','changes the fifth row in the rowset.\n\nAngela Bit Butt Horton','JDBC',1,NULL),(3477,'How to insert a new row into a RowSet ?','jrs.moveToInsertRow();\njrs.updateString(\"first_name\",\"Jonny\");\njrs.udateString...\njrs.updateInt...\njrs.insertRow();\njrs.moveToCurrentRow();','JDBC',1,NULL),(3478,'public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n        try(JdbcRowSet jrs = RowSetProvider.newFactory().createJdbcRowSet()){\n            String query = \"Select * from employees limit 100\";\n            jrs.setCommand(query);\n            jrs.setUrl(url);\n            jrs.setUsername(user);\n            jrs.setPassword(pw);\n            \n            jrs.moveToInsertRow();\n            jrs.updateInt(\"emp_no\",12345);\n            jrs.updateString(\"firs_name\",\"Blue\");\n            jrs.updateString(\"last_name\",\"Bella\");\n            jrs.insertRow();\n            \n            //System.out.println(jrs.getString(\"first_name\") + \" \" + jrs.getString(\"last_name\"));\n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n}','sqlexception: invalid state there is no rowset to perforem these changes on \nbecause execute() wasn\'t called.','JDBC',1,NULL),(3479,'public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n        try(JdbcRowSet jrs = RowSetProvider.newFactory().createJdbcRowSet()){\n            String query = \"Select * from employees limit 100\";\n            jrs.setCommand(query);\n            jrs.setUrl(url);\n            jrs.setUsername(user);\n            jrs.setPassword(pw);\n            \n            jrs.execute();\n            \n            jrs.moveToInsertRow();\n            jrs.updateInt(\"emp_no\", 789);\n            jrs.updateString(\"first_name\",\"Blue\");\n            jrs.updateString(\"last_name\",\"Bella\");\n            jrs.insertRow();\n            \n            System.out.println(jrs.getString(\"first_name\") + \" \" + jrs.getString(\"last_name\"));\n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n}','Blue Bella this prints the values just inserted in the insert row.','JDBC',1,NULL),(3480,'public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n        try(JdbcRowSet jrs = RowSetProvider.newFactory().createJdbcRowSet()){\n            String query = \"Select * from employees limit 100\";\n            jrs.setCommand(query);\n            jrs.setUrl(url);\n            jrs.setUsername(user);\n            jrs.setPassword(pw);\n            jrs.execute();\n            jrs.moveToInsertRow();\n            System.out.println(jrs.getString(\"first_name\") + \" \" + jrs.getString(\"last_name\"));\n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n}','null null','JDBC',1,NULL),(3481,'public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n        try(JdbcRowSet jrs = RowSetProvider.newFactory().createJdbcRowSet()){\n            String query = \"Select * from employees limit 100\";\n            jrs.setCommand(query);\n            jrs.setUsername(user);\n            jrs.setPassword(pw);\n            jrs.execute();\n            jrs.moveToInsertRow();\n            System.out.println(jrs.getString(\"first_name\") + \" \" + jrs.getString(\"last_name\"));\n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n}','NPE setURL was left out ','JDBC',1,NULL),(3482,'public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n        try(JdbcRowSet jrs = RowSetProvider.newFactory().createJdbcRowSet()){\n            String query = \"Select * from employees limit 100\";\n            jrs.setCommand(query);\n            jrs.setUrl(url);\n            jrs.setUsername(user);\n            jrs.setPassword(pw);\n            jrs.execute();\n            \n            jrs.addRowSetListener(new MyRowSetListener());\n            \n            jrs.moveToInsertRow();\n            jrs.updateInt(\"emp_no\",3);\n            jrs.updateString(\"first_name\",\"Micheal\");\n            jrs.updateString(\"last_name\",\"Boyd\");\n            jrs.insertRow();\n            \n            jrs.moveToCurrentRow();\n            \n            while(jrs.next()){\n                System.out.println(jrs.getString(\"first_name\") + \" \" + jrs.getString(\"last_name\"));\n            }\n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n    \n    class MyRowSetListener implements RowSetListener {\n        \n        public void rowChanged(RowSetEvent event) {\n            if(event.getSource() instanceof RowSet) {\n                try{\n                    ((RowSet) event.getSource()).execute();\n                    //re excute the query every time the rowset is updchanged to update it\n                } catch(SQLException e){\n                    \n                }\n                \n            }\n        }\n        \n        public void cursorMoved(RowSetEvent e) { }\n        public void rowSetChanged(RowSetEvent e){ }\n    }\n}','will not compile non static variable cannot be referenced from static context','JDBC',1,NULL),(3483,'\npublic class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n        try(JdbcRowSet jrs = RowSetProvider.newFactory().createJdbcRowSet()){\n            String query = \"Select * from employees limit 100\";\n            jrs.setCommand(query);\n            jrs.setUrl(url);\n            jrs.setUsername(user);\n            jrs.setPassword(pw);\n            jrs.execute();\n            \n            jrs.addRowSetListener(new MyRowSetListener());\n            \n            jrs.moveToInsertRow();\n            jrs.updateInt(\"emp_no\",3);\n            jrs.updateString(\"first_name\",\"Micheal\");\n            jrs.updateString(\"last_name\",\"Boyd\");\n            jrs.insertRow();\n            \n            jrs.moveToCurrentRow();\n            \n            while(jrs.next()){\n                System.out.println(jrs.getString(\"first_name\") + \" \" + jrs.getString(\"last_name\"));\n            }\n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n    \n    static class MyRowSetListener implements RowSetListener {\n        \n        public void rowChanged(RowSetEvent event) {\n            if(event.getSource() instanceof RowSet) {\n                try{\n                    ((RowSet) event.getSource()).execute();\n                    //re excute the query every time the rowset is updchanged to update it\n                } catch(SQLException e){\n                    \n                }\n                \n            }\n        }\n        \n        public void cursorMoved(RowSetEvent e) { }\n        public void rowSetChanged(RowSetEvent e){ }\n    }\n}','create a rowsetlistener','JDBC',1,NULL),(3484,'a JdbcRowSet is connected which means its update are actively written to\nthe db, a CachedRowSet and all the rest are disconnected which means they\ncan connect to get the data disconnect change the data then re connect to \nupdate their changes, thats what a cache is.','got it','JDBC',1,NULL),(3485,'how do you create a CachedRowSet','CachedRowSet cs = RowSetProvider.newFactory().createCachedRowSet();','JDBC',1,NULL),(3486,'\npublic class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n        try(JdbcRowSet jrs = RowSetProvider.newFactory().createJdbcRowSet()){\n            String query = \"Select * from employees limit 100\";\n            jrs.setCommand(query);\n            jrs.setUrl(url);\n            jrs.setUsername(user);\n            jrs.setPassword(pw);\n            jrs.execute();\n            \n            jrs.addRowSetListener(new MyRowSetListener());\n            \n            jrs.moveToInsertRow();\n            jrs.updateInt(\"emp_no\",3);\n            jrs.updateString(\"first_name\",\"Micheal\");\n            jrs.updateString(\"last_name\",\"Boyd\");\n            jrs.insertRow();\n            \n            jrs.moveToCurrentRow();\n            \n            while(jrs.next()){\n                System.out.println(jrs.getString(\"first_name\") + \" \" + jrs.getString(\"last_name\"));\n            }\n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n    \n    static class MyRowSetListener implements RowSetListener {\n        \n        public void rowChanged(RowSetEvent event) {\n            if(event.getSource() instanceof RowSet) {\n                try{\n                    ((RowSet) event.getSource()).execute();\n                    //re excute the query every time the rowset is updchanged to update it\n                } catch(SQLException e){\n                    \n                }\n                \n            }\n        }\n        \n        public void cursorMoved(RowSetEvent e) { }\n        public void rowSetChanged(RowSetEvent e){ }\n    }\n}','will not compile thats not how you create a RowSet. you should add \n\n	createJdbcRowSet();','JDBC',1,NULL),(3487,'When your done changing CachedRowSet what do you call?','acceptChanges();','JDBC',1,NULL),(3488,'how do you begin a transaction in jdbc ?','Connection conn = DriverManager..\nconn.setAutoCommit(false); // begin transaction','JDBC',1,NULL),(3489,'A jdbc transaction includes all of the sQL queries you execute until either ...?','you exlicityly commmit the current transaction\n\nyou excplicityl roll back the current transaction\n\nthere is a failure that forces automatic rollback.','JDBC',1,NULL),(3490,'public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n       try(Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\")){\n           conn.setAutoCommit(false);\n           Statement stmt = conn.createStatement();\n           stmt.execute(\"Insert into employees values (601,\'Dixon\',\'Ramey\')\");\n           stmt.execute(\"Insert into employees values (602,\'Alex\',\'Ramey\')\");\n           stmt.execute(\"Insert into employees values (603,\'Kevin\',\'Ramey\')\");\n           \n           conn.commit();\n           \n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n    \n}','start a transacation by setting autoCommit(false), then make sure you commit()\nit otherwise everything you just did will be automatically rolledback. \n\nAs soon you commit() another transaction is started.\n\nThere can only be one transaction at a time. ','JDBC',1,NULL),(3491,'public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n       try(Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\")){\n           conn.setAutoCommit(false);\n           Statement stmt = conn.createStatement();\n           stmt.execute(\"Insert into employees values (601,\'Dixon\',\'Ramey\')\");\n           stmt.execute(\"Insert into employees values (602,\'Alex\',\'Ramey\')\");\n           stmt.execute(\"Insert into employees values (603,\'Kevin\',\'Ramey\')\");\n           \n           conn.commit();\n           \n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n            \n            conn.rollback();\n        }\n    }\n    \n}','will not compile, Connection is scoped only within that try block because it is\nin a try with resources, conn in the catch is out of scope. ','JDBC',1,NULL),(3492,'public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\");\n  \n        try{   \n        \n            conn.setAutoCommit(false);\n           Statement stmt = conn.createStatement();\n           stmt.execute(\"Insert into employees values (601,\'Dixon\',\'Ramey\')\");\n           stmt.execute(\"Insert into employees values (602,\'Alex\',\'Ramey\')\");\n           stmt.execute(\"Insert into employees values (603,\'Kevin\',\'Ramey\')\");\n           \n           conn.commit();\n           \n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n            \n            conn.rollback();\n        }\n    }\n    \n}','WNC DriverManager.getConnection throws a sqlexception ','JDBC',1,NULL),(3493,'public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n       try(Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\")){\n           conn.setAutoCommit(false);\n           Statement stmt = conn.createStatement();\n           int updatecount = 0;\n           \n           updatecount += stmt.executeUpdate(\"Insert into employees values (701,\'Dixon\',\'Ramey\')\");\n           updatecount += stmt.executeUpdate(\"Insert into employees values (702,\'Alex\',\'Ramey\')\");\n           updatecount += stmt.executeUpdate(\"Insert into employees values (703,\'Kevin\',\'Ramey\')\");\n           \n           if(updatecount == 3){\n               System.out.println(\"Transaction complete\");\n                conn.commit();\n           } else {\n               System.out.println(\"Something didn\'t go through\");\n               conn.rollback();\n           }\n\n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n    \n}','if the insertions go as planned then commit the transaction otherwise try again\n','JDBC',1,NULL),(3494,'public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n       try(Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\")){\n           Statement stmt = conn.createStatement();\n           int updatecount = 0;\n           \n           updatecount += stmt.executeUpdate(\"Insert into employees values (701,\'Dixon\',\'Ramey\')\");\n           updatecount += stmt.executeUpdate(\"Insert into employees values (702,\'Alex\',\'Ramey\')\");\n           updatecount += stmt.executeUpdate(\"Insert into employees values (703,\'Kevin\',\'Ramey\')\");\n           \n           if(updatecount == 3){\n               System.out.println(\"Transaction complete\");\n                conn.commit();\n           } else {\n               System.out.println(\"Something didn\'t go through\");\n               conn.rollback();\n           }\n\n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n    \n}','sqlexception transaction has not been started. setAutoCommit(false) to start one','JDBC',1,NULL),(3495,'public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n       try(Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\")){\n           conn.setAutoCommit(false);\n           Statement stmt = conn.createStatement();\n           int updatecount = 0;\n           \n           updatecount += stmt.executeUpdate(\"Insert into employees values (706,\'Dixon\',\'Ramey\')\");\n           updatecount += stmt.executeUpdate(\"Insert into employees values (707,\'Alex\',\'Ramey\')\");\n           updatecount += stmt.executeUpdate(\"Insert into employees values (708,\'Kevin\',\'Ramey\')\");\n           \n           if(updatecount == 3){\n               System.out.println(\"Transaction complete\");\n                conn.setAutoCommit(true);\n           } else {\n               System.out.println(\"Something didn\'t go through\");\n               conn.rollback();\n           }\n\n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n    \n}','setting autocommit to true will committ any current transaction and turn auto commit back on','JDBC',1,NULL),(3496,'JDBC:\n\nYou call setAutoCommit(false) on Statement ojbects ','FALSE ! Connection objects','JDBC',1,NULL),(3497,'a savepoint represents a point in the transaction that you can rollback to.\nit is created from a connection object.','','JDBC',1,NULL),(3498,'public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n       try(Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\")){\n           conn.setAutoCommit(false);//start a transaction\n           Statement stmt = conn.createStatement();\n           int updatecount = 0;\n           \n           updatecount += stmt.executeUpdate(\"Insert into employees values (710,\'steve\',\'davidson\')\");\n           updatecount += stmt.executeUpdate(\"Insert into employees values (711,\'Alex\',\'The great\')\");\n           updatecount += stmt.executeUpdate(\"Insert into employees values (713,\'baily\',\'Ramey\')\");\n           Savepoint sp1 = conn.setSavepoint();\n           \n           stmt.executeUpdate(\"Insert into employees values(801,\'Whitey\',\'Ford\')\");\n           \n           conn.rollback();\n\n           ResultSet rs = stmt.executeQuery(\"select * from employees where first_name = \\\'Whitey\\\'\");\n           \n           while(rs.next()){\n               System.out.println(rs.getInt(\"emp_no\"));\n           }\n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n    \n}','how to use a savepoint','JDBC',1,NULL),(3499,'public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n       try(Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\")){\n          String call = \"{CALL REMOVEBOOKS(?,?)}\";\n          String titleToRemove = null;\n          int maxBooks = 0;\n          CallableStatement cstmt = conn.prepareCall(call);\n          String titles = \"%Hero%\";\n          int numBooksRemoved;\n          cstmt.setInt(0,maxBooks);\n          cstmt.setString(1,titleToRemove);\n          cstmt.registerOutParameter(0,java.sql.Types.INTEGER);\n          cstmt.execute();\n          numBooksRemoved = cstmt.getInt(0); \n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n    \n}','Prepared and Callable statement setXXX() methods number parameters from \n1 not 0. ','JDBC',1,NULL),(3500,'public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n       try(Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\")){\n          String call = \"{CALL REMOVEBOOKS(?,?)}\";\n          String titleToRemove = null;\n          int maxBooks = 0;\n          CallableStatement cstmt = conn.prepareCall(call);\n          String titles = \"%Hero%\";\n          int numBooksRemoved;\n          cstmt.setInt(0,maxBooks);\n          cstmt.setString(1,titleToRemove);\n          cstmt.registerOutParameter(0,java.sql.Types.INTEGER);\n          cstmt.executeQuery(query);\n          numBooksRemoved = cstmt.getInt(0); \n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n    \n}','executeQuery() for callable and preparedstatements must not have the query passed\nin as a parameter. \n\nAlso the indexes are numbered incorectly','JDBC',1,NULL),(3501,'public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n       try(Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\")){\n          String call = \"{CALL REMOVEBOOKS(?,?)}\";\n          String titleToRemove = null;\n          String query = \"select * from Books\";\n          int maxBooks = 0;\n          CallableStatement cstmt = conn.prepareCall(call);\n          String titles = \"%Hero%\";\n          int numBooksRemoved;\n          cstmt.setInt(1,maxBooks);\n          cstmt.setString(2,titleToRemove);\n          cstmt.registerOutParameter(1,java.sql.Types.INTEGER);\n          cstmt.executeQuery(query);\n          numBooksRemoved = cstmt.getInt(1);\n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n    \n}','sqlexception executeQuery() for callable and prepared statements must not have\nthe query passed in as a parameter ','JDBC',1,NULL),(3502,'public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n       try(Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\")){\n          String call = \"{CALL REMOVEBOOKS(?,?)}\";\n          String titleToRemove = null;\n          String query = \"select * from Books\";\n          int maxBooks = 0;\n          CallableStatement cstmt = conn.prepareCall(call);\n          String titles = \"%Hero%\";\n          int numBooksRemoved;\n          cstmt.setInt(1,maxBooks);\n          cstmt.setString(2,titleToRemove);\n          cstmt.execute();\n          cstmt.registerOutParameter(1,java.sql.Types.INTEGER);\n          numBooksRemoved = cstmt.getInt(1);\n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n    \n}','sqlexception for registering the out parameter after the execute call.','JDBC',1,NULL),(3503,'public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n       try(Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\")){\n          String call = \"{CALL REMOVEBOOKS(?,?)}\";\n          String titleToRemove = null;\n          String query = \"select * from Books\";\n          int maxBooks = 0;\n          CallableStatement cstmt = conn.prepareCall(call);\n          String titles = \"%Hero%\";\n          int numBooksRemoved;\n          cstmt.setInt(1,maxBooks);\n          cstmt.setString(2,titleToRemove);\n          cstmt.registerOutParameter(1,java.sql.Types.INTEGER);\n          ResultSet rs = cstmt.executeQuery();\n          rs.next();\n          numBooksRemoved = cstmt.getInt(1);\n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n    \n}','this stored proceudre does not return a resultset, so while it will compile\nbcasue executeQuery() will return a ResultSet to rs. cstmt.getInt(1); will throw\na sql exception.','JDBC',1,NULL),(3504,'public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n       try(Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\")){\n          String call = \"{CALL REMOVEBOOKS(?,?)}\";\n          String titleToRemove = null;\n          String query = \"select * from Books\";\n          int maxBooks = 0;\n          CallableStatement cstmt = conn.prepareCall(call);\n          String titles = \"%Hero%\";\n          int numBooksRemoved;\n          cstmt.setInt(1,maxBooks);\n          cstmt.setString(2,titleToRemove);\n          cstmt.registerOutParameter(1,java.sql.Types.INTEGER);\n          cstmt.execute();\n          numBooksRemoved = cstmt.getInt(1);\n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }  \n}','this is the way to use a CallableStatement.','JDBC',1,NULL),(3505,'try(RowSetFactory rsf = RowSetProvider.newFactory()) {\nRowSet rws = rsf.createRowSet();','Will not compile RowSetFactory does not implement autocloseable','JDBC',1,NULL),(3506,'String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n       //try(Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\")){\n        \n        try(CachedRowSet crs = RowSetProvider.newFactory().createCachedRowSet()) {\n            String query = \"Select * From employee\";\n            crs.setCommand(query);\n            crs.setUrl(url);\n            crs.setUsername(user);\n            crs.setPassword(pw);\n            crs.execute();\n            crs.last();\n            crs.updateString(\"last_name\", \"Sullivan\");\n            //database goes offline\n            crs.moveToInsertRow();\n            crs.updateInt(\"ID\",101);\n            crs.updateString(\"first_name\",\"Billy\");\n            crs.updateString(\"last_name\",\"Blue\");\n            crs.insertRow();\n            crs.moveToCurrentRow();\n            crs.absolute(10);\n            crs.deleteRow();\n            //db backonline\n        } catch(SQLException e){\n            System.out.println(e);\n        }','this database will be unchanged. the error here is that acceptChanges() was\nnever called to reconcile the changes made with the in memory version and the\nactual db.\n\nthe database being offline anytime after the execute() is invoked in irrelevent\n','JDBC',1,NULL),(3507,'public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n       //try(Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\")){\n        \n        try(CachedRowSet crs = RowSetProvider.newFactory().createCachedRowSet()) {\n            String query = \"Select * From employee\";\n            crs.setCommand(query);\n            crs.setUrl(url);\n            crs.setUsername(user);\n            crs.setPassword(pw);\n            crs.execute();\n            crs.last();\n            crs.updateString(\"last_name\", \"Sullivan\");\n            //database goes offline\n            crs.moveToInsertRow();\n            crs.updateInt(\"ID\",101);\n            crs.updateString(\"first_name\",\"Billy\");\n            crs.updateString(\"last_name\",\"Blue\");\n            crs.moveToCurrentRow();\n            crs.absolute(10);\n            crs.deleteRow();\n            //db backonline\n        } catch(SQLException e){\n            System.out.println(e);\n        }\n    }  \n}\nwhats missing here ?','crs.insertRow();\n\nalso crs.acceptChanges()','JDBC',1,NULL),(3508,'public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n       //try(Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\")){\n        \n        try(CachedRowSet crs = RowSetProvider.newFactory().createCachedRowSet()) {\n            String query = \"Select * From employee\";\n            crs.setCommand(query);\n            crs.setUrl(url);\n            crs.setUsername(user);\n            crs.setPassword(pw);\n            crs.last();\n            crs.updateString(\"last_name\", \"Sullivan\");\n            //database goes offline\n            crs.moveToInsertRow();\n            crs.updateInt(\"ID\",101);\n            crs.updateString(\"first_name\",\"Billy\");\n            crs.updateString(\"last_name\",\"Blue\");\n            crs.insertRow();\n            crs.moveToCurrentRow();\n            crs.absolute(10);\n            crs.deleteRow();\n            //db backonline\n        } catch(SQLException e){\n            System.out.println(e);\n        }\n    }  \n}','crs.execute() is missing','JDBC',1,NULL),(3509,'public class Hello {\n    public static void main(String[] args){\n        \n        boolean businessrule = true;\n       try(Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\")){\n            String query = \"Inser into ...\";\n            String query2 = \"Updat table...\";\n            \n            Statement st = conn.createStatement();\n            \n            st.executeUpdate(query);\n            st.executeUpdate(query2);\n            \n            if(businessrule){\n                conn.rollback();\n            }\n        } catch(SQLException e){\n            System.out.println(e);\n        }\n    }  \n}','the first two updates are executed, but then a sqlexception is thrown because \na transaction was never started to rollback.\n\nyou would have had to setAutoCommit(false) to start a transaction.\n\nThe first two were automatically commited. ','JDBC',1,NULL),(3510,'public class Hello {\n    public static void main(String[] args){\n        \n        boolean businessrule = false;\n       try(Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\")){\n            conn.setAutoCommit(false);\n            String query = \"Inser into ...\";\n            String query2 = \"Updat table...\";\n            \n            Statement st = conn.createStatement();\n            \n            st.executeUpdate(query);\n            st.executeUpdate(query2);\n            \n            if(businessrule){\n                conn.rollback();\n            } else {\n                conn.commit();\n            }\n        } catch(SQLException e){\n            System.out.println(e);\n        }\n    }  \n}','if the business rule remains false then both updates will be comitted.\nsince autocommit is false.','JDBC',1,NULL),(3511,'public class Hello {\n    public static void main(String[] args){\n\n       try(Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\")){\n            conn.setAutoCommit(false);\n            String query = \"Inser into ...\";\n            String query2 = \"Updat table...\";\n            Statement st = conn.createStatement();\n            \n            st.executeUpdate(query);\n            \n            Savepoint sp1 = conn.setSavepoint();\n            \n            st.executeUpdate(query2);\n            \n            conn.rollback();\n           \n        } catch(SQLException e){\n            System.out.println(e);\n        }\n    }  \n}','no rows are added at all, the rollback() rolls back to the savepoint but erasing the\nsecond update, but because there is no commit() at all the first update will also be \nrolledback when the try block closes for good becaus autocommitmode was set\nto false. ','JDBC',1,NULL),(3512,'public class Hello {\n    public static void main(String[] args){\n        try {\n            Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\");\n            Statement st = conn.createStatement();\n            String q = \"Select * From employees limit 100\";\n            ResultSet rs = st.executeQuery(q);\n            \n            rs.first();\n            System.out.println(\"First entry:\");\n            System.out.println(rs.getString(\"first_name\") + \" \" +rs.getString(\"last_name\"));\n            \n            rs.last();\n            System.out.println(\"Last entry:\");\n            System.out.println(rs.getString(\"first_name\") + \" \" +rs.getString(\"last_name\"));\n            \n            rs.absolute(20);\n            System.out.println(\"row: \"+ rs.getRow());\n            System.out.println(rs.getString(\"first_name\") + \" \" +rs.getString(\"last_name\"));\n            \n            rs.relative(10);\n            System.out.println(\"row: \"+ rs.getRow());\n            System.out.println(rs.getString(\"first_name\") + \" \" +rs.getString(\"last_name\")); \n            \n            String update = \"insert into employees values(09,\'Broden\',\'Chapman\')\";\n            boolean results = st.execute(update);\n            \n            if(!results){\n                System.out.println(\"update executed\");\n            }\n            \n            rs.last();\n            System.out.println(\"new entry row: \"+ rs.getRow());\n            System.out.println(rs.getString(\"first_name\") + \" \" +rs.getString(\"last_name\")); \n\n        } catch(SQLException e){System.out.println(e); }\n        \n    }\n}','First entry:\nMicheal Boyd\nLast entry:\nKenroku Malabarba\nrow: 20\nKyoichi Maliniak\nrow: 30\nGuoxiang Nooteboom\nupdate executed\njava.sql.SQLException: Operation not allowed after ResultSet closed\n\nAfter re executing a statement, all ResultSets tied to that statemnt are \nautomatically closed','JDBC',1,NULL),(3513,'public class Hello {\n    public static void main(String[] args){\n        try {\n            Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\");\n            Statement st = conn.createStatement();\n            String q = \"Select * From employees limit 100\";\n            getDBfile();\n            ResultSet rs = st.executeQuery(q);\n            \n            rs.first();\n            System.out.println(\"First entry:\");\n            System.out.println(rs.getString(\"first_name\") + \" \" +rs.getString(\"last_name\"));\n            \n            rs.last();\n            System.out.println(\"Last entry:\");\n            System.out.println(rs.getString(\"first_name\") + \" \" +rs.getString(\"last_name\"));\n            \n            rs.absolute(20);\n            System.out.println(\"row: \"+ rs.getRow());\n            System.out.println(rs.getString(\"first_name\") + \" \" +rs.getString(\"last_name\"));\n            \n            rs.relative(10);\n            System.out.println(\"row: \"+ rs.getRow());\n            System.out.println(rs.getString(\"first_name\") + \" \" +rs.getString(\"last_name\")); \n            \n            String update = \"insert into employees values(09,\'Broden\',\'Chapman\')\";\n            boolean results = st.execute(update);\n            \n            if(!results){\n                System.out.println(\"update executed\");\n            }\n            \n            rs.last();\n            System.out.println(\"new entry row: \"+ rs.getRow());\n            System.out.println(rs.getString(\"first_name\") + \" \" +rs.getString(\"last_name\")); \n\n        } catch(SQLException e | IOException e){System.out.println(e); }\n        \n    }\n    \n    public static void getDBfile() throws IOException { }  \n}','Will not compile, this is not the right syntax for multi - catch\nshould be \n\n	} catch(SQLException | IOException e){  ... }','General',1,NULL),(3514,'public class Hello {\n    public static void main(String[] args){\n        try {\n            Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\");\n            PreparedStatement pst = conn.prepareStatement(\"Select * From employees limit 100\");\n            ResultSet rs = pst.executeQuery();\n            \n            java.util.Date d = new java.util.Date();\n\n            rs.first();\n            System.out.println(\"First entry:\");\n            System.out.println(\"Hired today: \"+d);\n            System.out.println(rs.getString(\"first_name\") + \" \" +rs.getString(\"last_name\"));\n            \n            rs.last();\n            System.out.println(\"Last entry:\");\n            System.out.println(rs.getString(\"first_name\") + \" \" +rs.getString(\"last_name\"));\n            \n            rs.absolute(20);\n            System.out.println(\"row: \"+ rs.getRow());\n            System.out.println(rs.getString(\"first_name\") + \" \" +rs.getString(\"last_name\"));\n            \n            rs.relative(10);\n            System.out.println(\"row: \"+ rs.getRow());\n            System.out.println(rs.getString(\"first_name\") + \" \" +rs.getString(\"last_name\")); \n            \n            String update = \"insert into employees values(11,\'Broden\',\'Chapman\')\";\n            boolean results = pst.execute(update);\n            \n            if(!results){\n                System.out.println(\"update executed\");\n            }\n            \n            rs.last();\n            System.out.println(\"new entry row: \"+ rs.getRow());\n            System.out.println(rs.getString(\"first_name\") + \" \" +rs.getString(\"last_name\")); \n\n        } catch(SQLException e){System.out.println(e); }\n        \n    }\n}','First entry:\nHired today: Fri Jul 28 11:29:33 EDT 2017\nMicheal Boyd\nLast entry:\nTuval Kalloufi\nrow: 20\nChirstian Koblick\nrow: 30\nBerni Genin\nupdate executed\njava.sql.SQLException: Operation not allowed after ResultSet closed','JDBC',1,NULL),(3515,'public static void main(sa) {\n	//most useless method\n	Date d = new Date();\n	sout( d.getTime() + \" \" );\n}\n\nwhat does this show ?','public long getTime()\n\nReturns the number of milliseconds \nsince January 1, 1970, 00:00:00 GMT represented by this Date object.','Strings',1,NULL),(3516,'public class Hello {\n    public static void main(String[] args){\n        try {\n            Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\");\n            PreparedStatement pst = conn.prepareStatement(\"Select * From employees limit 100\");\n            ResultSet rs = pst.executeQuery();\n            \n            Date d = new Date();\n            //Calendar c = Calendar.getInstance();\n            Calendar c = new Calendar();\n            c.setTime(d);\n\n            rs.first();\n            System.out.println(\"First entry:\");\n            System.out.println(\"Hired today: \"+d);\n            System.out.println(\"Start first upcoming monday: \"+firstNextMonday(d));\n            System.out.println(rs.getString(\"first_name\") + \" \" +rs.getString(\"last_name\"));\n            \n            c.add(Calendar.MONTH,-1);\n            Date monthago = c.getTime();\n            rs.last();\n            System.out.println(\"Last entry:\");\n            System.out.println(\"Hired a month ago: \"+monthago);\n            System.out.println(rs.getString(\"first_name\") + \" \" +rs.getString(\"last_name\"));\n            ','WNC, the correct way to create a Calendar is \n\n	Calendar c = Calendar.getInstance();','Strings',1,NULL),(3517,'public class Hello {\n    public static void main(String[] args){\n        try {\n            Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\");\n            PreparedStatement pst = conn.prepareStatement(\"Select * From employees limit 100\");\n            ResultSet rs = pst.executeQuery();\n            \n            Date d = new Date();\n            Calendar c = new Calendar();\n            c.setTime(d);\n\n            rs.first();\n            System.out.println(\"First entry:\");\n            System.out.println(\"Hired today: \"+d);\n            System.out.println(\"Start first upcoming monday: \"+firstNextMonday(d));\n            System.out.println(rs.getString(\"first_name\") + \" \" +rs.getString(\"last_name\"));\n            \n            c.add(Calendar.MONTH,-1);\n            Date monthago = c.getTime();\n            rs.last();\n            System.out.println(\"Last entry:\");\n            System.out.println(\"Hired a month ago: \"+monthago);\n            System.out.println(rs.getString(\"first_name\") + \" \" +rs.getString(\"last_name\"));\n        } catch(SQLException e){ }\n        \n    }\n    \n    public static Date firstNextMonday(Date d){\n        Calendar c = Calendar.getInstance();\n        c.setTime(d);\n        \n        while(c.DAY_OF_WEEK != c.MONDAY){\n            //c.add(1,DAY_OF_WEEK);\n            c.add(c.DAY_OF_WEEK,1);\n        }\n        \n        return c.getTime();\n        \n    }\n}','WNC, the corrct ways to create a Calendar is \n\n	Calendar c = Calendar.getInstance();\n\nif that was corrected then this program would print:\n\n	First entry:\n	Hired today: Mon Aug 07 16:39:34 EDT 2017\n\nand keep running forever...\n\n	you were using accesing a static field at c.DAY_OF_WEEK\n	\n	it should be:\n\n	while(c.get(Calendar.DAY_OF_WEEK) != c.MONDAY){\n            //c.add(1,DAY_OF_WEEK);\n            c.add(c.DAY_OF_WEEK,1);\n        }\n\nif today was monday it would print the excact time and day of right now','Strings',1,NULL),(3518,'public class Hello {\n    public static void main(String[] args){\n        try {\n            Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\");\n            PreparedStatement pst = conn.prepareStatement(\"Select * From employees where first_name = ?\");\n            ResultSet rs = pst.executeQuery();\n            \n            Date d = new Date();\n            Calendar c = Calendar.getInstance();\n            c.setTime(d);\n            \n            DateFormat dateformat = DateFormat.getInstance();\n\n            rs.first();\n            System.out.println(\"First entry:\");\n            System.out.println(\"Hired today: \"+d);\n            System.out.println(\"Start first upcoming monday: \"+firstNextMonday(d));\n            System.out.println(rs.getString(\"first_name\") + \" \" +rs.getString(\"last_name\"));\n            \n            c.add(Calendar.MONTH,-1);\n            Date monthago = c.getTime();\n            rs.last();\n            System.out.println(\"Last entry:\");\n            System.out.println(\"Hired a month ago: \"+monthago);\n            System.out.println(rs.getString(\"first_name\") + \" \" +rs.getString(\"last_name\"));\n            \n            c.setTime(d);\n            c.add(Calendar.YEAR,-1);\n            c.add(Calendar.MONTH, -6);\n            Date yearandahalf = c.getTime();\n            rs.absolute(20);\n            System.out.println(\"row: \"+ rs.getRow());\n            System.out.println(\"Hired a year and a half ago\"+yearandahalf);\n            System.out.println(rs.getString(\"first_name\") + \" \" +rs.getString(\"last_name\"));\n	} catch(SQLException e) { }\n   }\n}','java.sql.SQLException: No value specified for parameter 1','Strings',1,NULL),(3519,'public static void main(String[] args){\n        Date d = new Date();\n        DateFormat df = DateFormat.getInstance();\n        \n        System.out.println(df.format(d));\n        \n    }','7/28/17 12:39 PM','Strings',1,NULL),(3520,'public static void main(String[] args){\n\n        Date d = new Date();\n        DateFormat df = DateFormat.getDateInstance();\n        \n        System.out.println(df.format(d));\n        \n    }','Jul 28, 2017','Strings',1,NULL),(3521,'What dateformat is this\n\n7/28/17',' public static void main(String[] args){\n        Date d = new Date();\n        DateFormat df = DateFormat.getDateInstance(DateFormat.SHORT);\n        \n        System.out.println(df.format(d));\n        \n    }','Strings',1,NULL),(3522,'public static void main(String[] args){\n        Date d = new Date();\n        DateFormat df = DateFormat.getDateInstance(DateFormat.SHORT);\n        \n        String s = df.format(d);\n        \n        Date d2 = df.parse(s);\n    }','will not compile, ParseException must be caught or thrown','Strings',1,NULL),(3523,'public static void main(String[] args){\n        Date d = new Date();\n        DateFormat df = DateFormat.getDateInstance(DateFormat.SHORT);\n        \n        String s = df.format(d);\n        \n        try{\n            Date d2 = df.parse(s);\n            System.out.println(\"parsed \"+d2);\n        } catch( ParseException e){\n            \n        }\n    }','parsedFri Jul 28 00:00:00 EDT 2017','Strings',1,NULL),(3524,'public static void main(String[] args){\n        Date d = new Date();\n        DateFormat df = new DateFormat(DateFormat.SHORT);\n        \n        String s = df.format(d);\n        \n        try{\n            Date d2 = df.parse(s);\n            System.out.println(\"parsed \"+d2);\n        } catch( ParseException e){\n            \n        }\n    }','WNC dateformat is abstract cannot be instantiated ','Strings',1,NULL),(3525,'try {\n            Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\");\n            PreparedStatement pst = conn.prepareStatement(\"Select * From employees limit 100\");\n            ResultSet rs = pst.executeQuery();\n            \n            Date d = new Date();\n            Calendar c = Calendar.getInstance();\n            c.setTime(d);\n            \n            DateFormat dateformat = DateFormat.getInstance();\n            Locale italian = new Locale(\"it\");\n            DateFormat italianformat = DateFormat.getInstance(DateFormat.FULL,italian);\n} catch(SQLException e){ }','The regular DF constructor doesn\'t take a style or Locale.\n\nGet a default date/time \nformatter that uses the SHORT style for both the date and the time.\n\nwith statements preparedstatements callablestatements:\n\n	executeQuery() returns a ResultSet\n	executeUpdate() returns an int\n	execute()  returns a boolean','Strings',1,NULL),(3526,'public class Hello {\n    public static void main(String[] args){\n        DateFormat df = DateFormat.getDateInstance(DateFormat.FULL,Locale.KOREA);\n        Date now = new Date();\n        \n        System.out.println(df.format(now));\n        \n        df.setLocale(Locale.US);\n        \n        System.out.println(df.format(now));\n    }\n}','WNC you can only set a DateFormat and NumberFormat can only set\n local at the time of instantiation. There is not method to change locale\nafterward.','Strings',1,NULL),(3527,'public class Hello {\n    public static void main(String[] args){\n        Locale loc1 = new Locale(\"pt\",\"BR\");\n        Locale loc2 = new Locale(\"da\",\"DK\");\n        Locale loc3 = new Locale(\"it\", \"IT\");\n        \n        System.out.println(loc1.getDisplayCountry());\n        System.out.println(loc2.getDisplayCountry());\n        System.out.println(loc3.getDisplayCountry());\n        \n        //display the countrys name in that language\n        \n        System.out.println(loc1.getDisplayCountry(loc1));\n        System.out.println(loc2.getDisplayCountry(loc2));\n        System.out.println(loc3.getDisplayCountry(loc3));\n    }\n}','Brazil\nDenmark\nItaly\nBrasil\nDanmark\nItalia','Strings',1,NULL),(3528,'public class Hello {\n    public static void main(String[] args){\n        float f1 = 123.43535353f;\n        NumberFormat nf = NumberFormat.getInstance();\n        System.out.println(nf.getMaximumFractionDigits());\n        \n        System.out.println(nf.format(f1));\n        \n    }\n}','3\n123.435','Strings',1,NULL),(3529,'public class Hello {\n    public static void main(String[] args){\n        float f1 = 123.43535353f;\n        NumberFormat nf = NumberFormat.getInstance();\n        System.out.println(nf.getMaximumFractionDigits());\n        \n        System.out.println(nf.format(f1));\n        \n        nf.setMaximumFractionDigits(5);\n        \n        System.out.println(nf.format(f1));\n        \n    }\n}','3\n123.435\n123.43536','Strings',1,NULL),(3530,'public class Hello {\n    public static void main(String[] args){\n        float f1 = 123.43535353f;\n        NumberFormat nf = NumberFormat.getInstance();\n        \n        try{\n            System.out.println(nf.parse(\"345.3435\"));\n            nf.setParseIntegerOnly(true);\n            System.out.println(nf.parse(\"345.3435\"));\n        } catch(ParseException e){\n            \n        }\n    }\n}','345.3435\n345','Strings',1,NULL),(3531,'public class Hello {\n    public static void main(String[] args){\n        float f1 = 123.43535353f;\n        NumberFormat nf = NumberFormat.getInstance();\n        NumberFormat nf2 = NumberFormat.getInstance(Locale.KOREA);\n        NumberFormat nf3 = NumberFormat.getCurrencyInstance();\n        NumberFormat nf4 = NumberFormat.getCurrencyInstance(Locale.KOREA);\n        \n        System.out.println(nf.format(f1));\n        System.out.println(nf2.format(f1));\n        System.out.println(nf3.format(f1));\n        System.out.println(nf4.format(f1));\n\n    }\n}','123.435\n123.435\n$123.44\n?123\n\ncould vary from maching to machine','Strings',1,NULL),(3532,'public class Hello {\n    public static void main(String[] args){\n        Pattern p = Pattern.compile(\"ab\");\n        Matcher m = p.matcher(\"abakdnfab kekrls ab\");\n        \n        while(m.find()){\n            System.out.println(m.start());\n        }\n        \n    }\n}','0\n7\n17','Strings',1,NULL),(3533,'public class Hello {\n    public static void main(String[] args){\n        Pattern p = Pattern.compile(\"\\\\d\");\n        Matcher m = p.matcher(\"The silly Dog89 ran for miles.56 Like a silly little puppy45\");\n        \n        while(m.find()){\n            System.out.println(m.start());\n        }\n        \n    }\n}','13\n14\n30\n31\n58\n59\n\n\\\\d looks for digits','Strings',1,NULL),(3534,'first:\n    public static void main(String[] args){\n        Pattern p = Pattern.compile(\"\\\\d\");\n        Matcher m = p.matcher(\"The silly Dog ran for 89 miles.\");\n        \n        while(m.find()){\n            System.out.println(m.start());\n        }\n        \n    }\nsecond:\n	public static void main(String[] args){\n        Pattern p = Pattern.compile(\"\\\\D\");\n        Matcher m = p.matcher(\"The silly Dog ran for 89 miles.\");\n        \n        while(m.find()){\n            System.out.println(m.start());\n        }\n        \n    }\n','\\\\d looks for digits, \\\\D looks for nondigitis\nfirst:\n22\n23\n\nsecond:\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n24\n25\n26\n27\n28\n29\n30','Strings',1,NULL),(3535,'regex metacharacter:\n\n\\s','a whitespace character \\t \\n \\f \\r','Strings',1,NULL),(3536,'regex metacharacter:\n\n\\S','non white space','Strings',1,NULL),(3537,'regex metacharacter:\n\n\\w word character\n\nmeaning what ?','a-z A-Z digits or _','Strings',1,NULL),(3538,'regex metacharacter:\n\n\\W non word character\n\nmeaning what ?','everything besides a-z A-Z _ or digits','Strings',1,NULL),(3539,'public static void main(String[] args){\n        Pattern p = Pattern.compile(\"\\\\s\");\n        Matcher m = p.matcher(\"The silly Dog ran for 89 miles.\");\n        \n        while(m.find()){\n            System.out.println(m.start());\n        }\n        \n    }','3\n9\n13\n17\n21\n24\n\nwhitespace characters','Strings',1,NULL),(3540,'public static void main(String[] args){\n        Pattern p = Pattern.compile(\"\\\\S\");\n        Matcher m = p.matcher(\"The silly Dog ran for 89 miles.\");\n        \n        while(m.find()){\n            System.out.println(m.start());\n        }\n        \n    }','all the non white spaces:\n0\n1\n2\n4\n5\n6\n7\n8\n10\n11\n12\n14\n15\n16\n18\n19\n20\n22\n23\n25\n26\n27\n28\n29\n30','Strings',1,NULL),(3541,'public static void main(String[] args){\n        Pattern p = Pattern.compile(\"\\\\w\");\n        Matcher m = p.matcher(\"The silly Dog ran for 89 miles.\");\n        \n        while(m.find()){\n            System.out.println(m.start());\n        }\n        \n    }','0   all the word characters similiar to \\\\S\n1\n2\n4\n5\n6\n7\n8\n10\n11\n12\n14\n15\n16\n18\n19\n20\n22\n23\n25\n26\n27\n28\n29','Strings',1,NULL),(3542,'public static void main(String[] args){\n        Pattern p = Pattern.compile(\"\\\\W\");\n        Matcher m = p.matcher(\"The silly Dog ran for 89 miles.\");\n        \n        while(m.find()){\n            System.out.println(m.start());\n        }\n        \n    }','3  //non word character similar to \\\\S numbers are word characters\n9\n13\n17\n21\n24\n30','Strings',1,NULL),(3543,'public class Hello {\n    public static void main(String[] args){\n        Pattern p = Pattern.compile(\"\\\\b\");\n        Matcher m = p.matcher(\"The silly Dog ran for 89 miles.\");\n        \n        while(m.find()){\n            System.out.println(m.start());\n        }\n        \n    }\n}','a word boundary, anytime there is a word character and a non word right next to\neach other.\nThere are invisible non word characters at the end and beginning of a string.\n\n0\n3\n4\n9\n10\n13\n14\n17\n18\n21\n22\n24\n25\n30','Strings',1,NULL),(3544,'public class Hello {\n    public static void main(String[] args){\n        Pattern p = Pattern.compile(\"\\\\B\");\n        Matcher m = p.matcher(\"The silly Dog ran for 89 miles.\");\n        \n        while(m.find()){\n            System.out.println(m.start());\n        }\n        \n    }\n}','//non word boundary each of these is a case where there IS NO word boundary\nor two word characters are beside each other or two non words are beside each other\nreturns the position of the second character.\n\n1 \n2\n5\n6\n7\n8\n11\n12\n15\n16\n19\n20\n23\n26\n27\n28\n29\n31','Strings',1,NULL),(3545,'public static void main(String[] args){\n        Pattern p = Pattern.compile(\"[soi]\");\n        Matcher m = p.matcher(\"The silly Dog ran for 89 miles.\");\n        \n        while(m.find()){\n            System.out.println(m.start());\n        }\n        \n    }','4\n5\n11\n19\n26\n29','Strings',1,NULL),(3546,'public class Hello {\n    public static void main(String[] args){\n        Pattern p = Pattern.compile(\"[a-z]\");\n        Matcher m = p.matcher(\"The silly Dog ran for 89 miles.\");\n        \n        while(m.find()){\n            System.out.println(m.start());\n        }\n        \n    }\n}\n','1\n2\n4\n5\n6\n7\n8\n11\n12\n14\n15\n16\n18\n19\n20\n25\n26\n27\n28\n29','Strings',1,NULL),(3547,'public class Hello {\n    public static void main(String[] args){\n        Pattern p = Pattern.compile(\"[a-cA-C]\");\n        Matcher m = p.matcher(\"The silly Dog ran for 89 miles.\");\n        \n        while(m.find()){\n            System.out.println(m.start());\n        }\n        \n    }\n}','15','Strings',1,NULL),(3548,'public class Hello {\n    public static void main(String[] args){\n        Pattern p = Pattern.compile(\"a?\");\n        Matcher m = p.matcher(\"The silly Dog ran for at least 89 miles.I am tired he said\");\n        \n        while(m.find()){\n            System.out.println(m.group());\n        }\n        \n    }\n}','// the mistake here is that ? gives you \"ZERO OR ONE\" so if there is no a \nthere that still mathces!\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58','Strings',1,NULL),(3549,'creaet a regex that finds a word composed of an \'a\' with any character next to it','public class Hello {\n    public static void main(String[] args){\n        Pattern p = Pattern.compile(\" a.\");\n        Matcher m = p.matcher(\"The silly Dog ran for at least 89 miles.I am tired he said\");\n        \n        while(m.find()){\n            System.out.println(m.start());\n            System.out.println(m.group());\n        }\n        \n    }\n}\n\n21\n at\n41\n am','Strings',1,NULL),(3550,'public class Hello {\n    public static void main(String[] args){\n        Pattern p = Pattern.compile(\"a.\");\n        Matcher m = p.matcher(\"The silly Dog ran for at least 89 miles.I am tired he said\");\n        \n        while(m.find()){\n            System.out.println(m.start());\n            System.out.println(m.group());\n        }\n        \n    }\n}\n\n','Without the space at the beginning of the pattern you allow a then any character\nto but up against any other character if you wanted it to just be individual\nwords then you could add a space at the beginning or a whitespce character.\n15\nan\n22\nat\n27\nas\n42\nam\n55\nai','Strings',1,NULL),(3551,'public class Hello {\n    public static void main(String[] args){\n        Pattern p = Pattern.compile(\"\\\\sa.\");\n        Matcher m = p.matcher(\"The silly Dog ran for at least 89 miles.I am tired he said\");\n        \n        while(m.find()){\n            System.out.println(m.start());\n            System.out.println(m.group());\n        }\n        \n    }\n}','21\n at\n41\n am','Strings',1,NULL),(3552,'public class Hello {\n    public static void main(String[] args){\n        //five letter words\n        Pattern p = Pattern.compile(\"\\\\s.....\\\\s\");\n        Matcher m = p.matcher(\"A regular expression, specified as a string, must first be compiled into an instance of this class\");\n        \n        while(m.find()){\n            System.out.println(m.start());\n            System.out.println(m.group());\n        }\n        \n    }\n}','49\n first ','Strings',1,NULL),(3553,'public class Hello {\n    public static void main(String[] dicks){\n      Path src = Paths.get(\"/home/maxbisesi/Documents/allfiles/copy.txt\");\n      Path srcParent = src.getParent();\n      System.out.println(srcParent);\n      \n    }\n\n}','/home/maxbisesi/Documents/allfiles\n\nNone of these methods throw an IOE','Input/Output',1,NULL),(3554,' public static void main(String[] args){\n        //five letter words\n        Pattern p = Pattern.compile(\".*xx\");\n        Matcher m = p.matcher(\"yyxxxyxx\");\n        \n        while(m.find()){\n            System.out.println(m.start());\n            System.out.println(m.group());\n		  System.out.println(m.end());\n        }\n        \n      \n    }','0\nyyxxxyxx\n8\n\n* is greedy so it reads then entire source then works backward, until it finds\nthe rightmost match. ','Strings',1,NULL),(3555,'public static void main(String[] args){\n        //five letter words\n        Pattern p = Pattern.compile(\".*y\");\n        Matcher m = p.matcher(\"yyxxxyxx\");\n        \n        while(m.find()){\n            System.out.println(m.start());\n            System.out.println(m.group());\n            System.out.println(m.end());\n        }\n        \n      \n    }','0\nyyxxxy\n6\n\ngreedy reads the whole source data first','Strings',1,NULL),(3556,' public static void main(String[] args){\n        //five letter words\n        Pattern p = Pattern.compile(\"\\\\d*\");\n        Matcher m = p.matcher(\"yy4xx89xxye90g\");\n        \n        while(m.find()){\n            System.out.println(m.start()+\":_\"+m.group()+\"_\");\n        }\n        \n      \n    }','This pattern says its looking for zero or more digits, \nso at the positions other than 2 5 and 11 it does find 0 digits\n\n0:__\n1:__\n2:_4_\n3:__\n4:__\n5:_89_\n7:__\n8:__\n9:__\n10:__\n11:_90_\n13:__\n14:__\n\n','Strings',1,NULL),(3557,'public static void main(String[] args){\n        //five letter words\n        Pattern p = Pattern.compile(\"a?\");\n        Matcher m = p.matcher(\"abaabbbaaabbaaa\");\n        \n        while(m.find()){\n            System.out.println(m.start()+\":_\"+m.group()+\"_:\"+m.end());\n        }\n        \n      \n    }','Greedy will allow zero length matches, proven by the start and end indexs being \nthe same.\n\n0:_a_:1\n1:__:1\n2:_a_:3\n3:_a_:4\n4:__:4\n5:__:5\n6:__:6\n7:_a_:8\n8:_a_:9\n9:_a_:10\n10:__:10\n11:__:11\n12:_a_:13\n13:_a_:14\n14:_a_:15\n15:__:15','Strings',1,NULL),(3558,'public class Hello {\n    public static void main(String[] args){\n        String[] tokens = \"hello my darling\".split(\" \");\n        \n        for(String s : tokens){\n            System.out.println(s);\n        }\n    }\n\n}','hello\nmy\ndarling','Strings',1,NULL),(3559,'public static void main(String[] args){\n        String[] tokens = \"hello5my5darling\".split(\"\\\\d\");\n        \n        for(String s : tokens){\n            System.out.println(s);\n        }\n    }','hello\nmy\ndarling','Strings',1,NULL),(3560,'public static void main(String[] args){\n        String[] tokens = \"bigibhjvu louf kvciy\".split(\"\");\n        \n        for(String s : tokens){\n            System.out.println(s);\n        }\n    }','b\ni\ng\ni\nb\nh\nj\nv\nu\n \nl\no\nu\nf\n \nk\nv\nc\ni\ny','Strings',1,NULL),(3561,'what is scanners default delemiter','whitespace','Strings',1,NULL),(3562,'public static void main(String[] args){\n        Pattern p = Pattern.compile(\"\\\\d*\");\n        Matcher m = p.matcher(\"ab34ef\");\n        while(m.find()){\n            System.out.print(m.start() + m.group());\n        }\n    }','01234456','Strings',1,NULL),(3563,'public static void main(String[] args){\n        Pattern p = Pattern.compile(\"\\\\d*\");\n        Matcher m = p.matcher(\"ab34ef8hk12345\");\n        while(m.find()){\n            System.out.print(m.start() + m.group());\n        }\n    }','0123445687891234514','Strings',1,NULL),(3564,'public class Hello {\n    public static void main(String[] args){\n        ResourceBundle rb = ResourceBundle.getBundle(\"NickNames\");\n        System.out.println(rb.getString(\"Max Bisesi\"));\n        \n    }\n}\n\nclass NickNames extends ListResourceBundle {\n    protected Object[][] getContents(){\n        return new Object[][]{{\"hello\",\"from java\"},{\"Max Bisesi\",\"Big Bad Max\"},{\"Garret Gieske\", \"gieske\"}};\n    }\n}','\n\n\n\n\n\n\n\n\n\n\nException in thread \"main\" java.util.MissingResourceException: \nCan\'t find bundle for base name NickNames, locale en_US\n\n\n\n\n\n\n\n\n\n\n\n','Locale',1,NULL),(3565,'public static void main(String[] args){\n       Locale initial = Locale.getDefault();\n        System.out.println(initial);\n        \n        Locale.setDefault(Locale.GERMANY);\n        System.out.println(Locale.getDefault());\n        \n    }','en_US\nde_DE','Locale',1,NULL),(3566,'two ways to get a ResourceBundle: ?','ResourceBundle.getBundle(basename);\nResourceBundle.getBundle(basename, locale);\n\nfirst uses default locale','Locale',1,NULL),(3567,'Java chooses the most specific resource bundle it can while while giving\npreference to java ListResourceBundle','got it !','Locale',1,NULL),(3568,'request french canadian resource bundle\n\nLocale loc = new Locale(\"fr\",\"CA\");\nResourceBundle rb = ResourceBundle.getBundle(\"RB\",loc);\n\nhow will java search for that bundle ?','RB_fr_CA.java // a java class mathcing excactly\nRB_fr_CA.properties // then it looks for exectaly matching property files\n\nRB_fr.java\nRB_fr.properites // if it cant find both it will look for the Language\n\n\nRB_en_US.java\nRB_en_US.poperties   // use the default locale instead\n\nRB_en.java\nRB_en.properties   //just llook for the default language\n\nRB.java\nRB.properties    //try default Bundle name','Locale',1,NULL),(3569,'What happens if java cant find a resourceBundle','missingresourceexception','Locale',1,NULL),(3570,'ResourceBundles can inherit properties from parents\n\nRB_en.properties\n	ride.in=Take a ride in\n\nRB_en_US.properties\n	elevator=elevator\n\nRB_en_UK.properties\n	elevator=lift\n\nLocale locale = new Locale(\"en\",\"UK\");\nResourceBundle rb = ResourceBundle.getBundle(\"RB\",locale);\nsout(rb.getString(\"ride.in\") + rb.getString(\"elevator\"));','Take a ride in the lift','Locale',1,NULL),(3571,'public static void main(String[] args){\n      ResourceBundle rb = ResourceBundle.getBundle(\"Flag\",new Locale(\"en_CA\"));\n        System.out.println(rb.getString(\"key\"));\n        \n    }\n\nthere are no resourcebundles loaded','MissingResourceException','Locale',1,NULL),(3572,'public static void main(String[] args){\n      ResourceBundle rb = ResourceBundle.getBundle(\"Flag\",new Locale(\"en_CA\"));\n        System.out.println(rb.getString(\"key\"));\n        \n    }\n\ndefault locale is Italian if there is only one resource bundle on the classpath\nhow will java search for that bundle based on the above ?','Flag_en_CA.properties\nFlag_en.java\nFlag_en.properties\nFlag.properties','Locale',1,NULL),(3573,'public static void main(String[] args){\n      ResourceBundle rb = ResourceBundle.getBundle(\"Flag\",new Locale(\"en_CA\"));\n        System.out.println(rb.getString(\"key\"));\n        \n    }\n\nwhich will be chosen ?\n\nFlag_fr_CA.properties\nFlag_en.properties\nFlag_CA.properties ','Flag_en.properties\n\nFlag_fr_CA.properties the language does not match\n\nFlag_CA.properties, CA is not a valid lang code','Locale',1,NULL),(3574,'public static void main(String[] args){\n      Pattern p = Pattern.compile(\"\\\\b\");\n      Matcher m = p.matcher(\"^23 *$76 bc\");\n      while(m.find()){\n          System.out.println(m.start()+\" \");\n      }\n        \n    }','1 \n3 \n6 \n8 \n9 \n11 \n\n\\\\b says that the number reported is the end of a boundary between a wordcharacter\nand a non word character,\n\nbetween 0 and 1 is a boundary between a word and a non word.\n\nimagine the end and beginning of a string is an invisible non word.\nposition 0 was not returned here because ^ is non word and that against the \ninvisble non word is not a boundary','Locale',1,NULL),(3575,'  public static void main(String[] args){\n      Pattern p = Pattern.compile(\"\\\\b\");\n      Matcher m = p.matcher(\"#ab de#\");\n      while(m.find()){\n          System.out.println(m.start()+\" \");\n      }\n        \n    }','1\n3\n4\n6','Locale',1,NULL),(3576,' public static void main(String[] args){\n      Pattern p = Pattern.compile(\"\\\\B\");\n      Matcher m = p.matcher(\"#ab de#\");\n      while(m.find()){\n          System.out.println(m.start()+\" \");\n      }\n        \n    }','0 \n2 \n5 \n7\n\nif there is a non word boundary between the last character and \nthe invible end of string non word boundary then start will give \nthe very last character index, where normally it would give the second \nindex of the two characters creating the non word boudary. ','Strings',1,NULL),(3577,'public static void main(String[] args){\n      Pattern p = Pattern.compile(\"\\\\b\");\n      Matcher m = p.matcher(\"abci####r\");\n      while(m.find()){\n          System.out.println(m.start()+\" \");\n      }\n        \n    }','0 \n4 \n8 \n9','Locale',1,NULL),(3578,'when searched using \\\\b what string would give the result: 2467 ?','something like this ^^rt##r\n\nthe output is determined by the difference between a boundary adn a word boundary\n\n','Strings',1,NULL),(3579,'when searched with \\\\B what string could give 1234567 ? ','^^^^^^^\n\nimagine Strings contain non word characters at the beginning and end of\neach string. Here, \\\\B is saying that there is NOT a word boundary between\nthe imaginary non word character that represents the beginning of the string\nand the first ^ symbol because they are both non words.\n\nThen there is NOT a word boundary between the first and subsequent ^ symbols\nbecause they are all non words. ','Locale',1,NULL),(3580,'public static void main(String[] args){\n        String[] chunks = \"1 a2 b 3 c4d 5e\".split(\"\\\\d\");\n        \n        for(String s : chunks){\n            System.out.println(\".\"+s+\".\");\n        }\n        \n    }','..\n. a.\n. b .\n. c.\n.d .\n.e.\n\nif the first character in the String is a delimter the first array\nelement will be an empty token','Locale',1,NULL),(3581,'if the first character in the String is a delimter the first array\nelement will be an empty token','got it ','Locale',1,NULL),(3582,'Train_en_US.properties: train=subway\nTrain_en_UK.properties: train=undergroudn\nTrain_en_.properties: ride = ride;\n\npublic class Choochoo {\n	public static void main(String[] args) {\n		Locale.setDefault(new Locale(\"en\",\"US\"));\n		ResourceBundle rb = \n	ResourceBundle.getBundle(\"Train\",new Locale(\"en\",\"US\"));\n		sout( rb.getString(\"ride\")+\" \"+rb.getString(\"train\"));\n	}\n}\n\nwhich change can you make independently to change the output to \"ride underground\"\n\nchange line 1 to Locale.setDefault(new Locale(\"en\",\"UK));\nAdd train=underground to Train_en.porperties\nchange line5 to new Locale(\"en\",\"UK\"));\nDelete Train_en_US.properties','Changed line5 to new Locale(\"en\",\"UK\")','Locale',1,NULL),(3583,'when using StringBuilder if you append past the current capacity it\ncan be automatically increased.\n\nif you insert past it you will receive an exception','go it ','Locale',1,NULL),(3584,'public static void main(String[] args){\n        StringBuilder sb = new StringBuilder(8);\n        System.out.println(sb.length() + \" \" + sb + \" \");\n        sb.insert(0,\"abcdef\");\n        sb.append(\"789\");\n        System.out.println(sb.length() + \" \" + sb);   \n    }','0  \n9 abcdef789','Locale',1,NULL),(3585,'public static void main(String[] args){\n        StringBuilder sb = new StringBuilder(8);\n        System.out.println(sb.length() + \" \" + sb + \" \");\n        sb.insert(0,\"abcdefghij\");\n        System.out.println(sb.length() + \" \" + sb);   \n    }','0  \n10 abcdefghij\n\nthe string builders capacity has been increased automatically','General',1,NULL),(3586,'public class Hello {\n    public static void main(String[] args){\n        ResourceBundle rb = ResourceBundle.getBundle(\"NickNames\",Locale.getDefault());\n        Object ob = rb.getInteger(\"123\");\n        \n    }\n}\n\nclass NickNames extends ListResourceBundle {\n    protected Object[][] getContents(){\n        return new Object[][]{{\"hello\",\"from java\"},{\"Max Bisesi\",\"Big Bad Max\"},{\"Garret Gieske\", \"gieske\"},{\"123\",678}};\n    }\n}','will not compile, there is no method getInteger();','General',1,NULL),(3587,'public class Hello {\n    public static void main(String[] args){\n        ResourceBundle rb = ResourceBundle.getBundle(\"Hello.NickNames\",Locale.getDefault());\n        Object ob = rb.getString(\"123\");\n        \n    }\n}\n\nclass NickNames extends ListResourceBundle {\n    protected Object[][] getContents(){\n        return new Object[][]{{\"hello\",\"from java\"},{\"Max Bisesi\",\"Big Bad Max\"},{\"Garret Gieske\", \"gieske\"},{\"123\",678}};\n    }\n}','ClassCastException\n\nyoou can either use getString to get a string or getObject to get anything else\nbut you cannot use getString to get an object','General',1,NULL),(3588,'public static void main(Sa) {\n	String s1 = \"abc\";\n	String s2 = s1;\n	s1 += \"d\";\n	sout(s1+\" \"+s2+\" \"+ (s1==s2));\n	\n	StringBuffer sb1 = new StringBuffer(\"abc\");\n	StringBuffer sb2 = sb1;\n	sb1.append(\"d\");\n	sout(sb1+ \" \" + sb2 + \" \" + (sb1==sb2));\n}','abcd abc false\nabcd abcd true\n\nstring objects are immutable references are mutable\n\nSo here, when the s1+=\"d\" executes. The String \"abc\" was once referenced\nby s1 but it not longer is. Now it is referenced by s2. a New String object\nis created abcd and s1 is reassinged to reference that.','General',1,NULL),(3589,'public class Hello {\n    public static void main(String[] args){\n       String s = \" maxy \";\n       String x = \" denny \";\n       s.trim();\n       x.trim();\n       String y = s+x;\n       \n        System.out.println(y);\n    }\n}',' maxy  denny \n\nstrings are immutable, when s.trim() is executed a new String is created\nand a reference to it is returned then immediately lost. s and x remain\npointing to the strings \" maxy \" and \" denny \".\n','General',1,NULL),(3590,'String s = \"987.123456\";\ndouble d = 987.123456d;\nNumberFormat nf = NumberFormat.getInstance();\nnf.setMaximumFractionDigits(5);\nsout(nf.format(d) + \" \");\ntry {\n	sout(nf.parse(s));\n} catch(ParseException e){ }','987.12346 // rounds doesn\'t truncate\n987.123456 // setMaxFracDigs applies to formating but not parsing','General',1,NULL),(3591,'public static void main(String[] args){\n        Pattern p = Pattern.compile(\"\\\\d+\");\n        Matcher m = p.matcher(\"ab2c4d67\");\n        int count = 0;\n        while(m.find()){\n            count++;\n        }\n        System.out.println(count);\n    }','3\n\n\\\\d looks for digits\n\n+ says one or more ','Strings',1,NULL),(3592,' public static void main(String[] args){\n        Pattern p = Pattern.compile(\"\\\\w+\");\n        Matcher m = p.matcher(\"ab2c4d67\");\n        int count = 0;\n        while(m.find()){\n            count++;\n        }\n        System.out.println(count);\n    }','this one is confusing but remember + is greedy\n\nits not a series of word characters in this case the whole damn thing is \none word character','Strings',1,NULL),(3593,'public static void main(String[] args){\n        Pattern p = Pattern.compile(\"\\\\S+\");\n        Matcher m = p.matcher(\"ab2c4d67\");\n        int count = 0;\n        while(m.find()){\n            count++;\n        }\n        System.out.println(count);\n    }','1\n\nthe whole string is one long non whitespace character and + is greedy\nso it took the whole thing','Strings',1,NULL),(3594,' public static void main(String[] args){\n        Pattern p = Pattern.compile(\"\\\\d+\");\n        Matcher m = p.matcher(\"78254467\");\n        int count = 0;\n        while(m.find()){\n            count++;\n        }\n        System.out.println(count);\n    }','1\n\n+ is greedy so this whole number is one big digit, greedy took the whole \nthing','Strings',1,NULL),(3595,'public static void main(String[] args){\n        Pattern p = Pattern.compile(\"\\\\W+\");\n        Matcher m = p.matcher(\"$%^&*\");\n        int count = 0;\n        while(m.find()){\n            count++;\n        }\n        System.out.println(count);\n    }','1\n\nthe whole string is one big non word character so the greedy + took the whole\nthing','Strings',1,NULL),(3596,'psvm(Sa){\n	String input = \"1 2 a 3 45 6\";	\n	Scanner sc = new Scanner(input);\n	int x = 0;\n	do {\n		x = sc.nextInt();\n		sout(x);	\n	} while(x!=0);\n}','1 2 followed by an exception','General',1,NULL),(3597,'Glob rules',' When the syntax is \"glob\" then the String representation of the path is matched using a limited pattern language that resembles regular expressions but with a simpler syntax. For example:\n\n    *.java 	Matches a path that represents a file name ending in .java\n    *.* 	Matches file names containing a dot\n    *.{java,class} 	Matches file names ending with .java or .class\n    foo.? 	Matches file names starting with foo. and a single character extension\n    /home/*/* 	Matches /home/gus/data on UNIX platforms\n    /home/** 	Matches /home/gus and /home/gus/data on UNIX platforms\n    C:\\\\* 	Matches C:\\foo and C:\\bar on the Windows platform (note that the backslash is escaped; as a string literal in the Java Language the pattern would be \"C:\\\\\\\\*\")\n\nThe following rules are used to interpret glob patterns:\n\n    The * character matches zero or more characters of a name component without crossing directory boundaries.\n\n    The ** characters matches zero or more characters crossing directory boundaries.\n\n    The ? character matches exactly one character of a name component.\n\n    The backslash character (\\) is used to escape characters that would otherwise be interpreted as special characters. The expression \\\\ matches a single backslash and \"\\{\" matches a left brace for example.\n\n    The [ ] characters are a bracket expression that match a single character of a name component out of a set of characters. For example, [abc] matches \"a\", \"b\", or \"c\". The hyphen (-) may be used to specify a range so [a-z] specifies a range that matches from \"a\" to \"z\" (inclusive). These forms can be mixed so [abce-g] matches \"a\", \"b\", \"c\", \"e\", \"f\" or \"g\". If the character after the [ is a ! then it is used for negation so [!a-c] matches any character except \"a\", \"b\", or \"c\".\n\n    Within a bracket expression the *, ? and \\ characters match themselves. The (-) character matches itself if it is the first character within the brackets, or the first character after the ! if negating.\n\n    The { } characters are a group of subpatterns, where the group matches if any subpattern in the group matches. The \",\" character is used to separate the subpatterns. Groups cannot be nested.\n\n    Leading period/dot characters in file name are treated as regular characters in match operations. For example, the \"*\" glob pattern matches file name \".login\". The Files.isHidden(java.nio.file.Path) method may be used to test whether a file is considered hidden.\n\n    All other characters match themselves in an implementation dependent manner. This includes characters representing any name-separators.\n\n    The matching of root components is highly implementation-dependent and is not specified.\n\nWhen the syntax is \"regex\" then the pattern component is a regular expression as defined by the Pattern class.\n\nFor both the glob and regex syntaxes, the matching details, such as whether the matching is case sensitive, are implementation-dependent and therefore not specified.','Strings',1,NULL),(3598,'public class Hello {\n    public static void main(String[] args) {\n        PathMatcher matcher = FileSystems.getDefault().getPathMatcher(\"*\");\n        Path p1 = Paths.get(\"One.java\");\n        \n        System.out.println(matcher.matches(p1));\n\n    }\n\n}','Exception in thread \"main\" java.lang.IllegalArgumentException\n\ngetPathMatcher() argument must take the form:\n\n	syntax:pattern\n\nspecify glob or regex ','Strings',1,NULL),(3599,'public class Hello {\n    public static void main(String[] args) {\n        PathMatcher matcher = FileSystems.getDefault().getPathMatcher(\"glob: *\");\n        Path p1 = Paths.get(\"One.java\");\n        \n        System.out.println(matcher.matches(p1));\n\n    }\n\n}','false, \nthe space after \'glob:\' matters. \n\nto give expected behavior take that space away.','Strings',1,NULL),(3600,'public class Hello {\n    public static void main(String[] args) {\n        PathMatcher matcher = FileSystems.getDefault().getPathMatcher(\"glob:*\");\n        Path p1 = Paths.get(\"One.java\");\n        \n        System.out.println(matcher.matches(p1));\n\n    }\n\n}','true,\n\nin glob * means any string inside directory bounds','Strings',1,NULL),(3601,'public class Hello {\n    public static void main(String[] args) {\n        PathMatcher matcher = FileSystems.getDefault().getPathMatcher(\"glob:\");\n        Path p1 = Paths.get(\"One.java\");\n        Path p2 = Paths.get(\"/home/Files/two.txt\");\n        Path p3 = Paths.get(\"/home/Pictures/amy1.pic\");\n        \n        System.out.println(matcher.matches(p1));\n        System.out.println(matcher.matches(p2));\n        System.out.println(matcher.matches(p3));\n\n    }\n\n}\ncreate a glob to match each of these paths','p1 could be:\n\"glob:*\" \"glob:**\" \"glob:*.{java,class}\" \"glob:One.????\"\n\n ','Strings',1,NULL),(3602,'public class Hello {\n    public static void main(String[] args) {\n        PathMatcher matcher = FileSystems.getDefault().getPathMatcher(\"glob:*{*txt,*pic,/dir}\");\n        Path p1 = Paths.get(\"files.*txt\");\n        Path p2 = Paths.get(\"pictures.*pic\");\n        Path p3 = Paths.get(\"home/dir\");\n        \n        System.out.println(matcher.matches(p1));\n        System.out.println(matcher.matches(p2));\n        System.out.println(matcher.matches(p3));\n    }\n\n}','true\ntrue\ntrue\n\nin a bracketed expression * ? and / match themselves\n\n* matches anything within a directory boundary','Strings',1,NULL),(3603,'public class Hello {\n    public static void main(String[] args) {\n        PathMatcher matcher = FileSystems.getDefault().getPathMatcher(\"glob:*{*txt,*pic,/dir}\");\n        Path p1 = Paths.get(\"home/files.*txt\");\n        Path p2 = Paths.get(\"documents/pictures.*pic\");\n        Path p3 = Paths.get(\"home/dir\");\n        \n        System.out.println(matcher.matches(p1));\n        System.out.println(matcher.matches(p2));\n        System.out.println(matcher.matches(p3));\n    }\n\n}','false \nfalse\ntrue\n\n* doesn\'t work accross directory bounds ','Strings',1,NULL),(3604,'public class Hello {\n    public static void main(String[] args) {\n        PathMatcher matcher = FileSystems.getPathMatcher(\"glob:*{*txt,*pic,/dir}\");\n        Path p1 = Paths.get(\"home/files.*txt\");\n        Path p2 = Paths.get(\"documents/pictures.*pic\");\n        Path p3 = Paths.get(\"home/dir\");\n        \n        System.out.println(matcher.matches(p1));\n        System.out.println(matcher.matches(p2));\n        System.out.println(matcher.matches(p3));\n    }\n\n}','will not compile the proper syntax is:\n\n	FileSystems.getDefault().getPathMatcher()','Strings',1,NULL),(3605,'public class Hello {\n    public static void main(String[] args) {\n        PathMatcher matcher = FileSystems.getDefault().getPathMatcher(\"regex:.*\");\n        Path p1 = Paths.get(\"home/files.*txt\");\n        Path p2 = Paths.get(\"documents/pictures.*pic\");\n        Path p3 = Paths.get(\"home/dir\");\n        \n        System.out.println(matcher.matches(p1));\n        System.out.println(matcher.matches(p2));\n        System.out.println(matcher.matches(p3));\n    }\n\n}','you can also do this to use regex instead of glob.\n\nhere they would all say \'true\'','Strings',1,NULL),(3606,'public class Hello {\n	private int size = 7;\n	private static int length = 3;\n	public static void main(String[] args) {\n		new Hello().go();\n	}\n	void go(){\n		int size = 5;\n                 System.out.println(new Gazer().adder());\n                 \n                 class Gazer {\n                     private int size = 6;\n                      int adder() { return size * length; }\n                }\n	}\n	\n}','will not compile, \n\nGazer is declared after it is used in a method,thats not allowed move it to before','Strings',1,NULL),(3607,'public class Hello {\n	private int size = 7;\n	private static int length = 3;\n	public static void main(String[] args) {\n		new Hello().go();\n	}\n	void go(){\n		int size = 5;\n                class Gazer {\n                      int adder() { return size * length; }\n                }\n                 System.out.println(new Gazer().adder());\n	}\n}','WNC,  \n\nlocal variable size is accessed from within inner class needs to be final,\n\n\n	','Strings',1,NULL),(3608,'public class Hello {\n	private int size = 7;\n	private static int length = 3;\n	public static void main(String[] args) {\n		new Hello().go();\n	}\n	void go(){\n                class Gazer {\n                      int adder() { return size * length; }\n                }\n                 System.out.println(new Gazer().adder());\n	}\n}','21\n\nnothing wrong here, instances can access statics just not the other way around!','Inner Classes',1,NULL),(3609,'public class Hello<T> {\n    \n    public static void main(String[] args){\n        \n        Dog d = new Dog();\n        \n        ArrayList<?> c = makeArrayList(new Animal());\n        \n\n    } \n    public static <G super Dog> ArrayList<G> makeArrayList(G g){\n        ArrayList<G> genlist = new ArrayList<>();\n        genlist.add(g);\n        return genlist;\n        \n    }\n}\n\nclass Animal{}\nclass Dog extends Animal{}','WNC\n\nsuper to bound a named type parameter (e.g. <S super T>) as opposed to a wildcard (e.g. <? super T>) is ILLEGAL simply because even if it\'s allowed, it wouldn\'t do what you\'d hoped it would do, because since Object is the ultimate super of all reference types, and everything is an Object, in effect there is no bound.\n\nIn your specific example, since any array of reference type is an Object[] (by Java array covariance), it can therefore be used as an argument to <S super T> S[] toArray(S[] a) (if such bound is legal) at compile-time, and it wouldn\'t prevent ArrayStoreException at run-time.\n\nWhat you\'re trying to propose is that given:\n\nList<Integer> integerList;\n\nand given this hypothetical super bound on toArray:\n\n<S super T> S[] toArray(S[] a) // hypothetical! currently illegal in Java\n\nthe compiler should only allow the following to compile:\n\nintegerList.toArray(new Integer[0]) // works fine!\nintegerList.toArray(new Number[0])  // works fine!\nintegerList.toArray(new Object[0])  // works fine!\n\nand no other array type arguments (since Integer only has those 3 types as super). That is, you\'re trying to prevent this from compiling:\n\nintegerList.toArray(new String[0])  // trying to prevent this from compiling\n\nbecause, by your argument, String is not a super of Integer. However, Object is a super of Integer, and a String[] is an Object[], so the compiler still would let the above compile, even if hypothetically you can do <S super T>!\n\nSo the following would still compile (just as the way they are right now), and ArrayStoreException at run-time could not be prevented by any compile-time checking using generic type bounds:\n\nintegerList.toArray(new String[0])  // compiles fine!\n// throws ArrayStoreException at run-time\n\nGenerics and arrays don\'t mix, and this is one of the many places where it shows.\nA non-array example\n\nAgain, let\'s say that you have this generic method declaration:\n\n<T super Integer> void add(T number) // hypothetical! currently illegal in Java\n\nAnd you have these variable declarations:\n\nInteger anInteger\nNumber aNumber\nObject anObject\nString aString\n\nYour intention with <T super Integer> (if it\'s legal) is that it should allow add(anInteger), and add(aNumber), and of course add(anObject), but NOT add(aString). Well, String is an Object, so add(aString) would still compile anyway.','Generics',1,NULL),(3610,'When using multi-catch, the catch block parameter is final and cannot \nhave a new value assigned to it in the catch block.\n\ntry{\n\n} catch(SQLException | IOException e){\n	\n	e = new IOException();\n}\n\n// this shows why thats illegal, your not sure which exception type \nwill come through.\n//updated 2','try{\n\n}catch(Exception1 | Exception2 e) {\n\n	e = new Exception1();\n}\n\nTHIS WOULD FAIL COMPILATION\n\n','Exceptions',1,NULL),(3611,'To compile old code that may use \'assert\' as an identifier, \nadd 1.3. This will tell the compiler to treat the word \'assert\' as an identifier.\n\n1.4 will use \'assert\' as a keyword	','javac -source 1.3 OldCode.java\n\njavac -source 1.4 NewCode.java','Exceptions',1,NULL),(3612,'Disable assertions at runtime		','java -da com.maxbisesi.Test\n\njava -disableassertions com.maxbisesi.Test','Exceptions',1,NULL),(3613,'Dont use assert expressions that can cause side effects...','This is a bad idea...\n\npublic void doStuff(){\n	assert (modifyThings());\n	//continue\n}\n\npublic boolean modifyThings() {\n	y = x++;\n	return true;\n}','Exceptions',1,NULL),(3614,'You cant use the variable name multiple times in a multi-catch. \nThe following wont compile...\n\ncatch(Exception1 e1 | Exception2 e2){\n\n}','Fails compilation','Exceptions',1,NULL),(3615,'With Multi catch order does NOT matter...		','the following are equivalent:\n\ncatch(SQLException | IOException e)\n\ncatch(IOException | SQLException e)','Exceptions',1,NULL),(3616,'With Multi-Catch you have to make sure a given excpetion can only\nmatch one type...\n\ncatch(IOException | SQLException e)\n\nthese two are different types.','The following will not compile...\n\ncatch(FileNotFoundException | IOException e)\n\nsince FILNOTFOUND is a subclass of IOException we could have just\nwrtten that in the first place..\n\ncatch(IOException)','Exceptions',1,NULL),(3617,'Legal or illegal...\n\ntry {\n	//do something\n} catch(IOException e){\n	\n	e = new IOException();\n}','This is legal but it is not good practice. It is illegal to reasign the value\nof a multi-catch parameter. \n\ntry {\n	\n} catch(SQLException | IOException e){\n\n	e = new IOException();\n}\n\n^^WILL NOT COMPILE\n','Exceptions',1,NULL),(3618,'public void couldthrow() throws SQLException, IOException { }\n\npublic void rethrow() throws SQLException, IOException {\n	try{\n		couldthrow();\n	} catch(Exception e){ \n		e = new IOException();\n		throw e;\n	}\n}	','Will not compile, it is legal to reassign the parameter here. But it is illegal\nto throw e. The method declares that it throws SQL and IO so throwing a \ngeneral exception is unreported. \n\nif the signature was throws Exception then everything would be fine\n\nException as a genreal','Exceptions',1,NULL),(3619,'legal or illegal\n\ntry {\n\n}','Illegal, regular trys have to have a catch or a finally\n\ntry-with can be used by themselves','Exceptions',1,NULL),(3620,'try(String s = \"hi\") {}','does not compile. \nto be declared in a try with the method has to implement auto closeable or\ncloseable','Exceptions',1,NULL),(3621,'Path p = Paths.get(\"/home/maxbisesi\");\n      try(BufferedReader br = new BufferedReader(new FileReader(p.toFile())), BufferedWriter bw = new BufferedWriter(new FileWriter(p.toFile()))){\n          \n      } catch(IOException e){\n          \n      }','will not compile,\nThe declared resources use a commma , not a semi colon ;\n\nshould be:\n\ntry(Resource r = new Resource(); ...','Exceptions',1,NULL),(3622,'Class A implements AutoCloseable { \n	public void close() throws Exception {}\n}	','ok, AutoCloseable interface allows throwing any Exception','Exceptions',1,NULL),(3623,'class B implements AutoCloseable { public void close() {}}\nclass C implements AutoCloseable { public void close() throws IOException {}}','ok sublcasses or implenting methods can throw a subclass of excpetion\nor none at all.\n\nAutoCloseable\'s  close throws an Exception','Exceptions',1,NULL),(3624,'class D implements Closeable { public void close() throws Exception{}}','ILLEGAL- Closeable only allows IOExceptions or subclasses','Exceptions',1,NULL),(3625,'class E implements Closeable { public void close() throws IOException {}}','ok Closeable allows throwing IOExceptions\n\nvoid close() throws IOException','Collections',1,NULL),(3626,'idempotent','you can call close() multiple times all day and nothing will happen the second time and beyond. \nwill not blow up. ','Exceptions',1,NULL),(3627,'AutoCloseable\'s close() is idempotent	','nothing bad will happen if you call close() more than one time. ','Exceptions',1,NULL),(3628,'Closeable\'s close() is not idempotent','might blow up if called more than once','Exceptions',1,NULL),(3629,'class A implements AutoCloseable {\n	public void close() {\n		sout(\"A\");\n	}\n}\n\nclass B implements AutoCloseable {\n	public void close() {\n		sout(\"B\");\n	}\n}\n\nclass C {\n	psvm(sa){\n		try(A a = new A(); B b = new B()){\n			throw new RuntimeException();\n		} catch(EXception e) {\n			sout(\"catch\");\n		}\n	}\n}\n\nwhat does it print?','B\nA\ncatch\n\nResources are closed in reverse order from what they are declared.','Exceptions',1,NULL),(3630,'public class Suppressed {\n	psvm(sa) {\n		try(One one = new One()) {\n			throw new exception(\"try\");\n		} catch (Exception e) {\n			sout(e.getMessage());\n			\n			for(Throwable t : e.getSuppressed()){\n				sout(\"suppressed:\" + t);\n		}	}\n	}\n}\n\nclass One implements AutoCloseable {\n	public void close() throws IOException {\n		throw new IOException(\"Closing\");\n	}\n}','Try\nsuppressed: java.io.IOException: Closing\n\nafter the exception in the try block gets thrown on line 4, the try with \nresources still calls close() and the catch block catches one \nof the exceptions.\n\nJava adds any excpeittions thrown by close() methods to a suppressed array in the main excpetion. \n\nif no other exception happens in the try block the exceptioon thrown in\nclose() gets treated as the main excpetion  for the catch block. ','Exceptions',1,NULL),(3631,'If the catch or Finally block throws an exception NO SUPPRESSION HAPPENS\nthe last exception thrown gets sent to the caller rather than the one from the \ntry- just like before try with resources','got it ','Exceptions',1,NULL),(3632,'class Bad implements AutoCloseable {\n	String name;\n	Bad(String n) { name = n; }\n	public void close() throws IOException {\n		throw new IOException(\"Closing -\" +name);\n	}\n}\n\npublic class Suppressed {\n	public static void main(SA) {\n		try(Bad b1 = new Bad(\"1\"); Bad b2 = new Bad(\"2\")) {\n			\n		} catch(Exception e) {\n			sout(e.getMessage());\n			for(Throwable t : e.getSuppressed()) {\n				sout(\"suppressed:\" + t);\n			}\n		}\n	}\n}','Closing - 2\nsuppressed: java.io.IOException: Closing - 1\n\nresources close in the opposite order they are declared','Exceptions',1,NULL),(3633,'Stream classes are used to read and write bytes, and Readers and Writers\nare used to read write Characters....','Since all file IO on the exam is related to characters, if you see a Stream\nlike DataOutputStream the the question is probably about serialization\nor something unrelated to the actual IO objective','Input/Output',1,NULL),(3634,'psvm(SA) {\n	try {\n		boolean newFile = false;\n		File file = new File(\"fiileWrite1.txt\");\n		sout(file.exists());\n		newFile = file.createNewFile());\n		sout(newFile);\n		sout(file.exists());\n	} catch (IOException e) {}\n}	','// first time\nfalse\ntrue \ntrue\n\n//second time\ntrue\nfalse\ntrue\n\nexists returns false the first time becasue the file was created as an object\nbut not yet as a physical file. ','Input/Output',1,NULL),(3635,'public static void main(String[] args){\n        File newFile = new File(\"/home/maxbisesi/Public/textFile5.txt\");\n        try{\n            System.out.println(newFile.exists());\n            newFile.createNewFile();\n            System.out.println(newFile.exists());\n        } catch(IOException e){\n            \n        }   \n    }','This method returns true if it can find the actual file\n\nfalse\ntrue\n\n	the first time it is run','Input/Output',1,NULL),(3636,'File method: \ntry {\n	createNewFile();\n} catch(IOException e) { } ','true if the named file does not exist and was successfully created; false if the named file already exists\n','Input/Output',1,NULL),(3637,'File class Constructors	','File(File parent, String child)\nCreates a new File instance from a parent abstract pathname and a child pathname string.\n\nFile(String pathname)\nCreates a new File instance by converting the given pathname string into an abstract pathname.\n\nFile(String parent, String child)\nCreates a new File instance from a parent pathname string and a child pathname string.','Input/Output',1,NULL),(3638,'File class key methods ','createNewFile()\ndelete()\nexists()\nisDirectory()\nisfile()\nlist()\nmkdir()\nrenameTo()','Input/Output',1,NULL),(3639,'FileWriter class Constructors	','FileWriter(File file)\n\nFileWriter(String filename)','Input/Output',1,NULL),(3640,'FileWriter class key methods 	','close()\nflush()\nwrite()','Input/Output',1,NULL),(3641,'BufferedWriter class constructors	','BufferedWriter(Writer out)','Input/Output',1,NULL),(3642,'BufferedWriter key methods	','close() \nflush()\nnewLine()\nwrite()','Input/Output',1,NULL),(3643,'PrintWriter constructors','PrintWriter(File file)\nCreates a new PrintWriter, without automatic line flushing, with the specified file.\n\nPrintWriter(File file, String csn)\nCreates a new PrintWriter, without automatic line flushing, with the specified file and charset.\n\nPrintWriter(OutputStream out)\nCreates a new PrintWriter, without automatic line flushing, from an existing OutputStream.\n\nPrintWriter(OutputStream out, boolean autoFlush)\nCreates a new PrintWriter from an existing OutputStream.\n\nPrintWriter(String fileName)\nCreates a new PrintWriter, without automatic line flushing, with the specified file name.\n\nPrintWriter(String fileName, String csn)\nCreates a new PrintWriter, without automatic line flushing, with the specified file name and charset.\n\nPrintWriter(Writer out)\nCreates a new PrintWriter, without automatic line flushing.\n\nPrintWriter(Writer out, boolean autoFlush)\nCreates a new PrintWriter.','Input/Output',1,NULL),(3644,'FileReader key methods 	','read()','Input/Output',1,NULL),(3645,'BufferedReader constructors	','Reader','Input/Output',1,NULL),(3646,'BufferedReader key methods','read()\nreadLine()','Input/Output',1,NULL),(3647,'File file = new file(\"filewriter2.txt\");\nFileWriter fw = new fileWriter(file);\n\nPrintWriter pw = new PrintWriter (fw);\n\npw.println(\"hello\");\npw.println(\"world\"));','filewrite2.txt would contain the text:\n\nhello\nworld','Input/Output',1,NULL),(3648,'File file = new File(\"filewrite2.txt\");\nFileReader fr = new FileReader(file);\nBufferedReader br = new BufferedReader(fr);\n\nString data = br.readLine();','','Input/Output',1,NULL),(3649,'File file = new File(\"foo\");\n\nif \"foo\" does not exist no actual file is created.\n\nif \"foo\" does exists, the new File object refers to the existing file. ','got it ','Input/Output',1,NULL),(3650,'readers dont have flush methods','io','Input/Output',1,NULL),(3651,'Console.readPassword() returns...','a char[]','Input/Output',1,NULL),(3652,'Path Method:\n\nPath getName(int index)','Returns the path element corresponding to the specified index.\n\nthe 0th element is the one closest to the root.','Input/Output',1,NULL),(3653,'Path Method:\n\nString getFileName()','returns the filename or the last element of the sequence of name elements\n\nor..\n\nReturns the name of the file or directory denoted by this path as a Path object. The file name is the farthest element from the root in the directory hierarchy.','Input/Output',1,NULL),(3654,'public class Hello {\n    public static void main(String[] dicks) throws IOException{\n      Path src = Paths.get(\"/home/maxbisesi/Documents/copy.txt\");\n\n      System.out.println(src.getNameCount());\n      \n    }\n\n}','4','Input/Output',1,NULL),(3655,'\npublic class Hello {\n    public static void main(String[] dicks) throws IOException{\n      Path src = Paths.get(\"/home/maxbisesi/Documents/copy.txt\");\n      Path srcParent = src.getParent();\n      System.out.println(srcParent);\n      \n    }\n\n}','\n/home/maxbisesi/Documents','Input/Output',1,NULL),(3656,'Path Method:\n\nPath getRoot()		','retunrs the root of thsi path, or null if this path does not have a root.','Input/Output',1,NULL),(3657,'Path Method:\n\nPath subpath(int beginindex, int endIndex)','returns a ssubsequence of this path NOT INCLUDING ROOT. \n\nbeginning INCLUSIVE\n\nending EXCLUSIVE','Input/Output',1,NULL),(3658,'Path extends from Iterable<Path>	','that means it can be iterated through in a for loop!','Input/Output',1,NULL),(3659,'int spaces = 1;\nPath myPath = Paths.get(\"tmp\", \"dir1\", \"dir2\", \"dir3\", \"file.txt\");\n\nfor(Path subpath : myPath){\n	sout( subpath + \"//\" );\n}','tmp/dir1/dir2/dir3/file.txt','Input/Output',1,NULL),(3660,'Path method:\n\nPath normalize()	','returns a path that is this path with redundant name elements eliminated\n\n. can be ignored\n\n.. followed by a directory can be removed as redundant','Input/Output',1,NULL),(3661,'Paths.get(\"/a/./b/./c\").normalize();\n','/a/b/c','Input/Output',1,NULL),(3662,'Paths.get(\".classpath\").normalize();','.classpath','Input/Output',1,NULL),(3663,'Paths.get(\"/a/b/c/..\").normalize()','/a/b','Input/Output',1,NULL),(3664,'Paths.get(\"../a/b/c\").normalize()','../a/b/c\n\nThe two dots do say go up one directory, but since there is\'nt a directory\nbefore it Path cant simplify it.','Input/Output',1,NULL),(3665,'Path dir = Paths.get(\"/home/java\");\nPath file = Paths.get(\"models/Model.pdf\");\nPath result = dir.resolve(file);\n\nsout( result );\n	','/home/java/models/Model.pdf\n\npath1.resolve(path2) should be read as \"resolve path2 within path1s directory\n','Input/Output',1,NULL),(3666,'class Hello {\n    public static void main(String[] args) {     \n        Path p1 = Paths.get(\"/home/max/tmp\");\n        Path p2 = Paths.get(\"/google\");\n        System.out.println(p1.resolve(p2));\n        \n    }\n\n}','/google\n\nResolve the given path against this path.\n\nIf the other parameter is an absolute path then this method trivially returns other.\n If other is an empty path then this method trivially returns this path.\n Otherwise this method considers this path to be a directory and resolves\n the given path against this path. In the simplest case, the given path does not have a root component, \nin which case this method joins the given path to this path \nand returns a resulting path that ends with the given path.','Input/Output',1,NULL),(3667,'Path absolute = Paths.get(\"/home/java\");\nPath relative = Paths.get(\"dir\");\nPath file = Paths.get(\"Model.pdf\");\n\nsout( absolute.resolve(relative) );\nsout( asolute.resolve(file) );\nsout( relative.resolve(file) );\nsout( relative.resolve(absolute) ); // BAD\nsout( file.resolve(absolute) ); //BAD\nsout( file.resolve(relative) ); //BAD','/home/java/dir\n/home/java/Model.pdf\n/dir/Model.pdf\n/home/java\n/home/java\nModel.pdf/dir\n\nThe first three do what you would exprect. They add the paramenter\nto resolve to the provided path object. The fourth and fifth try to resolve\nan absolute path within the context of something else. The problem is \nthat an aboluste path doesnt\'t depend on other directories it is absolute.\n','Input/Output',1,NULL),(3668,'Be carefule with questions that come in two flavors. one with a Path parameter\nand the other with a String parameter such as resolve()...\n\nPath path = Paths.get(\"/usr/bin/zip\");\npath.resolve(null);','Thhe compilere cannot decide here so it will not compile','Input/Output',1,NULL),(3669,'Which Path method is used to combine two paths and set one in another?','resolve()','Input/Output',1,NULL),(3670,'Which Path method is used to describe how to gret from one path to \nthe other	','relativize()','Input/Output',1,NULL),(3671,'Path dir = Paths.get(\"/home/java\");\nPath music = Paths.get(\"/home/java/country/Swift.mp3\");\nPath mp3 = dir.reltivize(music);\n\nsout( mp3 );','country/Swift.mp3\n\n\njava recognized that the /home/java part is the same and returned a path of\njust the remainder.\n\npath1.relativize(path2) should be read as \"give me a path shows how to get from\npath1 to path2\"','Input/Output',1,NULL),(3672,'\"give me a path shows how to get from\npath1 to path2\"','.relativize()','Input/Output',1,NULL),(3673,'Path absolute1 = Paths.get(\"/home/java\");\nPath absolute2 = Paths.get(\"/usr/local\");\nPath absolute3 = Paths.get(\"/home/java/temp/music.mp3\");\nPath relative1 = Paths.get(\"temp\");\nPath relative2 = Paths.get(\"temp/music.pdf\");\n\nsout( absolute1.relativize(absolute3) );\nsout( absolute3.relativize(absolute1) );\nsout( absolute1.relativize(absolute2) );\nsout( relative1.relativize(relative2) );\nsout( absolute1.relativize(relative1) ); //BAD','temp/music.mp3\n\n../..\n\n../../usr/local\n\nmusic.pdf\n\nExcpetion in main thread IllegalArgumentExcpetion\n\n	','Input/Output',1,NULL),(3674,'relativeize()','Path relativize(Path other)\n\nConstructs a relative path between this path and a given path.\n\nRelativization is the inverse of resolution. This method attempts to construct a relative path that when resolved against this path, yields a path that locates the same file as the given path. For example, on UNIX, if this path is \"/a/b\" and the given path is \"/a/b/c/d\" then the resulting relative path would be \"c/d\". Where this path and the given path do not have a root component, then a relative path can be constructed. A relative path cannot be constructed if only one of the paths have a root component. Where both paths have a root component then it is implementation dependent if a relative path can be constructed. If this path and the given path are equal then an empty path is returned.\n\nFor any two normalized paths p and q, where q does not have a root component,\n\n    p.relativize(p.resolve(q)).equals(q) \n\nWhen symbolic links are supported, then whether the resulting path, when resolved against this path, yields a path that can be used to locate the same file as other is implementation dependent. For example, if this path is \"/a/b\" and the given path is \"/a/x\" then the resulting relative path may be \"../x\". If \"b\" is a symbolic link then is implementation dependent if \"a/b/../x\" would locate the same file as \"/a/x\".\n\nParameters:\n    other - the path to relativize against this path\nReturns:\n    the resulting relative path, or an empty path if both paths are equal\nThrows:\n    IllegalArgumentException - if other is not a Path that can be relativized against this path','Input/Output',1,NULL),(3675,'When creating a Path you can seperate out folder and filename as much\nor as little as you want. When you don\'t begin with a root the Path\nis considered a relative path, which means Java looks from the current\ndirectory.\n\nPath p6 = Paths.get(\"tmp\", \"file1.txt\"); // relative path\n\n/ (root)\n	| - - tmp\n		| - file1.txt\n		| - tmp\n			| - file1.txt\n','If this program is run from the root, it is the one in /tmp/file1.txt\n\nif it is run from /tmp it is the one in /tmp/tmp/file1.txt\n\nif the program is run from anywhere else the path refers to a file that doesn\nnot exist. ','Input/Output',1,NULL),(3676,'With IO a file doesn\'t exists just because you create a File object.\nIt is the same with Path objects\n\nPath path = Paths.get(\"fileWrite1.txt\");\nsout(Files.exists(path)); // false\nFiles.createFile(path); \nsout(Files.exists(path)); // true','got it ','Input/Output',1,NULL),(3677,'create directories one at a time or all at once	......\n\nTHE directory must exist by the time the file is created','Path path1 = Paths.get(\"/java/source\");\nPath path2 = Paths.get(\"/java/source/directory\");\nPath file = Paths.get(\"/java/source/directory/Program.java\");\nFiles.createDirectory(path1);\nFiles.createDirectory(path2);\nFiles.createFile(file);\n\n// all at once\n\nFiles.createDirectories(path2);\nFile.createFile(file);','Input/Output',1,NULL),(3678,'Date januaryFirst = new GregorianCalendar(20q3, Calendar.January, 1).getTime();\n\nFile file = new File(\"c:/temp/file\");\nfile.createNewFile();\nfile.setLastModified(januaryFirst.getTime());\nfile.setLastModified(januaryFirst.getTime());\nsout(file.lastModified());\nfile.delete();','13570164000000','Input/Output',1,NULL),(3679,'Path path = Paths.get(\"c:/temp/file2\");\nDate januaryFirst = new GregorianCalendar(2013,Calendar.JANUARY, 1).getTime();\nFiles.createFile(path);\nFileTime fileTime = FileTime.fromMillis(januaryFirst.getTime());\nFiles.setLastModifiedTime(path,fileTime);\nsout(Files.getLastModifiedTime(path));\nFiles.delete((path);','2013-01-01T05','Input/Output',1,NULL),(3680,'How would you get the last modified date/time of a Path and a File?\n\nFile file = new file(\"test\");\nPath path = Paths.get(\"test\");','\nfile.lastModified();\n\nFiles.getLastModifiedTime(path);','Input/Output',1,NULL),(3681,'public class Hello {\n    static Thread max ,angela;\n    public static void main(String[] args){\n        angela = new Thread() {\n            public void run(){\n                System.out.println(\"A\");\n                try {\n                    max.sleep(1000);\n                } catch(Exception e){\n                    System.out.println(\"B\");\n                }\n                System.out.println(\"C\");\n                \n            }\n        };\n        \n        max = new Thread() {\n            public void run(){\n                System.out.println(\"D\");\n                try {\n                    angela.wait(); \n                } catch(Exception e){\n                    System.out.println(\"E\");\n                }\n                \n                System.out.println(\"F\");\n            }\n        };\n        \n        max.start();\n        angela.start();   \n    }\n} ','A C D E F \n\nin an undeterminable order, although thread angela uses the max reference\n.Sleep is static and therefore she puts herself to sleep. This is why\nreferences shouldn\'t be used for static methods. \n\nmax trys to synchronize on angela but he does not own the lock so he therefore\ncannot and throws an IllegalMonitorStateException. \n\n... ','Input/Output',1,NULL),(3682,'How would you get theread permision set of a Path and a File?\n\nFile file = new file(\"test\");\nPath path = Paths.get(\"test\");','file.canRead();\n\nFiles.isReadable(path);','Input/Output',1,NULL),(3683,'How would you get write and or execute permision set of a Path and a File?\n\nFile file = new file(\"test\");\nPath path = Paths.get(\"test\");','file.canWrite();\nfile.canExecute();\n\nFiles.isWritable(path);\nFiles.isExecutable(path);','Input/Output',1,NULL),(3684,'How do you set the last modified time of a path and file?\n\nFile file = new file(\"test\");\nPath path = Paths.get(\"test\");','file.setLastModifed(timeinMillis);\n\nFileTime ft = FileTime.fromMillis(timeInMillis);\nFiles.setLastModifiedTime(path,ft);','Input/Output',1,NULL),(3685,'BasicFileAttributes basic = Files.readAttributes(path, BasicFileAttributes.class);\n\nhow would you list the creation time, last access time, and last Modified time?	\n','basic.creationTime();\nbasic.lastAccessTime();\nbasick.lastModifiedTime();\n\nbasic.isDirectory();\n\n','Input/Output',1,NULL),(3686,'Three big things about BasicFileAttributes and BasicFileAttributeView...','1. BasicFileAttributes is PLURAL, BasicFileAttributeVIew is SINGULAR\n\n2. BasicFIleAttributeView basView = Files.getFileAttributeView(   );   \n\n	BasicFileAtttributes bas = FIles.readAttributes(   );\n\n3. You can ONLY update attributes in BasicFileAttributeView, \n	\n	VIEW IS FOR UPDATING','Input/Output',1,NULL),(3687,'How would you construct a PosixFileAttribute object?	','PosixFileAttributes pox = Files.readAttributes(path, PosixFileAttributes.class);\n','Input/Output',1,NULL),(3688,'How would you set a Unix File\'s permissions in Java?	','Path path = Paths.get(\"/tmp/file2\");\nFiles.createFile(path);\nPosixFileAttributes ps = Files.readAttributes(path, PosixFileAttributes.class);\n\nSet<PosixFilePermission> perms = PosixFilePermission.fromString(\"rw-r--r--\");\n\nFiles.setPosixFilePermissions(path,perms);\n\nsout( ps.permissions() );\n\nTHe output would be:\n\n[OWNER_WRITE, GROUP_READ, OTHERS_READ, OWNER_READ ]','Input/Output',1,NULL),(3689,'How to take modified times from one file\nand write new BasicFileAttributes\' last modified times\nlast access time and creation time to another file ... ?','BasicFileAttributes basic = Files.readAttributes(path1, BasicFileAttribute.class );\n\nFileTime at = basic.lastAccessTime();\nFileTime update = basic.lastModifiedTime();\nFileTime now = FileTime.fromMillis(System.currentTimeMiilis() );\n\nPath file = Paths.get(\"/temp/file.txt\");\nFiles.createFile(file);\n\nBasicFileAttributeView view = Files.getBasicFileAttributeView(file, BasicFileAttributeView.class);\n\nview.setTimes(update, at, now);','Input/Output',1,NULL),(3690,'BasicFileAttributeView is a...\n\nClass\n\nInterface\n\nAbstract class     ?','... interface\n\nmethods:\n\nString 	name()\nReturns the name of the attribute view.\n\nBasicFileAttributes 	readAttributes()\nReads the basic file attributes as a bulk operation.\n\nvoid 	setTimes(FileTime lastModifiedTime, FileTime lastAccessTime, FileTime createTime)\n\nUpdates any or all of the file\'s last modified time, last access time, and create time attributes.','Input/Output',1,NULL),(3691,'interface BasicFileAttributes methods.... ','FileTime 	creationTime()\nReturns the creation time.\n\nObject 	fileKey()\nReturns an object that uniquely identifies the given file, or null if a file key is not available.\n\nboolean 	isDirectory()\nTells whether the file is a directory.\n\nboolean 	isOther()\nTells whether the file is something other than a regular file, directory, or symbolic link.\n\nboolean 	isRegularFile()\nTells whether the file is a regular file with opaque content.\n\nboolean 	isSymbolicLink()\nTells whether the file is a symbolic link.\n\nFileTime 	lastAccessTime()\nReturns the time of last access.\n\nFileTime 	lastModifiedTime()\nReturns the time of last modification.\n\nlong 	size()\nReturns the size of the file (in bytes).','Input/Output',1,NULL),(3692,'interface PosixFileAttributes methods','GroupPrincipal 	group()\nReturns the group owner of the file.\n\nUserPrincipal 	owner()\nReturns the owner of the file.\n\nSet<PosixFilePermission> 	permissions()\nReturns the permissions of the file.','Input/Output',1,NULL),(3693,'interface PosixFileAttributeView methods ...','String 	name()\nReturns the name of the attribute view.\n\nPosixFileAttributes 	readAttributes()\nReads the basic file attributes as a bulk operation.\n\nvoid 	setGroup(GroupPrincipal group)\nUpdates the file group-owner.\n\nvoid 	setPermissions(Set<PosixFilePermission> perms)\nUpdates the file permissions.','Input/Output',1,NULL),(3694,'With DosFileAttributeView you can set what new and different file types ?','DosFileAttributeView has methods...\n\nsetArchive()\nsetHidden()\nsetReadOnly()\nsetSystem()\n\nfor Windows specific files ','Input/Output',1,NULL),(3695,'interface DosFileAttributeView methods...','String 	name()\nReturns the name of the attribute view.\n\nDosFileAttributes 	readAttributes()\nReads the basic file attributes as a bulk operation.\n\nvoid 	setArchive(boolean value)\nUpdates the value of the archive attribute.\n\nvoid 	setHidden(boolean value)\nUpdates the value of the hidden attribute.\n\nvoid 	setReadOnly(boolean value)\nUpdates the value of the read-only attribute.\n\nvoid 	setSystem(boolean value)\nUpdates the value of the system attribute.','Input/Output',1,NULL),(3696,'read a DosFileAttributes then declare if it is hidden and readonly \nthen set them so without using a DosFileAttributeView...','DosFileAttributes dos = Files.readAttributes(path, DosFileAttributes.class);\n\nsout( dos.isHidden() );\nsout( dos.isReadOnly() );\n\nFiles.setAttribute(path, \"dos:hidden\", true);\nFiles.setAttribute(path, \"dos:readonly\", true);\n\n','Input/Output',1,NULL),(3697,'You dont always need a XXXFileAttributeView object in order to change\na files attributes, you can just as easily do so with \"Files\" ...\n	','\n    setAttribute\n\n    public static Path setAttribute(Path path,\n                    String attribute,\n                    Object value,\n                    LinkOption... options)\n                             throws IOException\n\n    Sets the value of a file attribute.\n\n    The attribute parameter identifies the attribute to be set and takes the form:\n\n        [view-name:]attribute-name \n\n    where square brackets [...] delineate an optional component and the character \':\' stands for itself.\n\n    view-name is the name of a FileAttributeView that identifies a set of file attributes. If not specified then it defaults to \"basic\", the name of the file attribute view that identifies the basic set of file attributes common to many file systems. attribute-name is the name of the attribute within the set.\n\n    The options array may be used to indicate how symbolic links are handled for the case that the file is a symbolic link. By default, symbolic links are followed and the file attribute of the final target of the link is set. If the option NOFOLLOW_LINKS is present then symbolic links are not followed.\n\n    Usage Example: Suppose we want to set the DOS \"hidden\" attribute:\n\n        Path path = ...\n        Files.setAttribute(path, \"dos:hidden\", true);\n     \n\n    Parameters:\n        path - the path to the file\n        attribute - the attribute to set\n        value - the attribute value\n        options - options indicating how symbolic links are handled\n    Returns:\n        the path parameter\n    Throws:\n        UnsupportedOperationException - if the attribute view is not available\n        IllegalArgumentException - if the attribute name is not specified, or is not recognized, or the attribute value is of the correct type but has an inappropriate value\n        ClassCastException - if the attribute value is not of the expected type or is a collection containing elements that are not of the expected type\n        IOException - if an I/O error occurs\n        SecurityException - In the case of the default provider, and a security manager is installed, its checkWrite method denies write access to the file. If this method is invoked to set security sensitive attributes then the security manager may be invoked to check for additional permissions.\n\n','Input/Output',1,NULL),(3698,'You dont need PosixFileAttributeView to set a file permissions either...','Files.setPosixFilePermissions\n\npublic static Path setPosixFilePermissions(Path path,\n                           Set<PosixFilePermission> perms)\n                                    throws IOException\n\nSets a file\'s POSIX permissions.\n\nThe path parameter is associated with a FileSystem that supports the PosixFileAttributeView. This attribute view provides access to file attributes commonly associated \nwith files on file systems used by operating systems that implement the Portable \nOperating System Interface (POSIX) family of standards.\n\nParameters:\n    path - A file reference that locates the file\n    perms - The new set of permissions\nThrows:\n    UnsupportedOperationException - if the associated file system does not support the PosixFileAttributeView\n    ClassCastException - if the sets contains elements that are not of type PosixFilePermission\n    IOException - if an I/O error occurs\n    SecurityException - In the case of the default provider, and a security manager is installed, it denies RuntimePermission(\"accessUserInformation\") or its checkWrite method denies write access to the file.','Input/Output',1,NULL),(3699,'How to set a linux files permisions from a string ?\n	','PosixFileAttributes pos = Files.readAttributes(path, PosixFileAttributes.class);\nSet<PosixFilePermissions> perms = PosixFilePermissions.fromString(\"rw-r--r--:);\n\nFiles.setPosixFilePermissions(path,perms);\n\nsout(pos.group());\nsout(pos.permissions());','Input/Output',1,NULL),(3700,'What interface is used to recursively loop through a directory ?	','DirectoryStream<T> \n\nT is the element returned by the iterator. \n\nTHis allows for the convieninet use of a for - each loop to go through a dir.\n\nThe elements returned by the iterator are in no specific order.\n\n List<Path> listSourceFiles(Path dir) throws IOException {\n       List<Path> result = new ArrayList<>();\n       try (DirectoryStream<Path> stream = Files.newDirectoryStream(dir, \"*.{c,h,cpp,hpp,java}\")) {\n           for (Path entry: stream) {\n               result.add(entry);\n           }\n       } catch (DirectoryIteratorException ex) {\n           // I/O error encounted during the iteration, the cause is an IOException\n           throw ex.getCause();\n       }\n       return result;\n   }\n ','Input/Output',1,NULL),(3701,'how do you create a new DirectoryStream<T>','\n    Files.newDirectoryStream\n\n    public static DirectoryStream<Path> newDirectoryStream(Path dir)\n                                                    throws IOException\n\n    Opens a directory, returning a DirectoryStream to iterate over all entries in the directory. The elements returned by the directory stream\'s iterator are of type Path, each one representing an entry in the directory. The Path objects are obtained as if by resolving the name of the directory entry against dir.\n\n    When not using the try-with-resources construct, then directory stream\'s close method should be invoked after iteration is completed so as to free any resources held for the open directory.\n\n    When an implementation supports operations on entries in the directory that execute in a race-free manner then the returned directory stream is a SecureDirectoryStream.\n\n    Parameters:\n        dir - the path to the directory\n    Returns:\n        a new and open DirectoryStream object\n    Throws:\n        NotDirectoryException - if the file could not otherwise be opened because it is not a directory (optional specific exception)\n        IOException - if an I/O error occurs\n        SecurityException - In the case of the default provider, and a security manager is installed, the checkRead method is invoked to check read access to the directory.\n\n','Input/Output',1,NULL),(3702,'What type of object are returned by directorystreams iterator ? ','Path\n\nThe directory Stream interface is generic, but thats misleading since the \nonly way create a new DirectoryStream is by using File.newDirectoryStream\nwhich returns a Path.','Input/Output',1,NULL),(3703,'How would you filter the object returned by a directory Stream ?	','use \nFiles.newDirectoryStream(Path dir, String glob);\n\nthis lets you add a glob in that will compare the string representations \nof their file names agains the given glob.\n\nthis lets you filter your results...\n\n Path dir = ...\n     try (DirectoryStream<Path> stream = Files.newDirectoryStream(dir, \"*.java\")) {\n         :\n     }','Input/Output',1,NULL),(3704,'What will be returned by this code...\n\n	Path dir = Paths.get(\"/home/maxbisesi/Documents\");\n        \n	try(DirectoryStream<Path> ds = Files.newDirectoryStream(dir,\"[vx]*\")){\n            sout( );\n        } ','Nothing will not compile, must catch IOException for DirectoryStream','Input/Output',1,NULL),(3705,'How many directories at a time can DirectoryStream look at ?','only 1','Input/Output',1,NULL),(3706,'Think, DirectorySteam acts like ls in bash.','or ...\nDirectoryStream streams one directory','Input/Output',1,NULL),(3707,'What \"Files\" method do you use along with FileVisitor?','public static Path walkFileTree(Path start,\n                FileVisitor<? super Path> visitor)\n                         throws IOException\n\nWalks a file tree.\n\nThis method works as if invoking it were equivalent to evaluating the expression:\n\n     walkFileTree(start, EnumSet.noneOf(FileVisitOption.class), Integer.MAX_VALUE, visitor)\n     \n\nIn other words, it does not follow symbolic links, and visits all levels of the file tree.\n\nParameters:\n    start - the starting file\n    visitor - the file visitor to invoke for each file\nReturns:\n    the starting file\nThrows:\n    SecurityException - If the security manager denies access to the starting file. In the case of the default provider, the checkRead method is invoked to check read access to the directory.\n    IOException - if an I/O error is thrown by a visitor method','Input/Output',1,NULL),(3708,'FileVisitor methods return what ?','FileVisitResult','Input/Output',1,NULL),(3709,'Enum FileVisitResult elements','CONTINUE\nSKIP_SIBLINGS = continue without visiting the siblings of this file or directory\n\nSKIP_SUBTREE = continue without visiting the entries in this directory\n\nTERMINATE','Input/Output',1,NULL),(3710,'SimpleFileVisitor has a protected constructor so It can only be extended','SimpleFileVisitor sf = new SimpleFileVisitor() will not compile','Input/Output',1,NULL),(3711,'try(DirectoryStream stream = Files.newDirectoryStream(dir)){\n	sout(\"throw excpetion\");\n	//do stuff\n}\n\nWhats wrong here ?','DirectoryStream throws an IOException. Therefore anytime you use \nDirectoryStream you must catch an IOException\n\ntry(DirectoryStream stream = Files.newDirectoryStream(dir)){\n	sout(\"throw excpetion\");\n	//do stuff\n} catch(IOException e) { \n	log(e);\n}','Input/Output',1,NULL),(3712,'try(DirectoryStream stream = Files.newDirectoryStream(dir)){\n\n	for(Path file : stream){\n		sout(file.getFileName());\n	}\n} catch(IOException e ){\n\n}\n\nWhats wrong here ??','If DirectroyStream is not typed it will give Object elements. Therefore\nto use an untyped DirectoryStream you would have to use...\n	\n	for(Object file : stream) {\n	\n	}\n\n... but thats usually not what you want so always do this>>>\n\n	try(DirectoryStream<Path> Stream = Files.newDirectoryStream(dir)){\n\n	} catch(IOExcetpion e) {\n\n	}','Input/Output',1,NULL),(3713,'\npublic class CopyCharacters {\n    public static void main(String[] args) throws IOException {\n\n        FileReader inputStream = null;\n        FileWriter outputStream = null;\n\n        try {\n            inputStream = new FileReader(\"xanadu.txt\");\n            outputStream = new FileWriter(\"characteroutput.txt\");\n\n            int c;\n            while ((c = inputStream.read()) != -1) {\n                outputStream.write(c);\n            }\n        } finally {\n            if (inputStream != null) {\n                inputStream.close();\n            }\n            if (outputStream != null) {\n                outputStream.close();\n            }\n        }\n    }\n}\n','All character stream classes are descended from Reader and Writer. \nAs with byte streams, there are character stream classes that specialize in file I/O: FileReader and FileWriter. \nThe CopyCharacters example illustrates these classes.\n\nclose() throws IOException here too','Input/Output',1,NULL),(3714,'What has to be done with pretty much ALL IO classes ?','wrap them in Try Block, they all throw IOExceptions ','Input/Output',1,NULL),(3715,'What method does BufferedReader have that makes it valuable	','public String readLine()\n                throws IOException\n\nReads a line of text. A line is considered to be terminated by any one of a line feed (\'\\n\'), a carriage return (\'\\r\'), or a carriage return followed immediately by a linefeed.\n\nReturns:\n    A String containing the contents of the line, not including any line-termination characters, or null if the end of the stream has been reached\nThrows:\n    IOException - If an I/O error occurs\n\n\nOther IO classes have read methods that only read in a single character\nBufferedReader has this too. But this method really helps!','Input/Output',1,NULL),(3716,'Which IO class swallows exceptions and does not throw them but \nsaid exceptions can be checked using checkerror()','PrintWriter','Input/Output',1,NULL),(3717,'Path file = Paths.get(\"/home/dick/bigorsmall.txt\");\nBufferedWriter bw = new BufferedWriter(new FileWriter(file));\n\nbw.write(\"this ones pretty big \");','wont compile you cant construct a FileWriter from a Path not to mention there is an unreported IOException','Input/Output',1,NULL),(3718,'Files method:\n\nPath copy(Path src, Path targ, CopyOption...options)','Copy the file from the source to target and return the target.\n\nthrows FileAlreadyExistsException if target fiile already exists, and no\nREPLACE_EXSISTING copy Option is specified. ','Input/Output',1,NULL),(3719,'Files method:\n\nPath move(Path src, Path target, CopyOption options)','Moves the file from src to target return target. \n\nthrows:\n\n FileAlreadyExistsException - if the target file exists but cannot be replaced because the REPLACE_EXISTING option is not specified (optional specific exception)\n   \n DirectoryNotEmptyException - the REPLACE_EXISTING option is specified but the file cannot be replaced because it is a non-empty directory (optional specific exception)','Input/Output',1,NULL),(3720,'Path p1 = Paths.get(\"/home/One.txt\");\nPath p2 = Paths.get(\"One.txt\");\nPathMatcher matcher = FileSystems.getDefault().getPathMatcher(\"glob:*.txt\");\n\nsout( matcher.matches(p1) );\nsout( matcher.matches(p2) );','false \ntrue\n\nin glob * means match any character excpet a directory boundary\n\n** mathces any character across directory boundaries. \n\nnotice that PathMatcher(\"syntax:pattern\") can take a glob or a regex but you\nmust specify\n\nedit:\nwas previously:\nDefault().getPathMatcher(\"glob: *.txt\");\n\nthere cant be a space after the : or that will mathch...\n\n	Path path = Paths.get(\"one.txt\");\n        PathMatcher matcher = FileSystems.getDefault().getPathMatcher(\"glob: *.txt\");\n        System.out.println(matcher.matches(path));\n\nwould give false unless the space was removed. | Path p1 = Paths.get(\"/home/One.txt\");\nPath p2 = Paths.get(\"One.txt\");\nPathMatcher matcher = FileSystems.getDefault().getPathMatcher(\"glob: *.txt\");\n\nsout( matcher.matches(p1) );\nsout( matcher.matches(p2) );','Input/Output',1,NULL),(3721,'in Glob what does * mean ? what about ** ?','* matches any character inside a directory boundary\n** matches any character inside a directory boundary\n\n','Input/Output',1,NULL),(3722,'GLOB\n\nwhat does \"?\" mean ?','? matches any single character. ','Input/Output',1,NULL),(3723,'public class Hello {\n    public static void main(String[] args) {\n        PathMatcher matcher = FileSystems.getDefault().getPathMatcher(\"glob:**{.pic,.txt}\");\n        Path p1 = Paths.get(\"home/files.txt\");\n        Path p2 = Paths.get(\"documents/pictures/smile.pic\");\n        Path p3 = Paths.get(\"home/dir\");\n        \n        System.out.println(matcher.matches(p1));\n        System.out.println(matcher.matches(p2));\n        System.out.println(matcher.matches(p3));\n    }\n\n}','true\ntrue\nfalse','Input/Output',1,NULL),(3724,'public void matches(Path path, String glob){\n	PathMatcher matcher = FileSystems.getDefault().getPathMatcher(glob);\n	sout( matcher.matches(path) );\n}\n\nPath p1 = Paths.get(\"Bert-book\");\nPath p2 = Paths.get(\"Kathy-horse\");\nmatches(p1, \"glob:{Bert*,Kathy*}\");\nmatches(p2, \"glob: {Bert, Kathy}*\");\nmatches(p1, \"glob:{Bert,Kathy}\");','true\ntrue\nfalse','Input/Output',1,NULL),(3725,'FileVisitor\n\npublic FileVisitResult visitFileFailed(path file, BasicFileAttributes attrs) {\n\n	// do something\n	return FileVisitResult.CONTINUE;\n	\n}\n','wrong, visitFileFailed takes an IOExcpeption as a parameter\nas well as postVisitDirectory','Input/Output',1,NULL),(3726,'FileVisitor: \n\npublic FileVisitResult preVisitDirectory(path file, BasicFileAttributes attrs) {\n\n	// do something\n	return FileVisitResult.CONTINUE;\n	\n}','right, ','Input/Output',1,NULL),(3727,'FileVisitor:\n\npublic FileVisitResult visitFileFailed(path file, IOException e) {\n\n	// do something\n	return FileVisitResult.CONTINUE;\n	\n}','right','Input/Output',1,NULL),(3728,'FileVisitor:\n\npublic FileVisitResult postVisitDirectory(path file, IOException e) {\n\n	// do something\n	return FileVisitResult.CONTINUE;\n	\n}','right','Input/Output',1,NULL),(3729,'Date today = new Date();\n\nDateFormat df = DateFormat.getInstance();\n\nString todayFile = df.format(today);\n\nsout(todayFile);	// this gives 9/8/01 7:46 PM\n\ntodayFile.replaceAll(\" \",\"-\");\n\nsout( todayFile );\n\nwhat prints now ?','9/8/01 7:46 PM \n\nremember that strings are imutable, so even though you called \nreplaceAll on that string you didn\'t assing it to a new sString therefore it\nwas lost.\n\nshould be:\n	String newDate = todayFile.replaceAll(\" \",\"-\");','Strings',1,NULL),(3730,'Path p1 = Paths.get(todayFile+\".txt\");\nSystem.out.println(p1);\n        \nBufferedWriter bw = new BufferedWriter(new FileWriter(p1));','wont compile, FileWriter doesn\'t have a Path constructor,\n\nchange p1 to p1.toFile();\n\nFileWriter(File file)\nConstructs a FileWriter object given a File object.\n\nFileWriter(File file, boolean append)\nConstructs a FileWriter object given a File object.\n\nFileWriter(FileDescriptor fd)\nConstructs a FileWriter object associated with a file descriptor.\n\nFileWriter(String fileName)\nConstructs a FileWriter object given a file name.\n\nFileWriter(String fileName, boolean append)\nConstructs a FileWriter object given a file name with a boolean indicating whether or not to append the data written.','Input/Output',1,NULL),(3731,'class Eggs {\n	int doX(Long x, Long y){ return 1; }\n	int doX(long...){ return 2; }\n	int doX(Integer x, Integery){ return 3; }\n	int doX(Number n, Number m){ return 4; }\n	public static void main(SA){\n		new Eggs().go();\n	}\n	void go(){\n		short s = 7;\n		sout(doX(s,s) + \" \");\n		sout(doX(7,7));\n	}\n}','4 3 \n\ntwo rules apply to the first doX, you cannot widen and then box in\none step, and var-args are always chosen last. So you cannot widen shorts\nto ints or longs then box them to Integer or Long but you can box short\nto Short then widen that to Number, that takes priority over var args.\n\nthe second doX simmply boxs int to Integer.\n\n\n\n    Assignment contexts allow the use of one of the following:\n\n        an identity conversion (§5.1.1)\n\n        a widening primitive conversion (§5.1.2)\n\n        a widening reference conversion (§5.1.5)\n\n        a boxing conversion (§5.1.7) optionally followed by a widening reference conversion\n\n        an unboxing conversion (§5.1.8) optionally followed by a widening primitive conversion.\n\n\n','General',1,NULL),(3732,'What is the first and second argument to Files.walkFileTree()','the first is the directory to start walking at in the form of a Path\n\nthe second is an object of the class that extends SimpleFileVisitor<Path>','Input/Output',1,NULL),(3733,'Which Two FileVisitor methods take IOExceptions as parameters	?','visitFileFailed and postVisitDirectory','Input/Output',1,NULL),(3734,'Which two FileVisitor methods take BasicFileAttributes as parameters ?','preVisitDirectory and visitFile','Input/Output',1,NULL),(3735,'/home\n	- a.txt\n	- emptyChild	\n	- child\n		- b.txt\n		- grandchild\n			- c.txt\n\npublic class PrintDirs extends SimpleFileVisitor<Path> {\n	public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) {\n		sout( \"pre\" + dir);\n		String name = dir.getFileName().toString();\n		\n		if (name.equals(\"child\"))\n			return FileVisitResult.SKIP_SUBTREE;\n		return FileVisitResult.CONTINUE;\n\n	}\n}\n			\n			\n		\n	','now the output is:\n	pre: /home\n	file: /home/a.txt\n	pre: /home/child\n	pre: /home/emptyChild\n	post: /home/emptyChild\n	post: /home\n\npostVisitDirectory is never called if the subtree of the directory is skipped','Input/Output',1,NULL),(3736,'postVisitDirectory is never called if the subtree of the directory is skipped','','Input/Output',1,NULL),(3737,'/home\n	- a.txt\n	- emptyChild	\n	- child\n		b.txt\n		grandchild\n		c.txt\n\n\" assume you have FileVisitor method from previous flashcards where the\npre post and file are printed before printing the path of that dir or file \"\n\npublic FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) {\n	sout( \"pre: \" + dir);\n	String name = dir.getFileName().toString();\n	\n	if (name.equals(\"grandchild\"))\n		return FileVisitResult.SKIP_SUBTREE;\n	if ( name.equals(\"emptychild\")\n		return FileVisitResult.SKIP_SIBLINGS;\n	return FileVisitResult.CONTINUE;','assuming child is encountered beffore emptyChild, the output is: \n\npre: /home\nfile: /home/a.txt\npre: /home/child\nfile: /home/child/b.txt\npre: /home/child/grandchild\npost: /home/child\npre: /home/emptyChild\npost: /home\n\nyou skip the grandchld subtree so you dont see the postVisitDirectory call\n\nchild is a sibling but it was encountered before emptychild so it was not skipped','Input/Output',1,NULL),(3738,'public void matches(Path path, String glob){\n	PathMatcher matcher = FileSystems.getDefault().getPathMatcher(glob);\n	sout( matcher.matches(path) );\n}\n\nPath p1 = Paths.get(\"0*b/test/1\");\nPath p2 = Paths.get(\"9\\\\*b/test/1\");\nPath p3 = Paths.get(\"01b/test/1\");\nPath p4 = Paths.get(\"0*b/1\");\n\nString glob = \"[0-9]\\\\*{A*,b}/**/1\");\n\nmatches(p1,glob);\nmatches(p2,glob);\nmatches(p3,glob);\nmatches(p4,glob);\n','true \nfalse\nfalse\nfalse\n\n{A*,b} means A followed by anything or the single character b\n\n/**/ means one or more directories with any name\n\n\\\\* the actuall asterix character \\ escapes the * the second \\ espaces the first \\ ','Input/Output',1,NULL),(3739,'What exception if any do FileVisitor methods throw ?','IOException','Input/Output',1,NULL),(3740,'glob vs regex: \n\nZero or more of any character, including directory bounndary','glob: **\n\nregex: .*','Input/Output',1,NULL),(3741,'regex:\n\n.*','zero or or more of any character including directory boundary','Input/Output',1,NULL),(3742,'glob vs regex:\n\nZero or more of any character, not a directory boundary','glob: *\n\nregex: no syntax required','Input/Output',1,NULL),(3743,'Glob vs regex:\n\nexcactly one character','glob: ?\n\nregex: .','Input/Output',1,NULL),(3744,'glob vs regex:\n\nBegins with cat or dog','glob:\n	{cat, dog}*\n\nregex:\n\n	(cat|dog).*','Input/Output',1,NULL),(3745,'(cat|dog).*\n\nglob or regex ?','regex','Input/Output',1,NULL),(3746,'You are creating a PathMatcher\n\nPathMatcher matcher = ________._________().__________();','FileSystems.getDefault().getPathMatcher();','Input/Output',1,NULL),(3747,'You are creating a WatchService:\n\nWatchService watcher = _____________.__________()._________()','FileSystems.getDefault().newWatchService();','Input/Output',1,NULL),(3748,'What do you get from a WatchService to indicate a deletion creation or modification','WatchKey\ntry {\n	WatchKey key;\n	try {\n	key = watcher.take();\n              } catch(interuptedException x) {\n		return;\n	}\n	for(WatchEvent<?> event : key.pollEvents()){\n	//do stuff\n	}','Input/Output',1,NULL),(3749,'What are two ways to get a WatchKey ? \nand whats the difference between them ? ','take() will wait and block forever until an event takes place. Will throw\nInteruptedException if interuped without taking an event. \n\npoll() returns null if an event is not imediately available. ','Input/Output',1,NULL),(3750,'public class Frodo etends Hobbit {\n	public static void main(SA) { \n		int mygold = 7;\n		sout(countGold(mygold,6));\n	}\n}\nclass Hobbit {\n	int countGold(int x, int y) { return x + y; }\n}','does not compile countGold() cannot be called from a static context','Input/Output',1,NULL),(3751,'The contract between equals() and hashCode() is:','1) If two objects are equal, then they must have the same hash code.\n2) If two objects have the same hash code, they may or may not be equal. \n3) If two objects are not equal, they must NOT have the same hashcode\n','OOP',1,NULL),(3752,' public static void main(String[] args){\n       Path dir = Paths.get(\"/home/maxbisesi\");\n       try(DirectoryStream<Path> stream = Files.newDirectoryStream(dir,\"*\");){\n            for(Path path : stream){\n               System.out.println(path);\n            }\n        } catch(IOException e){\n            System.out.println(\"SQLException\");\n            System.out.println(e);\n        }\n   }','shows all files and directories in /home/maxbisesi\n\nsqlexception if the path is not a valid path','Input/Output',1,NULL),(3753,'public class Hello {\n    synchronized void a() { actBusy(); }\n    static synchronized void b() { actBusy(); }\n    static void actBusy() {\n        try {\n            Thread.sleep(1000);\n            \n        } catch( InterruptedException e){}\n            \n        \n    }\n    public static void main(String[] args) {\n        final Hello x = new Hello();\n        final Hello y = new Hello();\n        \n        Runnable runnable = new Runnable() {\n            public void run() {\n                int option = (int) (Math.random() * 4);\n                switch(option) {\n                    case 0: x.a(); break;\n                    case 1: x.b(); break;\n                    case 2: y.a(); break;\n                    case 3: y.b(); break;\n                }\n            }\n        };\n        \n        Thread t1 = new Thread(runnable);\n        Thread t2 = new Thread(runnable);\n        \n        t1.start();\n        t2.start();\n    \n    }\n\n}  \n\nwhich methods could never be running at the same time ?','x.a() thread1 x.a() in thread2\nx.b() thread1 x.b() in thread2\nx.b() thread1 y.b() in thread2\n\nthe same instance method of the same instance is blocked while a static\nmethod accross all methods is blocked. ','Threads',1,NULL),(3754,'Method forwarding relies on Has-a relationships','got it ','OOP',1,NULL),(3755,'class Animal implements Burriable {\n    private Integer size;\n    private String name;\n    \n    public Animal(int x, String y){\n        size = x;\n        name = y;\n    }\n    public Animal(){\n        size = 0;\n        name = \"\";\n    }\n\n    public int getSize() {\n        return size;\n    }\n\n    public String getName() {\n        return name;\n    }\n    \n    public void bury(){\n        System.out.println(\"just toss him in there...\");\n    }\n    public void digUp(){\n        System.out.println(\"Hang on this ones still kickin !\");\n    }\n    public void pray(){\n        System.out.println(\"...Lord forgive us for what we have done, hes only been gone for \"+YEARSDEAD+\" years.\");\n    }\n}\n\nclass Dog implements Burriable{\n    private Animal animal;\n    public Dog(Animal a){\n        animal = a;\n    }\n    \n    public void bury(){\n        animal.bury();\n    }\n    public void digUp(){\n        animal.digUp();\n    }\n    public void pray(){\n        animal.pray();\n    }\n    \n    public String yelpForHelp(){\n        return \"ar ar arrr....\";\n    }\n}\n\ninterface Burriable {\n    int YEARSDEAD = 1;\n    void bury();\n    void digUp();\n    void pray();\n}\n\nwhat OOP principle is this ?','method forwarding\n\nan object composition principle that calles methods on an instance variable of an object','OOP',1,NULL),(3756,'public class F {\n	private static final F f = new F();\n	public static F c(){\n		return f;\n	}\n\n	public void update(F a) { }\n	\n	public void delete(F a) { }\n\n}\nwhat design pattern is this ? ','The singleton pattern is identifiable bby the static variable for the single instance and the accessor returning it. ','OOP',1,NULL),(3757,'public class E {\n	private D d;\n	public void m() {\n		d.m();\n	}\n\n		public static E getInstance() {\n			return new E();\n		}\n}\n\nclass D {\n	public void m() { }\n}\n\nwhat design pattern principle is this ?\n','object composition, you can tell because of the method forwarding. \nSingleton is tempting but the getInstance method here returns a NEW instance\ninstead a single private static one like it should to be singleton. ','OOP',1,NULL),(3758,'class A {}\n\nabstract class G {\n	A m() { return n(); }\n	abstract A n();\n}\n\nwhat principle is demostrated','Factory,\n\nClass A is the object we are creating using the factory method. class G\nis the abstract superclass for the factory. Not shown is a class implementing \nclass G that actually creates the object. ','OOP',1,NULL),(3759,'which is a benefit of the DAO pattern ?	','Reuse The DAO pattern centralize logic for the data access code making reuse\neasier and allowing you to switch out implementations. ','OOP',1,NULL),(3760,'public void print(Path d) throws IOException {\n	try(DirectoryStream<Path> stream = Files.newDirectoryStream(d)){\n		for(Path path: stream){\n			sout( path.getFileName() );\n		}\n	}\n}\n\nwhat files will this display ? ','regular files, hidden files, and subdirectories','Input/Output',1,NULL),(3761,'public class Hello {\n    public static void main(String[] dicks) throws IOException{\n      Path src = Paths.get(\"/home/maxbisesi/Documents/copy.txt\");\n      Files.createFile(src);\n      \n      Files.copy(src, Paths.get(\"/home/maxbisesi/Documents/newcopy.txt\"));\n      \n    }\n\n}\n\nwhat happens if this is ran twice and all preivous files dont exist before','The first time the file will be created and copied normally the second time you\nwill get a file already exists excpeiotn','Input/Output',1,NULL),(3762,'public class Hello {\n    public static void main(String[] dicks){\n        ArrayList list = new ArrayList();\n        \n        list.add(\"java\");\n        list.add(\"sucks\");\n        \n        String item = list.get(0);\n\n    }\n\n}','Compilation fails, to compile would have to be \n\n	Object item = list.get(0);','Collections',1,NULL),(3763,'if(true)\n       int b = 1;\n        ','Will not compile, there is no scope there \n\nif(true){\n	int b = 1;\n} \n	this would though !','General',1,NULL),(3764,'public class Hello {\n    public static void main(String[] dicks){\n        Pattern p = Pattern.compile(\"C.*L\");\n        Matcher m = p.matcher(\"CooLooLCuuLooC\");\n        \n        while(m.find())\n            System.out.println(m.group());\n\n    }\n\n}','CooLooLCuuL\n\n* is the greedy quantifier, it takes as much as it can. ','Strings',1,NULL),(3765,'If a thread\'s priority is not specified explicitly then it gets\nNORM_PRIORITY\n\nT or F ','False it gets the same priority as the thread that created it ','Threads',1,NULL),(3766,'public class Hello {\n    public static void main(String[] dicks){\n        Animal ah2 = new Horse();\n        ah2.eat(\"carrots\");\n    }\n\n}\n\nclass Animal{\n    public void eat(){ }\n}\n\nclass Horse extends Animal {\n    public void eat() { }\n    public void eat(String s ){ } \n}\n    ','Will not compile, method eat in class animal cannot be applied to given types','General',1,NULL),(3767,'public class Hello {\n    public static void main(String[] dicks){\n        Animal ah2 = new Horse();\n        ah2.eat();\n    }\n\n}\n\nclass Animal{\n    public void eat(){ System.out.println(\"Animal\"); }\n}\n\nclass Horse extends Animal {\n    public void eat(){ System.out.println(\"Horse\");} \n}\n\n','Horse','General',1,NULL),(3768,'public class Hello {\n    public static void main(String[] dicks){\n        Animal ah2 = new Horse();\n        ah2.eat();\n    }\n\n}\n\nclass Animal{\n    public void eat(){ System.out.println(\"Animal\"); }\n}\n\nclass Horse extends Animal {\n    public void eat() throws IOException{ System.out.println(\"Horse\");} \n}','will not compile overriden method \ncannot throw new or broader checked exceptions','General',1,NULL),(3769,'public class Hello {\n    public static void main(String[] dicks){\n        Animal ah2 = new Horse();\n        ah2.eat();\n    }\n\n}\n\nclass Animal{\n    public void eat(){ System.out.println(\"Animal\"); }\n}\n\nclass Horse extends Animal {\n    public void eat(int x) throws IOException{ System.out.println(\"Horse\");} \n}','Animal\n\neat in horse is an overload, it still inherits Animals eat()','General',1,NULL),(3770,'//assume valid Connection cn, and good database connection\n\nString query = \"Select * from Answer\";\ntry(Statement stmt = cn.createStatement()){\n	ResultSet rs1 = stmt.executeQuery(query);\n	stmt.executeQuery(\"select * from Question\");\n	while(rs1.next(){\n		sout(rs1.getInt(\"fk_question_num\");\n	}\n} catch(SQLException e){\n	\n}','SQLException\n	Statement objects do not support multiple open ResultSets.\n	\n	Only a single ResultSet can be opened from the same statement object\n\n	*if the same statement object is executed more than once the previous\n	ResultSet is closed automatically\n		\n		... and attempting to access a closed RS is a SQLException','JDBC',1,NULL),(3771,'','','blank',1,NULL),(3772,'try(Connection conn = DriverManager.getConnection(url,user,pw)){\n	String pQuery = \"Select unitPrice From Book Where Title Like ?\";\n\n	PreparedStatement pstmt = conn.prepareStatement(pQuery);\n\n	ResultSet rs = pstmt.executeQuery();\n} catch(SQLException sq) {\n}\n','SQLException , attempting to execute a query without setting a parameter\nresults in an SQLException\n\n	should be>>>\n		\n		pstmt.setString(1,\"dick\");\n\nIndexing starts at 1','JDBC',1,NULL),(3773,'public class Hello {\n    public static void main(String[] dicks){\n        try{\n            couldthrow();\n        } catch(IOException | SQLException e){\n            \n        }\n        \n    }\n    \n    public static void couldthrow() throws IOException, SQLException{\n        \n    }\n\n}','compiles and runs just fine ','Exceptions',1,NULL),(3774,'public boolean equals(Object o) { \n	if(((Moof)o).getMoofValue() == this.moofValue {\n		return true;\n	} else {\n		return false;\n	}\n}\n\nwhats missing here','instanceof test','Collections',1,NULL),(3775,'equals() hashCode() and toString() are all PUBLIC','got it','Collections',1,NULL),(3776,'equals() Contract\n\nreflexive	','for any reference value x, x.equals(x) should be true. ','Collections',1,NULL),(3777,'equals() contract,\n\nsymmetric','for any reference values x and y, \n\nx.equals(y) shoud be true if and only if \ny.equals(x) returns true. ','Collections',1,NULL),(3778,'what are the four tenants of the equals contract ?','reflxive, x.equals(x) is always true\n\nsymetric, x.equals(y) and y.equals(x)\n\ntransitive, if x.equals(y) and y.equals(z) then x.equals(z)\n\nconsistent, x.equals(y) is true no matter how many times you call it\n\nif x is non null, x.equals(null) is always false','Collections',1,NULL),(3779,'if two objects are considered equal, their hashcodes...','MUST also be equal.','Collections',1,NULL),(3780,'Is it still legal to have a hashcode that always returns the same number ?','Yes just inefficient, all objects will go in the same bucket. The Collection\nwill search through a single big bucket using equal() to find the instance\nits looking for. In that case you defeat the purpose of using a hashed collection. ','Collections',1,NULL),(3781,'HashCode contract:\n\n1\n\n2\n\n\n3','When it is invoked on the same object more than once during an execution\nof a java application the hashcode() method must consistently return the \nsame integer \n\nIf two objects are equal according to the equals method, then calling hashchode)( \non each of the objects must produce the same integer\n\nunequal objects can still produce the same hashcodes \n\n*That means that equals and hashCode must work with same attributes somehow','Collections',1,NULL),(3782,'x.equals(y) == true\n\nmeans what for hashcode()...','x.hashcode() == y.hashcode()','Collections',1,NULL),(3783,'x.hashCode() != y.hashCode()	\n\nmeans what for equals()','x.equals(y) == false\n\nequals() and hashcode are like directions to get to a specific \nelement\n\nhashCode places all the elements in seperate but similiar buckets \nequals() gets the correct ones out.\n\nso if two elemets have different hashCodes they will be in different buckets\nanyway so hashCode is one level of precision and equals() is the next.','Collections',1,NULL),(3784,'public static void main(String[] args){\n        Path p = Paths.get(\"/home/maxbisesi/Public/GenDir/genFile.txt\");\n        Path p2 = Paths.get(\"/home/maxbisesi/Public\");\n        \n        System.out.println(p.relativize(p2));\n        System.out.println(p2.relativize(p));  \n}','../..\nGenDir/genFile.txt\n','Input/Output',1,NULL),(3785,'Collections:\n\n	Vector\n','a Vector is the same as an ArrayList but Vector methods are synchronized\nfor thread safety. \n\nVector and Hashtable are the two original collections\n\nunless you really need thread safety choose ArrayList over Vector, \nthe synchronized methods give an unecssary performance hit. \n\n','Collections',1,NULL),(3786,'Collections:\n\n	LinkedList','is ordered by index position except that the elements are doubly linked to \none another. This linkage gives you new methods for adding and removing\nfrom the beginning or end.\n\nEasy choice for implementing a stack or queue. \n\nmay iterate more slowly than ArrayList but still a good choice when you need\nfast insertion and deletion.\n\nLinkedList supports peek(), poll(), offer(), Queue methods!!','Collections',1,NULL),(3787,'Which Interface disallows duplicates','Set','Collections',1,NULL),(3788,'Collections:\n	\n	HashSet','unsorted and unordered. Uses the hashcode of the object being inserted\n\nso the more effeicinet your hashcode the more effecient access youll get\n\nUse for a collection with no duplicates where you dont care about the\norder when you iterate through it.','Collections',1,NULL),(3789,'Collections:\n\n	LinkedHashSet','\nMaintains a doubly linked list across elelemnts so the insertion order \nis maintained\n\nduplicates are still disallowed. ','Collections',1,NULL),(3790,'Collections:\n\n	TreeSet','Sorted\n\nguarentees elements will be in ascending order according to natural order\n\n','Collections',1,NULL),(3791,'public class Reader {\n	public void read(Path p, Charset s) {\n		try(BufferedReader r = Files.newBufferedReader(p,s)) {\n			try { r.read(); }\n			catch(IOException f) {\n				r.readLine();\n			}\n		} catch(IOException || NullPointerException e) {\n			r.close();\n		} finally {\n			r.close();\n		}\n	}\n}','compilation fails at the last three lines,\n\n1. multi catch syntax is | not ||\n\n2. objects declared in a try block are only available within the \ntry block so closing r is out of scope','Input/Output',1,NULL),(3792,'Collections:\n\n	HashMap','unsorted and unordered Map. \n\nUse When you need a map and you don\'t care\nabout the order when you iterate through. \n\nThe basic map, other maps add a little more overhead. \n\nWhere keys land in the map is based on hashCode() \n\nHashMap allows one null key and multiple null values ','blank',1,NULL),(3793,'Collections:\n	\n	Hashtable\n	','Hashtable is the synchronized counterpart to HashMap. \n\nWhile HashMap lets you have a null key and null values\n\nHashtable doesn\'t allow anything thats null!','Collections',1,NULL),(3794,'HashMap allows multiple null values','True!\n\nHashtable doesn\'t allow anything null it will throw a npe','Collections',1,NULL),(3795,'HashMap allows multiple null keys','FALSE\n\nThat would defeat the purpose of a \"key\"','Collections',1,NULL),(3796,'HashMap is sorted','FALSE\n\nunordered and unsorted','Collections',1,NULL),(3797,'HashMap is synchronized','FALSE','Collections',1,NULL),(3798,'Hashtable is synchronized ','True!','Collections',1,NULL),(3799,'Hashtable allows multiple null values and one null key','FALSE, nothing can be null in Hashtable','blank',1,NULL),(3800,'public static ArrayList<Animal> staggerSort(ArrayList<? extends Animal> list){\n        Map<String,List<Number>> byCategory = seperateToCategories(list);\n        return null;\n    }\n    \n    static Map<String,List<Number>> seperateToCategories(ArrayList<Animal> list){\n        return null;\n    }','since list is declared as anything that extends Animal you cant be sure that it\nwill be the right type to pass into the next method that taks <Animal>\n\nWill not compile','Generics',1,NULL),(3801,'public static void main(String[] args){\n        LinkedHashMap<String,String> lhm = new LinkedHashMap<>();\n        lhm.put(\"big\",\"Country\");\n        lhm.put(\"sweet\",\"Cheeks\");\n        lhm.put(\"big\",\"Bucks\");\n        \n        for(Map.Entry<String,String> entry: lhm.entrySet()){\n            System.out.println(entry.getKey()+\" \"+entry.getValue());\n        }\n        \n    }','big Bucks\nsweet Cheeks\n\nbig Bucks replaced big Country in the map, LinkedHashMaps maintain insertion\norder. \n\nso that mapping was simply replaced but it kept its position','Collections',1,NULL),(3802,'class Gutsy {\n	public static void main(String[] args){\n		new Gutsy().go();\n	}\n	void go() throws IOException {\n	String row;\n	try {\n		FileReader fr = new FileReader(\"TestFile.txt\");\n		BufferedReader br = new BufferedReader(fr);\n		while((row = br.readLine() ) != null)\n			sout( row );\n	} catch(IOException e) {\n		sout(\"got io error\");\n	} finally {\n		sout( \"done\" );\n	}\n   }\n}','WNC,\n\ngo() declares that it throws a checked exceptions so it has to be handled\nor thrown in main.\n\nif that would have compiled an IOException would be thrown so it would\nprint got io error done. ','Exceptions',1,NULL),(3803,'Given a properly prepared string[] with five elements what is the range \nof possible results that could be returned by Arrays.binarySearch() ? ','-6 through 4','Collections',1,NULL),(3804,'TreeMap','sorted Map\n\nsorted by natural order or custom comparison rules.','blank',1,NULL),(3805,'List<String> test = new ArrrayList<String>();\nString s = \"hi\";\ntest.add(\"string\");\ntest.add(s);\ntest.add(s+s);\nsout( test.size() );\nsout( test.contains(42) );\nsout( test.contains(\"hihi\") );\ntest.remove(\"hi\");\nsout( test.size() );','3\nfalse\ntrue\n2','Collections',1,NULL),(3806,'List myInts = new ArrayList();\n        myInts.add(4);\n        \n        myInts.add(new Integer(4));','These two are the same, the first demonstrates autoboxing. ','blank',1,NULL),(3807,'class Boxing2 {\n	static Integer x;\n	psvm(sa) {\n		doStuff(x);\n	}\n\n	static void doStuff(int z) {\n		int z2 = 5;\n		sout( z2 + z );\n	}\n}','NullPointerException','General',1,NULL),(3808,'public static void main(String[] dicks){\n        ArrayList<String> list = new ArrayList<>();\n        \n        list.add(\"CZ\");\n        list.add(\"a\");\n        list.add(\"AB\");\n        list.add(\"CE\");\n        list.add(\"CZ\");\n        list.add(\"cz\");\n        list.add(\"BA\");\n        list.add(\"BF\");\n        list.add(\"ABC\");\n        list.add(\"CE\");\n        list.add(\" CE\");\n        list.add(\"A\");\n        list.add(\"ce\");\n        list.add(\"A B\");\n        list.add(\"AA\");\n        list.add(\" Z\");\n        \n        System.out.println(\"unsorted: \"+list);\n        Collections.sort(list);\n        System.out.println(\"sorted: \"+list);','unsorted: [CZ, a, AB, CE, CZ, cz, BA, BF, ABC, CE,  CE, A, ce, A B, AA,  Z]\nsorted: [ CE,  Z, A, A B, AA, AB, ABC, BA, BF, CE, CE, CZ, CZ, a, ce, cz]\n\nspaces come first, as shown by A B and AA. Also capitals come before lowercase','Collections',1,NULL),(3809,'public class Hello {\n    public static void main(String[] dicks){\n        List<Horse> stable = new ArrayList<>();\n        \n        for(int x =0; x < 10; x++){\n            stable.add(new Horse());\n        }\n        \n        Collections.sort(stable);\n        \n    }\n\n}\n\nclass Horse {\n    public boolean equals(Horse s){\n        return false;\n    }\n}','Will not compile, Horse does not implement Comparable','Collections',1,NULL),(3810,'class Horse implements Comparable<Horse> {\n    public boolean equals(Horse s){\n        return false;\n    }\n    \n    int compareTo(Horse h){\n        \n    }\n    \n    \n}','will not compile, compareTo is public ','Collections',1,NULL),(3811,'public class Hello {\n    public static void main(String[] dicks){\n        List<Horse> stable = new ArrayList<>();\n        \n        for(int x =0; x < 10; x++){\n            stable.add(new Horse(\"lucky\"+x));\n        }\n        \n        Collections.sort(stable);\n        \n    }\n\n}\n\nclass Horse implements Comparable<Horse> {\n    String name;\n    \n    public Horse(String x){\n        name = x;\n    }\n    \n    public String getName(){\n        return name;\n    }\n    \n    public boolean equals(Horse s){\n        return false;\n    }\n    \n    public int compareTo(Horse h){\n        return name.compareTo(h.getName());\n        \n    }\n    \n    \n}','compiles fine!','Collections',1,NULL),(3812,'When you override equals() you must take an argument of what type ?','Object','Collections',1,NULL),(3813,'When you override compareTo() you must take an argument of type?','The type your sorting.\n\n\npublic interface Comparable<T>\n\n...type T','Collections',1,NULL),(3814,'class DVDInfo implements Comparable {\n	public int comparteTo(Object o) {\n		DVDInfo d = (DVDInfo) o;\n		return title.compareTo(d.getTitle() );\n	}\n}','This is still legal but painful, genereics make this easier but it will still \ncompile','Collections',1,NULL),(3815,'Comparator has _________________\n\nComparable has _________________','compare()\n\ncompareTo()','Collections',1,NULL),(3816,'Which soritng interface do you implement to create individual sorting classes\n	','Comparator','Collections',1,NULL),(3817,'class Dicksorter implements Comparator<Dicks> {\n	public int compareTo(Dick one) {\n	}\n}','will not compile the method is:\n\n	int compare(T o1, T o2)','Collections',1,NULL),(3818,'class DickSorter implements Comparator<Dick> {\n	public int compare(Dick one, Dick two){\n		return one.getSize().compareTo(two.getSize());\n	}\n}','compiles fine, this takes advvantage of integer comparison','Collections',1,NULL),(3819,'public class Hello {\n    public static void main(String[] dicks){\n        List<Horse> stable = new ArrayList<>();\n        \n        stable.add(new Horse(\"Honey\"));\n        stable.add(new Horse(\"Mighty Mikey\"));\n        stable.add( new Horse(\"The Fastest Stud in the Mud\"));\n        stable.add( new Horse(\"Churchill\"));\n        \n        Horse[] ranch = stable.toArray();\n\n    }\n\n}','Will not compile\n\ntoArray() in List interface returns an Object[]','Collections',1,NULL),(3820,'public class Hello {\n    public static void main(String[] dicks){\n        Horse[] stable = {new Horse(\"Johny\"), new Horse(\"wilfred\"), new Horse(\"Marco\"), new Horse(\"MAx\"), new Horse(\"Billy\") };\n        \n        int x = Arrays.binarySearch(stable,\"Johny\");\n        System.out.println(x);  \n\n    }\n\n}','ClassCastException, \"johny\" cant be turned into a horse\n\nshould be Arrays.binarySearch(stable,new Horse(\"Johny\"));','Collections',1,NULL),(3821,'public class Hello {\n    public static void main(String[] dicks){\n        Horse[] stable = {new Horse(\"Johny\"), new Horse(\"wilfred\"), new Horse(\"Marco\"), new Horse(\"MAx\"), new Horse(\"Billy\") };\n        \n        int x = Arrays.binarySearch(stable,new Horse(\"Johny\"));\n        System.out.println(x);  \n\n    }\n\n}    \n\nclass Horse implements Comparable<Horse> {\n    String name;\n    \n    public Horse(String x){\n        name = x;\n    }\n    \n    public String getName(){\n        return name;\n    }\n    \n    public boolean equals(Horse s){\n        return false;\n    }\n    \n    public int compareTo(Horse h){\n        return name.compareTo(h.getName());\n        \n    }\n    \n    \n    ','The results are undefined, the array is not sorted. ','Collections',1,NULL),(3822,'public class Hello {\n    public static void main(String[] dicks){\n        Horse[] stable = {new Horse(\"Johny\"), new Horse(\"wilfred\"), new Horse(\"Marco\"), new Horse(\"MAx\"), new Horse(\"Billy\") };\n        \n        \n        int x = Arrays.binarySearch(stable,new Horse(\"Marco\"));\n        System.out.println(x);  \n\n    }\n\n}\n\nclass Horse {\n    String name;\n    \n    public Horse(String x){\n        name = x;\n    }\n    \n    public String getName(){\n        return name;\n    }\n    \n    public boolean equals(Horse s){\n        return false;\n    }\n    \n}','ClassCastException Horse cannot be converted to Comparable\n\nbinarySearch uses comparable to search the Array.\n\nThis search would give inconsistant results anyways because \nthe array was not sorted first. \n\nto fix add this:\n\nclass Horse implements Comparable<Horse> {\n    String name;\n    \n    public Horse(String x){\n        name = x;\n    }\n    \n    public String getName(){\n        return name;\n    }\n    \n    public boolean equals(Horse s){\n        return false;\n    }\n    \n    public int compareTo(Horse s){\n        return name.compareTo(s.getName());\n    }\n    \n}\n\n-if an array is sorted in natrual order it must searched in natural order \n-if it is sorted using a comparator it must be searched using the same comparator.\n','Collections',1,NULL),(3823,'public class Hello {\n    public static void main(String[] dicks){\n        Horse[] stable = {new Horse(\"Johny\"), new Horse(\"wilfred\"), new Horse(\"Marco\"), new Horse(\"MAx\"), new Horse(\"Billy\") };\n        int x = Arrays.binarySearch(stable,new Horse(\"Marco\"));\n        System.out.println(x);  \n    }\n}\n\nclass Horse implements Comparable{\n    String name;\n    public Horse(String x){\n        name = x;\n    }\n    public String getName(){\n        return name;\n    }\n    public boolean equals(Horse s){\n        return false;\n    }\n    public int compareTo(Horse h){\n        return name.compareTo(h.getName());  \n    }\n}\n','Will not compile, if the untyped version of Comparable is used then\nthe parameter to compareTo would be Object\n\neither change to Comparable<Horse>\n\nor \n\ncomparTo(Object o) and cast.\n\notherwise, the answer would be 2 remember arrays aren\'t sorted even though\nyour using comparable the elements of an array dont get sorted so the positions are \nwhat index they were defined as !\n\nThis would give undefined results','Collections',1,NULL),(3824,'What method is used to search through Arrays and Collections','binarySearch()\n\nreturns the int index of the element being searched.\n\nUnsuccesful searches return an int index that represents the\n insertion point. \n\nThe collection or array must be sorted before you can search it.\n\nif you attempt to search an unsorted array or collection the results of the\nsearch will be unpredictable.\n\nIf it was sorted in natural order it must searched in natural order.\n	do this by NOT sending a Comparator as an argument to the binarySearch() \n\nIf it was sorted with a comparator it must be searched using the same comparator\n\n	\n	','Collections',1,NULL),(3825,'class Horse implements Comparable{\n    String name;\n    \n    public Horse(String x){\n        name = x;\n    }\n    \n    public String getName(){\n        return name;\n    }\n    \n    public boolean equals(Horse s){\n        return false;\n    }\n    \n    public int compareTo(Object h){\n        return name.compareTo(h.getName());\n  \n    }','will not compile, need to cast\n\nreturn name.compareTo(((Horse)h).getName());\n\ndoes not compile because h is an Object and Objects dont have a method\ncalled getName. \n\nyou would cast h to a horse. \n\nObject is the right argument type here though because Comparable is a raw type\nif it were Comparable<Horse> the argument would need to be Horse.','Collections',1,NULL),(3826,'public class Hello {\n    public static void main(String[] dicks){\n       Animal[] beavers = new Beaver[5];\n       \n       Animal[] animals = {new Beaver(), new Beaver(), new Beaver() };\n       \n       Animal[] ans2 = new Animal[5];\n       ans2[0] = new Beaver();\n\n    }\n}\n\nclass Animal{\n    public Animal(){\n        \n    }\n    \n    public String getName(){\n        return \"d\";\n    }\n}\n\nclass Beaver extends Animal{\n    \n}','these all compile fine, \n\nPolymorphism works with Arrays. ','Collections',1,NULL),(3827,'public class Hello {\n    public static void main(String[] dicks){\n       \n        String[] strings = {\"One\",\"Dice\",\"Angela\",\"Bisesi\",\"Franko\"};\n        \n        Arrays.sort(strings);\n        int x = Arrays.binarySearch(strings,\"Dice\");\n        System.out.println(x);  \n        \n        Arrays.sort(strings);\n        \n        System.out.println(Arrays.binarySearch(strings,\"Angela\"));\n    }\n\n}','2\n0','Collections',1,NULL),(3828,'class sortBySecondLetter implements Comparator<String> {\n    int compare(String one, String two){\n        \n    }\n}','compare must be public, will not compile','Collections',1,NULL),(3829,'class sortBySecondLetter implements Comparator<String> {\n    public int compare(String one, String two){\n        char charone = one.charAt(1);\n        char chartwo = two.charAt(1);\n        \n        return charone.compareTo(chartwo);\n    }\n}','will not compile, char is a primitive so charone cannot be dereferenced here\nchange to Character.','Collections',1,NULL),(3830,'public class Hello {\n    public static void main(String[] dicks){\n        sortBySecondLetter sbsl = new sortBySecondLetter();\n        String[] strings = {\"One\",\"Dice\",\"Angela\",\"Bisesi\",\"Franko\"};\n        \n        Arrays.sort(strings,sbsl);\n        \n        System.out.println(strings);\n    }\n\n}','[Ljava.lang.String;@15db9742\n\narrays are not classes','Collections',1,NULL),(3831,'String[] sa = {\"one\", \"two\", \"three\", \"four\" };\nList sList = Arrays.asList(sa);\n\nSout( \"size \" + sList.size() );\nsout( \"idx2 \" + sList.get(2) );\n\nsList.set(3,\"six\" );\nsa[1] = \"five\";\n\nfor(String s : sa ){\n	sout( s + \" \");\n}\nsout(\"\\n s1[1] \" + sList.get(1) );','size 4\nidx2 three\none \nfive \nthree \nsix \ns1[1] five','Collections',1,NULL),(3832,'public class Hello {\n    public static void main(String[] args){\n        String[] sa = {\"one\", \"two\", \"three\", \"four\" };\n        List sList = Arrays.asList(sa);\n\n        System.out.println( \"size \" + sList.size() );\n        System.out.println( \"idx2 \" + sList.get(2) );\n\n        sList.set(3,\"six\" );\n        sa[1] = \"five\";\n\n        for(String s : sa ){\n            System.out.println( s + \" \");\n        }\n        System.out.println(\"s1[1] \" + sList.get(1) );\n        \n        sList.remove(\"five\");\n        for(String s : sa)\n            System.out.println(s+\" \");\n    }\n\n}','UnsupportedOperationException\n\nThis UnsupportedOperationException comes when you try to perform some operation on collection where its not \nallowed and in your case, When you call Arrays.asList it \ndoes not return a java.util.ArrayList. It returns a java.util.Arrays$ArrayList which is an immutable list. \nYou cannot add to it and you cannot remove from it.\n\nReturns a {@code List} of the objects in the specified array. The size of the {@code List} cannot be modified, i.e. adding and removing are unsupported, but the elements can be set. Setting an element modifies the underlying array.\n\nEDIT\n\nThe type of the resulting list is Arrays.ArrayList, which is a private class inside Arrays.class. Practically speaking,\nit is nothing but a List-view on the array that you\'ve passed with Arrays.asList. With a consequence: if you change the array, the list is changed too. And because an array is not resizeable, \nremove and add operation must be unsupported.\n','Collections',1,NULL),(3833,'String[] sa = {\"one\", \"two\", \"three\", \"four\" };\n        List sList = Arrays.asList(sa);\n\n        System.out.println( \"size \" + sList.size() );\n        System.out.println( \"idx2 \" + sList.get(2) );\n\n        sList.set(3,\"six\" );\n        sa[1] = \"five\";\n\n        for(String s : sa ){\n            System.out.println( s + \" \");\n        }\n        System.out.println(\"s1[1] \" + sList.get(1) );\n        \n        sList.set(1, \"FIVE\");\n	sList.set(3,\"SIX);\n        for(String s : sa)\n            System.out.println(s+\" \");','size 4\nidx2 three\none \nfive \nthree \nsix \ns1[1] five\none \nFIVE \nthree \nSIX\n\nThis shows that Arrays and Lists coming from\nArrays.asList() are \"joined at the hip\" changes in one affect \nthe other. This is different from a \"Backed Collection\". Because \nBacked Collections dont go both ways and are only backed for a certain range.','Collections',1,NULL),(3834,'public static void main(String[] dicks){\n        String[] sa = {\"one\", \"two\", \"three\", \"four\" };\n        List sList = Arrays.asList(sa);\n\n        System.out.println( \"size \" + sList.size() );\n        System.out.println( \"idx2 \" + sList.get(2) );\n\n        sList.set(3,\"six\" );\n        sa[1] = \"five\";\n\n        for(String s : sa ){\n            System.out.println( s + \" \");\n        }\n        System.out.println(\"s1[1] \" + sList.get(1) );\n        \n        sList.set(1, \"FIVE\");\n        sList.set(3,\"SIX\");\n        sList.add(\"SEVEN\");\n        for(String s : sa)\n            System.out.println(s+\" \");','unsupported operation exception, \n\nList returned by asList is fixed size can only be updated not added to or removed from','Collections',1,NULL),(3835,' public static void main(String[] dicks){\n        List<Integer> iL = new ArrayList<Integer>();\n        for(int x=0; x<3; x++){\n                iL.add(x);\n        }\n        Object[] oa = iL.toArray();\n        Integer[] ia2 = new Integer[3];\n        ia2 = iL.toArray(oa);\n    }','will not compile, toArray( T[] a) will return an array of the type you send\nto it. so here an Object[] cannot be assigned to an Integer[].\n\nto fix:\n	change oa to ia2 which will cause toArray to return an Integer[]','Collections',1,NULL),(3836,'public static void main(String[] dicks){\n        List<Integer> iL = new ArrayList<Integer>();\n        for(int x=0; x<5; x++){\n                iL.add(x);\n        }\n        Object[] oa = iL.toArray();\n        Integer[] ia2 = new Integer[3];\n        ia2 = iL.toArray(ia2);\n        \n        for(Integer i : ia2){\n            System.out.println(i);\n        }     \n    }','0\n1\n2\n3\n4\n','Collections',1,NULL),(3837,'public static void main(String[] dicks){\n        List<Integer> iL = new ArrayList<Integer>();\n        for(int x=0; x<5; x++){\n                iL.add(x);\n        }\n        Object[] oa = iL.toArray();\n        Integer[] ia2 = new Integer[3];\n        ia2 = iL.toArray(ia2);\n        \n        for(Integer i : ia2){\n            System.out.println(i);\n        }\n        \n        iL.add(100);\n        \n        for(Integer i : ia2)\n            System.out.println(i);\n       \n    }','0\n1\n2\n3\n4\n0\n1\n2\n3\n4','Collections',1,NULL),(3838,' public static void main(String[] dicks){\n        List<Integer> iL = new ArrayList<Integer>();\n        for(int x=0; x<5; x++){\n                iL.add(x);\n        }\n        Integer[] oa = iL.toArray();     \n    }','will not compile, \n\n.toArray() returns an Object[]','Collections',1,NULL),(3839,'class HDTV implements Comparable<HDTV> {\n	private int size;\n	private String brand;\n        private int resolution;\n \n	public HDTV(int size, String brand, int res) {\n		this.size = size;\n		this.brand = brand;\n                this.resolution = res;\n	}\n \n	public int getSize() {\n		return size;\n	}\n        \n        public int getRes() {\n            return resolution;\n        }\n \n	public void setSize(int size) {\n		this.size = size;\n	}\n \n	public String getBrand() {\n		return brand;\n	}\n \n	public void setBrand(String brand) {\n		this.brand = brand;\n	}\n \n	@Override\n	public int compareTo(HDTV tv) {\n \n		if (this.getSize() > tv.getSize())\n			return 1;\n		else if (this.getSize() < tv.getSize())\n			return -1;\n		else\n			return 0;\n	}\n        \n        public String toString(){\n            return brand;\n        }\n}\n\npublic class Hello {\n    public static void main(String[] dicks){\n        compareTVs();\n    }\n    \n     \n    public static void compareTVs() {\n		HDTV tv1 = new HDTV(55, \"Samsung\", 6000);\n		HDTV tv2 = new HDTV(60, \"Sony\", 4500);\n                HDTV tv3 = new HDTV(70, \"MEGATV\", 10000);\n                HDTV tv4 = new HDTV(15,\"kitchenette\", 600);\n\n                HDTV[] array = {tv2, tv1, tv3, tv4 };\n                \n                System.out.println(Arrays.binarySearch(array,new HDTV(700,\"Samsung\",400)));\n                \n	}\n\n}','unpredictable result, the array is not sorted before being searched. ','Collections',1,NULL),(3840,'public static void main(String[] dicks){\n        List<HDTV> tvs = new ArrayList<>();\n        HDTV tv1 = new HDTV(55, \"Samsung\", 6000);\n        HDTV tv2 = new HDTV(60, \"Sony\", 4500);\n        HDTV tv3 = new HDTV(70, \"MEGATV\", 10000);\n        HDTV tv4 = new HDTV(15,\"kitchenette\", 600);\n        tvs.addAll(tv1,tv2,tv3,tv4);\n    }','will not compile \n\nArrayList.addAll doesn\'t work like that, it takes another collection\nthen adds all the elements from one to another. ','Collections',1,NULL),(3841,'public static void main(String[] dicks){\n        List<HDTV> tvs = new ArrayList<>();\n        \n        HDTV tv1 = new HDTV(55, \"Samsung\", 6000);\n        HDTV tv2 = new HDTV(60, \"Sony\", 4500);\n        HDTV tv3 = new HDTV(70, \"MEGATV\", 10000);\n        HDTV tv4 = new HDTV(15,\"kitchenette\", 600);\n        \n        tvs.add(tv1);\n        tvs.add(tv2);\n        tvs.add(tv3);\n        tvs.add(tv4);\n        \n        Iterator<HDTV> i3 = tvs.iterator();\n        \n        while(i3.hasNext()){\n            HDTV t3 = i3.next();\n            System.out.println(t3.getBrand());\n        }\n        \n        \n    }','Samsung\nSony\nMEGATV\nkitchenette\n\nthis shows proper use of an iterator','Collections',1,NULL),(3842,'public static void main(String[] dicks){\n        List<HDTV> tvs = new ArrayList<>();\n        \n        HDTV tv1 = new HDTV(55, \"Samsung\", 6000);\n        HDTV tv2 = new HDTV(60, \"Sony\", 4500);\n        HDTV tv3 = new HDTV(70, \"MEGATV\", 10000);\n        HDTV tv4 = new HDTV(15,\"kitchenette\", 600);\n        \n        tvs.add(tv1);\n        tvs.add(tv2);\n        tvs.add(tv3);\n        tvs.add(tv4);\n        \n        Iterator i3 = tvs.iterator();\n        \n        while(i3.hasNext()){\n            HDTV t3 = i3.next();\n            System.out.println(t3.getBrand());\n        }\n        \n        \n    }','If the iterator isn\'t typed then the elements returned by Iterator will be \nObjects so to make this compile, \n\nyou would have to cast\n\n	(HDTV) i3.next();','Collections',1,NULL),(3843,'  public static void main(String[] dicks){\n        List<HDTV> tvs = new ArrayList<>();\n        \n        HDTV tv1 = new HDTV(55, \"Samsung\", 6000);\n        HDTV tv2 = new HDTV(60, \"Sony\", 4500);\n        HDTV tv3 = new HDTV(70, \"MEGATV\", 10000);\n        HDTV tv4 = new HDTV(15,\"kitchenette\", 600);\n        \n        tvs.add(tv1);\n        tvs.add(tv2);\n        tvs.add(tv3);\n        tvs.add(tv4);\n        \n        HDTV[] tv = new HDTV[5];\n        HDTV[] hv = tvs.toArray(tv); //line 1\n        Object[] tvobjs = tvs.toArray(); //line 2\n        \n   \n    }\n\nwhich line would fail if any ?','none fail both of those are fine. ','Collections',1,NULL),(3844,'public static void main(String[] dicks){\n      Set s = new HashSet();\n      \n        System.out.println(s.add(4));\n        System.out.println(s.add(9));\n        System.out.println(s.add(5));\n        System.out.println(s.add(\"7\"));\n        System.out.println(s.add(4));\n        \n        for(Object o : s)\n            System.out.println(o);\n\n    }','true\ntrue\ntrue\ntrue\nfalse\n4\n5\n7\n9\n\nSets dont allow duplicates and the iteration order is not predictable','Collections',1,NULL),(3845,'public static void main(String[] dicks){\n      Set s = new TreeSet();\n      \n        System.out.println(s.add(4));\n        System.out.println(s.add(9));\n        System.out.println(s.add(5));\n        System.out.println(s.add(\"7\"));\n        System.out.println(s.add(4));\n        \n        for(Object o : s)\n            System.out.println(o);\n\n    }','ClassCastException\n \nTreeSets are sorted and all these elements aren\'t mutually comparabble','Collections',1,NULL),(3846,'class Dog {\n    public String name;\n    public Dog(String n) { name = n; }\n    \n    public String toString(){\n        return name;\n    }\n}\n\npublic class Hello {\n\n    public static void main(String[] dicks){\n      Map<Object,Object> map = new HashMap<>();\n      \n      map.put(\"d1\",new Dog(\"Charly\"));\n      map.put(\"d2\", new Dog(\"dumbfuck\"));\n      \n        System.out.println(map.get(\"d1\"));\n    }\n}','Charly,\n\nhere strings are used as keys and they override hashcode() and equals()\nso it can be used ','Collections',1,NULL),(3847,'class Dog {\n    public String name;\n    public Dog(String n) { name = n; }\n    \n    public String toString(){\n        return name;\n    }\n\n    public static void main(String[] dicks){\n      Map<Object,Object> map = new HashMap<>();\n      \n      map.put(new Dog(\"Bell\"),\"Big brown lab\");\n      map.put(new Dog(\"Sable\"), \"small schiperkee\");\n      \n        System.out.println(map.get(new Dog(\"Bell\")));\n    }\n\n}\n\n','null \n\nthe map cannot find the values bcause the keys dont have equals or hashcode methods.','Collections',1,NULL),(3848,'class Dog {\n    enum Pets{DOG, CAT, SNAKE};\n    public String name;\n    public Dog(String n) { name = n; }\n    \n    public String toString(){\n        return name;\n    }\n\npublic static void main(String[] dicks){\n      \n      Map<Object,Object> map = new HashMap<>();\n      \n      map.put(new Dog(\"Bell\"),\"Big brown lab\");\n      map.put(new Dog(\"Sable\"), \"small schiperkee\");\n      map.put(Pets.CAT, new Dog(\"catdog\"));\n      map.put(\"Dog\", Pets.DOG);\n      \n        System.out.println(map.get(new Dog(\"Bell\")));\n        System.out.println(map.get(Pets.CAT));\n        System.out.println(map.get(\"Dog\"));\n    }\n}','null\ncatdog\nDOG','Collections',1,NULL),(3849,'public int hashCode() { return name.length(); }\npublic int hashCode() { return 4; }\n \nwhich will be faster ?\n','both are legal, the first will be slightly better\n\nthe more unique a hashcode the faste retrieval will be. ','Collections',1,NULL),(3850,'TreeSet<Integer> tree = new TreeSet<Integer>();\ntree.add(12);\ntree.add(63);\ntree.add(34);\ntree.add(45);\n \nIterator<Integer> iterator = tree.iterator();\nSystem.out.print(\"Tree set data: \");\nwhile (iterator.hasNext()) {\n    System.out.print(iterator.next() + \" \");\n}','12\n34\n45\n63','Collections',1,NULL),(3851,'public class Hello {\n    \n    \n    public static void main(String[] dicks){\n      \n      List<Double> grades = new ArrayList<>();\n      grades.addAll(Arrays.asList( new Double[]{ 1.8, 4.6, 2.3, 8.9, 2.2 } ));\n      \n      Collections.sort(grades,new CusSort());\n      \n      System.out.println(grades);\n      \n        System.out.println(Collections.binarySearch(grades,4.2,new CusSort()));\n\n    }\n}\n    \n   class CusSort implements Comparator<Double> {\n       public int compare(Double d1, Double d2){\n           return d1.intValue() == d2.intValue() ? d2.compareTo(d1) : d1.compareTo(d2);\n           \n       }\n   }','[1.8, 2.3, 2.2, 4.6, 8.9]\n-5\n\nthis comparator sorts in ascending order uless they have the same integer\nvalue','Collections',1,NULL),(3852,'public class Hello {\n    \n    \n    public static void main(String[] dicks){\n      \n     TreeMap<String, String> map = new TreeMap<>();\n     map.put(\"a\",\"ant\"); map.put(\"b\",\"buffalo\"); map.put(\"h\",\"horse\");\n     \n     SortedMap<String, String> submap;\n     submap = map.subMap(\"b\",\"g\");\n     \n        System.out.println(map+\" \"+submap);\n        \n        map.put(\"b\",\"bat\");\n        \n        submap.put(\"f\",\"fish\");\n        \n        map.put(\"R\", \"raccoon\");\n        // submap.put(\"p\",\"pig\");\n        \n        System.out.println(map+\" \"+submap);\n    }\n}','{a=ant, b=buffalo, h=horse} {b=buffalo}\n{R=raccoon, a=ant, b=bat, f=fish, h=horse} {b=bat, f=fish}','Collections',1,NULL),(3853,'public class Hello {\n    \n    \n    public static void main(String[] dicks){\n      \n     TreeMap<String, String> map = new TreeMap<>();\n     map.put(\"a\",\"ant\"); map.put(\"b\",\"buffalo\"); map.put(\"h\",\"horse\");\n     \n     SortedMap<String, String> submap;\n     submap = map.subMap(\"b\",\"g\");\n     \n        System.out.println(map+\" \"+submap);\n        \n        map.put(\"b\",\"bat\");\n        \n        submap.put(\"f\",\"fish\");\n        \n        map.put(\"R\", \"raccoon\");\n        submap.put(\"p\",\"pig\");\n        \n        System.out.println(map+\" \"+submap);\n    }\n}','IllegalArgumnetException\n\np is out of range of the submap as first established with subMap(b g);\n\n','Collections',1,NULL),(3854,'public class Hello {\n    \n    \n    public static void main(String[] dicks){\n      \n     TreeMap<String, String> map = new TreeMap<>();\n     map.put(\"a\",\"ant\"); map.put(\"b\",\"buffalo\"); map.put(\"h\",\"horse\"); map.put(\"j\",\"jackle\");\n     \n     TreeMap<String, String> submap;\n     submap = map.subMap(\"b\",\"g\");\n     \n     System.out.println(map+\" \"+submap);\n\n    }\n}','will not compile, submap returns a SortedMap.','Collections',1,NULL),(3855,'class TreeMap<k,v> extends  _____________\n implements  ____________','AbstractMap<k,V>\nNavigableMap<K,V>','Collections',1,NULL),(3856,'public class Hello {\n    \n    \n    public static void main(String[] dicks){\n      \n     TreeMap<Animal, Integer> map = new TreeMap<>();\n     \n     map.put(new Animal(5,\"Ant\"), 6); map.put(new Animal(3,\"Beee\"),9); map.put(new Animal(25,\"Dog\"),7); map.put(new Animal(20,\"muskrat\"),20);\n     \n     System.out.println(map);\n     \n \n\n    }\n}\n\nclass sortAnimalsAlphabetically implements Comparator<Animal> {\n\n    @Override\n    public int compare(Animal o1, Animal o2) {\n        return o1.getName().compareTo(o2.getName());\n    }\n    \n}\n\nclass Animal implements Comparable<Animal> {\n    private Integer size;\n    private String name;\n    \n    public Animal(int x, String y){\n        size = x;\n        name = y;\n    }\n\n    public int getSize() {\n        return size;\n    }\n\n    public String getName() {\n        return name;\n    }\n    public int compareTo(Animal o){\n        return size.compareTo(o.getSize());\n        \n    }\n    \n    public String toString(){\n        return name;\n    }\n}','{Beee=9, Ant=6, muskrat=20, Dog=7}\n\nwithout a provided comparator TreeMap sorts using Animals comparable\n\nwhich is to rank by size','Collections',1,NULL),(3857,'public class Hello {\n    \n    \n    public static void main(String[] dicks){\n      \n     TreeMap<Animal, Integer> map = new TreeMap<>(new sortAnimalsAlphabetically());\n     \n     map.put(new Animal(5,\"Ant\"), 6); map.put(new Animal(3,\"Beee\"),9); map.put(new Animal(25,\"Dog\"),7); map.put(new Animal(20,\"muskrat\"),20);\n     \n     System.out.println(map);\n     \n \n\n    }\n}\n\nclass sortAnimalsAlphabetically implements Comparator<Animal> {\n\n    @Override\n    public int compare(Animal o1, Animal o2) {\n        return o1.getName().compareTo(o2.getName());\n    }\n    \n}\n\nclass Animal implements Comparable<Animal> {\n    private Integer size;\n    private String name;\n    \n    public Animal(int x, String y){\n        size = x;\n        name = y;\n    }\n\n    public int getSize() {\n        return size;\n    }\n\n    public String getName() {\n        return name;\n    }\n    public int compareTo(Animal o){\n        return size.compareTo(o.getSize());\n        \n    }\n    \n    public String toString(){\n        return name;\n    }\n}','{Ant=6, Beee=9, Dog=7, muskrat=20}\n\nsort using comparator','Collections',1,NULL),(3858,'public class Hello {\n    \n    \n    public static void main(String[] dicks){\n      \n     TreeMap<Animal, Integer> map = new TreeMap<>();\n     \n     map.put(new Animal(2,\"Ant\"), 6); map.put(new Animal(3,\"Beee\"),9); map.put(new Animal(15,\"Dog\"),7); map.put(new Animal(12,\"muskrat\"),20);\n     \n     SortedMap<Animal,Integer> copymap = map.subMap(map.firstKey(), map.lastKey());\n     \n     copymap.put(new Animal(50,\"Rhino\"), 1);\n     map.put(new Animal(30,\"Wolf\"), 4);\n     System.out.println(map);\n     \n     SortedMap<Animal,Integer> copy1map = copymap.subMap(new Animal(4,\"Worm\"), new Animal(25,\"Dolphin\"));\n     \n     System.out.println(copy1map);\n\n    }\n}\n\nclass sortAnimalsAlphabetically implements Comparator<Animal> {\n\n    @Override\n    public int compare(Animal o1, Animal o2) {\n        return o1.getName().compareTo(o2.getName());\n    }\n    \n}\n\nclass Animal implements Comparable<Animal> {\n    private Integer size;\n    private String name;\n    \n    public Animal(int x, String y){\n        size = x;\n        name = y;\n    }\n\n    public int getSize() {\n        return size;\n    }\n\n    public String getName() {\n        return name;\n    }\n    public int compareTo(Animal o){\n        return size.compareTo(o.getSize());\n        \n    }\n    \n    public String toString(){\n        return name;\n    }\n}','IllegalArgumentException key out of range\n\nyour trying to add a rhino - 50 - to the copied map when the biggest element\nin the orgiinal was a Dog at 15 !','Collections',1,NULL),(3859,'public class Hello {\n    \n    \n    public static void main(String[] dicks){\n      \n     TreeMap<Animal, Integer> map = new TreeMap<>();\n     \n     map.put(new Animal(2,\"Ant\"), 6); map.put(new Animal(3,\"Beee\"),9); map.put(new Animal(15,\"Dog\"),7); map.put(new Animal(12,\"muskrat\"),20);\n     \n     SortedMap<Animal,Integer> copymap = map.subMap(map.firstKey(), map.lastKey());\n     \n     map.put(new Animal(50,\"Rhino\"), 1);\n     map.put(new Animal(30,\"Wolf\"), 4);\n     System.out.println(map);\n     \n     SortedMap<Animal,Integer> copy1map = copymap.subMap(new Animal(1,\"Tic\"), new Animal(25,\"Dolphin\"));\n     \n     //System.out.println(copy1map);\n\n    }\n}\n\nclass sortAnimalsAlphabetically implements Comparator<Animal> {\n\n    @Override\n    public int compare(Animal o1, Animal o2) {\n        return o1.getName().compareTo(o2.getName());\n    }\n    \n}\n\nclass Animal implements Comparable<Animal> {\n    private Integer size;\n    private String name;\n    \n    public Animal(int x, String y){\n        size = x;\n        name = y;\n    }\n\n    public int getSize() {\n        return size;\n    }\n\n    public String getName() {\n        return name;\n    }\n    public int compareTo(Animal o){\n        return size.compareTo(o.getSize());\n        \n    }\n    \n    public String toString(){\n        return name;\n    }\n}\n','IllegalArgumentException, fromKey out of range\n\nthe tic your trying to add is too small previously the smallest elemtn was\nan Ant at 2','Collections',1,NULL),(3860,'public class Hello {\n    \n    \n    public static void main(String[] dicks){\n      \n     TreeMap<Animal, Integer> map = new TreeMap<>();\n     \n     map.put(new Animal(2,\"Ant\"), 6); map.put(new Animal(3,\"Beee\"),9); map.put(new Animal(15,\"Dog\"),7); map.put(new Animal(12,\"muskrat\"),20);\n     \n     SortedMap<Animal,Integer> copymap = map.subMap(map.firstKey(), map.lastKey());\n        System.out.println(map);\n        System.out.println(copymap);\n     \n     map.put(new Animal(50,\"Rhino\"), 1);\n     map.put(new Animal(30,\"Wolf\"), 4);\n     System.out.println(map);\n     \n     copymap = map.subMap(map.firstKey(), map.lastKey());\n     \n        System.out.println(copymap);\n     \n     //SortedMap<Animal,Integer> copy1map = copymap.subMap(new Animal(7,\"Snake\"), new Animal(40,\"Bear\"));\n     //System.out.println(copy1map);\n\n    }\n}','{Ant=6, Beee=9, muskrat=20, Dog=7}\n{Ant=6, Beee=9, muskrat=20}\n{Ant=6, Beee=9, muskrat=20, Dog=7, Wolf=4, Rhino=1}\n{Ant=6, Beee=9, muskrat=20, Dog=7, Wolf=4}\n\npublic SortedMap<K,V> subMap(K fromKey,\n                    K toKey)\n\nkeys range from fromKey, inclusive, to toKey, exclusive. (If fromKey and toKey are equal, the returned map is empty.)\n The returned map is backed by this map, so changes \nin the returned map are reflected in this map, and vice-versa.\n\nTHE TO KEY IS EXCLUSIVE ','Collections',1,NULL),(3861,'public class Hello {\n  public static void main(String[] dicks){\n      \n     TreeMap<Animal, Integer> map = new TreeMap<>();\n     \n     map.put(new Animal(2,\"Ant\"), 6); map.put(new Animal(3,\"Beee\"),9); map.put(new Animal(15,\"Dog\"),7); map.put(new Animal(12,\"muskrat\"),20);\n     \n     SortedMap<Animal,Integer> copymap = map.subMap(map.firstKey(),true, map.lastKey(),true);\n        System.out.println(map);\n        System.out.println(copymap);\n    }\n}\n\nclass Animal implements Comparable<Animal>{\n    private int size;\n    private String name;\n    public Animal(int s, String n){\n        size = s;\n        name = n;\n        \n    }\n    public int getSize(){\n        return size;\n    }\n    public int compareTo(Animal a){\n        int asize = a.getSize();\n        int bsize = this.size;\n        \n        if(asize < bsize)\n            return 1;\n        else if(asize == bsize)\n            return 0;\n        else\n            return -1;\n  \n    }\n    \n    public String toString(){\n        return name;\n    }\n}','{Ant=6, Beee=9, muskrat=20, Dog=7}\n{Ant=6, Beee=9, muskrat=20, Dog=7}\n\noverloaded version of submap indicates if that arg is inclusive \n\nThe map is sorted according to the natural ordering of its keys, or by a Comparator provided at map creation time\nNote that the ordering maintained by a tree map, like any sorted map, and whether or not an explicit comparator is provided, \nmust be consistent with equals if this sorted map is to correctly implement the Map interface. (See Comparable or Comparator for a precise definition of consistent with equals.) \nThis is so because the Map interface is defined in terms of the equals operation, but a sorted map performs all key comparisons using its compareTo (or compare) method, so two keys that are deemed equal by this method are, \nfrom the standpoint of the sorted map, equal.  ','Collections',1,NULL),(3862,'public class Hello {\n    \n    \n    public static void main(String[] dicks){\n      \n     TreeMap<Animal, Integer> map = new TreeMap<>();\n     \n     map.put(new Animal(2,\"Ant\"), 6); map.put(new Animal(3,\"Beee\"),9); map.put(new Animal(15,\"Dog\"),7); map.put(new Animal(12,\"muskrat\"),20);\n     \n     SortedMap<Animal,Integer> copymap = map.subMap(map.firstKey(),false, map.lastKey(),true);\n        System.out.println(map);\n        System.out.println(copymap);\n    }\n}','{Ant=6, Beee=9, muskrat=20, Dog=7}\n{Beee=9, muskrat=20, Dog=7}','Collections',1,NULL),(3863,'public class Hello {\n    \n    \n    public static void main(String[] dicks){\n      \n     TreeMap<Animal, Integer> map = new TreeMap<>();\n     \n     map.put(new Animal(2,\"Ant\"), 6); map.put(new Animal(3,\"Beee\"),9); map.put(new Animal(15,\"Dog\"),7); map.put(new Animal(12,\"muskrat\"),20);\n     \n     SortedMap<Animal,Integer> copymap = map.subMap(map.firstKey(),false, map.lastKey(),false);\n        System.out.println(map);\n        System.out.println(copymap);\n    }\n}','{Ant=6, Beee=9, muskrat=20, Dog=7}\n{Beee=9, muskrat=20}','Collections',1,NULL),(3864,'When using multi-catch, the catch block parameter is final and cannot \nhave a new value assigned to it in the catch block.\n\ntry{\n\n} catch(SQLException | IOException e){\n	\n	e = new IOException();\n}\n\n// this shows why thats illegal, your not sure which exception type \nwill come through.\n//updated 2','try{\n\n}catch(Exception1 | Exception2 e) {\n\n	e = new Exception1();\n}\n\nTHIS WOULD FAIL COMPILATION\n\n','Exceptions',1,NULL),(3865,'To compile old code that may use \'assert\' as an identifier, \nadd 1.3. This will tell the compiler to treat the word \'assert\' as an identifier.\n\n1.4 will use \'assert\' as a keyword	','javac -source 1.3 OldCode.java\n\njavac -source 1.4 NewCode.java','Exceptions',1,NULL),(3866,'Disable assertions at runtime		','java -da com.maxbisesi.Test\n\njava -disableassertions com.maxbisesi.Test','Exceptions',1,NULL),(3867,'Dont use assert expressions that can cause side effects...','This is a bad idea...\n\npublic void doStuff(){\n	assert (modifyThings());\n	//continue\n}\n\npublic boolean modifyThings() {\n	y = x++;\n	return true;\n}','Exceptions',1,NULL),(3868,'You cant use the variable name multiple times in a multi-catch. \nThe following wont compile...\n\ncatch(Exception1 e1 | Exception2 e2){\n\n}','Fails compilation','Exceptions',1,NULL),(3869,'With Multi catch order does NOT matter...		','the following are equivalent:\n\ncatch(SQLException | IOException e)\n\ncatch(IOException | SQLException e)','Exceptions',1,NULL),(3870,'With Multi-Catch you have to make sure a given excpetion can only\nmatch one type...\n\ncatch(IOException | SQLException e)\n\nthese two are different types.','The following will not compile...\n\ncatch(FileNotFoundException | IOException e)\n\nsince FILNOTFOUND is a subclass of IOException we could have just\nwrtten that in the first place..\n\ncatch(IOException)','Exceptions',1,NULL),(3871,'Legal or illegal...\n\ntry {\n	//do something\n} catch(IOException e){\n	\n	e = new IOException();\n}','This is legal but it is not good practice. It is illegal to reasign the value\nof a multi-catch parameter. \n\ntry {\n	\n} catch(SQLException | IOException e){\n\n	e = new IOException();\n}\n\n^^WILL NOT COMPILE\n','Exceptions',1,NULL),(3872,'public void couldthrow() throws SQLException, IOException { }\n\npublic void rethrow() throws SQLException, IOException {\n	try{\n		couldthrow();\n	} catch(Exception e){ \n		e = new IOException();\n		throw e;\n	}\n}	','Will not compile, it is legal to reassign the parameter here. But it is illegal\nto throw e. The method declares that it throws SQL and IO so throwing a \ngeneral exception is unreported. \n\nif the signature was throws Exception then everything would be fine\n\nException as a genreal','Exceptions',1,NULL),(3873,'legal or illegal\n\ntry {\n\n}','Illegal, regular trys have to have a catch or a finally\n\ntry-with can be used by themselves','Exceptions',1,NULL),(3874,'try(String s = \"hi\") {}','does not compile. \nto be declared in a try with the method has to implement auto closeable or\ncloseable','Exceptions',1,NULL),(3875,'Path p = Paths.get(\"/home/maxbisesi\");\n      try(BufferedReader br = new BufferedReader(new FileReader(p.toFile())), BufferedWriter bw = new BufferedWriter(new FileWriter(p.toFile()))){\n          \n      } catch(IOException e){\n          \n      }','will not compile,\nThe declared resources use a commma , not a semi colon ;\n\nshould be:\n\ntry(Resource r = new Resource(); ...','Exceptions',1,NULL),(3876,'Class A implements AutoCloseable { \n	public void close() throws Exception {}\n}	','ok, AutoCloseable interface allows throwing any Exception','Exceptions',1,NULL),(3877,'class B implements AutoCloseable { public void close() {}}\nclass C implements AutoCloseable { public void close() throws IOException {}}','ok sublcasses or implenting methods can throw a subclass of excpetion\nor none at all.\n\nAutoCloseable\'s  close throws an Exception','Exceptions',1,NULL),(3878,'class D implements Closeable { public void close() throws Exception{}}','ILLEGAL- Closeable only allows IOExceptions or subclasses','Exceptions',1,NULL),(3879,'class E implements Closeable { public void close() throws IOException {}}','ok Closeable allows throwing IOExceptions\n\nvoid close() throws IOException','Collections',1,NULL),(3880,'idempotent','you can call close() multiple times all day and nothing will happen the second time and beyond. \nwill not blow up. ','Exceptions',1,NULL),(3881,'AutoCloseable\'s close() is idempotent	','nothing bad will happen if you call close() more than one time. ','Exceptions',1,NULL),(3882,'Closeable\'s close() is not idempotent','might blow up if called more than once','Exceptions',1,NULL),(3883,'class A implements AutoCloseable {\n	public void close() {\n		sout(\"A\");\n	}\n}\n\nclass B implements AutoCloseable {\n	public void close() {\n		sout(\"B\");\n	}\n}\n\nclass C {\n	psvm(sa){\n		try(A a = new A(); B b = new B()){\n			throw new RuntimeException();\n		} catch(EXception e) {\n			sout(\"catch\");\n		}\n	}\n}\n\nwhat does it print?','B\nA\ncatch\n\nResources are closed in reverse order from what they are declared.','Exceptions',1,NULL),(3884,'public class Suppressed {\n	psvm(sa) {\n		try(One one = new One()) {\n			throw new exception(\"try\");\n		} catch (Exception e) {\n			sout(e.getMessage());\n			\n			for(Throwable t : e.getSuppressed()){\n				sout(\"suppressed:\" + t);\n		}	}\n	}\n}\n\nclass One implements AutoCloseable {\n	public void close() throws IOException {\n		throw new IOException(\"Closing\");\n	}\n}','Try\nsuppressed: java.io.IOException: Closing\n\nafter the exception in the try block gets thrown on line 4, the try with \nresources still calls close() and the catch block catches one \nof the exceptions.\n\nJava adds any excpeittions thrown by close() methods to a suppressed array in the main excpetion. \n\nif no other exception happens in the try block the exceptioon thrown in\nclose() gets treated as the main excpetion  for the catch block. ','Exceptions',1,NULL),(3885,'If the catch or Finally block throws an exception NO SUPPRESSION HAPPENS\nthe last exception thrown gets sent to the caller rather than the one from the \ntry- just like before try with resources','got it ','Exceptions',1,NULL),(3886,'class Bad implements AutoCloseable {\n	String name;\n	Bad(String n) { name = n; }\n	public void close() throws IOException {\n		throw new IOException(\"Closing -\" +name);\n	}\n}\n\npublic class Suppressed {\n	public static void main(SA) {\n		try(Bad b1 = new Bad(\"1\"); Bad b2 = new Bad(\"2\")) {\n			\n		} catch(Exception e) {\n			sout(e.getMessage());\n			for(Throwable t : e.getSuppressed()) {\n				sout(\"suppressed:\" + t);\n			}\n		}\n	}\n}','Closing - 2\nsuppressed: java.io.IOException: Closing - 1\n\nresources close in the opposite order they are declared','Exceptions',1,NULL),(3887,'Stream classes are used to read and write bytes, and Readers and Writers\nare used to read write Characters....','Since all file IO on the exam is related to characters, if you see a Stream\nlike DataOutputStream the the question is probably about serialization\nor something unrelated to the actual IO objective','Input/Output',1,NULL),(3888,'psvm(SA) {\n	try {\n		boolean newFile = false;\n		File file = new File(\"fiileWrite1.txt\");\n		sout(file.exists());\n		newFile = file.createNewFile());\n		sout(newFile);\n		sout(file.exists());\n	} catch (IOException e) {}\n}	','// first time\nfalse\ntrue \ntrue\n\n//second time\ntrue\nfalse\ntrue\n\nexists returns false the first time becasue the file was created as an object\nbut not yet as a physical file. ','Input/Output',1,NULL),(3889,'public static void main(String[] args){\n        File newFile = new File(\"/home/maxbisesi/Public/textFile5.txt\");\n        try{\n            System.out.println(newFile.exists());\n            newFile.createNewFile();\n            System.out.println(newFile.exists());\n        } catch(IOException e){\n            \n        }   \n    }','This method returns true if it can find the actual file\n\nfalse\ntrue\n\n	the first time it is run','Input/Output',1,NULL),(3890,'File method: \ntry {\n	createNewFile();\n} catch(IOException e) { } ','true if the named file does not exist and was successfully created; false if the named file already exists\n','Input/Output',1,NULL),(3891,'File class Constructors	','File(File parent, String child)\nCreates a new File instance from a parent abstract pathname and a child pathname string.\n\nFile(String pathname)\nCreates a new File instance by converting the given pathname string into an abstract pathname.\n\nFile(String parent, String child)\nCreates a new File instance from a parent pathname string and a child pathname string.','Input/Output',1,NULL),(3892,'File class key methods ','createNewFile()\ndelete()\nexists()\nisDirectory()\nisfile()\nlist()\nmkdir()\nrenameTo()','Input/Output',1,NULL),(3893,'FileWriter class Constructors	','FileWriter(File file)\n\nFileWriter(String filename)','Input/Output',1,NULL),(3894,'FileWriter class key methods 	','close()\nflush()\nwrite()','Input/Output',1,NULL),(3895,'BufferedWriter class constructors	','BufferedWriter(Writer out)','Input/Output',1,NULL),(3896,'BufferedWriter key methods	','close() \nflush()\nnewLine()\nwrite()','Input/Output',1,NULL),(3897,'PrintWriter constructors','PrintWriter(File file)\nCreates a new PrintWriter, without automatic line flushing, with the specified file.\n\nPrintWriter(File file, String csn)\nCreates a new PrintWriter, without automatic line flushing, with the specified file and charset.\n\nPrintWriter(OutputStream out)\nCreates a new PrintWriter, without automatic line flushing, from an existing OutputStream.\n\nPrintWriter(OutputStream out, boolean autoFlush)\nCreates a new PrintWriter from an existing OutputStream.\n\nPrintWriter(String fileName)\nCreates a new PrintWriter, without automatic line flushing, with the specified file name.\n\nPrintWriter(String fileName, String csn)\nCreates a new PrintWriter, without automatic line flushing, with the specified file name and charset.\n\nPrintWriter(Writer out)\nCreates a new PrintWriter, without automatic line flushing.\n\nPrintWriter(Writer out, boolean autoFlush)\nCreates a new PrintWriter.','Input/Output',1,NULL),(3898,'FileReader key methods 	','read()','Input/Output',1,NULL),(3899,'BufferedReader constructors	','Reader','Input/Output',1,NULL),(3900,'BufferedReader key methods','read()\nreadLine()','Input/Output',1,NULL),(3901,'File file = new file(\"filewriter2.txt\");\nFileWriter fw = new fileWriter(file);\n\nPrintWriter pw = new PrintWriter (fw);\n\npw.println(\"hello\");\npw.println(\"world\"));','filewrite2.txt would contain the text:\n\nhello\nworld','Input/Output',1,NULL),(3902,'File file = new File(\"filewrite2.txt\");\nFileReader fr = new FileReader(file);\nBufferedReader br = new BufferedReader(fr);\n\nString data = br.readLine();','','Input/Output',1,NULL),(3903,'File file = new File(\"foo\");\n\nif \"foo\" does not exist no actual file is created.\n\nif \"foo\" does exists, the new File object refers to the existing file. ','got it ','Input/Output',1,NULL),(3904,'readers dont have flush methods','io','Input/Output',1,NULL),(3905,'Console.readPassword() returns...','a char[]','Input/Output',1,NULL),(3906,'Path Method:\n\nPath getName(int index)','Returns the path element corresponding to the specified index.\n\nthe 0th element is the one closest to the root.','Input/Output',1,NULL),(3907,'Path Method:\n\nString getFileName()','returns the filename or the last element of the sequence of name elements\n\nor..\n\nReturns the name of the file or directory denoted by this path as a Path object. The file name is the farthest element from the root in the directory hierarchy.','Input/Output',1,NULL),(3908,'public class Hello {\n    public static void main(String[] dicks) throws IOException{\n      Path src = Paths.get(\"/home/maxbisesi/Documents/copy.txt\");\n\n      System.out.println(src.getNameCount());\n      \n    }\n\n}','4','Input/Output',1,NULL),(3909,'\npublic class Hello {\n    public static void main(String[] dicks) throws IOException{\n      Path src = Paths.get(\"/home/maxbisesi/Documents/copy.txt\");\n      Path srcParent = src.getParent();\n      System.out.println(srcParent);\n      \n    }\n\n}','\n/home/maxbisesi/Documents','Input/Output',1,NULL),(3910,'Path Method:\n\nPath getRoot()		','retunrs the root of thsi path, or null if this path does not have a root.','Input/Output',1,NULL),(3911,'Path Method:\n\nPath subpath(int beginindex, int endIndex)','returns a ssubsequence of this path NOT INCLUDING ROOT. \n\nbeginning INCLUSIVE\n\nending EXCLUSIVE','Input/Output',1,NULL),(3912,'Path extends from Iterable<Path>	','that means it can be iterated through in a for loop!','Input/Output',1,NULL),(3913,'int spaces = 1;\nPath myPath = Paths.get(\"tmp\", \"dir1\", \"dir2\", \"dir3\", \"file.txt\");\n\nfor(Path subpath : myPath){\n	sout( subpath + \"//\" );\n}','tmp/dir1/dir2/dir3/file.txt','Input/Output',1,NULL),(3914,'Path method:\n\nPath normalize()	','returns a path that is this path with redundant name elements eliminated\n\n. can be ignored\n\n.. followed by a directory can be removed as redundant','Input/Output',1,NULL),(3915,'Paths.get(\"/a/./b/./c\").normalize();\n','/a/b/c','Input/Output',1,NULL),(3916,'Paths.get(\".classpath\").normalize();','.classpath','Input/Output',1,NULL),(3917,'Paths.get(\"/a/b/c/..\").normalize()','/a/b','Input/Output',1,NULL),(3918,'Paths.get(\"../a/b/c\").normalize()','../a/b/c\n\nThe two dots do say go up one directory, but since there is\'nt a directory\nbefore it Path cant simplify it.','Input/Output',1,NULL),(3919,'Path dir = Paths.get(\"/home/java\");\nPath file = Paths.get(\"models/Model.pdf\");\nPath result = dir.resolve(file);\n\nsout( result );\n	','/home/java/models/Model.pdf\n\npath1.resolve(path2) should be read as \"resolve path2 within path1s directory\n','Input/Output',1,NULL),(3920,'class Hello {\n    public static void main(String[] args) {     \n        Path p1 = Paths.get(\"/home/max/tmp\");\n        Path p2 = Paths.get(\"/google\");\n        System.out.println(p1.resolve(p2));\n        \n    }\n\n}','/google\n\nResolve the given path against this path.\n\nIf the other parameter is an absolute path then this method trivially returns other.\n If other is an empty path then this method trivially returns this path.\n Otherwise this method considers this path to be a directory and resolves\n the given path against this path. In the simplest case, the given path does not have a root component, \nin which case this method joins the given path to this path \nand returns a resulting path that ends with the given path.','Input/Output',1,NULL),(3921,'Path absolute = Paths.get(\"/home/java\");\nPath relative = Paths.get(\"dir\");\nPath file = Paths.get(\"Model.pdf\");\n\nsout( absolute.resolve(relative) );\nsout( asolute.resolve(file) );\nsout( relative.resolve(file) );\nsout( relative.resolve(absolute) ); // BAD\nsout( file.resolve(absolute) ); //BAD\nsout( file.resolve(relative) ); //BAD','/home/java/dir\n/home/java/Model.pdf\n/dir/Model.pdf\n/home/java\n/home/java\nModel.pdf/dir\n\nThe first three do what you would exprect. They add the paramenter\nto resolve to the provided path object. The fourth and fifth try to resolve\nan absolute path within the context of something else. The problem is \nthat an aboluste path doesnt\'t depend on other directories it is absolute.\n','Input/Output',1,NULL),(3922,'Be carefule with questions that come in two flavors. one with a Path parameter\nand the other with a String parameter such as resolve()...\n\nPath path = Paths.get(\"/usr/bin/zip\");\npath.resolve(null);','Thhe compilere cannot decide here so it will not compile','Input/Output',1,NULL),(3923,'Which Path method is used to combine two paths and set one in another?','resolve()','Input/Output',1,NULL),(3924,'Which Path method is used to describe how to gret from one path to \nthe other	','relativize()','Input/Output',1,NULL),(3925,'Path dir = Paths.get(\"/home/java\");\nPath music = Paths.get(\"/home/java/country/Swift.mp3\");\nPath mp3 = dir.reltivize(music);\n\nsout( mp3 );','country/Swift.mp3\n\n\njava recognized that the /home/java part is the same and returned a path of\njust the remainder.\n\npath1.relativize(path2) should be read as \"give me a path shows how to get from\npath1 to path2\"','Input/Output',1,NULL),(3926,'\"give me a path shows how to get from\npath1 to path2\"','.relativize()','Input/Output',1,NULL),(3927,'Path absolute1 = Paths.get(\"/home/java\");\nPath absolute2 = Paths.get(\"/usr/local\");\nPath absolute3 = Paths.get(\"/home/java/temp/music.mp3\");\nPath relative1 = Paths.get(\"temp\");\nPath relative2 = Paths.get(\"temp/music.pdf\");\n\nsout( absolute1.relativize(absolute3) );\nsout( absolute3.relativize(absolute1) );\nsout( absolute1.relativize(absolute2) );\nsout( relative1.relativize(relative2) );\nsout( absolute1.relativize(relative1) ); //BAD','temp/music.mp3\n\n../..\n\n../../usr/local\n\nmusic.pdf\n\nExcpetion in main thread IllegalArgumentExcpetion\n\n	','Input/Output',1,NULL),(3928,'relativeize()','Path relativize(Path other)\n\nConstructs a relative path between this path and a given path.\n\nRelativization is the inverse of resolution. This method attempts to construct a relative path that when resolved against this path, yields a path that locates the same file as the given path. For example, on UNIX, if this path is \"/a/b\" and the given path is \"/a/b/c/d\" then the resulting relative path would be \"c/d\". Where this path and the given path do not have a root component, then a relative path can be constructed. A relative path cannot be constructed if only one of the paths have a root component. Where both paths have a root component then it is implementation dependent if a relative path can be constructed. If this path and the given path are equal then an empty path is returned.\n\nFor any two normalized paths p and q, where q does not have a root component,\n\n    p.relativize(p.resolve(q)).equals(q) \n\nWhen symbolic links are supported, then whether the resulting path, when resolved against this path, yields a path that can be used to locate the same file as other is implementation dependent. For example, if this path is \"/a/b\" and the given path is \"/a/x\" then the resulting relative path may be \"../x\". If \"b\" is a symbolic link then is implementation dependent if \"a/b/../x\" would locate the same file as \"/a/x\".\n\nParameters:\n    other - the path to relativize against this path\nReturns:\n    the resulting relative path, or an empty path if both paths are equal\nThrows:\n    IllegalArgumentException - if other is not a Path that can be relativized against this path','Input/Output',1,NULL),(3929,'When creating a Path you can seperate out folder and filename as much\nor as little as you want. When you don\'t begin with a root the Path\nis considered a relative path, which means Java looks from the current\ndirectory.\n\nPath p6 = Paths.get(\"tmp\", \"file1.txt\"); // relative path\n\n/ (root)\n	| - - tmp\n		| - file1.txt\n		| - tmp\n			| - file1.txt\n','If this program is run from the root, it is the one in /tmp/file1.txt\n\nif it is run from /tmp it is the one in /tmp/tmp/file1.txt\n\nif the program is run from anywhere else the path refers to a file that doesn\nnot exist. ','Input/Output',1,NULL),(3930,'With IO a file doesn\'t exists just because you create a File object.\nIt is the same with Path objects\n\nPath path = Paths.get(\"fileWrite1.txt\");\nsout(Files.exists(path)); // false\nFiles.createFile(path); \nsout(Files.exists(path)); // true','got it ','Input/Output',1,NULL),(3931,'create directories one at a time or all at once	......\n\nTHE directory must exist by the time the file is created','Path path1 = Paths.get(\"/java/source\");\nPath path2 = Paths.get(\"/java/source/directory\");\nPath file = Paths.get(\"/java/source/directory/Program.java\");\nFiles.createDirectory(path1);\nFiles.createDirectory(path2);\nFiles.createFile(file);\n\n// all at once\n\nFiles.createDirectories(path2);\nFile.createFile(file);','Input/Output',1,NULL),(3932,'Date januaryFirst = new GregorianCalendar(20q3, Calendar.January, 1).getTime();\n\nFile file = new File(\"c:/temp/file\");\nfile.createNewFile();\nfile.setLastModified(januaryFirst.getTime());\nfile.setLastModified(januaryFirst.getTime());\nsout(file.lastModified());\nfile.delete();','13570164000000','Input/Output',1,NULL),(3933,'Path path = Paths.get(\"c:/temp/file2\");\nDate januaryFirst = new GregorianCalendar(2013,Calendar.JANUARY, 1).getTime();\nFiles.createFile(path);\nFileTime fileTime = FileTime.fromMillis(januaryFirst.getTime());\nFiles.setLastModifiedTime(path,fileTime);\nsout(Files.getLastModifiedTime(path));\nFiles.delete((path);','2013-01-01T05','Input/Output',1,NULL),(3934,'How would you get the last modified date/time of a Path and a File?\n\nFile file = new file(\"test\");\nPath path = Paths.get(\"test\");','\nfile.lastModified();\n\nFiles.getLastModifiedTime(path);','Input/Output',1,NULL),(3935,'public class Hello {\n    static Thread max ,angela;\n    public static void main(String[] args){\n        angela = new Thread() {\n            public void run(){\n                System.out.println(\"A\");\n                try {\n                    max.sleep(1000);\n                } catch(Exception e){\n                    System.out.println(\"B\");\n                }\n                System.out.println(\"C\");\n                \n            }\n        };\n        \n        max = new Thread() {\n            public void run(){\n                System.out.println(\"D\");\n                try {\n                    angela.wait(); \n                } catch(Exception e){\n                    System.out.println(\"E\");\n                }\n                \n                System.out.println(\"F\");\n            }\n        };\n        \n        max.start();\n        angela.start();   \n    }\n} ','A C D E F \n\nin an undeterminable order, although thread angela uses the max reference\n.Sleep is static and therefore she puts herself to sleep. This is why\nreferences shouldn\'t be used for static methods. \n\nmax trys to synchronize on angela but he does not own the lock so he therefore\ncannot and throws an IllegalMonitorStateException. \n\n... ','Input/Output',1,NULL),(3936,'How would you get theread permision set of a Path and a File?\n\nFile file = new file(\"test\");\nPath path = Paths.get(\"test\");','file.canRead();\n\nFiles.isReadable(path);','Input/Output',1,NULL),(3937,'How would you get write and or execute permision set of a Path and a File?\n\nFile file = new file(\"test\");\nPath path = Paths.get(\"test\");','file.canWrite();\nfile.canExecute();\n\nFiles.isWritable(path);\nFiles.isExecutable(path);','Input/Output',1,NULL),(3938,'How do you set the last modified time of a path and file?\n\nFile file = new file(\"test\");\nPath path = Paths.get(\"test\");','file.setLastModifed(timeinMillis);\n\nFileTime ft = FileTime.fromMillis(timeInMillis);\nFiles.setLastModifiedTime(path,ft);','Input/Output',1,NULL),(3939,'BasicFileAttributes basic = Files.readAttributes(path, BasicFileAttributes.class);\n\nhow would you list the creation time, last access time, and last Modified time?	\n','basic.creationTime();\nbasic.lastAccessTime();\nbasick.lastModifiedTime();\n\nbasic.isDirectory();\n\n','Input/Output',1,NULL),(3940,'Three big things about BasicFileAttributes and BasicFileAttributeView...','1. BasicFileAttributes is PLURAL, BasicFileAttributeVIew is SINGULAR\n\n2. BasicFIleAttributeView basView = Files.getFileAttributeView(   );   \n\n	BasicFileAtttributes bas = FIles.readAttributes(   );\n\n3. You can ONLY update attributes in BasicFileAttributeView, \n	\n	VIEW IS FOR UPDATING','Input/Output',1,NULL),(3941,'How would you construct a PosixFileAttribute object?	','PosixFileAttributes pox = Files.readAttributes(path, PosixFileAttributes.class);\n','Input/Output',1,NULL),(3942,'How would you set a Unix File\'s permissions in Java?	','Path path = Paths.get(\"/tmp/file2\");\nFiles.createFile(path);\nPosixFileAttributes ps = Files.readAttributes(path, PosixFileAttributes.class);\n\nSet<PosixFilePermission> perms = PosixFilePermission.fromString(\"rw-r--r--\");\n\nFiles.setPosixFilePermissions(path,perms);\n\nsout( ps.permissions() );\n\nTHe output would be:\n\n[OWNER_WRITE, GROUP_READ, OTHERS_READ, OWNER_READ ]','Input/Output',1,NULL),(3943,'How to take modified times from one file\nand write new BasicFileAttributes\' last modified times\nlast access time and creation time to another file ... ?','BasicFileAttributes basic = Files.readAttributes(path1, BasicFileAttribute.class );\n\nFileTime at = basic.lastAccessTime();\nFileTime update = basic.lastModifiedTime();\nFileTime now = FileTime.fromMillis(System.currentTimeMiilis() );\n\nPath file = Paths.get(\"/temp/file.txt\");\nFiles.createFile(file);\n\nBasicFileAttributeView view = Files.getBasicFileAttributeView(file, BasicFileAttributeView.class);\n\nview.setTimes(update, at, now);','Input/Output',1,NULL),(3944,'BasicFileAttributeView is a...\n\nClass\n\nInterface\n\nAbstract class     ?','... interface\n\nmethods:\n\nString 	name()\nReturns the name of the attribute view.\n\nBasicFileAttributes 	readAttributes()\nReads the basic file attributes as a bulk operation.\n\nvoid 	setTimes(FileTime lastModifiedTime, FileTime lastAccessTime, FileTime createTime)\n\nUpdates any or all of the file\'s last modified time, last access time, and create time attributes.','Input/Output',1,NULL),(3945,'interface BasicFileAttributes methods.... ','FileTime 	creationTime()\nReturns the creation time.\n\nObject 	fileKey()\nReturns an object that uniquely identifies the given file, or null if a file key is not available.\n\nboolean 	isDirectory()\nTells whether the file is a directory.\n\nboolean 	isOther()\nTells whether the file is something other than a regular file, directory, or symbolic link.\n\nboolean 	isRegularFile()\nTells whether the file is a regular file with opaque content.\n\nboolean 	isSymbolicLink()\nTells whether the file is a symbolic link.\n\nFileTime 	lastAccessTime()\nReturns the time of last access.\n\nFileTime 	lastModifiedTime()\nReturns the time of last modification.\n\nlong 	size()\nReturns the size of the file (in bytes).','Input/Output',1,NULL),(3946,'interface PosixFileAttributes methods','GroupPrincipal 	group()\nReturns the group owner of the file.\n\nUserPrincipal 	owner()\nReturns the owner of the file.\n\nSet<PosixFilePermission> 	permissions()\nReturns the permissions of the file.','Input/Output',1,NULL),(3947,'interface PosixFileAttributeView methods ...','String 	name()\nReturns the name of the attribute view.\n\nPosixFileAttributes 	readAttributes()\nReads the basic file attributes as a bulk operation.\n\nvoid 	setGroup(GroupPrincipal group)\nUpdates the file group-owner.\n\nvoid 	setPermissions(Set<PosixFilePermission> perms)\nUpdates the file permissions.','Input/Output',1,NULL),(3948,'With DosFileAttributeView you can set what new and different file types ?','DosFileAttributeView has methods...\n\nsetArchive()\nsetHidden()\nsetReadOnly()\nsetSystem()\n\nfor Windows specific files ','Input/Output',1,NULL),(3949,'interface DosFileAttributeView methods...','String 	name()\nReturns the name of the attribute view.\n\nDosFileAttributes 	readAttributes()\nReads the basic file attributes as a bulk operation.\n\nvoid 	setArchive(boolean value)\nUpdates the value of the archive attribute.\n\nvoid 	setHidden(boolean value)\nUpdates the value of the hidden attribute.\n\nvoid 	setReadOnly(boolean value)\nUpdates the value of the read-only attribute.\n\nvoid 	setSystem(boolean value)\nUpdates the value of the system attribute.','Input/Output',1,NULL),(3950,'read a DosFileAttributes then declare if it is hidden and readonly \nthen set them so without using a DosFileAttributeView...','DosFileAttributes dos = Files.readAttributes(path, DosFileAttributes.class);\n\nsout( dos.isHidden() );\nsout( dos.isReadOnly() );\n\nFiles.setAttribute(path, \"dos:hidden\", true);\nFiles.setAttribute(path, \"dos:readonly\", true);\n\n','Input/Output',1,NULL),(3951,'You dont always need a XXXFileAttributeView object in order to change\na files attributes, you can just as easily do so with \"Files\" ...\n	','\n    setAttribute\n\n    public static Path setAttribute(Path path,\n                    String attribute,\n                    Object value,\n                    LinkOption... options)\n                             throws IOException\n\n    Sets the value of a file attribute.\n\n    The attribute parameter identifies the attribute to be set and takes the form:\n\n        [view-name:]attribute-name \n\n    where square brackets [...] delineate an optional component and the character \':\' stands for itself.\n\n    view-name is the name of a FileAttributeView that identifies a set of file attributes. If not specified then it defaults to \"basic\", the name of the file attribute view that identifies the basic set of file attributes common to many file systems. attribute-name is the name of the attribute within the set.\n\n    The options array may be used to indicate how symbolic links are handled for the case that the file is a symbolic link. By default, symbolic links are followed and the file attribute of the final target of the link is set. If the option NOFOLLOW_LINKS is present then symbolic links are not followed.\n\n    Usage Example: Suppose we want to set the DOS \"hidden\" attribute:\n\n        Path path = ...\n        Files.setAttribute(path, \"dos:hidden\", true);\n     \n\n    Parameters:\n        path - the path to the file\n        attribute - the attribute to set\n        value - the attribute value\n        options - options indicating how symbolic links are handled\n    Returns:\n        the path parameter\n    Throws:\n        UnsupportedOperationException - if the attribute view is not available\n        IllegalArgumentException - if the attribute name is not specified, or is not recognized, or the attribute value is of the correct type but has an inappropriate value\n        ClassCastException - if the attribute value is not of the expected type or is a collection containing elements that are not of the expected type\n        IOException - if an I/O error occurs\n        SecurityException - In the case of the default provider, and a security manager is installed, its checkWrite method denies write access to the file. If this method is invoked to set security sensitive attributes then the security manager may be invoked to check for additional permissions.\n\n','Input/Output',1,NULL),(3952,'You dont need PosixFileAttributeView to set a file permissions either...','Files.setPosixFilePermissions\n\npublic static Path setPosixFilePermissions(Path path,\n                           Set<PosixFilePermission> perms)\n                                    throws IOException\n\nSets a file\'s POSIX permissions.\n\nThe path parameter is associated with a FileSystem that supports the PosixFileAttributeView. This attribute view provides access to file attributes commonly associated \nwith files on file systems used by operating systems that implement the Portable \nOperating System Interface (POSIX) family of standards.\n\nParameters:\n    path - A file reference that locates the file\n    perms - The new set of permissions\nThrows:\n    UnsupportedOperationException - if the associated file system does not support the PosixFileAttributeView\n    ClassCastException - if the sets contains elements that are not of type PosixFilePermission\n    IOException - if an I/O error occurs\n    SecurityException - In the case of the default provider, and a security manager is installed, it denies RuntimePermission(\"accessUserInformation\") or its checkWrite method denies write access to the file.','Input/Output',1,NULL),(3953,'How to set a linux files permisions from a string ?\n	','PosixFileAttributes pos = Files.readAttributes(path, PosixFileAttributes.class);\nSet<PosixFilePermissions> perms = PosixFilePermissions.fromString(\"rw-r--r--:);\n\nFiles.setPosixFilePermissions(path,perms);\n\nsout(pos.group());\nsout(pos.permissions());','Input/Output',1,NULL),(3954,'What interface is used to recursively loop through a directory ?	','DirectoryStream<T> \n\nT is the element returned by the iterator. \n\nTHis allows for the convieninet use of a for - each loop to go through a dir.\n\nThe elements returned by the iterator are in no specific order.\n\n List<Path> listSourceFiles(Path dir) throws IOException {\n       List<Path> result = new ArrayList<>();\n       try (DirectoryStream<Path> stream = Files.newDirectoryStream(dir, \"*.{c,h,cpp,hpp,java}\")) {\n           for (Path entry: stream) {\n               result.add(entry);\n           }\n       } catch (DirectoryIteratorException ex) {\n           // I/O error encounted during the iteration, the cause is an IOException\n           throw ex.getCause();\n       }\n       return result;\n   }\n ','Input/Output',1,NULL),(3955,'how do you create a new DirectoryStream<T>','\n    Files.newDirectoryStream\n\n    public static DirectoryStream<Path> newDirectoryStream(Path dir)\n                                                    throws IOException\n\n    Opens a directory, returning a DirectoryStream to iterate over all entries in the directory. The elements returned by the directory stream\'s iterator are of type Path, each one representing an entry in the directory. The Path objects are obtained as if by resolving the name of the directory entry against dir.\n\n    When not using the try-with-resources construct, then directory stream\'s close method should be invoked after iteration is completed so as to free any resources held for the open directory.\n\n    When an implementation supports operations on entries in the directory that execute in a race-free manner then the returned directory stream is a SecureDirectoryStream.\n\n    Parameters:\n        dir - the path to the directory\n    Returns:\n        a new and open DirectoryStream object\n    Throws:\n        NotDirectoryException - if the file could not otherwise be opened because it is not a directory (optional specific exception)\n        IOException - if an I/O error occurs\n        SecurityException - In the case of the default provider, and a security manager is installed, the checkRead method is invoked to check read access to the directory.\n\n','Input/Output',1,NULL),(3956,'What type of object are returned by directorystreams iterator ? ','Path\n\nThe directory Stream interface is generic, but thats misleading since the \nonly way create a new DirectoryStream is by using File.newDirectoryStream\nwhich returns a Path.','Input/Output',1,NULL),(3957,'How would you filter the object returned by a directory Stream ?	','use \nFiles.newDirectoryStream(Path dir, String glob);\n\nthis lets you add a glob in that will compare the string representations \nof their file names agains the given glob.\n\nthis lets you filter your results...\n\n Path dir = ...\n     try (DirectoryStream<Path> stream = Files.newDirectoryStream(dir, \"*.java\")) {\n         :\n     }','Input/Output',1,NULL),(3958,'What will be returned by this code...\n\n	Path dir = Paths.get(\"/home/maxbisesi/Documents\");\n        \n	try(DirectoryStream<Path> ds = Files.newDirectoryStream(dir,\"[vx]*\")){\n            sout( );\n        } ','Nothing will not compile, must catch IOException for DirectoryStream','Input/Output',1,NULL),(3959,'How many directories at a time can DirectoryStream look at ?','only 1','Input/Output',1,NULL),(3960,'Think, DirectorySteam acts like ls in bash.','or ...\nDirectoryStream streams one directory','Input/Output',1,NULL),(3961,'What \"Files\" method do you use along with FileVisitor?','public static Path walkFileTree(Path start,\n                FileVisitor<? super Path> visitor)\n                         throws IOException\n\nWalks a file tree.\n\nThis method works as if invoking it were equivalent to evaluating the expression:\n\n     walkFileTree(start, EnumSet.noneOf(FileVisitOption.class), Integer.MAX_VALUE, visitor)\n     \n\nIn other words, it does not follow symbolic links, and visits all levels of the file tree.\n\nParameters:\n    start - the starting file\n    visitor - the file visitor to invoke for each file\nReturns:\n    the starting file\nThrows:\n    SecurityException - If the security manager denies access to the starting file. In the case of the default provider, the checkRead method is invoked to check read access to the directory.\n    IOException - if an I/O error is thrown by a visitor method','Input/Output',1,NULL),(3962,'FileVisitor methods return what ?','FileVisitResult','Input/Output',1,NULL),(3963,'Enum FileVisitResult elements','CONTINUE\nSKIP_SIBLINGS = continue without visiting the siblings of this file or directory\n\nSKIP_SUBTREE = continue without visiting the entries in this directory\n\nTERMINATE','Input/Output',1,NULL),(3964,'SimpleFileVisitor has a protected constructor so It can only be extended','SimpleFileVisitor sf = new SimpleFileVisitor() will not compile','Input/Output',1,NULL),(3965,'try(DirectoryStream stream = Files.newDirectoryStream(dir)){\n	sout(\"throw excpetion\");\n	//do stuff\n}\n\nWhats wrong here ?','DirectoryStream throws an IOException. Therefore anytime you use \nDirectoryStream you must catch an IOException\n\ntry(DirectoryStream stream = Files.newDirectoryStream(dir)){\n	sout(\"throw excpetion\");\n	//do stuff\n} catch(IOException e) { \n	log(e);\n}','Input/Output',1,NULL),(3966,'try(DirectoryStream stream = Files.newDirectoryStream(dir)){\n\n	for(Path file : stream){\n		sout(file.getFileName());\n	}\n} catch(IOException e ){\n\n}\n\nWhats wrong here ??','If DirectroyStream is not typed it will give Object elements. Therefore\nto use an untyped DirectoryStream you would have to use...\n	\n	for(Object file : stream) {\n	\n	}\n\n... but thats usually not what you want so always do this>>>\n\n	try(DirectoryStream<Path> Stream = Files.newDirectoryStream(dir)){\n\n	} catch(IOExcetpion e) {\n\n	}','Input/Output',1,NULL),(3967,'\npublic class CopyCharacters {\n    public static void main(String[] args) throws IOException {\n\n        FileReader inputStream = null;\n        FileWriter outputStream = null;\n\n        try {\n            inputStream = new FileReader(\"xanadu.txt\");\n            outputStream = new FileWriter(\"characteroutput.txt\");\n\n            int c;\n            while ((c = inputStream.read()) != -1) {\n                outputStream.write(c);\n            }\n        } finally {\n            if (inputStream != null) {\n                inputStream.close();\n            }\n            if (outputStream != null) {\n                outputStream.close();\n            }\n        }\n    }\n}\n','All character stream classes are descended from Reader and Writer. \nAs with byte streams, there are character stream classes that specialize in file I/O: FileReader and FileWriter. \nThe CopyCharacters example illustrates these classes.\n\nclose() throws IOException here too','Input/Output',1,NULL),(3968,'What has to be done with pretty much ALL IO classes ?','wrap them in Try Block, they all throw IOExceptions ','Input/Output',1,NULL),(3969,'What method does BufferedReader have that makes it valuable	','public String readLine()\n                throws IOException\n\nReads a line of text. A line is considered to be terminated by any one of a line feed (\'\\n\'), a carriage return (\'\\r\'), or a carriage return followed immediately by a linefeed.\n\nReturns:\n    A String containing the contents of the line, not including any line-termination characters, or null if the end of the stream has been reached\nThrows:\n    IOException - If an I/O error occurs\n\n\nOther IO classes have read methods that only read in a single character\nBufferedReader has this too. But this method really helps!','Input/Output',1,NULL),(3970,'Which IO class swallows exceptions and does not throw them but \nsaid exceptions can be checked using checkerror()','PrintWriter','Input/Output',1,NULL),(3971,'Path file = Paths.get(\"/home/dick/bigorsmall.txt\");\nBufferedWriter bw = new BufferedWriter(new FileWriter(file));\n\nbw.write(\"this ones pretty big \");','wont compile you cant construct a FileWriter from a Path not to mention there is an unreported IOException','Input/Output',1,NULL),(3972,'Files method:\n\nPath copy(Path src, Path targ, CopyOption...options)','Copy the file from the source to target and return the target.\n\nthrows FileAlreadyExistsException if target fiile already exists, and no\nREPLACE_EXSISTING copy Option is specified. ','Input/Output',1,NULL),(3973,'Files method:\n\nPath move(Path src, Path target, CopyOption options)','Moves the file from src to target return target. \n\nthrows:\n\n FileAlreadyExistsException - if the target file exists but cannot be replaced because the REPLACE_EXISTING option is not specified (optional specific exception)\n   \n DirectoryNotEmptyException - the REPLACE_EXISTING option is specified but the file cannot be replaced because it is a non-empty directory (optional specific exception)','Input/Output',1,NULL),(3974,'Path p1 = Paths.get(\"/home/One.txt\");\nPath p2 = Paths.get(\"One.txt\");\nPathMatcher matcher = FileSystems.getDefault().getPathMatcher(\"glob:*.txt\");\n\nsout( matcher.matches(p1) );\nsout( matcher.matches(p2) );','false \ntrue\n\nin glob * means match any character excpet a directory boundary\n\n** mathces any character across directory boundaries. \n\nnotice that PathMatcher(\"syntax:pattern\") can take a glob or a regex but you\nmust specify\n\nedit:\nwas previously:\nDefault().getPathMatcher(\"glob: *.txt\");\n\nthere cant be a space after the : or that will mathch...\n\n	Path path = Paths.get(\"one.txt\");\n        PathMatcher matcher = FileSystems.getDefault().getPathMatcher(\"glob: *.txt\");\n        System.out.println(matcher.matches(path));\n\nwould give false unless the space was removed. | Path p1 = Paths.get(\"/home/One.txt\");\nPath p2 = Paths.get(\"One.txt\");\nPathMatcher matcher = FileSystems.getDefault().getPathMatcher(\"glob: *.txt\");\n\nsout( matcher.matches(p1) );\nsout( matcher.matches(p2) );','Input/Output',1,NULL),(3975,'in Glob what does * mean ? what about ** ?','* matches any character inside a directory boundary\n** matches any character inside a directory boundary\n\n','Input/Output',1,NULL),(3976,'GLOB\n\nwhat does \"?\" mean ?','? matches any single character. ','Input/Output',1,NULL),(3977,'public class Hello {\n    public static void main(String[] args) {\n        PathMatcher matcher = FileSystems.getDefault().getPathMatcher(\"glob:**{.pic,.txt}\");\n        Path p1 = Paths.get(\"home/files.txt\");\n        Path p2 = Paths.get(\"documents/pictures/smile.pic\");\n        Path p3 = Paths.get(\"home/dir\");\n        \n        System.out.println(matcher.matches(p1));\n        System.out.println(matcher.matches(p2));\n        System.out.println(matcher.matches(p3));\n    }\n\n}','true\ntrue\nfalse','Input/Output',1,NULL),(3978,'public void matches(Path path, String glob){\n	PathMatcher matcher = FileSystems.getDefault().getPathMatcher(glob);\n	sout( matcher.matches(path) );\n}\n\nPath p1 = Paths.get(\"Bert-book\");\nPath p2 = Paths.get(\"Kathy-horse\");\nmatches(p1, \"glob:{Bert*,Kathy*}\");\nmatches(p2, \"glob: {Bert, Kathy}*\");\nmatches(p1, \"glob:{Bert,Kathy}\");','true\ntrue\nfalse','Input/Output',1,NULL),(3979,'FileVisitor\n\npublic FileVisitResult visitFileFailed(path file, BasicFileAttributes attrs) {\n\n	// do something\n	return FileVisitResult.CONTINUE;\n	\n}\n','wrong, visitFileFailed takes an IOExcpeption as a parameter\nas well as postVisitDirectory','Input/Output',1,NULL),(3980,'FileVisitor: \n\npublic FileVisitResult preVisitDirectory(path file, BasicFileAttributes attrs) {\n\n	// do something\n	return FileVisitResult.CONTINUE;\n	\n}','right, ','Input/Output',1,NULL),(3981,'FileVisitor:\n\npublic FileVisitResult visitFileFailed(path file, IOException e) {\n\n	// do something\n	return FileVisitResult.CONTINUE;\n	\n}','right','Input/Output',1,NULL),(3982,'FileVisitor:\n\npublic FileVisitResult postVisitDirectory(path file, IOException e) {\n\n	// do something\n	return FileVisitResult.CONTINUE;\n	\n}','right','Input/Output',1,NULL),(3983,'Date today = new Date();\n\nDateFormat df = DateFormat.getInstance();\n\nString todayFile = df.format(today);\n\nsout(todayFile);	// this gives 9/8/01 7:46 PM\n\ntodayFile.replaceAll(\" \",\"-\");\n\nsout( todayFile );\n\nwhat prints now ?','9/8/01 7:46 PM \n\nremember that strings are imutable, so even though you called \nreplaceAll on that string you didn\'t assing it to a new sString therefore it\nwas lost.\n\nshould be:\n	String newDate = todayFile.replaceAll(\" \",\"-\");','Strings',1,NULL),(3984,'Path p1 = Paths.get(todayFile+\".txt\");\nSystem.out.println(p1);\n        \nBufferedWriter bw = new BufferedWriter(new FileWriter(p1));','wont compile, FileWriter doesn\'t have a Path constructor,\n\nchange p1 to p1.toFile();\n\nFileWriter(File file)\nConstructs a FileWriter object given a File object.\n\nFileWriter(File file, boolean append)\nConstructs a FileWriter object given a File object.\n\nFileWriter(FileDescriptor fd)\nConstructs a FileWriter object associated with a file descriptor.\n\nFileWriter(String fileName)\nConstructs a FileWriter object given a file name.\n\nFileWriter(String fileName, boolean append)\nConstructs a FileWriter object given a file name with a boolean indicating whether or not to append the data written.','Input/Output',1,NULL),(3985,'class Eggs {\n	int doX(Long x, Long y){ return 1; }\n	int doX(long...){ return 2; }\n	int doX(Integer x, Integery){ return 3; }\n	int doX(Number n, Number m){ return 4; }\n	public static void main(SA){\n		new Eggs().go();\n	}\n	void go(){\n		short s = 7;\n		sout(doX(s,s) + \" \");\n		sout(doX(7,7));\n	}\n}','4 3 \n\ntwo rules apply to the first doX, you cannot widen and then box in\none step, and var-args are always chosen last. So you cannot widen shorts\nto ints or longs then box them to Integer or Long but you can box short\nto Short then widen that to Number, that takes priority over var args.\n\nthe second doX simmply boxs int to Integer.\n\n\n\n    Assignment contexts allow the use of one of the following:\n\n        an identity conversion (§5.1.1)\n\n        a widening primitive conversion (§5.1.2)\n\n        a widening reference conversion (§5.1.5)\n\n        a boxing conversion (§5.1.7) optionally followed by a widening reference conversion\n\n        an unboxing conversion (§5.1.8) optionally followed by a widening primitive conversion.\n\n\n','General',1,NULL),(3986,'What is the first and second argument to Files.walkFileTree()','the first is the directory to start walking at in the form of a Path\n\nthe second is an object of the class that extends SimpleFileVisitor<Path>','Input/Output',1,NULL),(3987,'Which Two FileVisitor methods take IOExceptions as parameters	?','visitFileFailed and postVisitDirectory','Input/Output',1,NULL),(3988,'Which two FileVisitor methods take BasicFileAttributes as parameters ?','preVisitDirectory and visitFile','Input/Output',1,NULL),(3989,'/home\n	- a.txt\n	- emptyChild	\n	- child\n		- b.txt\n		- grandchild\n			- c.txt\n\npublic class PrintDirs extends SimpleFileVisitor<Path> {\n	public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) {\n		sout( \"pre\" + dir);\n		String name = dir.getFileName().toString();\n		\n		if (name.equals(\"child\"))\n			return FileVisitResult.SKIP_SUBTREE;\n		return FileVisitResult.CONTINUE;\n\n	}\n}\n			\n			\n		\n	','now the output is:\n	pre: /home\n	file: /home/a.txt\n	pre: /home/child\n	pre: /home/emptyChild\n	post: /home/emptyChild\n	post: /home\n\npostVisitDirectory is never called if the subtree of the directory is skipped','Input/Output',1,NULL),(3990,'postVisitDirectory is never called if the subtree of the directory is skipped','','Input/Output',1,NULL),(3991,'/home\n	- a.txt\n	- emptyChild	\n	- child\n		b.txt\n		grandchild\n		c.txt\n\n\" assume you have FileVisitor method from previous flashcards where the\npre post and file are printed before printing the path of that dir or file \"\n\npublic FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) {\n	sout( \"pre: \" + dir);\n	String name = dir.getFileName().toString();\n	\n	if (name.equals(\"grandchild\"))\n		return FileVisitResult.SKIP_SUBTREE;\n	if ( name.equals(\"emptychild\")\n		return FileVisitResult.SKIP_SIBLINGS;\n	return FileVisitResult.CONTINUE;','assuming child is encountered beffore emptyChild, the output is: \n\npre: /home\nfile: /home/a.txt\npre: /home/child\nfile: /home/child/b.txt\npre: /home/child/grandchild\npost: /home/child\npre: /home/emptyChild\npost: /home\n\nyou skip the grandchld subtree so you dont see the postVisitDirectory call\n\nchild is a sibling but it was encountered before emptychild so it was not skipped','Input/Output',1,NULL),(3992,'public void matches(Path path, String glob){\n	PathMatcher matcher = FileSystems.getDefault().getPathMatcher(glob);\n	sout( matcher.matches(path) );\n}\n\nPath p1 = Paths.get(\"0*b/test/1\");\nPath p2 = Paths.get(\"9\\\\*b/test/1\");\nPath p3 = Paths.get(\"01b/test/1\");\nPath p4 = Paths.get(\"0*b/1\");\n\nString glob = \"[0-9]\\\\*{A*,b}/**/1\");\n\nmatches(p1,glob);\nmatches(p2,glob);\nmatches(p3,glob);\nmatches(p4,glob);\n','true \nfalse\nfalse\nfalse\n\n{A*,b} means A followed by anything or the single character b\n\n/**/ means one or more directories with any name\n\n\\\\* the actuall asterix character \\ escapes the * the second \\ espaces the first \\ ','Input/Output',1,NULL),(3993,'What exception if any do FileVisitor methods throw ?','IOException','Input/Output',1,NULL),(3994,'glob vs regex: \n\nZero or more of any character, including directory bounndary','glob: **\n\nregex: .*','Input/Output',1,NULL),(3995,'regex:\n\n.*','zero or or more of any character including directory boundary','Input/Output',1,NULL),(3996,'glob vs regex:\n\nZero or more of any character, not a directory boundary','glob: *\n\nregex: no syntax required','Input/Output',1,NULL),(3997,'Glob vs regex:\n\nexcactly one character','glob: ?\n\nregex: .','Input/Output',1,NULL),(3998,'glob vs regex:\n\nBegins with cat or dog','glob:\n	{cat, dog}*\n\nregex:\n\n	(cat|dog).*','Input/Output',1,NULL),(3999,'(cat|dog).*\n\nglob or regex ?','regex','Input/Output',1,NULL),(4000,'You are creating a PathMatcher\n\nPathMatcher matcher = ________._________().__________();','FileSystems.getDefault().getPathMatcher();','Input/Output',1,NULL),(4001,'You are creating a WatchService:\n\nWatchService watcher = _____________.__________()._________()','FileSystems.getDefault().newWatchService();','Input/Output',1,NULL),(4002,'What do you get from a WatchService to indicate a deletion creation or modification','WatchKey\ntry {\n	WatchKey key;\n	try {\n	key = watcher.take();\n              } catch(interuptedException x) {\n		return;\n	}\n	for(WatchEvent<?> event : key.pollEvents()){\n	//do stuff\n	}','Input/Output',1,NULL),(4003,'What are two ways to get a WatchKey ? \nand whats the difference between them ? ','take() will wait and block forever until an event takes place. Will throw\nInteruptedException if interuped without taking an event. \n\npoll() returns null if an event is not imediately available. ','Input/Output',1,NULL),(4004,'public class Frodo etends Hobbit {\n	public static void main(SA) { \n		int mygold = 7;\n		sout(countGold(mygold,6));\n	}\n}\nclass Hobbit {\n	int countGold(int x, int y) { return x + y; }\n}','does not compile countGold() cannot be called from a static context','Input/Output',1,NULL),(4005,'The contract between equals() and hashCode() is:','1) If two objects are equal, then they must have the same hash code.\n2) If two objects have the same hash code, they may or may not be equal. \n3) If two objects are not equal, they must NOT have the same hashcode\n','OOP',1,NULL),(4006,' public static void main(String[] args){\n       Path dir = Paths.get(\"/home/maxbisesi\");\n       try(DirectoryStream<Path> stream = Files.newDirectoryStream(dir,\"*\");){\n            for(Path path : stream){\n               System.out.println(path);\n            }\n        } catch(IOException e){\n            System.out.println(\"SQLException\");\n            System.out.println(e);\n        }\n   }','shows all files and directories in /home/maxbisesi\n\nsqlexception if the path is not a valid path','Input/Output',1,NULL),(4007,'public class Hello {\n    synchronized void a() { actBusy(); }\n    static synchronized void b() { actBusy(); }\n    static void actBusy() {\n        try {\n            Thread.sleep(1000);\n            \n        } catch( InterruptedException e){}\n            \n        \n    }\n    public static void main(String[] args) {\n        final Hello x = new Hello();\n        final Hello y = new Hello();\n        \n        Runnable runnable = new Runnable() {\n            public void run() {\n                int option = (int) (Math.random() * 4);\n                switch(option) {\n                    case 0: x.a(); break;\n                    case 1: x.b(); break;\n                    case 2: y.a(); break;\n                    case 3: y.b(); break;\n                }\n            }\n        };\n        \n        Thread t1 = new Thread(runnable);\n        Thread t2 = new Thread(runnable);\n        \n        t1.start();\n        t2.start();\n    \n    }\n\n}  \n\nwhich methods could never be running at the same time ?','x.a() thread1 x.a() in thread2\nx.b() thread1 x.b() in thread2\nx.b() thread1 y.b() in thread2\n\nthe same instance method of the same instance is blocked while a static\nmethod accross all methods is blocked. ','Threads',1,NULL),(4008,'Method forwarding relies on Has-a relationships','got it ','OOP',1,NULL),(4009,'class Animal implements Burriable {\n    private Integer size;\n    private String name;\n    \n    public Animal(int x, String y){\n        size = x;\n        name = y;\n    }\n    public Animal(){\n        size = 0;\n        name = \"\";\n    }\n\n    public int getSize() {\n        return size;\n    }\n\n    public String getName() {\n        return name;\n    }\n    \n    public void bury(){\n        System.out.println(\"just toss him in there...\");\n    }\n    public void digUp(){\n        System.out.println(\"Hang on this ones still kickin !\");\n    }\n    public void pray(){\n        System.out.println(\"...Lord forgive us for what we have done, hes only been gone for \"+YEARSDEAD+\" years.\");\n    }\n}\n\nclass Dog implements Burriable{\n    private Animal animal;\n    public Dog(Animal a){\n        animal = a;\n    }\n    \n    public void bury(){\n        animal.bury();\n    }\n    public void digUp(){\n        animal.digUp();\n    }\n    public void pray(){\n        animal.pray();\n    }\n    \n    public String yelpForHelp(){\n        return \"ar ar arrr....\";\n    }\n}\n\ninterface Burriable {\n    int YEARSDEAD = 1;\n    void bury();\n    void digUp();\n    void pray();\n}\n\nwhat OOP principle is this ?','method forwarding\n\nan object composition principle that calles methods on an instance variable of an object','OOP',1,NULL),(4010,'public class F {\n	private static final F f = new F();\n	public static F c(){\n		return f;\n	}\n\n	public void update(F a) { }\n	\n	public void delete(F a) { }\n\n}\nwhat design pattern is this ? ','The singleton pattern is identifiable bby the static variable for the single instance and the accessor returning it. ','OOP',1,NULL),(4011,'public class E {\n	private D d;\n	public void m() {\n		d.m();\n	}\n\n		public static E getInstance() {\n			return new E();\n		}\n}\n\nclass D {\n	public void m() { }\n}\n\nwhat design pattern principle is this ?\n','object composition, you can tell because of the method forwarding. \nSingleton is tempting but the getInstance method here returns a NEW instance\ninstead a single private static one like it should to be singleton. ','OOP',1,NULL),(4012,'class A {}\n\nabstract class G {\n	A m() { return n(); }\n	abstract A n();\n}\n\nwhat principle is demostrated','Factory,\n\nClass A is the object we are creating using the factory method. class G\nis the abstract superclass for the factory. Not shown is a class implementing \nclass G that actually creates the object. ','OOP',1,NULL),(4013,'which is a benefit of the DAO pattern ?	','Reuse The DAO pattern centralize logic for the data access code making reuse\neasier and allowing you to switch out implementations. ','OOP',1,NULL),(4014,'public void print(Path d) throws IOException {\n	try(DirectoryStream<Path> stream = Files.newDirectoryStream(d)){\n		for(Path path: stream){\n			sout( path.getFileName() );\n		}\n	}\n}\n\nwhat files will this display ? ','regular files, hidden files, and subdirectories','Input/Output',1,NULL),(4015,'public class Hello {\n    public static void main(String[] dicks) throws IOException{\n      Path src = Paths.get(\"/home/maxbisesi/Documents/copy.txt\");\n      Files.createFile(src);\n      \n      Files.copy(src, Paths.get(\"/home/maxbisesi/Documents/newcopy.txt\"));\n      \n    }\n\n}\n\nwhat happens if this is ran twice and all preivous files dont exist before','The first time the file will be created and copied normally the second time you\nwill get a file already exists excpeiotn','Input/Output',1,NULL),(4016,'public class Hello {\n    public static void main(String[] dicks){\n        ArrayList list = new ArrayList();\n        \n        list.add(\"java\");\n        list.add(\"sucks\");\n        \n        String item = list.get(0);\n\n    }\n\n}','Compilation fails, to compile would have to be \n\n	Object item = list.get(0);','Collections',1,NULL),(4017,'if(true)\n       int b = 1;\n        ','Will not compile, there is no scope there \n\nif(true){\n	int b = 1;\n} \n	this would though !','General',1,NULL),(4018,'public class Hello {\n    public static void main(String[] dicks){\n        Pattern p = Pattern.compile(\"C.*L\");\n        Matcher m = p.matcher(\"CooLooLCuuLooC\");\n        \n        while(m.find())\n            System.out.println(m.group());\n\n    }\n\n}','CooLooLCuuL\n\n* is the greedy quantifier, it takes as much as it can. ','Strings',1,NULL),(4019,'If a thread\'s priority is not specified explicitly then it gets\nNORM_PRIORITY\n\nT or F ','False it gets the same priority as the thread that created it ','Threads',1,NULL),(4020,'public class Hello {\n    public static void main(String[] dicks){\n        Animal ah2 = new Horse();\n        ah2.eat(\"carrots\");\n    }\n\n}\n\nclass Animal{\n    public void eat(){ }\n}\n\nclass Horse extends Animal {\n    public void eat() { }\n    public void eat(String s ){ } \n}\n    ','Will not compile, method eat in class animal cannot be applied to given types','General',1,NULL),(4021,'public class Hello {\n    public static void main(String[] dicks){\n        Animal ah2 = new Horse();\n        ah2.eat();\n    }\n\n}\n\nclass Animal{\n    public void eat(){ System.out.println(\"Animal\"); }\n}\n\nclass Horse extends Animal {\n    public void eat(){ System.out.println(\"Horse\");} \n}\n\n','Horse','General',1,NULL),(4022,'public class Hello {\n    public static void main(String[] dicks){\n        Animal ah2 = new Horse();\n        ah2.eat();\n    }\n\n}\n\nclass Animal{\n    public void eat(){ System.out.println(\"Animal\"); }\n}\n\nclass Horse extends Animal {\n    public void eat() throws IOException{ System.out.println(\"Horse\");} \n}','will not compile overriden method \ncannot throw new or broader checked exceptions','General',1,NULL),(4023,'public class Hello {\n    public static void main(String[] dicks){\n        Animal ah2 = new Horse();\n        ah2.eat();\n    }\n\n}\n\nclass Animal{\n    public void eat(){ System.out.println(\"Animal\"); }\n}\n\nclass Horse extends Animal {\n    public void eat(int x) throws IOException{ System.out.println(\"Horse\");} \n}','Animal\n\neat in horse is an overload, it still inherits Animals eat()','General',1,NULL),(4024,'//assume valid Connection cn, and good database connection\n\nString query = \"Select * from Answer\";\ntry(Statement stmt = cn.createStatement()){\n	ResultSet rs1 = stmt.executeQuery(query);\n	stmt.executeQuery(\"select * from Question\");\n	while(rs1.next(){\n		sout(rs1.getInt(\"fk_question_num\");\n	}\n} catch(SQLException e){\n	\n}','SQLException\n	Statement objects do not support multiple open ResultSets.\n	\n	Only a single ResultSet can be opened from the same statement object\n\n	*if the same statement object is executed more than once the previous\n	ResultSet is closed automatically\n		\n		... and attempting to access a closed RS is a SQLException','JDBC',1,NULL),(4025,'','','blank',1,NULL),(4026,'try(Connection conn = DriverManager.getConnection(url,user,pw)){\n	String pQuery = \"Select unitPrice From Book Where Title Like ?\";\n\n	PreparedStatement pstmt = conn.prepareStatement(pQuery);\n\n	ResultSet rs = pstmt.executeQuery();\n} catch(SQLException sq) {\n}\n','SQLException , attempting to execute a query without setting a parameter\nresults in an SQLException\n\n	should be>>>\n		\n		pstmt.setString(1,\"dick\");\n\nIndexing starts at 1','JDBC',1,NULL),(4027,'adsf','asdf','Exceptions',1,NULL),(4028,'d','d','d',1,NULL),(4029,'d','d','d',1,NULL),(4030,'d','d','d',1,NULL),(4031,'@Stateful\npublic class ModelEJB {\n    @PersistenceUnit\n   private EntityManagerFactory emf;\n    \n    public void putUserMessage(String messageString) throws MessageException {\n        this.deleteMessage();\n        try {\n            String decodedMessage = URLDecoder.decode(messageString, \"UTF-8\");\n            Message message = new Message(\"1\", \"(\" + messageString + \")\" + \" in a database\");\n            EntityManager em = emf.createEntityManager();\n            em.persist(message);\n        } catch (UnsupportedEncodingException uee ) {\n            throw new MessageException(\"something odd about that message...\" + messageString);\n        }\n    }','Notice that EntityManagerFactory emf is never initialized, yet calls to it are made. This demonstrates the technique of injection.\n\nThis only works becuase that instance is marked with the @PersistanceUnit anotation. \n\nSimilar to how javaEE container manages the lifecycle of java components such as servlets, javaEE containers also initialize certain variables while the component is coming to life, provided they are marked with annotations.','EE/Beans',1,NULL),(4032,'public class WriteServlet extends HttpServlet {\n    @EJB\n    private ModelEJB helloEJB;\n    \n    protected void doPost(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        String message = request.getParameter(PUT_MESSAGE);\n        if (\"\".equals(message)) {\n            helloEJB.deleteMessage();\n        } else {\n            try {\n                helloEJB.putUserMessage(message);\n            } catch (MessageException nme) {\n                throw new ServletException(nme);\n            }    \n        } \n        response.sendRedirect(\"./DisplayServlet\"); \n    }\n    \n}','Notice the process of injection here, helloEJB is not intitialized but rather marked with @EJB annotation.','EE/Beans',1,NULL),(4033,'JSPs are Java Servlets: the java EE server compiles JSPs dynamically into servlets at runtime. THus, Java Servlets form the underpinnings of this second kind of web component in the Java platform. ','','EE/Servlets',1,NULL),(4034,'HTTP Request\n\nHeaders\nGET /myphotos.html HTTP/1.1\nhost: photoserver.com\naccept: text/html, application/xml\nuser-agent: Mozilla/5.0\naccpt-encoding: gzip\naccept-language: en-US\n\nbody\n\n<empty>','host header carries the hostname of the web server to which the client is sending the request\n\naccept header contains a listing of MIME types that describe the kinds of response body informaiton the client will be able to deal with and the response the server will send back\n\nThe user-agent header indentifies the HTTP client\n\naccpet-encoding and accept language headers are used to inform the server what kind of language formats the client will be able to accept in a response.','EE/Http',1,NULL),(4035,'Servlet','A java object that processes the server side of HTTP interactions. ','EE/Servlets',1,NULL),(4036,'Three important Classes in the servlet API','javax.servlet.http.HttpServlet\njavax.servlet.http.HttpServletRequest\njavax.servlet.htttp.HttpServletResponse','EE/Servlets',1,NULL),(4037,'public void service(HttpServletRequest req, HttpServletResponse resp)','Handles al HTTP requests','EE/Servlets',1,NULL),(4038,'Name all the Http request methods of the Servlet class','doGet \ndoPost\nservice\ndoHead\ndoOptions\ndoPut\ndoTrace','EE/Servlets',1,NULL),(4039,'HttpServletRequest object contains a variety of methods for reading HTTP request headers and for reading the HTTp request body content, if there is any. The key methods are ?','public Enumeration getHeaderName()\npublic String getHeader(String name)\npublic InputStream getInputStream()\npublic Reader getReader()','EE/Servlets',1,NULL),(4040,'HttpServletResponse methods for setting response headers and body: ','public void setHeader(String name, String value)\npublic OutputStream getOutputStream() \npublic Writer getWriter()','EE/Servlets',1,NULL),(4041,'Skeleton for processing incoming http requests:\n\npublic class TemplateServlet extends HttpServlet {\n	\n	protected void service(HttpServletRequest request, HttpServletResponse res){\n		\n		for(Enumeration e = request.getHeaderNames(); e.hasMoreElements; ) {\n			String nextRequestHeaderNae = (String) e.nextElement();\n			String nextRequestHeaderValue = request.getHeader(nextRequestHEaderName);\n			\n			//examine request\n		}\n\n		//read request body\n		InputStream is = request.getInputStream();\n		Reader reader = request.getReader();\n		\n		//Gather Data to send back\n		\n		//set response header\n		response.setHeader(myResponseHEaderName, myResponseHEaderValue);\n		\n		PrintWriter writer = response.getWriter();  //or\n		OutputStream output = response.getOutputStream();\n	}\n}','process an incoming request','EE/Servlets',1,NULL),(4042,'javax.servlet.ServletContext','The ServletContext of a web application is an object that represents to all the servlets inside the webp application the container in which it runs. ','EE/Servlets',1,NULL),(4043,'If a servlet does not override an Http request method, the servlet will not respond to those types of requests. ','','EE/Servlets',1,NULL),(4044,'','','EE/Servlets',1,NULL),(4045,'if (request.getContentType() != null && request.getContentType().startsWith(\"multipart/form-data\")) {\n            this.uploadPhoto(request, pa);\n        }\n\n\nByteArrayOutputStream baos = new ByteArrayOutputStream();\n        String filename = null;\n        for (Part p: request.getParts()) {\n            this.copyBytes(p.getInputStream(), baos);\n            filename = p.getSubmittedFileName();\n        }\n        if (!\"\".equals(filename)) {\n            String photoName = filename.substring(0, filename.lastIndexOf(\".\"));\n            pa.addPhoto(photoName, baos.toByteArray());\n        }','larger chunks of data uploaded as multipart data over HTTP will likely arrive in a number of parts. This is dependnt on a number of factors, including the client, the size of the file, and the network, and the java EE server. \n\nIterate over the javax.servlet.http.Part object to get the parts\n\nobtain the photo data from the HttpServletRequest object by means of its InputStream, collecting the data in a byte array. ','EE/Servlets',1,NULL),(4046,'//Photo Album object\npublic static PhotoAlbum getPhotoAlbum(HttpSession session) {\n        if (session.getAttribute(ATTRIBUTE_NAME) == null) {\n            PhotoAlbum pa = new PhotoAlbum();\n            session.setAttribute(ATTRIBUTE_NAME, pa);\n        }\n        return (PhotoAlbum) session.getAttribute(ATTRIBUTE_NAME);\n    }\n\n\n//Display servlet\nHttpSession session = request.getSession();\n        PhotoAlbum pa = PhotoAlbum.getPhotoAlbum(session);\n        if (request.getContentType() != null && request.getContentType().startsWith(\"multipart/form-data\")) {\n            this.uploadPhoto(request, pa);\n        }','All three servlets( RemovePhotoServlet, DisplayAlbumServlet, and DisplayPhotoServlet) share on PhotoAlbum Servlet, which is passed around in and stored in session object so that they can all share one object.  ','EE/Servlets',1,NULL),(4047,'What method is called by the Java EE web container created a servlet instance ?','public void init(ServletConfig config) throws ServletException','EE/Servlets',1,NULL),(4048,'What object is passed to the Servlet\'s init() method ?','ServletConfig, gives the servlet a view of configurations. If there is an error in the init method. The Servlet will not come into service. ','EE/Servlets',1,NULL),(4049,'What happens if the service() method is implemented','That Servlet will implement any and all HttpRequests, and the servlets doXXX methods will not be called. ','EE/Servlets',1,NULL),(4050,'What happens when a web container decides that is has finished using an instance of a java servlet ?','Before being garbage collected, the container calls the servlet\'s \'public void destroy()\' \n\nonce destroy is called that servlet has served its purpose, the same instance can never be reused. ','EE/Servlets',1,NULL),(4051,'How many instances of a servlet will be instantiated ?','That number varies depending on the web container, whatever the scheme: \n\n-each java servlet instance may handle simultaneous requests from multiple clients\n\n- Each Java Servlet may be instantiated multiple times by the web container. \n\n... so program with concurrent requests in mind. ','EE/Servlets',1,NULL),(4052,'API for manipulating application data on the ServletContext: ','public Object getAttribute(String name)\npublic Enumeration<String> getAttributeNames()\npublic void removeAttribute(String name)\npublic void setAttribute(String name, Object value)','EE/Servlets',1,NULL),(4053,'If you run the photo application from two seperate browsers, when you upload a photo in one browser and then refresh the display of the application in the other browser, both browsers would display the same photos. \n\nThis is where the HttpSession object comes into play. ','javax.servlet.http.HttpSession\n\nrepresents a series of interactions with a single web application with a single client. \n\nthis is the object to use if you want to program to a particular client. ','EE/Servlets',1,NULL),(4054,'what methods are used to control the session timeout ? ','public int getMaxInactiveInterval()\npublic void setMaxInactiveInterval(int interval)','EE/Servlets',1,NULL),(4055,'how do you kill an HttpSession ?','public void invalidate()','EE/Servlets',1,NULL),(4056,'The Web container primarily relies on cookies to maintain session information, but if cookies are disabled how can the container still maintain a session ?','JSESSIONID:  in a technique called URL rewriting, any links the web app returns to the client have the session id added in as query string, under the name JSESSIONID. \n\nThis relies on the stateful nature of the underlying SSL protocol. ','EE/Servlets',1,NULL),(4057,'public void forward(ServletRequest request, ServletResponse response)','You ask the web resource represented by the request dispatcher to write the response for you, this means you must not have already written the response yourself. \n\nYou must not try to write to the response after you have already forwarded. ','EE/Servlets',1,NULL),(4058,'public void include(ServletRequest request, ServletResponse resp)','you want the resource represented by the request dispatcher to fill in some gaps in the response for you. \n\nThis method will include the reponse you have already written some to. ','EE/Servlets',1,NULL),(4059,'String indexString = request.getParameter(\"photo\");        \n        int index = (new Integer(indexString.trim())).intValue();\n        HttpSession session = request.getSession();\n        PhotoAlbum myPhotos = PhotoAlbum.getPhotoAlbum(session);\n        myPhotos.removePhoto(index);\n        request.getRequestDispatcher(\"DisplayAlbumServlet\").forward(request, response);','test ','servlets',1,NULL),(4060,'RequestDispatcher.forward: \n\nforward should be called before the response has been committed to the client (before response body output has been flushed). If the response already has been committed, this method throws ...','... an IllegalStateException. \n\nUncommitted output in the response buffer is automatically cleared before the forward. ','EE/Servlets',1,NULL),(4061,'protected void doPost() {\n    if (someCondition) {\n        sendRedirect();\n    }\n    forward(); \n}\n\nsomeCondition is true.','You will get an IllegalStateException\n\njava.lang.IllegalStateException: Cannot forward after response has been committed\n\nto fix this do this; \n\nprotected void doPost() {\n    if (someCondition) {\n        sendRedirect();\n        return;\n    }\n    forward();\n}','EE/Servlets',1,NULL),(4062,'What is the DispatcherType of a RequestDispatcher after calling its forward() method ?','DispatcherType.FORWARD','EE/Servlets',1,NULL),(4063,'What is the initial DispatcherType of a Request ?','DispatcherType.REQUEST','EE/Servlets',1,NULL),(4064,'interface javax.servlet.ServletRequest\n\nServletRequest.getDispatcherType\n\nsubinterface:\n\nHttpServletRequest\n\n\nServletRequest.getDispatcherType()\n\n','Gets the dispatcher type of this request.\n\nThe dispatcher type of a request is used by the container to select the filters that need to be applied to the request: Only filters with matching dispatcher type and url patterns will be applied.\n\nAllowing a filter that has been configured for multiple dispatcher types to query a request for its dispatcher type allows the filter to process the request differently depending on its dispatcher type.\n\nThe initial dispatcher type of a request is defined as DispatcherType.REQUEST. The dispatcher type of a request dispatched via RequestDispatcher.forward(ServletRequest, ServletResponse) or RequestDispatcher.include(ServletRequest, ServletResponse) is given as DispatcherType.FORWARD or DispatcherType.INCLUDE, respectively, while the dispatcher type of an asynchronous request dispatched via one of the AsyncContext.dispatch() methods is given as DispatcherType.ASYNC. Finally, the dispatcher type of a request dispatched to an error page by the container\'s error handling mechanism is given as DispatcherType.ERROR.','EE/Servlets',1,NULL),(4065,'interface javax.servlet.RequestDispatcher\n\nRequestDispatcher.include()','Includes the content of a resource (servlet, JSP page, HTML file) in the response. In essence, this method enables programmatic server-side includes.\n\nThe ServletResponse object has its path elements and parameters remain unchanged from the caller\'s. The included servlet cannot change the response status code or set headers; any attempt to make a change is ignored.\n\nThe request and response parameters must be either the same objects as were passed to the calling servlet\'s service method or be subclasses of the ServletRequestWrapper or ServletResponseWrapper classes that wrap them.\n\nThis method sets the dispatcher type of the given request to DispatcherType.INCLUDE.','EE/Servlets',1,NULL),(4066,'What can cause RequestDispatcher.include() to throw an illegalstateexpetion ?','Nothing .include() does not throw an IllegalStateExcpetion, it only throws a servlet exception or IOexception. ','EE/Servlets',1,NULL),(4067,' Calling include() before forward() throws IllegalStateException - why?','Because, the RequestDispatcher.include() method calls response.flushBuffer() method and this flushBuffer() method sets the \'committed\' flag for that response object. And hence the exception is thrown in such a scenario as we know that any forward() call on a \'committed\' response results in an IllegalStateException. Read more in this article - Why and when an IllegalStateException is thrown?\n\nThus we can conclude that RequestDispatcher.forward() method should typically be used only in the scenarios where the servlet calling this method is not supposed to do anything for building the response. All the response building task should be delegated to the servlet to which the request is forwarded. Any modification to the response object (header or body or both) will simply cause the RequestDispatcher.forward() method to throw an IllegalStateException for the simple reason that the forward() method is not capable to form a data pipeline among multiple servlets. How can we have moduler Response-Writers in Servlets? How can we form the response object by using multiple servlets?','EE/Servlets',1,NULL),(4068,'<% \n        Date now = new Date();\n        SimpleDateFormat sdf = new SimpleDateFormat(\"EEEEEEEE\");\n        String today = sdf.format(now);\n        out.println(today.trim());\n    %>\n\nwhat\'s the type of out ?','javax.servlet.jsp.JspWriter','EE/JSPs',1,NULL),(4069,'JSP Directives dictate properties global to the JSP they take the form : ','<%@ directive_name attribute-1=\"value1\" ... %>','EE/JSPs',1,NULL),(4070,'Three JSP directives','page, include, taglib','EE/JSPs',1,NULL),(4071,'JSP page directive','This directive governs general properties of the JSP, such as characterizing its output, buffering properties, and using imports for java scirplets','EE/JSPs',1,NULL),(4072,'JSP include directive','Allows this jsp to include the content of another file, useful for including a standard header in your jsp','EE/JSPs',1,NULL),(4073,'jsp taglib directive','declares that this jsp will use tags from a speciel tag library. ','EE/JSPs',1,NULL),(4074,'The default threading model for jsps is that they are expected to handle mutliple requests concurrently.\nHowever it can be useful to be able to create jsps that you know will only ever be called by one thread at a time. In such cases, jsp implemetnations may choose make any concurrent requests form a line and invoke only the jsp one thread at a time, or it may choose to instantiate multiple instances of the same JSP, each handling only one request at a time. For this use: \n	\n	','<@page isThreadSafe=\"false\"%>','EE/JSPs',1,NULL),(4075,'<%@page contentType=\"text/html\" pageEncoding=\"UTF-8\"%>\n<!DOCTYPE html>\n<html>\n    <head>\n        <title>JSP Clock</title>\n    </head>\n    <body>\n        <jsp:useBean id=\"mybean\" class=\"Model.ClockBean\"/>\n        \n        <div align=\'center\'>\n            <br/>\n            Hello there !\n            <br/><br/>\n            It\'s been <jsp:getProperty name=\"mybean\" property=\"currentTimeSinceEpoch\"/> milliseconds\n            since midnight, January 1st 1970 \n            <br/><br/>\n            In other words, its \n            <jsp:getProperty name=\"mybean\" property=\"readableDate\"/>\n            <br/><br/>\n            <jsp:setProperty name=\"mybean\" property=\"dateFormat\" value=\"MMMMMMMM\"/>\n            or in other words it the month of <jsp:getProperty name=\"mybean\" property=\"readableDate\"/>\n            in\n            <jsp:setProperty name=\"mybean\" property=\"dateFormat\" value=\"YYYY\" />\n            <jsp:getProperty name=\"mybean\" property=\"readableDate\"/>\n        </div>\n    </body>\n</html>\n','public class ClockBean implements Serializable {\n    String dateFromat = \"EEEEEEEE\";\n    \n    public void setDateFormat(String dateFormat){\n        this.dateFromat = dateFormat;\n    }\n    \n    public long getCurrentTimeSinceEpoch(){\n        return System.currentTimeMillis();\n    }\n    \n    public String getReadableDate() {\n        Date now = new Date();\n        SimpleDateFormat sdf = new SimpleDateFormat(this.dateFromat);\n        String today = sdf.format(now);\n        return today;\n    }\n}','EE/Beans',1,NULL),(4076,'<html>\n    <jsp:useBean id=\"weekBean\" class=\"Model.MyWeek\"/>\n    <jsp:setProperty name=\"weekBean\" property=\"name\" value=\"Danny\"></jsp:setProperty>\n    <head>\n        <meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\">\n        <title>Week Example</title>\n    </head>\n    <body><div align=\'center\'>\n        \n        <h2>${weekBean.description}</h2>\n        There are of course <jsp:getProperty name=\"weekBean\" property=\"numberDays\"/> days in the week<p>\n        <jsp:getProperty name=\"weekBean\" property=\"name\"/> works on\n        <c:forEach var=\"day\" items=\"${weekBean.workingDays}\">\n            ${day},\n        </c:forEach>\n            leaving ${weekBean.numberDays - weekBean.numberWorkingDays} days to enjoy other things in life.<p>\n        <c:set var=\"numberDaysOff\" scope=\"session\" value=\"${weekBean.numberDays - weekBean.numberWorkingDays}\"/>\n        That means ${weekBean.name} is working ${100 * weekBean.numberWorkingDays / weekBean.numberDays}% of the time\n        <p>\n        <c:if test=\"${weekBean.numberWorkingDays > (weekBean.numberDays - weekBean.numberWorkingDays)}\" >\n            This is far from ideal :(\n            <p>\n        </c:if> \n        <c:if test=\"${weekBean.weekendOff && !((weekBean.numberDays - weekBean.numberWorkingDays) == 0)}\" >\n            But at least ${weekBean.name} gets some time off and it is at the weekend\n        </c:if> \n    </div></body>  \n</html>','El can be used instead of <jsp:getProperty /> ','EE/EL',1,NULL),(4077,'What does it take for a class to be a JavaBean ?','all properties are private and the class uses getters/setters\na public no-arg constructor\nimplements serializable\n','EE/EL',1,NULL),(4078,'<rtexprvalue>true</rtexprvalue>','Runtime expression value, means the attribute can be set by a scriptlet or a EL.','EE/Tags',1,NULL),(4079,'public class PhotoAlbum {\n    public static String ATTRIBUTE_NAME = \"Photo_Album\";\n    private List<byte[]> photoDataList = new ArrayList<byte[]> ();\n    private List<String> names = new ArrayList<String>();\n        \n    public PhotoAlbum() {\n    }\n    \n    public void setSession(HttpSession session) {\n        session.setAttribute(ATTRIBUTE_NAME, this);\n    }\n\n\n<jsp:setProperty name=\"photoAlbum\" property=\"session\" value=\"<%=session%>\"/>','Use a jsp action to set the value of a bean to a jsp implicit object using a scriplet','EE/Tags',1,NULL),(4080,'<c:forEach var=\"i\" begin=\"1\" end=\"${photoAlbum.photoCount}\">\n        <td align=\'center\'>\n              <a href=\'RemovePhotoServlet?photo=${i-1}\'>remove</a>\n         </td>    \n</c:forEach> ','<c:forEach is a standard tag whose end attribute accesses the photoAlbum bean using EL,\nthis creates a series of links that send a get request to removePhoto servlet setting the photo number as an attribute. ','EE/Tags',1,NULL),(4081,'   <servlet>\n        <servlet-name>Faces Servlet</servlet-name>\n        <servlet-class>javax.faces.webapp.FacesServlet</servlet-class>\n        <load-on-startup>1</load-on-startup>\n    </servlet>\n    <servlet-mapping>\n        <servlet-name>Faces Servlet</servlet-name>\n        <url-pattern>*.xhtml</url-pattern>\n    </servlet-mapping>','route requests for the jsf pages(indicated by *.xhtml) to the FacesServlet class that is part of the JSF API','EE/ServerFaces',1,NULL),(4082,'web.xml:\n------------\n<web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\"\n	 xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n	 xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd\"\n	 version=\"3.1\">\n    <context-param>\n        <param-name>javax.faces.PROJECT_STAGE</param-name>\n        <param-value>Development</param-value>\n    </context-param>\n        <session-timeout>\n            30\n        </session-timeout>\n    </session-config>\n    <welcome-file-list>\n        <welcome-file>index.jsp</welcome-file>\n    </welcome-file-list>\n</web-app>\n\nbody of jsf\n---------------\n<body>\n        <div align=\"center\">\n            <br></br>\n            <h:form >\n                <h:inputText value=\"#{myHelloBean.name}\"/>\n            </h:form>\n            <br></br>\n            Hello to you, #{myHelloBean.name} !\n        </div>\n    </body>','result will show Hello to you, #{myHelloBean.name}! \nwithout the annotation in myBean or a mapping in the web.xml jsf cannot be interpreted by the FacesServlet.','EE/ServerFaces',1,NULL),(4083,' simple jsf\n----------------------- \n\n<body>\n        <div align=\"center\">\n            <br></br>\n            <h:form >\n                <h:inputText value=\"#{HelloBean.name}\"/>\n            </h:form>\n            <br></br>\n            Hello to you, #{HelloBean.name} !\n        </div>\n    </body>\n\nBean\n-------------\n@Named(value = \"HelloBean\")\n@RequestScoped\npublic class HelloBean {\n    private String name = \"dear reader\";\n    \n    public void setName(String name) {\n        this.name = name;\n    }\n    \n    public String getName() {\n        return this.name;\n    }  \n}\n','result will show what you type in the input box, there is no need to import the bean or anything. The input textbox will appear with the value \'dear reader\'. ','EE/ServerFaces',1,NULL),(4084,'@RequestScoped',' Specifies that a bean is request scoped.\n\nThe request scope is active:\n\n    during the service() method of any servlet in the web application, during the doFilter() method of any servlet filter and when the container calls any ServletRequestListener or AsyncListener,\n    during any Java EE web service invocation,\n    during any remote method invocation of any EJB, during any asynchronous method invocation of any EJB, during any call to an EJB timeout method and during message delivery to any EJB message-driven bean, and\n    during any message delivery to a MessageListener for a JMS topic or queue obtained from the Java EE component environment.\n\nThe request context is destroyed:\n\n    at the end of the servlet request, after the service() method, all doFilter() methods, and all requestDestroyed() and onComplete() notifications return,\n    after the web service invocation completes,\n    after the EJB remote method invocation, asynchronous method invocation, timeout or message delivery completes, or\n    after the message delivery to the MessageListener completes.\n','EE/Anotations',1,NULL),(4085,'What\'s the difference between JSPs and JSFs ?','JSPs are part of the java technology family and are compiled into servlets and may call beans,\n\nJSF is a framework for building user interfaces and application that includes apis for representing ui components, \n\nYou can use JSF tags in a jsp.\n\n\nJSP is a specialized kind of servlet.\n\nJSF is a set of tags you can use with JSP.\n\nFrom the browser client prespective jsp and jsf look the same. A jsp is converted into a servlet and only has minimal behavior. \n\nA jsf is more suited for a richer environment, it is converted into a component tree by the FacesServlet, follows component lifecycle defined by spec. ','EE/JSF',1,NULL),(4086,'\n\nThere are also situations where you can favor JSP over JSF. The application nature should be the deciding factor to choose the technology.\n\nIf you have a rich GUI interaction and lot of Java scripting needed then favor JSF. Basically if your GUI app architecture is like Component oriented & even driven like Swing then JSF is the best.\n\nIf the application is just a plain form submitting, not much of GUI interaction needed, then JSP could do well if learning a new tech is an overhead and also complex framework is unnecessary.\n','','EE/JSF',1,NULL),(4087,'\n\n    Servlets :\n\n    The Java Servlet API enables Java developers to write server-side code for delivering dynamic Web content. Like other proprietary Web server APIs, the Java Servlet API offered improved performance over CGI; however, it has some key additional advantages. Because servlets were coded in Java, they provides an object-oriented (OO) design approach and, more important, are able to run on any platform. Thus, the same code was portable to any host that supported Java. Servlets greatly contributed to the popularity of Java, as it became a widely used technology for server-side Web application development.\n\n    JSP :\n\n    JSP is built on top of servlets and provides a simpler, page-based solution to generating large amounts of dynamic HTML content for Web user interfaces. JavaServer Pages enables Web developers and designers to simply edit HTML pages with special tags for the dynamic, Java portions. JavaServer Pages works by having a special servlet known as a JSP container, which is installed on a Web server and handles all JSP page view requests. The JSP container translates a requested JSP into servlet code that is then compiled and immediately executed. Subsequent requests to the same page simply invoke the runtime servlet for the page. If a change is made to the JSP on the server, a request to view it triggers another translation, compilation, and restart of the runtime servlet.\n\n    JSF :\n\n    JavaServer Faces is a standard Java framework for building user interfaces for Web applications. Most important, it simplifies the development of the user interface, which is often one of the more difficult and tedious parts of Web application development.\n    Although it is possible to build user interfaces by using foundational Java Web technologies(such as Java servlets and JavaServer Pages) without a comprehensive framework designedfor enterprise Web application development, these core technologies can often lead to avariety of development and maintenance problems. More important, by the time the developers achieve a production-quality solution, the same set of problems solved by JSF will have been solved in a nonstandard manner. JavaServer Faces is designed to simplify the development of user interfaces for Java Web applications in the following ways:\n    • It provides a component-centric, client-independent development approach to building Web user interfaces, thus improving developer productivity and ease of use.\n    • It simplifies the access and management of application data from the Web user interface.\n    • It automatically manages the user interface state between multiple requests and multiple clients in a simple and unobtrusive manner.\n    • It supplies a development framework that is friendly to a diverse developer audience with different skill sets.\n    • It describes a standard set of architectural patterns for a web application.\n','','EE/JSF',1,NULL),(4088,'bean\n---------------\n@Named(\"partyBean\")\n@SessionScoped\npublic class PartyBean implements Serializable {\n    private String name;\n    private boolean parentsAllowed;\n    private List<Guest>items;\n    private String imageUri;\n    \n    public PartyBean() {\n        this.reset();\n    }\n    \n    public String getImageUri() {\n        return this.imageUri;\n    }\n}\n\nserver face:\n---------------------\n<h:form>\n                <label style=\"font-weight:bold\"> Party Pieces </label> <br/><br/>\n                <label>Choose a title: </label>\n                <h:inputText value =\"#{partyBean.name}\" ></h:inputText><br/>\n                <label>Choose a picture: </label>\n                <h:selectOneMenu value=\"#{partyBean.imageUri}\">\n                    <f:selectItem itemValue=\"party1.jpg\" itemLabel=\"Hats\" />\n                    <f:selectItem itemValue=\"party2.jpg\" itemLabel=\"Balloons\" />	   							\n                </h:selectOneMenu><br/>\n                <label>Are parents allowed ? </label>    \n                <h:selectBooleanCheckbox value=\"#{partyBean.parentsAllowed}\" ></h:selectBooleanCheckbox><br/>\n                <h:commandButton value=\"Submit picture and parent choices\" action=\"partyplanner\" /><br/>\n                <h:commandButton value=\"Reset to default\" action=\"#{partyBean.reset}\" /><br/><br/>\n            </h:form>\n\nWhat is the scope of this bean ? ','This bean is session scoped and managed, so if you access an application using this bean from a different browser then any changes saved in the first will not be visible to you. \n\nSince it is managed you don\'t need to instantiate it with \'useBean\'\n\nwithout the @Named(\"partyBean\") you would get this \n\n/partyplanner.xhtml @14,58 value=\"#{partyBean.name}\": Target Unreachable, identifier \'partyBean\' resolved to null\n\nsince the container was not notified of this bean\'s existance. \n\n','EE/JSF',1,NULL),(4089,'@SessionScoped\npublic Class BigBean implements Serializable {\n   private String name;\n   public BigBean(){ }\n    private getName(){\n      return name;\n   }\n   private setName(String name){\n      this.name = name;\n   }\n}\n\n<h:form>\n       <label style=\"font-weight:bold\"> Party Pieces </label> <br/><br/>\n         <label>Choose a title: </label>\n       <h:inputText value =\"#{BigBean.name}\" ></h:inputText><br/>\n</h:form>\n\nwhat happens when you press enter ? ','Target Unreachable, identifier \'BigBean\' resolved to null','EE/JSF',1,NULL),(4090,'How do you make a managed bean available for use by nae within a javaserver faces page ?','Annotate it with @Named(\" bean-name \")\n\n@ManagedBean was used in older jsf applications ','EE/JSF',1,NULL),(4091,'@RequestScoped','Bean scope annotation \n\na managed bean is instantiated once for every request/response interaction, created as the http request arrives and destroyed once the response leaves. \n\na good usecase would be a bean that backs a javaserver face page that gathers contact information then submits it to a DB once the user presses the submit button. ','EE/JSF',1,NULL),(4092,'@SessionScoped\n\nbean annotation','This bean has the same lifecycle as the HttpSession, \n\nThe bean is created once for each new HttpSession that is created and destroyed when the httpsession to whic hthe java ee webcontainer is associated either times out or is invalidated. \n\neach use of the application will have a unique instance of the bean backing thier jsf.\n\nUseful when you want to associate the application state with a particular user that survives as long as teh user is stil acitve in the application. ','EE/JSF',1,NULL),(4093,'@ApplicationScoped \n\nbean annotation','The simplest of all, this bean is created once prior to any users accessing the application and destroyed prior to shutting down the application, This makes this bean a kind of global object that all users have access to, shared for the lifetime of the application. \n\nUseful for application data that is globabl to the application: for instance a chat transcipt, a log of all users, or a history ','EE/JSF',1,NULL),(4094,'@ConversationScoped\n\nbean annotation','a type of scope that is instantiated for evey new HTtpSession and can be destroyed by the developer or when the session ends. \n\nUseful when you want a predefined set of interactions with a web application, perhaps the sequence of chats. \n\nTo end a conversation scoped bean use dependcy injection:\n\n@Name(value=\"HelloBean\")\n@RequestScoped\npublic class ConversationBean {\n   @Inject\n    Conversation conversation;\n\n    public void finishINteractions() {\n       conversation.end();\n   }\n\n  ...\n}','EE/JSF',1,NULL),(4095,'@Name(value=\"HelloBean\")\n@RequestScoped\npublic class ConversationBean {\n   @Inject\n    Conversation conversation;\n\n    public void finishINteractions() {\n       conversation.end();\n   }\n\n  ...\n}\n\nwhat happens the next a jsf page tries to use this managed bean after its conversation has ended ? ','javax.enterprise.context.Conversation\n\na new one is instantiated. ','EE/JSF',1,NULL),(4096,'@FlowScoped\n\nbean annotation\n','contained with the session scop, like conversation scope. \n\nScope is new during a preset sequence of interactions with the web application from a given user. \n\nbut instead of being explicitly managed by API calls from the developer, the boundaries of flow scope are managed by a mechanism in JSF called faces flow ','EE/JSF',1,NULL),(4097,'@ViewScoped','view scope extends request scope by starting while a page is being executed and remains active while the client continues to interact with that same page. Scope becomes inactive once the clinet navigates to a different page. \n\nUseful when coding pages that you expect to post back to themselves. ','EE/JSF',1,NULL),(4098,'@Dependent','\"My scope depends on where i am used. \" \n\nThe lifecycle and cardinality are governed by the componenet that uses it. \n\nuseful for working in components that act in more than one scope, if you have a component that makes currency conversions, you may wish to use this from a javabean that is request scope converting currencies on a single web page, or you may use it from a session-scoped bean that represents a shopping cart for international customers. \n','EE/JSF',1,NULL),(4099,'Which tags can be used to validate Beans?','<f:validateBean>\n<f:validateRegex>','EE/JSF',1,NULL),(4100,'<h:form>\n   <h:inputText id=\"username_component\" validatorMessage=\"Username must between 4 and 10 characters\"/>\n<f:validateLength minimun=\"4\" maximum=\"10/>\n</h:form>','validate length','EE/JSF',1,NULL),(4101,'<f:validateBean>','Checks a value against an implementation of the beans binding api:\njavax.faces.validator.BeanValidator\n','EE/JSF',1,NULL),(4102,'<f:validateRegex>','Checks a value against a regulare expression. Either in the form of a regex expression String: <f:validateRegex patter=\"/[0-9a--zA-Z]\"/>\nor as an implementations of the javax.faces.validator.RegexValidator class: \n\n<f:validateRegex binding=\"myRegexValidator\">','EE/JSF',1,NULL),(4103,'<f:validator validatorId=\"sharkValidator\">','@FacesValidator(\"sharkValidator\")\npublic class MyValidator implements Validator {\n	public void validate(FacesContext context, UIComponent component, Object Value) throws ValidatroException {\n\n	//check value\n	// throw exception if it does not pass the check\n}\n\n*how do the parameters get passed here ? ','EE/JSF',1,NULL),(4104,'<f:actionListener>','for use with command buttons and links this tag resisters teh given implementation of javax.faces.event.ActionListener which is then notified when teh components state changes. \n\n<f:actionListener type=\"classname\" >\n<f:actionListener binding=\"expression evaluating listener instance\">','EE/JSF',1,NULL),(4105,'<f:valueChangeListener>','For use with all input components and list, this tag registers the given implementation of javax.faces.event.ValueChangeListener, which is then notified when the component\'s state changes. \n\ntype=\"class\"\n\nbinding = \"expression\"','EE/JSF',1,NULL),(4106,'<f:setPropertyActionListener>\n\nfor use with command buttons and links this tag lets you directlt set the balue of a property on a mangaed bean. ','for use with command buttons and links this tag lets you directlt set the balue of a property on a mangaed bean. \n\n<f:setPropertyActionListener target=\"#{Bean.name}\" value=\"#{namelist.currentname}\">','EE/JSF',1,NULL),(4107,'two prebuilt most common data conversion tags in the <f: core library ?','<f:convertNumber> Converts a Double or Long object to and from a variety of formats, including standard currency formats and numbers specifying ranges for the nnumber of integer and fractional part digits \n\njavax.faces.convert.NumberConverter','EE/JSF',1,NULL),(4108,'<f:convertDateTime>','Converts a Date object to and from a variety of human readable date formats suitable for a variety of locales and teim zones, \n\njavax.faces.convert.DateTimeConverter\n\nlike validators these converters are added as subelemetns to input elements. ','EE/JSF',1,NULL),(4109,'What is used to define your own jsf converter ?','javax.faces.converter.Converter interface. \n\nNest <f:converter converterID=\"converter-name\"> within a component. \n\nimplement the converter interface and two method: \n\npublic String getAsString(FacesContext con, UIComponent com, Object value)\npublic Object getAsObject(FacesContext con, UICommponent, String value)\n\nthen name your converter class to be hooked to the tag with the annotation:\n@FacesConverter(\" name \")','EE/JSF',1,NULL),(4110,'JSTL Core tags can also be used in JSF page:','<c:catch> \ncatches any throwables within this tag uses the name of the var attribute to hold it\n\n<c:choose> \nDefines a set of mutually exclusive choices, used in conjunction with the <c:when> <c:otherwise> tags like a switch statement\n\n<c:if>\n\n<c:foreach>\n\n<c:set> set a page variable by name\n\n<c:when> simple conditional tag\n','EE/JSF',1,NULL),(4111,'@Named(value = \"photoBook\")\n@SessionScoped\npublic class PhotoBook implements Serializable { \n    private List<Photo> photos = new ArrayList<>();\n    private Photo currentPhoto = null;\n       \n    public PhotoBook() {\n        \n    }\n    \n    public void setCurrentPhoto(Photo p) {\n        System.out.println(\"setcurrent \" + p);\n        this.currentPhoto = p;\n    }\n    \n    public Photo getCurrentPhoto() {\n        return this.currentPhoto;\n    }\n}\n\nSay two clients access this application from two seperate locations. How many instances will be created ?','2 \n\nSessionScoped beans are created once for every new client. ','EE/Beans',1,NULL),(4112,'What annotation is needed for a class to be used as a validator in: \n\n<f:validator validatorId=\"imageUploadValidator\" /> ?\n\nWhat interface needs to be implemented ?\n\nWhat method overriden if any, and if so what is its signature ?','@FacesValidator(\"imageUploadValidator\")\npublic class ImageUploadValidator implements Validator {\n\n    @Override\n    public void validate(FacesContext context, UIComponent component, Object value) throws ValidatorException {\n        Part file = (Part) value;\n        if (!file.getContentType().equals(\"application/octet-stream\")\n                && !file.getContentType().equals(\"image/jpeg\")) {\n            throw new ValidatorException(new FacesMessage(\"The file you tried to upload is not an image file. Please try again.\"));\n        }\n    }\n    \n    \n    \n}','EE/Validators',1,NULL),(4113,'What\'s a CDI Bean ?','\n\n    CDI beans are classes that CDI can instantiate, manage, and inject automatically to satisfy the dependencies of other objects. Almost any Java class can be managed and injected by CDI.\n\nFor example, PrintServlet got dependency on a Message instance and have it injected automatically by the CDI runtime.\n\nPrintServlet.java\n\n@WebServlet(\"/printservlet\")\npublic class PrintServlet extends HttpServlet {\n    @Inject private Message message;\n\n    @Override\n    public void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        response.getWriter().print(message.get());\n    }\n}\n\nMessage.java (This class is a CDI bean)\n\n@RequestScoped\npublic class Message {\n    @Override\n    public String get() {\n        return \"Hello World!\";\n    }\n}','EE/Beans',1,NULL),(4114,'<h:commandButton value=\"submit\" actionListener=\"#{bean.actionListener}\" action=\"#{bean.action}\">\n    <f:actionListener type=\"com.example.ActionListenerType\" />\n    <f:actionListener binding=\"#{bean.actionListenerBinding()}\" />\n    <f:setPropertyActionListener target=\"#{bean.property}\" value=\"some\" />\n    <f:ajax listener=\"#{bean.ajaxListener}\" />\n</h:commandButton>\n\nWill invoke these methods in what order ? ','f:ajax listener is always invoked before any action listener so it is first, and actionListeners are always invoked before action method. \n\n\n    Bean#ajaxListener()\n    Bean#actionListener()\n    ActionListenerType#processAction()\n    Bean#actionListenerBinding()\n    Bean#setProperty()\n    Bean#action()\n \n\n','EE/JSF',1,NULL),(4115,'When a user interacts with a component the JSF can be handle the event in two ways : \n','Method Binding: \n\nPass the name of the managed bean method to the actionListener on the UI component\n\nAction Listener:\n\nimplement action listener interface and pass the implementation class name to the action listener attribute of the UI component\n\n','EE/JSF',1,NULL),(4116,'What\'s the difference between @Named and @ManagedBean when marking a bean ?','ManagedBean is deprecated...\n\nThe core difference is, @ManagedBean is managed by JSF framework and is only via @ManagedProperty available to another JSF managed beans. @Named is managed by application server (the container) via CDI framework and is via @Inject available to any kind of a container managed artifact like @WebListener, @WebFilter, @WebServlet, @Path, @Stateless, etc and even a JSF @ManagedBean. From the other side on, @ManagedProperty does not work inside a @Named or any other container managed artifact. It works really only inside @ManagedBean.\n\nAnother difference is that CDI actually injects proxies delegating to the current instance in the target scope on a per-request/thread basis (like as how EJBs are been injected). This mechanism allows injecting a bean of a narrower scope in a bean of a broader scope, which isn\'t possible with JSF @ManagedProperty. JSF \"injects\" here the physical instance directly by invoking a setter (that\'s also exactly why a setter is required, while that is not required with @Inject).\n\nWhile not directly a disadvantage — there are other ways — the scope of @ManagedBean is simply limited. From the other perspective, if you don\'t want to expose \"too much\" for @Inject, you can also just keep your managed beans @ManagedBean. It\'s like protected versus public. But that doesn\'t really count.\n\nAt least, in JSF 2.0/2.1, the major disadvantage of managing JSF backing beans by CDI is that there\'s no CDI equivalent of @ViewScoped. The @ConversationScoped comes close, but still requires manually starting and stopping and it appends an ugly cid request parameter to outcome URLs. MyFaces CODI makes it easier by fully transparently bridging JSF\'s javax.faces.bean.ViewScoped to CDI so you can just do @Named @ViewScoped, however that appends an ugly windowId request parameter to outcome URLs, also on plain vanilla page-to-page navigation. OmniFaces solves this all with a true CDI @ViewScoped which really ties the bean\'s scope to JSF view state instead of to an arbitrary request parameter.\n\nJSF 2.2 (which is released 3 years after this question/answer) offers a new fully CDI compatible @ViewScoped annotation out the box in flavor of javax.faces.view.ViewScoped. JSF 2.2 even comes along with a CDI-only @FlowScoped which doesn\'t have a @ManagedBean equivalent, hereby pushing JSF users towards CDI. The expectation is that @ManagedBean and friends will be deprecated as per Java EE 8. If you\'re currently still using @ManagedBean, it\'s therefore strongly recommend to switch to CDI to be prepared for future upgrade paths. CDI is readily available in Java EE Web Profile compatible containers, such as WildFly, TomEE and GlassFish. For Tomcat, you have to install it separately, exactly as you already did for JSF. See also How to install CDI in Tomcat?','EE/JSF',1,NULL),(4117,'what\'s the difference between @ManagedBean and @Named','@ManagedBean is deprecated it was originally used to manage beans only by the JSF framework where @Named Beans are managed by CDI','EE/JSF',1,NULL),(4118,'How can you navigate with action attribute of commandButton','hardcode the name of the page to navigate to, if the method passed to action attribute returns a string that will be the page to navigate to, if it returns null or void the current page will remain and the view scope will remain alive. \n\nA return value of an empty string or the same view ID will also return to the same page, but recreate the view scope and thus destroy any currently active view scoped beans and, if applicable, recreate them. \n\nThe action method can be any valid MethodExpression, also the ones which uses EL 2.2 arguments such as below:\n\n<h:commandXxx value=\"submit\" action=\"#{bean.edit(item)}\" />\n\nWith this method:\n\npublic void edit(Item item) {\n    // ...\n}\n\nNote that when your action method solely returns a string, then you can also just specify exactly that string in the action attribute. Thus, this is totally clumsy:\n\n<h:commandLink value=\"Go to next page\" action=\"#{bean.goToNextpage}\" />\n\nWith this senseless method returning a hardcoded string:\n\npublic String goToNextpage() {\n    return \"nextpage\";\n}\n\nInstead, just put that hardcoded string directly in the attribute:\n\n<h:commandLink value=\"Go to next page\" action=\"nextpage\" />','EE/JSF',1,NULL),(4119,'<h:body>\n        <h:form>\n            <h:outputLabel for=\"username\" value=\"User Name\"/>\n            <h:inputText id=\"username\" value=\"#{User.name}\"/>\n            <h:outputLabel for=\"userprofile\" value=\"Profile\"/>\n            <h:inputText value=\"#{User.profile}\"/>\n            <h:outputLabel for=\"userssn\" value=\"Social Security Number\"/>\n            <h:inputText id=\"userssn\" value=\"#{User.ssn}\"/>\n            <h:outputLabel for=\"userbalance\" value=\"Balance\"/>\n            <h:inputText id=\"userbalance\" value=\"#{User.balance}\"/>\n            <h:commandButton id=\"createuser\" value=\"Add User\" action=\"#{User.showUser}\"/>\n        </h:form>\n        <h:outputText value=\"#{User.UserStatement}\"/>\n    </h:body>\n\n\n@Named(value=\"User\")\n@RequestScoped\npublic class User implements Serializable{\n    private String name;\n    private String profile;\n    private String ssn;\n    private Integer balance;\n    private String statement;\n    \n    public User(){\n        \n    }\n    \n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public String getProfile() {\n        return profile;\n    }\n\n    public void setProfile(String profile) {\n        this.profile = profile;\n    }\n\n    public String getSsn() {\n        return ssn;\n    }\n\n    public void setSsn(String ssn) {\n        this.ssn = ssn;\n    }\n\n    public Integer getBalance() {\n        return balance;\n    }\n\n    public void setBalance(Integer balance) {\n        this.balance = balance;\n    }\n    \n    public String getUserStatement(){\n        return this.statement;\n    }\n    \n    public String showUser(){\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"The user is created is named\");\n        sb.append(this.name);\n        sb.append(\"Their ssn is:\");\n        sb.append(this.ssn);\n        this.statement = sb.toString();\n        return null;\n    }\n   \n}','/index.xhtml @20,54 value=\"#{User.UserStatement}\": The class \'Beans.User\' does not have the property \'UserStatement\'.','EE/JSF',1,NULL),(4120,'<h:outputLabel for=\" ...','So the for attribute must point to the id of the input component the label is intented to label. The label has the following SEO and usability advantages:\n\n    It tells in text about the associated input element.\n    It focuses and activates the associated input element when being focused/clicked itself.\n\nAs JSF is in the context of this question merely a HTML code generator, exactly the same applies to JSF components generating that HTML as well.\n\n<h:outputLabel for=\"email\">Email address</h:outputLabel>\n<h:inputText id=\"email\" />\n\nSearchbots will find the label and index the associated input element as such. Screenreaders as used by visually disabled people will find the label and tell its contents by sound. Endusers can click the label to see the associated input getting focused. Checkboxes/radiobuttons will be selected when clicking the label. File inputs will open the browse dialog when clicking the label. Etcetera.\n\nNoted should be that relatively a lot of low-quality JSF tutorials are abusing the <h:outputLabel> with the sole purpose to print out some Hello World text like so:\n\n<h:outputLabel value=\"#{bean.message}\" />\n\nThis particular use case is thus wrong. Instead, a <h:outputText> should have been used:\n\n<h:outputText value=\"#{bean.message}\" />\n\nOr even just EL in template text:\n\n#{bean.message}','EE/JSF',1,NULL),(4121,'Which jsf component will generate a <a> tag ?','<h:commandLink/>','EE/JSF',1,NULL),(4122,'Abusing an @ApplicationScoped bean for session/view/request scoped data would make it to be shared among all users, so anyone else can see each other\'s data which is just plain wrong. Abusing a @SessionScoped bean for view/request scoped data would make it to be shared among all tabs/windows in a single browser session, so the enduser may experience inconsitenties when interacting with every view after switching between tabs which is bad for user experience. Abusing a @RequestScoped bean for view scoped data would make view scoped data to be reinitialized to default on every single (ajax) postback, causing possibly non-working forms (see also points 4 and 5 here). Abusing a @ViewScoped bean for request, session or application scoped data, and abusing a @SessionScoped bean for application scoped data doesn\'t affect the client, but it unnecessarily occupies server memory and is plain inefficient.','','EE/Beans',1,NULL),(4123,'Which scope to choose depends solely on the data (the state) the bean holds and represents. Use @RequestScoped for simple and non-ajax forms/presentations. Use @ViewScoped for rich ajax-enabled dynamic views (ajaxbased validation, rendering, dialogs, etc). Use @FlowScoped for the \"wizard\" (\"questionnaire\") pattern of collecting input data spread over multiple pages. Use @SessionScoped for client specific data, such as the logged-in user and user preferences (language, etc). Use @ApplicationScoped for application wide data/constants, such as dropdown lists which are the same for everyone, or managed beans without any instance variables and having only methods.','','EE/Beans',1,NULL),(4124,'Note that the scope should rather not be chosen based on performance implications, unless you really have a low memory footprint and want to go completely stateless; you\'d need to use exclusively @RequestScoped beans and fiddle with request parameters to maintain the client\'s state. Also note that when you have a single JSF page with differently scoped data, then it\'s perfectly valid to put them in separate backing beans in a scope matching the data\'s scope. The beans can just access each other via @ManagedProperty in case of JSF managed beans or @Inject in case of CDI managed beans.','','EE/Beans',1,NULL),(4125,'The JSF @NoneScoped and CDI @Dependent basically lives as long as a single EL-evaluation on the bean. Imagine a login form with two input fields referring a bean property and a command button referring a bean action, thus with in total three EL expressions, then effectively three instances will be created. One with the username set, one with the password set and one on which the action is invoked. You normally want to use this scope only on beans which should live as long as the bean where it\'s being injected. So if a @NoneScoped or @Dependent is injected in a @SessionScoped, then it will live as long as the @SessionScoped bean.','','EE/Beans',1,NULL),(4126,'userbean\n--------------------\n@Named(value=\"User\")\n@RequestScoped\npublic class User implements Serializable{\n    private String name;\n    private String profile;\n    private String ssn;\n    private Integer balance;\n    private String statement;\n    \n    public User(){\n        \n    }\n    \n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public String getProfile() {\n        return profile;\n    }\n\n    public void setProfile(String profile) {\n        this.profile = profile;\n    }\n\n    public String getSsn() {\n        return ssn;\n    }\n\n    public void setSsn(String ssn) {\n        this.ssn = ssn;\n    }\n\n    public Integer getBalance() {\n        return balance;\n    }\n\n    public void setBalance(Integer balance) {\n        this.balance = balance;\n    }\n    \n    public String getUserStatement(){\n        return this.statement;\n    }\n    \n    public String showUser(){\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"The user is created is named\");\n        sb.append(this.name);\n        sb.append(\"Their ssn is:\");\n        sb.append(this.ssn);\n        this.statement = sb.toString();\n        return null;\n    }\n   \n}\n\nindex\n------------\n<h:body>\n        <h:form>\n            <h:outputLabel for=\"username\" value=\"User Name\"/>\n            <h:inputText id=\"username\" value=\"#{User.name}\"/>\n            <h:outputLabel for=\"userprofile\" value=\"Profile\"/>\n            <h:inputText value=\"#{User.profile}\"/>\n            <h:outputLabel for=\"userssn\" value=\"Social Security Number\"/>\n            <h:inputText id=\"userssn\" value=\"#{User.ssn}\"/>\n            <h:outputLabel for=\"userbalance\" value=\"Balance\"/>\n            <h:inputText id=\"userbalance\" value=\"#{User.balance}\"/>\n            <h:commandButton id=\"createuser\" value=\"Add User\" action=\"#{User.showUser}\"/>\n            <h:commandButton id=\"userlist\" action=\"UserList\" value=\"User List\"/>\n        </h:form>\n        <h:outputText value=\"#{User.userStatement}\"/>\n    </h:body>\n\nuserlist face\n----------------\n<h:head>\n        <title>TODO supply a title</title>\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"/>\n    </h:head>\n    <h:body>\n        #{User.name}\n    </h:body>\n\n\nthe user adds a user then clicks the userlist button what happens ?','The userlist face displays the name of the user just entered, if a user is not first entered then nothing is displayed...','EE/JSF',1,NULL),(4127,'UserBean\n--------------\n@Named(value=\"User\")\n@ViewScoped\npublic class User implements Serializable{\n    private String name;\n    private String profile;\n    private String ssn;\n    private Integer balance;\n    private String statement;\n    \n    public User(){\n        \n    }\n    \n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public String getProfile() {\n        return profile;\n    }\n\n    public void setProfile(String profile) {\n        this.profile = profile;\n    }\n\n    public String getSsn() {\n        return ssn;\n    }\n\n    public void setSsn(String ssn) {\n        this.ssn = ssn;\n    }\n\n    public Integer getBalance() {\n        return balance;\n    }\n\n    public void setBalance(Integer balance) {\n        this.balance = balance;\n    }\n    \n    public String getUserStatement(){\n        return this.statement;\n    }\n    \n    public String showUser(){\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"The user is created is named\");\n        sb.append(this.name);\n        sb.append(\"Their ssn is:\");\n        sb.append(this.ssn);\n        this.statement = sb.toString();\n        return null;\n    }\n   \n}\n\nindex.xhtml\n------------------\n<h:form>\n            <h:outputLabel for=\"username\" value=\"User Name\"/>\n            <h:inputText id=\"username\" value=\"#{User.name}\"/>\n            <h:outputLabel for=\"userprofile\" value=\"Profile\"/>\n            <h:inputText value=\"#{User.profile}\"/>\n            <h:outputLabel for=\"userssn\" value=\"Social Security Number\"/>\n            <h:inputText id=\"userssn\" value=\"#{User.ssn}\"/>\n            <h:outputLabel for=\"userbalance\" value=\"Balance\"/>\n            <h:inputText id=\"userbalance\" value=\"#{User.balance}\"/>\n            <h:commandButton id=\"createuser\" value=\"Add User\" action=\"#{User.showUser}\"/>\n            <h:commandButton id=\"userlist\" action=\"UserList\" value=\"User List\"/>\n        </h:form>\n        <h:outputText value=\"#{User.userStatement}\"/>\n\nUser list face\n-----------------\n<h:head>\n        <title>TODO supply a title</title>\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"/>\n    </h:head>\n    <h:body>\n        #{User.name}\n    </h:body>\n\na user types in their information, adds a user, then navigates to the USer list face. What happens ?','Upon pressing the save user button, the current page is reloaded and therefore the view scoped bean is destroyed, therefore there is no current bean and you get: \n\n/index.xhtml @11,62 value=\"#{User.name}\": Target Unreachable, identifier \'User\' resolved to null','EE/JSF',1,NULL),(4128,'What are the three subclasses of javax.faces.event.FacesEvent','ActionEvent, BehaviorEvent, ValueChangeEvent','EE/JSF',1,NULL),(4129,'Implement a validator that','@FacesValidator(\"imageUploadValidator\")\npublic class ImageUploadValidator implements Validator {\n\n    @Override\n    public void validate(FacesContext context, UIComponent component, Object value) throws ValidatorException {\n        Part file = (Part) value;\n        if (!file.getContentType().equals(\"application/octet-stream\")\n                && !file.getContentType().equals(\"image/jpeg\")) {\n            throw new ValidatorException(new FacesMessage(\"The file you tried to upload is          not an image file. Please try again.\"));\n        }\n    }\n    \n    \n    \n}','EE/JSF',1,NULL),(4130,'public class UserValidator implements Validator {\n    \n    public void validate(FacesContext context,UIComponent component,Object value) {\n        \n    }\n    \n}\n\n... will this compile ?','Yes, though the abstract method in Validator interface declares that it throws a ValidatorException the overriding method can declare that it does not throw any exception and still compile, but this is bad practice, for the Validator to work it must be able to throw a ValidatorException when a value is invalid.','EE/JSF',1,NULL),(4131,'<f:validateLength minimum=\"5\" maximum=\" 10\"/>','NumberFormatException, there is a space before the 10, that won\'t work. ','EE/JSF',1,NULL),(4132,'How can you make an input required and present a message if the requirment is not filled. ','<h:inputText value=\"#{User.profile}\" required=\"true\" requiredMessage=\"Don\'t forget their profile!\"/>','EE/JSF',1,NULL),(4133,'JSP Core tags\n------------------------\ncatch:	\nCatches any Throwable that occurs in its body and optionally exposes it.\n\nchoose:	\nSimple conditional tag that establishes a context for mutually exclusive conditional operations, marked by <when> and <otherwise>\n\nif	\nSimple conditional tag, which evalutes its body if the supplied condition is true and optionally exposes a Boolean scripting variable representing the evaluation of this condition\n\nimport	\nRetrieves an absolute or relative URL and exposes its contents to either the page, a String in \'var\', or a Reader in \'varReader\'.\n\nforEach	\nThe basic iteration tag, accepting many different collection types and supporting subsetting and other functionality\n\nforTokens\n	Iterates over tokens, separated by the supplied delimeters\nout	Like <%= ... >, but for expressions.\notherwise	Subtag of <choose> that follows <when> tags and runs only if all of the prior conditions evaluated to \'false\'\n\nparam	\nAdds a parameter to a containing \'import\' tag\'s URL.\n\nredirect	\nRedirects to a new URL.\n\nremove	\nRemoves a scoped variable (from a particular scope, if specified).\n\nset	\nSets the result of an expression evaluation in a \'scope\'\n\nurl	\nCreates a URL with optional query parameters.\n\nwhen	\nSubtag of <choose> that includes its body if its condition evalutes to \'true\' ','','EE/JSPs',1,NULL),(4134,'','','EE/JSPs',1,NULL),(4135,'@Named(\"TicTacToe\")\n@SessionScoped\npublic class TicTacToeGame implements Serializable{\n    private List<String> squares;\n    \n    public TicTacToeGame(){\n        for(int i =0; i<9; i++){\n            squares.add(\"_\");\n        }\n    }   \n}\n\n...create the use bean tag for this bean','<jsp:useBean id=\"game\" scope=\"session\" class=\"Beans.TicTacToeGame\" \n\n... or ..\n\nbeanName=\"TicTacToe\"/>\n\nif you use class you have to include the package or you can use the beans name according to @Named.','EE/JSPs',1,NULL),(4136,'<jsp:useBean id=\"game\" scope=\"session\" class=\"Beans.TicTacToeGame\" beanName=\"TicTacToe\"/>','Will not compile, cannot specify both class name and bean name. ','EE/JSPs',1,NULL),(4137,'What are the eight officially supported languages on the Heroku Platform? ','Node Ruby JAva PHP Clojure Go Scala Python','SalesforcePD1',1,NULL),(4138,'What are two features of Heroku Connect ?','Bidirectional Sync allowing data to be written into SFDC\nReal Time Sync between salesforce and postgres','SalesforcePD1',1,NULL),(4139,'A Developer needs to test an invoicing system integration. After reviewing the numbers of transaction required for the test, the developer estimates that the test data will total about 2GB of data storage. Production data is not required for integration testing. Which two environments meet the requirements for testing? Choose 2 answers','Full Sandbox\nPartial Sandbox','SalesforcePD1',1,NULL),(4140,'Which three options allow a developer to use stylesheets? ','<Apex:stylesheet> tag\ninline css\na static resource','SalesforcePD1',1,NULL),(4141,'The system saves the records that fired the before trigger after the trigger finishes execution. You can modify the records in the trigger without explicitly calling a DML insert or update operation. If you perform DML statements on those records, you get an error.','','SalesforcePD1',1,NULL),(4142,'Trigger context variables ...\n\nTrigger.XXX ...\n\nisExecuting: 	Returns true if the current context for the Apex code is a trigger, not a Visualforce page, a Web service, or an executeanonymous() API call.\n\nisInsert:	Returns true if this trigger was fired due to an insert operation, from the Salesforce user interface, Apex, or the API.\n\nisUpdate: Returns true if this trigger was fired due to an update operation, from the Salesforce user interface, Apex, or the API.\n\nisDelete: 	Returns true if this trigger was fired due to a delete operation, from the Salesforce user interface, Apex, or the API.\n\nisBefore: 	Returns true if this trigger was fired before any record was saved.\n\nisAfter: 	Returns true if this trigger was fired after all records were saved.\n\nisUndelete 	Returns true if this trigger was fired after a record is recovered from the Recycle Bin (that is, after an undelete operation from the Salesforce user interface, Apex, or the API.)\n\nnew 	Returns a list of the new versions of the sObject records.\n\nThis sObject list is only available in insert, update, and undelete triggers, and the records can only be modified in before triggers.\n\nnewMap 	A map of IDs to the new versions of the sObject records.\n\nThis map is only available in before update, after insert, after update, and after undelete triggers.\n\nold 	Returns a list of the old versions of the sObject records.\n\nThis sObject list is only available in update and delete triggers.\noldMap 	A map of IDs to the old versions of the sObject records.\n\nThis map is only available in update and delete triggers.\nsize 	The total number of records in a trigger invocation, both old and new.','','SalesforcePD1',1,NULL),(4143,'trigger MaintenanceRequest on Case (before update, after update) {\n    // call MaintenanceRequestHelper.updateWorkOrders  \n    if(Trigger.isBefore){\n        \n    }else if(Trigger.isAfter){\n        //Create new routine maintenanc request for each new closed request\n        MaintenanceRequestHelper.updateWorkOrders(Trigger.newMap,Trigger.oldMap);\n    }\n}\n\n\npublic class MaintenanceRequestHelper {\n    \n    public static void updateWorkOrders(Map<Id,Case>newmap, Map<Id,Case> oldmap){\n        List<Case> maintenanceRequestInserts = new List<Case>();\n        for(Case tmpCase : newmap.values()){\n            if(tmpCase.Status == \'Closed\' && (tmpCase.Type == \'Repair\' || tmpCase.Type == \'Routine Maintenance\')\n               && oldmap.get(tmpCase.Id).Status != \'Closed\'){\n                   Case maintenance = new Case(Type = \'Routine Maintenance\',\n                       						   Equipment__c = tmpCase.Equipment__c,\n                                               Vehicle__c = tmpCase.Vehicle__c,\n                                               Subject = \'Not null\',\n                                               Date_Reported__c = Date.today()\n                                              );\n                   maintenanceRequestInserts.add(maintenance);\n               }\n        }\n        insert maintenanceRequestInserts;\n    }        \n    \n}','That\'s how sandeep does it','SalesforcePD1',1,NULL),(4144,'Future methods must be static methods, and can only return a void type. The specified parameters must be primitive data types, arrays of primitive data types, or collections of primitive data types. Notably, future methods can’t take standard or custom objects as arguments. A common pattern is to pass the method a List of record IDs that you want to process asynchronously.','','SalesforcePD1',1,NULL),(4145,'The reason why objects can’t be passed as arguments to future methods is because the object can change between the time you call the method and the time that it actually executes. Remember, future methods are executed when system resources become available. In this case, the future method may have an old object value when it actually executes, which can cause all sorts of bad things to happen.','','SalesforcePD1',1,NULL),(4146,' @future(callout=true)\n    public static void sendSMSAsync(String fromNbr, String toNbr, String m) {\n        String results = sendSMS(fromNbr, toNbr, m);\n        System.debug(results);\n    }','To make a Web service callout to an external service or API, you create an Apex class with a future method that is marked with (callout=true). ','SalesforcePD1',1,NULL),(4147,'Http http = new Http();\nHttpRequest request = new HttpRequest();\nrequest.setEndpoint(\'https://th-apex-http-callout.herokuapp.com/animals\');\nrequest.setMethod(\'GET\');\nHttpResponse response = http.send(request);\n// If the request is successful, parse the JSON response.\nif (response.getStatusCode() == 200) {\n    // Deserialize the JSON string into collections of primitive data types.\n    Map<String, Object> results = (Map<String, Object>) JSON.deserializeUntyped(response.getBody());\n    // Cast the values in the \'animals\' key as a list\n    List<Object> animals = (List<Object>) results.get(\'animals\');\n    System.debug(\'Received the following animals:\');\n    for (Object animal: animals) {\n        System.debug(animal);\n    }\n}','Send a request','SalesforcePD1',1,NULL),(4148,'What method would you use to get the content of an HttpResponse ?','response.getBody();','SalesforcePD1',1,NULL),(4149,'Before permorming a REST callout you must ...','Authorize the URL in \'Remote Site Settings\'','SalesforcePD1',1,NULL),(4150,'			JSONParser parser = JSON.createParser(response.getBody());\n            \n            while(parser.nextToken() != null){\n                if(parser.getCurrentToken() == JSONToken.START_ARRAY){\n                    while(parser.nextToken() != null){\n                        if(parser.getCurrentToken() == JSONToken.START_OBJECT){\n                            Product2 prod = (Product2)parser.readValueAs(Product2.class);\n                            System.debug(prod.Name);\n                            System.debug(prod.Id);\n                        }\n                    }\n                }\n                \n            }','This is good but in superbadge example, the fields are not the same in Salesforce as they are in JSON. \n\nThere for you need to parse manually based on the text. \n','SalesforcePD1',1,NULL),(4151,'List<Product2> currentProducts = [Select ID, Name, Cost__c, Current_Inventory__c,\n                  Lifespan_Months__c, Maintenance_Cycle__c,    Replacement_Part__c,\n                  Warehouse_SKU__c From Product2\n                  Where Name IN :prods];','IN :List<String> works too !','SalesforcePD1',1,NULL),(4152,'Database.SaveResult[] srlist = Database.update(currentProducts,false);\n            \n            for(Database.SaveResult sr : srlist){\n                if(sr.isSuccess()){\n                    System.debug(\'successfully updated: \'+sr.getId());\n                } else {\n                    for(Database.Error err : sr.getErrors()){\n                        System.debug(\'The following error has occurred.\');                   \n	            		System.debug(err.getStatusCode() + \': \' + err.getMessage());\n                        System.debug(\'Account fields that affected this error: \' + err.getFields());\n                    }\n                }\n            }','to check','SalesforcePD1',1,NULL),(4153,'public class WarehouseSyncSchedule implements Schedulable {\n  // implement scheduled code here\n    global void execute(SchedulableContext context){\n        \n    }\n  \n}','WNC, Defining type for global methods must be defined as global. ','SalesforcePD1',1,NULL),(4154,'The parameter of this method is a SchedulableContext object. After a class has been scheduled, a CronTrigger object is created that represents the scheduled job. It provides a getTriggerId method that returns the ID of a CronTrigger API object.','','SalesforcePD1',1,NULL),(4155,'You can also schedule a class using the user interface.\n\n    From Setup, enter Apex in the Quick Find box, then select Apex Classes.\n    Click Schedule Apex.\n    For the job name, enter something like Daily Oppty Reminder.\n    Click the lookup button next to Apex class and enter * for the search term to get a list of all classes that can be scheduled. In the search results, click the name of your scheduled class.\n    Select Weekly or Monthly for the frequency and set the frequency desired.\n    Select the start and end dates, and a preferred start time.\n    Click Save.\n','this is a lot easier!','SalesforcePD1',1,NULL),(4156,'While writing a test class that covers an OpportunityLineItem trigger, a Developer is unable to create a standard Pricebook since one already exist in the org. how should the developer overcome this problem?','Use Test.getStandardPriceBookId() to get the standard pricebookID','SalesforcePD1',1,NULL),(4157,'Integer x;\nfor(x=0; x<10; x+=2){\n   if(x==8)\n      break;\n   if(x==10)\n      break;\n}\nSystem.debug(x)\nwhat will debug display ?','8','SalesforcePD1',1,NULL),(4158,'How should a devleloper prevent a recursive trigger ?','','SalesforcePD1',1,NULL),(4159,'What are three ways for a developer to run tests in an org ?','Developer console\nsetup menu\ntooling api','SalesforcePD1',1,NULL),(4160,'A developer created a helper class with a method that can be called from Visualforce pages, web services, triggers, and anonymous code. When the method is called from a trigger, the developer needs to execute code that should not be called when ran from anywhere else. \n\nHow can the developer determine if the code is being ran in a trigger context ?','Trigger.isExecuting == \'True\'; ','SalesforcePD1',1,NULL),(4161,'What are two considerations when deciding wether to use a roll up summary field ? ','Roll up summaries can be used on formulas fields, but if the formula contains an #Error result it may affect the summary value. \n\nRoll up summary fields do not cause validation rules on the parent object unless that object is edited seperately','SalesforcePD1',1,NULL),(4162,'a developer created a lightning component named accountList.cmp that displays a list of accounts. Client side logic that is executed when a user hovers over an account should be stored in which bundle member ?','accountListHelper.js','SalesforcePD1',1,NULL),(4163,'What can a developer use to determine if an Apex class exceeds any governor limits in a test class during bulk execution ?','Limits, startTest, stopTest','SalesforcePD1',1,NULL),(4165,'TESTCARD','TESTANSWER','TESTCATEGORY',1,NULL),(4166,'TESTCARD','TESTANSWER','TESTCATEGORY',1,NULL),(4168,'TESTCARD','TESTANSWER','TESTCATEGORY',1,NULL),(4169,'TESTCARD','TESTANSWER','TESTCATEGORY',1,NULL),(4170,'TESTCARD','TESTANSWER','TESTCATEGORY',1,NULL),(4171,'TESTCARD','TESTANSWER','TESTCATEGORY',1,NULL),(4224,'TRANS Test card','trans test Answer','trans test Category',1,NULL),(4225,'TRANS Test card','trans test Answer','trans test Category',1,NULL),(4226,'TRANS Test card','trans test Answer','trans test Category',1,NULL),(5397,'How do you create a hyphen program? ','sample ',' algorithms',1,NULL),(5502,'test 1','test 1','',44,NULL),(5503,'test 2','test 2','',44,NULL),(5504,'test 3','test 3','',44,NULL),(5505,'FCS QA 1','FCS QA 1','FCS QA 1',1,NULL),(5506,'FCS QA 2','FCS QA 2','FCS QA 2',1,NULL),(5507,'FCS QA 1','FCS QA 1','FCS QA 1',1,NULL),(5508,'FCS QA 2','FCS QA 2','FCS QA 2',1,NULL),(5509,'FCS QA 1','FCS QA 1','FCS QA 1',1,NULL),(5510,'FCS QA 2','FCS QA 2','FCS QA 1',1,NULL),(5511,'FCS QA 1','FCS QA 1','FCS QA 1',1,NULL),(5512,'FCS QA 2','FCS QA 12','FCS QA 12',1,NULL),(5513,'HOW many cb can a barista make an hour ? ','12-15 depending on competancy ','coffee',45,NULL),(5516,'asdf','asdf','d',1,NULL),(5519,'ID TEST','ID TEST ANSWER','TEST CAT',1,NULL),(5520,'ID TEST22','ID TEST ANSWER','TEST CAT',1,NULL),(6532,'useEffect(() => {\n\ncleanup = () => { console.log(\'cleanup\'); ) \nreturn cleanup;\n\n},RERENDER_PROP);\n\nWhen will cleanup get run ?','IF your useEffect function return a function, that function will get called when it\'s time to cleanup.','React',1,NULL),(6533,'Warning: useEffect received a final argument that is not an array (instead, received `boolean`). When specified, the final argument must be an array','Cant put booleans in the useEffect() final arg.','React',1,NULL),(6534,'There are a few good use cases for refs:','Managing focus, text selection, or media playback.\nTriggering imperative animations.\nIntegrating with third-party DOM libraries.\nAvoid using refs for anything that can be done declaratively.\n\nFor example, instead of exposing open() and close() methods on a Dialog component, pass an isOpen prop to it.\n\n','React',1,NULL),(6535,'Imperitive vs Declaritive','https://stackoverflow.com/questions/1784664/what-is-the-difference-between-declarative-and-imperative-programming\n\nWith imperitive programming you tell the compiler what you want step by step and it does that.\n\nWith Declaritive, you tell the compiler what you want to happen and it does it.','React',1,NULL),(6536,'What\'s the benifit of callback refs ? ','They are guarenteed to be current, \n\nReact will call the ref callback with DOM node or element when the component mounts and call it with null when it unmounts. \n\n\nthis.setTextInputRef = element => {\n      this.textInput = element;\n    };\n\n render() {\n    // Use the `ref` callback to store a reference to the text input DOM\n    // element in an instance field (for example, this.textInput).\n    return (\n      <div>\n        <input\n          type=\"text\"\n          ref={this.setTextInputRef}\n        />','React',1,NULL),(6537,'How do you use the ref attribute on a functional component ? ','You don\'t functions don\'t have instances,\nBut you can use the ref attribute inside a function as long as it\'s on a DOM element.','React',1,NULL),(6538,'The proper function of an absolute position is to overlap content. If you want other content to automatically push down then use relative position.','The content should load on the first page in a white box, with overflowing content pushing the following sections of the page down. However, as can be seen the lower sections load over the top of the first page white box. I have tried changing the positioning/clears of the various sections but cannot seem to create the necessary movement.\n\n.page1 { \n    background: url(\'../img/bg.jpg\')#131313;\n    background-size: cover;\n    height: 100%;\n    position: relative;\n}\n.huge-title {\n    position: absolute;\n    top: -20%;\n    right: 0;\n    bottom: 0;\n    left: 0;\n    margin: auto;\n    width: 100%;\n    height: 180px;\n}\n#detailsbox {\n    top: -4em;\n    width: 75%;\n    left: 12.5%;\n    right: 12.5%;\n    border: 20px solid white;\n    border-radius: 10px;\n    background-color: white;\n    text-align:center;\n    position: absolute;\n    float: left;\n    clear: both;\n}\n\nyou need to change .huge-title and #detailsbox to position:relative;\nyou can probably get rid of background-size: cover;\nalso change .huge-title and #detailsbox to the following:\n\n.page1 {\n  background: url(\'../img/bg.jpg\')#131313;\n  height: 100%;\n  position: relative;\n}\n.huge-title {\n  position: relative;\n  top: 20%;\n  right: 0;\n  left: 0;\n  margin: auto;\n  height: 100%;\n}\n#detailsbox {\n  top: -4em;\n  width: 75%;\n  left: 12.5%;\n  right: 12.5%;\n  border: 20px solid white;\n  border-radius: 10px;\n  background-color: white;\n  text-align: center;\n  position: relative;\n  float: left;\n  clear: both;\n}','CSS',1,NULL),(6539,'In Javascript null is considered an object','weird','JS Edge Cases',1,NULL),(6540,'Is the order guarenteed in JS array\'s ','Yes, arrays are ordered collections. \n\nhttp://www.ecma-international.org/ecma-262/5.1/#sec-15.4\n\nhttps://blog.caplin.com/2012/01/13/javascript-is-hard-part-1-you-cant-trust-arrays/\nhttps://stackoverflow.com/questions/34955787/is-a-javascript-array-order-guaranteed\n\nif the array is posted in a form it is no longer a js array. Jquery serializes as application/x-www-form-urlencoded\n\nJSON would be best to use for ordered collections being sent on forms since it supports orders','JS Edge Cases',1,NULL),(6541,'In PS how do you create a new Resource Group','New-AzResourceGroup -Name \"MaxsRSGroup\" -Location \"East US\" ','Azure',1,'AZURE'),(6542,'How do you get a policy definition by name ? ','Get-AzPolicyDefinition | Where-Object { $_.Properties.DisplayName -eq \' specified name \' }','Azure',1,'AZURE'),(6543,'Assign the policy in $definition to the resource group stored in $rg','New-AzPolicyAssignment -Name \'Require tag policy -DisplayName \'TAG POLICY\' -Scope $rg.ResourceId -PolicyDefinition $definition\n\n$definition contains the policy\'s Id','Azure',1,'AZURE'),(6544,'New-AzPolicyAssignment -Name \"require-tag-policy\" -DisplayName \"Tag Policy\" -Scope $rg.ResourceId -PolicyDefinition $definition','Creates a policy assignment to the resource group in $rg.','Azure',1,'AZURE'),(6545,'Using Powershell how do you create a new role definition by  using an upload file contianing a json definition','New-AzRoleDefinition -InputFile $HOME/az104-02a-customRoleDefinition.json','Azure',1,'AZURE'),(6546,'Get the scope of a Role Definition by name','$scope = (Get-AzRoleAssignment -RoleDefinitionName \'Support Request Contributor (Custom)\').Scope','Azure',1,'AZURE'),(6547,'Remove a role assignment using the object id, the role definition name, and the scope','Remove-AzRoleAssignment -ObjectId \'[object_ID]\' -RoleDefinitionName \'Support Request Contributor (Custom)\' -Scope $scope','Azure',1,'AZURE'),(6548,'Remove role definition','Remove-AzRoleDefinition -Name \'Support Request Contributor (Custom)\' -Force','Azure',1,'AZURE'),(6549,'Which PowerShell cmdlet is used to create your own unique policy?',' New-AzureRmPolicyDefinition','Azure',1,'AZURE'),(6550,'Which CLI command is used to create your own unique policy? ','az policy definition create','Azure',1,'AZURE'),(6551,'Which of the following is not provided as a built in Policy ? \nRequire SQL server 12.0\nEnforce a tag and its value\nRestrict which storage account SKUs can be chosen\nStop a user from deleting tags','Unfortunately, there is no policy that can stop people from deleting certain tags.','Azure',1,'AZURE'),(6552,'What can be used to organize resources for cost reporting?','Subscriptions, Resource groups, and tags ','Azure',1,'AZURE'),(6554,'CARDLIST-TESTCARD-0','CARDLIST-TESTANSWER-0','TESTCAT-0',1,NULL),(6555,'CARDLIST-TESTCARD-1','CARDLIST-TESTANSWER-1','TESTCAT-1',1,NULL),(6556,'CARDLIST-TESTCARD-2','CARDLIST-TESTANSWER-2','TESTCAT-2',1,NULL),(6557,'CARDLIST-TESTCARD-3','CARDLIST-TESTANSWER-3','TESTCAT-3',1,NULL),(6558,'CARDLIST-TESTCARD-4','CARDLIST-TESTANSWER-4','TESTCAT-4',1,NULL),(6559,'CARDLIST-TESTCARD-5','CARDLIST-TESTANSWER-5','TESTCAT-5',1,NULL),(6560,'CARDLIST-TESTCARD-6','CARDLIST-TESTANSWER-6','TESTCAT-6',1,NULL),(6561,'CARDLIST-TESTCARD-7','CARDLIST-TESTANSWER-7','TESTCAT-7',1,NULL),(6562,'CARDLIST-TESTCARD-8','CARDLIST-TESTANSWER-8','TESTCAT-8',1,NULL),(6563,'CARDLIST-TESTCARD-9','CARDLIST-TESTANSWER-9','TESTCAT-9',1,NULL),(6564,'CARDLIST-TESTCARD-10','CARDLIST-TESTANSWER-10','TESTCAT-10',1,NULL),(6565,'CARDLIST-TESTCARD-11','CARDLIST-TESTANSWER-11','TESTCAT-11',1,NULL),(6566,'CARDLIST-TESTCARD-12','CARDLIST-TESTANSWER-12','TESTCAT-12',1,NULL),(6567,'CARDLIST-TESTCARD-13','CARDLIST-TESTANSWER-13','TESTCAT-13',1,NULL),(6568,'CARDLIST-TESTCARD-14','CARDLIST-TESTANSWER-14','TESTCAT-14',1,NULL),(6569,'CARDLIST-TESTCARD-15','CARDLIST-TESTANSWER-15','TESTCAT-15',1,NULL),(6570,'CARDLIST-TESTCARD-16','CARDLIST-TESTANSWER-16','TESTCAT-16',1,NULL),(6571,'CARDLIST-TESTCARD-17','CARDLIST-TESTANSWER-17','TESTCAT-17',1,NULL),(6572,'CARDLIST-TESTCARD-18','CARDLIST-TESTANSWER-18','TESTCAT-18',1,NULL),(6573,'CARDLIST-TESTCARD-19','CARDLIST-TESTANSWER-19','TESTCAT-19',1,NULL),(6574,'CARDLIST-TESTCARD-20','CARDLIST-TESTANSWER-20','TESTCAT-20',1,NULL),(6575,'CARDLIST-TESTCARD-21','CARDLIST-TESTANSWER-21','TESTCAT-21',1,NULL),(6576,'CARDLIST-TESTCARD-22','CARDLIST-TESTANSWER-22','TESTCAT-22',1,NULL),(6577,'CARDLIST-TESTCARD-23','CARDLIST-TESTANSWER-23','TESTCAT-23',1,NULL),(6578,'CARDLIST-TESTCARD-24','CARDLIST-TESTANSWER-24','TESTCAT-24',1,NULL),(6579,'CARDLIST-TESTCARD-25','CARDLIST-TESTANSWER-25','TESTCAT-25',1,NULL),(6580,'CARDLIST-TESTCARD-26','CARDLIST-TESTANSWER-26','TESTCAT-26',1,NULL),(6581,'CARDLIST-TESTCARD-27','CARDLIST-TESTANSWER-27','TESTCAT-27',1,NULL),(6582,'CARDLIST-TESTCARD-28','CARDLIST-TESTANSWER-28','TESTCAT-28',1,NULL),(6583,'CARDLIST-TESTCARD-29','CARDLIST-TESTANSWER-29','TESTCAT-29',1,NULL),(6584,'CARDLIST-TESTCARD-30','CARDLIST-TESTANSWER-30','TESTCAT-30',1,NULL),(6585,'CARDLIST-TESTCARD-31','CARDLIST-TESTANSWER-31','TESTCAT-31',1,NULL),(6586,'CARDLIST-TESTCARD-32','CARDLIST-TESTANSWER-32','TESTCAT-32',1,NULL),(6587,'CARDLIST-TESTCARD-33','CARDLIST-TESTANSWER-33','TESTCAT-33',1,NULL),(6588,'CARDLIST-TESTCARD-34','CARDLIST-TESTANSWER-34','TESTCAT-34',1,NULL),(6589,'CARDLIST-TESTCARD-35','CARDLIST-TESTANSWER-35','TESTCAT-35',1,NULL),(6590,'CARDLIST-TESTCARD-36','CARDLIST-TESTANSWER-36','TESTCAT-36',1,NULL),(6591,'CARDLIST-TESTCARD-37','CARDLIST-TESTANSWER-37','TESTCAT-37',1,NULL),(6592,'CARDLIST-TESTCARD-38','CARDLIST-TESTANSWER-38','TESTCAT-38',1,NULL),(6593,'CARDLIST-TESTCARD-39','CARDLIST-TESTANSWER-39','TESTCAT-39',1,NULL),(6594,'CARDLIST-TESTCARD-40','CARDLIST-TESTANSWER-40','TESTCAT-40',1,NULL),(6595,'CARDLIST-TESTCARD-41','CARDLIST-TESTANSWER-41','TESTCAT-41',1,NULL),(6596,'CARDLIST-TESTCARD-42','CARDLIST-TESTANSWER-42','TESTCAT-42',1,NULL),(6597,'CARDLIST-TESTCARD-43','CARDLIST-TESTANSWER-43','TESTCAT-43',1,NULL),(6598,'CARDLIST-TESTCARD-44','CARDLIST-TESTANSWER-44','TESTCAT-44',1,NULL),(6599,'CARDLIST-TESTCARD-45','CARDLIST-TESTANSWER-45','TESTCAT-45',1,NULL),(6600,'CARDLIST-TESTCARD-46','CARDLIST-TESTANSWER-46','TESTCAT-46',1,NULL),(6601,'CARDLIST-TESTCARD-47','CARDLIST-TESTANSWER-47','TESTCAT-47',1,NULL),(6602,'CARDLIST-TESTCARD-48','CARDLIST-TESTANSWER-48','TESTCAT-48',1,NULL),(6603,'CARDLIST-TESTCARD-49','CARDLIST-TESTANSWER-49','TESTCAT-49',1,NULL),(6604,'CARDLIST-TESTCARD-50','CARDLIST-TESTANSWER-50','TESTCAT-50',1,NULL),(6605,'CARDLIST-TESTCARD-51','CARDLIST-TESTANSWER-51','TESTCAT-51',1,NULL),(6606,'CARDLIST-TESTCARD-52','CARDLIST-TESTANSWER-52','TESTCAT-52',1,NULL),(6607,'CARDLIST-TESTCARD-53','CARDLIST-TESTANSWER-53','TESTCAT-53',1,NULL),(6608,'CARDLIST-TESTCARD-54','CARDLIST-TESTANSWER-54','TESTCAT-54',1,NULL),(6609,'CARDLIST-TESTCARD-55','CARDLIST-TESTANSWER-55','TESTCAT-55',1,NULL),(6610,'CARDLIST-TESTCARD-56','CARDLIST-TESTANSWER-56','TESTCAT-56',1,NULL),(6611,'CARDLIST-TESTCARD-57','CARDLIST-TESTANSWER-57','TESTCAT-57',1,NULL),(6612,'CARDLIST-TESTCARD-58','CARDLIST-TESTANSWER-58','TESTCAT-58',1,NULL),(6613,'CARDLIST-TESTCARD-59','CARDLIST-TESTANSWER-59','TESTCAT-59',1,NULL),(6614,'CARDLIST-TESTCARD-60','CARDLIST-TESTANSWER-60','TESTCAT-60',1,NULL),(6615,'CARDLIST-TESTCARD-61','CARDLIST-TESTANSWER-61','TESTCAT-61',1,NULL),(6616,'CARDLIST-TESTCARD-62','CARDLIST-TESTANSWER-62','TESTCAT-62',1,NULL),(6617,'CARDLIST-TESTCARD-63','CARDLIST-TESTANSWER-63','TESTCAT-63',1,NULL),(6618,'CARDLIST-TESTCARD-64','CARDLIST-TESTANSWER-64','TESTCAT-64',1,NULL),(6619,'CARDLIST-TESTCARD-65','CARDLIST-TESTANSWER-65','TESTCAT-65',1,NULL),(6620,'CARDLIST-TESTCARD-66','CARDLIST-TESTANSWER-66','TESTCAT-66',1,NULL),(6621,'CARDLIST-TESTCARD-67','CARDLIST-TESTANSWER-67','TESTCAT-67',1,NULL),(6622,'CARDLIST-TESTCARD-68','CARDLIST-TESTANSWER-68','TESTCAT-68',1,NULL),(6623,'CARDLIST-TESTCARD-69','CARDLIST-TESTANSWER-69','TESTCAT-69',1,NULL),(6624,'CARDLIST-TESTCARD-70','CARDLIST-TESTANSWER-70','TESTCAT-70',1,NULL),(6625,'CARDLIST-TESTCARD-71','CARDLIST-TESTANSWER-71','TESTCAT-71',1,NULL),(6626,'CARDLIST-TESTCARD-72','CARDLIST-TESTANSWER-72','TESTCAT-72',1,NULL),(6627,'CARDLIST-TESTCARD-73','CARDLIST-TESTANSWER-73','TESTCAT-73',1,NULL),(6628,'CARDLIST-TESTCARD-74','CARDLIST-TESTANSWER-74','TESTCAT-74',1,NULL),(6629,'CARDLIST-TESTCARD-75','CARDLIST-TESTANSWER-75','TESTCAT-75',1,NULL),(6630,'CARDLIST-TESTCARD-76','CARDLIST-TESTANSWER-76','TESTCAT-76',1,NULL),(6631,'CARDLIST-TESTCARD-77','CARDLIST-TESTANSWER-77','TESTCAT-77',1,NULL),(6632,'CARDLIST-TESTCARD-78','CARDLIST-TESTANSWER-78','TESTCAT-78',1,NULL),(6633,'CARDLIST-TESTCARD-79','CARDLIST-TESTANSWER-79','TESTCAT-79',1,NULL),(6634,'CARDLIST-TESTCARD-80','CARDLIST-TESTANSWER-80','TESTCAT-80',1,NULL),(6635,'CARDLIST-TESTCARD-81','CARDLIST-TESTANSWER-81','TESTCAT-81',1,NULL),(6636,'CARDLIST-TESTCARD-82','CARDLIST-TESTANSWER-82','TESTCAT-82',1,NULL),(6637,'CARDLIST-TESTCARD-83','CARDLIST-TESTANSWER-83','TESTCAT-83',1,NULL),(6638,'CARDLIST-TESTCARD-84','CARDLIST-TESTANSWER-84','TESTCAT-84',1,NULL),(6639,'CARDLIST-TESTCARD-85','CARDLIST-TESTANSWER-85','TESTCAT-85',1,NULL),(6640,'CARDLIST-TESTCARD-86','CARDLIST-TESTANSWER-86','TESTCAT-86',1,NULL),(6641,'CARDLIST-TESTCARD-87','CARDLIST-TESTANSWER-87','TESTCAT-87',1,NULL),(6642,'CARDLIST-TESTCARD-88','CARDLIST-TESTANSWER-88','TESTCAT-88',1,NULL),(6643,'CARDLIST-TESTCARD-89','CARDLIST-TESTANSWER-89','TESTCAT-89',1,NULL),(6644,'CARDLIST-TESTCARD-90','CARDLIST-TESTANSWER-90','TESTCAT-90',1,NULL),(6645,'CARDLIST-TESTCARD-91','CARDLIST-TESTANSWER-91','TESTCAT-91',1,NULL),(6646,'CARDLIST-TESTCARD-92','CARDLIST-TESTANSWER-92','TESTCAT-92',1,NULL),(6647,'CARDLIST-TESTCARD-93','CARDLIST-TESTANSWER-93','TESTCAT-93',1,NULL),(6648,'CARDLIST-TESTCARD-94','CARDLIST-TESTANSWER-94','TESTCAT-94',1,NULL),(6649,'CARDLIST-TESTCARD-95','CARDLIST-TESTANSWER-95','TESTCAT-95',1,NULL),(6650,'CARDLIST-TESTCARD-96','CARDLIST-TESTANSWER-96','TESTCAT-96',1,NULL),(6651,'CARDLIST-TESTCARD-97','CARDLIST-TESTANSWER-97','TESTCAT-97',1,NULL),(6652,'CARDLIST-TESTCARD-98','CARDLIST-TESTANSWER-98','TESTCAT-98',1,NULL),(6653,'CARDLIST-TESTCARD-99','CARDLIST-TESTANSWER-99','TESTCAT-99',1,NULL),(6655,'CARDLIST-TESTCARD-0','CARDLIST-TESTANSWER-0','TESTCAT-0',1,NULL),(6656,'CARDLIST-TESTCARD-1','CARDLIST-TESTANSWER-1','TESTCAT-1',1,NULL),(6657,'CARDLIST-TESTCARD-2','CARDLIST-TESTANSWER-2','TESTCAT-2',1,NULL),(6658,'CARDLIST-TESTCARD-3','CARDLIST-TESTANSWER-3','TESTCAT-3',1,NULL),(6659,'CARDLIST-TESTCARD-4','CARDLIST-TESTANSWER-4','TESTCAT-4',1,NULL),(6660,'CARDLIST-TESTCARD-5','CARDLIST-TESTANSWER-5','TESTCAT-5',1,NULL),(6661,'CARDLIST-TESTCARD-6','CARDLIST-TESTANSWER-6','TESTCAT-6',1,NULL),(6662,'CARDLIST-TESTCARD-7','CARDLIST-TESTANSWER-7','TESTCAT-7',1,NULL),(6663,'CARDLIST-TESTCARD-8','CARDLIST-TESTANSWER-8','TESTCAT-8',1,NULL),(6664,'CARDLIST-TESTCARD-9','CARDLIST-TESTANSWER-9','TESTCAT-9',1,NULL),(6665,'CARDLIST-TESTCARD-10','CARDLIST-TESTANSWER-10','TESTCAT-10',1,NULL),(6666,'CARDLIST-TESTCARD-11','CARDLIST-TESTANSWER-11','TESTCAT-11',1,NULL),(6667,'CARDLIST-TESTCARD-12','CARDLIST-TESTANSWER-12','TESTCAT-12',1,NULL),(6668,'CARDLIST-TESTCARD-13','CARDLIST-TESTANSWER-13','TESTCAT-13',1,NULL),(6669,'CARDLIST-TESTCARD-14','CARDLIST-TESTANSWER-14','TESTCAT-14',1,NULL),(6670,'CARDLIST-TESTCARD-15','CARDLIST-TESTANSWER-15','TESTCAT-15',1,NULL),(6671,'CARDLIST-TESTCARD-16','CARDLIST-TESTANSWER-16','TESTCAT-16',1,NULL),(6672,'CARDLIST-TESTCARD-17','CARDLIST-TESTANSWER-17','TESTCAT-17',1,NULL),(6673,'CARDLIST-TESTCARD-18','CARDLIST-TESTANSWER-18','TESTCAT-18',1,NULL),(6674,'CARDLIST-TESTCARD-19','CARDLIST-TESTANSWER-19','TESTCAT-19',1,NULL),(6675,'CARDLIST-TESTCARD-20','CARDLIST-TESTANSWER-20','TESTCAT-20',1,NULL),(6676,'CARDLIST-TESTCARD-21','CARDLIST-TESTANSWER-21','TESTCAT-21',1,NULL),(6677,'CARDLIST-TESTCARD-22','CARDLIST-TESTANSWER-22','TESTCAT-22',1,NULL),(6678,'CARDLIST-TESTCARD-23','CARDLIST-TESTANSWER-23','TESTCAT-23',1,NULL),(6679,'CARDLIST-TESTCARD-24','CARDLIST-TESTANSWER-24','TESTCAT-24',1,NULL),(6680,'CARDLIST-TESTCARD-25','CARDLIST-TESTANSWER-25','TESTCAT-25',1,NULL),(6681,'CARDLIST-TESTCARD-26','CARDLIST-TESTANSWER-26','TESTCAT-26',1,NULL),(6682,'CARDLIST-TESTCARD-27','CARDLIST-TESTANSWER-27','TESTCAT-27',1,NULL),(6683,'CARDLIST-TESTCARD-28','CARDLIST-TESTANSWER-28','TESTCAT-28',1,NULL),(6684,'CARDLIST-TESTCARD-29','CARDLIST-TESTANSWER-29','TESTCAT-29',1,NULL),(6685,'CARDLIST-TESTCARD-30','CARDLIST-TESTANSWER-30','TESTCAT-30',1,NULL),(6686,'CARDLIST-TESTCARD-31','CARDLIST-TESTANSWER-31','TESTCAT-31',1,NULL),(6687,'CARDLIST-TESTCARD-32','CARDLIST-TESTANSWER-32','TESTCAT-32',1,NULL),(6688,'CARDLIST-TESTCARD-33','CARDLIST-TESTANSWER-33','TESTCAT-33',1,NULL),(6689,'CARDLIST-TESTCARD-34','CARDLIST-TESTANSWER-34','TESTCAT-34',1,NULL),(6690,'CARDLIST-TESTCARD-35','CARDLIST-TESTANSWER-35','TESTCAT-35',1,NULL),(6691,'CARDLIST-TESTCARD-36','CARDLIST-TESTANSWER-36','TESTCAT-36',1,NULL),(6692,'CARDLIST-TESTCARD-37','CARDLIST-TESTANSWER-37','TESTCAT-37',1,NULL),(6693,'CARDLIST-TESTCARD-38','CARDLIST-TESTANSWER-38','TESTCAT-38',1,NULL),(6694,'CARDLIST-TESTCARD-39','CARDLIST-TESTANSWER-39','TESTCAT-39',1,NULL),(6695,'CARDLIST-TESTCARD-40','CARDLIST-TESTANSWER-40','TESTCAT-40',1,NULL),(6696,'CARDLIST-TESTCARD-41','CARDLIST-TESTANSWER-41','TESTCAT-41',1,NULL),(6697,'CARDLIST-TESTCARD-42','CARDLIST-TESTANSWER-42','TESTCAT-42',1,NULL),(6698,'CARDLIST-TESTCARD-43','CARDLIST-TESTANSWER-43','TESTCAT-43',1,NULL),(6699,'CARDLIST-TESTCARD-44','CARDLIST-TESTANSWER-44','TESTCAT-44',1,NULL),(6700,'CARDLIST-TESTCARD-45','CARDLIST-TESTANSWER-45','TESTCAT-45',1,NULL),(6701,'CARDLIST-TESTCARD-46','CARDLIST-TESTANSWER-46','TESTCAT-46',1,NULL),(6702,'CARDLIST-TESTCARD-47','CARDLIST-TESTANSWER-47','TESTCAT-47',1,NULL),(6703,'CARDLIST-TESTCARD-48','CARDLIST-TESTANSWER-48','TESTCAT-48',1,NULL),(6704,'CARDLIST-TESTCARD-49','CARDLIST-TESTANSWER-49','TESTCAT-49',1,NULL),(6705,'CARDLIST-TESTCARD-50','CARDLIST-TESTANSWER-50','TESTCAT-50',1,NULL),(6706,'CARDLIST-TESTCARD-51','CARDLIST-TESTANSWER-51','TESTCAT-51',1,NULL),(6707,'CARDLIST-TESTCARD-52','CARDLIST-TESTANSWER-52','TESTCAT-52',1,NULL),(6708,'CARDLIST-TESTCARD-53','CARDLIST-TESTANSWER-53','TESTCAT-53',1,NULL),(6709,'CARDLIST-TESTCARD-54','CARDLIST-TESTANSWER-54','TESTCAT-54',1,NULL),(6710,'CARDLIST-TESTCARD-55','CARDLIST-TESTANSWER-55','TESTCAT-55',1,NULL),(6711,'CARDLIST-TESTCARD-56','CARDLIST-TESTANSWER-56','TESTCAT-56',1,NULL),(6712,'CARDLIST-TESTCARD-57','CARDLIST-TESTANSWER-57','TESTCAT-57',1,NULL),(6713,'CARDLIST-TESTCARD-58','CARDLIST-TESTANSWER-58','TESTCAT-58',1,NULL),(6714,'CARDLIST-TESTCARD-59','CARDLIST-TESTANSWER-59','TESTCAT-59',1,NULL),(6715,'CARDLIST-TESTCARD-60','CARDLIST-TESTANSWER-60','TESTCAT-60',1,NULL),(6716,'CARDLIST-TESTCARD-61','CARDLIST-TESTANSWER-61','TESTCAT-61',1,NULL),(6717,'CARDLIST-TESTCARD-62','CARDLIST-TESTANSWER-62','TESTCAT-62',1,NULL),(6718,'CARDLIST-TESTCARD-63','CARDLIST-TESTANSWER-63','TESTCAT-63',1,NULL),(6719,'CARDLIST-TESTCARD-64','CARDLIST-TESTANSWER-64','TESTCAT-64',1,NULL),(6720,'CARDLIST-TESTCARD-65','CARDLIST-TESTANSWER-65','TESTCAT-65',1,NULL),(6721,'CARDLIST-TESTCARD-66','CARDLIST-TESTANSWER-66','TESTCAT-66',1,NULL),(6722,'CARDLIST-TESTCARD-67','CARDLIST-TESTANSWER-67','TESTCAT-67',1,NULL),(6723,'CARDLIST-TESTCARD-68','CARDLIST-TESTANSWER-68','TESTCAT-68',1,NULL),(6724,'CARDLIST-TESTCARD-69','CARDLIST-TESTANSWER-69','TESTCAT-69',1,NULL),(6725,'CARDLIST-TESTCARD-70','CARDLIST-TESTANSWER-70','TESTCAT-70',1,NULL),(6726,'CARDLIST-TESTCARD-71','CARDLIST-TESTANSWER-71','TESTCAT-71',1,NULL),(6727,'CARDLIST-TESTCARD-72','CARDLIST-TESTANSWER-72','TESTCAT-72',1,NULL),(6728,'CARDLIST-TESTCARD-73','CARDLIST-TESTANSWER-73','TESTCAT-73',1,NULL),(6729,'CARDLIST-TESTCARD-74','CARDLIST-TESTANSWER-74','TESTCAT-74',1,NULL),(6730,'CARDLIST-TESTCARD-75','CARDLIST-TESTANSWER-75','TESTCAT-75',1,NULL),(6731,'CARDLIST-TESTCARD-76','CARDLIST-TESTANSWER-76','TESTCAT-76',1,NULL),(6732,'CARDLIST-TESTCARD-77','CARDLIST-TESTANSWER-77','TESTCAT-77',1,NULL),(6733,'CARDLIST-TESTCARD-78','CARDLIST-TESTANSWER-78','TESTCAT-78',1,NULL),(6734,'CARDLIST-TESTCARD-79','CARDLIST-TESTANSWER-79','TESTCAT-79',1,NULL),(6735,'CARDLIST-TESTCARD-80','CARDLIST-TESTANSWER-80','TESTCAT-80',1,NULL),(6736,'CARDLIST-TESTCARD-81','CARDLIST-TESTANSWER-81','TESTCAT-81',1,NULL),(6737,'CARDLIST-TESTCARD-82','CARDLIST-TESTANSWER-82','TESTCAT-82',1,NULL),(6738,'CARDLIST-TESTCARD-83','CARDLIST-TESTANSWER-83','TESTCAT-83',1,NULL),(6739,'CARDLIST-TESTCARD-84','CARDLIST-TESTANSWER-84','TESTCAT-84',1,NULL),(6740,'CARDLIST-TESTCARD-85','CARDLIST-TESTANSWER-85','TESTCAT-85',1,NULL),(6741,'CARDLIST-TESTCARD-86','CARDLIST-TESTANSWER-86','TESTCAT-86',1,NULL),(6742,'CARDLIST-TESTCARD-87','CARDLIST-TESTANSWER-87','TESTCAT-87',1,NULL),(6743,'CARDLIST-TESTCARD-88','CARDLIST-TESTANSWER-88','TESTCAT-88',1,NULL),(6744,'CARDLIST-TESTCARD-89','CARDLIST-TESTANSWER-89','TESTCAT-89',1,NULL),(6745,'CARDLIST-TESTCARD-90','CARDLIST-TESTANSWER-90','TESTCAT-90',1,NULL),(6746,'CARDLIST-TESTCARD-91','CARDLIST-TESTANSWER-91','TESTCAT-91',1,NULL),(6747,'CARDLIST-TESTCARD-92','CARDLIST-TESTANSWER-92','TESTCAT-92',1,NULL),(6748,'CARDLIST-TESTCARD-93','CARDLIST-TESTANSWER-93','TESTCAT-93',1,NULL),(6749,'CARDLIST-TESTCARD-94','CARDLIST-TESTANSWER-94','TESTCAT-94',1,NULL),(6750,'CARDLIST-TESTCARD-95','CARDLIST-TESTANSWER-95','TESTCAT-95',1,NULL),(6751,'CARDLIST-TESTCARD-96','CARDLIST-TESTANSWER-96','TESTCAT-96',1,NULL),(6752,'CARDLIST-TESTCARD-97','CARDLIST-TESTANSWER-97','TESTCAT-97',1,NULL),(6753,'CARDLIST-TESTCARD-98','CARDLIST-TESTANSWER-98','TESTCAT-98',1,NULL),(6754,'CARDLIST-TESTCARD-99','CARDLIST-TESTANSWER-99','TESTCAT-99',1,NULL),(6755,'Which Azure Service is the centralized spot for all Activity Logs, Metrics, Alerts and Diagnostics for all resources across your subscription?','Azure Monitor','Azure:metrics',1,'AZURE'),(6756,'In order to get diagnostics from an Azure virtual machine you own, what is the first step to doing that?','A diagnostics agent needs to be installed on the VM','Azure:metrics',1,'AZURE'),(6757,'What is the best way to \"baseline\" your existing Azure environment?','Export the ARM templates from Azure to recreate the deployment','Azure:metrics',1,'AZURE'),(6758,'In the context of alerts, you can create an Action Group. What action types can be created in an Action Group?','Automation Runbook \nAzure app Push Notifications\nEmail\nFunction\nITSM\nLogic App\nSecure webhook\nSMS\nWebhook\n','Azure:ActionGroups',1,'AZURE'),(6759,'Which Microsoft service can help you monitor and manage costs for Microsoft Azure, Amazon AWS and Google Cloud Platform?','Cloudyn','Azure:Monitor',1,'AZURE'),(6760,'What are the sections of an ARM template file ? ','Parameters\nVariables\nUser-defined functions\nResources\nOutput','Azure:ARM',1,'AZURE'),(6761,'What happens when you deploy a template ? ','Resource Manager converts the template into Rest API operations that are sent to the Storage resource provider. \n','Azure:ARM',1,'AZURE'),(6762,'What are the steps involved in creating a Policy on a resource group that enforces tagging using a built-in definition ?','1. In the portal search for \'Policy\'\n2. Click the \'Definitions\' blade and look at all the built-in definitions.\n3. Choose the \'Require a tag and its value on resources\' definition and click \'Assign\'\n4. Declare the scope using the current subscription and your resource group.\n5. Declare the \'Policy Enforcement\' option as \'Enabled\'\n6. Set the parameters as Name: \'role\' Value: \'infra\'\n7. Now verify by trying to add a storage account without adding the required tag.','Azure:Policy',1,'AZURE'),(6763,'Create a Policy that requires the \'role\' tag and that remediates non-compliant resources.','1. Go to Policy then \'assign\'.\n2. Specify the policy definition as the built-in policy \'Inherit a tag from the resource group if missing\'\n3. Set the parameter as \'Role\'\n4. On the Remediation tab: check \'Create a remediation task\' box, then on \'Policy to remediate\' chose the \n    built in policy chosena above.\n5. Now when you go to create a new Storage account or any other resource on your Resource Group it will \n   automatically be given the \'Role\' tag that the Resource Group has. ','Azure:Policy',1,'AZURE'),(6764,'What times or events cause a Resource to be evaluated for Policy compliance ?','- A resource is created, updated, or deleted in a scope with a policy assigned. \n- A policy or initiative is newly assigned to a Scope\n- A policy or initiative already assigned to a Scope is updated.\n- During the standard policy compliance evaluation cycle, which occurs every 24 hours. ','Azure:Policy',1,'AZURE'),(6765,'What\'s the difference between Azure policy and RBAC ? ','Azure policy evaluates state by examining properties on Resources. Azure policy does not restrict actions( aka operations). Azure policy ensures resources are compliant to your business rules without concern for who made the change and who has permission to make the change.\n\nRBAC focuses on managing user actions at different scopes. If control of an action is required, then RBAC is the correct tool to use. Even if an individual has access to perform an action, if the result is a non compliant resource, then Policy still blocks the create or update. \n\n\n\n','Azure:Policy',1,'AZURE'),(6766,'Describe the different replication options for a storage account. ','1\n2\n3\n4\n5','Azure:Storage',1,'AZURE'),(6767,'Describe the difference between Access tiers on a Storage Account.','Cool and Hot','Azure:Storage',1,'AZURE'),(6768,'Describe the different Connectivity Methods.','Found on the Networking tab Connectivity Methods..\nBecause your storage account is available anywhere and given a public url when created','Azure:Storage',1,'AZURE'),(6769,'The best way to share access among groups of people or applications is what ?','Not keys but Shared Access Signature.\n\nA shared access Signature is a token signed by one of your keys and upon which you can grant the permissions you want for that user. \n\n','Azure:Access',1,'AZURE'),(6770,'Describe the four kinds of Data a regular v2 storage account can hold.','- Most common type is a BLOB which is stored in Containers\n- SMB file system a shared file storage\n- Table storage\n- QUEUES, FIFO','Azure:Storage',1,'AZURE'),(6771,'What are the unsupported Metadata type ? \nSome things can be customized in a Salesforce org but can\'t be retrieved or deployed through Metadata API ','Account Teams\nActivity Button Overrides\nAuto-number on Customizable Standard Fields\nCalendars\nCampaign Influences\nCase Contact Roles\nCase Feed Layouts\nCase Team Roles\nConsole Layouts\nMultiline layout fields for contract line items\nCurrency Exchange Rates\nData Category Visibility Settings\nDelegated Administration\nDivisions\nFile Upload and Download Security Settings\nMail Merge Templates\nMultiline layout fields for opportunity teams\nOffline Briefcase Configurations\nOmni-Channel Queues and Omni-Channel Skills routing types for the LiveChatButton object\nOpportunity Big Deal Alerts\nOpportunity Update Reminders\nOrganization Wide Email Addresses\nPartner Management\nThe following standard picklists: IdeaTheme.Categories, Question.Origin. (All other standard picklists are supported.)\nPredefined Case Teams\nQuote Templates\nSalesforce to Salesforce\nSelf-Service Portal Font and Colors\nSelf-Service Portal Users\nSelf-Service Public Solutions\nSelf-Service Web-to-Case\nService report templates\nSocial Business Rules\nSoftPhone Layout\nSolution Categories\nSolution Settings\nStandard fields that aren’t customizable, such as autonumber fields or system fields\nWeb Links on Person Account Page Layouts\nWeb-to-Lead','Salesforce:Metadata',1,NULL),(6772,'Using PowerShell how do you get a Storage Account from the resource group \'az1000202-RG\' and store the name in a variable $storageAccountNameA','$storageAccountNameA = (Get-AzStorageAccount -ResourceGroupName \'az1000202-RG\')[0].StorageAccountName','Azure:Storage',1,'AZURE'),(6773,'Using Powershell how do you get the storage Account Key of the storage account name in $storageAccountName in the resource group \'az1000202-RG\' ? ','$storageAccount1Key1 = (Get-AzStorageAccountKey -ResourceGroupName \'az1000202-RG\' -StorageAccountName $storageAccountName)[0].Value','Azure:Storage',1,'AZURE'),(6774,'How do you create a new Storage Context using PowerShell with StorageAccountName $name1 and Storage Account Key $key1','$context1 = New-AzStorageContext -StorageAccountName $name1 -StorageAccountKey $key1','Azure:Storage',1,'AZURE'),(6775,'Create a storage container with name $name1 and context #context1','New-AzStorageContainer -Name $containerName -Context $context2 -Permission Off','Azure:Storage',1,'AZURE'),(6776,'Use powershell to create a new Storage account token ','$containerToken1 = New-AzStorageContainerSASToken -Context $context1 -ExpiryTime(get-date).AddHours(24) -FullUri -Name $containerName -Permission rwdl','Azure:Storage',1,'AZURE'),(6777,'What option do you have to grant someone access to a single container in your Azure storage account without having to give them your storage account keys?','Create for them a Shared Access Signature\n','Azure:Storage',1,'AZURE'),(6778,'2 PB is quite a large amount of storage, and very few uses are going to fill that up. Assuming that you will not fill it up, what would be the most likely reason you need to create more than one unmanaged storage account?','The main reason for creating separate storage accounts is when you are having a lot of IO operations per second.\n\nExceeding the maximun of 20000 IO operations per second','Azure:Storage',1,'AZURE'),(6786,'Use powershell to list all resource groups in a subscription','az group list','Azure:CLI',1,'AZURE'),(6787,'What\'s the difference between scaling up and scaling out ? ','Scaling up or verticle scaling means to increas memory,storage, or compute power to and existing and existing virtual machine already running to make it run faster.\n\nScaling out or horizontal scaling means to add more virtual machines to share the workload. \n ','Azure:WebApps',1,'AZURE'),(6788,'What are the benifits of diving Azure into Geographies ?','Allow customers with specific data residency and compliance needs to keep data close.\n\nGeographies ensure that data residency, sovereignty, compliance, and resiliency requirements are honored within geographical boundaries.\n\nGeographies are fault-tolerant to withstand complete region failure through their connection to dedicated high-capacity networking infrastructure','AZ900:',1,'AZURE'),(6789,'What are the four geographies ? ','Americas\nEurope\nAsia Pacific\nMiddle East and Africa','AZ900:',1,'AZURE'),(6790,'What\'s an availability zone ?','A physically seperate data center within an Azure region.','AZ900:',1,'AZURE'),(6791,'Not every region has support for availability zones. Which regions have at least three seperate zones ?','Central US\nEast US 2\nWest US 2\nWest Europe\nFrance Central\nNorth Europe\nSoutheast Asia','AZ900:',1,'AZURE'),(6792,'Region Pair ?','Each Azure region is always paired with another region within the same geography (such as US, Europe, or Asia) at least 300 miles away. This approach allows for the replication of resources (such as virtual machine storage) across a geography that helps reduce the likelihood of interruptions due to events such as natural disasters, civil unrest, power outages, or physical network outages affecting both regions at once','AZ900:',1,'AZURE'),(6793,'What are the three key characteristics for Azure SLAs ?','Performance Targets\nUptime and Connectivity Guarantees\nService credits','AZ900:',1,'AZURE'),(6794,'What is app Resiliancy ? ','Resiliency is the ability of a system to recover from failures and continue to function. It\'s not about avoiding failures, but responding to failures in a way that avoids downtime or data loss. The goal of resiliency is to return the application to a fully functioning state following a failure. High availability and disaster recovery are two crucial components of resiliency.','AZ900:',1,'AZURE'),(6795,'What are some considerations for defining an application\'s SLAs ? ','If your application SLA defines four 9\'s (99.99%) performance targets, recovering from failures by manual intervention may not be enough to fulfill your SLA. Your Azure solution must be self-diagnosing and self-healing instead.\n\nIt is difficult to respond to failures quickly enough to meet SLA performance targets above four 9\'s.\n\nCarefully consider the time window against which your application SLA performance targets are measured. The smaller the time window, the tighter the tolerances. If you define your application SLA as hourly or daily uptime, you need to understand these tighter tolerances might not allow for achievable performance targets.','AZ900:',1,'AZURE'),(6796,'Deploying an app can be done directly to what level of physical granularity?','Region\n\nAzure organizes infrastructure around regions, which include multiple datacenters. You can pick the region you want resources deployed into. You can\'t select a specific datacenter or location within a datacenter.','AZ900:',1,'AZURE'),(6797,'To use Azure datacenters that are made available with power, cooling, and networking capabilities independent from other datacenters in a region, choose a region that supports _________?','Availability Zones are datacenters set up to be an isolation boundary from others in the region, with their own power, cooling, and networking. If one zone in a region goes down, other Availability Zones in the region continue to work.','AZ900:',1,'AZURE'),(6798,'Application availability refers to what?','The overall time a system is accessible and working. ','AZ900:',1,'AZURE'),(6799,'Where do you go to view your bill ? ','Select your username in the top right hand corner. \n\nclick \' ... \' \n\nclick \"View My bill\"','AZ900:',1,'AZURE'),(6800,'How do you share a dashboard ?','Portal Menu > Dashboards > Share > Brings up the Sharing and access control panel > Select options and click \'Publish\'','AZ900:',1,'AZURE'),(6801,'Describe the two types of feature preview.','Private Preview. \n\nAn Azure feature marked \"private preview\" is available to specific Azure customers for evaluation purposes. This is typically by invite only and issued directly by the product team responsible for the feature or service.\n\nPublic Preview. \n\nAn Azure feature marked \"public preview\" is available to all Azure customers for evaluation purposes. These previews can be turned on through the preview features page as detailed below.','AZ900:',1,'AZURE'),(6802,'How do you access preview features ? ','Sign in to Azure portal.\n\nSelect Create a resource in the resources panel to open the New pane.\n\nEnter the word preview into the search box at the top of the New pane.\n\nA list of available preview features is displayed, with the word (preview) next to each one.','AZ900:',1,'AZURE'),(6803,'An Azure dashboard is stored as which type of file?','JSON','AZ900:',1,'AZURE'),(6804,'Which of the following terms refer to spending money upfront and then deducting that expense over time?','Capital expenditure refers to spending of money on physical infrastructure up front, and then deducting that expense from your tax bill over time.','Azure Fundamentals',1,'AZURE'),(6805,'What are some elements of IAAS ? ','Datacenters and buildings, \nNetworks and Firewalls\nServers and Storage','Azure Fundamentals',1,'AZURE'),(6806,'What are some elements of PAAS ? ','Developer tools, Database Management, analytics, Operating systems','Azure Fundamentals',1,'AZURE'),(6807,'What are some elements of SAAS ? ','Host applications ','Azure Fundamentals',1,'AZURE'),(6808,'Which of the following requires the most user management of the cloud services?','IAAS','Azure Fundamentals',1,'AZURE'),(6809,'. You\'re developing an application and want to focus on building, testing, and deploying. You don\'t want to worry about managing the underlying hardware or software. Which cloud service type is best for you?','PAAS','Azure Fundamentals',1,'AZURE'),(6810,'Availability Sets..','An availabilit set is combination of VMs, greater than two in number, that can alternately rebooted during maintenance without having to bring down your application. \n\nA fault domain is a physicall rack of servers, Availability sets will be distributed across fault domains so that should one go down the other will stay available.\n\n \n','Azure Fundamentals',1,'AZURE'),(6811,'VM scale sets...','VM scale sets let you create and manage a group of identicle, load balanced VMs. That way you can more VMs without having to worry about creating logic to bridge them together. \n\nScale sets allow you to centrally manage, configure, and update a large number of VMs in minutes to provide highly available applications. The number of VM instances can automatically increase or decrease in response to demand or a defined schedule. With Virtual Machine Scale Sets, you can build large-scale services for areas such as compute, big data, and container workloads.\n','Azure Fundamentals',1,'AZURE'),(6812,'When you\'re ready to run an job, Azure Batch does the following','Starts a pool of compute VMs ...\nIntalls applications and staging data...\nruns jobs with as many tasks as you need...\nIdentify failures and request work..\nScales down compute pools as needed. \n','Azure Fundamentals',1,'AZURE'),(6813,'Azure containers','An Azure contianer is a modified runtime environment that runs on top of your host OS.\n\nThis environment typically makes containers more lightweight than VMs. This design allows you to respond quickly to changes in demand or failure. Another benefit of containers is you can run multiple isolated applications on a single container host. Since containers are secured and isolated, you don\'t need separate servers for each app.','Azure Fundamentals',1,'AZURE'),(6814,'Describe the process for migrating apps to Containers.','You convert an existing application to one or more containers and then publish one or more container images to the Azure Container Registry.\nBy using the Azure portal or the command line, you deploy the containers to an AKS cluster.\nAzure AD controls access to AKS resources.\nYou access SLA-backed Azure services, such as Azure Database for MySQL, via OSBA.\nOptionally, AKS is deployed with a virtual network.','Azure Fundamentals',1,'AZURE'),(6815,'Describe Azure\'s serverless computing...','Its based on \n\nAbstraction of servers: Serverless computing abstracts the servers you run on. You never explicitly reserve server instances; the platform manages that for you. Each function execution can run on a different compute instance, and this execution context is transparent to the code. With serverless architecture, you simply deploy your code, which then runs with high availability.\n\nEvent-driven scale: Serverless computing is an excellent fit for workloads that respond to incoming events. Events include triggers by timers (for example, if a function needs to run every day at 10:00 AM UTC), HTTP (API and webhook scenarios), queues (for example, with order processing), and much more. Instead of writing an entire application, the developer authors a function, which contains both code and metadata about its triggers and bindings. The platform automatically schedules the function to run and scales the number of compute instances based on the rate of incoming events. Triggers define how a function is invoked and bindings provide a declarative way to connect to services from within the code.\n\nMicro-billing: Traditional computing has the notion of per-second billing, but often, that\'s not as useful as it seems. Even if a customer\'s website gets only one hit a day, they still pay for a full day\'s worth of availability. With serverless computing, they pay only for the time their code runs. If no active function executions occur, they\'re not charged. For example, if the code runs once a day for two minutes, they\'re charged for one execution and two minutes of computing time.','Azure Fundamentals',1,'AZURE'),(6816,'When are Azure functions ideal ? ','When you\'re only concerned with the code running your service and not the undrelying infasctructure.\nResponding to an event like an HTTP request. \n\nAzure Functions scale automatically based on demand, so they\'re a solid choice when demand is variable. For example, you may be receiving messages from an IoT solution used to monitor a fleet of delivery vehicles. You\'ll likely have more data arriving during business hours.\n\nUsing a VM-based approach, you\'d incur costs even when the VM is idle. With functions, Azure runs your code when it\'s triggered and automatically deallocates resources when the function is finished. \n\nThey\'re key because you don\'t have to pay for continuous uptime. \n','Azure Fundamentals',1,'AZURE'),(6817,'Are Azure functions stateless or stateful ?','Azure Functions can be either stateless (the default), where they behave as if they\'re restarted every time they respond to an event, or stateful (called \"Durable Functions\"), where a context is passed through the function to track prior activity.','Azure Fundamentals',1,'AZURE'),(6818,'How are logic apps different from functions ?','Azure Logic Apps are similar to Functions - both enable you to trigger logic based on an event. Where Functions execute code, Logic Apps execute workflows designed to automate business scenarios and built from predefined logic blocks.\n\nYou create Logic apps with a visual designer similar to Salesforce Process Builders.\n\nAs an example, let\'s say a ticket arrives in ZenDesk. You could:\n\nDetect the intent of the message with cognitive services\nCreate an item in SharePoint to track the issue\nIf the customer isn\'t in your database, add them to your Dynamics 365 CRM system\nSend a follow-up email to acknowledge their request\n\n','Azure Fundamentals',1,'AZURE'),(6819,'                Functions	              |       Logic Apps\n\nState:	     Normally stateless, but Durable Functions provide state  |	Stateful\nDevelopment:	Code-first (imperative) |	Designer-first (declarative)\nConnectivity:	About a dozen built-in binding types, write code for custom bindings. |	Large collection of connectors, Enterprise Integration Pack for B2B scenarios, build custom connectors\nActions:	Each activity is an Azure function; write code for activity functions |	Large collection of ready-made actions\nMonitoring:	Azure Application Insights. |	 Azure portal, Log Analytics\nManagement:	REST API, Visual Studio	Azure portal, REST API, PowerShell, Visual Studio\nExecution context: Can run locally or in the cloud	|.  Runs only in the cloud.\n','observe the given table','Azure Fundamentals',1,'AZURE'),(6820,'Suppose you have an existing application running locally on your own server. You need additional capacity but prefer to move to Azure instead of buying upgraded on-premises hardware. Which compute option would likely give you the quickest route to getting your application running in Azure?','You have full control over the VM setup, so you can configure it to match your on-premises server. This control will allow your existing application to run on the Azure VM with little or no change.','Azure Fundamentals',1,'AZURE'),(6821,'Imagine that you work on a photo-sharing application that runs on millions of mobile devices. Demand is unpredictable because you see a spike in usage whenever a locally or nationally significant event occurs. Which Azure compute resource is the best match for this workload?','The photo-sharing app is event driven and needs to handle unpredictable demand. Serverless computing is a good fit for this situation because it is event-based and can scale instantly to process spikes in traffic. It should also be a cost-effective choice because you will pay for compute time only when processing user data.','Azure Fundamentals',1,'AZURE'),(6822,'The compute options give you different levels of control over the configuration of the environment in which your application runs. Which of the following lists the compute options in order of your control from \"most control\" to \"least control\"?','Virtual machines, containers, serverless computing\n\nVirtual machines give you full control over the environment. Containers give you limited control. Serverless computing does not allow you to do any infrastructure configuration.','Azure Fundamentals',1,'AZURE'),(6823,'You need governance when: ','You have multiple engineering teams working in Azure\nYou have multiple subscriptions in your tenant\nYou have regulatory requirements that must be enforced\nYou want to ensure standards are followed for all IT allocated resources','AZURE:Governance',1,'AZURE'),(6824,'How are Azure Policy and RBAC different ? ','RBAC focuses on user actions at different scopes, You might be added to the contributor role for a resource group, allowing you to make changes to anything in that resource group.\n\nPolicy focuses on Resource properties, during deployment and for already existing Resources. Policy controls the types and locations of resources. Unlike RBAC, Policy is a default-allow-explicit-deny system.','AZURE:Governance',1,'AZURE'),(6825,'A policy definition expresses what to evaluate and what action to take\n','For example, you could ensure all public websites are secured with HTTPS, prevent a particular storage type from being created, or force a specific version of SQL Server to be used.','AZURE:Governance',1,'AZURE'),(6826,'Describe the following policy definition: \nAllowed Resource Type','Describe a set rules/conditions that specify which resource types your organization can deploy. It\'s effect is to deny all resources that are not part of this defined list. ','AZURE:Governance',1,'AZURE'),(6827,'Describe the following Policy definition:\nNot allowed resource types','Prevents a list of resource types from being deployed.','AZURE:Governance',1,'AZURE'),(6828,'When you create a policy assignment with the \'New-AzPolicyAssignment\' command what four pieces of information do you have to provide ?','Name: the actual name of the assignment\nDisplayName: sort of like a descriptions\nDefinition: the id of the policy definition you likely got from:  Get-AzPolicyDefinition | Where-Object \nScope: which Resource Group or groupings the policy gets enforced on, could be anything from subscriptions to rgs.\n\n# Create the policy assignment with the built-in definition against your resource group\nNew-AzPolicyAssignment -Name \'audit-vm-manageddisks\' -DisplayName \'Audit VMs without managed disks Assignment\' -Scope $rg.ResourceId -PolicyDefinition $definition','AZURE:Governance',1,'AZURE'),(6829,'Using powershell how could you identify resources in a resource group that are non compliant to the policy assignment ?\n\n','Get-AzPolicyState -ResourceGroupName $rg.ResourceGroupName -PolicyAssignmentName \'audit-vm-manageddisks\' -Filter \'IsCompliant eq false\'','AZURE:Governance',1,'AZURE'),(6830,'Say you have a resource group with 10 resources in it. You apply a policy definition to the resource group, which resources will have this policy enforced on them and which wont\' ? ','It depends on which resources are excluded. When assigning the policy in the portal.\nWhen assigning click scope > exclusions and you can list which ones should be excluded. ','AZURE:Governance',1,'AZURE'),(6831,'What happens when a policy effect is set to Audit or AuditIfNotExists and the rule is matched ?','Creates a warning event in the activity log when evaluating a non-compliant resource, but it doesn\'t stop the request.','AZURE:Governance',1,'AZURE'),(6832,'Azure Management Groups are containers for managing access, policies, and compliance across multiple Azure subscriptions. Management groups allow you to order your Azure resources hierarchically into collections, which provide a further level of classification that is above the level of subscriptions. All subscriptions within a management group automatically inherit the conditions applied to the management group. Management groups give you enterprise-grade management at a large scale no matter what type of subscriptions you might have.','na','AZURE:Governance',1,'AZURE'),(6833,'What tool can you use to give user access to multiple subscriptions ?','Management Group. Add many subscriptions to this one management group then create a Role Based Access Control RBAC to give access to it. ','AZURE:Governance',1,'AZURE'),(6834,'Policy can be inherited by resources from Resource Groups, where else can resources and subscriptions inherit conditions from ?','Management groups\nYou can manage your Azure subscriptions more effectively by using Azure Policy and Azure role-based access controls (RBACs). These provide distinct governance conditions that you can apply to each management group. The resources and subscriptions you assign to a management group automatically inherit the conditions that you apply to that management group.','AZURE:Governance',1,'AZURE'),(6835,'What\'s the difference between Azure BluePrints and Azure Resource Manager Templates ?','Nearly everything you want to deploy with a Blueprint you could do with a Resource Manager Template.\nNothing about a Resource Manager Template exists natively in Azure though, it\'s just like a list of resources and properties. With a blueprint however the connection is maintatined between the blueprint and the resources you deployed, that helps with tracking and auditing. \n\nResource Manager templates are stored either locally or in source control. The template gets used for deployments of one or more Azure resources, but once those resources deploy there\'s no active connection or relationship to the template.\n\nWith Blueprints, the relationship between the blueprint definition (what should be deployed) and the blueprint assignment (what was deployed) is preserved. This connection supports improved tracking and auditing of deployments. Blueprints can also upgrade several subscriptions at once that are governed by the same blueprint.\n\nThere\'s no need to choose between a Resource Manager template and a blueprint. Each blueprint can consist of zero or more Resource Manager template artifacts. This support means that previous efforts to develop and maintain a library of Resource Manager templates are reusable in Blueprints.','AZURE:Governance',1,'AZURE'),(6836,'Using a policy in a blueprint would be nice excpet how can you when you can\'t provide parameters ?','You\'re in luck blueprints support using parameters with policies and initiatives. ','AZURE:Governance',1,'AZURE'),(6837,'What are the four sources for transparency into how Microsoft manages the underlying resources you are building on ?','Microsoft Privacy Statement\nMicrosoft Trust Center\nService Trust Portal\nCompliance Manager','AZURE:Governance',1,'AZURE'),(6838,'Where do you look to understand what personal data Microsoft processes, how they do it and for what ?','Privacy statement\n','AZURE:Governance',1,'AZURE'),(6839,'Where do you go to find out how Microsoft implements security privacy compliance and transparency in all products and services ? And what details are given ? ','Trust Center\n\nIt includes:\n\n-In-depth information about security, privacy, compliance offerings, policies, features, and practices across Microsoft cloud products.\n-Recommended resources in the form of a curated list of the most applicable and widely used resources for each topic.\n-Information specific to key organizational roles, including business managers, tenant admins or data security teams, risk assessment and privacy officers, and legal compliance teams.\n-Cross-company document search, which is coming soon and will enable existing cloud service customers to search the Service Trust Portal.\n-Direct guidance and support for when you can\'t find what you\'re looking for.','AZURE:Governance',1,'AZURE'),(6840,'Where do you get audit reports for compliance ?','Service Trust Portal','AZURE:Governance',1,'AZURE'),(6841,'Service Trust portal which hosts the compliance manager can help you see how Microsoft helps your organization maintain and track compliance with standards, laws, and regulations such as ? ','ISO\nSOC\nNIST\nFedRAMP\nGDPR','AZURE:Governance',1,'AZURE'),(6842,'What features does Compliance Manager provide ?','Detailed information provided by Microsoft to auditors and regulators, as part of various third-party audits of Microsoft \'s cloud services against various standards (for example, ISO 27001, ISO 27018, and NIST).\n\nInformation that Microsoft compiles internally for its compliance with regulations (such as HIPAA and the EU GDPR).\n\nAn organization\'s self-assessment of their own compliance with these standards and regulations.\n\nEnables you to assign, track, and record compliance and assessment-related activities, which can help your organization cross team barriers to achieve your organization\'s compliance goals.\n\nProvides a Compliance Score to help you track your progress and prioritize auditing controls that will help reduce your organization\'s exposure to risk.\n\nProvides a secure repository in which to upload and manage evidence and other artifacts related to compliance activities.\n\nProduces richly detailed reports in Microsoft Excel that document the compliance activities performed by Microsoft and your organization, which can be provided to auditors, regulators, and other compliance stakeholders.','AZURE:Governance',1,'AZURE'),(6843,'What do you use to montior health of apps and resources ?','Azure Monitor\nAzure Service Health','AZURE:Governance',1,'AZURE'),(6844,'Which Data Sources can be monitored by Azure Monitor ?','Application monitoring data = Data about the performance and functionality of the code you have written, regardless of its platform.\n\nGuest OS monitoring data = Data about the operating system on which your application is running. This could be running in Azure, another cloud, or on-premises.\n\nAzure resource monitoring data = Data about the operation of an Azure resource.\n\nAzure subscription monitoring data = Data about the operation and management of an Azure subscription, as well as data about the health and operation of Azure itself.\n\nAzure tenant monitoring data = Data about the operation of tenant-level Azure services, such as Azure Active Directory.','AZURE:Governance',1,'AZURE'),(6845,'Where do you look to see how a resource is performing and what resources it\'s consuming ?','Metrics','AZURE:Governance',1,'AZURE'),(6846,'Diagnostics let you ... ?','Enable guest-level monitoring\nPerformance counters: collect performance data\nEvent Logs: enable various event logs\nCrash Dumps: enable or disable\nSinks: send your diagnostic data to other services for more analysis\nAgent: configure agent settings','AZURE:Governance',1,'AZURE'),(6847,'This is a service that monitors the availability, performance, and usage of your web applications, whether they\'re hosted in the cloud or on-premises. It leverages the powerful data analysis platform in Log Analytics to provide you with deeper insights into your application\'s operations. It can diagnose errors without waiting for a user to report them. It includes connection points to a variety of development tools, and integrates with Microsoft Visual Studio to support your DevOps processes.','Application Insights','AZURE:Governance',1,'AZURE'),(6848,'How do you monitor Kubernetes ?','Azure monitor for containers','AZURE:Governance',1,'AZURE'),(6849,'A monitoring solution would\'nt be very effective if you couldn\'t proactively respond to critical conditions detected by the data collected. What are two tools for responding ?','Alerts. \nAzure Monitor proactively notifies you of critical conditions using alerts, and can potentially attempt to take corrective actions. Alert rules based on metrics can provide alerts in almost real-time, based on numeric values. Alert rules based on logs allow for complex logic across data, from multiple sources.\n\nAutoscale. \nAzure Monitor uses Autoscale to ensure that you have the right amount of resources running to manage the load on your application effectively. Autoscale enables you to create rules that use metrics, collected by Azure Monitor, to determine when to automatically add resources to handle increases in load. Autoscale can also help reduce your Azure costs by removing resources that are not being used. You can specify a minimum and maximum number of instances, and provide the logic that determines when Autoscale should increase or decrease resources.','AZURE:Governance',1,'AZURE'),(6850,'Azure Service health is composed of what views ? ','Azure status:\nProvides a global view of the health state of Azure services.\n\nService Health: gives a customizaable dashboard that tracks the state of your services in the regions where you use them. This is where you create and manage service health alerts.\n\n\nResource Health: Gives status on your resources and how they are affected by the health of Azure services.\n ','AZURE:Governance',1,'AZURE'),(6851,'Where do you go to create and manage Service Health alerts ?','Service Health dashboard','AZURE:Governance',1,'AZURE'),(6852,'Which Azure service allows you to configure fine-grained access management for Azure resources, enabling you to grant users only the rights they need to perform their jobs?','Role-based access control (RBAC) provides fine-grained access management for Azure resources, enabling you to grant users only the rights they need to perform their jobs. RBAC is provided at no additional cost to all Azure subscriber.','AZURE:Governance',1,'AZURE'),(6853,'You can download published audit reports and other compliance-related information related to Microsoft’s cloud service from the Service Trust Portal','True','AZURE:Governance',1,'AZURE'),(6854,'Which Azure service allows you to create, assign, and, manage policies to enforce different rules and effects over your resources and stay compliant with your corporate standards and service-level agreements (SLAs)?','Azure Policy is a service in Azure that you use to create, assign, and, manage policies. These policies enforce different rules and effects over your resources, so those resources stay compliant with your corporate standards and service-level agreements (SLAs).','AZURE:Governance',1,'AZURE'),(6855,'What services provides up-to-date status information about the health of Azure services?','Azure Service Health is the correct answer, because it provides you with a global view of the health of Azure services. With Azure Status, a component of Azure Service Health, you can get up-to-the-minute information on service availability.','AZURE:Governance',1,'AZURE'),(6856,'are necessary for the body’s maintenance, growth, and repair.\n','','ASVAB:GS',1,'ASVAB'),(6857,'On a Fahrenheit thermometer, the boiling point of water at sea level is\n','Water boils at 212 degrees on the Fahrenheit scale at sea level. On the Celsius scale, it boils at 100 degrees and on the Kelvin scale at 373 K.\n\nKaplan Test Prep. ASVAB Prep Plus 2020-2021: 6 Practice Tests + Proven Strategies + Online + Video (Kaplan Test Prep) (Kindle Locations 2095-2096). Kaplan Publishing. Kindle Edition. ','ASVAB:GS',1,'ASVAB'),(6858,'The process by which the body’s cells use oxygen and glucose to produce energy, while releasing carbon dioxide and water vapor as waste products, is known as\n','The process by which animals convert oxygen (and sugars) into carbon dioxide and water is called respiration. The reverse process, by which plants convert carbon dioxide and water into sugar and oxygen, is called photosynthesis.\n\nKaplan Test Prep. ASVAB Prep Plus 2020-2021: 6 Practice Tests + Proven Strategies + Online + Video (Kaplan Test Prep) (Kindle Locations 2098-2100). Kaplan Publishing. Kindle Edition. ','ASVAB:GS',1,'ASVAB'),(6859,' __ carry blood back to the heart from the capillaries.\n\n','Veins carry blood from capillaries toward the heart. Arteries carry blood away from the heart. Ventricles are the lower chambers of the heart. Red blood cells are the component of blood that carries oxygen.\n\n','ASVAB:GS',1,'ASVAB'),(6860,'Which of the following is an example of a chemical process?\n\nKaplan Test Prep. ASVAB Prep Plus 2020-2021: 6 Practice Tests + Proven Strategies + Online + Video (Kaplan Test Prep) (Kindle Locations 712-713). Kaplan Publishing. Kindle Edition. ','','ASVAB:GS',1,'ASVAB'),(6861,'A universal donor is a person with which of the following blood types?\n\nKaplan Test Prep. ASVAB Prep Plus 2020-2021: 6 Practice Tests + Proven Strategies + Online + Video (Kaplan Test Prep) (Kindle Location 718). Kaplan Publishing. Kindle Edition. ','','ASVAB:GS',1,'ASVAB'),(6862,'Blood enters the right atrium of the heart from the\n','Blood enters the right atrium of the heart from the vena cava.\n','ASVAB:GS',1,'ASVAB'),(6863,'Which of the following substances has the highest pH?\n\nKaplan Test Prep. ASVAB Prep Plus 2020-2021: 6 Practice Tests + Proven Strategies + Online + Video (Kaplan Test Prep) (Kindle Locations 728-729). Kaplan Publishing. Kindle Edition. ','','ASVAB:GS',1,'ASVAB'),(6864,'Which of the following organs does the most work to break down food using enzymes?\n','','ASVAB:GS',1,'ASVAB'),(6865,'Which of the following is NOT part of the female reproductive system?\n\nKaplan Test Prep. ASVAB Prep Plus 2020-2021: 6 Practice Tests + Proven Strategies + Online + Video (Kaplan Test Prep) (Kindle Locations 739-740). Kaplan Publishing. Kindle Edition. ','','ASVAB:GS',1,'ASVAB'),(6866,'Which of the following is NOT part of the female reproductive system? \n\noviduct uterus ovary testes\n','','ASVAB:GS',1,'ASVAB'),(6867,'The most basic unit of inheritance is ?','','ASVAB:GS',1,'ASVAB'),(6868,'Which of the following is a sedimentary rock? \ngranite \nmarble\nshale \nslate\n','','ASVAB:GS',1,'ASVAB'),(6869,'A producer is also known as a ','','ASVAB:GS',1,'ASVAB'),(6870,'What type of rock is obsidian ?','','ASVAB:GS',1,'ASVAB'),(6871,'During a lunar eclipse .. ','','ASVAB:GS',1,'ASVAB'),(6872,'A centimeter is one hundredth of a meter one tenth of a meter ten meters one hundred meters\n','','ASVAB:GS',1,'ASVAB'),(6873,'Momentum is the push or pull that forces an object to change its speed or direction the rate of change of velocity the rate at which an object changes position the tendency of an object to continue moving in the same direction\n\n','','ASVAB:GS',1,'ASVAB'),(6874,'Which color\'s light waves have the highest frequency ?','','ASVAB:GS',1,'ASVAB'),(6875,'The major portion of an atom’s mass consists of neutrons and protons electrons and protons electrons and neutrons\n','The major portion of an atom’s mass consists of neutrons and protons electrons and protons electrons and neutrons\n\n','ASVAB:GS',1,'ASVAB'),(6876,'Which of the following is NOT an example of an arthropod? crab centipede sea urchin spider\n','','ASVAB:GS',1,'ASVAB'),(6877,'Table salt is considered a(n) ionic compound semi-ionic compound covalent compound element\n','','ASVAB:GS',1,'ASVAB'),(6878,'Over the course of 24 hours...','','ASVAB:GS',1,'ASVAB'),(6879,'Which of the following kingdoms is composed of prokaryotic life forms such as bacteria, and as such is considered the most primitive?\n','','ASVAB:GS',1,'ASVAB'),(6880,'Human beings belong to the phylum Animalia Chordata Mammalia Primata\n','','ASVAB:GS',1,'ASVAB'),(6881,'John bought a camera on sale that normally costs $160. If the price was reduced 20% during the sale, what was the sale price of the camera?\n','','ASVAB:AR',1,'ASVAB'),(6882,'A subway car passes 3 stations every 10 minutes. At this rate, how many stations will it pass in one hour?\n','First set up the rate as a proportion where where x is them number of stations\n\n 3 stations /10 minutes = x stations / 1 hour\n\nThen convert the units:\n\n3 stations /10 minutes = x stations / 60 minutes\n\nthen cross multiply and solve\n\n18','ASVAB:AR',1,'ASVAB'),(6883,'On a certain map 3/4 inch represents one mile. What distance, in miles, is represented by 1 3/4 inches?\n','every 3/4 inch of map there is 1 real mile\n\nso the ratio of inches to the miles they represent is always to 3/4 to 1. \n\ninches / miles = 3/4 / 1 = 3/4\n\n1 3/4 inches = 7/4 inches\n\n7/4 inches / x miles = 3/4\n\ncross multiply: \n\n2 1/3 miles \n\n','ASVAB:AR',1,'ASVAB'),(6884,'A certain box contains baseballs and golf balls. If the ratio of baseballs to golf balls is 2:3 and there are 30 baseballs in the box, how many golf balls are in the box?\n','2 basesball / 3 golfballs\n\n30 bb/x gb = 2/3\n\ncross multiply and solve','ASVAB:AR',1,'ASVAB'),(6885,'Four people shared a taxi to the airport. The fare was $36.00, and they gave the driver a tip equal to 25% of the fare. If they equally shared the cost of the fare and tip, how much did each person pay?\n','The total cost of the ride is:\n36 + (36 * .25)\n\n36 + 9 = 45\n\nif they all paid equally then they each paid:\n\n45/4 = 11.25 ','ASVAB:AR',1,'ASVAB'),(6886,'If a car travels of a kilometer each second, how many kilometers does it travel in an hour?\n','','ASVAB:AR',1,'ASVAB'),(6887,'20 - (-5)','25','ASVAB:AR',1,'ASVAB'),(6888,'Ms. Smith drove a total of 700 miles on a business trip. If her car averaged 35 miles per gallon of gasoline and gasoline cost $1.25 per gallon, what was the cost in dollars of the gasoline for the trip?\n','If she averages 35 miles a gallon she would need 20 gallons to drive 700 miles:\n35 X 20 = 700\n20 X 1.25 = 25 dollars for the trip','ASVAB:AR',1,'ASVAB'),(6889,'After eating 25% of the jelly beans, Brett had 72 left. How many jelly beans did Brett have originally?\n','Be careful with a question like this one. You’re given the percent decrease (25%) and the new number (72), and you’re asked to reconstruct the original number. Don’t just take 25% of 72 and add it on. That 25% is based not on the new number, 72, but on the original number—the number you’re looking for. The best way to do a problem like this is to set up an equation:\n\n(Original number) - (25% of original number) = New Number\nx - .25x = 72\n.75x = 72\nx = 96\n\n','ASVAB:AR',1,'ASVAB'),(6890,'A student finishes the first half of an exam in time it takes him to finish the second half. If the entire exam takes him an hour, how many minutes does he spend on the first half of the exam?\n','The time it takes to complete the entire exam is the sum of the time spent on the first half of the exam and the time spent on the second half. The time spent on the first half is of the time spent on the second half. \n\nIf S represents the time spent on the second half, then the total time spent is \n\n2/3 S + S or 5/3 S\n\nYou know this total time is one hour, or 60 minutes. Set up a simple equation and solve for S.\n\n5/3 S = 60\n5/3S * 3/5 = 60 * 3/5\nS = 36 \n','ASVAB:AR',1,'ASVAB'),(6891,'A 25-ounce solution is 20% alcohol. 50 ounces of water are added to it, what percent of the new solution is alcohol?\n','You\'re asked what percent of the new solution is alc.\n\nThe first solution was 20% alc or 1/5.\n20% of 25 oz is 5 oz\n\nThere were 25oz then 50oz were added so the new solution is 75oz.\n\nso the percent alcohol is 5 oz of 75 oz solution:\n\n% alcohol = alcohol / total solution X 100 %\n\n  = 5/75 X 100 %\n  = % 6 2/3 \n\n\n','ASVAB:AR',1,'ASVAB'),(6892,'Marty has exactly 5 blue pens, 6 black pens, and 4 red pens in his backpack. If he pulls out one pen at random from his backpack, what is the probability that the pen is either red or black?\n','To find probability, determine the number of desired outcomes and divide that by the number of possible outcomes. The probability formula looks like this:\n\nProbability = red or black/ red black blue\n\nP = 10 / 15\n\n= 2/3','ASVAB:AR',1,'ASVAB'),(6893,'From 1980 to 1990 the population of Country X increased by 100%. From 1990 to 2000, the population increased by 50%. What was the combined increase for the period 1980–2000?\n','Be careful with combined percent increase. You cannot just add the two percents because they’re percents of different bases. In this instance, the 100% increase is based on the 1980 population, but the 50% increase is based on the larger 1990 population. If you just added 100% and 50% to get 150%, you would have chosen a wrong answer. The best way to do a problem like this one is to pick a number for the original whole and just see what happens. The best number to pick here is 100.\n\nThe best way to do a problem like this one is to pick a number for the original whole and just see what happens. The best number to pick here is 100.\n\nIf the 1980 population was 100, then a 100% increase would put the 1990 population at 200. And a 50% increase over 200 would be 200 + 100 = 300. Since the population went from 100 to 300, that’s a percent increase of 200%.\n\n','ASVAB:AR',1,'ASVAB'),(6894,'If a worker earns 200 for the first 40 hours of work in a week and then is paid one-and-one-half times her regular rate for any additional hours, how many hours must she work to make $230 in a week?\n','First find out what her normal rate of pay is.\n\n$200 / 40 hours = $5 an hour\n\novertime is 1.5 the normal rate so\n\n3/2 X 5 = $7.50 an hour\n\nNow figure out how long it takes the worker to make $230. It takes her 40 hours to make the first $200. The last $30 are made at the overtime rate. Since it takes one hour to make $7.50 at this rate, you can figure out the number of extra hours by dividing $30 by $7.50 per hour: $30 ÷ $7.50 per hour = 4 hours. The total time needed is 40 hours plus 4 hours, or 44 hours.\n\n','ASVAB:AR',1,'ASVAB'),(6895,'If 50% of x is 150, what is 75% of x?\n\n','The most important thing to keep in mind is that you’re solving for 75% of x and not for x itself. First, you are told that 50% of x is 150. That means that half of x is 150, and that x is 300. So 75% of x = 0.75 × 300 = 225.\n\nKaplan Test Prep. ASVAB Prep Plus 2020-2021: 6 Practice Tests + Proven Strategies + Online + Video (Kaplan Test Prep) (Kindle Locations 2274-2276). Kaplan Publishing. Kindle Edition. ','ASVAB:AR',1,'ASVAB'),(6896,'The total fare for two adults and three children on an excursion boat is $14. If each child’s fare is one half of each adult’s fare, what is the adult fare?\n','This is a question where backsolving can save a lot of time. But you could also set up an equation:\n\nequation represents the total:\n2x + 3y = 14 \nSince each childs fare is half of an adults which is x:\ny = x/2\n\n2x + 3x/2 = 14\nyou do this..\n3x/2 = 14 - 2x\nor this would be easier.. \n4x/2 + 3x/2 = 14\n7x/2 = 14\n7x = 28\nx = 4\ny = 2','14',1,'ASVAB'),(6897,'What is the prime factorization of 140?\n\n','140 = 70 * 2\n140 = 35*2*2\n140= 5*7*2*2','ASVAB:AR',1,'ASVAB'),(6898,'A painter charges $12 an hour while his son charges $6 an hour. If the father and son worked the same amount of time together on a job, how many hours did each of them work if their combined charge for their labor was $108?\n','Combined they charge 18 an hour\nso $18x = 108\n\n6','ASVAB:AR',1,'ASVAB'),(6899,'At garage A it cost 8.75 to park a car for the first hour and $1.25 for each additional hour. At garage B, it costs $5.50 to park a car for the first hour and $2.50 for each additional hour. What is the difference between the cost of parking a car for 5 hours at garage A and parking it for the same length of time at garage B?\n','First figure out A then Figure out B, then substract\n\nThe first hour at garage A costs $8.75 The next 4 hours cost 4 × $1.25 = $5.00 The total cost for parking at garage A = $8.75 + $5.00 = $13.75 The first hour at garage B costs $5.50 The next 4 hours cost 4 × $2.50 = $10.00 The total cost for parking at garage B = $5.50 + $10.00 = $15.50\n\nA = 8.75 + 4*1.25 = 13.75\n\nB = 5 + 4*2.50 = 15.50 = 1.75','ASVAB:AR',1,'ASVAB'),(6900,'Jan types at an average rate of 12 pages per hour. At that rate, how long will it take Jan to type 100 pages?\n','Set up a proportion:\n\n12 pages / 1 hour = 100 pages / x hours \n\n8 1/3 hours','ASVAB:AR',1,'ASVAB'),(6901,'Two large sodas contians the same amount as the three medium sodas. Two medium sodas contain the same amount as three small sodas. How many small sodas contain the same amount as eight large sodas?\n','This problem sets up relationships among large, medium, and small sodas—2 large sodas are equal to 3 medium sodas, and 2 medium sodas are equal to 3 small sodas. How many small sodas equal 8 large sodas? Well, 2 larges equal 3 mediums, so 12 mediums must equal 4 × 2 or 8 large sodas. You now can find how many small sodas represent 12 mediums. Since 2 mediums are the same as 3 small sodas, 12 mediums must equal 6 × 3 or 18 small sodas.\n','ASVAB:AR',1,'ASVAB'),(6902,'If each digit 5 in the number 258,546 is replaced with the digit 7, by how much will the number be increased?\n\n','','ASVAB:AR',1,'ASVAB'),(6903,'Michael bought 2 1/4 pounds of lumber at $4.00 per pound. If a 7% sales tax was added, how much did Michael pay?\n','2.25 * 4 = $9\nThen add 7% sales tax to $9.00. Find 7% of $9.00 by multiplying 0.07 × $9.00 = $0.63. Add $0.63 to $9.00 to get $9.63,\n\n','ASVAB:AR',1,'ASVAB'),(6904,'The ratio of what is equivalent to the ratio of \n3 1/4 to 5 1/4 \n\n','The question asks which of five ratios is equivalent to the ratio of 3 1/4 to 5 1/4 . Since the ratios in the answer choices are expressed in whole numbers, turn this ratio into whole numbers. Start by turning the ratio into improper fractions:\n\n3 1/4 to 5 1/4 \n\n13/4 : 21/4\n\n\n\n','ASVAB:AR',1,'ASVAB'),(6905,'A cat is fed 3/8 of a pound of cat food every day. For how many days will 72 pounds of this cat food feed the cat?\n\n','Set up a proportion:\n\n3/8 lb / 1 day = 72 lb / x days\n\ncross multiply\n\n3x/8 = 72\n3x = 72 * 8\nx = 192','ASVAB:AR',1,'ASVAB'),(6906,'After spending 5/12 of her salary, Eva has $420 left. What is her salary?\n \n','If she spent 5/12 of her salary she has 7/12 left.\nSo 7/12 of her salary is 420$.\n\n7/12x = $420\nx = 720 ','ASVAB:AR',1,'ASVAB'),(6907,'A stock decreases in value by 20%. By what percent must the stock price increase to reach its former value?\n ','The trick here is that while the stock decreases and increases by the same amount it doesn\'t increase or decrease by the same percent. \n\nWhen the stock first decreases, that amount of change is part of a larger whole. If the stock were to increase to its former value, that same amount of change would be a larger percent of a smaller whole.\n\nYou can just pick a number here say $100.\n\nIf the stock decreased from $100 to $80 that a decrease of $20. What percent of 80 is 20 ? \n\n20/80 * %100 = 1/4 * 100 = %25\n\n25% ','ASVAB:AR',1,'ASVAB'),(6908,'Joan can shovel a certain driveway in 50 minutes, If mary can shovel the same driveway in 20 minutes, how long will it take them, to the nearest minute, to shovel the driveway if they work together?\n','This is a combined work problem. So Joan can shovel the whole thing in 50 minutes, so each minute she does 1/50 of the driveway. \n\nMary does 1/20 every minute. \n\nSo in one minute they do:\n\n1/50 + 1/20 = 2/100 + 5/100 = 7/100\n\nSo they do the entire driveway in 100/7 minutes\n\nthey do the entire driveway in minutes. (If you do of a job in 1 minute, you do the whole job in the reciprocal of , or 2 minutes.)\n\n100/7 = 14 2/7 \n\nso about 14 minutes','ASVAB:AR',1,'ASVAB'),(6909,'June’s weekly salary is $70 less than Kelly’s, which is $50 more than Eileen’s. If Eileen earns $280 per week\nHow much does june earn a week ? \n','260','ASVAB:AR',1,'ASVAB'),(6910,'A stock decreases in value by 20%. By what percent must the stock price increase to reach its former value?\n','','ASVAB:AR',1,'ASVAB'),(6911,'What are some things you should think about regarding your current infrastructure before creating a virtual machine ?','Consider how your current infastructure should map to the cloud.\n\nStart with the network\nName the VM\nDecide the location for the VM\nDetermine the size of the VM\nUnderstanding the pricing model\nStorage for the VM\nSelect an operating system','Azure:VMs',1,'AZURE'),(6912,'What questions should you ask when planning your VM ?','What does the server communicate with?\nWhich ports are open?\nWhich OS is used?\nHow much disk space is in use?\nWhat kind of data does this use? Are there restrictions (legal or otherwise) with not having it on-premises?\nWhat sort of CPU, memory, and disk I/O load does the server have? Is there burst traffic to account for?','Azure:VMs',1,'AZURE'),(6913,'What information should be included when naming a VM ?','Environment\nLocation\nRole\nInstance\nProduct/Service','Azure:VMs',1,'AZURE'),(6914,'What are Network Security Groups(NSG) used for ? ','Network Security Groups (NSGs), which allow you to control the traffic flow to and from subnets and to and from VMs. NSGs act as software firewalls, applying custom rules to each inbound or outbound request at the network interface and subnet level. This allows you to fully control every network request coming in or out of the VM.','Azure:VMs',1,'AZURE'),(6915,'There are several resources a VM needs to run. \nYou can provide your own or Azure will create them for you.\nWhat are they ? \nHow are they named if created by Azure for you ?\nWhich are required and which are optional ?','The VM itself\nStorage account for the disks\nVirtual network (shared with other VMs and services)\nNetwork interface to communicate on the network\nNetwork Security Group(s) to secure the network traffic\nPublic Internet address (optional)\n\nAzure will use the name of the VM to create a name for the resource if it creates if for you. ','Azure:VMs',1,'AZURE'),(6916,'What are some considerations when deciding the location of your VM ?','You want to place your VM as close as possible to the customer, this imporoves performance and lets you comply with regulations.\n\nDifferent location support differenet hardware configurations.\n\nThere are alos price differences between locations.\n','Azure:VMs',1,'AZURE'),(6917,'Which Vm size is ideal for running a Database ?','Storage optimized.\n\nStorage optimized VMs are designed to have high disk throughput and IO. Ideal for VMs running databases.','Azure:VMs',1,'AZURE'),(6918,'Which is the fastest and most powerful VM ?','High Performance Compute\n\nHigh performance compute is the fastest and most powerful CPU virtual machines with optional high-throughput network interfaces.','Azure:VMs',1,'AZURE'),(6919,'Which VM is targeted for heavy graphics rendering and video editing ?','GPU','Azure:VMs',1,'AZURE'),(6920,'Since you can\'t change a VM size after creating it, if you need to upgrade a VM size should you completely delete it or just deallocate it ?','Actually you can upgrade an existing VM, you can do so while it\'s running. \n\nYou can upgrade or downgrade the VM - as long as your current hardware configuration is allowed in the new size.','Azure:VMs',1,'AZURE'),(6921,'How are VM\'s priced ?','A subscription will be charged by storage and compute power indepently for every VM. That way you can scale them as needed.','Azure:VMs',1,'AZURE'),(6922,'How is a VM\'s compute charged ?','Compute expenses are priced on a per-hour basis but billed on a per-minute basis. For example, you are only charged for 55 minutes of usage if the VM is deployed for 55 minutes. You are not charged for compute capacity if you stop and deallocate the VM since this releases the hardware. The hourly price varies based on the VM size and OS you select. The cost for a VM includes the charge for the Windows operating system. Linux-based instances are cheaper because there is no operating system license charge.','Azure:VMs',1,'AZURE'),(6923,'How are a VM\'s storage costs charged ?','You are charged separately for the storage the VM uses. The status of the VM has no relation to the storage charges that will be incurred; even if the VM is stopped/deallocated and you aren’t billed for the running VM, you will be charged for the storage used by the disks.','Azure:VMs',1,'AZURE'),(6924,'You have two options when creating a VHD for a VM, what are they and what is the difference ?','Managed and unmanaged disks\n\nWith unmanaged disks, you are responsible for the storage accounts that are used to hold the VHDs that correspond to your VM disks. You pay the storage account rates for the amount of space you use. A single storage account has a fixed-rate limit of 20,000 I/O operations/sec. This means that a storage account is capable of supporting 40 standard virtual hard disks at full utilization. If you need to scale out with more disks, then you\'ll need more storage accounts, which can get complicated.\n\nManaged disks are the newer and recommended disk storage model. They elegantly solve this complexity by putting the burden of managing the storage accounts onto Azure. You specify the size of the disk, up to 4 TB, and Azure creates and manages both the disk and the storage. You don\'t have to worry about storage account limits, which makes managed disks easier to scale out.\n\n','Azure:VMs',1,'AZURE'),(6925,'Describe the options available to create and manage an Azure Virtual Machine','','Azure:VMs',1,'AZURE'),(6926,'In addition to the portal what are the other ways you can manage resources in Azure ?','Azure Resource Manager\nAzure PowerShell\nAzure CLI\nAzure REST API\nAzure Client SDK\nAzure VM Extensions\nAzure Automation Services','Azure:Storage',1,'AZURE'),(6927,'How would you create a VM wiht powershell ? What are the options ?','New-AzVm `\n    -ResourceGroupName \"TestResourceGroup\" `\n    -Name \"test-wp1-eus-vm\" `\n    -Location \"East US\" `\n    -VirtualNetworkName \"test-wp1-eus-network\" `\n    -SubnetName \"default\" `\n    -SecurityGroupName \"test-wp1-eus-nsg\" `\n    -PublicIpAddressName \"test-wp1-eus-pubip\" `\n    -OpenPorts 80,3389','Azure:VMs',1,'AZURE'),(6928,'How would you create a VM with Azure CLI ?','az vm create \\\n    --resource-group TestResourceGroup \\\n    --name test-wp1-eus-vm \\\n    --image win2016datacenter \\\n    --admin-username jonc \\\n    --admin-password aReallyGoodPasswordHere','Azure:VMs',1,'AZURE'),(6929,'You can access VM programmatically via the REST api, what are some of the operations available to you ?','Create and manage availability sets\nAdd and manage virtual machine extensions\nCreate and manage managed disks, snapshots, and images\nAccess the platform images available in Azure\nRetrieve usage information of your resources\nCreate and manage virtual machines\nCreate and manage virtual machine scale sets','Azure:VMs',1,'AZURE'),(6930,'Let\'s assume you want to configure and install additional software on your virtual machine after the initial deployment. You want this task to use a specific configuration, monitored and executed automatically.\nWhat tool should you use ?','Azure VM extensions.\nAzure VM extensions are small applications that allow you to configure and automate tasks on Azure VMs after initial deployment. Azure VM extensions can be run with the Azure CLI, PowerShell, Azure Resource Manager templates, and the Azure portal.\n\nYou bundle extensions with a new VM deployment or run them against an existing system.','Azure:VMs',1,'AZURE'),(6931,' Let\'s assume you have a VM that is monitored for a specific error event. You want to take action and fix the problem as soon as it\'s reported. What tool allows you to set up watcher tasks that can respond to events that may occur in your datacenter.','Process Automation','Azure:VMs',1,'AZURE'),(6932,'What tool allows you to track software updates that become available for the operating system that runs on your VM','Configuraion Management','Azure:VMs',1,'AZURE'),(6933,'Whats the difference between configuration management and update management ?','idk','Azure:VMs',1,'AZURE'),(6934,'What is availability ?','The percentage of time a service is available for use','Azure:VMs',1,'AZURE'),(6935,'Does Microsoft automatically update your VM\'s OS or software ?','No. You have complete control and responsibility for that. However, the underlying software host and hardware are periodically patched to ensure reliability and high performance at all times.','Azure:VMs',1,'AZURE'),(6936,'How do you use an Availability Set ?','Place multiple idnetical VMs into them. That way there is no single point of failure, if one goes down or needs update the others will still be able to provide service.\n\nWhen you place VMs into an availability set, Azure guarantees to spread them across Fault Domains and Update Domains.','Azure:VMs',1,'AZURE'),(6937,'Azure VMs in an Availability Set are spread across: ','Fault Domains and Update domains','Azure:VMs',1,'AZURE'),(6938,'Fault Domain:','A fault domain is a logical group of hardware in Azure that shares a common power source and network switch. You can think of it as a rack within an on-premises datacenter. The first two VMs in an availability set will be provisioned into two different racks so that if the network or the power failed in a rack, only one VM would be affected. Fault domains are also defined for managed disks attached to VMs.','Azure:VMs',1,'AZURE'),(6939,'Update Domain:','An update domain is a logical group of hardware that can undergo maintenance or be rebooted at the same time. Azure will automatically place availability sets into update domains to minimize the impact when the Azure platform introduces host operating system changes. Azure then processes each update domain one at a time.','Azure:VMs',1,'AZURE'),(6940,'In what data scenarios can Azure Backup be used ?','Files and folders on Windows OS machines (physical or virtual, local or cloud)\nApplication-aware snapshots (Volume Shadow Copy Service)\nPopular Microsoft server workloads such as Microsoft SQL Server, Microsoft SharePoint, and Microsoft Exchange\nNative support for Azure Virtual Machines, both Windows, and Linux\nLinux and Windows 10 client machines','Azure:VMs',1,'AZURE'),(6941,' Suppose you want to run a network appliance on a virtual machine. Which workload option should you choose?','Compute optimized virtual machines are designed to have a high CPU-to-memory ratio. Suitable for medium traffic web servers, network appliances, batch processes, and application servers.','Azure:VMs',1,'AZURE'),(6942,'A laptop, smart wtach, and tablet all connect and share data what kind of network is this ?','PAN','Networking',1,'AZURE'),(6943,'What are the distinctions between a LAN and WAN','A LAN is privately operated an exists in one building. A WAN connects multiple offices and multiple organizations. \nLAN is faster like 10 Gbps compared to WAN 1 Gbps\nLAN is less congested. \nA LAN can be managed in house where WAN needs a third party. \n','Networking',1,'AZURE'),(6944,'What are the limitations of a bus topoloyg','The first limitation is the length of the main cable or bus. The longer it gets, the higher the chance of signal dropout. This limitation constrains the physical layout of the network. All devices have to be physically located near each other, for example, in the same room. Finally, if there\'s a break in the bus cable, the whole network fails.','Networking',1,'AZURE'),(6945,'In Which topology is every node connected to every other node ?','Mesh','Networking',1,'AZURE'),(6946,'Which network topology is the most scalable and robust ?','Star','Networking',1,'AZURE'),(6947,'Which IEEE is called Fast Ethernet ? And what\'s its speed ?','IEEE 802.3u 100 Mbps','Networking',1,'AZURE'),(6948,'Which specification covers all physical networking standards for Ethernet and wireless ?','802','Networking',1,'AZURE'),(6949,'Which address is a unique identifier burned into every network enabled device at the time of manufactur ?','MAC address (Media Access Control)','Networking',1,'AZURE'),(6950,'Which network device do you use when two Network devices are some distance from each other ?','Repeater','Networking',1,'AZURE'),(6951,'Which Network device is used to improve performance by reducing unecessary network traffic on network segments ?','Bridge','Networking',1,'AZURE'),(6952,'What\'s the difference between a switch and a hub ?','A hub is like a multiport repeater, it doesn\'t interpret or filter data. A switch can interpret and filter packet data to send them directly to the correct network device. ','Networking',1,'AZURE'),(6953,'Describe the two Azure options for handling network traffic.','Azure hub-spoke\nAzure hub-spoke is a reference architecture. The hub is usually an Azure virtual network that acts as the central connection point between the cloud and an on-premises network. Each spoke is also an Azure virtual network, usually connected to the hub via a peer network. Connections between the cloud and the on-premises network can be made through a VPN gateway or Azure ExpressRoute.\n\nAzure ExpressRoute\nAn ExpressRoute connection is a dedicated circuit between an on-premises network and the cloud that uses a much higher bandwidth than a regular VPN gateway connection. An ExpressRoute circuit is hosted by a connectivity partner and provides a super-resilient connection.','',1,NULL),(6954,'What are network standards used for?','To ensure that hardware and software made by different vendors can work together seamlessly.','Networking',1,'AZURE'),(6955,'What is the primary purpose of a hub?','Hubs offer the simplest form of network. They allow multiple Ethernet-based network-enabled devices to communicate with each other.','Networking',1,'AZURE'),(6956,'Describe the four layers of the Internet Protocol Suite:','Application layer: The top layer of this stack is concerned with application or process communication. The application layer is responsible for determining which communication protocols to use based on what type of message is transmitted. For example, the layer assigns the correct email protocols such as POP, SMTP, or IMAP if the message is email content.\n\nTransport layer: This layer is responsible for host-to-host communication on the network. The protocols associated with this layer are TCP and UDP. TCP is responsible for flow control. UDP is responsible for providing a datagram service.\n\nInternet layer: This layer is responsible for exchanging datagrams. A datagram contains the data from the transport layer and adds in the origin and recipient IP addresses. The protocols associated with this layer are IP, ICMP, and the Internet Protocol Security (IPsec) suite.\n\nNetwork access layer: The bottom layer of this stack is responsible for defining how the data is sent across the network. The protocols associated with this layer are ARP, MAC, Ethernet, DSL, and ISDN.','Networking',1,'AZURE'),(6957,'What two protocols are in the transport layer ? ','TCP UDP','Networking',1,'AZURE'),(6958,'Describe the three Network monitoring tools Azure provides:','Azure Network Watcher: You can use Network Watcher to capture packet data from the Azure services you use. You can also understand the flow of data in network traffic patterns and troubleshoot network-related problems on your network.\n\nNetwork Performance Monitor: Network Performance Monitor monitors and reports on the health of your network, provides insights into its performance, and reports on connectivity between your applications. While Network Performance Monitor is cloud-based, it can provide a hybrid service to monitor both cloud and on-premises networks.\n\nPerformance Monitor: Performance Monitor is a capability within Network Performance Monitor. Designed to monitor network connectivity across your entire estate, whether on-premises or cloud-based, it reports network issues as they occur. Performance Monitor can monitor all network routes, along with redundant paths, and report any issues. It can identify particular network segments that degrade network performance. Performance Monitor can report on the health of the network without needing to rely on SNMP.','Azure:Networking',1,'AZURE'),(6959,'What would you use the Simple Network Management Protocol (SNMP) for?','For collecting and organizing information about managed devices on IP networks and for modifying that information to change device behavior.','Networking',1,'AZURE'),(6960,'What is the Internet Control Message Protocol (ICMP) used for?','To send error messages and operational information that indicate success or failure when communicating with another IP address.\nICMP is a protocol that\'s used to send information about the success or failure of any network operation.','Networking',1,'AZURE'),(6961,'Which of these standards and protocols is used predominately for email?\n\nFTP\nTCP\nSMTP','POP3, SMTP, and IMAP are all email protocols.','Networking',1,'AZURE'),(6962,'What protocol is used to resolve the MAC address of an IP address','The Address Resolution Protocol (ARP) is a communications protocol within the Internet Protocol suite. It\'s a request-response protocol used to resolve the media access control (MAC) address for a given IP address. ARP supports many data link layer technologies, such as Internet Protocol version 4 (IPv4), DECnet, and PUP. When an Internet Protocol version 6 (IPv6) address is resolved, the Neighbor Discovery Protocol (NDP) is used instead of ARP. Without ARP, there would be no means to resolve an IP address to a physical device address.\n\nThere\'s also the Reverse Address Resolution Protocol (RARP), which retrieves an IP address based on the given MAC address.','Networking',1,'AZURE'),(6963,'Most of TCP/IP protocol is stateless, what layer must maintain some state ?','The transport layer operates in a stateful mode because it maintains a connection until all the packets in the message are received.','Networking',1,'AZURE'),(6964,'192.168.0.1 Given this IP address which is the network identifier and which is the host','192 is the network\n1 is the host\n\nthe host number and has to be unique within the network','Networking',1,'AZURE'),(6965,'Describe the classes A - E of IP addresses.','Class	Start address	End address	       addresses available	Subnet mask\nA	0.0.0.0	       127.255.255.255	128	16,777,216	 2,147,483,648	255.0.0.0\nB	128.0.0.0	191.255.255.255	16,384	65,536	        1,073,741,824	255.255.0.0\nC	192.0.0.0	223.255.255.255	2,097,152	     256	536,870,912	255.255.255.0\nD	224.0.0.0	239.255.255.255	-	-	  268,435,456	-\nE	240.0.0.0	255.255.255.255	-	-	 268,435,456	-','Networking',1,'AZURE'),(6966,'What is a subnet ?','A subnet is a way to further divide up an IP address. The IP is the routing address then the subnet is that address within the network located by the IP','Networking',1,'AZURE'),(6967,'How is IPv6 different ?','The structure of IPv6 is different from IPv4. Instead of four decimal numbers, it uses eight groups of four hexadecimal numbers called a hexadectet. Each hexadectet is separated with a colon. A full IPv6 address looks like this: 2001:0db8:0000:0000:0000:8a2e:0370:7334.\n\nSimplified network configuration: IPv6 has address autoconfiguration built into the protocol. For example, a router broadcasts the network prefix and the network device can append its MAC address to self-assign a unique IPv6 address.\nSecurity: IPsec is built into IPv6.\nNew service support: IPv6 eliminates the need for NAT, which makes it easier to create peer-to-peer networks.\nMulticast and anycast functionality: Multicast allows for the broadcast of messages in a one-to-many fashion. Anycast allows a single destination to have multiple routing paths to two or more endpoint destinations.','Networking',1,'AZURE'),(6968,'Which Azure service can use an A AAAA or CNAME record to route traffic to specific resources ?','Azure DNS and alias records ','Azure:Networking',1,'AZURE'),(6969,' How would you access a private network from the internet?','It\'s not possible to access a private network from the internet. A private network can access another private network by using network address translation.','Azure:Networking',1,'AZURE'),(6970,'Describe the three types of Client.','Thick. This type of client is the most common in today\'s network environments. A thick client is sometimes known as a workstation, and can process and store data locally without using a server. The client\'s interaction with a server is minimal and might only be to store data on a shared network drive.\n\nThin. Historically, a thin client was a terminal. A thin client can\'t process or store data locally, and relies totally on the server to provide computational power and storage. Today, thin clients are represented by web applications that request and display information from servers regardless of the device they\'re running on.\n\nHybrid. This client combines the best of both thick and thin clients. A hybrid client can do limited local data processing but has no local storage capability. An example of such a client is a device that renders content and stores the results on the server like we see in the automated rating systems.','Network Security',1,'AZURE'),(6971,'Describe the three client server models.','Request-response. In this model, the client sends a request to the server. The server carries out an activity and sends back a response. The response is either the result of a request or an acknowledgment.\n\nPeer-to-peer (P2P). In this model, every network device attached to the network is both a client and a server. Each client can request services (for example files) from any other device on the network and vice versa. P2P is an unstructured network suited for ad hoc usage.\n\nPublish-subscribe. This model is a messaging pattern, where clients subscribe to a service on the server. When a server receives a new message, it sends a response to each client that has subscribed. An RSS feed is a typical publish-subscribe type of client-server, where the user subscribes to the RSS feed. When new items appear, the user is automatically notified.','Network Security',1,'AZURE'),(6972,'Describe the process of authentication using TLS/SSL.','1 The client sends a \"ClientHello\" message to the server. This message includes information like the SSL/TLS version, and the cryptographic algorithms that the client supports.\n\n2 The server sends a \"ServerHello\" message back that includes the algorithm it has chosen from the list of algorithms supported by the client. The message also includes a session ID, the server\'s digital certificate, and its public key.\n\n3 The client uses the digital certificate to verify the server\'s identity with a certificate authority, so the client can be sure it\'s dealing with a trusted server.\n\n4 A client key exchange happens, where the client sends a shared key that\'s encrypted with the server\'s public key to the server.\n\n5 The client sends a \"finished\" message that\'s encrypted with the shared key.\n\n6 The server sends its own \"finished\" message that is encrypted with the shared key. From this point, the client and the server can continue to exchange messages that are encrypted with the shared encrypted key.','Network Security',1,'AZURE'),(6973,'What\'s the difference between authentication and authorization ?','Authentication	\n-------------\nConfirms whether the user or client is who they claim to be.	\nAsks for credentials like username or password.	\nMust happen before authorization.	\nFor example, an HR member signs in to the HR app.	\n\nAuthorization\n--------------\nConfirms whether the user or client can perform an action against a resource or service.\nChecks permissions attached to the account in the background, and sometimes indicates which permission you need.\n\nThe HR member attempts to delete a user from the wrong department by accident. The action is denied because they don\'t have the right permissions for that department.\n','Network Security',1,'AZURE'),(6974,'What happens in the handshake process of SSL/TLS protocol?','he server sends a \"ServerHello\" message back. This message includes a session ID, the server\'s digital certificate, and its public key.\nThe server and the client exchange a number of messages like this before communication can start flowing officially between the two.','Network Security',1,'AZURE'),(6975,'If 48 is divided by 0.08, the result is\n\nKaplan Test Prep. ASVAB Prep Plus 2020-2021: 6 Practice Tests + Proven Strategies + Online + Video (Kaplan Test Prep) (Kindle Location 1391). Kaplan Publishing. Kindle Edition. ','','ASVAB:MK',1,'ASVAB'),(6976,'If the number 9,899,399 is increased by 2,082, the result will be\n\n','Be careful when number crunching, you should be fast and accurate:\n\n9,899,399\n+   2,082\n---------\n9,901,481','ASVAB:MK',1,'ASVAB'),(6977,'The cube of 9 is','','ASVAB:MK',1,'ASVAB'),(6978,'What is the value of (-ab)(a) when a = -2 and b = 3?\n\nKaplan Test Prep. ASVAB Prep Plus 2020-2021: 6 Practice Tests + Proven Strategies + Online + Video (Kaplan Test Prep) (Kindle Location 1406). Kaplan Publishing. Kindle Edition. ','','ASVAB:MK',1,'ASVAB'),(6979,'0.123 × 104\n\nKaplan Test Prep. ASVAB Prep Plus 2020-2021: 6 Practice Tests + Proven Strategies + Online + Video (Kaplan Test Prep) (Kindle Locations 1417-1418). Kaplan Publishing. Kindle Edition. ','','ASVAB:MK',1,'ASVAB'),(6980,'sqrt(100) - sqrt(64)','','ASVAB:MK',1,'ASVAB'),(6981,'A circle has a diameter of 6, an area of b square units, and a circumference of c units. What is the value of b + c?\n\nKaplan Test Prep. ASVAB Prep Plus 2020-2021: 6 Practice Tests + Proven Strategies + Online + Video (Kaplan Test Prep) (Kindle Locations 1428-1429). Kaplan Publishing. Kindle Edition. ','','ASVAB:MK',1,'ASVAB'),(6982,'A bag contains 8 white, 4 red, 7 green, and 5 blue marbles. Eight marbles are withdrawn at random. How many of the withdrawn marbles are white if the chance of drawing a white marble is now 1 in 4?\n','','ASVAB:MK',1,'ASVAB'),(6983,'Liza has 40 fewer than 3 times the number of books that Janice has. If B is equal to the number of books that Janice has, which of the following expressions shows the number of books that Liza and Janice have together ? \n\nKaplan Test Prep. ASVAB Prep Plus 2020-2021: 6 Practice Tests + Proven Strategies + Online + Video (Kaplan Test Prep) (Kindle Locations 1439-1441). Kaplan Publishing. Kindle Edition. ','','ASVAB:MK',1,'ASVAB'),(6984,'if x != 0 then 6x^2 / 2x^2 is','','ASVAB:MK',1,'ASVAB'),(6985,'A number is considered “blue” if the sum of its digits is equal to the product of its digits. Which of the following is “blue”?\n\n111 220 321 422 \n\nKaplan Test Prep. ASVAB Prep Plus 2020-2021: 6 Practice Tests + Proven Strategies + Online + Video (Kaplan Test Prep) (Kindle Locations 1458-1459). Kaplan Publishing. Kindle Edition. ','','ASVAB:MK',1,'ASVAB'),(6986,'If x = , what is the value of y when ?\n\nKaplan Test Prep. ASVAB Prep Plus 2020-2021: 6 Practice Tests + Proven Strategies + Online + Video (Kaplan Test Prep) (Kindle Locations 1463-1465). Kaplan Publishing. Kindle Edition. ','','ASVAB:MK',1,'ASVAB'),(6987,'If line p above is parallel to line q, what is the value of x + y?\n\nKaplan Test Prep. ASVAB Prep Plus 2020-2021: 6 Practice Tests + Proven Strategies + Online + Video (Kaplan Test Prep) (Kindle Locations 1472-1473). Kaplan Publishing. Kindle Edition. ','','ASVAB:MK',1,'ASVAB'),(6988,'If 3ab = 6, what is the value of a in terms of b?\n\nKaplan Test Prep. ASVAB Prep Plus 2020-2021: 6 Practice Tests + Proven Strategies + Online + Video (Kaplan Test Prep) (Kindle Locations 1477-1478). Kaplan Publishing. Kindle Edition. ','','ASVAB:MK',1,'ASVAB'),(6989,'When D is divided by 15, the result is 6 with a remainder of 2. What is the remainder when D is divided by 6?\n\nKaplan Test Prep. ASVAB Prep Plus 2020-2021: 6 Practice Tests + Proven Strategies + Online + Video (Kaplan Test Prep) (Kindle Locations 1497-1498). Kaplan Publishing. Kindle Edition. ','','ASVAB:MK',1,'ASVAB'),(6990,'If the average of 7 consecutive even numbers is 24, then the largest number is\n\nKaplan Test Prep. ASVAB Prep Plus 2020-2021: 6 Practice Tests + Proven Strategies + Online + Video (Kaplan Test Prep) (Kindle Locations 1502-1503). Kaplan Publishing. Kindle Edition. ','','ASVAB:MK',1,'ASVAB'),(6991,'A box that has dimensions of 2 inches by 3 inches by 4 inches has a total surface area ?\n\nKaplan Test Prep. ASVAB Prep Plus 2020-2021: 6 Practice Tests + Proven Strategies + Online + Video (Kaplan Test Prep) (Kindle Location 1508). Kaplan Publishing. Kindle Edition. ','','ASVAB:MK',1,'ASVAB'),(6992,'If 100 ÷ x = 10n, then which of the following is equal to nx?\n\nKaplan Test Prep. ASVAB Prep Plus 2020-2021: 6 Practice Tests + Proven Strategies + Online + Video (Kaplan Test Prep) (Kindle Locations 1513-1514). Kaplan Publishing. Kindle Edition. ','','ASVAB:MK',1,'ASVAB'),(6993,'Melissa took 5n photographs on a certain trip. If she gives n photographs to each of her 3 friends, how many photographs will she have left?\n\nKaplan Test Prep. ASVAB Prep Plus 2020-2021: 6 Practice Tests + Proven Strategies + Online + Video (Kaplan Test Prep) (Kindle Locations 1531-1532). Kaplan Publishing. Kindle Edition. ','','ASVAB:MK',1,'ASVAB'),(6994,'Which of the following symbols represents a photosensitive diode?\n','','ASVAB:EI',1,'ASVAB'),(6995,'One hertz is equivalent to \n\n- one cycle per second of any continuous process \n- an acceleration of 1 m/s2 \n- a change in frequency of one cycle per second\n- the negative of a period','','ASVAB:EI',1,'ASVAB'),(6996,'A(n) is an element that freely conducts electricity.\n\nKaplan Test Prep. ASVAB Prep Plus 2020-2021: 6 Practice Tests + Proven Strategies + Online + Video (Kaplan Test Prep) (Kindle Locations 1565-1566). Kaplan Publishing. Kindle Edition. ','','ASVAB:EI',1,'ASVAB'),(6997,'Electron flow theory states that\n\nKaplan Test Prep. ASVAB Prep Plus 2020-2021: 6 Practice Tests + Proven Strategies + Online + Video (Kaplan Test Prep) (Kindle Location 1577). Kaplan Publishing. Kindle Edition. ','','ASVAB:EI',1,'ASVAB'),(6998,'Which of the following CANNOT describe an “earth ground” in home electricity? a buried conduit a copper rod driven into the ground a device made to protect occupants from electrical shock a device for measuring electrical resistance\n\nKaplan Test Prep. ASVAB Prep Plus 2020-2021: 6 Practice Tests + Proven Strategies + Online + Video (Kaplan Test Prep) (Kindle Locations 1571-1575). Kaplan Publishing. Kindle Edition. ','','ASVAB:EI',1,'ASVAB'),(6999,'The “electrical pressure” that causes electrons to flow in one direction through a conducting path is a result of\n\nKaplan Test Prep. ASVAB Prep Plus 2020-2021: 6 Practice Tests + Proven Strategies + Online + Video (Kaplan Test Prep) (Kindle Location 1584). Kaplan Publishing. Kindle Edition. ','','ASVAB:EI',1,'ASVAB'),(7000,'This is the symbol for which type of meter?\n(omega)\nKaplan Test Prep. ASVAB Prep Plus 2020-2021: 6 Practice Tests + Proven Strategies + Online + Video (Kaplan Test Prep) (Kindle Locations 1589-1590). Kaplan Publishing. Kindle Edition. ','','ASVAB:EI',1,'ASVAB'),(7001,'What type of circuit does this symbol represent?\n\nparallel circut\nseries circut\nseries parallel circuit\nshort circuit\n\nKaplan Test Prep. ASVAB Prep Plus 2020-2021: 6 Practice Tests + Proven Strategies + Online + Video (Kaplan Test Prep) (Kindle Location 1597). Kaplan Publishing. Kindle Edition. ','','ASVAB:EI',1,'ASVAB'),(7002,'Under a constant voltage, increasing resistance results in current flow\n\nKaplan Test Prep. ASVAB Prep Plus 2020-2021: 6 Practice Tests + Proven Strategies + Online + Video (Kaplan Test Prep) (Kindle Locations 1604-1605). Kaplan Publishing. Kindle Edition. ','','ASVAB:EI',1,'ASVAB'),(7003,'Increasing the voltage in a circuit and keeping resistance the same will result in\n\nKaplan Test Prep. ASVAB Prep Plus 2020-2021: 6 Practice Tests + Proven Strategies + Online + Video (Kaplan Test Prep) (Kindle Location 1610). Kaplan Publishing. Kindle Edition. ','','ASVAB:EI',1,'ASVAB'),(7004,'Several loads in series have different resistances. Given that the same current flows through each of them, what relationship does Ohm’s law predict between resistance and voltage drop?\n\nKaplan Test Prep. ASVAB Prep Plus 2020-2021: 6 Practice Tests + Proven Strategies + Online + Video (Kaplan Test Prep) (Kindle Locations 1615-1617). Kaplan Publishing. Kindle Edition. ','','ASVAB:EI',1,'ASVAB'),(7005,'How are Azure CLI commands structured ?','Commands in the CLI are structured in groups and subgroups. Each group represents a service provided by Azure, and the subgroups divide commands for these services into logical groupings. For example, the storage group contains subgroups including account, blob, and queue.','Azure:CLI',1,NULL),(7006,'Once you login into azure and a tenant how do you list all subscriptions ?','az account list --all','Azure:CLI',1,NULL),(7007,'Create a resource group','az group create --name <name> --location <location>','Azure:CLI',1,NULL),(7008,'How do you create a variable ?','export VARNAME = 56','Azure:CLI',1,NULL),(7009,'How do you filter a reosurce group list ? ','az group list --query \"[?name == \'$RESOURCE_GROUP\']\"\n\nThe query is formatted using JMESPath, which is a standard query language for JSON requests','Azure:CLI',1,NULL),(7010,'Create an app service plan ','az appservice plan create --name $AZURE_APP_PLAN --resource-group $RESOURCE_GROUP --location $AZURE_REGION --sku FREE','Azure:CLI',1,NULL),(7011,'Create a webapp','az webapp create --name $AZURE_WEB_APP --resource-group $RESOURCE_GROUP --plan $AZURE_APP_PLAN','Azure:CLI',1,NULL),(7012,'Deploy code from GitHub to a new webapp','az webapp deployment source config --name $AZURE_WEB_APP --resource-group $RESOURCE_GROUP --repo-url \"https://github.com/Azure-Samples/php-docs-hello-world\" --branch master --manual-integration','Azure:CLI',1,NULL),(7013,'What cmdlet do you use to load modules ?','Import-Module','Azure Powershell',1,'AZURE'),(7014,'Which cmdlet do you use to show the active subscription ?','Get-AzContext','Azure Powershell',1,'AZURE'),(7015,'How do you get a list of all subscriptions in your account ?','Get-AzSubscription','Azure Powershell',1,'AZURE'),(7016,'Change the active subscription','Select-AzSubscription -Subscription \"Visual Studio Enterprise\"','Azure Powershell',1,'AZURE'),(7017,'Print a list of resource groups into a formatted table:\n','Get-AzResourceGroup | Format-Table','Azure Powershell',1,'AZURE'),(7018,'List resources in the resource group ExerciseResources','Get-AzResource -ResourceGroupName ExerciseResources','Azure Powershell',1,'AZURE'),(7019,'Create a VM','New-AzVm \n       -ResourceGroupName <resource group name> \n       -Name <machine name> \n       -Credential <credentials object> \n       -Location <location> \n       -Image <image name>','Azure Powershell',1,'AZURE'),(7020,'How would you use the Get-Credential command inside the New-AZVM command ?','New-AzVM -Name MyVm -ResourceGroupName ExerciseResources -Credential (Get-Credential) ...','Azure Powershell',1,'AZURE'),(7021,'How would you delete, start, stop, update and reomve a vm ?','Remove-AzVM	Deletes an Azure VM.\nStart-AzVM	Start a stopped VM.\nStop-AzVM	Stop a running VM.\nRestart-AzVM	Restart a VM.\nUpdate-AzVM	Updates the configuration for a VM.','Azure Powershell',1,'AZURE'),(7022,'Get the status of a VM and store it in a variable','$vm = Get-AzVM  -Name MyVM -ResourceGroupName ExerciseResources','Azure Powershell',1,'AZURE'),(7023,'Get a virtual machine name MYVM in resource group TESTGroup. Then update it\'s size to Standard_DS3_v2','$ResourceGroupName = \"ExerciseResources\"\n$vm = Get-AzVM  -Name MyVM -ResourceGroupName $ResourceGroupName\n$vm.HardwareProfile.vmSize = \"Standard_DS3_v2\"\n\nUpdate-AzVM -ResourceGroupName $ResourceGroupName  -VM $vm','Azure Powershell',1,'AZURE'),(7024,'0 / 5 = \n5 / 0 =','0 / 5 = 0 \n5 / 0 = undefined\n\nYou can\'t divide by zero because it\'s impossible, there\'s no amount of zeros that can equal 5','Pre-Cal',1,NULL),(7025,'What\'s the reciprocal of x - 2 ?','1 / x - 2','Pre-Cal',1,NULL),(7026,'2 / 5 * 4 / 7 = ','8 / 35\n\nWhen multiplying fractions just multiply across','Pre-Cal',1,NULL),(7027,'3 / 10 ÷ 4/5','When dividing fractions flip the second fraction then multiply:\n\n3 / 10 ÷ 4 / 5 = 3 / 10 * 5 / 4 = 15 / 30 = 3/4','Pre-Cal',1,NULL),(7028,'2/5 + 3/8','When adding fractions\n\nif the denominator is different:\n\n1 Find the least common denominator\n 2/5 = 16/40\n 3/8 = 15/40\n2 Once they have the same denominator add them up and keep the least common denominator\n  31/40\n\nThen reduce the fraction\n','Pre-Cal',1,NULL),(7029,'Cancel terms\n\nx^5 Y^2 \n-------\nx^3 z','x^5 Y^2 \n-------\nx^3 z     =\n\nx*x*x*x*x*y*y\n-------------\nx*x*x*z\n\nthen cross out what you can','Pre-Cal',1,NULL),(7030,'What\'s an algebra expression ?','xyz or a^2*p^3*sqrt(q-6)\n\nBasically anything without the equal sign','Pre-Cal',1,NULL),(7031,'When are you allowed to cancel terms ?','Only when an expression has an unbroken chain of multiplication through the entire numerator and the entire denominator:\n\na^4b^2(xy-pg)^4(c+d)\n--------------------\nab^4z(xy-pg)^3\n\nThink of mulitpication as electricity you can only cancel if the current flows from one end to the other:\n\na(xy-pq)(c+d)\n-------\nbz','Pre-Cal',1,NULL),(7032,'a^7b^2(xy - 6z)^3(c+d) + 1\n-------------------------\nc^2*b^3(xy-2)\n','You can\'t cancel here because there is a +1 in the numerator, that would throw the equation out of whack if any canceling was done. ','Pre-Cal',1,NULL),(7033,'x^0 = ','1','Pre-Cal',1,NULL),(7034,'x^-3 ','1 / x^3','Pre-Cal',1,NULL),(7035,'4^-2','1 / 16','Pre-Cal',1,NULL),(7036,'x^2/3','cubert(x)^2 or cubert(x^2)','Pre-Cal',1,NULL),(7037,'x^2 * x^3 = ','x^5\n\nYou add the powers here. You can\'t do anything to x^2 + x^3 because they\'re not like terms.\nYou can only add or subtract terms when the variable part of each term is the same:\n3xy^2z + 4xy^2z = 7xy^2z','Pre-Cal',1,NULL),(7038,'What\'s 3 chairs plus 4 chairs ?\nWhat\'s 3 chairs plus 2 cars ?','7 chairs\nThere\'s no addition there it\'s still 3 chairs and 2 cars. Those are not like terms.','Pre-Cal',1,NULL),(7039,'x^5 / x^3 = ','x ^ 2\n\nx^a / x^b = x^(a-b)','Pre-Cal',1,NULL),(7040,'x^2 / x^5','x^-3','Pre-Cal',1,NULL),(7041,'(x^2)^3 = ','Here you multiply the powers:\nx^6\n\n(x^a)^b = x^ab\n','Pre-Cal',1,NULL),(7042,'(xyz)^4','x^4y^4z^4\n\nDistribute the powers','Pre-Cal',1,NULL),(7043,'(x/y)^4','x^4 / y^4\n\n(x/y)^4 = x^4 / y^4\n\nDistribute powers here too ','Pre-Cal',1,NULL),(7044,'(x+y)^2','THIS DOES NOT EQUAL != x^2 + y^2\n\nYou multiply it out \n\n(x+y)(x+y)\n\nIf you plug numbers in there you can prove which is the right one\n','Pre-Cal',1,NULL),(7045,'4root(x^3)','x^(3/4)','Pre-Cal',1,NULL),(7046,'sqrt(0)\nsqrt(1)','0\n1','Pre-Cal',1,NULL),(7047,'sqrt(a) * sqrt(b)','sqrt(a*b)','Pre-Cal',1,NULL),(7048,'sqrt(a) / sqrt(b)','sqrt(a/b)','Pre-Cal',1,NULL),(7049,'cubert(4root(a))','12root(a)','Pre-Cal',1,NULL),(7050,'4root(a^4)','|a|','Pre-Cal',1,NULL),(7051,'cuberoot(a^3)','a\n\nCancels out','Pre-Cal',1,NULL),(7052,'sqrt(a+b)','DOES NOT equal a+b\n','Pre-Cal',1,NULL),(7053,'sqrt(504)','sqrt(504) = \n\nfirst break it down into all its prime factors\nsqrt(2*2*2*3*3*7)\n\nCircle each pair and take any number circled and put it on the outside\n2*3 * sqrt(2*7)\nSimplify\n\n7sqrt(14)','Pre-Cal',1,NULL),(7054,'What\'s a logarithm ?','It\'s just a different way of expressing an exponential relationship betweeen numbers\n2^3 = 8 \nlog_28 = 3\n\nlog base 2 of 8 equals 3\n\nThe base of a log can be any number greater than zero other than 1\nLog base e is ln ','Pre-Cal',1,NULL),(7055,'log_c1 = ','0','Pre Cal',1,NULL),(7056,'log_CC = ','1\nlog base x of x is always 1','Pre Cal',1,NULL),(7057,'log_c(ab)','log_ca + log_cb','Pre Cal',1,NULL),(7058,'log_c(a/b)','log_ca - log_cb','Pre Cal',1,NULL),(7059,'log_ca^b','b*log_ca','Pre Cal',1,NULL),(7060,'log_ab = ','log_cb / log_ca\n\nYou can calculate something like log_3(20)\n\nlog20/log3 using 10 for c','Pre Cal',1,NULL),(7061,'log_a(a^b)','b','Pre Cal',1,NULL),(7062,'a^(log_a(b))','b','Pre Cal',1,NULL),(7063,'Create a new Vm use Resource group learn-eacfa563-dc75-4adf-9d0b-646aa1c4d8da.\nGive it a name, Location, Credential, use Image UbuntuLTS, and open port 22','New-AzVm -ResourceGroup learn-eacfa563-dc75-4adf-9d0b-646aa1c4d8da -Name \"MaxsVM\" -Location \"westus2\" -Credential (Get-Credential) -Image UbuntuLTS -OpenPorts 22','Azure:Powershell',1,NULL),(7064,'Get a vm by the name of \"TestVM01\" in Resource Group \"BigRG\" store it in a variable $vm, then display information about it\'s disks.','$vm = Get-AzVm -Name \"TestVM01\" -ResourceGroup \"BigRG\"\n$vm.StorageProfile.OsDisk','Azure:Powershell',1,NULL),(7065,'There is a vm stored in variable $vm, display its public Ip addresses','$vm | Get-AzPublicIpAddress','Azure Powershell',1,'AZURE'),(7066,'Get the ip address of your vm in $vm then connect with ssh','$vm | Get-AzPublicIpAddress\n// 888.445.332.0002\nssh uname@888.445.332.0002','Azure Powershell',1,'AZURE'),(7067,'Stop the vm stored in $vm','Stop-AzVM -Name $vm.Name -ResourceGroup $vm.ResourceGroupName','Azure Powershell',1,'AZURE'),(7068,'Delete the vm stored in $vm','Remove-AzVM -Name $vm.Name -ResourceGroup $vm.ResourceGroupName','Azure Powershell',1,'AZURE'),(7069,'Remove the network interface of the Vm stored in $vm','$vm | Remove-AzNetworkInterface –Force','Azure Powershell',1,'AZURE'),(7070,'Remove the managed disks and storage accounts stored in $vm','Get-AzDisk -ResourceGroupName $vm.ResourceGroupName -DiskName $vm.StorageProfile.OSDisk.Name | Remove-AzDisk -Force','Azure Powershell',1,'AZURE'),(7071,'Delete the virtual network of $vm','Get-AzVirtualNetwork -ResourceGroup $vm.ResourceGroupName | Remove-AzVirtualNetwork -Force','Azure Powershell',1,'AZURE'),(7072,'Delete the network security group of $vm','Get-AzNetworkSecurityGroup -ResourceGroup $vm.ResourceGroupName | Remove-AzNetworkSecurityGroup -Force','Azure Powershell',1,'AZURE'),(7073,'Delete the public Ip address in $vm','Get-AzPublicIpAddress -ResourceGroup $vm.ResourceGroupName | Remove-AzPublicIpAddress -Force','Azure Powershell',1,'AZURE'),(7074,'How would you execute a powershell script named script.ps1 ?','./script.ps1','Azure Powershell',1,'AZURE'),(7075,'Write a powershell loop that iterates 5 times','For ($i = 1; $i -lt 5; $i++)\n{\n    $i\n}\n\n\nComparison operators are written:\n-lt less than\n-le less than or equal to\n-eq equal\n-ne not equal','Azure Powershell',1,'AZURE'),(7076,'Pass parameters for size and location to the script setupEnvironment.ps1\nthen inside that script capture them into variables','.\\setupEnvironment.ps1 -size 5 -location \"East US\"\n\nthe parameters and variables are matched by name.\nparam([string]$location, [int]$size)','Azure Powershell',1,'AZURE'),(7077,'Pass parameters for size and location to the script setupEnvironment.ps1\nbut ommit the names of the parameter\nthen inside that script capture them into variables relying only on position','.\\setupEnvironment.ps1 5 \"East US\"\nparam([int]$size, [string]$location)','Azure Powershell',1,'AZURE'),(7078,'what command do you use to create a new text file ?','touch\n','Azure Powershell',1,'AZURE'),(7079,'What command do you use to capture parameters from command line ?','param','Azure Powershell',1,'AZURE'),(7080,'How would you promtp for a username and password then store the result in a variable ?','$adminCredential = Get-Credential -Message \"Enter a username and password for the VM administrator.\"','Azure Powershell',1,'AZURE'),(7081,'param([string]$resourceGroup)\n\n$adminCredential = Get-Credential -Message \"Enter a username and password for the VM administrator.\"\n\nFor ($i = 1; $i -le 3; $i++)\n{\n    $vmName = \"ConferenceDemo\" + $i\n    Write-Host \"Creating VM: \" $vmName\n    New-AzVm -ResourceGroupName $resourceGroup -Name $vmName -Credential $adminCredential -Image UbuntuLTS\n}','','Azure Powershell',1,'AZURE'),(7082,'Describe the core terminology of Azure AD.\nDescribe the core features of Azure AD.\nDescribe the licensing models for Azure AD','','Active Directory',1,NULL),(7083,'What\'s active directory ?','Azure AD is a cloud-based identity management solution. It helps your company\'s internal users to:\n\nAccess external resources, like Azure services, Office 365, and third-party SaaS applications.\n\nAccess internal resources such as applications on your corporate network, and cloud-based applications that your company builds.\n\nAzure AD stores your users in a tenant that represents an organization. For example, say you have a company tenant where all of your employee user accounts are stored. Users in this tenant can be added to groups so they have a common shared-access level. You could have one group for developers and another group for application testers. These groups would have different access levels for applications. Each tenant can have multiple groups that hold multiple users.','Active Directory',1,NULL),(7084,'How can developer benefit from Active Directory ?','Application developers can use Azure AD to enable users to use preexisting credentials to access applications. Developers also use Azure AD to create personalized end-user experiences by accessing organizational user data through APIs that are specific to Azure AD.','Active Directory',1,NULL),(7085,'As an administrator how can you determine how secure your AD tenant is ?','Use the Identity Secure Score\n\nThe identity secure score can help you understand. Azure AD gives an overall value between 1 and 223. This value represents how well you match the recommendations and best practices that Microsoft suggests for tenant security. The identity secure score reveals how effective your security is and helps you implement improvements.\n\nYou can find your tenant\'s identity secure score in the Azure portal. Go to your Azure AD tenant and then open the identity secure score dashboard.','Active Directory',1,NULL),(7086,'What kind of things does the Identity Secure Score show you ?','The dashboard shows information such as how you compare with the industry average and with tenants of the same size as yours. The dashboard also provides a graph that shows how your score has changed over time. You see what you can do to improve your score and how much impact each improvement will have.','Active Directory',1,NULL),(7087,'How is Azure AD different from Active Directory ?','Azure AD is a cloud based idnetity solution that helps you managed users and applications.\nActive Directory manages objects like devices and users on your on-premise network.\n\nActive Directory \nAuthentication: Kerberos.\nstructure: NTLM	Forests, domains, organizational units	.\nUsed for: Authentication and authorization for on-premises printers, applications, file services, and more.\n\nAzure AD\nAuthentication: includes SAML, OAuth, WS-federation.\nStructured as tenants\nInternet-based services and applications like Office 365, Azure services, and third-party SaaS applications','Active Directory',1,NULL),(7088,'Say you want to acheive a hybrid identity for you users to authenticate by. What methods would you use ?','Azure AD password hash synchronization. Here, the user\'s password is hashed twice and synchronized between the on-premises Active Directory and Azure AD. Users have the same credentials to access resources and applications both on-premises and in the cloud.\n\nAzure AD pass-through authentication. Here, an agent is installed on on-premises servers that authenticate against the on-premises Active Directory. When an Azure AD user account tries to authenticate, password authentication is handled on-premises through these servers and Active Directory.\n\nFederated authentication. Here, the authentication process is performed by an on-premises Active Directory Federation Services (AD FS) server that validates users\' passwords. Use this authentication method if you want advanced measures like smart card-based authentication for users.','Active Directory',1,NULL),(7089,'What is an identity security score?','It\'s a number between 1 and 223 that indicates how aligned your security is with Microsoft best practices.\nUse an identity security score to see how secure your Azure AD instance is','Active Directory',1,NULL),(7090,'What do you get with Azure AD free ','You can manage users and groups, and you get basic reports, on-premises Active Directory synchronization, and self-service password reset for Azure AD users. You also get single sign-on for Office 365, Azure services, and many third-party SaaS applications.','Active Directory',1,NULL),(7091,'What do you get with Azure Ad premium p1 ? ','You get all the features from the free tier, but you can also let users access on-premises and cloud-based services and resources. You can use self-service group management or dynamic groups, where users are added and removed automatically, based on your criteria. This tier supports on-premises identity management suites like Microsoft Identity Manager. Self-service password reset is also supported for users who are based on-premises.','Active Directory',1,NULL),(7092,'What do you get with active directory p2 ?','You get all the features of the previous two tiers, along with Active Directory Identity Protection. This feature helps you configure risk-based conditional access to protect applications from identity risks. You can also use privileged identity management, which lets you monitor and put detailed restrictions on administrators.','Active Directory',1,NULL),(7093,'Azure AD gives a base set of permissions to all users. Internal members have more access than guest users.\nGuest users are helpful when working with third parties. What can internal users do with users and contacts that guests can\'t ?','users:\nCan view all profile details. Can change own password, mobile phone number, and profile photos.	\n\nguests: \nCan view only profile name, email, sign-in name, photo, user principal name, and user type properties of other users and contacts. Can change own password.','Active Directory',1,NULL),(7094,'Azure AD gives a base set of permissions to all users. Internal members have more access than guest users.\nGuest users are helpful when working with third parties. What can internal users do with applications that guests can\'t ?','Can register new applications.	\nCan\'t register new applications. Can delete owned applications.','Active Directory',1,NULL),(7095,'Can a guest user delete a Device they own ?','Yes\nUsers\nCan read all properties of devices. Can manage all properties of owned devices.	\n\nGuests\nCan\'t read all properties of devices. Can\'t manage all properties of owned devices. Can delete owned devices.','Active Directory',1,NULL),(7096,'Which licensing plan supports Identity Protection?','Azure Active Directory Premium P2\nIdentity Protection helps you configure risk-based conditional access for your applications to protect them from identity-based risks.\n\nAzure Active Directory Premium P2. You get all the features of the previous two tiers, along with Active Directory Identity Protection. This feature helps you configure risk-based conditional access to protect applications from identity risks. You can also use privileged identity management, which lets you monitor and put detailed restrictions on administrators.','Active Directory',1,NULL),(7097,'Which Azure AD service can you use to collaborate with external partners ? ','Azure AD B2B\nUse Azure AD to invite external users to your tenant. Your organization can then collaborate with external healthcare partner staff members through Azure AD B2B Collaboration.\n\nFor example, your company works with external healthcare partners. These partners can be invited as guest users to your tenant. When their work is done, you can revoke access for those external partners until it\'s needed again.','Active Directory',1,NULL),(7098,'Which Azure AD service do you use to manage your customers\' identities and access','Your doctors\' accounts should have protected access to resources and services. Use Azure AD B2C to securely authenticate the doctors through their preferred identity providers.\n\nAD B2C also helps you monitor for threats like brute force attacks and denial-of-service attacks on doctors\' user accounts. To use Azure AD B2C, you register your applications. You then configure user flows to set up the user\'s journey to access an application.','Active Directory',1,NULL),(7099,'Which service lets users access Virtual Machines using their existing AD credentials ?','Azure AD DS lets you add virtual machines to a domain without needing domain controllers. Your internal staff users can access virtual machines by using their company Azure AD credentials.\n\nUse this service to reduce the complexity of migrating on-premises applications to Azure. An organization could also use Azure AD DS to handle its infrastructure if it runs applications both on-premises and in the cloud. \n\nTo connect with an on premise app:\nThe organization deploys its applications and servers in a virtual network on Azure.\nAzure AD Connect sync synchronizes identity information between the on-premises Active Directory instance and the organization\'s tenant in Azure AD.\nThe company enables Azure AD DS on their Azure AD tenant.\nThe applications and servers in Azure can use features like domain joining and Kerberos authentication.','Active Directory',1,NULL),(7100,'How can you use Azure AD to manage user-access to many different application that internal and external users rely on','you can manage different categories of app in Azure AD\n\nAzure AD App Gallery applications. Thousands of SaaS applications are integrated with Azure AD. Find these applications in Azure Marketplace.\nCustom applications. You can register your company-built applications with Azure AD. You then control and monitor authentication for these applications.\nNon-gallery applications. You can manually add any applications that you don\'t see in the gallery.\nOn-premises applications. You can add on-premises applications by configuring Azure AD Application Proxy. This process creates secure remote access for your on-premises applications. To connect them, download and install the Application Proxy connector on-premises.','Active Directory',1,NULL),(7101,'What would you use to require users to pass additional authentication challenges before they access an application ? ','Conditional Access policies.\nFor example, you can configure a conditional-access policy to require users to complete a multi-factor authentication challenge after their credentials are verified and before they access the application.\nConditional-access policies are available for Premium P1 and Premium P2 license tiers.','Active Directory',1,NULL),(7102,'What kind of details can be had by reports monitoring application access','cover sign-in dates, user details, applications the user has used, risk detection, location, and more. Access those reports through the Azure portal or specific APIs for programmatic usage.','Active Directory',1,NULL),(7103,'What do you use to respond to threats detected by Azure AD Identity Protection ?','You configure a risk policy to set up how Identity Protection should respond to a particular type of risk. Use policies in this way to save time and give you peace of mind.','Active Directory',1,NULL),(7104,' What does Azure AD B2B provide?','Azure AD B2B allows you to invite external users to your tenant so that your staff can collaborate with them.\nIf your company works with external contractors, those contractors can be invited as guest users. When the work is done, access for those contractors can be revoked.','Active Directory',1,NULL),(7105,'What does Azure AD Application Proxy do?','You use it to add on-premises applications to your instance of Azure AD.\nBy using Application Proxy in this way, you create secure remote access for your on-premises applications.','Active Directory',1,NULL),(7106,'Where do you go to create a AD Tenant ?','+ create a resource panel.\n\nTenants are considered resources.\n','Active Directory',1,NULL),(7107,'Deploy an AD environment using the saved steps...','look in Google docs for \"Setting up Azure AD\"\nor\nhttps://docs.microsoft.com/en-us/azure/active-directory/fundamentals/active-directory-deployment-checklist-p2\nso that you know how to do it','Active Directory',1,NULL),(7108,'What benefit does a Content Delivery Network (CDN) provide its users?','Content Delivery Network - allows you to improve performance by removing the burden of serving static, unchanging files from the main server to a network of servers around the globe; a CDN can reduce traffic to a server by 50% or more, which means you can serve more users or serve the same users faster','Azure:Import/Export',1,NULL),(7109,'The standard use for a Content Delivery Network (CDN) cache is to accelerate the serving of static files such as images, videos, and scripts. But when a website is completely customized to each user, where every user sees different content or personalized content, it\'s not as effective. How can a CDN help these dynamic websites serve web content faster to users?','Depending on your settings, a CDN can read the HTML as it passes through and automatically fetch the next files to be delivered without the client needing to ask.','Azure:Import/Export',1,NULL),(7110,'What tool do you use to keep the files on your local machine in sync with you Azure file share ?','Azure File Sync','Azure:Storage',1,NULL),(7111,'What do you keep files in to keep them in sync with other servers using File Sync ?','Sync Group','Azure:Storage',1,NULL),(7112,'You have a storage account in which you have created a Container with a public access level of privae. In that container you have a text file, you click on the text file and go to the Overview section. From there you copy the url to your clipboard and paste it into your browser. What happens ? ','You see the following: \n\n<Error>\n<Code>ResourceNotFound</Code>\n<Message>The specified resource does not exist. RequestId:946aad0b-001e-0030-61f8-5baefb000000 Time:2020-07-17T05:08:53.7708342Z</Message>\n</Error>\n\nIf you want to see that file: \nClick over to the \'Generat SAS\' section\nSet the start adn end time of the keys, and the permissions\nSet the protocols\nYou only get two keys: key 1 and key 2\ngenerate the SAS token and URL \nnow you can use that url to access the above file','Azure:Storage',1,NULL),(7113,'How would you go about connecting a file share to a virtual machine ? ','-On your file share pane choose Connect\n-On the Connect pane you will be given a choice of OS\n these give you a scripts to run in your virtual machine that will connect to the file share\n- Choose the OS of your vm and copy the script to the clipboard. \n- Go to the virtual machine. Find the Operations section, then click \'Run Command\'\n- Paste the script from earlier and run it. \n\nTo verify \ninsert some items into your vm:\n   New-Item -Type Directory -Path \'Z:\\az104-07-folder\'\n   New-Item -Type File -Path \'Z:\\az104-07-folder\\az-104-07-file.txt\'\nGo back to the File Share, Click Refresh and verify that this folder and file appear','Virtual Machines',1,NULL),(7114,'Slope intercept form','y = mx + b','Pre Cal',1,NULL),(7115,'What would be the equation of a straight horizontal line ?','y = 10 \n','Pre Cal',1,NULL),(7116,'point slope form','y - y1 = m(x - x1)','Pre Cal',1,NULL),(7117,'Shift the function y = 2^x right 4 units','Horizontal changes are made by adding or subtracting a number or multiplying a number from or by the input variable x\n\nAll horizontal functions work the opposite of how you would expect.\n- adding to x makes the function go left\n- subtracting makes the function go right\n- Multiplying by a number > 1 shrinks the function \n- Multiplying x by a number < 1 expands the function\n\nSo here y = 2^(x - 4) would shift the function right four units. \nSo instead of passing through 0,1 and 1,2 it passes through (-4,1) (-3,2)','Pre Cal',1,NULL),(7118,'When transforming a function:\n- adding to x makes the function go ___\n- subtracting makes the function go ___\n- Multiplying by a number > 1 ____ the function \n- Multiplying x by a number < 1 ____ the function','All horizontal functions work the opposite of how you would expect.\n\n- adding to x makes the function go left\n- subtracting makes the function go right\n- Multiplying by a number > 1 shrinks the function \n- Multiplying x by a number < 1 expands the function','Pre Cal',1,NULL),(7119,'If you multiply the x in y = 2^x the function ____ horizontally by a factor of 2.\nWhat happens to the y ?','Shrinks\n\nY stays the same. \n\nso if y = 2^x goes through (1,2) so y = 2^2x goes through (.5,2)\n\n','Pre Cal',1,NULL),(7120,'Expand y = 2^x by a factor of 2:\n','y = 2^(1/2x)\n\nso if y = 2^x goes through (-4,1/16) y = 2^(1/2x) goes through (-16,1/16)','Pre Cal',1,NULL),(7121,'How would you reflect a function over the y axis ?','Multiply its x by -1\n(1,2) becomes (-1,2)','Pre Cal',1,NULL),(7122,'How do you vertically transform a function ?','add subtract or multiply the entire functionm by a number \n\nso y = 10^x can be moved upwards by adding to it\n\ny = 10^x + 6','Pre Cal',1,NULL),(7123,'y = 2^x - 4 shifts the original ___\ny = 5 * 10^x shifts the original ___\ny = 10^x + 4 shifts the original ___\ny = 1/3 * 10^x shifts the original ___\n\n','y = 2^x - 4 shifts the original down 4 units\ny = 5 * 10^x stretches the original vertically by a factor of 5\ny = 10^x + 4 shifts the original up 4 units\ny = 1/3 * 10^x shrinks the original vertically by a factor of 3','Pre Cal',1,NULL),(7124,'test','test','test',1,NULL);
/*!40000 ALTER TABLE `FlashCards` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `FlashCardUsers`
--

DROP TABLE IF EXISTS `FlashCardUsers`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `FlashCardUsers` (
  `card_id` int NOT NULL,
  `user_id` int NOT NULL,
  `correct` int NOT NULL DEFAULT '0',
  `incorrect` int NOT NULL DEFAULT '0',
  PRIMARY KEY (`card_id`,`user_id`),
  KEY `fk_user_id` (`user_id`),
  CONSTRAINT `fk_card_id` FOREIGN KEY (`card_id`) REFERENCES `FlashCards` (`card_id`) ON DELETE CASCADE,
  CONSTRAINT `fk_user_id` FOREIGN KEY (`user_id`) REFERENCES `FlashUsers` (`user_id`) ON DELETE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `FlashCardUsers`
--

LOCK TABLES `FlashCardUsers` WRITE;
/*!40000 ALTER TABLE `FlashCardUsers` DISABLE KEYS */;
INSERT INTO `FlashCardUsers` VALUES (27,1,0,0),(28,1,0,0),(29,1,0,0),(30,1,0,0),(31,1,0,0),(32,1,0,0),(33,1,0,0),(36,1,0,0),(37,1,0,0),(38,1,0,0),(39,1,0,0),(40,1,0,0),(41,1,0,0),(42,1,0,0),(43,1,0,0),(44,1,0,0),(45,1,0,0),(46,1,0,0),(47,1,0,0),(48,1,0,0),(49,1,0,0),(50,1,0,0),(51,1,0,0),(52,1,0,0),(54,1,0,0),(55,1,0,0),(56,1,0,0),(57,1,0,0),(58,1,0,0),(59,1,0,0),(60,1,0,0),(61,1,0,0),(62,1,0,0),(63,1,0,0),(64,1,0,0),(65,1,0,0),(66,1,0,0),(67,1,0,0),(68,1,0,0),(69,1,0,0),(70,1,0,0),(71,1,0,0),(72,1,0,0),(73,1,0,0),(74,1,0,0),(75,1,0,0),(76,1,0,0),(77,1,0,0),(78,1,0,0),(79,1,0,0),(80,1,0,0),(81,1,0,0),(82,1,0,0),(83,1,0,0),(84,1,0,0),(85,1,0,0),(86,1,0,0),(87,1,0,0),(88,1,0,0),(89,1,0,0),(90,1,0,0),(91,1,0,0),(92,1,0,0),(93,1,0,0),(94,1,0,0),(95,1,0,0),(96,1,0,0),(97,1,0,0),(98,1,0,0),(99,1,0,0),(100,1,0,0),(101,1,0,0),(102,1,0,0),(103,1,0,0),(104,1,0,0),(105,1,0,0),(106,1,0,0),(107,1,0,0),(108,1,0,0),(109,1,0,0),(111,1,0,0),(112,1,0,0),(113,1,0,0),(114,1,0,0),(115,1,0,0),(116,1,0,0),(117,1,0,0),(118,1,0,0),(119,1,0,0),(120,1,0,0),(121,1,0,0),(122,1,0,0),(123,1,0,0),(124,1,0,0),(125,1,0,0),(126,1,0,0),(127,1,0,0),(128,1,0,0),(129,1,0,0),(130,1,0,0),(131,1,0,0),(132,1,0,0),(133,1,0,0),(134,1,0,0),(135,1,0,0),(136,1,0,0),(137,1,0,0),(138,1,0,0),(139,1,0,0),(140,1,0,0),(141,1,0,0),(142,1,0,0),(143,1,0,0),(144,1,0,0),(145,1,0,0),(146,1,0,0),(147,1,0,0),(148,1,0,0),(149,1,0,0),(150,1,0,0),(151,1,0,0),(152,1,0,0),(153,1,0,0),(154,1,0,0),(155,1,0,0),(156,1,0,0),(157,1,0,0),(158,1,0,0),(159,1,0,0),(160,1,0,0),(161,1,0,0),(162,1,0,0),(163,1,0,0),(164,1,0,0),(165,1,0,0),(166,1,0,0),(167,1,0,0),(168,1,0,0),(169,1,0,0),(170,1,0,0),(171,1,0,0),(172,1,0,0),(173,1,0,0),(174,1,0,0),(175,1,0,0),(176,1,0,0),(177,1,0,0),(178,1,0,0),(179,1,0,0),(180,1,0,0),(181,1,0,0),(182,1,0,0),(183,1,0,0),(184,1,0,0),(185,1,0,0),(186,1,0,0),(187,1,0,0),(188,1,0,0),(189,1,0,0),(190,1,0,0),(191,1,0,0),(192,1,0,0),(193,1,0,0),(194,1,0,0),(195,1,0,0),(196,1,0,0),(197,1,0,0),(198,1,0,0),(199,1,0,0),(200,1,0,0),(201,1,0,0),(202,1,0,0),(203,1,0,0),(204,1,0,0),(205,1,0,0),(206,1,0,0),(207,1,0,0),(208,1,0,0),(209,1,0,0),(210,1,0,0),(211,1,0,0),(212,1,0,0),(213,1,0,0),(214,1,0,0),(215,1,0,0),(216,1,0,0),(217,1,0,0),(218,1,0,0),(219,1,0,0),(220,1,0,0),(221,1,0,0),(222,1,0,0),(223,1,0,0),(224,1,0,0),(225,1,0,0),(226,1,0,0),(227,1,0,0),(228,1,0,0),(229,1,0,0),(230,1,0,0),(231,1,0,0),(232,1,0,0),(233,1,0,0),(234,1,0,0),(235,1,0,0),(236,1,0,0),(237,1,0,0),(238,1,0,0),(239,1,0,0),(240,1,0,0),(241,1,0,0),(242,1,0,0),(243,1,0,0),(244,1,0,0),(245,1,0,0),(246,1,0,0),(247,1,0,0),(248,1,0,0),(249,1,0,0),(250,1,0,0),(251,1,0,0),(252,1,0,0),(253,1,0,0),(254,1,0,0),(255,1,0,0),(256,1,0,0),(257,1,0,0),(258,1,0,0),(259,1,0,0),(260,1,0,0),(261,1,0,0),(262,1,0,0),(263,1,0,0),(264,1,0,0),(265,1,0,0),(266,1,0,0),(267,1,0,0),(268,1,0,0),(269,1,0,0),(270,1,0,0),(271,1,0,0),(272,1,0,0),(273,1,0,0),(274,1,0,0),(275,1,0,0),(276,1,0,0),(277,1,0,0),(278,1,0,0),(279,1,0,0),(280,1,0,0),(281,1,0,0),(282,1,0,0),(283,1,0,0),(284,1,0,0),(285,1,0,0),(286,1,0,0),(287,1,0,0),(288,1,0,0),(289,1,0,0),(290,1,0,0),(291,1,0,0),(292,1,0,0),(293,1,0,0),(294,1,0,0),(295,1,0,0),(296,1,0,0),(297,1,0,0),(298,1,0,0),(299,1,0,0),(300,1,0,0),(301,1,0,0),(302,1,0,0),(303,1,0,0),(304,1,0,0),(305,1,0,0),(306,1,0,0),(307,1,0,0),(308,1,0,0),(309,1,0,0),(310,1,0,0),(311,1,0,0),(312,1,0,0),(313,1,0,0),(314,1,0,0),(315,1,0,0),(316,1,0,0),(317,1,0,0),(318,1,0,0),(319,1,0,0),(320,1,0,0),(321,1,0,0),(322,1,0,0),(323,1,0,0),(324,1,0,0),(325,1,0,0),(326,1,0,0),(327,1,0,0),(328,1,0,0),(329,1,0,0),(330,1,0,0),(331,1,0,0),(332,1,0,0),(333,1,0,0),(334,1,0,0),(335,1,0,0),(336,1,0,0),(337,1,0,0),(338,1,0,0),(339,1,0,0),(340,1,0,0),(341,1,0,0),(342,1,0,0),(343,1,0,0),(344,1,0,0),(345,1,0,0),(346,1,0,0),(347,1,0,0),(348,1,0,0),(349,1,0,0),(350,1,0,0),(351,1,0,0),(352,1,0,0),(353,1,0,0),(354,1,0,0),(355,1,0,0),(356,1,0,0),(357,1,0,0),(358,1,0,0),(359,1,0,0),(360,1,0,0),(361,1,0,0),(362,1,0,0),(363,1,0,0),(364,1,0,0),(365,1,0,0),(366,1,0,0),(367,1,0,0),(368,1,0,0),(369,1,0,0),(370,1,0,0),(371,1,0,0),(372,1,0,0),(373,1,0,0),(374,1,0,0),(375,1,0,0),(376,1,0,0),(377,1,0,0),(378,1,0,0),(379,1,0,0),(380,1,0,0),(381,1,0,0),(382,1,0,0),(383,1,0,0),(384,1,0,0),(385,1,0,0),(386,1,0,0),(387,1,0,0),(388,1,0,0),(389,1,0,0),(390,1,0,0),(391,1,0,0),(392,1,0,0),(393,1,0,0),(394,1,0,0),(395,1,0,0),(396,1,0,0),(397,1,0,0),(398,1,0,0),(399,1,0,0),(400,1,0,0),(401,1,0,0),(402,1,0,0),(403,1,0,0),(404,1,0,0),(405,1,0,0),(406,1,0,0),(407,1,0,0),(408,1,0,0),(409,1,0,0),(410,1,0,0),(411,1,0,0),(412,1,0,0),(413,1,0,0),(414,1,0,0),(415,1,0,0),(416,1,0,0),(417,1,0,0),(418,1,0,0),(419,1,0,0),(420,1,0,0),(421,1,0,0),(422,1,0,0),(423,1,0,0),(424,1,0,0),(425,1,0,0),(426,1,0,0),(427,1,0,0),(428,1,0,0),(429,1,0,0),(430,1,0,0),(431,1,0,0),(432,1,0,0),(433,1,0,0),(434,1,0,0),(435,1,0,0),(436,1,0,0),(437,1,0,0),(438,1,0,0),(439,1,0,0),(440,1,0,0),(441,1,0,0),(442,1,0,0),(443,1,0,0),(444,1,0,0),(445,1,0,0),(446,1,0,0),(447,1,0,0),(448,1,0,0),(449,1,0,0),(450,1,0,0),(451,1,0,0),(452,1,0,0),(453,1,0,0),(454,1,0,0),(455,1,0,0),(456,1,0,0),(457,1,0,0),(458,1,0,0),(459,1,0,0),(460,1,0,0),(461,1,0,0),(462,1,0,0),(463,1,0,0),(464,1,0,0),(465,1,0,0),(466,1,0,0),(467,1,0,0),(468,1,0,0),(469,1,0,0),(470,1,0,0),(471,1,0,0),(472,1,0,0),(473,1,0,0),(474,1,0,0),(475,1,0,0),(476,1,0,0),(477,1,0,0),(478,1,0,0),(479,1,0,0),(480,1,0,0),(481,1,0,0),(482,1,0,0),(483,1,0,0),(484,1,0,0),(485,1,0,0),(486,1,0,0),(487,1,0,0),(488,1,0,0),(489,1,0,0),(490,1,0,0),(491,1,0,0),(492,1,0,0),(493,1,0,0),(494,1,0,0),(495,1,0,0),(496,1,0,0),(497,1,0,0),(498,1,0,0),(499,1,0,0),(500,1,0,0),(501,1,0,0),(502,1,0,0),(503,1,0,0),(504,1,0,0),(505,1,0,0),(506,1,0,0),(507,1,0,0),(508,1,0,0),(509,1,0,0),(510,1,0,0),(511,1,0,0),(512,1,0,0),(513,1,0,0),(514,1,0,0),(515,1,0,0),(516,1,0,0),(517,1,0,0),(518,1,0,0),(519,1,0,0),(520,1,0,0),(521,1,0,0),(522,1,0,0),(523,1,0,0),(524,1,0,0),(525,1,0,0),(526,1,0,0),(527,1,0,0),(528,1,0,0),(529,1,0,0),(530,1,0,0),(531,1,0,0),(532,1,0,0),(533,1,0,0),(534,1,0,0),(535,1,0,0),(536,1,0,0),(537,1,0,0),(538,1,0,0),(539,1,0,0),(540,1,0,0),(541,1,0,0),(542,1,0,0),(543,1,0,0),(544,1,0,0),(545,1,0,0),(546,1,0,0),(547,1,0,0),(548,1,0,0),(549,1,0,0),(550,1,0,0),(551,1,0,0),(552,1,0,0),(553,1,0,0),(554,1,0,0),(555,1,0,0),(556,1,0,0),(557,1,0,0),(558,1,0,0),(559,1,0,0),(560,1,0,0),(561,1,0,0),(562,1,0,0),(563,1,0,0),(564,1,0,0),(565,1,0,0),(566,1,0,0),(567,1,0,0),(568,1,0,0),(569,1,0,0),(570,1,0,0),(571,1,0,0),(572,1,0,0),(573,1,0,0),(574,1,0,0),(575,1,0,0),(576,1,0,0),(577,1,0,0),(578,1,0,0),(579,1,0,0),(580,1,0,0),(581,1,0,0),(582,1,0,0),(583,1,0,0),(584,1,0,0),(585,1,0,0),(586,1,0,0),(587,1,0,0),(588,1,0,0),(589,1,0,0),(590,1,0,0),(591,1,0,0),(592,1,0,0),(593,1,0,0),(594,1,0,0),(595,1,0,0),(596,1,0,0),(597,1,0,0),(598,1,0,0),(599,1,0,0),(600,1,0,0),(601,1,0,0),(602,1,0,0),(603,1,0,0),(604,1,0,0),(605,1,0,0),(606,1,0,0),(607,1,0,0),(608,1,0,0),(609,1,0,0),(610,1,0,0),(611,1,0,0),(612,1,0,0),(613,1,0,0),(614,1,0,0),(615,1,0,0),(616,1,0,0),(617,1,0,0),(618,1,0,0),(619,1,0,0),(620,1,0,0),(621,1,0,0),(622,1,0,0),(623,1,0,0),(624,1,0,0),(625,1,0,0),(626,1,0,0),(627,1,0,0),(628,1,0,0),(629,1,0,0),(630,1,0,0),(631,1,0,0),(632,1,0,0),(633,1,0,0),(634,1,0,0),(635,1,0,0),(636,1,0,0),(637,1,0,0),(638,1,0,0),(639,1,0,0),(640,1,0,0),(641,1,0,0),(642,1,0,0),(643,1,0,0),(644,1,0,0),(645,1,0,0),(646,1,0,0),(647,1,0,0),(648,1,0,0),(649,1,0,0),(650,1,0,0),(651,1,0,0),(652,1,0,0),(653,1,0,0),(654,1,0,0),(655,1,0,0),(656,1,0,0),(657,1,0,0),(658,1,0,0),(659,1,0,0),(660,1,0,0),(661,1,0,0),(662,1,0,0),(663,1,0,0),(664,1,0,0),(665,1,0,0),(666,1,0,0),(667,1,0,0),(668,1,0,0),(669,1,0,0),(670,1,0,0),(671,1,0,0),(672,1,0,0),(673,1,0,0),(674,1,0,0),(675,1,0,0),(676,1,0,0),(677,1,0,0),(678,1,0,0),(679,1,0,0),(680,1,0,0),(681,1,0,0),(682,1,0,0),(683,1,0,0),(684,1,0,0),(685,1,0,0),(686,1,0,0),(687,1,0,0),(688,1,0,0),(689,1,0,0),(690,1,0,0),(691,1,0,0),(692,1,0,0),(693,1,0,0),(694,1,0,0),(695,1,0,0),(696,1,0,0),(697,1,0,0),(698,1,0,0),(699,1,0,0),(700,1,0,0),(701,1,0,0),(702,1,0,0),(703,1,0,0),(704,1,0,0),(705,1,0,0),(706,1,0,0),(707,1,0,0),(708,1,0,0),(709,1,0,0),(710,1,0,0),(711,1,0,0),(712,1,0,0),(713,1,0,0),(714,1,0,0),(715,1,0,0),(716,1,0,0),(717,1,0,0),(718,1,0,0),(719,1,0,0),(720,1,0,0),(721,1,0,0),(722,1,0,0),(723,1,0,0),(724,1,0,0),(725,1,0,0),(726,1,0,0),(727,1,0,0),(728,1,0,0),(729,1,0,0),(730,1,0,0),(731,1,0,0),(732,1,0,0),(733,1,0,0),(734,1,0,0),(735,1,0,0),(736,1,0,0),(737,1,0,0),(738,1,0,0),(739,1,0,0),(740,1,0,0),(741,1,0,0),(742,1,0,0),(743,1,0,0),(744,1,0,0),(745,1,0,0),(746,1,0,0),(747,1,0,0),(748,1,0,0),(749,1,0,0),(750,1,0,0),(751,1,0,0),(752,1,0,0),(753,1,0,0),(754,1,0,0),(755,1,0,0),(756,1,0,0),(757,1,0,0),(758,1,0,0),(759,1,0,0),(760,1,0,0),(761,1,0,0),(762,1,0,0),(763,1,0,0),(764,1,0,0),(765,1,0,0),(766,1,0,0),(767,1,0,0),(768,1,0,0),(769,1,0,0),(770,1,0,0),(771,1,0,0),(772,1,0,0),(773,1,0,0),(774,1,0,0),(775,1,0,0),(776,1,0,0),(777,1,0,0),(778,1,0,0),(779,1,0,0),(780,1,0,0),(781,1,0,0),(782,1,0,0),(783,1,0,0),(784,1,0,0),(785,1,0,0),(786,1,0,0),(787,1,0,0),(789,1,0,0),(790,1,0,0),(791,1,0,0),(792,1,0,0),(793,1,0,0),(794,1,0,0),(795,1,0,0),(796,1,0,0),(797,1,0,0),(798,1,0,0),(799,1,0,0),(800,1,0,0),(801,1,0,0),(802,1,0,0),(803,1,0,0),(804,1,0,0),(805,1,0,0),(806,1,0,0),(807,1,0,0),(808,1,0,0),(809,1,0,0),(810,1,0,0),(811,1,0,0),(812,1,0,0),(813,1,0,0),(814,1,0,0),(815,1,0,0),(816,1,0,0),(817,1,0,0),(818,1,0,0),(819,1,0,0),(820,1,0,0),(821,1,0,0),(822,1,0,0),(823,1,0,0),(824,1,0,0),(825,1,0,0),(826,1,0,0),(827,1,0,0),(828,1,0,0),(829,1,0,0),(830,1,0,0),(831,1,0,0),(832,1,0,0),(833,1,0,0),(834,1,0,0),(835,1,0,0),(836,1,0,0),(837,1,0,0),(838,1,0,0),(839,1,0,0),(840,1,0,0),(841,1,0,0),(842,1,0,0),(843,1,0,0),(844,1,0,0),(845,1,0,0),(846,1,0,0),(847,1,0,0),(848,1,0,0),(849,1,0,0),(850,1,0,0),(851,1,0,0),(852,1,0,0),(853,1,0,0),(854,1,0,0),(855,1,0,0),(856,1,0,0),(857,1,0,0),(858,1,0,0),(859,1,0,0),(860,1,0,0),(861,1,0,0),(862,1,0,0),(863,1,0,0),(864,1,0,0),(865,1,0,0),(866,1,0,0),(867,1,0,0),(868,1,0,0),(869,1,0,0),(870,1,0,0),(871,1,0,0),(872,1,0,0),(873,1,0,0),(874,1,0,0),(875,1,0,0),(876,1,0,0),(877,1,0,0),(878,1,0,0),(879,1,0,0),(880,1,0,0),(881,1,0,0),(882,1,0,0),(883,1,0,0),(884,1,0,0),(885,1,0,0),(886,1,0,0),(887,1,0,0),(888,1,0,0),(889,1,0,0),(890,1,0,0),(891,1,0,0),(892,1,0,0),(893,1,0,0),(894,1,0,0),(895,1,0,0),(896,1,0,0),(897,1,0,0),(898,1,0,0),(899,1,0,0),(900,1,0,0),(901,1,0,0),(902,1,0,0),(903,1,0,0),(904,1,0,0),(905,1,0,0),(906,1,0,0),(907,1,0,0),(908,1,0,0),(909,1,0,0),(910,1,0,0),(911,1,0,0),(912,1,0,0),(913,1,0,0),(914,1,0,0),(915,1,0,0),(916,1,0,0),(917,1,0,0),(918,1,0,0),(919,1,0,0),(920,1,0,0),(921,1,0,0),(922,1,0,0),(923,1,0,0),(924,1,0,0),(925,1,0,0),(926,1,0,0),(927,1,0,0),(928,1,0,0),(929,1,0,0),(930,1,0,0),(931,1,0,0),(932,1,0,0),(933,1,0,0),(934,1,0,0),(935,1,0,0),(936,1,0,0),(937,1,0,0),(938,1,0,0),(939,1,0,0),(940,1,0,0),(941,1,0,0),(942,1,0,0),(943,1,0,0),(944,1,0,0),(945,1,0,0),(946,1,0,0),(947,1,0,0),(948,1,0,0),(949,1,0,0),(950,1,0,0),(951,1,0,0),(952,1,0,0),(953,1,0,0),(954,1,0,0),(955,1,0,0),(956,1,0,0),(957,1,0,0),(958,1,0,0),(959,1,0,0),(960,1,0,0),(961,1,0,0),(962,1,0,0),(963,1,0,0),(964,1,0,0),(965,1,0,0),(966,1,0,0),(967,1,0,0),(968,1,0,0),(969,1,0,0),(970,1,0,0),(971,1,0,0),(972,1,0,0),(973,1,0,0),(974,1,0,0),(975,1,0,0),(976,1,0,0),(977,1,0,0),(978,1,0,0),(979,1,0,0),(980,1,0,0),(981,1,0,0),(982,1,0,0),(983,1,0,0),(984,1,0,0),(985,1,0,0),(986,1,0,0),(987,1,0,0),(988,1,0,0),(989,1,0,0),(990,1,0,0),(991,1,0,0),(992,1,0,0),(993,1,0,0),(994,1,0,0),(995,1,0,0),(996,1,0,0),(997,1,0,0),(998,1,0,0),(999,1,0,0),(1000,1,0,0),(1001,1,0,0),(1002,1,0,0),(1003,1,0,0),(1004,1,0,0),(1005,1,0,0),(1006,1,0,0),(1007,1,0,0),(1008,1,0,0),(1009,1,0,0),(1010,1,0,0),(1011,1,0,0),(1012,1,0,0),(1013,1,0,0),(1014,1,0,0),(1015,1,0,0),(1016,1,0,0),(1017,1,0,0),(1018,1,0,0),(1019,1,0,0),(1020,1,0,0),(1021,1,0,0),(1022,1,0,0),(1023,1,0,0),(1024,1,0,0),(1025,1,0,0),(1026,1,0,0),(1027,1,0,0),(1028,1,0,0),(1029,1,0,0),(1030,1,0,0),(1031,1,0,0),(1032,1,0,0),(1033,1,0,0),(1034,1,0,0),(1035,1,0,0),(1036,1,0,0),(1037,1,0,0),(1038,1,0,0),(1039,1,0,0),(1040,1,0,0),(1041,1,0,0),(1042,1,0,0),(1043,1,0,0),(1044,1,0,0),(1045,1,0,0),(1046,1,0,0),(1047,1,0,0),(1048,1,0,0),(1049,1,0,0),(1050,1,0,0),(1051,1,0,0),(1052,1,0,0),(1053,1,0,0),(1054,1,0,0),(1055,1,0,0),(1056,1,0,0),(1057,1,0,0),(1058,1,0,0),(1059,1,0,0),(1060,1,0,0),(1061,1,0,0),(1062,1,0,0),(1063,1,0,0),(1064,1,0,0),(1065,1,0,0),(1066,1,0,0),(1067,1,0,0),(1068,1,0,0),(1069,1,0,0),(1070,1,0,0),(1071,1,0,0),(1072,1,0,0),(1073,1,0,0),(1074,1,0,0),(1075,1,0,0),(1076,1,0,0),(1077,1,0,0),(1078,1,0,0),(1079,1,0,0),(1080,1,0,0),(1081,1,0,0),(1082,1,0,0),(1083,1,0,0),(1084,1,0,0),(1085,1,0,0),(1086,1,0,0),(1087,1,0,0),(1088,1,0,0),(1089,1,0,0),(1090,1,0,0),(1091,1,0,0),(1092,1,0,0),(1093,1,0,0),(1094,1,0,0),(1095,1,0,0),(1096,1,0,0),(1097,1,0,0),(1098,1,0,0),(1099,1,0,0),(1100,1,0,0),(1101,1,0,0),(1102,1,0,0),(1103,1,0,0),(1104,1,0,0),(1105,1,0,0),(1106,1,0,0),(1107,1,0,0),(1108,1,0,0),(1109,1,0,0),(1110,1,0,0),(1111,1,0,0),(1112,1,0,0),(1113,1,0,0),(1114,1,0,0),(1115,1,0,0),(1116,1,0,0),(1117,1,0,0),(1118,1,0,0),(1119,1,0,0),(1120,1,0,0),(1121,1,0,0),(1122,1,0,0),(1123,1,0,0),(1124,1,0,0),(1125,1,0,0),(1126,1,0,0),(1127,1,0,0),(1128,1,0,0),(1129,1,0,0),(1130,1,0,0),(1131,1,0,0),(1132,1,0,0),(1133,1,0,0),(1134,1,0,0),(1135,1,0,0),(1136,1,0,0),(1137,1,0,0),(1138,1,0,0),(1139,1,0,0),(1140,1,0,0),(1141,1,0,0),(1142,1,0,0),(1143,1,0,0),(1144,1,0,0),(1145,1,0,0),(1146,1,0,0),(1147,1,0,0),(1148,1,0,0),(1149,1,0,0),(1150,1,0,0),(1151,1,0,0),(1152,1,0,0),(1153,1,0,0),(1154,1,0,0),(1155,1,0,0),(1156,1,0,0),(1157,1,0,0),(1158,1,0,0),(1159,1,0,0),(1160,1,0,0),(1161,1,0,0),(1162,1,0,0),(1163,1,0,0),(1164,1,0,0),(1165,1,0,0),(1166,1,0,0),(1167,1,0,0),(1168,1,0,0),(1169,1,0,0),(1170,1,0,0),(1171,1,0,0),(1172,1,0,0),(1173,1,0,0),(1174,1,0,0),(1175,1,0,0),(1176,1,0,0),(1177,1,0,0),(1178,1,0,0),(1179,1,0,0),(1180,1,0,0),(1181,1,0,0),(1182,1,0,0),(1183,1,0,0),(1184,1,0,0),(1185,1,0,0),(1186,1,0,0),(1187,1,0,0),(1189,1,0,0),(1190,1,0,0),(1191,1,0,0),(1192,1,0,0),(1193,1,0,0),(1194,1,0,0),(1195,1,0,0),(1196,1,0,0),(1197,1,0,0),(1198,1,0,0),(1199,1,0,0),(1200,1,0,0),(1201,1,0,0),(1202,1,0,0),(1203,1,0,0),(1204,1,0,0),(1205,1,0,0),(1206,1,0,0),(1207,1,0,0),(1208,1,0,0),(1209,1,0,0),(1210,1,0,0),(1211,1,0,0),(1212,1,0,0),(1213,1,0,0),(1214,1,0,0),(1215,1,0,0),(1216,1,0,0),(1217,1,0,0),(1218,1,0,0),(1219,1,0,0),(1220,1,0,0),(1221,1,0,0),(1222,1,0,0),(1223,1,0,0),(1224,1,0,0),(1225,1,0,0),(1226,1,0,0),(1227,1,0,0),(1228,1,0,0),(1229,1,0,0),(1230,1,0,0),(1231,1,0,0),(1232,1,0,0),(1233,1,0,0),(1234,1,0,0),(1235,1,0,0),(1236,1,0,0),(1237,1,0,0),(1238,1,0,0),(1239,1,0,0),(1240,1,0,0),(1241,1,0,0),(1242,1,0,0),(1243,1,0,0),(1244,1,0,0),(1245,1,0,0),(1246,1,0,0),(1247,1,0,0),(1248,1,0,0),(1249,1,0,0),(1250,1,0,0),(1251,1,0,0),(1252,1,0,0),(1253,1,0,0),(1254,1,0,0),(1255,1,0,0),(1256,1,0,0),(1257,1,0,0),(1258,1,0,0),(1259,1,0,0),(1260,1,0,0),(1261,1,0,0),(1262,1,0,0),(1263,1,0,0),(1264,1,0,0),(1265,1,0,0),(1266,1,0,0),(1267,1,0,0),(1268,1,0,0),(1269,1,0,0),(1270,1,0,0),(1271,1,0,0),(1272,1,0,0),(1273,1,0,0),(1274,1,0,0),(1275,1,0,0),(1276,1,0,0),(1277,1,0,0),(1278,1,0,0),(1279,1,0,0),(1280,1,0,0),(1281,1,0,0),(1282,1,0,0),(1283,1,0,0),(1284,1,0,0),(1285,1,0,0),(1286,1,0,0),(1287,1,0,0),(1288,1,0,0),(1289,1,0,0),(1290,1,0,0),(1291,1,0,0),(1292,1,0,0),(1293,1,0,0),(1294,1,0,0),(1295,1,0,0),(1296,1,0,0),(1297,1,0,0),(1298,1,0,0),(1299,1,0,0),(1300,1,0,0),(1301,1,0,0),(1302,1,0,0),(1303,1,0,0),(1304,1,0,0),(1305,1,0,0),(1306,1,0,0),(1307,1,0,0),(1308,1,0,0),(1309,1,0,0),(1310,1,0,0),(1311,1,0,0),(1312,1,0,0),(1313,1,0,0),(1314,1,0,0),(1315,1,0,0),(1316,1,0,0),(1317,1,0,0),(1318,1,0,0),(1319,1,0,0),(1320,1,0,0),(1321,1,0,0),(1322,1,0,0),(1323,1,0,0),(1324,1,0,0),(1325,1,0,0),(1326,1,0,0),(1327,1,0,0),(1328,1,0,0),(1329,1,0,0),(1330,1,0,0),(1331,1,0,0),(1332,1,0,0),(1333,1,0,0),(1334,1,0,0),(1335,1,0,0),(1336,1,0,0),(1337,1,0,0),(1338,1,0,0),(1339,1,0,0),(1340,1,0,0),(1341,1,0,0),(1342,1,0,0),(1343,1,0,0),(1344,1,0,0),(1345,1,0,0),(1346,1,0,0),(1347,1,0,0),(1348,1,0,0),(1349,1,0,0),(1350,1,0,0),(1351,1,0,0),(1352,1,0,0),(1353,1,0,0),(1354,1,0,0),(1355,1,0,0),(1356,1,0,0),(1357,1,0,0),(1358,1,0,0),(1359,1,0,0),(1360,1,0,0),(1361,1,0,0),(1362,1,0,0),(1363,1,0,0),(1364,1,0,0),(1365,1,0,0),(1366,1,0,0),(1367,1,0,0),(1368,1,0,0),(1369,1,0,0),(1370,1,0,0),(1371,1,0,0),(1372,1,0,0),(1373,1,0,0),(1374,1,0,0),(1375,1,0,0),(1376,1,0,0),(1377,1,0,0),(1378,1,0,0),(1379,1,0,0),(1380,1,0,0),(1381,1,0,0),(1382,1,0,0),(1383,1,0,0),(1384,1,0,0),(1385,1,0,0),(1386,1,0,0),(1387,1,0,0),(1388,1,0,0),(1389,1,0,0),(1390,1,0,0),(1391,1,0,0),(1392,1,0,0),(1393,1,0,0),(1394,1,0,0),(1395,1,0,0),(1396,1,0,0),(1397,1,0,0),(1398,1,0,0),(1399,1,0,0),(1400,1,0,0),(1401,1,0,0),(1402,1,0,0),(1403,1,0,0),(1404,1,0,0),(1405,1,0,0),(1406,1,0,0),(1407,1,0,0),(1408,1,0,0),(1409,1,0,0),(1410,1,0,0),(1411,1,0,0),(1412,1,0,0),(1413,1,0,0),(1414,1,0,0),(1415,1,0,0),(1416,1,0,0),(1417,1,0,0),(1418,1,0,0),(1419,1,0,0),(1420,1,0,0),(1421,1,0,0),(1422,1,0,0),(1423,1,0,0),(1424,1,0,0),(1425,1,0,0),(1426,1,0,0),(1427,1,0,0),(1428,1,0,0),(1429,1,0,0),(1430,1,0,0),(1431,1,0,0),(1432,1,0,0),(1433,1,0,0),(1434,1,0,0),(1435,1,0,0),(1436,1,0,0),(1437,1,0,0),(1438,1,0,0),(1439,1,0,0),(1440,1,0,0),(1441,1,0,0),(1442,1,0,0),(1443,1,0,0),(1444,1,0,0),(1445,1,0,0),(1446,1,0,0),(1447,1,0,0),(1448,1,0,0),(1449,1,0,0),(1450,1,0,0),(1451,1,0,0),(1452,1,0,0),(1453,1,0,0),(1454,1,0,0),(1455,1,0,0),(1456,1,0,0),(1457,1,0,0),(1458,1,0,0),(1459,1,0,0),(1460,1,0,0),(1461,1,0,0),(1462,1,0,0),(1463,1,0,0),(1464,1,0,0),(1465,1,0,0),(1466,1,0,0),(1467,1,0,0),(1468,1,0,0),(1469,1,0,0),(1470,1,0,0),(1471,1,0,0),(1472,1,0,0),(1473,1,0,0),(1474,1,0,0),(1475,1,0,0),(1476,1,0,0),(1477,1,0,0),(1478,1,0,0),(1479,1,0,0),(1480,1,0,0),(1481,1,0,0),(1482,1,0,0),(1483,1,0,0),(1484,1,0,0),(1485,1,0,0),(1486,1,0,0),(1487,1,0,0),(1488,1,0,0),(1489,1,0,0),(1490,1,0,0),(1491,1,0,0),(1492,1,0,0),(1493,1,0,0),(1494,1,0,0),(1495,1,0,0),(1496,1,0,0),(1497,1,0,0),(1498,1,0,0),(1499,1,0,0),(1500,1,0,0),(1501,1,0,0),(1502,1,0,0),(1503,1,0,0),(1504,1,0,0),(1505,1,0,0),(1506,1,0,0),(1507,1,0,0),(1508,1,0,0),(1509,1,0,0),(1510,1,0,0),(1511,1,0,0),(1512,1,0,0),(1513,1,0,0),(1514,1,0,0),(1515,1,0,0),(1516,1,0,0),(1517,1,0,0),(1518,1,0,0),(1519,1,0,0),(1520,1,0,0),(1521,1,0,0),(1522,1,0,0),(1523,1,0,0),(1524,1,0,0),(1525,1,0,0),(1526,1,0,0),(1527,1,0,0),(1528,1,0,0),(1529,1,0,0),(1530,1,0,0),(1531,1,0,0),(1532,1,0,0),(1533,1,0,0),(1534,1,0,0),(1535,1,0,0),(1536,1,0,0),(1537,1,0,0),(1538,1,0,0),(1539,1,0,0),(1540,1,0,0),(1541,1,0,0),(1542,1,0,0),(1543,1,0,0),(1544,1,0,0),(1545,1,0,0),(1546,1,0,0),(1547,1,0,0),(1548,1,0,0),(1549,1,0,0),(1550,1,0,0),(1551,1,0,0),(1552,1,0,0),(1553,1,0,0),(1554,1,0,0),(1555,1,0,0),(1556,1,0,0),(1557,1,0,0),(1558,1,0,0),(1559,1,0,0),(1560,1,0,0),(1561,1,0,0),(1562,1,0,0),(1563,1,0,0),(1564,1,0,0),(1565,1,0,0),(1566,1,0,0),(1567,1,0,0),(1568,1,0,0),(1569,1,0,0),(1570,1,0,0),(1571,1,0,0),(1572,1,0,0),(1573,1,0,0),(1574,1,0,0),(1575,1,0,0),(1576,1,0,0),(1577,1,0,0),(1578,1,0,0),(1579,1,0,0),(1580,1,0,0),(1581,1,0,0),(1582,1,0,0),(1583,1,0,0),(1584,1,0,0),(1585,1,0,0),(1586,1,0,0),(1587,1,0,0),(1588,1,0,0),(1589,1,0,0),(1590,1,0,0),(1591,1,0,0),(1592,1,0,0),(1593,1,0,0),(1594,1,0,0),(1595,1,0,0),(1596,1,0,0),(1597,1,0,0),(1598,1,0,0),(1599,1,0,0),(1600,1,0,0),(1601,1,0,0),(1602,1,0,0),(1603,1,0,0),(1604,1,0,0),(1605,1,0,0),(1606,1,0,0),(1607,1,0,0),(1608,1,0,0),(1609,1,0,0),(1610,1,0,0),(1611,1,0,0),(1612,1,0,0),(1613,1,0,0),(1614,1,0,0),(1615,1,0,0),(1616,1,0,0),(1617,1,0,0),(1618,1,0,0),(1619,1,0,0),(1620,1,0,0),(1621,1,0,0),(1622,1,0,0),(1623,1,0,0),(1624,1,0,0),(1625,1,0,0),(1626,1,0,0),(1627,1,0,0),(1628,1,0,0),(1629,1,0,0),(1630,1,0,0),(1631,1,0,0),(1632,1,0,0),(1633,1,0,0),(1634,1,0,0),(1635,1,0,0),(1636,1,0,0),(1637,1,0,0),(1638,1,0,0),(1639,1,0,0),(1640,1,0,0),(1641,1,0,0),(1642,1,0,0),(1643,1,0,0),(1644,1,0,0),(1645,1,0,0),(1646,1,0,0),(1647,1,0,0),(1648,1,0,0),(1649,1,0,0),(1650,1,0,0),(1651,1,0,0),(1652,1,0,0),(1653,1,0,0),(1654,1,0,0),(1655,1,0,0),(1656,1,0,0),(1657,1,0,0),(1658,1,0,0),(1659,1,0,0),(1660,1,0,0),(1661,1,0,0),(1662,1,0,0),(1663,1,0,0),(1664,1,0,0),(1665,1,0,0),(1666,1,0,0),(1667,1,0,0),(1668,1,0,0),(1669,1,0,0),(1670,1,0,0),(1671,1,0,0),(1672,1,0,0),(1673,1,0,0),(1674,1,0,0),(1675,1,0,0),(1676,1,0,0),(1677,1,0,0),(1678,1,0,0),(1679,1,0,0),(1680,1,0,0),(1681,1,0,0),(1682,1,0,0),(1683,1,0,0),(1684,1,0,0),(1685,1,0,0),(1686,1,0,0),(1687,1,0,0),(1688,1,0,0),(1689,1,0,0),(1690,1,0,0),(1691,1,0,0),(1692,1,0,0),(1693,1,0,0),(1694,1,0,0),(1695,1,0,0),(1696,1,0,0),(1697,1,0,0),(1698,1,0,0),(1699,1,0,0),(1700,1,0,0),(1701,1,0,0),(1702,1,0,0),(1703,1,0,0),(1704,1,0,0),(1705,1,0,0),(1706,1,0,0),(1707,1,0,0),(1708,1,0,0),(1709,1,0,0),(1710,1,0,0),(1711,1,0,0),(1712,1,0,0),(1713,1,0,0),(1714,1,0,0),(1715,1,0,0),(1716,1,0,0),(1717,1,0,0),(1718,1,0,0),(1719,1,0,0),(1720,1,0,0),(1721,1,0,0),(1722,1,0,0),(1723,1,0,0),(1724,1,0,0),(1725,1,0,0),(1726,1,0,0),(1727,1,0,0),(1728,1,0,0),(1729,1,0,0),(1730,1,0,0),(1731,1,0,0),(1732,1,0,0),(1733,1,0,0),(1734,1,0,0),(1735,1,0,0),(1736,1,0,0),(1737,1,0,0),(1738,1,0,0),(1739,1,0,0),(1740,1,0,0),(1741,1,0,0),(1742,1,0,0),(1743,1,0,0),(1744,1,0,0),(1745,1,0,0),(1746,1,0,0),(1747,1,0,0),(1748,1,0,0),(1749,1,0,0),(1750,1,0,0),(1751,1,0,0),(1752,1,0,0),(1753,1,0,0),(1754,1,0,0),(1755,1,0,0),(1756,1,0,0),(1757,1,0,0),(1758,1,0,0),(1759,1,0,0),(1760,1,0,0),(1761,1,0,0),(1762,1,0,0),(1763,1,0,0),(1764,1,0,0),(1765,1,0,0),(1766,1,0,0),(1767,1,0,0),(1768,1,0,0),(1769,1,0,0),(1770,1,0,0),(1771,1,0,0),(1772,1,0,0),(1773,1,0,0),(1774,1,0,0),(1775,1,0,0),(1776,1,0,0),(1777,1,0,0),(1778,1,0,0),(1779,1,0,0),(1780,1,0,0),(1781,1,0,0),(1782,1,0,0),(1783,1,0,0),(1784,1,0,0),(1785,1,0,0),(1786,1,0,0),(1787,1,0,0),(1788,1,0,0),(1789,1,0,0),(1790,1,0,0),(1791,1,0,0),(1792,1,0,0),(1793,1,0,0),(1794,1,0,0),(1795,1,0,0),(1796,1,0,0),(1797,1,0,0),(1798,1,0,0),(1799,1,0,0),(1800,1,0,0),(1801,1,0,0),(1802,1,0,0),(1803,1,0,0),(1804,1,0,0),(1805,1,0,0),(1806,1,0,0),(1807,1,0,0),(1808,1,0,0),(1809,1,0,0),(1810,1,0,0),(1811,1,0,0),(1812,1,0,0),(1813,1,0,0),(1814,1,0,0),(1815,1,0,0),(1816,1,0,0),(1817,1,0,0),(1818,1,0,0),(1819,1,0,0),(1820,1,0,0),(1821,1,0,0),(1822,1,0,0),(1823,1,0,0),(1824,1,0,0),(1825,1,0,0),(1826,1,0,0),(1827,1,0,0),(1828,1,0,0),(1829,1,0,0),(1830,1,0,0),(1831,1,0,0),(1832,1,0,0),(1833,1,0,0),(1834,1,0,0),(1835,1,0,0),(1836,1,0,0),(1837,1,0,0),(1838,1,0,0),(1839,1,0,0),(1840,1,0,0),(1841,1,0,0),(1842,1,0,0),(1843,1,0,0),(1844,1,0,0),(1845,1,0,0),(1846,1,0,0),(1847,1,0,0),(1848,1,0,0),(1849,1,0,0),(1850,1,0,0),(1851,1,0,0),(1852,1,0,0),(1853,1,0,0),(1854,1,0,0),(1855,1,0,0),(1856,1,0,0),(1857,1,0,0),(1858,1,0,0),(1859,1,0,0),(1860,1,0,0),(1861,1,0,0),(1862,1,0,0),(1863,1,0,0),(1864,1,0,0),(1865,1,0,0),(1866,1,0,0),(1867,1,0,0),(1868,1,0,0),(1869,1,0,0),(1870,1,0,0),(1871,1,0,0),(1872,1,0,0),(1873,1,0,0),(1874,1,0,0),(1875,1,0,0),(1876,1,0,0),(1877,1,0,0),(1878,1,0,0),(1879,1,0,0),(1880,1,0,0),(1881,1,0,0),(1882,1,0,0),(1883,1,0,0),(1884,1,0,0),(1885,1,0,0),(1886,1,0,0),(1887,1,0,0),(1888,1,0,0),(1889,1,0,0),(1890,1,0,0),(1891,1,0,0),(1892,1,0,0),(1893,1,0,0),(1894,1,0,0),(1895,1,0,0),(1896,1,0,0),(1897,1,0,0),(1898,1,0,0),(1899,1,0,0),(1900,1,0,0),(1901,1,0,0),(1902,1,0,0),(1903,1,0,0),(1904,1,0,0),(1905,1,0,0),(1906,1,0,0),(1907,1,0,0),(1908,1,0,0),(1909,1,0,0),(1910,1,0,0),(1911,1,0,0),(1912,1,0,0),(1913,1,0,0),(1914,1,0,0),(1915,1,0,0),(1916,1,0,0),(1917,1,0,0),(1918,1,0,0),(1919,1,0,0),(1920,1,0,0),(1921,1,0,0),(1922,1,0,0),(1923,1,0,0),(1924,1,0,0),(1925,1,0,0),(1926,1,0,0),(1927,1,0,0),(1928,1,0,0),(1929,1,0,0),(1930,1,0,0),(1931,1,0,0),(1932,1,0,0),(1933,1,0,0),(1934,1,0,0),(1935,1,0,0),(1936,1,0,0),(1937,1,0,0),(1938,1,0,0),(1939,1,0,0),(1940,1,0,0),(1941,1,0,0),(1942,1,0,0),(1943,1,0,0),(1944,1,0,0),(1945,1,0,0),(1946,1,0,0),(1947,1,0,0),(1948,1,0,0),(1949,1,0,0),(1950,1,0,0),(1951,1,0,0),(1952,1,0,0),(1953,1,0,0),(1954,1,0,0),(1955,1,0,0),(1956,1,0,0),(1957,1,0,0),(1958,1,0,0),(1959,1,0,0),(1960,1,0,0),(1961,1,0,0),(1962,1,0,0),(1963,1,0,0),(1964,1,0,0),(1965,1,0,0),(1966,1,0,0),(1967,1,0,0),(1968,1,0,0),(1969,1,0,0),(1970,1,0,0),(1971,1,0,0),(1972,1,0,0),(1973,1,0,0),(1974,1,0,0),(1975,1,0,0),(1976,1,0,0),(1977,1,0,0),(1978,1,0,0),(1979,1,0,0),(1980,1,0,0),(1981,1,0,0),(1982,1,0,0),(1983,1,0,0),(1984,1,0,0),(1985,1,0,0),(1986,1,0,0),(1987,1,0,0),(1988,1,0,0),(1989,1,0,0),(1990,1,0,0),(1991,1,0,0),(1992,1,0,0),(1993,1,0,0),(1994,1,0,0),(1995,1,0,0),(1996,1,0,0),(1997,1,0,0),(1998,1,0,0),(1999,1,0,0),(2000,1,0,0),(2001,1,0,0),(2002,1,0,0),(2003,1,0,0),(2004,1,0,0),(2005,1,0,0),(2006,1,0,0),(2007,1,0,0),(2008,1,0,0),(2009,1,0,0),(2010,1,0,0),(2011,1,0,0),(2012,1,0,0),(2013,1,0,0),(2014,1,0,0),(2015,1,0,0),(2016,1,0,0),(2017,1,0,0),(2018,1,0,0),(2019,1,0,0),(2020,1,0,0),(2021,1,0,0),(2022,1,0,0),(2023,1,0,0),(2024,1,0,0),(2025,1,0,0),(2026,1,0,0),(2027,1,0,0),(2028,1,0,0),(2029,1,0,0),(2030,1,0,0),(2031,1,0,0),(2032,1,0,0),(2033,1,0,0),(2034,1,0,0),(2035,1,0,0),(2036,1,0,0),(2037,1,0,0),(2038,1,0,0),(2039,1,0,0),(2040,1,0,0),(2041,1,0,0),(2042,1,0,0),(2043,1,0,0),(2044,1,0,0),(2045,1,0,0),(2046,1,0,0),(2047,1,0,0),(2048,1,0,0),(2049,1,0,0),(2050,1,0,0),(2051,1,0,0),(2052,1,0,0),(2053,1,0,0),(2054,1,0,0),(2055,1,0,0),(2056,1,0,0),(2057,1,0,0),(2058,1,0,0),(2059,1,0,0),(2060,1,0,0),(2061,1,0,0),(2062,1,0,0),(2063,1,0,0),(2064,1,0,0),(2065,1,0,0),(2066,1,0,0),(2067,1,0,0),(2068,1,0,0),(2069,1,0,0),(2070,1,0,0),(2071,1,0,0),(2072,1,0,0),(2073,1,0,0),(2074,1,0,0),(2075,1,0,0),(2076,1,0,0),(2077,1,0,0),(2078,1,0,0),(2079,1,0,0),(2080,1,0,0),(2081,1,0,0),(2082,1,0,0),(2083,1,0,0),(2084,1,0,0),(2085,1,0,0),(2086,1,0,0),(2087,1,0,0),(2088,1,0,0),(2089,1,0,0),(2090,1,0,0),(2091,1,0,0),(2092,1,0,0),(2093,1,0,0),(2094,1,0,0),(2095,1,0,0),(2096,1,0,0),(2097,1,0,0),(2098,1,0,0),(2099,1,0,0),(2100,1,0,0),(2101,1,0,0),(2102,1,0,0),(2103,1,0,0),(2104,1,0,0),(2105,1,0,0),(2106,1,0,0),(2107,1,0,0),(2108,1,0,0),(2109,1,0,0),(2110,1,0,0),(2111,1,0,0),(2112,1,0,0),(2113,1,0,0),(2114,1,0,0),(2115,1,0,0),(2116,1,0,0),(2117,1,0,0),(2118,1,0,0),(2119,1,0,0),(2120,1,0,0),(2121,1,0,0),(2122,1,0,0),(2123,1,0,0),(2124,1,0,0),(2125,1,0,0),(2126,1,0,0),(2127,1,0,0),(2128,1,0,0),(2129,1,0,0),(2130,1,0,0),(2131,1,0,0),(2132,1,0,0),(2133,1,0,0),(2134,1,0,0),(2135,1,0,0),(2136,1,0,0),(2137,1,0,0),(2138,1,0,0),(2139,1,0,0),(2140,1,0,0),(2141,1,0,0),(2142,1,0,0),(2143,1,0,0),(2144,1,0,0),(2145,1,0,0),(2146,1,0,0),(2147,1,0,0),(2148,1,0,0),(2149,1,0,0),(2150,1,0,0),(2151,1,0,0),(2152,1,0,0),(2153,1,0,0),(2154,1,0,0),(2155,1,0,0),(2156,1,0,0),(2157,1,0,0),(2158,1,0,0),(2159,1,0,0),(2160,1,0,0),(2161,1,0,0),(2162,1,0,0),(2163,1,0,0),(2164,1,0,0),(2165,1,0,0),(2166,1,0,0),(2167,1,0,0),(2168,1,0,0),(2169,1,0,0),(2170,1,0,0),(2171,1,0,0),(2172,1,0,0),(2173,1,0,0),(2174,1,0,0),(2175,1,0,0),(2176,1,0,0),(2177,1,0,0),(2178,1,0,0),(2179,1,0,0),(2180,1,0,0),(2181,1,0,0),(2182,1,0,0),(2183,1,0,0),(2184,1,0,0),(2185,1,0,0),(2186,1,0,0),(2187,1,0,0),(2188,1,0,0),(2189,1,0,0),(2190,1,0,0),(2191,1,0,0),(2192,1,0,0),(2193,1,0,0),(2194,1,0,0),(2195,1,0,0),(2196,1,0,0),(2197,1,0,0),(2198,1,0,0),(2199,1,0,0),(2200,1,0,0),(2201,1,0,0),(2202,1,0,0),(2203,1,0,0),(2204,1,0,0),(2205,1,0,0),(2206,1,0,0),(2207,1,0,0),(2208,1,0,0),(2209,1,0,0),(2210,1,0,0),(2211,1,0,0),(2212,1,0,0),(2213,1,0,0),(2214,1,0,0),(2215,1,0,0),(2216,1,0,0),(2217,1,0,0),(2218,1,0,0),(2219,1,0,0),(2220,1,0,0),(2221,1,0,0),(2222,1,0,0),(2223,1,0,0),(2224,1,0,0),(2225,1,0,0),(2226,1,0,0),(2227,1,0,0),(2228,1,0,0),(2229,1,0,0),(2230,1,0,0),(2231,1,0,0),(2232,1,0,0),(2233,1,0,0),(2234,1,0,0),(2235,1,0,0),(2236,1,0,0),(2237,1,0,0),(2238,1,0,0),(2239,1,0,0),(2240,1,0,0),(2241,1,0,0),(2242,1,0,0),(2243,1,0,0),(2244,1,0,0),(2245,1,0,0),(2246,1,0,0),(2247,1,0,0),(2248,1,0,0),(2249,1,0,0),(2250,1,0,0),(2251,1,0,0),(2252,1,0,0),(2253,1,0,0),(2254,1,0,0),(2255,1,0,0),(2256,1,0,0),(2257,1,0,0),(2258,1,0,0),(2259,1,0,0),(2260,1,0,0),(2261,1,0,0),(2262,1,0,0),(2263,1,0,0),(2264,1,0,0),(2265,1,0,0),(2266,1,0,0),(2267,1,0,0),(2268,1,0,0),(2269,1,0,0),(2270,1,0,0),(2271,1,0,0),(2272,1,0,0),(2273,1,0,0),(2274,1,0,0),(2275,1,0,0),(2276,1,0,0),(2277,1,0,0),(2278,1,0,0),(2279,1,0,0),(2280,1,0,0),(2281,1,0,0),(2282,1,0,0),(2283,1,0,0),(2284,1,0,0),(2285,1,0,0),(2286,1,0,0),(2287,1,0,0),(2288,1,0,0),(2289,1,0,0),(2290,1,0,0),(2291,1,0,0),(2292,1,0,0),(2293,1,0,0),(2294,1,0,0),(2295,1,0,0),(2296,1,0,0),(2297,1,0,0),(2298,1,0,0),(2299,1,0,0),(2300,1,0,0),(2301,1,0,0),(2302,1,0,0),(2303,1,0,0),(2304,1,0,0),(2305,1,0,0),(2306,1,0,0),(2307,1,0,0),(2308,1,0,0),(2309,1,0,0),(2310,1,0,0),(2311,1,0,0),(2312,1,0,0),(2313,1,0,0),(2314,1,0,0),(2315,1,0,0),(2316,1,0,0),(2317,1,0,0),(2318,1,0,0),(2319,1,0,0),(2320,1,0,0),(2321,1,0,0),(2322,1,0,0),(2323,1,0,0),(2324,1,0,0),(2325,1,0,0),(2326,1,0,0),(2327,1,0,0),(2328,1,0,0),(2329,1,0,0),(2330,1,0,0),(2331,1,0,0),(2332,1,0,0),(2333,1,0,0),(2334,1,0,0),(2335,1,0,0),(2336,1,0,0),(2337,1,0,0),(2338,1,0,0),(2339,1,0,0),(2340,1,0,0),(2341,1,0,0),(2342,1,0,0),(2343,1,0,0),(2344,1,0,0),(2345,1,0,0),(2346,1,0,0),(2347,1,0,0),(2348,1,0,0),(2349,1,0,0),(2350,1,0,0),(2351,1,0,0),(2352,1,0,0),(2353,1,0,0),(2354,1,0,0),(2355,1,0,0),(2356,1,0,0),(2357,1,0,0),(2358,1,0,0),(2359,1,0,0),(2360,1,0,0),(2361,1,0,0),(2362,1,0,0),(2363,1,0,0),(2364,1,0,0),(2365,1,0,0),(2366,1,0,0),(2367,1,0,0),(2368,1,0,0),(2369,1,0,0),(2370,1,0,0),(2371,1,0,0),(2372,1,0,0),(2373,1,0,0),(2374,1,0,0),(2375,1,0,0),(2376,1,0,0),(2377,1,0,0),(2378,1,0,0),(2379,1,0,0),(2380,1,0,0),(2381,1,0,0),(2382,1,0,0),(2383,1,0,0),(2384,1,0,0),(2385,1,0,0),(2386,1,0,0),(2387,1,0,0),(2388,1,0,0),(2389,1,0,0),(2390,1,0,0),(2391,1,0,0),(2392,1,0,0),(2393,1,0,0),(2394,1,0,0),(2395,1,0,0),(2396,1,0,0),(2397,1,0,0),(2398,1,0,0),(2399,1,0,0),(2400,1,0,0),(2401,1,0,0),(2402,1,0,0),(2403,1,0,0),(2404,1,0,0),(2405,1,0,0),(2406,1,0,0),(2407,1,0,0),(2408,1,0,0),(2409,1,0,0),(2410,1,0,0),(2411,1,0,0),(2412,1,0,0),(2413,1,0,0),(2414,1,0,0),(2415,1,0,0),(2416,1,0,0),(2417,1,0,0),(2418,1,0,0),(2419,1,0,0),(2420,1,0,0),(2421,1,0,0),(2422,1,0,0),(2423,1,0,0),(2424,1,0,0),(2425,1,0,0),(2426,1,0,0),(2427,1,0,0),(2428,1,0,0),(2429,1,0,0),(2430,1,0,0),(2431,1,0,0),(2432,1,0,0),(2433,1,0,0),(2434,1,0,0),(2435,1,0,0),(2436,1,0,0),(2437,1,0,0),(2438,1,0,0),(2439,1,0,0),(2440,1,0,0),(2441,1,0,0),(2442,1,0,0),(2443,1,0,0),(2444,1,0,0),(2445,1,0,0),(2446,1,0,0),(2447,1,0,0),(2448,1,0,0),(2449,1,0,0),(2450,1,0,0),(2451,1,0,0),(2452,1,0,0),(2453,1,0,0),(2454,1,0,0),(2455,1,0,0),(2456,1,0,0),(2457,1,0,0),(2458,1,0,0),(2459,1,0,0),(2460,1,0,0),(2461,1,0,0),(2462,1,0,0),(2463,1,0,0),(2464,1,0,0),(2465,1,0,0),(2466,1,0,0),(2467,1,0,0),(2468,1,0,0),(2469,1,0,0),(2470,1,0,0),(2471,1,0,0),(2472,1,0,0),(2473,1,0,0),(2474,1,0,0),(2475,1,0,0),(2476,1,0,0),(2477,1,0,0),(2478,1,0,0),(2479,1,0,0),(2480,1,0,0),(2481,1,0,0),(2482,1,0,0),(2483,1,0,0),(2484,1,0,0),(2485,1,0,0),(2486,1,0,0),(2487,1,0,0),(2488,1,0,0),(2489,1,0,0),(2490,1,0,0),(2491,1,0,0),(2492,1,0,0),(2493,1,0,0),(2494,1,0,0),(2495,1,0,0),(2496,1,0,0),(2497,1,0,0),(2498,1,0,0),(2499,1,0,0),(2500,1,0,0),(2501,1,0,0),(2502,1,0,0),(2503,1,0,0),(2504,1,0,0),(2505,1,0,0),(2506,1,0,0),(2507,1,0,0),(2508,1,0,0),(2509,1,0,0),(2510,1,0,0),(2511,1,0,0),(2512,1,0,0),(2513,1,0,0),(2514,1,0,0),(2515,1,0,0),(2516,1,0,0),(2517,1,0,0),(2518,1,0,0),(2519,1,0,0),(2520,1,0,0),(2521,1,0,0),(2522,1,0,0),(2523,1,0,0),(2524,1,0,0),(2525,1,0,0),(2526,1,0,0),(2527,1,0,0),(2528,1,0,0),(2529,1,0,0),(2530,1,0,0),(2531,1,0,0),(2532,1,0,0),(2533,1,0,0),(2534,1,0,0),(2535,1,0,0),(2536,1,0,0),(2537,1,0,0),(2538,1,0,0),(2539,1,0,0),(2540,1,0,0),(2541,1,0,0),(2542,1,0,0),(2543,1,0,0),(2544,1,0,0),(2545,1,0,0),(2546,1,0,0),(2547,1,0,0),(2548,1,0,0),(2549,1,0,0),(2550,1,0,0),(2551,1,0,0),(2552,1,0,0),(2553,1,0,0),(2554,1,0,0),(2555,1,0,0),(2556,1,0,0),(2557,1,0,0),(2558,1,0,0),(2559,1,0,0),(2560,1,0,0),(2561,1,0,0),(2562,1,0,0),(2563,1,0,0),(2564,1,0,0),(2565,1,0,0),(2566,1,0,0),(2567,1,0,0),(2568,1,0,0),(2569,1,0,0),(2570,1,0,0),(2571,1,0,0),(2572,1,0,0),(2573,1,0,0),(2574,1,0,0),(2575,1,0,0),(2576,1,0,0),(2577,1,0,0),(2578,1,0,0),(2579,1,0,0),(2580,1,0,0),(2581,1,0,0),(2582,1,0,0),(2583,1,0,0),(2584,1,0,0),(2585,1,0,0),(2586,1,0,0),(2587,1,0,0),(2588,1,0,0),(2589,1,0,0),(2590,1,0,0),(2591,1,0,0),(2592,1,0,0),(2593,1,0,0),(2594,1,0,0),(2595,1,0,0),(2596,1,0,0),(2597,1,0,0),(2598,1,0,0),(2599,1,0,0),(2600,1,0,0),(2601,1,0,0),(2602,1,0,0),(2603,1,0,0),(2604,1,0,0),(2605,1,0,0),(2606,1,0,0),(2607,1,0,0),(2608,1,0,0),(2609,1,0,0),(2610,1,0,0),(2611,1,0,0),(2612,1,0,0),(2613,1,0,0),(2614,1,0,0),(2615,1,0,0),(2616,1,0,0),(2617,1,0,0),(2618,1,0,0),(2619,1,0,0),(2620,1,0,0),(2621,1,0,0),(2622,1,0,0),(2623,1,0,0),(2624,1,0,0),(2625,1,0,0),(2626,1,0,0),(2627,1,0,0),(2628,1,0,0),(2629,1,0,0),(2630,1,0,0),(2631,1,0,0),(2632,1,0,0),(2633,1,0,0),(2634,1,0,0),(2635,1,0,0),(2636,1,0,0),(2637,1,0,0),(2638,1,0,0),(2639,1,0,0),(2640,1,0,0),(2641,1,0,0),(2642,1,0,0),(2643,1,0,0),(2644,1,0,0),(2645,1,0,0),(2646,1,0,0),(2647,1,0,0),(2648,1,0,0),(2649,1,0,0),(2650,1,0,0),(2651,1,0,0),(2652,1,0,0),(2653,1,0,0),(2654,1,0,0),(2655,1,0,0),(2656,1,0,0),(2657,1,0,0),(2658,1,0,0),(2659,1,0,0),(2660,1,0,0),(2661,1,0,0),(2662,1,0,0),(2663,1,0,0),(2664,1,0,0),(2665,1,0,0),(2666,1,0,0),(2667,1,0,0),(2668,1,0,0),(2669,1,0,0),(2670,1,0,0),(2671,1,0,0),(2672,1,0,0),(2673,1,0,0),(2674,1,0,0),(2675,1,0,0),(2676,1,0,0),(2677,1,0,0),(2678,1,0,0),(2679,1,0,0),(2680,1,0,0),(2681,1,0,0),(2682,1,0,0),(2683,1,0,0),(2684,1,0,0),(2685,1,0,0),(2686,1,0,0),(2687,1,0,0),(2688,1,0,0),(2689,1,0,0),(2690,1,0,0),(2691,1,0,0),(2692,1,0,0),(2693,1,0,0),(2694,1,0,0),(2695,1,0,0),(2696,1,0,0),(2697,1,0,0),(2698,1,0,0),(2699,1,0,0),(2700,1,0,0),(2701,1,0,0),(2702,1,0,0),(2703,1,0,0),(2704,1,0,0),(2705,1,0,0),(2706,1,0,0),(2707,1,0,0),(2708,1,0,0),(2709,1,0,0),(2710,1,0,0),(2711,1,0,0),(2712,1,0,0),(2713,1,0,0),(2714,1,0,0),(2715,1,0,0),(2716,1,0,0),(2717,1,0,0),(2718,1,0,0),(2719,1,0,0),(2720,1,0,0),(2721,1,0,0),(2722,1,0,0),(2723,1,0,0),(2724,1,0,0),(2725,1,0,0),(2726,1,0,0),(2727,1,0,0),(2728,1,0,0),(2729,1,0,0),(2730,1,0,0),(2731,1,0,0),(2732,1,0,0),(2733,1,0,0),(2734,1,0,0),(2735,1,0,0),(2736,1,0,0),(2737,1,0,0),(2738,1,0,0),(2739,1,0,0),(2740,1,0,0),(2741,1,0,0),(2742,1,0,0),(2743,1,0,0),(2744,1,0,0),(2745,1,0,0),(2746,1,0,0),(2747,1,0,0),(2748,1,0,0),(2749,1,0,0),(2750,1,0,0),(2751,1,0,0),(2752,1,0,0),(2753,1,0,0),(2754,1,0,0),(2755,1,0,0),(2756,1,0,0),(2757,1,0,0),(2758,1,0,0),(2759,1,0,0),(2760,1,0,0),(2761,1,0,0),(2762,1,0,0),(2763,1,0,0),(2764,1,0,0),(2765,1,0,0),(2766,1,0,0),(2767,1,0,0),(2768,1,0,0),(2769,1,0,0),(2770,1,0,0),(2771,1,0,0),(2772,1,0,0),(2773,1,0,0),(2774,1,0,0),(2775,1,0,0),(2776,1,0,0),(2777,1,0,0),(2778,1,0,0),(2779,1,0,0),(2780,1,0,0),(2781,1,0,0),(2782,1,0,0),(2783,1,0,0),(2784,1,0,0),(2785,1,0,0),(2786,1,0,0),(2787,1,0,0),(2788,1,0,0),(2789,1,0,0),(2790,1,0,0),(2791,1,0,0),(2792,1,0,0),(2793,1,0,0),(2794,1,0,0),(2795,1,0,0),(2796,1,0,0),(2797,1,0,0),(2798,1,0,0),(2799,1,0,0),(2800,1,0,0),(2801,1,0,0),(2802,1,0,0),(2803,1,0,0),(2804,1,0,0),(2805,1,0,0),(2806,1,0,0),(2807,1,0,0),(2808,1,0,0),(2809,1,0,0),(2810,1,0,0),(2811,1,0,0),(2812,1,0,0),(2813,1,0,0),(2814,1,0,0),(2815,1,0,0),(2816,1,0,0),(2817,1,0,0),(2818,1,0,0),(2819,1,0,0),(2820,1,0,0),(2821,1,0,0),(2822,1,0,0),(2823,1,0,0),(2824,1,0,0),(2825,1,0,0),(2826,1,0,0),(2827,1,0,0),(2828,1,0,0),(2829,1,0,0),(2830,1,0,0),(2831,1,0,0),(2832,1,0,0),(2833,1,0,0),(2834,1,0,0),(2835,1,0,0),(2836,1,0,0),(2837,1,0,0),(2838,1,0,0),(2839,1,0,0),(2841,1,0,0),(2842,1,0,0),(2843,1,0,0),(2844,1,0,0),(2845,1,0,0),(2846,1,0,0),(2847,1,0,0),(2848,1,0,0),(2849,1,0,0),(2850,1,0,0),(2851,1,0,0),(2852,1,0,0),(2853,1,0,0),(2854,1,0,0),(2855,1,0,0),(2856,1,0,0),(2857,1,0,0),(2858,1,0,0),(2859,1,0,0),(2860,1,0,0),(2861,1,0,0),(2862,1,0,0),(2863,1,0,0),(2864,1,0,0),(2865,1,0,0),(2866,1,0,0),(2867,1,0,0),(2868,1,0,0),(2869,1,0,0),(2870,1,0,0),(2871,1,0,0),(2872,1,0,0),(2873,1,0,0),(2874,1,0,0),(2875,1,0,0),(2876,1,0,0),(2877,1,0,0),(2878,1,0,0),(2879,1,0,0),(2880,1,0,0),(2881,1,0,0),(2882,1,0,0),(2883,1,0,0),(2884,1,0,0),(2885,1,0,0),(2886,1,0,0),(2887,1,0,0),(2888,1,0,0),(2889,1,0,0),(2890,1,0,0),(2891,1,0,0),(2892,1,0,0),(2893,1,0,0),(2894,1,0,0),(2895,1,0,0),(2896,1,0,0),(2897,1,0,0),(2898,1,0,0),(2899,1,0,0),(2900,1,0,0),(2901,1,0,0),(2902,1,0,0),(2903,1,0,0),(2904,1,0,0),(2905,1,0,0),(2906,1,0,0),(2907,1,0,0),(2908,1,0,0),(2909,1,0,0),(2910,1,0,0),(2911,1,0,0),(2912,1,0,0),(2913,1,0,0),(2914,1,0,0),(2915,1,0,0),(2916,1,0,0),(2917,1,0,0),(2918,1,0,0),(2919,1,0,0),(2920,1,0,0),(2921,1,0,0),(2922,1,0,0),(2923,1,0,0),(2924,1,0,0),(2925,1,0,0),(2926,1,0,0),(2927,1,0,0),(2928,1,0,0),(2929,1,0,0),(2930,1,0,0),(2931,1,0,0),(2932,1,0,0),(2933,1,0,0),(2934,1,0,0),(2935,1,0,0),(2936,1,0,0),(2937,1,0,0),(2938,1,0,0),(2939,1,0,0),(2940,1,0,0),(2941,1,0,0),(2942,1,0,0),(2943,1,0,0),(2944,1,0,0),(2945,1,0,0),(2946,1,0,0),(2947,1,0,0),(2948,1,0,0),(2949,1,0,0),(2950,1,0,0),(2951,1,0,0),(2952,1,0,0),(2953,1,0,0),(2954,1,0,0),(2955,1,0,0),(2956,1,0,0),(2957,1,0,0),(2958,1,0,0),(2959,1,0,0),(2960,1,0,0),(2961,1,0,0),(2962,1,0,0),(2963,1,0,0),(2964,1,0,0),(2965,1,0,0),(2966,1,0,0),(2967,1,0,0),(2968,1,0,0),(2969,1,0,0),(2970,1,0,0),(2971,1,0,0),(2972,1,0,0),(2973,1,0,0),(2974,1,0,0),(2975,1,0,0),(2976,1,0,0),(2977,1,0,0),(2978,1,0,0),(2979,1,0,0),(2980,1,0,0),(2981,1,0,0),(2982,1,0,0),(2983,1,0,0),(2984,1,0,0),(2985,1,0,0),(2986,1,0,0),(2987,1,0,0),(2988,1,0,0),(2989,1,0,0),(2990,1,0,0),(2991,1,0,0),(2992,1,0,0),(2993,1,0,0),(2994,1,0,0),(2995,1,0,0),(2996,1,0,0),(2997,1,0,0),(2998,1,0,0),(2999,1,0,0),(3000,1,0,0),(3001,1,0,0),(3002,1,0,0),(3003,1,0,0),(3004,1,0,0),(3005,1,0,0),(3006,1,0,0),(3007,1,0,0),(3008,1,0,0),(3009,1,0,0),(3010,1,0,0),(3011,1,0,0),(3012,1,0,0),(3013,1,0,0),(3014,1,0,0),(3015,1,0,0),(3016,1,0,0),(3017,1,0,0),(3018,1,0,0),(3019,1,0,0),(3020,1,0,0),(3021,1,0,0),(3022,1,0,0),(3023,1,0,0),(3024,1,0,0),(3025,1,0,0),(3026,1,0,0),(3027,1,0,0),(3028,1,0,0),(3029,1,0,0),(3030,1,0,0),(3031,1,0,0),(3032,1,0,0),(3033,1,0,0),(3034,1,0,0),(3035,1,0,0),(3036,1,0,0),(3037,1,0,0),(3038,1,0,0),(3039,1,0,0),(3040,1,0,0),(3041,1,0,0),(3042,1,0,0),(3043,1,0,0),(3044,1,0,0),(3045,1,0,0),(3046,1,0,0),(3047,1,0,0),(3048,1,0,0),(3049,1,0,0),(3050,1,0,0),(3051,1,0,0),(3052,1,0,0),(3053,1,0,0),(3054,1,0,0),(3055,1,0,0),(3056,1,0,0),(3057,1,0,0),(3058,1,0,0),(3059,1,0,0),(3060,1,0,0),(3061,1,0,0),(3062,1,0,0),(3063,1,0,0),(3064,1,0,0),(3065,1,0,0),(3066,1,0,0),(3067,1,0,0),(3068,1,0,0),(3069,1,0,0),(3070,1,0,0),(3071,1,0,0),(3072,1,0,0),(3073,1,0,0),(3074,1,0,0),(3075,1,0,0),(3076,1,0,0),(3077,1,0,0),(3078,1,0,0),(3079,1,0,0),(3080,1,0,0),(3081,1,0,0),(3082,1,0,0),(3083,1,0,0),(3084,1,0,0),(3085,1,0,0),(3086,1,0,0),(3087,1,0,0),(3088,1,0,0),(3089,1,0,0),(3090,1,0,0),(3091,1,0,0),(3092,1,0,0),(3093,1,0,0),(3094,1,0,0),(3095,1,0,0),(3096,1,0,0),(3097,1,0,0),(3098,1,0,0),(3099,1,0,0),(3100,1,0,0),(3101,1,0,0),(3102,1,0,0),(3103,1,0,0),(3104,1,0,0),(3105,1,0,0),(3106,1,0,0),(3107,1,0,0),(3108,1,0,0),(3109,1,0,0),(3110,1,0,0),(3111,1,0,0),(3112,1,0,0),(3113,1,0,0),(3114,1,0,0),(3115,1,0,0),(3116,1,0,0),(3117,1,0,0),(3118,1,0,0),(3119,1,0,0),(3120,1,0,0),(3121,1,0,0),(3122,1,0,0),(3123,1,0,0),(3124,1,0,0),(3125,1,0,0),(3126,1,0,0),(3127,1,0,0),(3128,1,0,0),(3129,1,0,0),(3130,1,0,0),(3131,1,0,0),(3132,1,0,0),(3133,1,0,0),(3134,1,0,0),(3135,1,0,0),(3136,1,0,0),(3137,1,0,0),(3138,1,0,0),(3139,1,0,0),(3140,1,0,0),(3141,1,0,0),(3142,1,0,0),(3143,1,0,0),(3144,1,0,0),(3145,1,0,0),(3146,1,0,0),(3147,1,0,0),(3148,1,0,0),(3149,1,0,0),(3150,1,0,0),(3151,1,0,0),(3152,1,0,0),(3153,1,0,0),(3154,1,0,0),(3155,1,0,0),(3156,1,0,0),(3157,1,0,0),(3158,1,0,0),(3159,1,0,0),(3160,1,0,0),(3161,1,0,0),(3162,1,0,0),(3163,1,0,0),(3164,1,0,0),(3165,1,0,0),(3166,1,0,0),(3167,1,0,0),(3168,1,0,0),(3169,1,0,0),(3170,1,0,0),(3171,1,0,0),(3172,1,0,0),(3173,1,0,0),(3174,1,0,0),(3175,1,0,0),(3176,1,0,0),(3177,1,0,0),(3178,1,0,0),(3179,1,0,0),(3180,1,0,0),(3181,1,0,0),(3182,1,0,0),(3183,1,0,0),(3184,1,0,0),(3185,1,0,0),(3186,1,0,0),(3187,1,0,0),(3188,1,0,0),(3189,1,0,0),(3190,1,0,0),(3191,1,0,0),(3192,1,0,0),(3193,1,0,0),(3194,1,0,0),(3195,1,0,0),(3196,1,0,0),(3197,1,0,0),(3198,1,0,0),(3199,1,0,0),(3200,1,0,0),(3201,1,0,0),(3202,1,0,0),(3203,1,0,0),(3204,1,0,0),(3205,1,0,0),(3206,1,0,0),(3207,1,0,0),(3208,1,0,0),(3209,1,0,0),(3210,1,0,0),(3211,1,0,0),(3212,1,0,0),(3213,1,0,0),(3214,1,0,0),(3215,1,0,0),(3216,1,0,0),(3217,1,0,0),(3218,1,0,0),(3219,1,0,0),(3220,1,0,0),(3221,1,0,0),(3222,1,0,0),(3223,1,0,0),(3224,1,0,0),(3225,1,0,0),(3226,1,0,0),(3227,1,0,0),(3228,1,0,0),(3229,1,0,0),(3230,1,0,0),(3231,1,0,0),(3232,1,0,0),(3233,1,0,0),(3234,1,0,0),(3235,1,0,0),(3236,1,0,0),(3237,1,0,0),(3238,1,0,0),(3239,1,0,0),(3240,1,0,0),(3241,1,0,0),(3242,1,0,0),(3243,1,0,0),(3244,1,0,0),(3245,1,0,0),(3246,1,0,0),(3247,1,0,0),(3248,1,0,0),(3249,1,0,0),(3250,1,0,0),(3251,1,0,0),(3252,1,0,0),(3253,1,0,0),(3254,1,0,0),(3255,1,0,0),(3256,1,0,0),(3257,1,0,0),(3258,1,0,0),(3259,1,0,0),(3260,1,0,0),(3261,1,0,0),(3262,1,0,0),(3263,1,0,0),(3264,1,0,0),(3265,1,0,0),(3266,1,0,0),(3267,1,0,0),(3268,1,0,0),(3269,1,0,0),(3270,1,0,0),(3271,1,0,0),(3272,1,0,0),(3273,1,0,0),(3274,1,0,0),(3275,1,0,0),(3276,1,0,0),(3277,1,0,0),(3278,1,0,0),(3279,1,0,0),(3280,1,0,0),(3281,1,0,0),(3282,1,0,0),(3283,1,0,0),(3284,1,0,0),(3285,1,0,0),(3286,1,0,0),(3287,1,0,0),(3288,1,0,0),(3289,1,0,0),(3290,1,0,0),(3291,1,0,0),(3292,1,0,0),(3293,1,0,0),(3294,1,0,0),(3295,1,0,0),(3296,1,0,0),(3297,1,0,0),(3298,1,0,0),(3299,1,0,0),(3300,1,0,0),(3301,1,0,0),(3302,1,0,0),(3303,1,0,0),(3304,1,0,0),(3305,1,0,0),(3306,1,0,0),(3307,1,0,0),(3308,1,0,0),(3309,1,0,0),(3310,1,0,0),(3311,1,0,0),(3312,1,0,0),(3313,1,0,0),(3314,1,0,0),(3315,1,0,0),(3316,1,0,0),(3317,1,0,0),(3318,1,0,0),(3319,1,0,0),(3320,1,0,0),(3321,1,0,0),(3322,1,0,0),(3323,1,0,0),(3324,1,0,0),(3325,1,0,0),(3326,1,0,0),(3327,1,0,0),(3328,1,0,0),(3329,1,0,0),(3330,1,0,0),(3331,1,0,0),(3332,1,0,0),(3333,1,0,0),(3334,1,0,0),(3335,1,0,0),(3336,1,0,0),(3337,1,0,0),(3338,1,0,0),(3339,1,0,0),(3340,1,0,0),(3341,1,0,0),(3342,1,0,0),(3343,1,0,0),(3344,1,0,0),(3345,1,0,0),(3346,1,0,0),(3347,1,0,0),(3348,1,0,0),(3349,1,0,0),(3350,1,0,0),(3351,1,0,0),(3352,1,0,0),(3353,1,0,0),(3354,1,0,0),(3355,1,0,0),(3356,1,0,0),(3357,1,0,0),(3358,1,0,0),(3359,1,0,0),(3360,1,0,0),(3361,1,0,0),(3362,1,0,0),(3363,1,0,0),(3364,1,0,0),(3365,1,0,0),(3366,1,0,0),(3367,1,0,0),(3368,1,0,0),(3369,1,0,0),(3370,1,0,0),(3371,1,0,0),(3372,1,0,0),(3373,1,0,0),(3374,1,0,0),(3375,1,0,0),(3376,1,0,0),(3377,1,0,0),(3378,1,0,0),(3379,1,0,0),(3380,1,0,0),(3381,1,0,0),(3382,1,0,0),(3383,1,0,0),(3384,1,0,0),(3385,1,0,0),(3386,1,0,0),(3387,1,0,0),(3388,1,0,0),(3389,1,0,0),(3390,1,0,0),(3391,1,0,0),(3392,1,0,0),(3393,1,0,0),(3394,1,0,0),(3395,1,0,0),(3396,1,0,0),(3397,1,0,0),(3398,1,0,0),(3399,1,0,0),(3400,1,0,0),(3401,1,0,0),(3402,1,0,0),(3403,1,0,0),(3404,1,0,0),(3405,1,0,0),(3406,1,0,0),(3407,1,0,0),(3408,1,0,0),(3409,1,0,0),(3410,1,0,0),(3411,1,0,0),(3412,1,0,0),(3413,1,0,0),(3414,1,0,0),(3415,1,0,0),(3416,1,0,0),(3417,1,0,0),(3418,1,0,0),(3419,1,0,0),(3420,1,0,0),(3421,1,0,0),(3422,1,0,0),(3423,1,0,0),(3424,1,0,0),(3425,1,0,0),(3426,1,0,0),(3427,1,0,0),(3428,1,0,0),(3429,1,0,0),(3430,1,0,0),(3431,1,0,0),(3432,1,0,0),(3433,1,0,0),(3434,1,0,0),(3435,1,0,0),(3436,1,0,0),(3437,1,0,0),(3438,1,0,0),(3439,1,0,0),(3440,1,0,0),(3441,1,0,0),(3442,1,0,0),(3443,1,0,0),(3444,1,0,0),(3445,1,0,0),(3446,1,0,0),(3447,1,0,0),(3448,1,0,0),(3449,1,0,0),(3450,1,0,0),(3451,1,0,0),(3452,1,0,0),(3453,1,0,0),(3454,1,0,0),(3455,1,0,0),(3456,1,0,0),(3457,1,0,0),(3458,1,0,0),(3459,1,0,0),(3460,1,0,0),(3461,1,0,0),(3462,1,0,0),(3463,1,0,0),(3464,1,0,0),(3465,1,0,0),(3466,1,0,0),(3467,1,0,0),(3468,1,0,0),(3469,1,0,0),(3470,1,0,0),(3471,1,0,0),(3472,1,0,0),(3473,1,0,0),(3474,1,0,0),(3475,1,0,0),(3476,1,0,0),(3477,1,0,0),(3478,1,0,0),(3479,1,0,0),(3480,1,0,0),(3481,1,0,0),(3482,1,0,0),(3483,1,0,0),(3484,1,0,0),(3485,1,0,0),(3486,1,0,0),(3487,1,0,0),(3488,1,0,0),(3489,1,0,0),(3490,1,0,0),(3491,1,0,0),(3492,1,0,0),(3493,1,0,0),(3494,1,0,0),(3495,1,0,0),(3496,1,0,0),(3497,1,0,0),(3498,1,0,0),(3499,1,0,0),(3500,1,0,0),(3501,1,0,0),(3502,1,0,0),(3503,1,0,0),(3504,1,0,0),(3505,1,0,0),(3506,1,0,0),(3507,1,0,0),(3508,1,0,0),(3509,1,0,0),(3510,1,0,0),(3511,1,0,0),(3512,1,0,0),(3513,1,0,0),(3514,1,0,0),(3515,1,0,0),(3516,1,0,0),(3517,1,0,0),(3518,1,0,0),(3519,1,0,0),(3520,1,0,0),(3521,1,0,0),(3522,1,0,0),(3523,1,0,0),(3524,1,0,0),(3525,1,0,0),(3526,1,0,0),(3527,1,0,0),(3528,1,0,0),(3529,1,0,0),(3530,1,0,0),(3531,1,0,0),(3532,1,0,0),(3533,1,0,0),(3534,1,0,0),(3535,1,0,0),(3536,1,0,0),(3537,1,0,0),(3538,1,0,0),(3539,1,0,0),(3540,1,0,0),(3541,1,0,0),(3542,1,0,0),(3543,1,0,0),(3544,1,0,0),(3545,1,0,0),(3546,1,0,0),(3547,1,0,0),(3548,1,0,0),(3549,1,0,0),(3550,1,0,0),(3551,1,0,0),(3552,1,0,0),(3553,1,0,0),(3554,1,0,0),(3555,1,0,0),(3556,1,0,0),(3557,1,0,0),(3558,1,0,0),(3559,1,0,0),(3560,1,0,0),(3561,1,0,0),(3562,1,0,0),(3563,1,0,0),(3564,1,0,0),(3565,1,0,0),(3566,1,0,0),(3567,1,0,0),(3568,1,0,0),(3569,1,0,0),(3570,1,0,0),(3571,1,0,0),(3572,1,0,0),(3573,1,0,0),(3574,1,0,0),(3575,1,0,0),(3576,1,0,0),(3577,1,0,0),(3578,1,0,0),(3579,1,0,0),(3580,1,0,0),(3581,1,0,0),(3582,1,0,0),(3583,1,0,0),(3584,1,0,0),(3585,1,0,0),(3586,1,0,0),(3587,1,0,0),(3588,1,0,0),(3589,1,0,0),(3590,1,0,0),(3591,1,0,0),(3592,1,0,0),(3593,1,0,0),(3594,1,0,0),(3595,1,0,0),(3596,1,0,0),(3597,1,0,0),(3598,1,0,0),(3599,1,0,0),(3600,1,0,0),(3601,1,0,0),(3602,1,0,0),(3603,1,0,0),(3604,1,0,0),(3605,1,0,0),(3606,1,0,0),(3607,1,0,0),(3608,1,0,0),(3609,1,0,0),(3610,1,0,0),(3611,1,0,0),(3612,1,0,0),(3613,1,0,0),(3614,1,0,0),(3615,1,0,0),(3616,1,0,0),(3617,1,0,0),(3618,1,0,0),(3619,1,0,0),(3620,1,0,0),(3621,1,0,0),(3622,1,0,0),(3623,1,0,0),(3624,1,0,0),(3625,1,0,0),(3626,1,0,0),(3627,1,0,0),(3628,1,0,0),(3629,1,0,0),(3630,1,0,0),(3631,1,0,0),(3632,1,0,0),(3633,1,0,0),(3634,1,0,0),(3635,1,0,0),(3636,1,0,0),(3637,1,0,0),(3638,1,0,0),(3639,1,0,0),(3640,1,0,0),(3641,1,0,0),(3642,1,0,0),(3643,1,0,0),(3644,1,0,0),(3645,1,0,0),(3646,1,0,0),(3647,1,0,0),(3648,1,0,0),(3649,1,0,0),(3650,1,0,0),(3651,1,0,0),(3652,1,0,0),(3653,1,0,0),(3654,1,0,0),(3655,1,0,0),(3656,1,0,0),(3657,1,0,0),(3658,1,0,0),(3659,1,0,0),(3660,1,0,0),(3661,1,0,0),(3662,1,0,0),(3663,1,0,0),(3664,1,0,0),(3665,1,0,0),(3666,1,0,0),(3667,1,0,0),(3668,1,0,0),(3669,1,0,0),(3670,1,0,0),(3671,1,0,0),(3672,1,0,0),(3673,1,0,0),(3674,1,0,0),(3675,1,0,0),(3676,1,0,0),(3677,1,0,0),(3678,1,0,0),(3679,1,0,0),(3680,1,0,0),(3681,1,0,0),(3682,1,0,0),(3683,1,0,0),(3684,1,0,0),(3685,1,0,0),(3686,1,0,0),(3687,1,0,0),(3688,1,0,0),(3689,1,0,0),(3690,1,0,0),(3691,1,0,0),(3692,1,0,0),(3693,1,0,0),(3694,1,0,0),(3695,1,0,0),(3696,1,0,0),(3697,1,0,0),(3698,1,0,0),(3699,1,0,0),(3700,1,0,0),(3701,1,0,0),(3702,1,0,0),(3703,1,0,0),(3704,1,0,0),(3705,1,0,0),(3706,1,0,0),(3707,1,0,0),(3708,1,0,0),(3709,1,0,0),(3710,1,0,0),(3711,1,0,0),(3712,1,0,0),(3713,1,0,0),(3714,1,0,0),(3715,1,0,0),(3716,1,0,0),(3717,1,0,0),(3718,1,0,0),(3719,1,0,0),(3720,1,0,0),(3721,1,0,0),(3722,1,0,0),(3723,1,0,0),(3724,1,0,0),(3725,1,0,0),(3726,1,0,0),(3727,1,0,0),(3728,1,0,0),(3729,1,0,0),(3730,1,0,0),(3731,1,0,0),(3732,1,0,0),(3733,1,0,0),(3734,1,0,0),(3735,1,0,0),(3736,1,0,0),(3737,1,0,0),(3738,1,0,0),(3739,1,0,0),(3740,1,0,0),(3741,1,0,0),(3742,1,0,0),(3743,1,0,0),(3744,1,0,0),(3745,1,0,0),(3746,1,0,0),(3747,1,0,0),(3748,1,0,0),(3749,1,0,0),(3750,1,0,0),(3751,1,0,0),(3752,1,0,0),(3753,1,0,0),(3754,1,0,0),(3755,1,0,0),(3756,1,0,0),(3757,1,0,0),(3758,1,0,0),(3759,1,0,0),(3760,1,0,0),(3761,1,0,0),(3762,1,0,0),(3763,1,0,0),(3764,1,0,0),(3765,1,0,0),(3766,1,0,0),(3767,1,0,0),(3768,1,0,0),(3769,1,0,0),(3770,1,0,0),(3771,1,0,0),(3772,1,0,0),(3773,1,0,0),(3774,1,0,0),(3775,1,0,0),(3776,1,0,0),(3777,1,0,0),(3778,1,0,0),(3779,1,0,0),(3780,1,0,0),(3781,1,0,0),(3782,1,0,0),(3783,1,0,0),(3784,1,0,0),(3785,1,0,0),(3786,1,0,0),(3787,1,0,0),(3788,1,0,0),(3789,1,0,0),(3790,1,0,0),(3791,1,0,0),(3792,1,0,0),(3793,1,0,0),(3794,1,0,0),(3795,1,0,0),(3796,1,0,0),(3797,1,0,0),(3798,1,0,0),(3799,1,0,0),(3800,1,0,0),(3801,1,0,0),(3802,1,0,0),(3803,1,0,0),(3804,1,0,0),(3805,1,0,0),(3806,1,0,0),(3807,1,0,0),(3808,1,0,0),(3809,1,0,0),(3810,1,0,0),(3811,1,0,0),(3812,1,0,0),(3813,1,0,0),(3814,1,0,0),(3815,1,0,0),(3816,1,0,0),(3817,1,0,0),(3818,1,0,0),(3819,1,0,0),(3820,1,0,0),(3821,1,0,0),(3822,1,0,0),(3823,1,0,0),(3824,1,0,0),(3825,1,0,0),(3826,1,0,0),(3827,1,0,0),(3828,1,0,0),(3829,1,0,0),(3830,1,0,0),(3831,1,0,0),(3832,1,0,0),(3833,1,0,0),(3834,1,0,0),(3835,1,0,0),(3836,1,0,0),(3837,1,0,0),(3838,1,0,0),(3839,1,0,0),(3840,1,0,0),(3841,1,0,0),(3842,1,0,0),(3843,1,0,0),(3844,1,0,0),(3845,1,0,0),(3846,1,0,0),(3847,1,0,0),(3848,1,0,0),(3849,1,0,0),(3850,1,0,0),(3851,1,0,0),(3852,1,0,0),(3853,1,0,0),(3854,1,0,0),(3855,1,0,0),(3856,1,0,0),(3857,1,0,0),(3858,1,0,0),(3859,1,0,0),(3860,1,0,0),(3861,1,0,0),(3862,1,0,0),(3863,1,0,0),(3864,1,0,0),(3865,1,0,0),(3866,1,0,0),(3867,1,0,0),(3868,1,0,0),(3869,1,0,0),(3870,1,0,0),(3871,1,0,0),(3872,1,0,0),(3873,1,0,0),(3874,1,0,0),(3875,1,0,0),(3876,1,0,0),(3877,1,0,0),(3878,1,0,0),(3879,1,0,0),(3880,1,0,0),(3881,1,0,0),(3882,1,0,0),(3883,1,0,0),(3884,1,0,0),(3885,1,0,0),(3886,1,0,0),(3887,1,0,0),(3888,1,0,0),(3889,1,0,0),(3890,1,0,0),(3891,1,0,0),(3892,1,0,0),(3893,1,0,0),(3894,1,0,0),(3895,1,0,0),(3896,1,0,0),(3897,1,0,0),(3898,1,0,0),(3899,1,0,0),(3900,1,0,0),(3901,1,0,0),(3902,1,0,0),(3903,1,0,0),(3904,1,0,0),(3905,1,0,0),(3906,1,0,0),(3907,1,0,0),(3908,1,0,0),(3909,1,0,0),(3910,1,0,0),(3911,1,0,0),(3912,1,0,0),(3913,1,0,0),(3914,1,0,0),(3915,1,0,0),(3916,1,0,0),(3917,1,0,0),(3918,1,0,0),(3919,1,0,0),(3920,1,0,0),(3921,1,0,0),(3922,1,0,0),(3923,1,0,0),(3924,1,0,0),(3925,1,0,0),(3926,1,0,0),(3927,1,0,0),(3928,1,0,0),(3929,1,0,0),(3930,1,0,0),(3931,1,0,0),(3932,1,0,0),(3933,1,0,0),(3934,1,0,0),(3935,1,0,0),(3936,1,0,0),(3937,1,0,0),(3938,1,0,0),(3939,1,0,0),(3940,1,0,0),(3941,1,0,0),(3942,1,0,0),(3943,1,0,0),(3944,1,0,0),(3945,1,0,0),(3946,1,0,0),(3947,1,0,0),(3948,1,0,0),(3949,1,0,0),(3950,1,0,0),(3951,1,0,0),(3952,1,0,0),(3953,1,0,0),(3954,1,0,0),(3955,1,0,0),(3956,1,0,0),(3957,1,0,0),(3958,1,0,0),(3959,1,0,0),(3960,1,0,0),(3961,1,0,0),(3962,1,0,0),(3963,1,0,0),(3964,1,0,0),(3965,1,0,0),(3966,1,0,0),(3967,1,0,0),(3968,1,0,0),(3969,1,0,0),(3970,1,0,0),(3971,1,0,0),(3972,1,0,0),(3973,1,0,0),(3974,1,0,0),(3975,1,0,0),(3976,1,0,0),(3977,1,0,0),(3978,1,0,0),(3979,1,0,0),(3980,1,0,0),(3981,1,0,0),(3982,1,0,0),(3983,1,0,0),(3984,1,0,0),(3985,1,0,0),(3986,1,0,0),(3987,1,0,0),(3988,1,0,0),(3989,1,0,0),(3990,1,0,0),(3991,1,0,0),(3992,1,0,0),(3993,1,0,0),(3994,1,0,0),(3995,1,0,0),(3996,1,0,0),(3997,1,0,0),(3998,1,0,0),(3999,1,0,0),(4000,1,0,0),(4001,1,0,0),(4002,1,0,0),(4003,1,0,0),(4004,1,0,0),(4005,1,0,0),(4006,1,0,0),(4007,1,0,0),(4008,1,0,0),(4009,1,0,0),(4010,1,0,0),(4011,1,0,0),(4012,1,0,0),(4013,1,0,0),(4014,1,0,0),(4015,1,0,0),(4016,1,0,0),(4017,1,0,0),(4018,1,0,0),(4019,1,0,0),(4020,1,0,0),(4021,1,0,0),(4022,1,0,0),(4023,1,0,0),(4024,1,0,0),(4025,1,0,0),(4026,1,0,0),(4027,1,0,0),(4028,1,0,0),(4029,1,0,0),(4030,1,0,0),(4031,1,0,0),(4032,1,0,0),(4033,1,0,0),(4034,1,0,0),(4035,1,0,0),(4036,1,0,0),(4037,1,0,0),(4038,1,0,0),(4039,1,0,0),(4040,1,0,0),(4041,1,0,0),(4042,1,0,0),(4043,1,0,0),(4044,1,0,0),(4045,1,0,0),(4046,1,0,0),(4047,1,0,0),(4048,1,0,0),(4049,1,0,0),(4050,1,0,0),(4051,1,0,0),(4052,1,0,0),(4053,1,0,0),(4054,1,0,0),(4055,1,0,0),(4056,1,0,0),(4057,1,0,0),(4058,1,0,0),(4059,1,0,0),(4060,1,0,0),(4061,1,0,0),(4062,1,0,0),(4063,1,0,0),(4064,1,0,0),(4065,1,0,0),(4066,1,0,0),(4067,1,0,0),(4068,1,0,0),(4069,1,0,0),(4070,1,0,0),(4071,1,0,0),(4072,1,0,0),(4073,1,0,0),(4074,1,0,0),(4075,1,0,0),(4076,1,0,0),(4077,1,0,0),(4078,1,0,0),(4079,1,0,0),(4080,1,0,0),(4081,1,0,0),(4082,1,0,0),(4083,1,0,0),(4084,1,0,0),(4085,1,0,0),(4086,1,0,0),(4087,1,0,0),(4088,1,0,0),(4089,1,0,0),(4090,1,0,0),(4091,1,0,0),(4092,1,0,0),(4093,1,0,0),(4094,1,0,0),(4095,1,0,0),(4096,1,0,0),(4097,1,0,0),(4098,1,0,0),(4099,1,0,0),(4100,1,0,0),(4101,1,0,0),(4102,1,0,0),(4103,1,0,0),(4104,1,0,0),(4105,1,0,0),(4106,1,0,0),(4107,1,0,0),(4108,1,0,0),(4109,1,0,0),(4110,1,0,0),(4111,1,0,0),(4112,1,0,0),(4113,1,0,0),(4114,1,0,0),(4115,1,0,0),(4116,1,0,0),(4117,1,0,0),(4118,1,0,0),(4119,1,0,0),(4120,1,0,0),(4121,1,0,0),(4122,1,0,0),(4123,1,0,0),(4124,1,0,0),(4125,1,0,0),(4126,1,0,0),(4127,1,0,0),(4128,1,0,0),(4129,1,0,0),(4130,1,0,0),(4131,1,0,0),(4132,1,0,0),(4133,1,0,0),(4134,1,0,0),(4135,1,0,0),(4136,1,0,0),(4137,1,0,0),(4138,1,0,0),(4139,1,0,0),(4140,1,0,0),(4141,1,0,0),(4142,1,0,0),(4143,1,0,0),(4144,1,0,0),(4145,1,0,0),(4146,1,0,0),(4147,1,0,0),(4148,1,0,0),(4149,1,0,0),(4150,1,0,0),(4151,1,0,0),(4152,1,0,0),(4153,1,0,0),(4154,1,0,0),(4155,1,0,0),(4156,1,0,0),(4157,1,0,0),(4158,1,0,0),(4159,1,0,0),(4160,1,0,0),(4161,1,0,0),(4162,1,0,0),(4163,1,0,0),(5513,45,0,0),(5516,1,0,0),(6532,1,0,0),(6533,1,0,0),(6534,1,0,0),(6535,1,0,0),(6536,1,0,0),(6537,1,0,0),(6538,1,0,0),(6539,1,0,0),(6540,1,0,0),(6541,1,0,0),(6542,1,0,0),(6544,1,0,0),(6545,1,0,0),(6546,1,0,0),(6547,1,0,0),(6548,1,0,0),(6549,1,0,0),(6550,1,0,0),(6551,1,0,0),(6552,1,0,0),(6755,1,0,0),(6756,1,0,0),(6757,1,0,0),(6758,1,0,0),(6759,1,0,0),(6760,1,0,0),(6761,1,0,0),(6762,1,0,0),(6763,1,0,0),(6764,1,0,0),(6765,1,0,0),(6766,1,0,0),(6767,1,0,0),(6768,1,0,0),(6769,1,0,0),(6770,1,0,0),(6771,1,0,0),(6772,1,0,0),(6773,1,0,0),(6774,1,0,0),(6775,1,0,0),(6776,1,0,0),(6777,1,0,0),(6778,1,0,0),(6786,1,0,0),(6787,1,0,0),(6788,1,0,0),(6789,1,0,0),(6790,1,0,0),(6791,1,0,0),(6792,1,0,0),(6793,1,0,0),(6794,1,0,0),(6795,1,0,0),(6796,1,0,0),(6797,1,0,0),(6798,1,0,0),(6799,1,0,0),(6800,1,0,0),(6801,1,0,0),(6802,1,0,0),(6803,1,0,0),(6804,1,0,0),(6805,1,0,0),(6806,1,0,0),(6807,1,0,0),(6808,1,0,0),(6809,1,0,0),(6810,1,0,0),(6811,1,0,0),(6812,1,0,0),(6813,1,0,0),(6814,1,0,0),(6815,1,0,0),(6816,1,0,0),(6817,1,0,0),(6818,1,0,0),(6819,1,0,0),(6820,1,0,0),(6821,1,0,0),(6822,1,0,0),(6823,1,0,0),(6824,1,0,0),(6825,1,0,0),(6826,1,0,0),(6827,1,0,0),(6828,1,0,0),(6829,1,0,0),(6830,1,0,0),(6831,1,0,0),(6832,1,0,0),(6833,1,0,0),(6834,1,0,0),(6835,1,0,0),(6836,1,0,0),(6837,1,0,0),(6838,1,0,0),(6839,1,0,0),(6840,1,0,0),(6841,1,0,0),(6842,1,0,0),(6843,1,0,0),(6844,1,0,0),(6845,1,0,0),(6846,1,0,0),(6847,1,0,0),(6848,1,0,0),(6849,1,0,0),(6850,1,0,0),(6851,1,0,0),(6852,1,0,0),(6853,1,0,0),(6854,1,0,0),(6855,1,0,0),(6856,1,0,0),(6857,1,0,0),(6858,1,0,0),(6859,1,0,0),(6860,1,0,0),(6861,1,0,0),(6862,1,0,0),(6863,1,0,0),(6864,1,0,0),(6865,1,0,0),(6866,1,0,0),(6867,1,0,0),(6868,1,0,0),(6869,1,0,0),(6870,1,0,0),(6871,1,0,0),(6872,1,0,0),(6873,1,0,0),(6874,1,0,0),(6875,1,0,0),(6876,1,0,0),(6877,1,0,0),(6878,1,0,0),(6879,1,0,0),(6880,1,0,0),(6881,1,0,0),(6882,1,0,0),(6883,1,0,0),(6884,1,0,0),(6885,1,0,0),(6886,1,0,0),(6887,1,0,0),(6888,1,0,0),(6889,1,0,0),(6890,1,0,0),(6891,1,0,0),(6892,1,0,0),(6893,1,0,0),(6894,1,0,0),(6895,1,0,0),(6896,1,0,0),(6897,1,0,0),(6898,1,0,0),(6899,1,0,0),(6900,1,0,0),(6901,1,0,0),(6902,1,0,0),(6903,1,0,0),(6904,1,0,0),(6905,1,0,0),(6906,1,0,0),(6907,1,0,0),(6908,1,0,0),(6909,1,0,0),(6910,1,0,0),(6911,1,0,0),(6912,1,0,0),(6913,1,0,0),(6914,1,0,0),(6915,1,0,0),(6916,1,0,0),(6917,1,0,0),(6918,1,0,0),(6919,1,0,0),(6920,1,0,0),(6921,1,0,0),(6922,1,0,0),(6923,1,0,0),(6924,1,0,0),(6925,1,0,0),(6926,1,0,0),(6927,1,0,0),(6928,1,0,0),(6929,1,0,0),(6930,1,0,0),(6931,1,0,0),(6932,1,0,0),(6933,1,0,0),(6934,1,0,0),(6935,1,0,0),(6936,1,0,0),(6937,1,0,0),(6938,1,0,0),(6939,1,0,0),(6940,1,0,0),(6941,1,0,0),(6942,1,0,0),(6943,1,0,0),(6944,1,0,0),(6945,1,0,0),(6946,1,0,0),(6947,1,0,0),(6948,1,0,0),(6949,1,0,0),(6950,1,0,0),(6951,1,0,0),(6952,1,0,0),(6953,1,0,0),(6954,1,0,0),(6955,1,0,0),(6956,1,0,0),(6957,1,0,0),(6958,1,0,0),(6959,1,0,0),(6960,1,0,0),(6961,1,0,0),(6962,1,0,0),(6963,1,0,0),(6964,1,0,0),(6965,1,0,0),(6966,1,0,0),(6967,1,0,0),(6968,1,0,0),(6969,1,0,0),(6970,1,0,0),(6971,1,0,0),(6972,1,0,0),(6973,1,0,0),(6974,1,0,0),(6975,1,0,0),(6976,1,0,0),(6977,1,0,0),(6978,1,0,0),(6979,1,0,0),(6980,1,0,0),(6981,1,0,0),(6982,1,0,0),(6983,1,0,0),(6984,1,0,0),(6985,1,0,0),(6986,1,0,0),(6987,1,0,0),(6988,1,0,0),(6989,1,0,0),(6990,1,0,0),(6991,1,0,0),(6992,1,0,0),(6993,1,0,0),(6994,1,0,0),(6995,1,0,0),(6996,1,0,0),(6997,1,0,0),(6998,1,0,0),(6999,1,0,0),(7000,1,0,0),(7001,1,0,0),(7002,1,0,0),(7003,1,0,0),(7004,1,0,0),(7005,1,0,0),(7006,1,0,0),(7007,1,0,0),(7008,1,0,0),(7009,1,0,0),(7010,1,0,0),(7011,1,0,0),(7012,1,0,0),(7013,1,0,0),(7014,1,0,0),(7015,1,0,0),(7016,1,0,0),(7017,1,0,0),(7018,1,0,0),(7019,1,0,0),(7020,1,0,0),(7021,1,0,0),(7022,1,0,0),(7023,1,0,0),(7024,1,0,0),(7025,1,0,0),(7026,1,0,0),(7027,1,0,0),(7028,1,0,0),(7029,1,0,0),(7030,1,0,0),(7031,1,0,0),(7032,1,0,0),(7033,1,0,0),(7034,1,0,0),(7035,1,0,0),(7036,1,0,0),(7037,1,0,0),(7038,1,0,0),(7039,1,0,0),(7040,1,0,0),(7041,1,0,0),(7042,1,0,0),(7043,1,0,0),(7044,1,0,0),(7045,1,0,0),(7046,1,0,0),(7047,1,0,0),(7048,1,0,0),(7049,1,0,0),(7050,1,0,0),(7051,1,0,0),(7052,1,0,0),(7053,1,0,0),(7054,1,0,0),(7055,1,0,0),(7056,1,0,0),(7057,1,0,0),(7058,1,0,0),(7059,1,0,0),(7060,1,0,0),(7061,1,0,0),(7062,1,0,0),(7063,1,0,0),(7064,1,0,0),(7065,1,0,0),(7066,1,0,0),(7067,1,0,0),(7068,1,0,0),(7069,1,0,0),(7070,1,0,0),(7071,1,0,0),(7072,1,0,0),(7073,1,0,0),(7074,1,0,0),(7075,1,0,0),(7076,1,0,0),(7077,1,0,0),(7078,1,0,0),(7079,1,0,0),(7080,1,0,0),(7081,1,0,0),(7082,1,0,0),(7083,1,0,0),(7084,1,0,0),(7085,1,0,0),(7086,1,0,0),(7087,1,0,0),(7088,1,0,0),(7089,1,0,0),(7090,1,0,0),(7091,1,0,0),(7092,1,0,0),(7093,1,0,0),(7094,1,0,0),(7095,1,0,0),(7096,1,0,0),(7097,1,0,0),(7098,1,0,0),(7099,1,0,0),(7100,1,0,0),(7101,1,0,0),(7102,1,0,0),(7103,1,0,0),(7104,1,0,0),(7105,1,0,0),(7106,1,0,0),(7107,1,0,0),(7108,1,0,0),(7109,1,0,0),(7110,1,0,0),(7111,1,0,0),(7112,1,0,0),(7113,1,0,0),(7114,1,0,0),(7115,1,0,0),(7116,1,0,0),(7117,1,0,0),(7118,1,0,0),(7119,1,0,0),(7120,1,0,0),(7121,1,0,0),(7122,1,0,0),(7123,1,0,0),(7124,1,0,0);
/*!40000 ALTER TABLE `FlashCardUsers` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `FlashUsers`
--

DROP TABLE IF EXISTS `FlashUsers`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `FlashUsers` (
  `user_id` int NOT NULL AUTO_INCREMENT,
  `username` varchar(30) DEFAULT NULL,
  `password` varchar(60) DEFAULT NULL,
  `email` varchar(30) DEFAULT NULL,
  `userrank` varchar(30) NOT NULL,
  `points` int NOT NULL,
  PRIMARY KEY (`user_id`)
) ENGINE=InnoDB AUTO_INCREMENT=68 DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `FlashUsers`
--

LOCK TABLES `FlashUsers` WRITE;
/*!40000 ALTER TABLE `FlashUsers` DISABLE KEYS */;
INSERT INTO `FlashUsers` VALUES (1,'maxbisesi','$2a$10$TMZz0gvRJf9/yecPEdGfAOHjnEfZMWBZ4EgeSUb8yPoY5RSXyaRiW','max.bisesi@gmail.com','FreeDiver',0),(44,'dfesta','Basketball12','dannyfest@yelp.com','Recruit',0),(45,'haliemun','Starbucks12','hmun@starbucks.com','Recruit',0),(46,'roryOd','Kelsey12','roryOd@buildzoom.com','Recruit',0),(48,'kyree3','ILoveBen','kyree3@starbucks.com','Recruit',0),(64,'UncleJoe22','$2a$10$l78pvWCP9FO51.w1pecYsepYgRGbVcovGaFD3XUmm3vAiNIDWMkUa','joe.B@oracle.com','Recruit',0),(65,'dmenzie','$2a$10$aTydAnkqLOnhc4U1AE1.zu5XW8h8RCmje22EW.rCwyT7tV64.oo4i','dmenzie@republicservices.com','Recruit',0),(66,'codythurmond','$2a$10$V1uYoGZnz.XNZ2chjVVGLOdGvdr2lm0iI7Ee1NBnirG0zE2t3/qR6','c.thurmond@gmail.com','Recruit',0),(67,'tester','$2a$10$bN3J0pyYkY2Sp4E4nNiVLObq317KCGVcAH7rqnVqm12P5mnGQRKSm','tester@gmail.com','Recruit',0);
/*!40000 ALTER TABLE `FlashUsers` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `Notes`
--

DROP TABLE IF EXISTS `Notes`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `Notes` (
  `note_id` int NOT NULL AUTO_INCREMENT,
  `note` varchar(500) NOT NULL,
  `user_id` int DEFAULT NULL,
  `card_id` int DEFAULT NULL,
  PRIMARY KEY (`note_id`),
  KEY `fk_note_user` (`user_id`),
  KEY `fk_note_card` (`card_id`),
  CONSTRAINT `fk_note_card` FOREIGN KEY (`card_id`) REFERENCES `FlashCards` (`card_id`) ON DELETE SET NULL,
  CONSTRAINT `fk_note_user` FOREIGN KEY (`user_id`) REFERENCES `FlashUsers` (`user_id`) ON DELETE SET NULL
) ENGINE=InnoDB DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `Notes`
--

LOCK TABLES `Notes` WRITE;
/*!40000 ALTER TABLE `Notes` DISABLE KEYS */;
/*!40000 ALTER TABLE `Notes` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `UserSessions`
--

DROP TABLE IF EXISTS `UserSessions`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `UserSessions` (
  `session_id` int NOT NULL AUTO_INCREMENT,
  `correct` int NOT NULL,
  `incorrect` int NOT NULL,
  `cards_added` int NOT NULL,
  `points_added` int NOT NULL,
  `card_sets_added` int NOT NULL,
  `date` datetime DEFAULT CURRENT_TIMESTAMP,
  `user_id` int NOT NULL,
  PRIMARY KEY (`session_id`),
  KEY `user_id` (`user_id`),
  CONSTRAINT `UserSessions_ibfk_1` FOREIGN KEY (`user_id`) REFERENCES `FlashUsers` (`user_id`) ON DELETE CASCADE
) ENGINE=InnoDB AUTO_INCREMENT=259 DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `UserSessions`
--

LOCK TABLES `UserSessions` WRITE;
/*!40000 ALTER TABLE `UserSessions` DISABLE KEYS */;
INSERT INTO `UserSessions` VALUES (229,0,0,0,0,0,'2020-05-25 10:40:02',64),(230,0,0,0,0,0,'2020-05-25 10:43:25',65);
/*!40000 ALTER TABLE `UserSessions` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `Weapons`
--

DROP TABLE IF EXISTS `Weapons`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `Weapons` (
  `weapon_id` int NOT NULL AUTO_INCREMENT,
  `name` varchar(30) NOT NULL,
  `damage` int NOT NULL,
  `defense` int NOT NULL,
  PRIMARY KEY (`weapon_id`)
) ENGINE=InnoDB AUTO_INCREMENT=21 DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `Weapons`
--

LOCK TABLES `Weapons` WRITE;
/*!40000 ALTER TABLE `Weapons` DISABLE KEYS */;
INSERT INTO `Weapons` VALUES (1,'',0,0),(2,'Hand Cannon',0,0),(3,'Hand Cannon',0,0),(4,'Hand Cannon',0,0),(5,'Saber',0,0),(6,'Saber',0,0),(7,'Hand Cannon',0,0),(8,'',0,0),(9,'',0,0),(10,'',0,0),(11,'',0,0),(12,'',0,0),(13,'',0,0),(14,'Hand Cannon',0,0),(15,'',0,0),(16,'',0,0),(17,'',0,0),(18,'',0,0),(19,'',0,0),(20,'',0,0);
/*!40000 ALTER TABLE `Weapons` ENABLE KEYS */;
UNLOCK TABLES;
/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;

-- Dump completed on 2020-07-19  1:54:52
