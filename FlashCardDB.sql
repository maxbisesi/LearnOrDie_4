-- MySQL dump 10.13  Distrib 5.7.26, for Linux (x86_64)
--
-- Host: localhost    Database: FCSRemoteCopy
-- ------------------------------------------------------
-- Server version	5.7.26-0ubuntu0.16.04.1

/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!40101 SET NAMES utf8 */;
/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
/*!40103 SET TIME_ZONE='+00:00' */;
/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;

--
-- Table structure for table `cardset`
--

DROP TABLE IF EXISTS `cardset`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `cardset` (
  `setid` mediumint(9) NOT NULL AUTO_INCREMENT,
  `set_name` varchar(20) DEFAULT NULL,
  `fk_user_id` int(11) DEFAULT NULL,
  `status` varchar(10) DEFAULT NULL,
  `description` varchar(100) DEFAULT NULL,
  PRIMARY KEY (`setid`),
  KEY `fk_cardset_user_id` (`fk_user_id`),
  CONSTRAINT `fk_cardset_user_id` FOREIGN KEY (`fk_user_id`) REFERENCES `flashuser` (`user_id`)
) ENGINE=InnoDB AUTO_INCREMENT=113 DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `cardset`
--

LOCK TABLES `cardset` WRITE;
/*!40000 ALTER TABLE `cardset` DISABLE KEYS */;
INSERT INTO `cardset` VALUES (111,'test',5,'Deleted','test'),(112,'Exceptions',5,NULL,'jdfd');
/*!40000 ALTER TABLE `cardset` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `cardsetcard`
--

DROP TABLE IF EXISTS `cardsetcard`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `cardsetcard` (
  `setid` mediumint(9) NOT NULL,
  `cardid` int(11) NOT NULL,
  PRIMARY KEY (`setid`,`cardid`),
  KEY `cardid` (`cardid`),
  CONSTRAINT `cardsetcard_ibfk_3` FOREIGN KEY (`setid`) REFERENCES `cardset` (`setid`) ON DELETE CASCADE,
  CONSTRAINT `cardsetcard_ibfk_4` FOREIGN KEY (`cardid`) REFERENCES `flashcard` (`cardid`) ON DELETE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `cardsetcard`
--

LOCK TABLES `cardsetcard` WRITE;
/*!40000 ALTER TABLE `cardsetcard` DISABLE KEYS */;
INSERT INTO `cardsetcard` VALUES (111,26),(112,26),(111,27),(112,27),(111,28),(112,28),(111,29),(112,29),(111,30),(112,30),(111,32),(112,32),(111,33),(112,33),(111,34),(112,34),(111,35),(112,35),(111,36),(112,36),(111,37),(112,37),(111,38),(112,38),(111,39),(112,39),(111,40),(112,40),(111,41),(112,41),(111,42),(112,42),(111,43),(112,43),(111,44),(112,44),(111,45),(112,45),(111,46),(112,46),(111,47),(111,48),(111,49),(111,50),(111,51),(111,52),(111,53),(111,54),(111,55),(111,56),(111,57),(111,58),(111,59),(111,60),(111,61),(111,62),(111,63),(111,64),(111,65);
/*!40000 ALTER TABLE `cardsetcard` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `deletedcards`
--

DROP TABLE IF EXISTS `deletedcards`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `deletedcards` (
  `cardid` int(11) NOT NULL AUTO_INCREMENT,
  `answer` varchar(3000) DEFAULT NULL,
  `card` varchar(3000) DEFAULT NULL,
  `category` varchar(255) DEFAULT NULL,
  `times_wrong` int(11) DEFAULT NULL,
  `times_right` int(11) DEFAULT NULL,
  `owner_id` int(11) DEFAULT NULL,
  `fk_user_id` int(11) DEFAULT NULL,
  PRIMARY KEY (`cardid`),
  KEY `fk_user` (`fk_user_id`)
) ENGINE=InnoDB AUTO_INCREMENT=91 DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `deletedcards`
--

LOCK TABLES `deletedcards` WRITE;
/*!40000 ALTER TABLE `deletedcards` DISABLE KEYS */;
INSERT INTO `deletedcards` VALUES (31,'the following are equivalent:\n\ncatch(SQLException | IOException e)\n\ncatch(IOException | SQLException e)','With Multi catch order does NOT matter...		','Exceptions',1,4,NULL,5),(66,'io','readers dont have flush methods','IO',0,12,NULL,5),(67,'a char[]','Console.readPassword() returns...','IO',0,12,NULL,5),(68,'Returns the path element corresponding to the specified index.\n\nthe 0th element is the one closest to the root.','Path Method:\n\nPath getName(int index)','IO',0,12,NULL,5),(69,'returns the filename or the last element of the sequence of name elements\n\nor..\n\nReturns the name of the file or directory denoted by this path as a Path object. The file name is the farthest element from the root in the directory hierarchy.','Path Method:\n\nString getFileName()','IO',0,12,NULL,5),(70,'4','public class Hello {\n    public static void main(String[] dicks) throws IOException{\n      Path src = Paths.get(\"/home/maxbisesi/Documents/copy.txt\");\n\n      System.out.println(src.getNameCount());\n      \n    }\n\n}','IO',0,11,NULL,5),(71,'\n/home/maxbisesi/Documents','\npublic class Hello {\n    public static void main(String[] dicks) throws IOException{\n      Path src = Paths.get(\"/home/maxbisesi/Documents/copy.txt\");\n      Path srcParent = src.getParent();\n      System.out.println(srcParent);\n      \n    }\n\n}','IO',0,11,NULL,5),(72,'retunrs the root of thsi path, or null if this path does not have a root.','Path Method:\n\nPath getRoot()		','IO',0,10,NULL,5),(73,'returns a ssubsequence of this path NOT INCLUDING ROOT. \n\nbeginning INCLUSIVE\n\nending EXCLUSIVE','Path Method:\n\nPath subpath(int beginindex, int endIndex)','IO',0,9,NULL,5),(74,'that means it can be iterated through in a for loop!','Path extends from Iterable<Path>	','IO',0,9,NULL,5),(75,'tmp/dir1/dir2/dir3/file.txt','int spaces = 1;\nPath myPath = Paths.get(\"tmp\", \"dir1\", \"dir2\", \"dir3\", \"file.txt\");\n\nfor(Path subpath : myPath){\n	sout( subpath + \"//\" );\n}','IO',0,9,NULL,5),(76,'returns a path that is this path with redundant name elements eliminated\n\n. can be ignored\n\n.. followed by a directory can be removed as redundant','Path method:\n\nPath normalize()	','IO',0,8,NULL,5),(77,'/a/b/c','Paths.get(\"/a/./b/./c\").normalize();\n','IO',0,8,NULL,5),(78,'.classpath','Paths.get(\".classpath\").normalize();','IO',0,8,NULL,5),(79,'/a/b','Paths.get(\"/a/b/c/..\").normalize()','IO',0,8,NULL,5),(80,'../a/b/c\n\nThe two dots do say go up one directory, but since there is\'nt a directory\nbefore it Path cant simplify it.','Paths.get(\"../a/b/c\").normalize()','IO',0,8,NULL,5),(81,'/home/java/models/Model.pdf\n\npath1.resolve(path2) should be read as \"resolve path2 within path1s directory\n','Path dir = Paths.get(\"/home/java\");\nPath file = Paths.get(\"models/Model.pdf\");\nPath result = dir.resolve(file);\n\nsout( result );\n	','IO',0,8,NULL,5),(82,'/google\n\nResolve the given path against this path.\n\nIf the other parameter is an absolute path then this method trivially returns other.\n If other is an empty path then this method trivially returns this path.\n Otherwise this method considers this path to be a directory and resolves\n the given path against this path. In the simplest case, the given path does not have a root component, \nin which case this method joins the given path to this path \nand returns a resulting path that ends with the given path.','class Hello {\n    public static void main(String[] args) {     \n        Path p1 = Paths.get(\"/home/max/tmp\");\n        Path p2 = Paths.get(\"/google\");\n        System.out.println(p1.resolve(p2));\n        \n    }\n\n}','IO',0,8,NULL,5),(83,'/home/java/dir\n/home/java/Model.pdf\n/dir/Model.pdf\n/home/java\n/home/java\nModel.pdf/dir\n\nThe first three do what you would exprect. They add the paramenter\nto resolve to the provided path object. The fourth and fifth try to resolve\nan absolute path within the context of something else. The problem is \nthat an aboluste path doesnt\'t depend on other directories it is absolute.\n','Path absolute = Paths.get(\"/home/java\");\nPath relative = Paths.get(\"dir\");\nPath file = Paths.get(\"Model.pdf\");\n\nsout( absolute.resolve(relative) );\nsout( asolute.resolve(file) );\nsout( relative.resolve(file) );\nsout( relative.resolve(absolute) ); // BAD\nsout( file.resolve(absolute) ); //BAD\nsout( file.resolve(relative) ); //BAD','IO',0,8,NULL,5),(84,'Thhe compilere cannot decide here so it will not compile','Be carefule with questions that come in two flavors. one with a Path parameter\nand the other with a String parameter such as resolve()...\n\nPath path = Paths.get(\"/usr/bin/zip\");\npath.resolve(null);','IO',0,8,NULL,5),(85,'resolve()','Which Path method is used to combine two paths and set one in another?','IO',0,8,NULL,5),(86,'relativize()','Which Path method is used to describe how to gret from one path to \nthe other	','IO',0,3,NULL,5),(87,'country/Swift.mp3\n\n\njava recognized that the /home/java part is the same and returned a path of\njust the remainder.\n\npath1.relativize(path2) should be read as \"give me a path shows how to get from\npath1 to path2\"','Path dir = Paths.get(\"/home/java\");\nPath music = Paths.get(\"/home/java/country/Swift.mp3\");\nPath mp3 = dir.reltivize(music);\n\nsout( mp3 );','IO',0,3,NULL,5),(88,'.relativize()','\"give me a path shows how to get from\npath1 to path2\"','IO',0,3,NULL,5),(89,'temp/music.mp3\n\n../..\n\n../../usr/local\n\nmusic.pdf\n\nExcpetion in main thread IllegalArgumentExcpetion\n\n	','Path absolute1 = Paths.get(\"/home/java\");\nPath absolute2 = Paths.get(\"/usr/local\");\nPath absolute3 = Paths.get(\"/home/java/temp/music.mp3\");\nPath relative1 = Paths.get(\"temp\");\nPath relative2 = Paths.get(\"temp/music.pdf\");\n\nsout( absolute1.relativize(absolute3) );\nsout( absolute3.relativize(absolute1) );\nsout( absolute1.relativize(absolute2) );\nsout( relative1.relativize(relative2) );\nsout( absolute1.relativize(relative1) ); //BAD','IO',1,3,NULL,5),(90,'Path relativize(Path other)\n\nConstructs a relative path between this path and a given path.\n\nRelativization is the inverse of resolution. This method attempts to construct a relative path that when resolved against this path, yields a path that locates the same file as the given path. For example, on UNIX, if this path is \"/a/b\" and the given path is \"/a/b/c/d\" then the resulting relative path would be \"c/d\". Where this path and the given path do not have a root component, then a relative path can be constructed. A relative path cannot be constructed if only one of the paths have a root component. Where both paths have a root component then it is implementation dependent if a relative path can be constructed. If this path and the given path are equal then an empty path is returned.\n\nFor any two normalized paths p and q, where q does not have a root component,\n\n    p.relativize(p.resolve(q)).equals(q) \n\nWhen symbolic links are supported, then whether the resulting path, when resolved against this path, yields a path that can be used to locate the same file as other is implementation dependent. For example, if this path is \"/a/b\" and the given path is \"/a/x\" then the resulting relative path may be \"../x\". If \"b\" is a symbolic link then is implementation dependent if \"a/b/../x\" would locate the same file as \"/a/x\".\n\nParameters:\n    other - the path to relativize against this path\nReturns:\n    the resulting relative path, or an empty path if both paths are equal\nThrows:\n    IllegalArgumentException - if other is not a Path that can be relativized against this path','relativeize()','IO',1,3,NULL,5);
/*!40000 ALTER TABLE `deletedcards` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `flashcard`
--

DROP TABLE IF EXISTS `flashcard`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `flashcard` (
  `cardid` int(11) NOT NULL AUTO_INCREMENT,
  `answer` varchar(3000) DEFAULT NULL,
  `card` varchar(3000) DEFAULT NULL,
  `category` varchar(255) DEFAULT NULL,
  `times_wrong` int(11) DEFAULT NULL,
  `times_right` int(11) DEFAULT NULL,
  `owner_id` int(11) DEFAULT NULL,
  `fk_user_id` int(11) DEFAULT NULL,
  PRIMARY KEY (`cardid`),
  KEY `fk_user` (`fk_user_id`),
  CONSTRAINT `flashcard_ibfk_1` FOREIGN KEY (`fk_user_id`) REFERENCES `flashuser` (`user_id`)
) ENGINE=InnoDB AUTO_INCREMENT=4608 DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `flashcard`
--

LOCK TABLES `flashcard` WRITE;
/*!40000 ALTER TABLE `flashcard` DISABLE KEYS */;
INSERT INTO `flashcard` VALUES (26,'try{\n\n}catch(Exception1 | Exception2 e) {\n\n	e = new Exception1();\n}\n\nTHIS WOULD FAIL COMPILATION\n\n','When using multi-catch, the catch block parameter is final and cannot \nhave a new value assigned to it in the catch block.\n\ntry{\n\n} catch(SQLException | IOException e){\n	\n	e = new IOException();\n}\n\n// this shows why thats illegal, your not sure which exception type \nwill come through.\n//updated 2','Exceptions',0,7,NULL,5),(27,'javac -source 1.3 OldCode.java\n\njavac -source 1.4 NewCode.java','To compile old code that may use \'assert\' as an identifier, \nadd 1.3. This will tell the compiler to treat the word \'assert\' as an identifier.\n\n1.4 will use \'assert\' as a keyword	','Exceptions',0,8,NULL,5),(28,'java -da com.maxbisesi.Test\n\njava -disableassertions com.maxbisesi.Test','Disable assertions at runtime		','Exceptions',0,9,NULL,5),(29,'This is a bad idea...\n\npublic void doStuff(){\n	assert (modifyThings());\n	//continue\n}\n','Dont use assert expressions that can cause side effects...','Exceptions',0,6,NULL,5),(30,'javac -source 1.3 OldCode.java\n\njavac -source 1.4 NewCode.java\n\nUPDATE!','To compile old code that may use \'assert\' as an identifier, \nadd 1.3. This will tell the compiler to treat the word \'assert\' as an identifier.\n\n1.4 will use \'assert\' as a keyword	','Exceptions',0,2,NULL,5),(32,'The following will not compile...\n\ncatch(FileNotFoundException | IOException e)\n\nsince FILENOTFOUND is a subclass of IOException we could have just\nwrtten that in the first place..\n\ncatch(IOException)','With Multi-Catch you have to make sure a given excpetion can only\nmatch one type...\n\ncatch(IOException | SQLException e)\n\nthese two are different types.','Exceptions',0,3,NULL,5),(33,'This is legal but it is not good practice. It is illegal to reasign the value\nof a multi-catch parameter. \n\ntry {\n	\n} catch(SQLException | IOException e){\n\n	e = new IOException();\n}\n\n^^WILL NOT COMPILE\n','Legal or illegal...\n\ntry {\n	//do something\n} catch(IOException e){\n	\n	e = new IOException();\n}','Exceptions',0,5,NULL,5),(34,'Will not compile, it is legal to reassign the parameter here. But it is illegal\nto throw e. The method declares that it throws SQL and IO so throwing a \ngeneral exception is unreported. \n\nif the signature was throws Exception then everything would be fine\n\nException as a genreal','public void couldthrow() throws SQLException, IOException { }\n\npublic void rethrow() throws SQLException, IOException {\n	try{\n		couldthrow();\n	} catch(Exception e){ \n		e = new IOException();\n		throw e;\n	}\n}	','Exceptions',1,4,NULL,5),(35,'Illegal, regular trys have to have a catch or a finally\n\ntry-with can be used by themselves','legal or illegal\n\ntry {\n\n}','Exceptions',1,4,NULL,5),(36,'does not compile. \nto be declared in a try with the method has to implement auto closeable or\ncloseable','try(String s = \"hi\") {}','Exceptions',1,4,NULL,5),(37,'will not compile,\nThe declared resources use a commma , not a semi colon ;\n\nshould be:\n\ntry(Resource r = new Resource(); ...','Path p = Paths.get(\"/home/maxbisesi\");\n      try(BufferedReader br = new BufferedReader(new FileReader(p.toFile())), BufferedWriter bw = new BufferedWriter(new FileWriter(p.toFile()))){\n          \n      } catch(IOException e){\n          \n      }','Exceptions',2,3,NULL,5),(38,'ok, AutoCloseable interface allows throwing any Exception','Class A implements AutoCloseable { \n	public void close() throws Exception {}\n}	','Exceptions',1,4,NULL,5),(39,'ok sublcasses or implenting methods can throw a subclass of excpetion\nor none at all.\n\nAutoCloseable\'s  close throws an Exception','class B implements AutoCloseable { public void close() {}}\nclass C implements AutoCloseable { public void close() throws IOException {}}','Exceptions',1,3,NULL,5),(40,'ILLEGAL- Closeable only allows IOExceptions or subclasses','class D implements Closeable { public void close() throws Exception{}}','Exceptions',1,3,NULL,5),(41,'ok Closeable allows throwing IOExceptions\n\nvoid close() throws IOException','class E implements Closeable { public void close() throws IOException {}}','Collections',1,4,NULL,5),(42,'you can call close() multiple times all day and nothing will happen the second time and beyond. \nwill not blow up. ','idempotent','Exceptions',1,4,NULL,5),(43,'nothing bad will happen if you call close() more than one time. ','AutoCloseable\'s close() is idempotent	','Exceptions',1,4,NULL,5),(44,'might blow up if called more than once','Closeable\'s close() is not idempotent','Exceptions',1,4,NULL,5),(45,'B\nA\ncatch\n\nResources are closed in reverse order from what they are declared.','class A implements AutoCloseable {\n	public void close() {\n		sout(\"A\");\n	}\n}\n\nclass B implements AutoCloseable {\n	public void close() {\n		sout(\"B\");\n	}\n}\n\nclass C {\n	psvm(sa){\n		try(A a = new A(); B b = new B()){\n			throw new RuntimeException();\n		} catch(EXception e) {\n			sout(\"catch\");\n		}\n	}\n}\n\nwhat does it print?','Exceptions',1,4,NULL,5),(46,'Try\nsuppressed: java.io.IOException: Closing\n\nafter the exception in the try block gets thrown on line 4, the try with \nresources still calls close() and the catch block catches one \nof the exceptions.\n\nJava adds any excpeittions thrown by close() methods to a suppressed array in the main excpetion. \n\nif no other exception happens in the try block the exceptioon thrown in\nclose() gets treated as the main excpetion  for the catch block. ','public class Suppressed {\n	psvm(sa) {\n		try(One one = new One()) {\n			throw new exception(\"try\");\n		} catch (Exception e) {\n			sout(e.getMessage());\n			\n			for(Throwable t : e.getSuppressed()){\n				sout(\"suppressed:\" + t);\n		}	}\n	}\n}\n\nclass One implements AutoCloseable {\n	public void close() throws IOException {\n		throw new IOException(\"Closing\");\n	}\n}','Exceptions',1,6,NULL,5),(47,'got it ','If the catch or Finally block throws an exception NO SUPPRESSION HAPPENS\nthe last exception thrown gets sent to the caller rather than the one from the \ntry- just like before try with resources','Exceptions',1,6,NULL,5),(48,'Closing - 2\nsuppressed: java.io.IOException: Closing - 1\n\nresources close in the opposite order they are declared\ndd','class Bad implements AutoCloseable {\n	String name;\n	Bad(String n) { name = n; }\n	public void close() throws IOException {\n		throw new IOException(\"Closing -\" +name);\n	}\n}\n\npublic class Suppressed {\n	public static void main(SA) {\n		try(Bad b1 = new Bad(\"1\"); Bad b2 = new Bad(\"2\")) {\n			\n		} catch(Exception e) {\n			sout(e.getMessage());\n			for(Throwable t : e.getSuppressed()) {\n				sout(\"suppressed:\" + t);\n			}\n		}\n	}\n}','Exceptions',0,1,NULL,5),(49,'Since all file IO on the exam is related to characters, if you see a Stream\nlike DataOutputStream the the question is probably about serialization\nor something unrelated to the actual IO objective','Stream classes are used to read and write bytes, and Readers and Writers\nare used to read write Characters....','IO',1,6,NULL,5),(50,'// first time\nfalse\ntrue \ntrue\n\n//second time\ntrue\nfalse\ntrue\n\nexists returns false the first time becasue the file was created as an object\nbut not yet as a physical file. ','psvm(SA) {\n	try {\n		boolean newFile = false;\n		File file = new File(\"fiileWrite1.txt\");\n		sout(file.exists());\n		newFile = file.createNewFile());\n		sout(newFile);\n		sout(file.exists());\n	} catch (IOException e) {}\n}	','IO',1,5,NULL,5),(51,'This method returns true if it can find the actual file\n\nfalse\n','public static void main(String[] args){\n        File newFile = new File(\"/home/maxbisesi/Public/textFile5.txt\");\n        try{\n            System.out.println(newFile.exists());\n            newFile.createNewFile();\n            System.out.println(newFile.exists());\n        } catch(IOException e){\n            \n        }   \n    }','IO',0,0,NULL,5),(52,'true if the named file does not exist and was successfully created; false if the named file already exists\n','File method: \ntry {\n	createNewFile();\n} catch(IOException e) { } ','IO',1,5,NULL,5),(53,'File(File parent, String child)\nCreates a new File instance from a parent abstract pathname and a child pathname string.\n\nFile(String pathname)\nCreates a new File instance by converting the given pathname string into an abstract pathname.\n\nFile(String parent, String child)\nCreates a new File instance from a parent pathname string and a child pathname string.','File class Constructors	','IO',1,5,NULL,5),(54,'createNewFile()\ndelete()\nexists()\nisDirectory()\nisfile()\nlist()\nmkdir()\nrenameTo()','File class key methods ','IO',1,4,NULL,5),(55,'FileWriter(File file)\n\nFileWriter(String filename)','FileWriter class Constructors	','IO',2,3,NULL,5),(56,'close()\nflush()\nwrite()','FileWriter class key methods 	','IO',2,3,NULL,5),(57,'BufferedWriter(Writer out)','BufferedWriter class constructors	','IO',2,3,NULL,5),(58,'close() \nflush()\nnewLine()\nwrite()','BufferedWriter key methods	','IO',2,3,NULL,5),(59,'PrintWriter(File file)\nCreates a new PrintWriter, without automatic line flushing, with the specified file.\n\nPrintWriter(File file, String csn)\nCreates a new PrintWriter, without automatic line flushing, with the specified file and charset.\n\nPrintWriter(OutputStream out)\nCreates a new PrintWriter, without automatic line flushing, from an existing OutputStream.\n\nPrintWriter(OutputStream out, boolean autoFlush)\nCreates a new PrintWriter from an existing OutputStream.\n\nPrintWriter(String fileName)\nCreates a new PrintWriter, without automatic line flushing, with the specified file name.\n\nPrintWriter(String fileName, String csn)\nCreates a new PrintWriter, without automatic line flushing, with the specified file name and charset.\n\nPrintWriter(Writer out)\nCreates a new PrintWriter, without automatic line flushing.\n\nPrintWriter(Writer out, boolean autoFlush)\nCreates a new PrintWriter.','PrintWriter constructors','IO',2,3,NULL,5),(60,'read()','FileReader key methods 	','IO',2,3,NULL,5),(61,'Reader','BufferedReader constructors	','IO',2,3,NULL,5),(62,'read()\nreadLine()','BufferedReader key methods','IO',2,3,NULL,5),(63,'filewrite2.txt would contain the text:\n\nhello\nworld','File file = new file(\"filewriter2.txt\");\nFileWriter fw = new fileWriter(file);\n\nPrintWriter pw = new PrintWriter (fw);\n\npw.println(\"hello\");\npw.println(\"world\"));','IO',2,3,NULL,5),(64,'','File file = new File(\"filewrite2.txt\");\nFileReader fr = new FileReader(file);\nBufferedReader br = new BufferedReader(fr);\n\nString data = br.readLine();','IO',2,3,NULL,5),(65,'got it ','File file = new File(\"foo\");\n\nif \"foo\" does not exist no actual file is created.\n\nif \"foo\" does exists, the new File object refers to the existing file. ','IO',2,3,NULL,5),(91,'If this program is run from the root, it is the one in /tmp/file1.txt\n\nif it is run from /tmp it is the one in /tmp/tmp/file1.txt\n\nif the program is run from anywhere else the path refers to a file that doesn\nnot exist. ','When creating a Path you can seperate out folder and filename as much\nor as little as you want. When you don\'t begin with a root the Path\nis considered a relative path, which means Java looks from the current\ndirectory.\n\nPath p6 = Paths.get(\"tmp\", \"file1.txt\"); // relative path\n\n/ (root)\n	| - - tmp\n		| - file1.txt\n		| - tmp\n			| - file1.txt\n','IO',2,3,NULL,5),(92,'got it ','With IO a file doesn\'t exists just because you create a File object.\nIt is the same with Path objects\n\nPath path = Paths.get(\"fileWrite1.txt\");\nsout(Files.exists(path)); // false\nFiles.createFile(path); \nsout(Files.exists(path)); // true','IO',2,3,NULL,5),(93,'Path path1 = Paths.get(\"/java/source\");\nPath path2 = Paths.get(\"/java/source/directory\");\nPath file = Paths.get(\"/java/source/directory/Program.java\");\nFiles.createDirectory(path1);\nFiles.createDirectory(path2);\nFiles.createFile(file);\n\n// all at once\n\nFiles.createDirectories(path2);\nFile.createFile(file);','create directories one at a time or all at once	......\n\nTHE directory must exist by the time the file is created','IO',2,3,NULL,5),(94,'13570164000000','Date januaryFirst = new GregorianCalendar(20q3, Calendar.January, 1).getTime();\n\nFile file = new File(\"c:/temp/file\");\nfile.createNewFile();\nfile.setLastModified(januaryFirst.getTime());\nfile.setLastModified(januaryFirst.getTime());\nsout(file.lastModified());\nfile.delete();','IO',2,3,NULL,5),(95,'2013-01-01T05','Path path = Paths.get(\"c:/temp/file2\");\nDate januaryFirst = new GregorianCalendar(2013,Calendar.JANUARY, 1).getTime();\nFiles.createFile(path);\nFileTime fileTime = FileTime.fromMillis(januaryFirst.getTime());\nFiles.setLastModifiedTime(path,fileTime);\nsout(Files.getLastModifiedTime(path));\nFiles.delete((path);','IO',2,3,NULL,5),(96,'\nfile.lastModified();\n\nFiles.getLastModifiedTime(path);','How would you get the last modified date/time of a Path and a File?\n\nFile file = new file(\"test\");\nPath path = Paths.get(\"test\");','IO',2,3,NULL,5),(97,'','public class Hello {\n    static Thread max ,angela;\n    public static void main(String[] args){\n        angela = new Thread() {\n            public void run(){\n                System.out.println(\"A\");\n                try {\n                    max.sleep(1000);\n                } catch(Exception e){\n                    System.out.println(\"B\");\n                }\n                System.out.println(\"C\");\n                \n            }\n        };\n        \n        max = new Thread() {\n            public void run(){\n                System.out.println(\"D\");\n                try {\n                    angela.wait(); \n                } catch(Exception e){\n                    System.out.println(\"E\");\n                }\n                \n                System.out.println(\"F\");\n            }\n        };\n        \n        max.start();\n        angela.start();   \n    }\n} ','IO',0,0,NULL,5),(98,'file.canRead();\n\nFiles.isReadable(path);','How would you get theread permision set of a Path and a File?\n\nFile file = new file(\"test\");\nPath path = Paths.get(\"test\");','IO',1,4,NULL,5),(99,'file.canWrite();\nfile.canExecute();\n\nFiles.isWritable(path);\nFiles.isExecutable(path);','How would you get write and or execute permision set of a Path and a File?\n\nFile file = new file(\"test\");\nPath path = Paths.get(\"test\");','IO',1,4,NULL,5),(100,'file.setLastModifed(timeinMillis);\n\nFileTime ft = FileTime.fromMillis(timeInMillis);\nFiles.setLastModifiedTime(path,ft);','How do you set the last modified time of a path and file?\n\nFile file = new file(\"test\");\nPath path = Paths.get(\"test\");','IO',1,4,NULL,5),(101,'file.canWrite();\nfile.canExecute();\n\nFiles.isWritable(path);\nFiles.isExecutable(path);\n\nUPDATEEE!','How would you get write and or execute permision set of a Path and a File?\n\nFile file = new file(\"test\");\nPath path = Paths.get(\"test\");','IO',0,0,NULL,5),(102,'A C D E F \n\nin an undeterminable order, although thread angela uses the max reference\n.Sleep is static and therefore she puts herself to sleep. This is why\nreferences shouldn\'t be used for static methods. \n\nmax trys to synchronize on angela but he does not own the lock so he therefore\ncannot and throws an IllegalMonitorStateException. \n\n... \n\noh yea update','public class Hello {\n    static Thread max ,angela;\n    public static void main(String[] args){\n        angela = new Thread() {\n            public void run(){\n                System.out.println(\"A\");\n                try {\n                    max.sleep(1000);\n                } catch(Exception e){\n                    System.out.println(\"B\");\n                }\n                System.out.println(\"C\");\n                \n            }\n        };\n        \n        max = new Thread() {\n            public void run(){\n                System.out.println(\"D\");\n                try {\n                    angela.wait(); \n                } catch(Exception e){\n                    System.out.println(\"E\");\n                }\n                \n                System.out.println(\"F\");\n            }\n        };\n        \n        max.start();\n        angela.start();   \n    }\n} ','IO',0,0,NULL,5),(103,'PosixFileAttributes pox = Files.readAttributes(path, PosixFileAttributes.class);\n\nupdate','How would you construct a PosixFileAttribute object?	','IO',0,0,NULL,5),(104,'Path path = Paths.get(\"/tmp/file2\");\nFiles.createFile(path);\nPosixFileAttributes ps = Files.readAttributes(path, PosixFileAttributes.class);\n\nSet<PosixFilePermission> perms = PosixFilePermission.fromString(\"rw-r--r--\");\n\nFiles.setPosixFilePermissions(path,perms);\n\nsout( ps.permissions() );\n\nTHe output would be:\n\n[OWNER_WRITE, GROUP_READ, OTHERS_READ, OWNER_READ ]','How would you set a Unix File\'s permissions in Java?	','IO',1,3,NULL,5),(105,'BasicFileAttributes basic = Files.readAttributes(path1, BasicFileAttribute.class );\n\nFileTime at = basic.lastAccessTime();\nFileTime update = basic.lastModifiedTime();\nFileTime now = FileTime.fromMillis(System.currentTimeMiilis() );\n\nPath file = Paths.get(\"/temp/file.txt\");\nFiles.createFile(file);\n\nBasicFileAttributeView view = Files.getBasicFileAttributeView(file, BasicFileAttributeView.class);\n\nview.setTimes(update, at, now);','How to take modified times from one file\nand write new BasicFileAttributes\' last modified times\nlast access time and creation time to another file ... ?','IO',1,3,NULL,5),(106,'... interface\n\nmethods:\n\nString 	name()\nReturns the name of the attribute view.\n\nBasicFileAttributes 	readAttributes()\nReads the basic file attributes as a bulk operation.\n\nvoid 	setTimes(FileTime lastModifiedTime, FileTime lastAccessTime, FileTime createTime)\n\nUpdates any or all of the file\'s last modified time, last access time, and create time attributes.','BasicFileAttributeView is a...\n\nClass\n\nInterface\n\nAbstract class     ?','IO',1,1,NULL,5),(107,'FileTime 	creationTime()\nReturns the creation time.\n\nObject 	fileKey()\nReturns an object that uniquely identifies the given file, or null if a file key is not available.\n\nboolean 	isDirectory()\nTells whether the file is a directory.\n\nboolean 	isOther()\nTells whether the file is something other than a regular file, directory, or symbolic link.\n\nboolean 	isRegularFile()\nTells whether the file is a regular file with opaque content.\n\nboolean 	isSymbolicLink()\nTells whether the file is a symbolic link.\n\nFileTime 	lastAccessTime()\nReturns the time of last access.\n\nFileTime 	lastModifiedTime()\nReturns the time of last modification.\n\nlong 	size()\nReturns the size of the file (in bytes).','interface BasicFileAttributes methods.... ','IO',1,1,NULL,5),(108,'GroupPrincipal 	group()\nReturns the group owner of the file.\n\nUserPrincipal 	owner()\nReturns the owner of the file.\n\nSet<PosixFilePermission> 	permissions()\nReturns the permissions of the file.','interface PosixFileAttributes methods','IO',1,1,NULL,5),(109,'String 	name()\nReturns the name of the attribute view.\n\nPosixFileAttributes 	readAttributes()\nReads the basic file attributes as a bulk operation.\n\nvoid 	setGroup(GroupPrincipal group)\nUpdates the file group-owner.\n\nvoid 	setPermissions(Set<PosixFilePermission> perms)\nUpdates the file permissions.','interface PosixFileAttributeView methods ...','IO',1,1,NULL,5),(110,'DosFileAttributeView has methods...\n\nsetArchive()\nsetHidden()\nsetReadOnly()\nsetSystem()\n\nfor Windows specific files ','With DosFileAttributeView you can set what new and different file types ?','IO',1,1,NULL,5),(111,'String 	name()\nReturns the name of the attribute view.\n\nDosFileAttributes 	readAttributes()\nReads the basic file attributes as a bulk operation.\n\nvoid 	setArchive(boolean value)\nUpdates the value of the archive attribute.\n\nvoid 	setHidden(boolean value)\nUpdates the value of the hidden attribute.\n\nvoid 	setReadOnly(boolean value)\nUpdates the value of the read-only attribute.\n\nvoid 	setSystem(boolean value)\nUpdates the value of the system attribute.','interface DosFileAttributeView methods...','IO',1,1,NULL,5),(112,'DosFileAttributes dos = Files.readAttributes(path, DosFileAttributes.class);\n\nsout( dos.isHidden() );\nsout( dos.isReadOnly() );\n\nFiles.setAttribute(path, \"dos:hidden\", true);\nFiles.setAttribute(path, \"dos:readonly\", true);\n\n','read a DosFileAttributes then declare if it is hidden and readonly \nthen set them so without using a DosFileAttributeView...','IO',1,1,NULL,5),(113,'\n    setAttribute\n\n    public static Path setAttribute(Path path,\n                    String attribute,\n                    Object value,\n                    LinkOption... options)\n                             throws IOException\n\n    Sets the value of a file attribute.\n\n    The attribute parameter identifies the attribute to be set and takes the form:\n\n        [view-name:]attribute-name \n\n    where square brackets [...] delineate an optional component and the character \':\' stands for itself.\n\n    view-name is the name of a FileAttributeView that identifies a set of file attributes. If not specified then it defaults to \"basic\", the name of the file attribute view that identifies the basic set of file attributes common to many file systems. attribute-name is the name of the attribute within the set.\n\n    The options array may be used to indicate how symbolic links are handled for the case that the file is a symbolic link. By default, symbolic links are followed and the file attribute of the final target of the link is set. If the option NOFOLLOW_LINKS is present then symbolic links are not followed.\n\n    Usage Example: Suppose we want to set the DOS \"hidden\" attribute:\n\n        Path path = ...\n        Files.setAttribute(path, \"dos:hidden\", true);\n     \n\n    Parameters:\n        path - the path to the file\n        attribute - the attribute to set\n        value - the attribute value\n        options - options indicating how symbolic links are handled\n    Returns:\n        the path parameter\n    Throws:\n        UnsupportedOperationException - if the attribute view is not available\n        IllegalArgumentException - if the attribute name is not specified, or is not recognized, or the attribute value is of the correct type but has an inappropriate value\n        ClassCastException - if the attribute value is not of the expected type or is a collection containing elements that are not of the expected type\n        IOException - if an I/O error occurs\n        SecurityException - In the case of the default provider, and a security manager is installed, its checkWrite method denies write access to the file. If this method is invoked to set security sensitive attributes then the security manager may be invoked to check for additional permissions.\n\n','You dont always need a XXXFileAttributeView object in order to change\na files attributes, you can just as easily do so with \"Files\" ...\n	','IO',1,1,NULL,5),(114,'Files.setPosixFilePermissions\n\npublic static Path setPosixFilePermissions(Path path,\n                           Set<PosixFilePermission> perms)\n                                    throws IOException\n\nSets a file\'s POSIX permissions.\n\nThe path parameter is associated with a FileSystem that supports the PosixFileAttributeView. This attribute view provides access to file attributes commonly associated \nwith files on file systems used by operating systems that implement the Portable \nOperating System Interface (POSIX) family of standards.\n\nParameters:\n    path - A file reference that locates the file\n    perms - The new set of permissions\nThrows:\n    UnsupportedOperationException - if the associated file system does not support the PosixFileAttributeView\n    ClassCastException - if the sets contains elements that are not of type PosixFilePermission\n    IOException - if an I/O error occurs\n    SecurityException - In the case of the default provider, and a security manager is installed, it denies RuntimePermission(\"accessUserInformation\") or its checkWrite method denies write access to the file.','You dont need PosixFileAttributeView to set a file permissions either...','IO',1,1,NULL,5),(115,'PosixFileAttributes pos = Files.readAttributes(path, PosixFileAttributes.class);\nSet<PosixFilePermissions> perms = PosixFilePermissions.fromString(\"rw-r--r--:);\n\nFiles.setPosixFilePermissions(path,perms);\n\nsout(pos.group());\nsout(pos.permissions());','How to set a linux files permisions from a string ?\n	','IO',0,2,NULL,5),(116,'DirectoryStream<T> \n\nT is the element returned by the iterator. \n\nTHis allows for the convieninet use of a for - each loop to go through a dir.\n\nThe elements returned by the iterator are in no specific order.\n\n List<Path> listSourceFiles(Path dir) throws IOException {\n       List<Path> result = new ArrayList<>();\n       try (DirectoryStream<Path> stream = Files.newDirectoryStream(dir, \"*.{c,h,cpp,hpp,java}\")) {\n           for (Path entry: stream) {\n               result.add(entry);\n           }\n       } catch (DirectoryIteratorException ex) {\n           // I/O error encounted during the iteration, the cause is an IOException\n           throw ex.getCause();\n       }\n       return result;\n   }\n ','What interface is used to recursively loop through a directory ?	','IO',0,2,NULL,5),(117,'\n    Files.newDirectoryStream\n\n    public static DirectoryStream<Path> newDirectoryStream(Path dir)\n                                                    throws IOException\n\n    Opens a directory, returning a DirectoryStream to iterate over all entries in the directory. The elements returned by the directory stream\'s iterator are of type Path, each one representing an entry in the directory. The Path objects are obtained as if by resolving the name of the directory entry against dir.\n\n    When not using the try-with-resources construct, then directory stream\'s close method should be invoked after iteration is completed so as to free any resources held for the open directory.\n\n    When an implementation supports operations on entries in the directory that execute in a race-free manner then the returned directory stream is a SecureDirectoryStream.\n\n    Parameters:\n        dir - the path to the directory\n    Returns:\n        a new and open DirectoryStream object\n    Throws:\n        NotDirectoryException - if the file could not otherwise be opened because it is not a directory (optional specific exception)\n        IOException - if an I/O error occurs\n        SecurityException - In the case of the default provider, and a security manager is installed, the checkRead method is invoked to check read access to the directory.\n\n','how do you create a new DirectoryStream<T>','IO',1,1,NULL,5),(118,'Path\n\nThe directory Stream interface is generic, but thats misleading since the \nonly way create a new DirectoryStream is by using File.newDirectoryStream\nwhich returns a Path.','What type of object are returned by directorystreams iterator ? ','IO',1,1,NULL,5),(119,'use \nFiles.newDirectoryStream(Path dir, String glob);\n\nthis lets you add a glob in that will compare the string representations \nof their file names agains the given glob.\n\nthis lets you filter your results...\n\n Path dir = ...\n     try (DirectoryStream<Path> stream = Files.newDirectoryStream(dir, \"*.java\")) {\n         :\n     }','How would you filter the object returned by a directory Stream ?	','IO',1,1,NULL,5),(120,'Nothing will not compile, must catch IOException for DirectoryStream','What will be returned by this code...\n\n	Path dir = Paths.get(\"/home/maxbisesi/Documents\");\n        \n	try(DirectoryStream<Path> ds = Files.newDirectoryStream(dir,\"[vx]*\")){\n            sout( );\n        } ','IO',1,1,NULL,5),(121,'only 1','How many directories at a time can DirectoryStream look at ?','IO',1,1,NULL,5),(122,'or ...\nDirectoryStream streams one directory','Think, DirectorySteam acts like ls in bash.','IO',1,1,NULL,5),(123,'public static Path walkFileTree(Path start,\n                FileVisitor<? super Path> visitor)\n                         throws IOException\n\nWalks a file tree.\n\nThis method works as if invoking it were equivalent to evaluating the expression:\n\n     walkFileTree(start, EnumSet.noneOf(FileVisitOption.class), Integer.MAX_VALUE, visitor)\n     \n\nIn other words, it does not follow symbolic links, and visits all levels of the file tree.\n\nParameters:\n    start - the starting file\n    visitor - the file visitor to invoke for each file\nReturns:\n    the starting file\nThrows:\n    SecurityException - If the security manager denies access to the starting file. In the case of the default provider, the checkRead method is invoked to check read access to the directory.\n    IOException - if an I/O error is thrown by a visitor method','What \"Files\" method do you use along with FileVisitor?','IO',1,1,NULL,5),(124,'FileVisitResult','FileVisitor methods return what ?','IO',1,1,NULL,5),(125,'CONTINUE\nSKIP_SIBLINGS = continue without visiting the siblings of this file or directory\n\nSKIP_SUBTREE = continue without visiting the entries in this directory\n\nTERMINATE','Enum FileVisitResult elements','IO',1,1,NULL,5),(126,'SimpleFileVisitor sf = new SimpleFileVisitor() will not compile','SimpleFileVisitor has a protected constructor so It can only be extended','IO',1,1,NULL,5),(127,'DirectoryStream throws an IOException. Therefore anytime you use \nDirectoryStream you must catch an IOException\n\ntry(DirectoryStream stream = Files.newDirectoryStream(dir)){\n	sout(\"throw excpetion\");\n	//do stuff\n} catch(IOException e) { \n	log(e);\n}','try(DirectoryStream stream = Files.newDirectoryStream(dir)){\n	sout(\"throw excpetion\");\n	//do stuff\n}\n\nWhats wrong here ?','IO',1,1,NULL,5),(128,'If DirectroyStream is not typed it will give Object elements. Therefore\nto use an untyped DirectoryStream you would have to use...\n	\n	for(Object file : stream) {\n	\n	}\n\n... but thats usually not what you want so always do this>>>\n\n	try(DirectoryStream<Path> Stream = Files.newDirectoryStream(dir)){\n\n	} catch(IOExcetpion e) {\n\n	}','try(DirectoryStream stream = Files.newDirectoryStream(dir)){\n\n	for(Path file : stream){\n		sout(file.getFileName());\n	}\n} catch(IOException e ){\n\n}\n\nWhats wrong here ??','IO',1,1,NULL,5),(129,'All character stream classes are descended from Reader and Writer. \nAs with byte streams, there are character stream classes that specialize in file I/O: FileReader and FileWriter. \nThe CopyCharacters example illustrates these classes.\n\nclose() throws IOException here too','\npublic class CopyCharacters {\n    public static void main(String[] args) throws IOException {\n\n        FileReader inputStream = null;\n        FileWriter outputStream = null;\n\n        try {\n            inputStream = new FileReader(\"xanadu.txt\");\n            outputStream = new FileWriter(\"characteroutput.txt\");\n\n            int c;\n            while ((c = inputStream.read()) != -1) {\n                outputStream.write(c);\n            }\n        } finally {\n            if (inputStream != null) {\n                inputStream.close();\n            }\n            if (outputStream != null) {\n                outputStream.close();\n            }\n        }\n    }\n}\n','IO',1,1,NULL,5),(130,'wrap them in Try Block, they all throw IOExceptions ','What has to be done with pretty much ALL IO classes ?','IO',1,1,NULL,5),(131,'public String readLine()\n                throws IOException\n\nReads a line of text. A line is considered to be terminated by any one of a line feed (\'\\n\'), a carriage return (\'\\r\'), or a carriage return followed immediately by a linefeed.\n\nReturns:\n    A String containing the contents of the line, not including any line-termination characters, or null if the end of the stream has been reached\nThrows:\n    IOException - If an I/O error occurs\n\n\nOther IO classes have read methods that only read in a single character\nBufferedReader has this too. But this method really helps!','What method does BufferedReader have that makes it valuable	','IO',1,0,NULL,5),(132,'PrintWriter','Which IO class swallows exceptions and does not throw them but \nsaid exceptions can be checked using checkerror()','IO',1,0,NULL,5),(133,'wont compile you cant construct a FileWriter from a Path not to mention there is an unreported IOException','Path file = Paths.get(\"/home/dick/bigorsmall.txt\");\nBufferedWriter bw = new BufferedWriter(new FileWriter(file));\n\nbw.write(\"this ones pretty big \");','IO',1,0,NULL,5),(134,'Copy the file from the source to target and return the target.\n\nthrows FileAlreadyExistsException if target fiile already exists, and no\nREPLACE_EXSISTING copy Option is specified. ','Files method:\n\nPath copy(Path src, Path targ, CopyOption...options)','IO',1,0,NULL,5),(135,'Moves the file from src to target return target. \n\nthrows:\n\n FileAlreadyExistsException - if the target file exists but cannot be replaced because the REPLACE_EXISTING option is not specified (optional specific exception)\n   \n DirectoryNotEmptyException - the REPLACE_EXISTING option is specified but the file cannot be replaced because it is a non-empty directory (optional specific exception)','Files method:\n\nPath move(Path src, Path target, CopyOption options)','IO',1,0,NULL,5),(136,'false \ntrue\n\nin glob * means match any character excpet a directory boundary\n\n** mathces any character across directory boundaries. \n\nnotice that PathMatcher(\"syntax:pattern\") can take a glob or a regex but you\nmust specify\n\nedit:\nwas previously:\nDefault().getPathMatcher(\"glob: *.txt\");\n\nthere cant be a space after the : or that will mathch...\n\n	Path path = Paths.get(\"one.txt\");\n        PathMatcher matcher = FileSystems.getDefault().getPathMatcher(\"glob: *.txt\");\n        System.out.println(matcher.matches(path));\n\nwould give false unless the space was removed. | Path p1 = Paths.get(\"/home/One.txt\");\nPath p2 = Paths.get(\"One.txt\");\nPathMatcher matcher = FileSystems.getDefault().getPathMatcher(\"glob: *.txt\");\n\nsout( matcher.matches(p1) );\nsout( matcher.matches(p2) );','Path p1 = Paths.get(\"/home/One.txt\");\nPath p2 = Paths.get(\"One.txt\");\nPathMatcher matcher = FileSystems.getDefault().getPathMatcher(\"glob:*.txt\");\n\nsout( matcher.matches(p1) );\nsout( matcher.matches(p2) );','IO',1,0,NULL,5),(137,'* matches any character inside a directory boundary\n** matches any character inside a directory boundary\n\n','in Glob what does * mean ? what about ** ?','IO',1,0,NULL,5),(138,'? matches any single character. ','GLOB\n\nwhat does \"?\" mean ?','IO',1,0,NULL,5),(139,'true\ntrue\nfalse','public class Hello {\n    public static void main(String[] args) {\n        PathMatcher matcher = FileSystems.getDefault().getPathMatcher(\"glob:**{.pic,.txt}\");\n        Path p1 = Paths.get(\"home/files.txt\");\n        Path p2 = Paths.get(\"documents/pictures/smile.pic\");\n        Path p3 = Paths.get(\"home/dir\");\n        \n        System.out.println(matcher.matches(p1));\n        System.out.println(matcher.matches(p2));\n        System.out.println(matcher.matches(p3));\n    }\n\n}','IO',1,0,NULL,5),(140,'true\ntrue\nfalse','public void matches(Path path, String glob){\n	PathMatcher matcher = FileSystems.getDefault().getPathMatcher(glob);\n	sout( matcher.matches(path) );\n}\n\nPath p1 = Paths.get(\"Bert-book\");\nPath p2 = Paths.get(\"Kathy-horse\");\nmatches(p1, \"glob:{Bert*,Kathy*}\");\nmatches(p2, \"glob: {Bert, Kathy}*\");\nmatches(p1, \"glob:{Bert,Kathy}\");','IO',1,0,NULL,5),(141,'wrong, visitFileFailed takes an IOExcpeption as a parameter\nas well as postVisitDirectory','FileVisitor\n\npublic FileVisitResult visitFileFailed(path file, BasicFileAttributes attrs) {\n\n	// do something\n	return FileVisitResult.CONTINUE;\n	\n}\n','IO',1,0,NULL,5),(142,'right, ','FileVisitor: \n\npublic FileVisitResult preVisitDirectory(path file, BasicFileAttributes attrs) {\n\n	// do something\n	return FileVisitResult.CONTINUE;\n	\n}','IO',1,0,NULL,5),(143,'right','FileVisitor:\n\npublic FileVisitResult visitFileFailed(path file, IOException e) {\n\n	// do something\n	return FileVisitResult.CONTINUE;\n	\n}','IO',1,0,NULL,5),(144,'right','FileVisitor:\n\npublic FileVisitResult postVisitDirectory(path file, IOException e) {\n\n	// do something\n	return FileVisitResult.CONTINUE;\n	\n}','IO',1,0,NULL,5),(145,'9/8/01 7:46 PM \n\nremember that strings are imutable, so even though you called \nreplaceAll on that string you didn\'t assing it to a new sString therefore it\nwas lost.\n\nshould be:\n	String newDate = todayFile.replaceAll(\" \",\"-\");','Date today = new Date();\n\nDateFormat df = DateFormat.getInstance();\n\nString todayFile = df.format(today);\n\nsout(todayFile);	// this gives 9/8/01 7:46 PM\n\ntodayFile.replaceAll(\" \",\"-\");\n\nsout( todayFile );\n\nwhat prints now ?','Strings',1,0,NULL,5),(146,'wont compile, FileWriter doesn\'t have a Path constructor,\n\nchange p1 to p1.toFile();\n\nFileWriter(File file)\nConstructs a FileWriter object given a File object.\n\nFileWriter(File file, boolean append)\nConstructs a FileWriter object given a File object.\n\nFileWriter(FileDescriptor fd)\nConstructs a FileWriter object associated with a file descriptor.\n\nFileWriter(String fileName)\nConstructs a FileWriter object given a file name.\n\nFileWriter(String fileName, boolean append)\nConstructs a FileWriter object given a file name with a boolean indicating whether or not to append the data written.','Path p1 = Paths.get(todayFile+\".txt\");\nSystem.out.println(p1);\n        \nBufferedWriter bw = new BufferedWriter(new FileWriter(p1));','IO',1,0,NULL,5),(147,'4 3 \n\ntwo rules apply to the first doX, you cannot widen and then box in\none step, and var-args are always chosen last. So you cannot widen shorts\nto ints or longs then box them to Integer or Long but you can box short\nto Short then widen that to Number, that takes priority over var args.\n\nthe second doX simmply boxs int to Integer.\n\n\n\n    Assignment contexts allow the use of one of the following:\n\n        an identity conversion (§5.1.1)\n\n        a widening primitive conversion (§5.1.2)\n\n        a widening reference conversion (§5.1.5)\n\n        a boxing conversion (§5.1.7) optionally followed by a widening reference conversion\n\n        an unboxing conversion (§5.1.8) optionally followed by a widening primitive conversion.\n\n\n','class Eggs {\n	int doX(Long x, Long y){ return 1; }\n	int doX(long...){ return 2; }\n	int doX(Integer x, Integery){ return 3; }\n	int doX(Number n, Number m){ return 4; }\n	public static void main(SA){\n		new Eggs().go();\n	}\n	void go(){\n		short s = 7;\n		sout(doX(s,s) + \" \");\n		sout(doX(7,7));\n	}\n}','General',1,0,NULL,5),(148,'the first is the directory to start walking at in the form of a Path\n\nthe second is an object of the class that extends SimpleFileVisitor<Path>','What is the first and second argument to Files.walkFileTree()','IO',1,0,NULL,5),(149,'visitFileFailed and postVisitDirectory','Which Two FileVisitor methods take IOExceptions as parameters	?','IO',1,0,NULL,5),(150,'preVisitDirectory and visitFile','Which two FileVisitor methods take BasicFileAttributes as parameters ?','IO',1,0,NULL,5),(151,'now the output is:\n	pre: /home\n	file: /home/a.txt\n	pre: /home/child\n	pre: /home/emptyChild\n	post: /home/emptyChild\n	post: /home\n\npostVisitDirectory is never called if the subtree of the directory is skipped','/home\n	- a.txt\n	- emptyChild	\n	- child\n		- b.txt\n		- grandchild\n			- c.txt\n\npublic class PrintDirs extends SimpleFileVisitor<Path> {\n	public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) {\n		sout( \"pre\" + dir);\n		String name = dir.getFileName().toString();\n		\n		if (name.equals(\"child\"))\n			return FileVisitResult.SKIP_SUBTREE;\n		return FileVisitResult.CONTINUE;\n\n	}\n}\n			\n			\n		\n	','IO',1,0,NULL,5),(152,'','postVisitDirectory is never called if the subtree of the directory is skipped','IO',1,0,NULL,5),(153,'assuming child is encountered beffore emptyChild, the output is: \n\npre: /home\nfile: /home/a.txt\npre: /home/child\nfile: /home/child/b.txt\npre: /home/child/grandchild\npost: /home/child\npre: /home/emptyChild\npost: /home\n\nyou skip the grandchld subtree so you dont see the postVisitDirectory call\n\nchild is a sibling but it was encountered before emptychild so it was not skipped','/home\n	- a.txt\n	- emptyChild	\n	- child\n		b.txt\n		grandchild\n		c.txt\n\n\" assume you have FileVisitor method from previous flashcards where the\npre post and file are printed before printing the path of that dir or file \"\n\npublic FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) {\n	sout( \"pre: \" + dir);\n	String name = dir.getFileName().toString();\n	\n	if (name.equals(\"grandchild\"))\n		return FileVisitResult.SKIP_SUBTREE;\n	if ( name.equals(\"emptychild\")\n		return FileVisitResult.SKIP_SIBLINGS;\n	return FileVisitResult.CONTINUE;','IO',1,0,NULL,5),(154,'true \nfalse\nfalse\nfalse\n\n{A*,b} means A followed by anything or the single character b\n\n/**/ means one or more directories with any name\n\n\\\\* the actuall asterix character \\ escapes the * the second \\ espaces the first \\ ','public void matches(Path path, String glob){\n	PathMatcher matcher = FileSystems.getDefault().getPathMatcher(glob);\n	sout( matcher.matches(path) );\n}\n\nPath p1 = Paths.get(\"0*b/test/1\");\nPath p2 = Paths.get(\"9\\\\*b/test/1\");\nPath p3 = Paths.get(\"01b/test/1\");\nPath p4 = Paths.get(\"0*b/1\");\n\nString glob = \"[0-9]\\\\*{A*,b}/**/1\");\n\nmatches(p1,glob);\nmatches(p2,glob);\nmatches(p3,glob);\nmatches(p4,glob);\n','IO',1,0,NULL,5),(155,'IOException','What exception if any do FileVisitor methods throw ?','IO',1,0,NULL,5),(156,'glob: **\n\nregex: .*','glob vs regex: \n\nZero or more of any character, including directory bounndary','IO',1,0,NULL,5),(157,'zero or or more of any character including directory boundary','regex:\n\n.*','IO',1,0,NULL,5),(158,'glob: *\n\nregex: no syntax required','glob vs regex:\n\nZero or more of any character, not a directory boundary','IO',1,0,NULL,5),(159,'glob: ?\n\nregex: .','Glob vs regex:\n\nexcactly one character','IO',1,0,NULL,5),(160,'glob:\n	{cat, dog}*\n\nregex:\n\n	(cat|dog).*','glob vs regex:\n\nBegins with cat or dog','IO',1,0,NULL,5),(161,'regex','(cat|dog).*\n\nglob or regex ?','IO',1,0,NULL,5),(162,'FileSystems.getDefault().getPathMatcher();','You are creating a PathMatcher\n\nPathMatcher matcher = ________._________().__________();','IO',1,0,NULL,5),(163,'FileSystems.getDefault().newWatchService();','You are creating a WatchService:\n\nWatchService watcher = _____________.__________()._________()','IO',1,0,NULL,5),(164,'WatchKey\ntry {\n	WatchKey key;\n	try {\n	key = watcher.take();\n              } catch(interuptedException x) {\n		return;\n	}\n	for(WatchEvent<?> event : key.pollEvents()){\n	//do stuff\n	}','What do you get from a WatchService to indicate a deletion creation or modification','IO',1,0,NULL,5),(165,'take() will wait and block forever until an event takes place. Will throw\nInteruptedException if interuped without taking an event. \n\npoll() returns null if an event is not imediately available. ','What are two ways to get a WatchKey ? \nand whats the difference between them ? ','IO',1,0,NULL,5),(166,'does not compile countGold() cannot be called from a static context','public class Frodo etends Hobbit {\n	public static void main(SA) { \n		int mygold = 7;\n		sout(countGold(mygold,6));\n	}\n}\nclass Hobbit {\n	int countGold(int x, int y) { return x + y; }\n}','IO',1,0,NULL,5),(167,'1) If two objects are equal, then they must have the same hash code.\n2) If two objects have the same hash code, they may or may not be equal. \n3) If two objects are not equal, they must NOT have the same hashcode\n','The contract between equals() and hashCode() is:','OOP',1,0,NULL,5),(168,'shows all files and directories in /home/maxbisesi\n\nsqlexception if the path is not a valid path',' public static void main(String[] args){\n       Path dir = Paths.get(\"/home/maxbisesi\");\n       try(DirectoryStream<Path> stream = Files.newDirectoryStream(dir,\"*\");){\n            for(Path path : stream){\n               System.out.println(path);\n            }\n        } catch(IOException e){\n            System.out.println(\"SQLException\");\n            System.out.println(e);\n        }\n   }','IO',1,0,NULL,5),(169,'x.a() thread1 x.a() in thread2\nx.b() thread1 x.b() in thread2\nx.b() thread1 y.b() in thread2\n\nthe same instance method of the same instance is blocked while a static\nmethod accross all methods is blocked. ','public class Hello {\n    synchronized void a() { actBusy(); }\n    static synchronized void b() { actBusy(); }\n    static void actBusy() {\n        try {\n            Thread.sleep(1000);\n            \n        } catch( InterruptedException e){}\n            \n        \n    }\n    public static void main(String[] args) {\n        final Hello x = new Hello();\n        final Hello y = new Hello();\n        \n        Runnable runnable = new Runnable() {\n            public void run() {\n                int option = (int) (Math.random() * 4);\n                switch(option) {\n                    case 0: x.a(); break;\n                    case 1: x.b(); break;\n                    case 2: y.a(); break;\n                    case 3: y.b(); break;\n                }\n            }\n        };\n        \n        Thread t1 = new Thread(runnable);\n        Thread t2 = new Thread(runnable);\n        \n        t1.start();\n        t2.start();\n    \n    }\n\n}  \n\nwhich methods could never be running at the same time ?','Threads',1,0,NULL,5),(170,'got it ','Method forwarding relies on Has-a relationships','OOP',1,0,NULL,5),(171,'method forwarding\n\nan object composition principle that calles methods on an instance variable of an object','class Animal implements Burriable {\n    private Integer size;\n    private String name;\n    \n    public Animal(int x, String y){\n        size = x;\n        name = y;\n    }\n    public Animal(){\n        size = 0;\n        name = \"\";\n    }\n\n    public int getSize() {\n        return size;\n    }\n\n    public String getName() {\n        return name;\n    }\n    \n    public void bury(){\n        System.out.println(\"just toss him in there...\");\n    }\n    public void digUp(){\n        System.out.println(\"Hang on this ones still kickin !\");\n    }\n    public void pray(){\n        System.out.println(\"...Lord forgive us for what we have done, hes only been gone for \"+YEARSDEAD+\" years.\");\n    }\n}\n\nclass Dog implements Burriable{\n    private Animal animal;\n    public Dog(Animal a){\n        animal = a;\n    }\n    \n    public void bury(){\n        animal.bury();\n    }\n    public void digUp(){\n        animal.digUp();\n    }\n    public void pray(){\n        animal.pray();\n    }\n    \n    public String yelpForHelp(){\n        return \"ar ar arrr....\";\n    }\n}\n\ninterface Burriable {\n    int YEARSDEAD = 1;\n    void bury();\n    void digUp();\n    void pray();\n}\n\nwhat OOP principle is this ?','OOP',1,0,NULL,5),(172,'The singleton pattern is identifiable bby the static variable for the single instance and the accessor returning it. ','public class F {\n	private static final F f = new F();\n	public static F c(){\n		return f;\n	}\n\n	public void update(F a) { }\n	\n	public void delete(F a) { }\n\n}\nwhat design pattern is this ? ','OOP',1,0,NULL,5),(173,'object composition, you can tell because of the method forwarding. \nSingleton is tempting but the getInstance method here returns a NEW instance\ninstead a single private static one like it should to be singleton. ','public class E {\n	private D d;\n	public void m() {\n		d.m();\n	}\n\n		public static E getInstance() {\n			return new E();\n		}\n}\n\nclass D {\n	public void m() { }\n}\n\nwhat design pattern principle is this ?\n','OOP',1,0,NULL,5),(174,'Factory,\n\nClass A is the object we are creating using the factory method. class G\nis the abstract superclass for the factory. Not shown is a class implementing \nclass G that actually creates the object. ','class A {}\n\nabstract class G {\n	A m() { return n(); }\n	abstract A n();\n}\n\nwhat principle is demostrated','OOP',1,0,NULL,5),(175,'Reuse The DAO pattern centralize logic for the data access code making reuse\neasier and allowing you to switch out implementations. ','which is a benefit of the DAO pattern ?	','OOP',1,0,NULL,5),(176,'regular files, hidden files, and subdirectories','public void print(Path d) throws IOException {\n	try(DirectoryStream<Path> stream = Files.newDirectoryStream(d)){\n		for(Path path: stream){\n			sout( path.getFileName() );\n		}\n	}\n}\n\nwhat files will this display ? ','IO',1,0,NULL,5),(177,'The first time the file will be created and copied normally the second time you\nwill get a file already exists excpeiotn','public class Hello {\n    public static void main(String[] dicks) throws IOException{\n      Path src = Paths.get(\"/home/maxbisesi/Documents/copy.txt\");\n      Files.createFile(src);\n      \n      Files.copy(src, Paths.get(\"/home/maxbisesi/Documents/newcopy.txt\"));\n      \n    }\n\n}\n\nwhat happens if this is ran twice and all preivous files dont exist before','IO',1,0,NULL,5),(178,'Compilation fails, to compile would have to be \n\n	Object item = list.get(0);','public class Hello {\n    public static void main(String[] dicks){\n        ArrayList list = new ArrayList();\n        \n        list.add(\"java\");\n        list.add(\"sucks\");\n        \n        String item = list.get(0);\n\n    }\n\n}','Collections',1,0,NULL,5),(179,'Will not compile, there is no scope there \n\nif(true){\n	int b = 1;\n} \n	this would though !','if(true)\n       int b = 1;\n        ','General',1,0,NULL,5),(180,'CooLooLCuuL\n\n* is the greedy quantifier, it takes as much as it can. ','public class Hello {\n    public static void main(String[] dicks){\n        Pattern p = Pattern.compile(\"C.*L\");\n        Matcher m = p.matcher(\"CooLooLCuuLooC\");\n        \n        while(m.find())\n            System.out.println(m.group());\n\n    }\n\n}','Strings',1,0,NULL,5),(181,'False it gets the same priority as the thread that created it ','If a thread\'s priority is not specified explicitly then it gets\nNORM_PRIORITY\n\nT or F ','Threads',1,0,NULL,5),(182,'Will not compile, method eat in class animal cannot be applied to given types','public class Hello {\n    public static void main(String[] dicks){\n        Animal ah2 = new Horse();\n        ah2.eat(\"carrots\");\n    }\n\n}\n\nclass Animal{\n    public void eat(){ }\n}\n\nclass Horse extends Animal {\n    public void eat() { }\n    public void eat(String s ){ } \n}\n    ','General',1,0,NULL,5),(183,'Horse','public class Hello {\n    public static void main(String[] dicks){\n        Animal ah2 = new Horse();\n        ah2.eat();\n    }\n\n}\n\nclass Animal{\n    public void eat(){ System.out.println(\"Animal\"); }\n}\n\nclass Horse extends Animal {\n    public void eat(){ System.out.println(\"Horse\");} \n}\n\n','General',1,0,NULL,5),(184,'will not compile overriden method \ncannot throw new or broader checked exceptions','public class Hello {\n    public static void main(String[] dicks){\n        Animal ah2 = new Horse();\n        ah2.eat();\n    }\n\n}\n\nclass Animal{\n    public void eat(){ System.out.println(\"Animal\"); }\n}\n\nclass Horse extends Animal {\n    public void eat() throws IOException{ System.out.println(\"Horse\");} \n}','General',1,0,NULL,5),(185,'Animal\n\neat in horse is an overload, it still inherits Animals eat()','public class Hello {\n    public static void main(String[] dicks){\n        Animal ah2 = new Horse();\n        ah2.eat();\n    }\n\n}\n\nclass Animal{\n    public void eat(){ System.out.println(\"Animal\"); }\n}\n\nclass Horse extends Animal {\n    public void eat(int x) throws IOException{ System.out.println(\"Horse\");} \n}','General',1,0,NULL,5),(186,'SQLException\n	Statement objects do not support multiple open ResultSets.\n	\n	Only a single ResultSet can be opened from the same statement object\n\n	*if the same statement object is executed more than once the previous\n	ResultSet is closed automatically\n		\n		... and attempting to access a closed RS is a SQLException','//assume valid Connection cn, and good database connection\n\nString query = \"Select * from Answer\";\ntry(Statement stmt = cn.createStatement()){\n	ResultSet rs1 = stmt.executeQuery(query);\n	stmt.executeQuery(\"select * from Question\");\n	while(rs1.next(){\n		sout(rs1.getInt(\"fk_question_num\");\n	}\n} catch(SQLException e){\n	\n}','JDBC',1,0,NULL,5),(187,'','','blank',1,0,NULL,5),(188,'SQLException , attempting to execute a query without setting a parameter\nresults in an SQLException\n\n	should be>>>\n		\n		pstmt.setString(1,\"dick\");\n\nIndexing starts at 1','try(Connection conn = DriverManager.getConnection(url,user,pw)){\n	String pQuery = \"Select unitPrice From Book Where Title Like ?\";\n\n	PreparedStatement pstmt = conn.prepareStatement(pQuery);\n\n	ResultSet rs = pstmt.executeQuery();\n} catch(SQLException sq) {\n}\n','JDBC',1,0,NULL,5),(189,'compiles and runs just fine ','public class Hello {\n    public static void main(String[] dicks){\n        try{\n            couldthrow();\n        } catch(IOException | SQLException e){\n            \n        }\n        \n    }\n    \n    public static void couldthrow() throws IOException, SQLException{\n        \n    }\n\n}','Exceptions',1,0,NULL,5),(190,'instanceof test','public boolean equals(Object o) { \n	if(((Moof)o).getMoofValue() == this.moofValue {\n		return true;\n	} else {\n		return false;\n	}\n}\n\nwhats missing here','Collections',1,0,NULL,5),(191,'got it','equals() hashCode() and toString() are all PUBLIC','Collections',1,0,NULL,5),(192,'for any reference value x, x.equals(x) should be true. ','equals() Contract\n\nreflexive	','Collections',1,0,NULL,5),(193,'for any reference values x and y, \n\nx.equals(y) shoud be true if and only if \ny.equals(x) returns true. ','equals() contract,\n\nsymmetric','Collections',1,0,NULL,5),(194,'reflxive, x.equals(x) is always true\n\nsymetric, x.equals(y) and y.equals(x)\n\ntransitive, if x.equals(y) and y.equals(z) then x.equals(z)\n\nconsistent, x.equals(y) is true no matter how many times you call it\n\nif x is non null, x.equals(null) is always false','what are the four tenants of the equals contract ?','Collections',1,0,NULL,5),(195,'MUST also be equal.','if two objects are considered equal, their hashcodes...','Collections',1,0,NULL,5),(196,'Yes just inefficient, all objects will go in the same bucket. The Collection\nwill search through a single big bucket using equal() to find the instance\nits looking for. In that case you defeat the purpose of using a hashed collection. ','Is it still legal to have a hashcode that always returns the same number ?','Collections',1,0,NULL,5),(197,'When it is invoked on the same object more than once during an execution\nof a java application the hashcode() method must consistently return the \nsame integer \n\nIf two objects are equal according to the equals method, then calling hashchode)( \non each of the objects must produce the same integer\n\nunequal objects can still produce the same hashcodes \n\n*That means that equals and hashCode must work with same attributes somehow','HashCode contract:\n\n1\n\n2\n\n\n3','Collections',1,0,NULL,5),(198,'x.hashcode() == y.hashcode()','x.equals(y) == true\n\nmeans what for hashcode()...','Collections',1,0,NULL,5),(199,'x.equals(y) == false\n\nequals() and hashcode are like directions to get to a specific \nelement\n\nhashCode places all the elements in seperate but similiar buckets \nequals() gets the correct ones out.\n\nso if two elemets have different hashCodes they will be in different buckets\nanyway so hashCode is one level of precision and equals() is the next.','x.hashCode() != y.hashCode()	\n\nmeans what for equals()','Collections',1,0,NULL,5),(200,'../..\nGenDir/genFile.txt\n','public static void main(String[] args){\n        Path p = Paths.get(\"/home/maxbisesi/Public/GenDir/genFile.txt\");\n        Path p2 = Paths.get(\"/home/maxbisesi/Public\");\n        \n        System.out.println(p.relativize(p2));\n        System.out.println(p2.relativize(p));  \n}','IO',1,0,NULL,5),(201,'a Vector is the same as an ArrayList but Vector methods are synchronized\nfor thread safety. \n\nVector and Hashtable are the two original collections\n\nunless you really need thread safety choose ArrayList over Vector, \nthe synchronized methods give an unecssary performance hit. \n\n','Collections:\n\n	Vector\n','Collections',1,0,NULL,5),(202,'is ordered by index position except that the elements are doubly linked to \none another. This linkage gives you new methods for adding and removing\nfrom the beginning or end.\n\nEasy choice for implementing a stack or queue. \n\nmay iterate more slowly than ArrayList but still a good choice when you need\nfast insertion and deletion.\n\nLinkedList supports peek(), poll(), offer(), Queue methods!!','Collections:\n\n	LinkedList','Collections',1,0,NULL,5),(203,'Set','Which Interface disallows duplicates','Collections',1,0,NULL,5),(204,'unsorted and unordered. Uses the hashcode of the object being inserted\n\nso the more effeicinet your hashcode the more effecient access youll get\n\nUse for a collection with no duplicates where you dont care about the\norder when you iterate through it.','Collections:\n	\n	HashSet','Collections',2,0,NULL,5),(205,'\nMaintains a doubly linked list across elelemnts so the insertion order \nis maintained\n\nduplicates are still disallowed. ','Collections:\n\n	LinkedHashSet','Collections',0,1,NULL,5),(206,'Sorted\n\nguarentees elements will be in ascending order according to natural order\n\n','Collections:\n\n	TreeSet','Collections',0,1,NULL,5),(207,'compilation fails at the last three lines,\n\n1. multi catch syntax is | not ||\n\n2. objects declared in a try block are only available within the \ntry block so closing r is out of scope','public class Reader {\n	public void read(Path p, Charset s) {\n		try(BufferedReader r = Files.newBufferedReader(p,s)) {\n			try { r.read(); }\n			catch(IOException f) {\n				r.readLine();\n			}\n		} catch(IOException || NullPointerException e) {\n			r.close();\n		} finally {\n			r.close();\n		}\n	}\n}','IO',0,1,NULL,5),(208,'unsorted and unordered Map. \n\nUse When you need a map and you don\'t care\nabout the order when you iterate through. \n\nThe basic map, other maps add a little more overhead. \n\nWhere keys land in the map is based on hashCode() \n\nHashMap allows one null key and multiple null values ','Collections:\n\n	HashMap','blank',0,1,NULL,5),(209,'Hashtable is the synchronized counterpart to HashMap. \n\nWhile HashMap lets you have a null key and null values\n\nHashtable doesn\'t allow anything thats null!','Collections:\n	\n	Hashtable\n	','Collections',1,1,NULL,5),(210,'True!\n\nHashtable doesn\'t allow anything null it will throw a npe','HashMap allows multiple null values','Collections',0,1,NULL,5),(211,'FALSE\n\nThat would defeat the purpose of a \"key\"','HashMap allows multiple null keys','Collections',0,1,NULL,5),(212,'FALSE\n\nunordered and unsorted','HashMap is sorted','Collections',0,1,NULL,5),(213,'FALSE','HashMap is synchronized','Collections',0,1,NULL,5),(214,'True!','Hashtable is synchronized ','Collections',0,1,NULL,5),(215,'FALSE, nothing can be null in Hashtable','Hashtable allows multiple null values and one null key','blank',0,1,NULL,5),(216,'since list is declared as anything that extends Animal you cant be sure that it\nwill be the right type to pass into the next method that taks <Animal>\n\nWill not compile','public static ArrayList<Animal> staggerSort(ArrayList<? extends Animal> list){\n        Map<String,List<Number>> byCategory = seperateToCategories(list);\n        return null;\n    }\n    \n    static Map<String,List<Number>> seperateToCategories(ArrayList<Animal> list){\n        return null;\n    }','Generics',0,1,NULL,5),(217,'big Bucks\nsweet Cheeks\n\nbig Bucks replaced big Country in the map, LinkedHashMaps maintain insertion\norder. \n\nso that mapping was simply replaced but it kept its position','public static void main(String[] args){\n        LinkedHashMap<String,String> lhm = new LinkedHashMap<>();\n        lhm.put(\"big\",\"Country\");\n        lhm.put(\"sweet\",\"Cheeks\");\n        lhm.put(\"big\",\"Bucks\");\n        \n        for(Map.Entry<String,String> entry: lhm.entrySet()){\n            System.out.println(entry.getKey()+\" \"+entry.getValue());\n        }\n        \n    }','Collections',0,1,NULL,5),(218,'WNC,\n\ngo() declares that it throws a checked exceptions so it has to be handled\nor thrown in main.\n\nif that would have compiled an IOException would be thrown so it would\nprint got io error done. ','class Gutsy {\n	public static void main(String[] args){\n		new Gutsy().go();\n	}\n	void go() throws IOException {\n	String row;\n	try {\n		FileReader fr = new FileReader(\"TestFile.txt\");\n		BufferedReader br = new BufferedReader(fr);\n		while((row = br.readLine() ) != null)\n			sout( row );\n	} catch(IOException e) {\n		sout(\"got io error\");\n	} finally {\n		sout( \"done\" );\n	}\n   }\n}','Exceptions',0,1,NULL,5),(219,'-6 through 4','Given a properly prepared string[] with five elements what is the range \nof possible results that could be returned by Arrays.binarySearch() ? ','Collections',0,1,NULL,5),(220,'sorted Map\n\nsorted by natural order or custom comparison rules.','TreeMap','blank',0,1,NULL,5),(221,'3\nfalse\ntrue\n2','List<String> test = new ArrrayList<String>();\nString s = \"hi\";\ntest.add(\"string\");\ntest.add(s);\ntest.add(s+s);\nsout( test.size() );\nsout( test.contains(42) );\nsout( test.contains(\"hihi\") );\ntest.remove(\"hi\");\nsout( test.size() );','Collections',0,1,NULL,5),(222,'These two are the same, the first demonstrates autoboxing. ','List myInts = new ArrayList();\n        myInts.add(4);\n        \n        myInts.add(new Integer(4));','blank',0,1,NULL,5),(223,'NullPointerException','class Boxing2 {\n	static Integer x;\n	psvm(sa) {\n		doStuff(x);\n	}\n\n	static void doStuff(int z) {\n		int z2 = 5;\n		sout( z2 + z );\n	}\n}','General',0,1,NULL,5),(224,'unsorted: [CZ, a, AB, CE, CZ, cz, BA, BF, ABC, CE,  CE, A, ce, A B, AA,  Z]\nsorted: [ CE,  Z, A, A B, AA, AB, ABC, BA, BF, CE, CE, CZ, CZ, a, ce, cz]\n\nspaces come first, as shown by A B and AA. Also capitals come before lowercase','public static void main(String[] dicks){\n        ArrayList<String> list = new ArrayList<>();\n        \n        list.add(\"CZ\");\n        list.add(\"a\");\n        list.add(\"AB\");\n        list.add(\"CE\");\n        list.add(\"CZ\");\n        list.add(\"cz\");\n        list.add(\"BA\");\n        list.add(\"BF\");\n        list.add(\"ABC\");\n        list.add(\"CE\");\n        list.add(\" CE\");\n        list.add(\"A\");\n        list.add(\"ce\");\n        list.add(\"A B\");\n        list.add(\"AA\");\n        list.add(\" Z\");\n        \n        System.out.println(\"unsorted: \"+list);\n        Collections.sort(list);\n        System.out.println(\"sorted: \"+list);','Collections',0,1,NULL,5),(225,'Will not compile, Horse does not implement Comparable','public class Hello {\n    public static void main(String[] dicks){\n        List<Horse> stable = new ArrayList<>();\n        \n        for(int x =0; x < 10; x++){\n            stable.add(new Horse());\n        }\n        \n        Collections.sort(stable);\n        \n    }\n\n}\n\nclass Horse {\n    public boolean equals(Horse s){\n        return false;\n    }\n}','Collections',0,1,NULL,5),(226,'will not compile, compareTo is public ','class Horse implements Comparable<Horse> {\n    public boolean equals(Horse s){\n        return false;\n    }\n    \n    int compareTo(Horse h){\n        \n    }\n    \n    \n}','Collections',0,1,NULL,5),(227,'compiles fine!','public class Hello {\n    public static void main(String[] dicks){\n        List<Horse> stable = new ArrayList<>();\n        \n        for(int x =0; x < 10; x++){\n            stable.add(new Horse(\"lucky\"+x));\n        }\n        \n        Collections.sort(stable);\n        \n    }\n\n}\n\nclass Horse implements Comparable<Horse> {\n    String name;\n    \n    public Horse(String x){\n        name = x;\n    }\n    \n    public String getName(){\n        return name;\n    }\n    \n    public boolean equals(Horse s){\n        return false;\n    }\n    \n    public int compareTo(Horse h){\n        return name.compareTo(h.getName());\n        \n    }\n    \n    \n}','Collections',0,1,NULL,5),(228,'Object','When you override equals() you must take an argument of what type ?','Collections',0,1,NULL,5),(229,'The type your sorting.\n\n\npublic interface Comparable<T>\n\n...type T','When you override compareTo() you must take an argument of type?','Collections',0,1,NULL,5),(230,'This is still legal but painful, genereics make this easier but it will still \ncompile','class DVDInfo implements Comparable {\n	public int comparteTo(Object o) {\n		DVDInfo d = (DVDInfo) o;\n		return title.compareTo(d.getTitle() );\n	}\n}','Collections',0,1,NULL,5),(231,'compare()\n\ncompareTo()','Comparator has _________________\n\nComparable has _________________','Collections',0,1,NULL,5),(232,'Comparator','Which soritng interface do you implement to create individual sorting classes\n	','Collections',1,0,NULL,5),(233,'will not compile the method is:\n\n	int compare(T o1, T o2)','class Dicksorter implements Comparator<Dicks> {\n	public int compareTo(Dick one) {\n	}\n}','Collections',0,1,NULL,5),(234,'compiles fine, this takes advvantage of integer comparison','class DickSorter implements Comparator<Dick> {\n	public int compare(Dick one, Dick two){\n		return one.getSize().compareTo(two.getSize());\n	}\n}','Collections',0,1,NULL,5),(235,'Will not compile\n\ntoArray() in List interface returns an Object[]','public class Hello {\n    public static void main(String[] dicks){\n        List<Horse> stable = new ArrayList<>();\n        \n        stable.add(new Horse(\"Honey\"));\n        stable.add(new Horse(\"Mighty Mikey\"));\n        stable.add( new Horse(\"The Fastest Stud in the Mud\"));\n        stable.add( new Horse(\"Churchill\"));\n        \n        Horse[] ranch = stable.toArray();\n\n    }\n\n}','Collections',0,1,NULL,5),(236,'ClassCastException, \"johny\" cant be turned into a horse\n\nshould be Arrays.binarySearch(stable,new Horse(\"Johny\"));','public class Hello {\n    public static void main(String[] dicks){\n        Horse[] stable = {new Horse(\"Johny\"), new Horse(\"wilfred\"), new Horse(\"Marco\"), new Horse(\"MAx\"), new Horse(\"Billy\") };\n        \n        int x = Arrays.binarySearch(stable,\"Johny\");\n        System.out.println(x);  \n\n    }\n\n}','Collections',0,1,NULL,5),(237,'The results are undefined, the array is not sorted. ','public class Hello {\n    public static void main(String[] dicks){\n        Horse[] stable = {new Horse(\"Johny\"), new Horse(\"wilfred\"), new Horse(\"Marco\"), new Horse(\"MAx\"), new Horse(\"Billy\") };\n        \n        int x = Arrays.binarySearch(stable,new Horse(\"Johny\"));\n        System.out.println(x);  \n\n    }\n\n}    \n\nclass Horse implements Comparable<Horse> {\n    String name;\n    \n    public Horse(String x){\n        name = x;\n    }\n    \n    public String getName(){\n        return name;\n    }\n    \n    public boolean equals(Horse s){\n        return false;\n    }\n    \n    public int compareTo(Horse h){\n        return name.compareTo(h.getName());\n        \n    }\n    \n    \n    ','Collections',0,1,NULL,5),(238,'ClassCastException Horse cannot be converted to Comparable\n\nbinarySearch uses comparable to search the Array.\n\nThis search would give inconsistant results anyways because \nthe array was not sorted first. \n\nto fix add this:\n\nclass Horse implements Comparable<Horse> {\n    String name;\n    \n    public Horse(String x){\n        name = x;\n    }\n    \n    public String getName(){\n        return name;\n    }\n    \n    public boolean equals(Horse s){\n        return false;\n    }\n    \n    public int compareTo(Horse s){\n        return name.compareTo(s.getName());\n    }\n    \n}\n\n-if an array is sorted in natrual order it must searched in natural order \n-if it is sorted using a comparator it must be searched using the same comparator.\n','public class Hello {\n    public static void main(String[] dicks){\n        Horse[] stable = {new Horse(\"Johny\"), new Horse(\"wilfred\"), new Horse(\"Marco\"), new Horse(\"MAx\"), new Horse(\"Billy\") };\n        \n        \n        int x = Arrays.binarySearch(stable,new Horse(\"Marco\"));\n        System.out.println(x);  \n\n    }\n\n}\n\nclass Horse {\n    String name;\n    \n    public Horse(String x){\n        name = x;\n    }\n    \n    public String getName(){\n        return name;\n    }\n    \n    public boolean equals(Horse s){\n        return false;\n    }\n    \n}','Collections',0,1,NULL,5),(239,'Will not compile, if the untyped version of Comparable is used then\nthe parameter to compareTo would be Object\n\neither change to Comparable<Horse>\n\nor \n\ncomparTo(Object o) and cast.\n\notherwise, the answer would be 2 remember arrays aren\'t sorted even though\nyour using comparable the elements of an array dont get sorted so the positions are \nwhat index they were defined as !\n\nThis would give undefined results','public class Hello {\n    public static void main(String[] dicks){\n        Horse[] stable = {new Horse(\"Johny\"), new Horse(\"wilfred\"), new Horse(\"Marco\"), new Horse(\"MAx\"), new Horse(\"Billy\") };\n        int x = Arrays.binarySearch(stable,new Horse(\"Marco\"));\n        System.out.println(x);  \n    }\n}\n\nclass Horse implements Comparable{\n    String name;\n    public Horse(String x){\n        name = x;\n    }\n    public String getName(){\n        return name;\n    }\n    public boolean equals(Horse s){\n        return false;\n    }\n    public int compareTo(Horse h){\n        return name.compareTo(h.getName());  \n    }\n}\n','Collections',0,1,NULL,5),(240,'binarySearch()\n\nreturns the int index of the element being searched.\n\nUnsuccesful searches return an int index that represents the\n insertion point. \n\nThe collection or array must be sorted before you can search it.\n\nif you attempt to search an unsorted array or collection the results of the\nsearch will be unpredictable.\n\nIf it was sorted in natural order it must searched in natural order.\n	do this by NOT sending a Comparator as an argument to the binarySearch() \n\nIf it was sorted with a comparator it must be searched using the same comparator\n\n	\n	','What method is used to search through Arrays and Collections','Collections',0,1,NULL,5),(241,'will not compile, need to cast\n\nreturn name.compareTo(((Horse)h).getName());\n\ndoes not compile because h is an Object and Objects dont have a method\ncalled getName. \n\nyou would cast h to a horse. \n\nObject is the right argument type here though because Comparable is a raw type\nif it were Comparable<Horse> the argument would need to be Horse.','class Horse implements Comparable{\n    String name;\n    \n    public Horse(String x){\n        name = x;\n    }\n    \n    public String getName(){\n        return name;\n    }\n    \n    public boolean equals(Horse s){\n        return false;\n    }\n    \n    public int compareTo(Object h){\n        return name.compareTo(h.getName());\n  \n    }','Collections',0,1,NULL,5),(242,'these all compile fine, \n\nPolymorphism works with Arrays. ','public class Hello {\n    public static void main(String[] dicks){\n       Animal[] beavers = new Beaver[5];\n       \n       Animal[] animals = {new Beaver(), new Beaver(), new Beaver() };\n       \n       Animal[] ans2 = new Animal[5];\n       ans2[0] = new Beaver();\n\n    }\n}\n\nclass Animal{\n    public Animal(){\n        \n    }\n    \n    public String getName(){\n        return \"d\";\n    }\n}\n\nclass Beaver extends Animal{\n    \n}','Collections',0,1,NULL,5),(243,'2\n0','public class Hello {\n    public static void main(String[] dicks){\n       \n        String[] strings = {\"One\",\"Dice\",\"Angela\",\"Bisesi\",\"Franko\"};\n        \n        Arrays.sort(strings);\n        int x = Arrays.binarySearch(strings,\"Dice\");\n        System.out.println(x);  \n        \n        Arrays.sort(strings);\n        \n        System.out.println(Arrays.binarySearch(strings,\"Angela\"));\n    }\n\n}','Collections',0,1,NULL,5),(244,'compare must be public, will not compile','class sortBySecondLetter implements Comparator<String> {\n    int compare(String one, String two){\n        \n    }\n}','Collections',0,1,NULL,5),(245,'will not compile, char is a primitive so charone cannot be dereferenced here\nchange to Character.','class sortBySecondLetter implements Comparator<String> {\n    public int compare(String one, String two){\n        char charone = one.charAt(1);\n        char chartwo = two.charAt(1);\n        \n        return charone.compareTo(chartwo);\n    }\n}','Collections',0,1,NULL,5),(246,'[Ljava.lang.String;@15db9742\n\narrays are not classes','public class Hello {\n    public static void main(String[] dicks){\n        sortBySecondLetter sbsl = new sortBySecondLetter();\n        String[] strings = {\"One\",\"Dice\",\"Angela\",\"Bisesi\",\"Franko\"};\n        \n        Arrays.sort(strings,sbsl);\n        \n        System.out.println(strings);\n    }\n\n}','Collections',0,1,NULL,5),(247,'size 4\nidx2 three\none \nfive \nthree \nsix \ns1[1] five','String[] sa = {\"one\", \"two\", \"three\", \"four\" };\nList sList = Arrays.asList(sa);\n\nSout( \"size \" + sList.size() );\nsout( \"idx2 \" + sList.get(2) );\n\nsList.set(3,\"six\" );\nsa[1] = \"five\";\n\nfor(String s : sa ){\n	sout( s + \" \");\n}\nsout(\"\\n s1[1] \" + sList.get(1) );','Collections',0,1,NULL,5),(248,'UnsupportedOperationException\n\nThis UnsupportedOperationException comes when you try to perform some operation on collection where its not \nallowed and in your case, When you call Arrays.asList it \ndoes not return a java.util.ArrayList. It returns a java.util.Arrays$ArrayList which is an immutable list. \nYou cannot add to it and you cannot remove from it.\n\nReturns a {@code List} of the objects in the specified array. The size of the {@code List} cannot be modified, i.e. adding and removing are unsupported, but the elements can be set. Setting an element modifies the underlying array.\n\nEDIT\n\nThe type of the resulting list is Arrays.ArrayList, which is a private class inside Arrays.class. Practically speaking,\nit is nothing but a List-view on the array that you\'ve passed with Arrays.asList. With a consequence: if you change the array, the list is changed too. And because an array is not resizeable, \nremove and add operation must be unsupported.\n','public class Hello {\n    public static void main(String[] args){\n        String[] sa = {\"one\", \"two\", \"three\", \"four\" };\n        List sList = Arrays.asList(sa);\n\n        System.out.println( \"size \" + sList.size() );\n        System.out.println( \"idx2 \" + sList.get(2) );\n\n        sList.set(3,\"six\" );\n        sa[1] = \"five\";\n\n        for(String s : sa ){\n            System.out.println( s + \" \");\n        }\n        System.out.println(\"s1[1] \" + sList.get(1) );\n        \n        sList.remove(\"five\");\n        for(String s : sa)\n            System.out.println(s+\" \");\n    }\n\n}','Collections',0,1,NULL,5),(249,'size 4\nidx2 three\none \nfive \nthree \nsix \ns1[1] five\none \nFIVE \nthree \nSIX\n\nThis shows that Arrays and Lists coming from\nArrays.asList() are \"joined at the hip\" changes in one affect \nthe other. This is different from a \"Backed Collection\". Because \nBacked Collections dont go both ways and are only backed for a certain range.','String[] sa = {\"one\", \"two\", \"three\", \"four\" };\n        List sList = Arrays.asList(sa);\n\n        System.out.println( \"size \" + sList.size() );\n        System.out.println( \"idx2 \" + sList.get(2) );\n\n        sList.set(3,\"six\" );\n        sa[1] = \"five\";\n\n        for(String s : sa ){\n            System.out.println( s + \" \");\n        }\n        System.out.println(\"s1[1] \" + sList.get(1) );\n        \n        sList.set(1, \"FIVE\");\n	sList.set(3,\"SIX);\n        for(String s : sa)\n            System.out.println(s+\" \");','Collections',0,1,NULL,5),(250,'unsupported operation exception, \n\nList returned by asList is fixed size can only be updated not added to or removed from','public static void main(String[] dicks){\n        String[] sa = {\"one\", \"two\", \"three\", \"four\" };\n        List sList = Arrays.asList(sa);\n\n        System.out.println( \"size \" + sList.size() );\n        System.out.println( \"idx2 \" + sList.get(2) );\n\n        sList.set(3,\"six\" );\n        sa[1] = \"five\";\n\n        for(String s : sa ){\n            System.out.println( s + \" \");\n        }\n        System.out.println(\"s1[1] \" + sList.get(1) );\n        \n        sList.set(1, \"FIVE\");\n        sList.set(3,\"SIX\");\n        sList.add(\"SEVEN\");\n        for(String s : sa)\n            System.out.println(s+\" \");','Collections',0,1,NULL,5),(251,'will not compile, toArray( T[] a) will return an array of the type you send\nto it. so here an Object[] cannot be assigned to an Integer[].\n\nto fix:\n	change oa to ia2 which will cause toArray to return an Integer[]',' public static void main(String[] dicks){\n        List<Integer> iL = new ArrayList<Integer>();\n        for(int x=0; x<3; x++){\n                iL.add(x);\n        }\n        Object[] oa = iL.toArray();\n        Integer[] ia2 = new Integer[3];\n        ia2 = iL.toArray(oa);\n    }','Collections',0,1,NULL,5),(252,'0\n1\n2\n3\n4\n','public static void main(String[] dicks){\n        List<Integer> iL = new ArrayList<Integer>();\n        for(int x=0; x<5; x++){\n                iL.add(x);\n        }\n        Object[] oa = iL.toArray();\n        Integer[] ia2 = new Integer[3];\n        ia2 = iL.toArray(ia2);\n        \n        for(Integer i : ia2){\n            System.out.println(i);\n        }     \n    }','Collections',0,1,NULL,5),(253,'0\n1\n2\n3\n4\n0\n1\n2\n3\n4','public static void main(String[] dicks){\n        List<Integer> iL = new ArrayList<Integer>();\n        for(int x=0; x<5; x++){\n                iL.add(x);\n        }\n        Object[] oa = iL.toArray();\n        Integer[] ia2 = new Integer[3];\n        ia2 = iL.toArray(ia2);\n        \n        for(Integer i : ia2){\n            System.out.println(i);\n        }\n        \n        iL.add(100);\n        \n        for(Integer i : ia2)\n            System.out.println(i);\n       \n    }','Collections',0,1,NULL,5),(254,'will not compile, \n\n.toArray() returns an Object[]',' public static void main(String[] dicks){\n        List<Integer> iL = new ArrayList<Integer>();\n        for(int x=0; x<5; x++){\n                iL.add(x);\n        }\n        Integer[] oa = iL.toArray();     \n    }','Collections',0,1,NULL,5),(255,'unpredictable result, the array is not sorted before being searched. ','class HDTV implements Comparable<HDTV> {\n	private int size;\n	private String brand;\n        private int resolution;\n \n	public HDTV(int size, String brand, int res) {\n		this.size = size;\n		this.brand = brand;\n                this.resolution = res;\n	}\n \n	public int getSize() {\n		return size;\n	}\n        \n        public int getRes() {\n            return resolution;\n        }\n \n	public void setSize(int size) {\n		this.size = size;\n	}\n \n	public String getBrand() {\n		return brand;\n	}\n \n	public void setBrand(String brand) {\n		this.brand = brand;\n	}\n \n	@Override\n	public int compareTo(HDTV tv) {\n \n		if (this.getSize() > tv.getSize())\n			return 1;\n		else if (this.getSize() < tv.getSize())\n			return -1;\n		else\n			return 0;\n	}\n        \n        public String toString(){\n            return brand;\n        }\n}\n\npublic class Hello {\n    public static void main(String[] dicks){\n        compareTVs();\n    }\n    \n     \n    public static void compareTVs() {\n		HDTV tv1 = new HDTV(55, \"Samsung\", 6000);\n		HDTV tv2 = new HDTV(60, \"Sony\", 4500);\n                HDTV tv3 = new HDTV(70, \"MEGATV\", 10000);\n                HDTV tv4 = new HDTV(15,\"kitchenette\", 600);\n\n                HDTV[] array = {tv2, tv1, tv3, tv4 };\n                \n                System.out.println(Arrays.binarySearch(array,new HDTV(700,\"Samsung\",400)));\n                \n	}\n\n}','Collections',0,1,NULL,5),(256,'will not compile \n\nArrayList.addAll doesn\'t work like that, it takes another collection\nthen adds all the elements from one to another. ','public static void main(String[] dicks){\n        List<HDTV> tvs = new ArrayList<>();\n        HDTV tv1 = new HDTV(55, \"Samsung\", 6000);\n        HDTV tv2 = new HDTV(60, \"Sony\", 4500);\n        HDTV tv3 = new HDTV(70, \"MEGATV\", 10000);\n        HDTV tv4 = new HDTV(15,\"kitchenette\", 600);\n        tvs.addAll(tv1,tv2,tv3,tv4);\n    }','Collections',0,1,NULL,5),(257,'Samsung\nSony\nMEGATV\nkitchenette\n\nthis shows proper use of an iterator','public static void main(String[] dicks){\n        List<HDTV> tvs = new ArrayList<>();\n        \n        HDTV tv1 = new HDTV(55, \"Samsung\", 6000);\n        HDTV tv2 = new HDTV(60, \"Sony\", 4500);\n        HDTV tv3 = new HDTV(70, \"MEGATV\", 10000);\n        HDTV tv4 = new HDTV(15,\"kitchenette\", 600);\n        \n        tvs.add(tv1);\n        tvs.add(tv2);\n        tvs.add(tv3);\n        tvs.add(tv4);\n        \n        Iterator<HDTV> i3 = tvs.iterator();\n        \n        while(i3.hasNext()){\n            HDTV t3 = i3.next();\n            System.out.println(t3.getBrand());\n        }\n        \n        \n    }','Collections',0,0,NULL,5),(258,'If the iterator isn\'t typed then the elements returned by Iterator will be \nObjects so to make this compile, \n\nyou would have to cast\n\n	(HDTV) i3.next();','public static void main(String[] dicks){\n        List<HDTV> tvs = new ArrayList<>();\n        \n        HDTV tv1 = new HDTV(55, \"Samsung\", 6000);\n        HDTV tv2 = new HDTV(60, \"Sony\", 4500);\n        HDTV tv3 = new HDTV(70, \"MEGATV\", 10000);\n        HDTV tv4 = new HDTV(15,\"kitchenette\", 600);\n        \n        tvs.add(tv1);\n        tvs.add(tv2);\n        tvs.add(tv3);\n        tvs.add(tv4);\n        \n        Iterator i3 = tvs.iterator();\n        \n        while(i3.hasNext()){\n            HDTV t3 = i3.next();\n            System.out.println(t3.getBrand());\n        }\n        \n        \n    }','Collections',0,0,NULL,5),(259,'none fail both of those are fine. ','  public static void main(String[] dicks){\n        List<HDTV> tvs = new ArrayList<>();\n        \n        HDTV tv1 = new HDTV(55, \"Samsung\", 6000);\n        HDTV tv2 = new HDTV(60, \"Sony\", 4500);\n        HDTV tv3 = new HDTV(70, \"MEGATV\", 10000);\n        HDTV tv4 = new HDTV(15,\"kitchenette\", 600);\n        \n        tvs.add(tv1);\n        tvs.add(tv2);\n        tvs.add(tv3);\n        tvs.add(tv4);\n        \n        HDTV[] tv = new HDTV[5];\n        HDTV[] hv = tvs.toArray(tv); //line 1\n        Object[] tvobjs = tvs.toArray(); //line 2\n        \n   \n    }\n\nwhich line would fail if any ?','Collections',0,0,NULL,5),(260,'true\ntrue\ntrue\ntrue\nfalse\n4\n5\n7\n9\n\nSets dont allow duplicates and the iteration order is not predictable','public static void main(String[] dicks){\n      Set s = new HashSet();\n      \n        System.out.println(s.add(4));\n        System.out.println(s.add(9));\n        System.out.println(s.add(5));\n        System.out.println(s.add(\"7\"));\n        System.out.println(s.add(4));\n        \n        for(Object o : s)\n            System.out.println(o);\n\n    }','Collections',0,0,NULL,5),(261,'ClassCastException\n \nTreeSets are sorted and all these elements aren\'t mutually comparabble','public static void main(String[] dicks){\n      Set s = new TreeSet();\n      \n        System.out.println(s.add(4));\n        System.out.println(s.add(9));\n        System.out.println(s.add(5));\n        System.out.println(s.add(\"7\"));\n        System.out.println(s.add(4));\n        \n        for(Object o : s)\n            System.out.println(o);\n\n    }','Collections',0,0,NULL,5),(262,'Charly,\n\nhere strings are used as keys and they override hashcode() and equals()\nso it can be used ','class Dog {\n    public String name;\n    public Dog(String n) { name = n; }\n    \n    public String toString(){\n        return name;\n    }\n}\n\npublic class Hello {\n\n    public static void main(String[] dicks){\n      Map<Object,Object> map = new HashMap<>();\n      \n      map.put(\"d1\",new Dog(\"Charly\"));\n      map.put(\"d2\", new Dog(\"dumbfuck\"));\n      \n        System.out.println(map.get(\"d1\"));\n    }\n}','Collections',0,0,NULL,5),(263,'null \n\nthe map cannot find the values bcause the keys dont have equals or hashcode methods.','class Dog {\n    public String name;\n    public Dog(String n) { name = n; }\n    \n    public String toString(){\n        return name;\n    }\n\n    public static void main(String[] dicks){\n      Map<Object,Object> map = new HashMap<>();\n      \n      map.put(new Dog(\"Bell\"),\"Big brown lab\");\n      map.put(new Dog(\"Sable\"), \"small schiperkee\");\n      \n        System.out.println(map.get(new Dog(\"Bell\")));\n    }\n\n}\n\n','Collections',0,0,NULL,5),(264,'null\ncatdog\nDOG','class Dog {\n    enum Pets{DOG, CAT, SNAKE};\n    public String name;\n    public Dog(String n) { name = n; }\n    \n    public String toString(){\n        return name;\n    }\n\npublic static void main(String[] dicks){\n      \n      Map<Object,Object> map = new HashMap<>();\n      \n      map.put(new Dog(\"Bell\"),\"Big brown lab\");\n      map.put(new Dog(\"Sable\"), \"small schiperkee\");\n      map.put(Pets.CAT, new Dog(\"catdog\"));\n      map.put(\"Dog\", Pets.DOG);\n      \n        System.out.println(map.get(new Dog(\"Bell\")));\n        System.out.println(map.get(Pets.CAT));\n        System.out.println(map.get(\"Dog\"));\n    }\n}','Collections',0,0,NULL,5),(265,'both are legal, the first will be slightly better\n\nthe more unique a hashcode the faste retrieval will be. ','public int hashCode() { return name.length(); }\npublic int hashCode() { return 4; }\n \nwhich will be faster ?\n','Collections',0,0,NULL,5),(266,'12\n34\n45\n63','TreeSet<Integer> tree = new TreeSet<Integer>();\ntree.add(12);\ntree.add(63);\ntree.add(34);\ntree.add(45);\n \nIterator<Integer> iterator = tree.iterator();\nSystem.out.print(\"Tree set data: \");\nwhile (iterator.hasNext()) {\n    System.out.print(iterator.next() + \" \");\n}','Collections',0,0,NULL,5),(267,'[1.8, 2.3, 2.2, 4.6, 8.9]\n-5\n\nthis comparator sorts in ascending order uless they have the same integer\nvalue','public class Hello {\n    \n    \n    public static void main(String[] dicks){\n      \n      List<Double> grades = new ArrayList<>();\n      grades.addAll(Arrays.asList( new Double[]{ 1.8, 4.6, 2.3, 8.9, 2.2 } ));\n      \n      Collections.sort(grades,new CusSort());\n      \n      System.out.println(grades);\n      \n        System.out.println(Collections.binarySearch(grades,4.2,new CusSort()));\n\n    }\n}\n    \n   class CusSort implements Comparator<Double> {\n       public int compare(Double d1, Double d2){\n           return d1.intValue() == d2.intValue() ? d2.compareTo(d1) : d1.compareTo(d2);\n           \n       }\n   }','Collections',0,0,NULL,5),(268,'{a=ant, b=buffalo, h=horse} {b=buffalo}\n{R=raccoon, a=ant, b=bat, f=fish, h=horse} {b=bat, f=fish}','public class Hello {\n    \n    \n    public static void main(String[] dicks){\n      \n     TreeMap<String, String> map = new TreeMap<>();\n     map.put(\"a\",\"ant\"); map.put(\"b\",\"buffalo\"); map.put(\"h\",\"horse\");\n     \n     SortedMap<String, String> submap;\n     submap = map.subMap(\"b\",\"g\");\n     \n        System.out.println(map+\" \"+submap);\n        \n        map.put(\"b\",\"bat\");\n        \n        submap.put(\"f\",\"fish\");\n        \n        map.put(\"R\", \"raccoon\");\n        // submap.put(\"p\",\"pig\");\n        \n        System.out.println(map+\" \"+submap);\n    }\n}','Collections',0,0,NULL,5),(269,'IllegalArgumnetException\n\np is out of range of the submap as first established with subMap(b g);\n\n','public class Hello {\n    \n    \n    public static void main(String[] dicks){\n      \n     TreeMap<String, String> map = new TreeMap<>();\n     map.put(\"a\",\"ant\"); map.put(\"b\",\"buffalo\"); map.put(\"h\",\"horse\");\n     \n     SortedMap<String, String> submap;\n     submap = map.subMap(\"b\",\"g\");\n     \n        System.out.println(map+\" \"+submap);\n        \n        map.put(\"b\",\"bat\");\n        \n        submap.put(\"f\",\"fish\");\n        \n        map.put(\"R\", \"raccoon\");\n        submap.put(\"p\",\"pig\");\n        \n        System.out.println(map+\" \"+submap);\n    }\n}','Collections',0,0,NULL,5),(270,'will not compile, submap returns a SortedMap.','public class Hello {\n    \n    \n    public static void main(String[] dicks){\n      \n     TreeMap<String, String> map = new TreeMap<>();\n     map.put(\"a\",\"ant\"); map.put(\"b\",\"buffalo\"); map.put(\"h\",\"horse\"); map.put(\"j\",\"jackle\");\n     \n     TreeMap<String, String> submap;\n     submap = map.subMap(\"b\",\"g\");\n     \n     System.out.println(map+\" \"+submap);\n\n    }\n}','Collections',0,0,NULL,5),(271,'AbstractMap<k,V>\nNavigableMap<K,V>','class TreeMap<k,v> extends  _____________\n implements  ____________','Collections',0,0,NULL,5),(272,'{Beee=9, Ant=6, muskrat=20, Dog=7}\n\nwithout a provided comparator TreeMap sorts using Animals comparable\n\nwhich is to rank by size','public class Hello {\n    \n    \n    public static void main(String[] dicks){\n      \n     TreeMap<Animal, Integer> map = new TreeMap<>();\n     \n     map.put(new Animal(5,\"Ant\"), 6); map.put(new Animal(3,\"Beee\"),9); map.put(new Animal(25,\"Dog\"),7); map.put(new Animal(20,\"muskrat\"),20);\n     \n     System.out.println(map);\n     \n \n\n    }\n}\n\nclass sortAnimalsAlphabetically implements Comparator<Animal> {\n\n    @Override\n    public int compare(Animal o1, Animal o2) {\n        return o1.getName().compareTo(o2.getName());\n    }\n    \n}\n\nclass Animal implements Comparable<Animal> {\n    private Integer size;\n    private String name;\n    \n    public Animal(int x, String y){\n        size = x;\n        name = y;\n    }\n\n    public int getSize() {\n        return size;\n    }\n\n    public String getName() {\n        return name;\n    }\n    public int compareTo(Animal o){\n        return size.compareTo(o.getSize());\n        \n    }\n    \n    public String toString(){\n        return name;\n    }\n}','Collections',0,0,NULL,5),(273,'{Ant=6, Beee=9, Dog=7, muskrat=20}\n\nsort using comparator','public class Hello {\n    \n    \n    public static void main(String[] dicks){\n      \n     TreeMap<Animal, Integer> map = new TreeMap<>(new sortAnimalsAlphabetically());\n     \n     map.put(new Animal(5,\"Ant\"), 6); map.put(new Animal(3,\"Beee\"),9); map.put(new Animal(25,\"Dog\"),7); map.put(new Animal(20,\"muskrat\"),20);\n     \n     System.out.println(map);\n     \n \n\n    }\n}\n\nclass sortAnimalsAlphabetically implements Comparator<Animal> {\n\n    @Override\n    public int compare(Animal o1, Animal o2) {\n        return o1.getName().compareTo(o2.getName());\n    }\n    \n}\n\nclass Animal implements Comparable<Animal> {\n    private Integer size;\n    private String name;\n    \n    public Animal(int x, String y){\n        size = x;\n        name = y;\n    }\n\n    public int getSize() {\n        return size;\n    }\n\n    public String getName() {\n        return name;\n    }\n    public int compareTo(Animal o){\n        return size.compareTo(o.getSize());\n        \n    }\n    \n    public String toString(){\n        return name;\n    }\n}','Collections',0,0,NULL,5),(274,'IllegalArgumentException key out of range\n\nyour trying to add a rhino - 50 - to the copied map when the biggest element\nin the orgiinal was a Dog at 15 !','public class Hello {\n    \n    \n    public static void main(String[] dicks){\n      \n     TreeMap<Animal, Integer> map = new TreeMap<>();\n     \n     map.put(new Animal(2,\"Ant\"), 6); map.put(new Animal(3,\"Beee\"),9); map.put(new Animal(15,\"Dog\"),7); map.put(new Animal(12,\"muskrat\"),20);\n     \n     SortedMap<Animal,Integer> copymap = map.subMap(map.firstKey(), map.lastKey());\n     \n     copymap.put(new Animal(50,\"Rhino\"), 1);\n     map.put(new Animal(30,\"Wolf\"), 4);\n     System.out.println(map);\n     \n     SortedMap<Animal,Integer> copy1map = copymap.subMap(new Animal(4,\"Worm\"), new Animal(25,\"Dolphin\"));\n     \n     System.out.println(copy1map);\n\n    }\n}\n\nclass sortAnimalsAlphabetically implements Comparator<Animal> {\n\n    @Override\n    public int compare(Animal o1, Animal o2) {\n        return o1.getName().compareTo(o2.getName());\n    }\n    \n}\n\nclass Animal implements Comparable<Animal> {\n    private Integer size;\n    private String name;\n    \n    public Animal(int x, String y){\n        size = x;\n        name = y;\n    }\n\n    public int getSize() {\n        return size;\n    }\n\n    public String getName() {\n        return name;\n    }\n    public int compareTo(Animal o){\n        return size.compareTo(o.getSize());\n        \n    }\n    \n    public String toString(){\n        return name;\n    }\n}','Collections',0,0,NULL,5),(275,'IllegalArgumentException, fromKey out of range\n\nthe tic your trying to add is too small previously the smallest elemtn was\nan Ant at 2','public class Hello {\n    \n    \n    public static void main(String[] dicks){\n      \n     TreeMap<Animal, Integer> map = new TreeMap<>();\n     \n     map.put(new Animal(2,\"Ant\"), 6); map.put(new Animal(3,\"Beee\"),9); map.put(new Animal(15,\"Dog\"),7); map.put(new Animal(12,\"muskrat\"),20);\n     \n     SortedMap<Animal,Integer> copymap = map.subMap(map.firstKey(), map.lastKey());\n     \n     map.put(new Animal(50,\"Rhino\"), 1);\n     map.put(new Animal(30,\"Wolf\"), 4);\n     System.out.println(map);\n     \n     SortedMap<Animal,Integer> copy1map = copymap.subMap(new Animal(1,\"Tic\"), new Animal(25,\"Dolphin\"));\n     \n     //System.out.println(copy1map);\n\n    }\n}\n\nclass sortAnimalsAlphabetically implements Comparator<Animal> {\n\n    @Override\n    public int compare(Animal o1, Animal o2) {\n        return o1.getName().compareTo(o2.getName());\n    }\n    \n}\n\nclass Animal implements Comparable<Animal> {\n    private Integer size;\n    private String name;\n    \n    public Animal(int x, String y){\n        size = x;\n        name = y;\n    }\n\n    public int getSize() {\n        return size;\n    }\n\n    public String getName() {\n        return name;\n    }\n    public int compareTo(Animal o){\n        return size.compareTo(o.getSize());\n        \n    }\n    \n    public String toString(){\n        return name;\n    }\n}\n','Collections',0,0,NULL,5),(276,'{Ant=6, Beee=9, muskrat=20, Dog=7}\n{Ant=6, Beee=9, muskrat=20}\n{Ant=6, Beee=9, muskrat=20, Dog=7, Wolf=4, Rhino=1}\n{Ant=6, Beee=9, muskrat=20, Dog=7, Wolf=4}\n\npublic SortedMap<K,V> subMap(K fromKey,\n                    K toKey)\n\nkeys range from fromKey, inclusive, to toKey, exclusive. (If fromKey and toKey are equal, the returned map is empty.)\n The returned map is backed by this map, so changes \nin the returned map are reflected in this map, and vice-versa.\n\nTHE TO KEY IS EXCLUSIVE ','public class Hello {\n    \n    \n    public static void main(String[] dicks){\n      \n     TreeMap<Animal, Integer> map = new TreeMap<>();\n     \n     map.put(new Animal(2,\"Ant\"), 6); map.put(new Animal(3,\"Beee\"),9); map.put(new Animal(15,\"Dog\"),7); map.put(new Animal(12,\"muskrat\"),20);\n     \n     SortedMap<Animal,Integer> copymap = map.subMap(map.firstKey(), map.lastKey());\n        System.out.println(map);\n        System.out.println(copymap);\n     \n     map.put(new Animal(50,\"Rhino\"), 1);\n     map.put(new Animal(30,\"Wolf\"), 4);\n     System.out.println(map);\n     \n     copymap = map.subMap(map.firstKey(), map.lastKey());\n     \n        System.out.println(copymap);\n     \n     //SortedMap<Animal,Integer> copy1map = copymap.subMap(new Animal(7,\"Snake\"), new Animal(40,\"Bear\"));\n     //System.out.println(copy1map);\n\n    }\n}','Collections',0,0,NULL,5),(277,'{Ant=6, Beee=9, muskrat=20, Dog=7}\n{Ant=6, Beee=9, muskrat=20, Dog=7}\n\noverloaded version of submap indicates if that arg is inclusive \n\nThe map is sorted according to the natural ordering of its keys, or by a Comparator provided at map creation time\nNote that the ordering maintained by a tree map, like any sorted map, and whether or not an explicit comparator is provided, \nmust be consistent with equals if this sorted map is to correctly implement the Map interface. (See Comparable or Comparator for a precise definition of consistent with equals.) \nThis is so because the Map interface is defined in terms of the equals operation, but a sorted map performs all key comparisons using its compareTo (or compare) method, so two keys that are deemed equal by this method are, \nfrom the standpoint of the sorted map, equal.  ','public class Hello {\n  public static void main(String[] dicks){\n      \n     TreeMap<Animal, Integer> map = new TreeMap<>();\n     \n     map.put(new Animal(2,\"Ant\"), 6); map.put(new Animal(3,\"Beee\"),9); map.put(new Animal(15,\"Dog\"),7); map.put(new Animal(12,\"muskrat\"),20);\n     \n     SortedMap<Animal,Integer> copymap = map.subMap(map.firstKey(),true, map.lastKey(),true);\n        System.out.println(map);\n        System.out.println(copymap);\n    }\n}\n\nclass Animal implements Comparable<Animal>{\n    private int size;\n    private String name;\n    public Animal(int s, String n){\n        size = s;\n        name = n;\n        \n    }\n    public int getSize(){\n        return size;\n    }\n    public int compareTo(Animal a){\n        int asize = a.getSize();\n        int bsize = this.size;\n        \n        if(asize < bsize)\n            return 1;\n        else if(asize == bsize)\n            return 0;\n        else\n            return -1;\n  \n    }\n    \n    public String toString(){\n        return name;\n    }\n}','Collections',0,0,NULL,5),(278,'{Ant=6, Beee=9, muskrat=20, Dog=7}\n{Beee=9, muskrat=20, Dog=7}','public class Hello {\n    \n    \n    public static void main(String[] dicks){\n      \n     TreeMap<Animal, Integer> map = new TreeMap<>();\n     \n     map.put(new Animal(2,\"Ant\"), 6); map.put(new Animal(3,\"Beee\"),9); map.put(new Animal(15,\"Dog\"),7); map.put(new Animal(12,\"muskrat\"),20);\n     \n     SortedMap<Animal,Integer> copymap = map.subMap(map.firstKey(),false, map.lastKey(),true);\n        System.out.println(map);\n        System.out.println(copymap);\n    }\n}','Collections',0,0,NULL,5),(279,'{Ant=6, Beee=9, muskrat=20, Dog=7}\n{Beee=9, muskrat=20}','public class Hello {\n    \n    \n    public static void main(String[] dicks){\n      \n     TreeMap<Animal, Integer> map = new TreeMap<>();\n     \n     map.put(new Animal(2,\"Ant\"), 6); map.put(new Animal(3,\"Beee\"),9); map.put(new Animal(15,\"Dog\"),7); map.put(new Animal(12,\"muskrat\"),20);\n     \n     SortedMap<Animal,Integer> copymap = map.subMap(map.firstKey(),false, map.lastKey(),false);\n        System.out.println(map);\n        System.out.println(copymap);\n    }\n}','Collections',0,0,NULL,5),(280,'{Ant=6, Beee=9, muskrat=20, Dog=7}\n{Ant=6, Beee=9, muskrat=20, Dog=7}\n{Ant=6, Beee=9, muskrat=20, Dog=7, Wolf=1, Giant sloth=6}\n{Ant=6, Beee=9, muskrat=20, Dog=7}\n\nIf new elements are added to the orginal map that are out of the range\nof the submap then they are not copied over to the sub.\n\nThat submap only exist within the range it was defined. ','public class Hello {\n    \n    \n    public static void main(String[] dicks){\n      \n     TreeMap<Animal, Integer> map = new TreeMap<>();\n     \n     map.put(new Animal(2,\"Ant\"), 6); map.put(new Animal(3,\"Beee\"),9); map.put(new Animal(15,\"Dog\"),7); map.put(new Animal(12,\"muskrat\"),20);\n     \n     SortedMap<Animal,Integer> copymap = map.subMap(map.firstKey(),true, map.lastKey(),true);\n     \n        System.out.println(map);\n        System.out.println(copymap);\n     map.put(new Animal(25,\"Wolf\"), 1);\n     //copymap.put(new Animal(22,\"Lynx\"), 0);\n     map.put(new Animal(33,\"Giant sloth\"), 6);\n     //copymap.put(new Animal(30,\"Comodo\"),5);\n     \n        System.out.println(map);\n        System.out.println(copymap);        \n    }\n}','Collections',0,0,NULL,5),(281,'{Ant=6, Beee=9, muskrat=20, Dog=7}\n{Ant=6, Beee=9, muskrat=20, Dog=7}\n{Ant=6, Beee=9, Fat Cat=0, muskrat=20, Dog=7, Wolf=1, Giant sloth=6}\n{Ant=6, Beee=9, Fat Cat=0, muskrat=20, Dog=7}','public class Hello {\n    \n    \n    public static void main(String[] dicks){\n      \n     TreeMap<Animal, Integer> map = new TreeMap<>();\n     \n     map.put(new Animal(2,\"Ant\"), 6); map.put(new Animal(3,\"Beee\"),9); map.put(new Animal(15,\"Dog\"),7); map.put(new Animal(12,\"muskrat\"),20);\n     \n     SortedMap<Animal,Integer> copymap = map.subMap(map.firstKey(),true, map.lastKey(),true);\n     \n        System.out.println(map);\n        System.out.println(copymap);\n     map.put(new Animal(25,\"Wolf\"), 1);\n     copymap.put(new Animal(10,\"Fat Cat\"), 0);\n     map.put(new Animal(33,\"Giant sloth\"), 6);\n     \n        System.out.println(map);\n        System.out.println(copymap);\n    }\n}','Collections',0,0,NULL,5),(282,'{Ant=6, Beee=9, chipmunk=4, muskrat=20, Dog=7, Wolf=1, Giant sloth=6, Leapord=2, Cave Dweller=1}\n{Ant=6, Beee=9, chipmunk=4, muskrat=20, Dog=7, Wolf=1, Giant sloth=6}','public class Hello {\n    \n    \n    public static void main(String[] dicks){\n      \n     TreeMap<Animal, Integer> map = new TreeMap<>();\n     \n     map.put(new Animal(2,\"Ant\"), 6); map.put(new Animal(3,\"Beee\"),9); map.put(new Animal(15,\"Dog\"),7); map.put(new Animal(12,\"muskrat\"),20);\n     map.put(new Animal(25,\"Wolf\"), 1); map.put(new Animal(33,\"Giant sloth\"), 6);\n     map.put(new Animal(35,\"Leapord\"),2); map.put(new Animal(9,\"chipmunk\"),4); map.put(new Animal(46,\"Cave Dweller\"),1);\n     \n        System.out.println(map);\n        \n     SortedMap<Animal,Integer> headmap = map.headMap(new Animal(35,\"Leapord\"));\n     \n        System.out.println(headmap);\n   \n    }\n}','Collections',0,0,NULL,5),(283,'{Ant=6, Beee=9, chipmunk=4, muskrat=20, Dog=7, Wolf=1, Giant sloth=6, Leapord=2, Cave Dweller=1}\n{Ant=6, Beee=9, chipmunk=4, muskrat=20, Dog=7, Wolf=1, Giant sloth=6, Leapord=2}','public class Hello {\n    \n    \n    public static void main(String[] dicks){\n      \n     TreeMap<Animal, Integer> map = new TreeMap<>();\n     \n     map.put(new Animal(2,\"Ant\"), 6); map.put(new Animal(3,\"Beee\"),9); map.put(new Animal(15,\"Dog\"),7); map.put(new Animal(12,\"muskrat\"),20);\n     map.put(new Animal(25,\"Wolf\"), 1); map.put(new Animal(33,\"Giant sloth\"), 6);\n     map.put(new Animal(35,\"Leapord\"),2); map.put(new Animal(9,\"chipmunk\"),4); map.put(new Animal(46,\"Cave Dweller\"),1);\n     \n        System.out.println(map);\n        \n     SortedMap<Animal,Integer> headmap = map.headMap(new Animal(35,\"Leapord\"),true);\n     \n        System.out.println(headmap);\n   \n    }\n}','Collections',0,0,NULL,5),(284,'{Ant=6, Beee=9, chipmunk=4, muskrat=20, Dog=7, Wolf=1, Giant sloth=6, Leapord=2, Cave Dweller=1}\n{Ant=6, Beee=9, chipmunk=4, muskrat=20, Dog=7, Wolf=1, Giant sloth=6, Leapord=2}','public class Hello {\n    \n    \n    public static void main(String[] dicks){\n      \n     TreeMap<Animal, Integer> map = new TreeMap<>();\n     \n     map.put(new Animal(2,\"Ant\"), 6); map.put(new Animal(3,\"Beee\"),9); map.put(new Animal(15,\"Dog\"),7); map.put(new Animal(12,\"muskrat\"),20);\n     map.put(new Animal(25,\"Wolf\"), 1); map.put(new Animal(33,\"Giant sloth\"), 6);\n     map.put(new Animal(35,\"Leapord\"),2); map.put(new Animal(9,\"chipmunk\"),4); map.put(new Animal(46,\"Cave Dweller\"),1);\n     \n        System.out.println(map);\n        \n     SortedMap<Animal,Integer> headmap = map.headMap(new Animal(40,\"Python\"),true);\n     \n        System.out.println(headmap);\n   \n    }\n}','Collections',0,0,NULL,5),(285,'{Ant=6, Beee=9, chipmunk=4, muskrat=20, Dog=7, Wolf=1, Giant sloth=6, Leapord=2, Cave Dweller=1}\n{Ant=6, Beee=9, chipmunk=4, muskrat=20, Dog=7, Wolf=1, Giant sloth=6, Leapord=2}','public class Hello {\n    \n    \n    public static void main(String[] dicks){\n      \n     TreeMap<Animal, Integer> map = new TreeMap<>();\n     \n     map.put(new Animal(2,\"Ant\"), 6); map.put(new Animal(3,\"Beee\"),9); map.put(new Animal(15,\"Dog\"),7); map.put(new Animal(12,\"muskrat\"),20);\n     map.put(new Animal(25,\"Wolf\"), 1); map.put(new Animal(33,\"Giant sloth\"), 6);\n     map.put(new Animal(35,\"Leapord\"),2); map.put(new Animal(9,\"chipmunk\"),4); map.put(new Animal(46,\"Cave Dweller\"),1);\n     \n        System.out.println(map);\n        \n     SortedMap<Animal,Integer> headmap = map.headMap(new Animal(40,\"Python\"));\n     \n        System.out.println(headmap);\n   \n    }\n}','Collections',0,0,NULL,5),(286,'IOException caused by flushing a closed Bufferedwriter','try{\n            bw.write(df.format(today));\n            bw.newLine();\n            bw.write(\"Flash Cards \\n\");\n            bw.newLine();\n            \n            for(Card c : cards){\n                bw.write(\"================================================\\n\");\n                bw.write(\"-\"+counter+\"-\\n\");\n                bw.write(\"================================================\\n\");\n                bw.write(c.getCard());\n                bw.newLine();\n                bw.write(\"================================================\\n\");\n                bw.write(c.getAnswer());\n                bw.newLine();\n                bw.write(\"================================================\\n\");\n                counter++;\n            }\n            \n            bw.close();\n	    bw.flush();\n            \n        } catch(IOException e){\n            System.out.println(\"Problem saving cards\");\n            e.printStackTrace(); \n        } ','Collections',0,0,NULL,5),(287,'{Ant=6, Beee=9, chipmunk=4, muskrat=20, Dog=7, Wolf=1, Giant sloth=6, Leapord=2, Cave Dweller=1}\n{Ant=6, Beee=9, chipmunk=4, muskrat=20, Dog=7, Wolf=1, Giant sloth=6, Leapord=2}\n{Ant=6, Beee=9, chipmunk=4, muskrat=20, Dog=7, Wolf=1, Giant sloth=6}','public class Hello {\n    \n    \n    public static void main(String[] dicks){\n      \n     TreeMap<Animal, Integer> map = new TreeMap<>();\n     \n     map.put(new Animal(2,\"Ant\"), 6); map.put(new Animal(3,\"Beee\"),9); map.put(new Animal(15,\"Dog\"),7); map.put(new Animal(12,\"muskrat\"),20);\n     map.put(new Animal(25,\"Wolf\"), 1); map.put(new Animal(33,\"Giant sloth\"), 6);\n     map.put(new Animal(35,\"Leapord\"),2); map.put(new Animal(9,\"chipmunk\"),4); map.put(new Animal(46,\"Cave Dweller\"),1);\n     \n        System.out.println(map);\n        \n     SortedMap<Animal,Integer> headmap = map.headMap(new Animal(40,\"Python\"));\n     \n     System.out.println(headmap);\n        \n     NavigableMap<Animal,Integer> headmapincl = map.headMap(new Animal(34,\"Lynx\"), true);\n     SortedMap<Animal,Integer> headmap_2 = map.headMap(new Animal(30,\"Fox\"), true);\n     \n        System.out.println(headmapincl);\n        \n   \n    }\n}','Collections',0,0,NULL,5),(288,'{Ant=6, Beee=9, chipmunk=4, muskrat=20, Dog=7, Wolf=1, Giant sloth=6, Leapord=2, Cave Dweller=1}\n{Giant sloth=6, Leapord=2, Cave Dweller=1}','public class Hello {\n    \n    \n    public static void main(String[] dicks){\n      \n     TreeMap<Animal, Integer> map = new TreeMap<>();\n     \n     map.put(new Animal(2,\"Ant\"), 6); map.put(new Animal(3,\"Beee\"),9); map.put(new Animal(15,\"Dog\"),7); map.put(new Animal(12,\"muskrat\"),20);\n     map.put(new Animal(25,\"Wolf\"), 1); map.put(new Animal(33,\"Giant sloth\"), 6);\n     map.put(new Animal(35,\"Leapord\"),2); map.put(new Animal(9,\"chipmunk\"),4); map.put(new Animal(46,\"Cave Dweller\"),1);\n     \n        System.out.println(map);\n        \n    SortedMap<Animal,Integer> tailmap = map.tailMap(new Animal(33,\"Giant Sloth\"));\n    \n        System.out.println(tailmap);\n        \n   \n    }\n}','Collections',0,0,NULL,5),(289,'{Ant=6, Beee=9, chipmunk=4, muskrat=20, Dog=7, Wolf=1, Giant sloth=6, Leapord=2, Cave Dweller=1}\n{Leapord=2, Cave Dweller=1}','public class Hello {\n    \n    \n    public static void main(String[] dicks){\n      \n     TreeMap<Animal, Integer> map = new TreeMap<>();\n     \n     map.put(new Animal(2,\"Ant\"), 6); map.put(new Animal(3,\"Beee\"),9); map.put(new Animal(15,\"Dog\"),7); map.put(new Animal(12,\"muskrat\"),20);\n     map.put(new Animal(25,\"Wolf\"), 1); map.put(new Animal(33,\"Giant sloth\"), 6);\n     map.put(new Animal(35,\"Leapord\"),2); map.put(new Animal(9,\"chipmunk\"),4); map.put(new Animal(46,\"Cave Dweller\"),1);\n     \n        System.out.println(map);\n        \n    SortedMap<Animal,Integer> tailmap = map.tailMap(new Animal(33,\"Giant Sloth\"),false);\n    \n        System.out.println(tailmap);\n        \n   \n    }\n}','Collections',0,0,NULL,5),(290,'will not compile,\n\npollFirstEntry(),cielingKey,higherKey(), floorKey(), pollLastEntry(),\ndescendingMap()\n\n	are all in TreeMap not interface SortedMap.',' public static void main(String[] dicks){\n      \n     TreeMap<Animal, Integer> map = new TreeMap<>();\n     \n     map.put(new Animal(2,\"Ant\"), 6); map.put(new Animal(3,\"Beee\"),9); map.put(new Animal(15,\"Dog\"),7); map.put(new Animal(12,\"muskrat\"),20);\n     map.put(new Animal(25,\"Wolf\"), 1); map.put(new Animal(33,\"Giant sloth\"), 6);\n     map.put(new Animal(35,\"Leapord\"),2); map.put(new Animal(9,\"chipmunk\"),4); map.put(new Animal(46,\"Cave Dweller\"),1);\n     \n        System.out.println(map);\n        \n     SortedMap<Animal,Integer> tailmap = map.tailMap(new Animal(33,\"Giant Sloth\"),false);\n     \n        System.out.println(tailmap.pollFirtEntry());\n    \n    }\n}','Collections',0,0,NULL,5),(291,'{Ant=6, Beee=9, chipmunk=4, muskrat=20, Dog=7, Wolf=1, Giant sloth=6, Leapord=2, Cave Dweller=1}\nAnt=6\nCave Dweller=1\nBeee\nchipmunk\nLeapord\nGiant sloth','public class Hello {\n    \n    \n    public static void main(String[] dicks){\n      \n     TreeMap<Animal, Integer> map = new TreeMap<>();\n     \n     map.put(new Animal(2,\"Ant\"), 6); map.put(new Animal(3,\"Beee\"),9); map.put(new Animal(15,\"Dog\"),7); map.put(new Animal(12,\"muskrat\"),20);\n     map.put(new Animal(25,\"Wolf\"), 1); map.put(new Animal(33,\"Giant sloth\"), 6);\n     map.put(new Animal(35,\"Leapord\"),2); map.put(new Animal(9,\"chipmunk\"),4); map.put(new Animal(46,\"Cave Dweller\"),1);\n     \n        System.out.println(map);\n        \n     \n        System.out.println(map.pollFirstEntry());\n        System.out.println(map.pollLastEntry());\n        System.out.println(map.ceilingKey(new Animal(2,\"Ant\")));\n        System.out.println(map.higherKey(new Animal(3,\"Beee\")));\n        System.out.println(map.floorKey(new Animal(46,\"Cave Dweller\")));\n        System.out.println(map.lowerKey(new Animal(35,\"Leapord\")));\n        \n    \n    }\n}','Collections',0,0,NULL,5),(292,'nullpointerexception, PQ does not allow null elements','\npublic class Hello {\n    public static void main(String[] dicks){\n      \n        PriorityQueue<Animal> q = new PriorityQueue<>();\n        \n        q.add(new Animal(5,\"Sheep\"));\n        q.offer(new Animal(6,\"Goat\"));\n        q.offer(new Animal(10,\"Cow\"));\n        q.offer(new Animal(12,\"Bull\"));\n        q.offer(null);\n        \n        System.out.println(q);\n        \n    \n    }\n}','Collections',0,0,NULL,5),(293,'ConcurrentModificationExcpeiton for removing elements from the pq\nwhile iterating over it. ','public class Hello {\n    public static void main(String[] dicks){\n        \n        PriorityQueue<Animal> q = new PriorityQueue<>(5);\n        \n        q.add(new Animal(5,\"Sheep\"));\n        q.offer(new Animal(6,\"Goat\"));\n        q.offer(new Animal(10,\"Cow\"));\n        q.offer(new Animal(12,\"Bull\"));\n        q.offer(new Animal(3,\"Cat\"));\n        q.offer(new Animal(7,\"Sloth\"));\n        \n        for(Animal x : q)\n            System.out.println(x);\n        \n        System.out.println(\"__________________\");\n        \n        for(Animal x : q)\n            System.out.println(q.poll());\n        \n    \n    }\n}','Collections',0,0,NULL,5),(294,'Cat\nSheep\nSloth\nBull\nGoat\nCow\n__________________\nCat\nSheep\nGoat\nSloth\nCow\nBull\n\nYou need to poll the items from the PriorityQueue one by one. toString doesn\'t do that.\n\nSo instead of your System.out.println(queue); do this:\n\nwhile(!queue.isEmpty()) {\n   System.out.println(queue.poll());\n}\n\nThe reason is that the PriorityQueue is never completely sorted internally, lookup how a heap works for more detail. Polling items from it fixes the heap during the calls, thus it should output the elements in sorted order.','public class Hello {\n    public static void main(String[] dicks){\n        \n        PriorityQueue<Animal> q = new PriorityQueue<>(5);\n        \n        q.add(new Animal(5,\"Sheep\"));\n        q.offer(new Animal(6,\"Goat\"));\n        q.offer(new Animal(10,\"Cow\"));\n        q.offer(new Animal(12,\"Bull\"));\n        q.offer(new Animal(3,\"Cat\"));\n        q.offer(new Animal(7,\"Sloth\"));\n        \n        for(Animal x : q)\n            System.out.println(x);\n        \n        System.out.println(\"__________________\");\n        \n        while(!q.isEmpty())\n            System.out.println(q.poll());\n        \n    \n    }\n}','Collections',0,0,NULL,5),(295,'will not compile string cannot be converted to Animal','public class Hello {\n    public static void main(String[] dicks){\n        \n        PriorityQueue<Animal> q = new PriorityQueue<>(5);\n        \n        q.add(new Animal(5,\"Sheep\"));\n        q.offer(new Animal(6,\"Goat\"));\n        q.offer(new Animal(10,\"Cow\"));\n        q.offer(new Animal(12,\"Bull\"));\n        q.offer(new Animal(3,\"Cat\"));\n        q.offer(new Animal(7,\"Sloth\"));\n        \n        q.offer(\"Sloths\");\n        q.add(\"fake bull\");\n        \n        while(!q.isEmpty())\n            System.out.println(q.poll());\n        \n\n        \n    \n    }\n}','Collections',0,0,NULL,5),(296,'will not compile, Collections.sort will only sort Lists','public class Hello {\n    public static void main(String[] dicks){\n        Comparator revSort = Collections.reverseOrder();\n        PriorityQueue<Animal> q = new PriorityQueue<>();\n        \n        q.add(new Animal(5,\"Sheep\"));\n        q.offer(new Animal(6,\"Goat\"));\n        q.offer(new Animal(10,\"Cow\"));\n        q.offer(new Animal(12,\"Bull\"));\n        q.offer(new Animal(3,\"Cat\"));\n        q.offer(new Animal(7,\"Sloth\"));\n        \n        PriorityQueue<Animal> q2 = new PriorityQueue<>(q);\n        \n        Collections.sort(q2,revSort);\n        \n        while(!q.isEmpty())\n            System.out.println(q.poll());\n        \n        while(!q2.isEmpty())\n            System.out.println(q2.poll());\n\n    }\n}','Collections',0,0,NULL,5),(297,'Bull\nCow\nSloth\nGoat\nSheep\nCat','public class Hello {\n    public static void main(String[] dicks){\n        Comparator revSort = Collections.reverseOrder();\n        PriorityQueue<Animal> q = new PriorityQueue<>(revSort);\n        \n        q.add(new Animal(5,\"Sheep\"));\n        q.offer(new Animal(6,\"Goat\"));\n        q.offer(new Animal(10,\"Cow\"));\n        q.offer(new Animal(12,\"Bull\"));\n        q.offer(new Animal(3,\"Cat\"));\n        q.offer(new Animal(7,\"Sloth\"));\n        \n        while(!q.isEmpty()){\n            System.out.println(q.poll());\n        }\n        \n        \n\n    }\n}','Collections',0,0,NULL,5),(298,'Here animal doesn\'t impleemnt equals and remove uses equals to determine the \nelement to remove','public class Hello {\n    public static void main(String[] dicks){\n        Comparator revSort = Collections.reverseOrder();\n        PriorityQueue<Animal> q = new PriorityQueue<>(revSort);\n        \n        q.add(new Animal(5,\"Sheep\"));\n        q.offer(new Animal(6,\"Goat\"));\n        q.offer(new Animal(10,\"Cow\"));\n        q.offer(new Animal(12,\"Bull\"));\n        q.offer(new Animal(3,\"Cat\"));\n        q.offer(new Animal(7,\"Sloth\"));\n        \n        System.out.println(q.remove());\n        System.out.println(q.remove(new Animal(7,\"Sloth\")));\n        \n        while(!q.isEmpty()){\n            System.out.println(q.poll());\n        }\n\n    }\n}\n\nclass Animal implements Comparable<Animal> {\n    private Integer size;\n    private String name;\n    \n    public Animal(int x, String y){\n        size = x;\n        name = y;\n    }\n\n    public int getSize() {\n        return size;\n    }\n\n    public String getName() {\n        return name;\n    }\n    public int compareTo(Animal o){\n        return size.compareTo(o.getSize());\n        \n    }\n    \n    public String toString(){\n        return name;\n    }\n}\n','Collections',0,0,NULL,5),(299,'now with equals remove() works just fine. \n\nBull\ntrue\n\nCow\nGoat\nSheep\nCat\n\nnotice the pq is sorted with a Reverse sort comparator, so the animal class\nimplements Comparable. If it didn\'t implement Comparable it could not be used \nin the PriorityQueue. If it wasn\'t for the equals method the remove(sloth)\ncall would return false and sloth would not be removed. Thus making the \noutput:\n\n	Bull\n	false\n\n	Cow\n	Sloth\n	Goat\n	Sheep\n	Cat\n\nalso notice that it is a queue and therefore removes from the head','public class Hello {\n    public static void main(String[] dicks){\n        Comparator revSort = Collections.reverseOrder();\n        PriorityQueue<Animal> q = new PriorityQueue<>(revSort);\n        \n        q.add(new Animal(5,\"Sheep\"));\n        q.offer(new Animal(6,\"Goat\"));\n        q.offer(new Animal(10,\"Cow\"));\n        q.offer(new Animal(12,\"Bull\"));\n        q.offer(new Animal(3,\"Cat\"));\n        q.offer(new Animal(7,\"Sloth\"));\n        \n        System.out.println(q.remove());\n        System.out.println(q.remove(new Animal(7,\"Sloth\")));\n        System.out.println(\"\");\n        \n        while(!q.isEmpty()){\n            System.out.println(q.poll());\n        }\n    }\n}\n\nclass Animal implements Comparable<Animal> {\n    private Integer size;\n    private String name;\n    \n    public Animal(int x, String y){\n        size = x;\n        name = y;\n    }\n\n    public int getSize() {\n        return size;\n    }\n\n    public String getName() {\n        return name;\n    }\n    public int compareTo(Animal o){\n        return size.compareTo(o.getSize());\n        \n    }\n    \n    public String toString(){\n        return name;\n    }\n    \n    public boolean equals(Object o){\n        if((o instanceof Animal)){\n            if((((Animal)o).getSize() == this.size) && (((Animal)o).getName().equals(name) ))\n                return true;\n            return false;           \n        } \n        return false;\n    }\n}','Collections',0,0,NULL,5),(300,'Biffy\ntwo tone\nbig slick\nfunny farm\ntwice tickled\nnull\nnull','public class Hello {\n    public static void main(String[] dicks){\n        Map<Integer,String> map = new HashMap<>();\n        \n        map.put(7,\"Biffy\");\n        map.put(5,\"two tone\");\n        map.put(9,\"big slick\");\n        map.put(1,\"funny farm\");\n        map.put(10, \"twice tickled\");\n        \n        List<Integer> list = new ArrayList<>();\n        \n        list.add(7);\n        list.add(5);\n        list.add(9);\n        list.add(1);\n        list.add(10);\n        list.add(16);\n        list.add(14);\n        \n        for(int x : list){\n            System.out.println(map.remove(x));\n        }    \n\n    }\n}','Collections',0,0,NULL,5),(301,'sizes: 5, 7, 5\nBiffy\nset contains?: true\nsizes: 4, 7, 5\ntwo tone\nset contains?: true\nsizes: 3, 7, 5\nbig slick\nset contains?: true\nsizes: 2, 7, 5\nfunny farm\nset contains?: true\nsizes: 1, 7, 5\ntwice tickled\nset contains?: true\nsizes: 0, 7, 5\nnull\nset contains?: false\nsizes: 0, 7, 5\nnull\nset contains?: false','public class Hello {\n    public static void main(String[] dicks){\n        Map<Integer,String> map = new HashMap<>();\n        \n        map.put(7,\"Biffy\");\n        map.put(5,\"two tone\");\n        map.put(9,\"big slick\");\n        map.put(1,\"funny farm\");\n        map.put(10, \"twice tickled\");\n        \n        List<Integer> list = new ArrayList<>();\n        \n        list.add(7);\n        list.add(5);\n        list.add(9);\n        list.add(1);\n        list.add(10);\n        list.add(16);\n        list.add(14);\n        \n        Set<Integer> set = new HashSet<>();\n        \n        set.add(7);\n        set.add(5);\n        set.add(9);\n        set.add(1);\n        set.add(10);\n        \n        for(int x : list){\n            System.out.println(\"sizes: \"+map.size() +\", \"+ list.size()+\", \"+set.size());\n            System.out.println(map.remove(x));\n            System.out.println(\"set contains?: \"+set.contains(x));\n        }    \n\n    }\n}','Collections',0,0,NULL,5),(302,'','Spaces sort before characters,\nuppercases sort before the lower,\nyour good to go','Collections',0,0,NULL,5),(303,'true\ntrue\nfalse\ntrue\ntrue\ntrue\nfalse\n4\ntrue\nfalse\n3','public class Hello {\n    public static void main(String[] dicks){\n       HashSet<Animal> set = new HashSet<>();\n       \n       Animal cat = new Animal(3,\"Cat\");\n       Animal dog = new Animal(4,\"Dog\");\n       Animal wolf = new Animal(6,\"Wolf\");\n       Animal coyote = new Animal(5,\"Coyote\");\n       Animal cat2 = new Animal(3,\"Cat\");\n       \n        System.out.println(cat.equals(cat2));\n       \n        System.out.println(set.add(cat));\n        System.out.println(set.add(cat));\n        System.out.println(set.add(dog));\n        System.out.println(set.add(wolf));\n        System.out.println(set.add(coyote));\n        System.out.println(set.add(cat2));\n        \n       \n        System.out.println(set.size());\n        System.out.println(set.remove(cat));\n        System.out.println(set.contains(cat));\n        System.out.println(set.size());\n        \n        \n    \n    }\n}\n\n\nclass Animal {\n    private Integer size;\n    private String name;\n    \n    public Animal(int x, String y){\n        size = x;\n        name = y;\n    }\n\n    public int getSize() {\n        return size;\n    }\n\n    public String getName() {\n        return name;\n    }\n    \n    public String toString(){\n        return name;\n    }\n    \n    public boolean equals(Object o){\n        if((o instanceof Animal)){\n            if((((Animal)o).getSize() == this.size) && (((Animal)o).getName().equals(name) ))\n                return true;\n            return false;           \n        } \n        return false;\n    }\n    \n    //public int hashCode(){ return name.length() + size; }\n        \n}','Collections',0,0,NULL,5),(304,'true\ntrue\nfalse\ntrue\ntrue\ntrue\nfalse\n4\ntrue\nfalse\n3\n\nif hashCode() is not overriden then every object will go in its own bucket\ntherefore equals will not be able to differentiate between equal objects because it will have no\nother objects to compare that object to!','public class Hello {\n    public static void main(String[] dicks){\n       HashSet<Animal> set = new HashSet<>();\n       \n       Animal cat = new Animal(3,\"Cat\");\n       Animal dog = new Animal(4,\"Dog\");\n       Animal wolf = new Animal(6,\"Wolf\");\n       Animal coyote = new Animal(5,\"Coyote\");\n       Animal cat2 = new Animal(3,\"Cat\");\n       \n        System.out.println(cat.equals(cat2));\n       \n        System.out.println(set.add(cat));\n        System.out.println(set.add(cat));\n        System.out.println(set.add(dog));\n        System.out.println(set.add(wolf));\n        System.out.println(set.add(coyote));\n        System.out.println(set.add(cat2));\n        \n       \n        System.out.println(set.size());\n        System.out.println(set.remove(cat));\n        System.out.println(set.contains(cat));\n        System.out.println(set.size());\n        \n        \n    \n    }\n}\n\n\nclass Animal {\n    private Integer size;\n    private String name;\n    \n    public Animal(int x, String y){\n        size = x;\n        name = y;\n    }\n\n    public int getSize() {\n        return size;\n    }\n\n    public String getName() {\n        return name;\n    }\n    \n    public String toString(){\n        return name;\n    }\n    \n    public boolean equals(Object o){\n        if((o instanceof Animal)){\n            if((((Animal)o).getSize() == this.size) && (((Animal)o).getName().equals(name) ))\n                return true;\n            return false;           \n        } \n        return false;\n    }\n    \n    public int hashCode(){ return name.length() + size; }\n        \n}\n','Collections',0,0,NULL,5),(305,'false\ntrue\nfalse\ntrue\ntrue\ntrue\ntrue\n5\ntrue\nfalse\n4\n\nif equals is not overriden then only references with the same actual\nobject are considered equal','public class Hello {\n    public static void main(String[] dicks){\n       HashSet<Animal> set = new HashSet<>();\n       \n       Animal cat = new Animal(3,\"Cat\");\n       Animal dog = new Animal(4,\"Dog\");\n       Animal wolf = new Animal(6,\"Wolf\");\n       Animal coyote = new Animal(5,\"Coyote\");\n       Animal cat2 = new Animal(3,\"Cat\");\n       \n        System.out.println(cat.equals(cat2));\n       \n        System.out.println(set.add(cat));\n        System.out.println(set.add(cat));\n        System.out.println(set.add(dog));\n        System.out.println(set.add(wolf));\n        System.out.println(set.add(coyote));\n        System.out.println(set.add(cat2));\n        \n       \n        System.out.println(set.size());\n        System.out.println(set.remove(cat));\n        System.out.println(set.contains(cat));\n        System.out.println(set.size());\n        \n        \n    \n    }\n}\n\n\nclass Animal {\n    private Integer size;\n    private String name;\n    \n    public Animal(int x, String y){\n        size = x;\n        name = y;\n    }\n\n    public int getSize() {\n        return size;\n    }\n\n    public String getName() {\n        return name;\n    }\n    \n    public String toString(){\n        return name;\n    }\n    \n    /**\n    public boolean equals(Object o){\n        if((o instanceof Animal)){\n            if((((Animal)o).getSize() == this.size) && (((Animal)o).getName().equals(name) ))\n                return true;\n            return false;           \n        } \n        return false;\n    } **/\n    \n    public int hashCode(){ return name.length() + size; }\n        \n}\n','Collections',0,0,NULL,5),(306,'nullpointerexception\n\nLinkedHashSet and HashSet allow null elements but when you call a method on a null\nyou get an exception','public class Hello {\n    public static void main(String[] dicks){\n       Animal cat = new Animal(3,\"Cat\");\n       Animal dog = new Animal(4,\"Dog\");\n       Animal wolf = new Animal(6,\"Wolf\");\n       Animal coyote = new Animal(5,\"Coyote\");\n       Animal cat2 = new Animal(3,\"Cat\");\n       \n       LinkedHashSet<Animal> lhs = new LinkedHashSet<>();\n       HashSet<Animal> hs = new HashSet<>();\n       \n       lhs.add(cat); lhs.add(dog); lhs.add(wolf); lhs.add(coyote); lhs.add(null);\n       hs.add(cat); hs.add(dog); hs.add(wolf); hs.add(coyote); hs.add(null);\n       \n       for(Animal x : lhs){\n           System.out.print(x.getName()+\" \");\n       }\n \n    }\n}','Collections',0,0,NULL,5),(307,'true\ntrue\nfalse\nfalse\n\nSets allow null elements but they also dont allow duplicates so here \nis will not let you add ANother null','public class Hello {\n    public static void main(String[] dicks){\n       Animal cat = new Animal(3,\"Cat\");\n       Animal dog = new Animal(4,\"Dog\");\n       Animal wolf = new Animal(6,\"Wolf\");\n       Animal coyote = new Animal(5,\"Coyote\");\n       Animal cat2 = new Animal(3,\"Cat\");\n       \n       LinkedHashSet<Animal> lhs = new LinkedHashSet<>();\n       HashSet<Animal> hs = new HashSet<>();\n       \n       lhs.add(cat); lhs.add(dog); lhs.add(wolf); lhs.add(coyote);\n       hs.add(cat); hs.add(dog); hs.add(wolf); hs.add(coyote); \n       \n       System.out.println( lhs.add(null) ); \n       System.out.println( hs.add(null) );\n       \n       System.out.println( lhs.add(null) );\n       System.out.println( hs.add(null) );\n        \n\n    }\n}','Collections',0,0,NULL,5),(308,'will not compile,\n\nHashtable is a Map !\n\nrequires two type arguments','public class Hello {\n    public static void main(String[] dicks){\n       Animal cat = new Animal(3,\"Cat\");\n       Animal dog = new Animal(4,\"Dog\");\n       Animal wolf = new Animal(6,\"Wolf\");\n       Animal coyote = new Animal(5,\"Coyote\");\n       Animal cat2 = new Animal(3,\"Cat\");\n       \n       LinkedHashSet<Animal> lhs = new LinkedHashSet<>();\n       HashSet<Animal> hs = new HashSet<>();\n       Hashtable<Animal> ht = new Hashtable<>();\n       \n       lhs.add(cat); lhs.add(dog); lhs.add(wolf); lhs.add(coyote);\n       hs.add(cat); hs.add(dog); hs.add(wolf); hs.add(coyote); \n       \n       System.out.println(lhs.add(null)); \n       System.out.println(hs.add(null));\n       \n       System.out.println(lhs.add(null));\n       System.out.println(hs.add(null));\n        \n\n    }\n}','Collections',0,0,NULL,5),(309,'null\nnull\nnull\nnull\nnull\nCat\nCat\nDog\nDog\n\nput\n\npublic V put(K key,\n    V value)\n\nMaps the specified key to the specified value in this hashtable. \nNeither the key nor the value can be null.\n\nThe value can be retrieved by calling the get\n method with a key that is equal to the original key.\n\nTo successfully store and retrieve objects from a hashtable, \nthe objects used as keys \nmust implement the hashCode method and the equals method. \n\nto know anything about how this code works you need to know if it implements\nequals and hashCode','public class Hello {\n    public static void main(String[] dicks){\n       Animal cat = new Animal(3,\"Cat\");\n       Animal dog = new Animal(4,\"Dog\");\n       Animal wolf = new Animal(6,\"Wolf\");\n       Animal coyote = new Animal(5,\"Coyote\");\n       Animal cat2 = new Animal(3,\"Cat\");\n\n       Hashtable<Integer,Animal> ht = new Hashtable<>();\n\n        System.out.println(ht.put(1,cat));\n        System.out.println(ht.put(2,dog));\n        System.out.println(ht.put(3,wolf));\n        System.out.println(ht.put(4,coyote));\n        System.out.println(ht.put(5, cat2));\n        \n        System.out.println(ht.put(1,cat));\n        System.out.println(ht.put(1,new Animal(3,\"Barn Cat\")));\n        \n        System.out.println(ht.put(2,dog));\n        System.out.println(ht.put(2, new Animal(4,\"Fox\")));\n    }\n}','Collections',0,0,NULL,5),(310,'null\nnull\nnull\nnull\nnull\nCat\nCat\n5\nDog\nDog','public class Hello {\n    public static void main(String[] dicks){\n       Animal cat = new Animal(3,\"Cat\");\n       Animal dog = new Animal(4,\"Dog\");\n       Animal wolf = new Animal(6,\"Wolf\");\n       Animal coyote = new Animal(5,\"Coyote\");\n       Animal cat2 = new Animal(3,\"Cat\");\n\n       Hashtable<Integer,Animal> ht = new Hashtable<>();\n\n        System.out.println(ht.put(1,cat));\n        System.out.println(ht.put(2,dog));\n        System.out.println(ht.put(3,wolf));\n        System.out.println(ht.put(4,coyote));\n        System.out.println(ht.put(5, cat2));\n        \n        System.out.println(ht.put(1,cat));\n        System.out.println(ht.put(1,new Animal(3,\"Barn Cat\")));\n        \n        System.out.println(ht.size());\n        \n        System.out.println(ht.put(2,dog));\n        System.out.println(ht.put(2, new Animal(4,\"Fox\")));\n    }\n}\n\n\nclass Animal {\n    private Integer size;\n    private String name;\n    \n    public Animal(int x, String y){\n        size = x;\n        name = y;\n    }\n\n    public int getSize() {\n        return size;\n    }\n\n    public String getName() {\n        return name;\n    }\n    \n    public String toString(){\n        return name;\n    }\n    \n    /**\n    public boolean equals(Object o){\n        if((o instanceof Animal)){\n            if((((Animal)o).getSize() == this.size) && (((Animal)o).getName().equals(name) ))\n                return true;\n            return false;           \n        } \n        return false;\n    } **/\n    \n    //public int hashCode(){ return name.length() + size; }\n        \n}\n','Collections',0,0,NULL,5),(311,'will not compile int cannot auotbox to null\n\na primitive cannot be null','public class Hello {\n    public static void main(String[] dicks){\n        Map<String, Integer> map = new HashMap<>();\n        \n        String name = \"Max\";\n        map.put(name,10000000);\n        \n        int total = map.get(\"Max\");\n        \n        (if total == null){\n            System.out.println(\"no money in maxs account\");\n        }\n    }\n}','Collections',0,0,NULL,5),(312,'class Foo<t> { }	// a class\nT anInstance;		//an instance variable\nFoo(T aRef) { }	// a constructor argument\nvoid bar(T aRef) { }	// a method argument\nT baz() { }		// a return type\n\nThe compiler will substitute the actual type','The generics type identifier can be used in class, method, and variable declarations....\n\n','Generics',0,0,NULL,5),(313,'List and Set, With Maps you remove by the key which removes the element','Which Collection interfaces have a method for removing an element by the object ?','Collections',0,0,NULL,5),(314,'Will Not compile\n\nuntyped collections store Objects so you would have to cast to a String. ','public class Hello {\n    public static void main(String[] args){\n        List myList = new ArrayList();\n        myList.add(\"Hoyt\");\n        myList.add(\"JOJO\");\n        myList.add(\"Adam\");\n        \n        String athletename = myList.get(1);\n        System.out.println(athletename+ \" \" + athletename.length());\n    }\n}','Collections',0,0,NULL,5),(315,'Will Not compile','void takeListOfStrings(List<String> strings) {\n	strings.add(new Integer(42) ); \n}','Generics',0,0,NULL,5),(316,'Compiles fine, you know what is coming out of a typed list returned from a method declared with that type','public List<Dog> getDogList() {\n	List<Dog> dogs = new ArrayList<>();\n	//add dogs to list\n	return dogs;\n}\n\nDog d = getDogList().get(0);','Generics',0,0,NULL,5),(317,'Will not compile','public List getDogList() {\n	List dogs = new ArrayList();\n	dogs.add(\"Dicks\");\n	dogs.add(\"Spot\");\n	dogs.add(\"FIdo\");\n	return dogs;\n}\n\npsvm(sa){	\n	List dognames = getDogList();\n	Dog fido = dognames.get(2);\n}\n	','Generics',0,0,NULL,5),(318,'The cast is unecessary but it wont cause any error','psvm(sa){\n	List<Integer> list = new ArrayList<>();\n	list.add(5);\n	list.add(9);\n	list.add(7);\n\n	Integer i = (Integer) list.get(0);\n}','Generics',0,0,NULL,5),(319,'Works fine. ','public class Hello {\n    public static void main(String[] args){\n        List<Integer> myList = new ArrayList<>();\n        \n        myList.add(4);\n        myList.add(6);\n        Adder adder = new Adder();\n        int total = adder.addAll(myList);\n        \n        System.out.println(total);\n        \n    }\n}\n\nclass Adder {\n        int addAll(List list){\n            Iterator it = list.iterator();\n            int total = 0;\n            \n            while(it.hasNext()){\n                int i = ((Integer)it.next()).intValue();\n                total += i;\n            }\n            \n            return total;\n        }\n}','Generics',0,0,NULL,5),(320,'ClassCastException','public class Hello {\n    public static void main(String[] args){\n        List myList = new ArrayList();\n        \n        myList.add(4);\n        myList.add(6);\n        myList.add(\"whoops\");\n        Adder adder = new Adder();\n        int total = adder.addAll(myList);\n        \n        System.out.println(total);\n        \n    }\n}\n\nclass Adder {\n        int addAll(List list){\n            Iterator it = list.iterator();\n            int total = 0;\n            \n            while(it.hasNext()){\n                int i = ((Integer)it.next()).intValue();\n                total += i;\n            }\n            \n            return total;\n        }\n}','Generics',0,0,NULL,5),(321,'compiles and runs no problem','public class Hello {\n    public static void main(String[] args){\n        List<Integer> myList = new ArrayList<>();\n        \n        myList.add(4);\n        myList.add(6);\n        Inserter is = new Inserter();\n        is.insert(myList);\n        \n    }\n}\n\nclass Inserter {\n        void insert(List list){\n            list.add(new Integer(42));\n            Iterator it = list.iterator();\n            int total = 0;\n            \n            while(it.hasNext()){\n                int i = ((Integer)it.next()).intValue();\n                total += i;\n            }\n\n        }\n}','Generics',0,0,NULL,5),(322,'ClassCastException\n\nand compiler warning for going into unsafe method','public class Hello {\n    public static void main(String[] args){\n        List<Integer> myList = new ArrayList<>();\n        \n        myList.add(4);\n        myList.add(6);\n        Inserter is = new Inserter();\n        is.insert(myList);\n        \n    }\n}\n\nclass Inserter {\n        void insert(List list){\n            list.add(\"42\");\n            Iterator it = list.iterator();\n            int total = 0;\n            \n            while(it.hasNext()){\n                int i = ((Integer)it.next()).intValue();\n                total += i;\n            }\n\n        }\n}','Generics',0,0,NULL,5),(323,'Will not compile because of .intValue() the list declared in inserter is of type Object','public class Hello {\n    public static void main(String[] args){\n        List<Integer> myList = new ArrayList<>();\n        \n        myList.add(4);\n        myList.add(6);\n        Inserter is = new Inserter();\n        is.insert(myList);\n        \n    }\n}\n\nclass Inserter {\n        void insert(List list){\n            list.add(\"42\");\n            Iterator it = list.iterator();\n            int total = 0;\n            \n            while(it.hasNext()){\n                int i = (it.next()).intValue();\n                total += i;\n            }\n\n        }\n}','Generics',0,0,NULL,5),(324,'comiler warning but compiles and runs just fine, in order to support legacy code this must be allowed. ','public class Hello {\n    public static void main(String[] args){\n        List<Integer> myList = new ArrayList<>();\n        \n        myList.add(4);\n        myList.add(6);\n        Inserter is = new Inserter();\n        is.insert(myList);\n        \n    }\n}\n\nclass Inserter {\n        void insert(List list){\n            list.add(\"42\");           \n        }\n}','Generics',0,0,NULL,5),(325,'','The compiiler only issues warnings when a typed collection is going into an untyped method and that method\nADDS somethiing. ','Generics',0,0,NULL,5),(326,'The generic types are removed by the compiler before runtime. The types are just for the compiler the JVM\nhas no idea about types. To the JVM generic code looks the same as pre generic. ','\"Type Erasure\"\n','Generics',0,0,NULL,5),(327,'cast is required here','List myList = new ArrayList();\n        \nmyList.add(45);\n        \nint x = (Integer) myList.get(0);','Generics',0,0,NULL,5),(328,'cast not necessary here',' List<Integer> myList = new ArrayList<>();\n        \n        myList.add(45);\n        \n        int x = myList.get(0);\n        \n        ','Generics',0,0,NULL,5),(329,'no\nno\nyes\nyes','List<Object> myList = new ArrayList<JButton>();\nList<Number> myList = new ArrayList<Integer>();\nList<JButton> myList = new ArrayList<JButton>();\nList<String> myList = new ArrayList<String>();','Generics',0,0,NULL,5),(330,'This is ok!\n\nunlike collection types array types can use polymorphism.\n','class Parent { }\nclass Child extends Parent { }\n\npublic class Test {\n	psvm(SA){\n		Parent[] myArray = new Child[4];\n	}\n}','Generics',0,0,NULL,5),(331,'This not ok ','List<Object> myList = new ArrayList<JButton>();	','Generics',0,0,NULL,5),(332,'Will not compile\n\nif the method parameter says ArrayList<Animal> then you\ncan only pass in an ArrayList of type <Animal>, \npolymorphism doesn\'t work for generic types','public class AnimalDoctor {\n	public void checkAnimals(ArrayLIst<Animal> list){\n		for(Animal a : animals){\n			a.checkup();\n		}\n	}\n}\n\npsvm(Sa){\n        List<Dog> dogs = new ArrayList<Dog>();\n        dogs.add(new Dog()); dogs.add(new Dog());\n\n        List<Cat> cats = new ArrrayLiist<Cat>();\n        cats.add(new Cat()); cats.add(new Cat());\n\n        AnimalDoctor ad = new AnimalDoctor();\n        ad.checkAnimals(dogs);\n        ad.checkAnimals(cats);\n}\n}','Generics',0,0,NULL,5),(333,'fine','Animal[] animals = new Animal[3];\nanimals[0] = new Cat();\nanimals[1] = new Dog();','Generics',0,0,NULL,5),(334,'fine you can add and instance of a subtype into an array or collection declared with a supertype.\n\nyou can addDogs and Cats to an Animal array or an Animal Collection. ','List<Animal> animals = new ArrayList<Animal>();\nanimals.add(new Cat());\nanimals.add(new Dog());\n','Generics',0,0,NULL,5),(335,'ok!','public class Hello {\n    public static void main(String[] args){\n       \n      \n        \n    }\n    \n    public void foo() {\n	Dog[] dogs = { new Dog(), new Dog() };\n	addAnimal(dogs);\n    }\n    \n    public void addAnimal(Animal[] animals) {\n	animals[0] = new Dog();\n        animals[1] = new Cat();\n    }\n}','Generics',0,0,NULL,5),(336,'ok !\n\nThe compiler thinks its ok to add a Dog to an Animal[] since a Dog can be assigned to an animal reference. B\n\nBut the compiler does not know if you passed in an array of an animal subtype. \n\nThe reason: at runtime the JVM knows the type of the array but not the type of the collection ','public class Hello {\n    public static void main(String[] args){\n \n    }\n    \n    public void foo() {\n	Cat[] cats = { new Cat(), new Cat() };\n	addAnimal(cats);\n    }\n    \n    public void addAnimal(Animal[] animals) {\n	animals[0] = new Dog();\n        animals[1] = new Cat();\n    }\n}','Generics',0,0,NULL,5),(337,'comiles and runs just fine','public class Hello {\n    public static void main(String[] args){\n        List<Animal> animals = new ArrayList<Animal>();\n        animals.add(new Dog());\n        animals.add(new Cat());\n        \n        addAnimal(animals);\n    \n    }\n    public static void addAnimal(List<Animal> animals) {\n	animals.add(new Dog());\n    }\n}','Generics',0,0,NULL,5),(338,'comiles fine','public class Hello {\n    public static void main(String[] args){\n        ArrayList<Animal> animals = new ArrayList<>();\n        animals.add(new Dog());\n        animals.add(new Cat());\n        \n        addAnimal(animals);\n    \n    }\n    public static void addAnimal(List<Animal> animals) {\n	animals.add(new Dog());\n    }\n}','Generics',0,0,NULL,5),(339,'will not compile, ','public class Hello {\n    public static void main(String[] args){\n        List<Dog> animals = new ArrayList<>();\n        animals.add(new Dog());\n        \n        \n        addAnimal(animals);\n    \n    }\n    public static void addAnimal(List<Animal> animals) {\n	animals.add(new Dog());\n    }\n}','Generics',0,0,NULL,5),(340,'will not compile because of ArrayList<Dog> cant be applied to List<Animal>','public class Hello {\n    public static void main(String[] args){\n        ArrayList<Dog> animals = new ArrayList<>();\n        animals.add(new Dog());\n        \n        \n        addAnimal(animals);\n    \n    }\n    public static void addAnimal(List<Animal> animals) {\n	animals.add(new Dog());\n    }\n}','Generics',0,0,NULL,5),(341,'<?> wildcard\n\ntells the compiler you can take any generic subtype of the declared argument type because you won\'t\nbe putting anything in the collection. ','What mechanism is used to tell the compiler \" Hey, I\'m using the collection passed in just to invoke methods \non the elements  and I promise not to ADD anything into the collection\"','Generics',0,0,NULL,5),(342,'wont compile \n\nadding to a collection is not compatible with ? notation','public class Hello {\n    public static void main(String[] args){\n        ArrayList<Dog> animals = new ArrayList<>();\n        animals.add(new Dog());\n        \n        \n        addAnimal(animals);\n    \n    }\n    public static void addAnimal(List<? extends Animal> animals) {\n	animals.add(new Dog());\n    }\n}','Generics',0,0,NULL,5),(343,'compiles fine!','public class Hello {\n    public static void main(String[] args){\n        ArrayList<Dog> animals = new ArrayList<>();\n        animals.add(new Dog());\n        \n        \n        addAnimal(animals);\n    \n    }\n    public static void addAnimal(List<? extends Animal> animals) {\n	for(Animal a : animals){\n            a.makesound();\n        }\n    }\n}','Generics',0,0,NULL,5),(344,'will not compile because of for(Animal a : animals)\n\n	needs to be... \n		for(Serializable a : animals)','public class Hello {\n    public static void main(String[] args){\n        ArrayList<Dog> animals = new ArrayList<>();\n        animals.add(new Dog());\n        \n        \n        addAnimal(animals);\n    \n    }\n    public static void addAnimal(List<? extends Serializable> animals) {\n	for(Animal a : animals){\n            a.makesound();\n        }\n    }\n}\n\nclass Dog extends Animal{}\nclass Cat extends Animal{}\nclass Animal implements Serializable{\n    public void makesound(){ System.out.println(\"SOUND\"); }\n        \n}','Generics',0,0,NULL,5),(345,'compiles fine!','public class Hello {\n    public static void main(String[] args){\n        ArrayList<Dog> animals = new ArrayList<>();\n        animals.add(new Dog());\n        \n        \n        addAnimal(animals);\n    \n    }\n    public static void addAnimal(List<? extends Serializable> animals) {\n	for(Serializable a : animals){\n            //call method form interface\n        }\n    }\n}\n\nclass Dog extends Animal{}\nclass Cat extends Animal{}\nclass Animal implements Serializable{\n    public void makesound(){ System.out.println(\"SOUND\"); }\n        \n}','Generics',0,0,NULL,5),(346,'<? super Dog>\n\npublic class Hello {\n    public static void main(String[] args) {     \n\n        List<Animal> animals = new ArrayList<Animal>();\n        animals.add(new Dog());\n        animals.add(new Cat());\n        \n        addAnimal(animals);\n    \n    }\n    \n    public static void addAnimal(List<? super Dog> animals) {\n	animals.add(new Dog());\n    }\n}\n\nWhile you can now accept in List types of <? super Dog> you can still only\nadd type Dog to that list. This is created because its ok to add a Dog to List<Object>\n\n\n','What can you use to type a method parameter and still add to the collection','Generics',0,0,NULL,5),(347,'this is fine\n\n\"Hey compiler, please accept any List with a generic type that is of type Dog or a supertype of Dog. \nNothing lower in the inheritance tree can come in, but anything higher than Dog is okay\"\n\nif you pass in a List of type Animal then it\'s perfectly fine to add a Dog to it. If you pass in a list of type Dog\nits still ok to add a Dog to it. if you pass in a list of type Object its still ok. \n\nHowever that doesn\'t give you the freedom to just add anything  you can still\nonly add the type after the super','public class Hello {\n    public static void main(String[] args){\n        List<Animal> animals = new ArrayList<Animal>();\n        animals.add(new Dog());\n        animals.add(new Animal());\n        \n        addAnimal(animals);\n        \n    \n    }\n    public static void addAnimal(List<? super Dog> animals) {\n	animals.add(new Dog());\n    }\n}','Generics',0,0,NULL,5),(348,'will not compile incompatible types ','public class Hello {\n    public static void main(String[] args){\n        List<Animal> animals = new ArrayList<Animal>();\n        animals.add(new Dog());\n        animals.add(new Animal());\n        \n        addAnimal(animals);\n        \n    \n    }\n    public static void addAnimal(List<Object> animals) {\n	animals.add(new Dog());\n    }\n}','Generics',0,0,NULL,5),(349,'','','Generics',0,0,NULL,5),(350,'? will mean that any type of list can be passed to this method however nothing will be allowed to be added to it\n\n<Object> will mean that only lists of type Object can be passed to this method and \nyou will be able to add pretty much anything to that list. ','whats the difference between\n\npublic void foo(List<?> list){ }\npublic void foo(List<Object> list) { }','Generics',0,0,NULL,5),(351,'class Bar compiles fine\n\nTest is the class that fails. ','public class TestWildcards {\n	psvm(sa) {\n		List<Integer> myList = new ArrayList<Integer>();\n		Bar bar = new Bar();\n		bar.doInsert(MyList);\n	}\n}\n\nclass Bar {\n	void doInsert(List<Object> list) {\n		list.add(new Dog();	\n	}\n}\n\nwhich class fails compilation here ?','Generics',0,0,NULL,5),(352,'Bar','public class TestWildcards {\n	psvm(sa) {\n		List<Integer> myList = new ArrayList<Integer>();\n		Bar bar = new Bar();\n		bar.doInsert(MyList);\n	}\n}\n\nclass Bar {\n	void doInsert(List<?> list) {\n		list.add(new Dog();	\n	}\n}\n\nwhich class fails compilation here ?','Generics',0,0,NULL,5),(353,'nothing they are identicle \n\nthey both say I can refer to any type of object. but you wont be able to addd to me. \n\nthis is very differenct from List<Object> ','whats the difference between \n\nList<?>\nList<? extends Object>','Generics',0,0,NULL,5),(354,'1 2  and 5 compile ','1 List<?> list = new ArrayList<Dog>();\n2 List<? extends Animal> alist = new ArrayList<Dog>();\n3  List<?> foo = new ArrayList<? extends Animal>();\n4 List<? extends Dog> cList = new ArrayList<Integer>();\n5 List<? super Dog> dList = new ArrayList<Animal>();\n6 List<? super Animal elist = new ArrayList<Dog>();\n\n','Generics',0,0,NULL,5),(355,'AutoCloseable()\nyou can call close() mulitple times and nothing will happen the second time and beyond. \n\nCloseable() is not, something could go wrong the second time','Which interface close() is idempotent ?','Generics',0,0,NULL,5),(356,'public <T> void makeArrayList(T t){ }\n\nYou have to define the type variable BEFORE the return type of the method\n\n','declare a generic method:\n\npublic <T> void makeArrayList(T t){ }\n\npublic void makeArrayList(T t) { }\n\npublic void <T> makeArrayList(T t){\n}','Generics',0,0,NULL,5),(357,'Will not compile \n\nNon static type variable cannot be referenced from static context. \n\nWhen T is defined for a new class it is appropriate for that instance there forfore static methods of that \nclass wont really know about the individualy typed instances. \n\nSingleton with generics doesn\'t make a whole lot of sense anyway....\n\npublic class SimpleSingleton {\nprivate Map<String, Object> counter = new HashMap<String, Object>();\n\npublic <T> T getInstance(Class<T> clazz) throws IllegalAccessException, InstantiationException {\n    T singleton = (T) counter.get(clazz.getName());\n    if (singleton == null) {\n        singleton = clazz.newInstance();\n        counter.put(clazz.getName(), singleton);\n    }\n    return singleton;\n}\n\n\nalso adding a Dog to an ArrayList typed for T will not compile \n','public class Hello<T> {\n    public static void main(String[] args){\n        Printer<String> x = Printer.getInstance();\n\n    }\n    public static void addAnimal(List<T> animals) {\n	animals.add(new Dog());\n    }\n    \n    public <G> ArrayList<G> makeArrayList(G g){\n        ArrayList<G> genlist = new ArrayList();\n        genlist.add(g);\n        return genlist;\n        \n    }\n}\n\nclass Printer<T> {\n    private ArrayList<T> joblist = new ArrayList<>();\n    private static Printer instance = null;\n    \n    protected Printer(){\n        \n    }\n    \n    public static Printer getInstance(){\n        if(instance == null){\n            instance = new Printer();\n            return instance;\n        }\n        \n        return instance;\n        \n    }\n    \n    public void addJob(T t){\n        joblist.add(t);\n    }\n}','Generics',0,0,NULL,5),(358,'NullPointerException\n\ninstance in class Printer is never intitialized','public class Hello<T> {\n    public static void main(String[] args){\n        Printer<String> x = new Printer<>();\n        String y = x.instance;\n        System.out.println(y.length());\n\n    } \n    public <G> ArrayList<G> makeArrayList(G g){\n        ArrayList<G> genlist = new ArrayList();\n        genlist.add(g);\n        return genlist;\n        \n    }\n}\n\nclass Printer<T> {\n    private ArrayList<T> joblist = new ArrayList<>();\n    T instance;\n    \n    public Printer(){\n        \n    }\n    \n    public void addJob(T t){\n        joblist.add(t);\n    }\n    \n    public T getAnewT(){\n        return instance;\n    }\n}','Generics',0,0,NULL,5),(359,'in the overloaded constructor T should be instance, remember a Type is an Object not an reference varialb.e','class Printer<T> {\n    private ArrayList<T> joblist = new ArrayList<>();\n    private T instance;\n    \n    public Printer(){\n        \n    }\n    \n    public Printer(T b){\n        T = b;\n    }\n    \n    public void addJob(T t){\n        joblist.add(t);\n    }\n    \n    public T getAnewT(){\n        return instance;\n    }\n}','Generics',0,0,NULL,5),(360,'a Class will be created with a type that extends number','class Printer<T extends Number> {\n    private ArrayList<T> joblist = new ArrayList<>();\n    private T instance;\n    \n    public Printer(){\n        \n    }\n    \n    public Printer(T b){\n       instance = b;\n    }\n    \n    public void addJob(T t){\n        joblist.add(t);\n    }\n    \n    public T getAnewT(){\n        return instance;\n    }\n}','Generics',0,0,NULL,5),(361,'will not compile, a type variable is needed here not a wildcard.\n\nWildcards are never used in generic class definitions','class Printer<? extends Number> {\n    private ArrayList<T> joblist = new ArrayList<>();\n    private T instance;\n    \n    public Printer(){\n        \n    }\n    \n    public Printer(T b){\n       instance = b;\n    }\n    \n    public void addJob(T t){\n        joblist.add(t);\n    }\n    \n    public T getAnewT(){\n        return instance;\n    }\n}','Generics',0,0,NULL,5),(362,'Does not compile,\n\nyou cant use super when defining a generic class','class Printer<T super Beagle> {\n    private ArrayList<T> joblist = new ArrayList<>();\n    private T instance;\n    \n    public Printer(){\n        \n    }\n    \n    public Printer(T b){\n       instance = b;\n    }\n    \n    public void addJob(T t){\n        joblist.add(t);\n    }\n    \n    public T getAnewT(){\n        return instance;\n    }\n}\n\nclass Animal{}\nclass Dog extends Animal{}\nclass Beagle extends Dog{}','Generics',0,0,NULL,5),(363,'fine,\n\nyou use extends when creating a generic class to specify bounds','class Printer<T extends Animal> {\n    private ArrayList<T> joblist = new ArrayList<>();\n    private T instance;\n    \n    public Printer(){\n        \n    }\n    \n    public Printer(T b){\n       instance = b;\n    }\n    \n    public void addJob(T t){\n        joblist.add(t);\n    }\n    \n    public void makeSound() {\n        instance.makeSound();\n    }\n    \n    public T getAnewT(){\n        return instance;\n    }\n}\n\nclass Animal{public void makeSound(){\n            System.out.println(\"Sound!\");\n}\n}\nclass Dog extends Animal{}\nclass Beagle extends Dog{}','Generics',0,0,NULL,5),(364,'will not compile type argument string is not within bound of class Printer','public class Hello<T> {\n    public static void main(String[] args){\n        \n        Printer<String> x = new Printer<>();\n\n\n    } \n    public <G> ArrayList<G> makeArrayList(G g){\n        ArrayList<G> genlist = new ArrayList();\n        genlist.add(g);\n        return genlist;\n        \n    }\n}\n\nclass Printer<T extends Animal> {\n    private ArrayList<T> joblist = new ArrayList<>();\n    private T instance;\n    \n    public Printer(){\n        \n    }\n    \n    public Printer(T b){\n       instance = b;\n    }\n    \n    public void addJob(T t){\n        joblist.add(t);\n    }\n    \n    public void makeSound() {\n        instance.makeSound();\n    }\n    \n    public T getAnewT(){\n        return instance;\n    }\n}\n\nclass Animal{public void makeSound(){\n            System.out.println(\"Sound!\");\n}\n}\nclass Dog extends Animal{}\nclass Beagle extends Dog{}','Generics',0,0,NULL,5),(365,'will not compile because of (Dog d)','public class Hello<T> {\n    public static void main(String[] args){\n\n        ArrayList x = makeArrayList(Dog d);\n        \n        ArrayList c = new ArrayList<String>();\n\n    } \n    public <G> ArrayList<G> makeArrayList(G g){\n        ArrayList<G> genlist = new ArrayList();\n        genlist.add(g);\n        return genlist;\n        \n    }\n}','Generics',0,0,NULL,5),(366,'compiles fine.','public class Hello<T> {\n    public static void main(String[] args){\n        \n        Dog d = new Dog();\n        \n        ArrayList x = makeArrayList(d);\n        \n        ArrayList c = new ArrayList<String>();\n\n    } \n    public static <G> ArrayList<G> makeArrayList(G g){\n        ArrayList<G> genlist = new ArrayList();\n        genlist.add(g);\n        return genlist;\n        \n    }\n}','Generics',0,0,NULL,5),(367,'neither Dog a nor stringa will compile. The Declared type of the arraylists is non generic so they return objects\n','public class Hello<T> {\n    public static void main(String[] args){\n        \n        Dog d = new Dog();\n        \n        ArrayList x = makeArrayList(d);\n        \n        ArrayList c = new ArrayList<String>();\n        c.add(\"quick string\");\n        \n        x.add(new Dog());\n        \n        Dog a = x.get(0);\n        String stringa = c.get(0);\n \n    } \n    public static <G> ArrayList<G> makeArrayList(G g){\n        ArrayList<G> genlist = new ArrayList();\n        genlist.add(g);\n        return genlist;\n        \n    }\n}','Generics',0,0,NULL,5),(368,'compiles fine','public class Hello<T> {\n    public static void main(String[] args){\n        \n        Dog d = new Dog();\n        \n        ArrayList<Dog> c = makeArrayList(d);\n \n    } \n    public static <G> ArrayList<G> makeArrayList(G g){\n        ArrayList<G> genlist = new ArrayList();\n        genlist.add(g);\n        return genlist;\n        \n    }\n}','Generics',0,0,NULL,5),(369,'compiles fine','public class Hello<T> {\n    public static void main(String[] args){\n        \n        Dog d = new Dog();\n        \n        ArrayList<Dog> c = makeArrayList(d);\n        \n        c.add(new Beagle());\n \n    } \n    public static <G extends Animal> ArrayList<G> makeArrayList(G g){\n        ArrayList<G> genlist = new ArrayList();\n        genlist.add(g);\n        return genlist;\n        \n    }\n}\n\n\nclass Animal{public void makeSound(){\n            System.out.println(\"Sound!\");\n}\n}\nclass Dog extends Animal{}\nclass Beagle extends Dog{}','Generics',0,0,NULL,5),(370,'Compilation fails ? wildcard is not valid here you need a type varialbe istead','public class Hello<T> {\n    public static void main(String[] args){\n        \n        Dog d = new Dog();\n        \n        ArrayList<Dog> c = makeArrayList(d);\n \n    } \n    public static <? extends Animal> ArrayList<?> makeArrayList(? g){\n        ArrayList<?> genlist = new ArrayList();\n        genlist.add(g);\n        return genlist;\n        \n    }\n}','Generics',0,0,NULL,5),(371,'compiles fine, \n\nyou can define ArrayLIsts this way, you wont be able to add anything to it though','public class Hello<T> {\n    public static void main(String[] args){\n        \n        Dog d = new Dog();\n        \n        ArrayList<?> c = makeArrayList(d);\n \n    } \n    public static <G extends Animal> ArrayList<G> makeArrayList(G g){\n        ArrayList<G> genlist = new ArrayList();\n        genlist.add(g);\n        return genlist;\n        \n    }\n}','Generics',0,0,NULL,5),(372,'compilation fails','public class Hello<T> {\n    public static void main(String[] args){\n        \n        Dog d = new Dog();\n        \n        ArrayList<?> c = makeArrayList(d);\n        c.add(new Animal());\n    } \n    public static <G extends Animal> ArrayList<G> makeArrayList(G g){\n        ArrayList<G> genlist = new ArrayList();\n        genlist.add(g);\n        return genlist;\n        \n    }\n}','Generics',0,0,NULL,5),(373,'does not compile because of H extends Beagle\n\nshould be ? extends Beagle','public class Hello<T> {\n    public static void main(String[] args){\n        \n        Dog d = new Dog();\n        \n        ArrayList<H extends Beagle> c = makeArrayList(d);\n        \n    } \n    public static <G extends Animal> ArrayList<G> makeArrayList(G g){\n        ArrayList<G> genlist = new ArrayList();\n        genlist.add(g);\n        return genlist;\n        \n    }\n}','Generics',0,0,NULL,5),(374,'does not compile Beagle is the lowest type and nothing extends it,\n\nthe only type that would be acceptable here is a Beagle','public class Hello<T> {\n    public static void main(String[] args){\n        \n        Dog d = new Dog();\n        \n        ArrayList<? extends Beagle> c = makeArrayList(d);\n        \n    } \n    public static <G extends Animal> ArrayList<G> makeArrayList(G g){\n        ArrayList<G> genlist = new ArrayList();\n        genlist.add(g);\n        return genlist;\n        \n    }\n}\n\n\nclass Animal{public void makeSound(){\n            System.out.println(\"Sound!\");\n}\n}\nclass Dog extends Animal{}\nclass Beagle extends Dog{}','Generics',0,0,NULL,5),(375,'compiles fine','public class Hello<T> {\n    public static void main(String[] args){\n        \n        Dog d = new Dog();\n        \n        ArrayList<? extends Animal> c = makeArrayList(d);\n        \n    } \n    public static <G extends Animal> ArrayList<G> makeArrayList(G g){\n        ArrayList<G> genlist = new ArrayList();\n        genlist.add(g);\n        return genlist;\n        \n    }\n}\n\n\nclass Animal{public void makeSound(){\n            System.out.println(\"Sound!\");\n}\n}\nclass Dog extends Animal{}\nclass Beagle extends Dog{}','Generics',0,0,NULL,5),(376,'\n\nPECS (short for \"Producer extends and Consumer super\") can be explained by : Get and Put Principle\nGet And Put Principle (From Java Generics and Collections)\n\nIt states,\n\n    use an extends wildcard when you only get values out of a structure\n    use a super wildcard when you only put values into a structure\n    and don’t use a wildcard when you both get and put.\n\nLet\'s understand it by example:\n\n1. For Extends Wildcard(get values i.e Producer extends)\n\nHere is a method, that takes a collection of numbers, converts each to a double, and sums them up\n\npublic static double sum(Collection<? extends Number> nums) {\n   double s = 0.0;\n   for (Number num : nums) \n      s += num.doubleValue();\n   return s;\n}\n\nLet\'s call the method :\n\nList<Integer>ints = Arrays.asList(1,2,3);\nassert sum(ints) == 6.0;\nList<Double>doubles = Arrays.asList(2.78,3.14);\nassert sum(doubles) == 5.92;\nList<Number>nums = Arrays.<Number>asList(1,2,2.78,3.14);\nassert sum(nums) == 8.92;\n\nSince, sum() method uses extends, all of the following calls are legal. The first two calls would not be legal if extends was not used.\n\nEXCEPTION : You cannot put anything into a type declared with an extends wildcard—except for the value null, which belongs to every reference type:\n\nList<Integer> ints = new ArrayList<Integer>();\nints.add(1);\nints.add(2);\nList<? extends Number> nums = ints;\nnums.add(null);  // ok\nassert nums.toString().equals(\"[1, 2, null]\");\n\n2. For Super Wildcard(put values i.e Consumer super)\n\nHere is a method, that takes a collection of numbers and an int n, and puts the first n integers, starting from zero, into the collection:\n\npublic static void count(Collection<? super Integer> ints, int n) {\n    for (int i = 0; i < n; i++) ints.add(i);\n}\n\nLet\'s call the method :\n\nList<Integer>ints = new ArrayList<Integer>();\ncount(ints, 5);\nassert ints.toString().equals(\"[0, 1, 2, 3, 4]\");\nList<Number>nums = new ArrayList<Number>();\ncount(nums, 5); nums.add(5.0);\nassert nums.toString().equals(\"[0, 1, 2, 3, 4, 5.0]\");\nList<Object>objs = new ArrayList<Object>();\ncount(objs, 5); objs.add(\"five\");\nassert objs.toString().equals(\"[0, 1, 2, 3, 4, five]\");\n\nSince, count() method uses super, all of the following calls are legal: The last two calls would not be legal if super was not used.\n\nEXCEPTION : you cannot get anything out from a type declared with a super wildcard—except for a value of type Object, which is a supertype of every reference type:\n\nList<Object> objs = Arrays.<Object>asList(1,\"two\");\nList<? super Integer> ints = objs;\nString str = \"\";\nfor (Object obj : ints) str += obj.toString();\nassert str.equals(\"1two\");\n\n3. When both Get and Put, don\'t Use wildcard\n\nWhenever you both put values into and get values out of the same structure, you should not use a wildcard.\n\npublic static double sumCount(Collection<Number> nums, int n) {\n   count(nums, n);\n   return sum(nums);\n}\n\n','PECS','Generics',0,0,NULL,5),(377,'PECS\n\nproducers extends consumers super','public class Hello<T> {\n    \n    public static void main(String[] args){\n        \n        Dog d = new Dog();\n        \n        ArrayList<? extends Animal> c = new ArrayList<Beagle>();\n        \n        c.add(new Beagle()); // does not compile\n        c.add(new Beagle()); // does not compile\n        \n        Animal a = c.get(0);\n    } ','Generics',0,0,NULL,5),(378,'does not compile because of Beagle a = c.get(0);','public class Hello<T> {\n    \n    public static void main(String[] args){\n        \n        Dog d = new Dog();\n        \n        ArrayList<? super Beagle> c = new ArrayList<Beagle>();\n        \n        c.add(new Beagle());\n        c.add(new Beagle()); \n        \n        Beagle a = c.get(0);\n    } ','Generics',0,0,NULL,5),(379,'compiles fine','public class Hello<T> {\n    \n    public static void main(String[] args){\n        \n        Dog d = new Dog();\n        \n        ArrayList<Dog> c = makeArrayList(d);\n        \n        c.add(new Beagle());\n        c.add(new Beagle()); \n\n    } \n    public static <G extends Animal> ArrayList<G> makeArrayList(G g){\n        ArrayList<G> genlist = new ArrayList<>();\n        genlist.add(g);\n        return genlist;\n        \n    }\n}','Generics',0,0,NULL,5),(380,'compiles fine','public class Hello<T> {\n    \n    public static void main(String[] args){\n        \n        Dog d = new Dog();\n        \n        ArrayList<Dog> c = makeArrayList(new Beagle());\n        \n        c.add(new Beagle());\n        c.add(new Beagle()); \n\n    } \n    public static <G extends Animal> ArrayList<G> makeArrayList(G g){\n        ArrayList<G> genlist = new ArrayList<>();\n        genlist.add(g);\n        return genlist;\n        \n    }\n}','Generics',0,0,NULL,5),(381,'comilation fails\n\nArrayLIst<Animal> cannot be applied to ArrayList<Dog>','public class Hello<T> {\n    \n    public static void main(String[] args){\n        \n        Dog d = new Dog();\n        \n        ArrayList<Dog> c = makeArrayList(new Animal());\n        \n        c.add(new Beagle());\n        c.add(new Beagle()); \n\n    } \n    public static <G extends Animal> ArrayList<G> makeArrayList(G g){\n        ArrayList<G> genlist = new ArrayList<>();\n        genlist.add(g);\n        return genlist;\n        \n    }\n}','Generics',0,0,NULL,5),(382,'comiles fine','\npublic class Hello<T> {\n    \n    public static void main(String[] args){\n        \n        Dog d = new Dog();\n        \n        ArrayList<?> c = makeArrayList(new Animal());\n        \n\n    } \n    public static <G extends Animal> ArrayList<G> makeArrayList(G g){\n        ArrayList<G> genlist = new ArrayList<>();\n        genlist.add(g);\n        return genlist;\n        \n    }\n}','Generics',0,0,NULL,5),(383,'','public class Test {\n\n    public class A {}\n\n    public class B extends A {}\n\n    public class C extends B {}\n\n    public void testCoVariance(List<? extends B> myBlist) {\n        B b = new B();\n        C c = new C();\n        myBlist.add(b); // does not compile\n        myBlist.add(c); // does not compile\n        A a = myBlist.get(0); \n    }\n\n    public void testContraVariance(List<? super B> myBlist) {\n        B b = new B();\n        C c = new C();\n        myBlist.add(b);\n        myBlist.add(c);\n        A a = myBlist.get(0); // does not compile\n    }\n}','Generics',0,0,NULL,5),(384,'\n\nJosh Bloch\'s mnemonic PECS is useful here. It stands for:\n\nProducer extends, Consumer super\n\nThis means that when a parameterized type being passed to a method will produce instances of T (they will be retrieved from it in some way), ? extends T should be used, since any instance of a subclass of T is also a T.\n\nWhen a parameterized type being passed to a method will consume instances of T (they will be passed to it to do something), ? super T should be used because an instance of T can legally be passed to any method that accepts some supertype of T. A Comparator<Number> could be used on a Collection<Integer>, for example. ? extends T would not work, because a Comparator<Integer> could not operate on a Collection<Number>.\n\nEdit: To clarify a little more on get/put (produce/consume):\n\npublic T something();\n       ^\n\nThe above is a method that produces T.\n\npublic void something(T t);\n                      ^\n\nThe above is a method that consumes T.\n\n\"Producer extends, Consumer super\" applies to how the method a parameterized object is being passed to is going to be using that object. In the case of Collections.max(), items will be retrieved from the Collection, so it is a producer. Those items will be passed as arguments to the method on Comparator, so it is a consumer.\n','PECS','Generics',0,0,NULL,5),(385,'','/ Source \n       List<Integer> intList = Arrays.asList(1,2,3);\n       List<Double> doubleList = Arrays.asList(2.78,3.14);\n       List<Number> numList = Arrays.asList(1,2,2.78,3.14,5);\n\n       // Destination\n       List<Integer> intList2 = new ArrayList<>();\n       List<Double> doublesList2 = new ArrayList<>();\n       List<Number> numList2 = new ArrayList<>();\n\n        // Works\n        copyElements1(intList,intList2);         // from int to int\n        copyElements1(doubleList,doublesList2);  // from double to double\n\n\n     static <T> void copyElements1(Collection<T> src, Collection<T> dest) {\n        for(T n : src){\n            dest.add(n);\n         }\n      }\n\n\n     // Let\'s try to copy intList to its supertype\n     copyElements1(intList,numList2); // error, method signature just says \"T\"\n                                      // and here the compiler is given \n                                      // two types: Integer and Number, \n                                      // so which one shall it be?\n\n     // PECS to the rescue!\n     copyElements2(intList,numList2);  // possible\n\n\n\n    // copy Integer (? extends T) to its supertype (Number is super of Integer)\n    private static <T> void copyElements2(Collection<? extends T> src, \n                                          Collection<? super T> dest) {\n        for(T n : src){\n            dest.add(n);\n        }\n    }','Generics',0,0,NULL,5),(386,'does not compile Collection<G> is given two different types here\n\nalso a and b were not initialized, that is ok to do with instance variables\nbut not locals \n\nyou could say \n\nArrayList<Animal> a = null;\nand same for b;','public class Hello<T> {\n    \n    public static void main(String[] args){\n        ArrayList<Animal> a;\n        ArrayList<Beagle> b;\n        \n        Hello<String> x = new Hello<>();\n        \n        x.copyColl(a,b);\n        \n\n    } \n    public <G> void copyColl(Collection<G> src, Collection<G> dest){\n        \n        for(G n : src)\n            dest.add(n);\n        \n    }\n}','Generics',0,0,NULL,5),(387,'compiles fine','public class Hello<T> {\n    \n    public static void main(String[] args){\n        ArrayList<Dog> a = new ArrayList<>();\n        ArrayList<Dog> b = new ArrayList<>();\n        \n        Hello<String> x = new Hello<>();\n        \n        x.copyColl(a,b);\n        \n\n    } \n    public <G extends Animal> void copyColl(Collection<G> src, Collection<G> dest){\n        \n        for(G n : src)\n            dest.add(n);\n        \n    }\n}','Generics',0,0,NULL,5),(388,'does not compile \n\nyou cant add to a collection declared with wildcard extends','public class Hello<T> {\n    \n    public static void main(String[] args){\n        ArrayList<Dog> a = new ArrayList<>();\n        ArrayList<Dog> b = new ArrayList<>();\n        \n        Hello<String> x = new Hello<>();\n        \n        \n        \n        x.copyColl(a,b);\n        \n\n    } \n    public <G extends Animal> void copyColl(Collection<G> src, Collection<? extends G> dest){\n        \n        for(G n : src)\n            dest.add(n);\n        \n    }\n}','Generics',0,0,NULL,5),(389,'compiles fine','public class Hello<T> {\n    \n    public static void main(String[] args){\n        ArrayList<Dog> a = new ArrayList<>();\n        ArrayList<Dog> b = new ArrayList<>();\n        \n        Hello<String> x = new Hello<>();\n        \n        \n        \n        x.copyColl(a,b);\n        \n\n    } \n    public <G extends Animal> void copyColl(Collection<G> src, Collection<? super G> dest){\n        \n        for(G n : src)\n            dest.add(n);\n        \n    }\n}','Generics',0,0,NULL,5),(390,'will not compiile at x.copyColl','public class Hello<T> {\n    \n    public static void main(String[] args){\n        ArrayList<Animal> a = new ArrayList<>();\n        ArrayList<Dog> b = new ArrayList<>();\n        \n        Hello<String> x = new Hello<>();\n        \n        \n        \n        x.copyColl(a,b);\n        \n\n    } \n    public <G extends Animal> void copyColl(Collection<? extends G> src, Collection<? super G> dest){\n        \n        for(G n : src)\n            dest.add(n);\n        \n    }\n}','Generics',0,0,NULL,5),(391,'compiles fine\n\nyou can easily take a beagle and add it to an Animal array','public class Hello<T> {\n    \n    public static void main(String[] args){\n        ArrayList<Beagle> a = new ArrayList<>();\n        ArrayList<Animal> b = new ArrayList<>();\n        \n        Hello<String> x = new Hello<>();\n        \n        \n        \n        x.copyColl(a,b);\n        \n\n    } \n    public <G extends Animal> void copyColl(Collection<? extends G> src, Collection<? super G> dest){\n        \n        for(G n : src)\n            dest.add(n);\n        \n    }\n}','Generics',0,0,NULL,5),(392,'','','blank',0,0,NULL,5),(393,'','','blank',0,0,NULL,5),(394,'','','blank',0,0,NULL,5),(395,'','','blank',0,0,NULL,5),(396,'','','blank',0,0,NULL,5),(397,'public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs)\nthrows IOException {\n	sout( dir );\n	return FileVisitResult.CONTINUE;\n}\n\npublic FileVisitResult postVisitDirectory(Path dir, IOException e)\nthrows IOException {\n	sout( dir );\n	return FileVisitResult.CONTINUE;\n}\n\n**VisitFile is called only for Files and not directories','public class Visit extends SimpleFileVisitor<Path> {\n\n	//insert here\n\n   public static void main(String[] args) throws Exception {\n	Visit v = new Visit();\n	Files.walkFileTree(Paths.get(\"/mydir\"),v);\n   }\n}\n\nwhat inserted here will print out the provided directory and all \nsubdirectories ?\n\n\n','IO',0,1,NULL,5),(398,'','','blank',0,0,NULL,5),(399,'','','blank',0,0,NULL,5),(400,'r1\nr4\npre \nb1\nb2\nr3\nr2\nhawk\n\nstatic init blocks run at class loading time. Instance init blocks run after\nthe constructors call to super()','class Bird {	\n	{ System.out.println(\"b1\"); }	\n	public Bird() { System.out.println(\"b2\"); }\n}\n\nclass Raptor extends Bird {\n	static {System.out.println(\"r1\"); }\n	public Raptor() { System.out.println(\"r2\"); }\n	{ System.out.println(\"r3\"); }\n	static { System.out.println(\"r4\"); }\n}\npublic class Hello extends Raptor {\n\n    public static void main(String[] args) {\n        System.out.println(\"pre \");\n        new Hello();\n        System.out.println(\"hawk\");\n    }\n}\n		','OOP',0,0,NULL,5),(401,'BasicFileAttributeView baView = Files.getFileAttributeView(d,BasicFileAttributeView.class);','public static void makeFileCreatedOnMonday(Path d) throws IOException{\n        BasicFileAttributes ba = Files.readAttributes(d, BasicFileAttributes.class);\n        Calendar c = Calendar.getInstance();\n        //BasicFileAttributeView baView = Files.readAttributeView(d,BasicFileAttributes.class)\n        //BasicFileAttributeView baView = Files.getBasicAttributeView(d,BasicFileAttributes.class);\n        //BasicFileAttributeView baView = Files.getFileAttributeView(d,BasicFileAttributes.class);\n        //BasicFileAttributeView baView = Files.getFileAttributeView(d,BasicFileAttributeView.class);\n        \n	//void setTimes(FileTime lastModifiedTime,FileTime lastAccessTime,FileTime createTime)\n        \n        Date creationDate = new Date(ba.creationTime().toMillis());\n        c.setTime(creationDate);\n        \n        if(c.get(Calendar.DAY_OF_WEEK) == Calendar.MONDAY){\n            baView.setTimes(null,null,null);\n        } else {\n            //other fields are retained\n            c.set(Calendar.DAY_OF_WEEK,Calendar.MONDAY);\n            FileTime newDay = FileTime.fromMillis(c.getTimeInMillis());\n            \n            baView.setTimes(null,null,newDay);\n        }\n        \n    }\n\nHow do you create a FileAttributeView ?','Strings',0,0,NULL,5),(402,'','','blank',0,0,NULL,5),(403,'compiles with warnings \n\nthe problems will arrise down the road when you get that dog out of a supposedly Integer array. ','psvm(SA){\n	List<Integer> list = new ArrayLIst<>();\n	list.add(5); //autoboxing\n	foo( list );\n}\n\nstatic void foo(List alist) {\n	alist.add(new Dog(\"Charly\"));\n}','Generics',0,0,NULL,5),(404,'','Generic type information does not exist at runtime - it is for compile-time safetly only.\nMixing generics with legacy code can create compiled code that may throw an excecption at runtime. ','Generics',0,0,NULL,5),(405,'','polymorphic assingment rules apply everywhere an assignment can be made for generics,\n\nthe following are not allowed:\n	\n	void foo(List<Animal> alist {  }  //cannot take a List<Dog>\n\n	List<Animal> bar() {  }  // cannot return a List<Dog>','Generics',0,0,NULL,5),(406,'compiles fine','class Animal{\n    public void makeSound() throws InterruptedException {\n            System.out.println(\"Sound!\");\n    }\n}\nclass Dog extends Animal{\n    public void makeSound() throws InterruptedException {\n        System.out.println(\"Bark!\");\n        \n    }\n}\nclass BullDog extends Dog{\n    public void makeSound() throws InterruptedException {\n        System.out.println(\"Grumble!\");\n    }\n}','Generics',0,0,NULL,5),(407,'BullDog does not compile, Dog\'s makeSound chose not to throw the exception but then when BullDog chose \nto override it didn\'t know that Animal used to throw that exception. ','class Animal{\n    public void makeSound() throws InterruptedException {\n            System.out.println(\"Sound!\");\n    }\n}\nclass Dog extends Animal{\n    public void makeSound(){\n        System.out.println(\"Bark!\");\n        \n    }\n}\nclass BullDog extends Dog{\n    public void makeSound() throws InterruptedException {\n        System.out.println(\"Grumble!\");\n    }\n}','General',0,0,NULL,5),(408,'does not compile because you cannot return an Animal list from a method declaring a return statemnt\nof Dog list','public class Hello<T> {\n    \n    public static void main(String[] args){\n      Hello<?> x = new Hello<>();\n      \n      List<?> readonlylist = x.dogs();\n      List<?> readonlyanimallist = x.animals();\n        \n\n    } \n    public ArrayList<Animal> animals(){\n        ArrayList<Animal> vetlist = new ArrayList<>();\n        vetlist.add(new Animal());\n        vetlist.add(new BullDog());\n        vetlist.add(new BullDog());\n        vetlist.add(new Dog());\n        vetlist.add(new Animal());\n        \n        return vetlist;\n  \n    }\n    \n    public ArrayList<Dog> dogs(){\n        ArrayList<Animal> vetlist = new ArrayList<>();\n        vetlist.add(new Dog());\n        vetlist.add(new BullDog());\n        vetlist.add(new BullDog());\n        vetlist.add(new Dog());\n        vetlist.add(new Dog());\n\n        return vetlist;\n    }','Generics',0,0,NULL,5),(409,'','Wildcard syntax allows a generic method to accept subtypes or supertypes of the declared type\nof the method argument.\n\n	void addD(List<Dog> d) {  } //can take only <Dog>\n	\n	void addD(List<? extends Dog>) { } //take a <Dog> or <Beagle>','Generics',0,0,NULL,5),(410,'','The wildcard keyword \'extends\' is used to mean either \" extends \" or \"implements\" \n\nso in <? extends Dog> Dog can be a class or interface. ','Generics',0,0,NULL,5),(411,'','When using a wildcard List<? extends Dog>, the collection can be accessed but not modified','Generics',0,0,NULL,5),(412,'','When using a wildcard List<?> any generic type can be assigned to the reference, but for access only\nno modifications.','Generics',0,0,NULL,5),(413,'','List<Object> refers only to a List<Object>, while List<?> or List<? extends Object> can hold \nany type of object, but for access only. \n\n','Generics',0,0,NULL,5),(414,'got it ','The generic type identifier can be used in class, method, and variable declarations:\n\n	class Foo<t> { }\n	T anInstance;\n	Foo(T aRef) { } // a constructor argument\n	void bar(T aRef) {  }	//method argument\n	T baz() { }	//return type','Generics',0,0,NULL,5),(415,'','You can declare a generic method using a type not defined in the class:\n	\n	public <T> void makeList(T t) { }\n\n\n    This is not using T as a return type. This method has a void return type, but to use T within the argument you must declare the <T>\n	which happens before the return type. ','Generics',0,0,NULL,5),(416,'List<List<Integer>> table = new ArrayList<>();\n\nList<List<Integer>> table = new ArrayList<List<Integer>>();\n\n	not this:\n		List<List<Integer>> superlist1 = new ArrayList<ArrayList<Integer>>();\n\n	.... incompatible types','psvm(SA){\n	for(int i = 0; i<= 10; i++) {\n		List<Integer> row = new ArrayList<>();\n		for (int j = 0; j<= 10; j++)\n		         row.add(i*j);\n		table.add(row);\n	}\n	for(List<Integer> row : table)\n		sout(row);\n}\n\ndefine table','Generics',0,0,NULL,5),(417,'2 is true because often two dissiimilar objects can return the same hashcode value.\n\n4 is true because if the hashCode() comparison == returns true, might or might not be equal. \n\n3 is incorrect because often two dissimilar objects can return the same hashcode value. \n\n1 and 5 are a negation of the equals and hashCode() contract','Which statements are true about comparing two instances of the same class \ngiven that equals() and hashCode() have been properly overriden\n\n1 if the equals() returns true, the hashCode() comparison == might return false\n\n2 if the equals() returns false, the hashCode() comparison == might return true\n\n3 if the hashCode() comparison == returns true, the equals() method must return true\n\n4 if the hashCode() comparison == returns true, the equals() method might return true\n\n5 if the hashCode() comparison != returns true, the equals() method might return true','Generics',0,0,NULL,5),(418,'got it\n','IF TWO OBJECTS ARE EQUAL ACCORDING TO THE EQUALS(OBJECT) METHOD, THE CALLING THE HASHCODE()\nMETHOD ON EACH OF THE TWO OBJECT MUST PRODUCE THE SAME INTEGER RESULT. ','Generics',0,0,NULL,5),(419,'','It is not required that if two object are unequal according to the dquals method, the calling the hashCode()\non each of the two objects must produce distinct integer results. ','Generics',0,0,NULL,5),(420,'ClassCastException','public static void before() {\n	Set set = new TreeSet();\n	set.add(\"2\");\n	set.add(3);\n	set.add(\"1);\n	Iterator it = set.iterator();\n		while(it.hasNext() )\n	sout( it.next() );\n}\n','Generics',0,0,NULL,5),(421,'Change Herbivore interface to\n	\n	 interface Herbivore<E extends Animal> extends Hungry<E> { }','interface Hungry<E> { void munch(E x); }\ninterface Carnivore<E extends Animal> extends Hungry<E> { }\ninterface Herbivore<E extends Plant> extends Hungry<E> { }\nabstract class Plant { }\nabstract class Animal { }\nclass Grass extends Plant { }\nclass Sheep extends Animal implements Herbivore<Sheep> {\n    public void munch (Sheep x){ }\n}\nclass Wolf extends Animal implements Carnivore<Sheep> {\n    public void munch(Sheep x) { }\n}\n\nwhat can you change to make this compile','Generics',0,0,NULL,5),(422,'Sheep does not compile,\n\n	Sheep is not abstract and does not override abstract method munch(Plant) in Hungry','interface Hungry<E> { void munch(E x); }\ninterface Carnivore<E extends Animal> extends Hungry<E> { }\ninterface Herbivore<E extends Plant> extends Hungry<E> { }\nabstract class Plant { }\nabstract class Animal { }\nclass Grass extends Plant { }\nclass Sheep extends Animal implements Herbivore<Plant> {\n    public void munch (Sheep x){ }\n}\nclass Wolf extends Animal implements Carnivore<Sheep> {\n    public void munch(Sheep x) { }\n}','Generics',0,0,NULL,5),(423,'compiles and runs no problem','public class Hello<T> {\n  public static void main(String[] args){\n      Sheep bella = new Sheep();\n      \n      bella.munch(new Grass());\n      \n  }\n      \n}\n\ninterface Hungry<E> { void munch(E x); }\ninterface Carnivore<E extends Animal> extends Hungry<E> { }\ninterface Herbivore<E extends Plant> extends Hungry<E> { }\nabstract class Plant { }\nabstract class Animal { }\nclass Grass extends Plant { }\nclass Sheep extends Animal implements Herbivore<Plant> {\n    public void munch (Plant x){ }\n}\nclass Wolf extends Animal implements Carnivore<Sheep> {\n    public void munch(Sheep x) { }\n}','Generics',0,0,NULL,5),(424,'The variable c of type ArrayList<? super Beagle> could possibly hold an instance of \nArrayList<Beagle>, ArrayList<Dog>, ArrayList<Animal>, or ArrayList<Object>.\n If it happened to be set to an ArrayList<Beagle>, it would violate the generic type to add a Dog to it.\n The compiler can\'t track what you actually assign to the ArrayList<? super Beagle> variable over the course of the program, \nso it assumes the worst and prevents the possible type safety violation. ','public class Hello<T> {\n\n   public static void main(String[] args){\n\n    Dog d = new Dog();\n\n    ArrayList<? super Beagle> c = makeArrayList(d);\n\n    c.add(new Beagle());\n    c.add(new Beagle());\n    c.add(new Dog());    \n  } \n\n  public static <G extends Animal> ArrayList<G> makeArrayList(G g){\n    ArrayList<G> genlist = new ArrayList<>();\n    genlist.add(g);\n    return genlist;\n\n }\n}\n\n\nclass Animal{public void makeSound(){\n        System.out.println(\"Sound!\");\n }\n}   \n class Dog extends Animal{}\nclass Beagle extends Dog{}','Generics',0,0,NULL,5),(425,'For example, if the department of motor vehicles supplies a list of drivers to the census bureau, this seems reasonable. We think that a List<Driver> is a List<Person>, assuming that Driver is a subtype of Person. In fact, what is being passed is a copy of the registry of drivers. Otherwise, the census bureau could add new people who are not drivers into the list, corrupting the DMV\'s records.','Let\'s test your understanding of generics. Is the following code snippet legal?\n\nList<String> ls = new ArrayList<String>(); // 1\nList<Object> lo = ls; // 2 \n\nLine 1 is certainly legal. The trickier part of the question is line 2. This boils down to the question: is a List of String a List of Object. Most people instinctively answer, \"Sure!\"\n\nWell, take a look at the next few lines:\n\nlo.add(new Object()); // 3\nString s = ls.get(0); // 4: Attempts to assign an Object to a String!\n\nHere we\'ve aliased ls and lo. Accessing ls, a list of String, through the alias lo, we can insert arbitrary objects into it. As a result ls does not hold just Strings anymore, and when we try and get something out of it, we get a rude surprise.\n\nThe Java compiler will prevent this from happening of course. Line 2 will cause a compile time error.\n\nIn general, if Foo is a subtype (subclass or subinterface) of Bar, and G is some generic type declaration, it is not the case that G<Foo> is a subtype of G<Bar>. This is probably the hardest thing you need to learn about generics, because it goes against our deeply held intuitions.\n\nWe should not assume that collections don\'t change. Our instinct may lead us to think of these things as immutable.','Generics',0,1,NULL,5),(426,'static <T> void fromArrayToCollection(T[] a, Collection<T> c) {\n    for (T o : a) {\n        c.add(o); // Correct\n    }\n}','static void fromArrayToCollection(Object[] a, Collection<?> c) {\n    for (Object o : a) { \n        c.add(o); // compile-time error\n    }\n}\n\nfix this with a generic method....','Generics',0,0,NULL,5),(427,'','\n\nNo, a List<Dog> is not a List<Animal>. Consider what you can do with a List<Animal> - you can add any animal to it... including a cat. Now, can you logically add a cat to a litter of puppies? Absolutely not.\n\n// Illegal code - because otherwise life would be Bad\nList<Dog> dogs = new ArrayList<Dog>(); // ArrayList implements List\nList<Animal> animals = dogs; // Awooga awooga\nanimals.add(new Cat());\nDog dog = dogs.get(0); // This should be safe, right?\n\nSuddenly you have a very confused cat.\n\nNow, you can\'t add a Cat to a List<? extends Animal> because you don\'t know it\'s a List<Cat>. \nYou can retrieve a value and know that it will be an Animal, but you can\'t add arbitrary animals. \nThe reverse is true for List<? super Animal> - in that case you can add an Animal to it safely, but you don\'t know anything about what might be retrieved from it, because it could be a List<Object>.\n','Generics',0,0,NULL,5),(428,'compiles fine...\n\nHerbivore<Plant> extends Hungry<Plant> works because the type is a parameter just like the formal \nparameters. So it is not necessary that a subinterface has the same parameters as long as its indicated that\nit does in fact take a type parameter. \n\nIn a nutshell, generics enable types (classes and interfaces) to be parameters when defining classes, interfaces and methods. Much like the more familiar formal parameters used in method declarations, type parameters provide a way for you to re-use the same code with different inputs. The difference is that the inputs to formal parameters are values, while the inputs to type parameters are types.\n\nits the same reason why List<E>, an interface, has to be the same as = new ArrayList<E> but not the \nsame as all other Lists\n\nList<String> list = new ArrayList<String>();\n	\n	ArrayList implements List just like Herbivore extends Hungry.','public class Hello<T> {\n  public static void main(String[] args){\n      Sheep bella = new Sheep();\n      \n  }\n      \n}\n\ninterface Hungry<E> { void munch(E x); }\ninterface Carnivore<E extends Animal> extends Hungry<E> { }\ninterface Herbivore<Plant> extends Hungry<Plant> { }\nabstract class Plant { }\nabstract class Animal { }\nclass Grass extends Plant { }\nclass Sheep extends Animal implements Herbivore<Grass> {\n    public void munch (Grass x){ }\n}\nclass Wolf extends Animal implements Carnivore<Sheep> {\n    public void munch(Sheep x) { }\n}','Generics',0,0,NULL,5),(429,'','Raw Types\n\nA raw type is the name of a generic class or interface without any type arguments. For example, given the generic Box class:\n\npublic class Box<T> {\n    public void set(T t) { /* ... */ }\n    // ...\n}\n\nTo create a parameterized type of Box<T>, you supply an actual type argument for the formal type parameter T:\n\nBox<Integer> intBox = new Box<>();\n\nIf the actual type argument is omitted, you create a raw type of Box<T>:\n\nBox rawBox = new Box();\n\nTherefore, Box is the raw type of the generic type Box<T>. However, a non-generic class or interface type is not a raw type.\n\nRaw types show up in legacy code because lots of API classes (such as the Collections classes) were not generic prior to JDK 5.0. When using raw types, you essentially get pre-generics behavior — a Box gives you Objects. For backward compatibility, assigning a parameterized type to its raw type is allowed:\n\nBox<String> stringBox = new Box<>();\nBox rawBox = stringBox;               // OK\n\nBut if you assign a raw type to a parameterized type, you get a warning:\n\nBox rawBox = new Box();           // rawBox is a raw type of Box<T>\nBox<Integer> intBox = rawBox;     // warning: unchecked conversion\n\nYou also get a warning if you use a raw type to invoke generic methods defined in the corresponding generic type:\n\nBox<String> stringBox = new Box<>();\nBox rawBox = stringBox;\nrawBox.set(8);  // warning: unchecked invocation to set(T)\n\nThe warning shows that raw types bypass generic type checks, deferring the catch of unsafe code to runtime. Therefore, you should avoid using raw types.','Generics',0,0,NULL,5),(430,'compiles fine \n\ngeneric typed objects can be assigned to raw types.','class Driver<E>{\n    \n}\nabstract class Auto{}\nclass Truck extends Auto{}\nclass Car extends Auto{}\n\npublic class Hello<T> {\n  public static void main(String[] args){\n      Driver<Truck> truckdriver = new Driver<>();\n      Driver untypeddriver = truckdriver;\n      \n      List biglist = new ArrayList<String>();\n      \n  }\n      \n}','Generics',0,0,NULL,5),(431,'compiles fine, raw type reerences that are assinged to typed objects still take objects.','public class Hello<T> {\n  public static void main(String[] args){\n      \n      List biglist = new ArrayList<String>();\n      \n      biglist.add(8);\n      biglist.add(\"bigdick\");\n      \n  }\n      \n}','Generics',0,0,NULL,5),(432,'compiles fine,  but you can still add anything to biglist','public class Hello<T> {\n  public static void main(String[] args){\n      Driver<Truck> truckdriver = new Driver<>();\n      Driver untypeddriver = truckdriver;\n      \n      List biglist = new ArrayList<Driver<Truck>>();\n      \n      biglist.add(8);\n      biglist.add(\"bigdick\");\n      \n  }\n      \n}','Generics',0,0,NULL,5),(433,'fine','public class Hello {\n  public static void main(String[] args){\n      Driver<Truck> truckdriver = new Driver();\n      \n      testmethod(new Driver<Truck>());   \n  }\n  \n  public static void testmethod(Object x){\n      // do something\n  }\n      \n}','Generics',0,0,NULL,5),(434,' You can subtype a generic class or interface by extending or implementing it. The relationship between the type parameters of one class or interface and the type parameters of another are determined by the extends and implements clauses.\n\nUsing the Collections classes as an example, ArrayList<E> implements List<E>, and List<E> extends Collection<E>. So ArrayList<String> is a subtype of List<String>, which is a subtype of Collection<String>. So long as you do not vary the type argument, the subtyping relationship is preserved between the types.\ndiagram showing a sample collections hierarchy: ArrayList<String> is a subtype of List<String>, which is a subtype of Collection<String>.\nA sample Collections hierarchy\n\nNow imagine we want to define our own list interface, PayloadList, that associates an optional value of generic type P with each element. Its declaration might look like:\n\ninterface PayloadList<E,P> extends List<E> {\n  void setPayload(int index, P val);\n  ...\n}\n\nThe following parameterizations of PayloadList are subtypes of List<String>:\n\n    PayloadList<String,String>\n    PayloadList<String,Integer>\n    PayloadList<String,Exception>\n','Generic Classes and Subtyping','Generics',0,0,NULL,5),(435,' As you already know, it is possible to assign an object of one type to an object of another type provided that the types are compatible. For example, you can assign an Integer to an Object, since Object is one of Integer\'s supertypes:\n\nObject someObject = new Object();\nInteger someInteger = new Integer(10);\nsomeObject = someInteger;   // OK\n\nIn object-oriented terminology, this is called an \"is a\" relationship. Since an Integer is a kind of Object, the assignment is allowed. But Integer is also a kind of Number, so the following code is valid as well:\n\npublic void someMethod(Number n) { /* ... */ }\n\nsomeMethod(new Integer(10));   // OK\nsomeMethod(new Double(10.1));   // OK\n\nThe same is also true with generics. You can perform a generic type invocation, passing Number as its type argument, and any subsequent invocation of add will be allowed if the argument is compatible with Number:\n\nBox<Number> box = new Box<Number>();\nbox.add(new Integer(10));   // OK\nbox.add(new Double(10.1));  // OK\n\nNow consider the following method:\n\npublic void boxTest(Box<Number> n) { /* ... */ }\n\nWhat type of argument does it accept? By looking at its signature, you can see that it accepts a single argument whose type is Box<Number>. But what does that mean? Are you allowed to pass in Box<Integer> or Box<Double>, as you might expect? The answer is \"no\", because Box<Integer> and Box<Double> are not subtypes of Box<Number>.\n\nThis is a common misunderstanding when it comes to programming with generics, but it is an important concept to learn.\ndiagram showing that Box<Integer> is not a subtype of Box<Number>\nBox<Integer> is not a subtype of Box<Number> even though Integer is a subtype of Number.\nNote: Given two concrete types A and B (for example, Number and Integer), MyClass<A> has no relationship to MyClass<B>, regardless of whether or not A and B are related. The common parent of MyClass<A> and MyClass<B> is Object.','Generics, Inheritance, and Subtypes','Generics',0,0,NULL,5),(436,'','List<? extends Integer> intList = new ArrayList<>();\nList<? extends Number>  numList = intList;  // OK. List<? extends Integer> is a subtype of List<? extends Number>','Generics',0,0,NULL,5),(437,'compilation fails,\n\ninterface methods are implicityl public abstract so when you overid them like munch in Panda you have to say\npublic . ','interface Hungry<E> { void munch(E x); }\ninterface Carnivore<E extends Animal> extends Hungry<E> { }\n\ninterface Herbivore<Plant> extends Hungry<Plant> { }\n\n\ninterface Pineavore<Pine> extends Herbivore<Plant> { }\n\n\n\nclass Panda implements Herbivore<Pine>{  \n    void munch(Pine x){\n            System.out.println(\"eat pines\");\n    };\n} \nclass Chamelion implements Herbivore<Flowers>{ \n    public void munch(Flowers x){ } \n}','Generics',0,0,NULL,5),(438,'will not compile, when you implement a generic interface, you must provide a type similarly you cannot say\nnew Thing<E>();','interface Hungry<E> { void munch(E x); }\n\nclass Driver<E> implements Hungry<T>{\n    public void munch(T food){\n        \n    }\n    \n}','Generics',0,0,NULL,5),(439,'Panda does not compile \n\ndoes not override abstract method munch(Plant) in class Hungry.\n\n	','interface Hungry<E> { void munch(E x); }\n\ninterface Herbivore<Grass> extends Hungry<Plant> { }\n\nclass Panda implements Herbivore<Grass>{  \n        public void munch(Grass x){\n            System.out.println(\"eat pines\");\n    };\n} \n\nabstract class Animal { }\nabstract class Plant { }\nclass Grass extends Plant { }','Generics',0,0,NULL,5),(440,'ArrayList','Which collection class allows you to grow or shrink its size and provide indexed access to its elements,\nbut whose methods are not synhcronized ?','Generics',0,0,NULL,5),(441,'1 ArrayList<Integer> input = null;\n   List<Integer> output = null;\n\n2 List<Number> input = null;\n    List<Number> output = null\n\n3  List<Integer> input = null\n   List<Integer> output = null;\n\n\nThe return type is List so the output has to be a list it cant be arraylist. \nwhatever the input is thats what the output will be so input and output have to be the same type\nand the type has to be something that extends Number','public static <E extends Number> List<E> process(List<E> nums)\n\n// declare input and output\n\noutput = process(input);\n\n','Generics',0,0,NULL,5),(442,'2\n2\n3 4\n\nfor the sake of the exam add and offer both add to naturally sorted collections \nso here the order becomes the natural order. \n\neven strings get sorted numerically.\n\n','public class Hello {\n  public static void main(String[] args){\n      PriorityQueue<String> pq = new PriorityQueue<String>();\n      pq.add(\"2\");\n      pq.add(\"4\");\n      System.out.println(pq.peek());\n      pq.offer(\"1\");\n      pq.add(\"3\");\n      pq.remove(\"1\");\n      System.out.println(pq.poll());\n      if(pq.remove(\"2\")) System.out.println(pq.poll());\n      System.out.println(pq.poll() + \" \" + pq.peek());\n  }\n   \n}','Generics',0,0,NULL,5),(443,'1 2 2 4 3 5 67 7 \n1 2 2 3 4 5 67 7\n\nString only looks at the first charater so 67 is the same as 6','public class Hello {\n  public static void main(String[] args){\n      PriorityQueue<String> pq = new PriorityQueue<String>();\n      pq.add(\"2\");\n      pq.add(\"4\");\n\n      pq.offer(\"1\");\n      pq.add(\"3\");\n      \n      pq.add(\"2\");\n      pq.offer(\"5\");\n      \n      pq.add(\"67\");\n      pq.add(\"7\");\n      \n      for(String x : pq)\n          System.out.print(x+\" \");\n      \n      System.out.println(\"\");\n      \n      for(int x = 0; x <8; x++)\n          System.out.print(pq.poll()+\" \");\n\n  }\n   \n}','Generics',0,0,NULL,5),(444,'2\n\nthe size is two when hashCode is implementd this imp. will place all turtles with size 1 in the same bucket\n\nsize() counts the buckets.\n\nif hashCode was not implemented then every entry would go into its own bucket and the size would be\n12\n\n','public class Hello {\n  public static void main(String[] args){\n      LinkedHashSet<Turtle> t = new LinkedHashSet<>();\n      t.add(new Turtle(1)); t.add( new Turtle(2)); t.add(new Turtle(1));\n      t.add(new Turtle(1)); t.add( new Turtle(2)); t.add(new Turtle(1));\n      t.add(new Turtle(1)); t.add(new Turtle(1)); t.add(new Turtle(1));\n      t.add(new Turtle(1)); t.add(new Turtle(1)); t.add(new Turtle(1));\n      \n      System.out.println(t.size());\n\n  }\n   \n}\n\ninterface Hungry<E> { void munch(E x); }\nabstract class Animal { }\nabstract class Plant { }\nclass Grass extends Plant { }\n\nclass Turtle {\n    int size;\n    public Turtle(int z){\n        size = z;\n    }\n    \n    public boolean equals(Object o){\n        return (this.size == ((Turtle)o).size);\n    }\n    \n    public int hashCode() { return size/5; }\n}','Generics',0,0,NULL,5),(445,'classcastexception','class Grass extends Plant { }\n\npublic class Hello {\n  public static void main(String[] args){\n     TreeSet<Grass> grassset = new TreeSet<>();\n     grassset.add(new Grass());\n\n  }\n   \n}','Generics',0,0,NULL,5),(446,'The output will contain a -1\n\n\"pen marble map key\" \n\n.binarySearch has to be invoked with the same Comparator that created it. \n	here it doesn\'t know how the array is sorted so it gives insertion point','public class GeoCache {\n	public static void main(String[ ]args) {\n		String[] s = {\"map\",\"pen\",\"marble\",\"key\"};\n		Othello o = new Othello();\n		Arrays.sort(s,o);\n		for(String s2: s) sout(s2+\" \");\n		sout( Arrays.binarySearch(s,\"map\");\n	}\n\n	static class Othello implements Comparator<String> {\n		public int compare(String a, String b) { return b.compareTo(a);l }\n	}\n}\n		','Collections',0,0,NULL,5),(447,'One good usage of inner classes that comes into my mind is in java.util.ArrayList that hides its iterators implementations into private inner classes. You can\'t create them except by invoking iterator() or listIterator() on the list object.\n\nThis way the Iterator and ListIterator implementations for ArrayList are grouped with their related class and methods for enhanced readability (the implementations are pretty short), but hidden from others.\n\nThey can\'t be declared static as they need access to their enclosing instance object.','public class ArrayList<E> extends AbstractList<E>\n         implements List<E>, RandomAccess, Cloneable, java.io.Serializable {\n    ...\n    public Iterator<E> iterator() {\n         return new Itr();\n    }\n\n    private class Itr implements Iterator<E> {\n    ...\n    }\n\n    public ListIterator<E> listIterator() {\n         return new ListItr(0);\n    }\n\n    private class ListItr extends Itr implements ListIterator<E> {\n    ...\n    }\n}','General',0,0,NULL,5),(448,'foo 7\n\ncompiles fine, you need the outer classes reference for a regular inner class\n\nthe inner class can be created as such from within the enclosing class. \n\ncould also be Inner a = new Inner();','public class Hello {\n    private int secretnum = 7;\n    \n  public static void main(String[] args){\n     Hello h = new Hello();\n     h.createInner();\n\n  }\n  \n  public void createInner(){\n      Hello.Inner a = new Hello.Inner();\n      a.foo(); a.seeOuter();\n  }\n  \n  \n  class Inner {\n      public void seeOuter(){\n          System.out.println(secretnum);\n      }\n      \n      void foo(){\n          System.out.println(\"Foo\");\n      }\n  }\n   \n}','Inner Classes',0,0,NULL,5),(449,'WNC,\n\nNo static declarations are allowed in regular inner classes unless they \nare final.\n\nThe creation of a is legal though redundant, it could have been:\n\n	Inner a = new Inner();\n','public class Hello {\n    private int secretnum = 7;\n    \n  public static void main(String[] args){\n     Hello h = new Hello();\n     h.createInner();\n\n  }\n  \n  public void createInner(){\n      Hello.Inner a = new Hello.Inner();\n      a.foo(); a.seeOuter();\n  }\n  \n  \n  class Inner {\n      private static int verysecret = 8;\n      \n      public void seeOuter(){\n          System.out.println(secretnum);\n      }\n      \n      void foo(){\n          System.out.println(\"Foo\");\n      }\n  }','Inner Classes',0,0,NULL,5),(450,'compiles fine, if an inner class is going to have static member it has to be final','public class Hello {\n    private int secretnum = 7;\n    \n  public static void main(String[] args){\n     Hello h = new Hello();\n     h.createInner();\n\n  }\n  \n  public void createInner(){\n      Hello.Inner a = new Hello.Inner();\n      a.foo(); a.seeOuter();\n  }\n  \n  \n  class Inner {\n      private static final int verysecret = 8;\n      \n      public void seeOuter(){\n          System.out.println(secretnum);\n      }\n      \n      void foo(){\n          System.out.println(\"Foo\");\n      }\n  }\n   \n}','Inner Classes',0,0,NULL,5),(451,'apple carrot orange plum\n\nwith arraylist you can add(int index, object elemetn) to a specific index','public class sequence {\n	psvm(sa){\n		ArrayList<String> list = new ArrayList<>();\n		list.add(\"apple\");\n		list.add(\"organe\");\n		list.add(\"plum\");\n		list.add(1,\"carrot\");\n		sout( list );\n	}\n}','Collections',0,0,NULL,5),(452,'will not compile,\n\ninner classes are the same as class instance variables so naturally you cannot access \nthem from a static context. ','public class Hello {\n    private int secretnum = 7;\n    \n    public static void main(String[] args){\n        Inner in = new Inner();\n\n    }\n  \n     class Inner {\n        private static final int verysecret = 8;\n        void foo(){\n          System.out.println(\"Foo\");\n        } \n  }\n   \n}','Inner Classes',0,0,NULL,5),(453,'compiles fine','public class Hello {\n    private int secretnum = 7;\n    \n    public static void main(String[] args){\n        Hello h = new Hello();\n        Hello.Inner in = h.new Inner();\n\n    }\n  \n     class Inner {\n        private static final int verysecret = 8;\n        void foo(){\n          System.out.println(\"Foo\");\n        } \n  }\n   \n}','Inner Classes',0,0,NULL,5),(454,'When instantiating from a static method You have to provide the Outer class name\n\nthe inner class is just a like an instance member. \n\nbut in the instance method its easy to create the inner class normally. \n\nits the same to create a new inner class in the static method as it is from another class.\n\n\nThis was one is also confusing because it has a mistakenly named method \nthat looks like a constructor. But its not. ','public class Hello {\n    private int secretnum = 7;\n    private static Inner inner;\n    \n    public static void main(String[] args){\n        Hello h = new Hello();\n        Hello.Inner in = h.new Inner();\n        \n        Hello.Inner in2 = h.new Inner();\n        \n        Hello.Inner in3 = new Hello().new Inner();\n        \n        inner = h.new Inner();\n        \n        //Inner a = new Inner(); this would not work\n        \n\n    }\n    \n    public void instancemaker(){\n        Inner a = new Inner();\n        System.out.println(a.verysecret);\n    }\n  \n     class Inner {\n        private static final int verysecret = 8;\n        \n        public void Inner(int x){\n            \n        }\n        void foo(){\n          System.out.println(\"Foo\");\n        } \n  }\n   \n}','Inner Classes',0,0,NULL,5),(455,'public class Hello {\n    private int secretnum = 7;\n    public static void main(String[] args) {}\n    class Inner {  private static final int verysecret = 8; }\n}\n\nclass Dog extends Hello { class Innerdog extends Inner{ } }','public class Hello {\n    private int secretnum = 7;\n    public static void main(String[] args) {}\n    class Inner {  private static final int verysecret = 8; }\n}\n\nclass Dog extends Hello.Inner {}\n\nchange this code so it compiles, and creates a class that extends Hello.Inner','Inner Classes',0,0,NULL,5),(456,'class Dog extends Hello{ class Inner extends Hello.Inner { } }','public class Hello {\n    private int secretnum = 7;\n    public static void main(String[] args) {}\n    class Inner {  private static final int verysecret = 8; }\n}\n\nclass Dog extends Hello{ class Inner extends Inner { } }\n\nthis is illegal what could make it legal ?','Inner Classes',0,0,NULL,5),(457,'good example of an anonymous inner class from opennlp','public Iterator<String> iterator() {\n    return new Iterator<String>() {\n\n      private int index;\n\n      public boolean hasNext() {\n        return index < size();\n      }\n\n      public String next() {\n\n        if (hasNext()) {\n          return getToken(index++);\n        }\n        else {\n          throw new NoSuchElementException();\n        }\n      }\n\n      public void remove() {\n        throw new UnsupportedOperationException();\n      }\n\n    };\n  }','Inner Classes',0,0,NULL,5),(458,'good example of anonymous inner class','public Iterator<String> iterator() {\n    return new Iterator<String>() {\n\n      private int index;\n\n      public boolean hasNext() {\n        return index < size();\n      }\n\n      public String next() {\n\n        if (hasNext()) {\n          return getToken(index++);\n        }\n        else {\n          throw new NoSuchElementException();\n        }\n      }\n\n      public void remove() {\n        throw new UnsupportedOperationException();\n      }\n\n    };\n  }','Inner Classes',0,0,NULL,5),(459,'fine\ngood example of;\nStringTokenizer\nBufferedReader\n\n','public static Dictionary parseOneEntryPerLine(Reader in) throws IOException {\n    BufferedReader lineReader = new BufferedReader(in);\n\n    Dictionary dictionary = new Dictionary();\n\n    String line;\n\n    while ((line = lineReader.readLine()) != null) {\n      StringTokenizer whiteSpaceTokenizer = new StringTokenizer(line, \" \");\n\n      String[] tokens = new String[whiteSpaceTokenizer.countTokens()];\n\n      if (tokens.length > 0) {\n        int tokenIndex = 0;\n        while (whiteSpaceTokenizer.hasMoreTokens()) {\n          tokens[tokenIndex++] = whiteSpaceTokenizer.nextToken();\n        }\n\n        dictionary.put(new StringList(tokens));\n      }\n    }\n\n    return dictionary;\n  }','General',0,0,NULL,5),(460,'will not compile \nreadLine() method throws IOException\n\nmust be caught or thrown!','public static Dictionary parseOneEntryPerLine(Reader in)  {\n    BufferedReader lineReader = new BufferedReader(in);\n\n    Dictionary dictionary = new Dictionary();\n\n    String line;\n\n    while ((line = lineReader.readLine()) != null) {\n      StringTokenizer whiteSpaceTokenizer = new StringTokenizer(line, \" \");\n\n      String[] tokens = new String[whiteSpaceTokenizer.countTokens()];\n\n      if (tokens.length > 0) {\n        int tokenIndex = 0;\n        while (whiteSpaceTokenizer.hasMoreTokens()) {\n          tokens[tokenIndex++] = whiteSpaceTokenizer.nextToken();\n        }\n\n        dictionary.put(new StringList(tokens));\n      }\n    }\n\n    return dictionary;\n  }','IO',0,0,NULL,5),(461,'1=Bell\n3=Whistle\n5=Nic\n\ninner classes can have static members only if they are final','public class Hello {\n    private int secretnum = 7;\n    public static void main(String[] args) {\n        Map<Integer,String> hellomap = new HashMap();\n        hellomap.put(1,\"Bell\");\n        hellomap.put(3,\"Whistle\");\n        hellomap.put(5,\"Nic\");\n        \n        for(Entry<Integer,String> x : hellomap.entrySet()){\n            System.out.println(x);\n        }\n    \n    }\n    public class Inner {  private static final int verysecret = 8; }\n}','Inner Classes',0,0,NULL,5),(462,'EvenIterator will not compile is not abstract and does not impelemnt next() in Iterator()\n\nThis shows that since DSIterator extends Iterator the first concrete class has to be the one to \nimplement the interfaces methods. ','public class Hello {\n    private final static int SIZE = 25;\n    private int[] array = new int[SIZE];\n    \n    public Hello(){\n        for(int i = 0; i<SIZE; i++){\n            array[i] = i;\n        }\n    }\n    \n    public void printEven(){\n        \n    }\n    \n    interface DSIterator extends java.util.Iterator<Integer> { }\n    \n    private class EvenIterator implements DSIterator{\n        \n    }\n    \n\n    public static void main(String[] args) {\n\n    \n    }\n\n}','General',0,0,NULL,5),(463,'will not compile print() cannot be called from a static context.','public class Hello {\n    private final static int SIZE = 100;\n    private int[] array = new int[SIZE];\n    \n    public Hello(){\n        for(int i = 0; i<SIZE; i++){\n            array[i] = i;\n        }\n    }\n    \n    public void print(){\n        ThirdIterator it = new ThirdIterator();\n        while(it.hasNext()){\n            System.out.print(it.next() +\" \");\n        }\n        \n    }\n    \n    interface DSIterator extends java.util.Iterator<Integer> { }\n    \n    private class ThirdIterator implements DSIterator{\n        private int nextIndex = 0;\n        \n        public boolean hasNext(){\n            return (nextIndex <= SIZE - 1);\n        }\n        \n        public Integer next(){\n            Integer retValue = Integer.valueOf(array[nextIndex]);\n            \n            nextIndex += 3;\n            return retValue;\n            \n        }\n        \n    }\n    \n\n    public static void main(String[] args) {\n        print();\n    \n    }\n\n}','General',0,0,NULL,5),(464,'0 3 6 9 12 15 18 21 24 27 30 33 36 39 42 45 48 51 54 57 60 63 66 69 72 75 78 81 84 87 90 93 96 99','public class Hello {\n    private final static int SIZE = 100;\n    private int[] array = new int[SIZE];\n    \n    public Hello(){\n        for(int i = 0; i<SIZE; i++){\n            array[i] = i;\n        }\n    }\n    \n    public void print(){\n        ThirdIterator it = new ThirdIterator();\n        while(it.hasNext()){\n            Object i = it.next();\n            //System.out.print(it.next() +\" \");\n        }\n        \n    }\n    \n    interface DSIterator extends java.util.Iterator { }\n    \n    private class ThirdIterator implements DSIterator{\n        private int nextIndex = 0;\n        \n        public boolean hasNext(){\n            return (nextIndex <= SIZE - 1);\n        }\n        \n        public Integer next(){\n            Integer retValue = Integer.valueOf(array[nextIndex]);\n            \n            nextIndex += 3;\n            return retValue;\n            \n        }\n        \n    }\n    \n\n    public static void main(String[] args) {\n        Hello h = new Hello();\n        h.print();\n    \n    }\n\n}','General',0,0,NULL,5),(465,'if a final variable is static it has be intitialized right away.\n\nWhere a final instance varialbe must be intitialized at some point either in the constructor or upon creation.\n\n','public class Hello {\n    private final static int SIZE;\n    private int[] array;\n    \n    public Hello(int size){\n        this.SIZE = size;\n        \n        array = new int[SIZE];\n        \n        for(int i = 0; i<SIZE; i++){\n            array[i] = i;\n        }\n    }\n}','General',0,0,NULL,5),(466,'Will not compile \n\nfinal variable SIZE is never initialized in default constructor or otherwise and this is a compilererror','public class Hello {\n    private final int SIZE;\n    private int[] array;\n    \n    public void print(){\n        ThirdIterator it = new ThirdIterator();\n        while(it.hasNext()){\n            Integer i = it.next();\n            //System.out.print(it.next() +\" \");\n        }\n        \n    }\n\n}','General',0,0,NULL,5),(467,'final Variable SIZE in Hello is not intitialized in constructor \n\ncannot assign a value to final variable SIZE in innerclass ThirdIterator\n\nnon static third iterator class cannot be referenced from static main.\n\n','public class Hello {\n    private final int SIZE;\n    private int[] array;\n    \n    interface DSIterator extends java.util.Iterator<Integer> { }\n    \n    private class ThirdIterator implements DSIterator{\n        private int nextIndex = 0;\n        public ThirdIterator(){\n            SIZE = 100;\n            for(int ix=0; ix<SIZE; ix++){\n                array[ix] = ix;\n            }\n        }\n        \n        public boolean hasNext(){\n            return (nextIndex <= SIZE - 1);\n        }\n        \n        public Integer next(){\n            Integer retValue = Integer.valueOf(array[nextIndex]);\n            \n            nextIndex += 3;\n            return retValue;\n            \n        }\n        \n    }\n    \n    private static class EveryFourth implements DSIterator{\n        private int nextIndex = 0;\n        private static final int SIZE = 1000;\n        private int[] array = new int[SIZE];\n        \n        public EveryFourth(){\n           for(int i =0; i<100; i++){\n               array[i] = i;\n           }\n        }\n        \n        public boolean hasNext(){\n            return (nextIndex <= SIZE-1);\n        }\n        \n        public Integer next() {\n            Integer retValue = Integer.valueOf(array[nextIndex]);\n            \n            nextIndex += 4;\n            return retValue;\n        }\n    }\n    \n\n    public static void main(String[] args) {\n        EveryFourth a = new EveryFourth();\n        ThirdIterator b = new ThirdIterator();\n        \n    \n    }\n\n}\n\nThere multiple problems here','Inner Classes',0,0,NULL,5),(468,'you cant do this either\nfinal variable SIZE is not instantiated on creation or in the \nconstructor. Even though it is in the ThirdIterator class\nconstructor. that does not work. ','public class Hello {\n    private final int SIZE;\n    private int[] array;\n    \n    public Hello(){\n        ThirdIterator x = new ThirdIterator();\n    }\n    \n    interface DSIterator extends java.util.Iterator<Integer> { }\n    \n    private class ThirdIterator implements DSIterator{\n        private int nextIndex = 0;\n        public ThirdIterator(){\n            SIZE = 100;\n            for(int ix=0; ix<SIZE; ix++){\n                array[ix] = ix;\n            }\n        }\n......\n.........','Inner Classes',0,0,NULL,5),(469,'compiles fine','public class Hello {\n    private final int SIZE = 100;\n    private int[] array;\n\n    interface DSIterator extends java.util.Iterator<Integer> { }\n    \n    private class ThirdIterator implements DSIterator{\n        private int nextIndex = 0;\n        public ThirdIterator(){\n            for(int ix=0; ix<SIZE; ix++){\n                array[ix] = ix;\n            }\n        }  \n        public boolean hasNext(){\n            return (nextIndex <= SIZE - 1);\n        }\n        public Integer next(){\n            Integer retValue = Integer.valueOf(array[nextIndex]); \n            nextIndex += 3;\n            return retValue;    \n        }\n    }\n    private static class EveryFourth implements DSIterator{\n        private int nextIndex = 0;\n        private static final int SIZE = 1000;\n        private int[] array = new int[SIZE];\n        public EveryFourth(){\n           for(int i =0; i<100; i++){\n               array[i] = i;\n           }\n        }\n        public boolean hasNext(){\n            return (nextIndex <= SIZE-1);\n        }\n        \n        public Integer next() {\n            Integer retValue = Integer.valueOf(array[nextIndex]);\n            \n            nextIndex += 4;\n            return retValue;\n        }\n    }\n    public static void main(String[] args) {\n        EveryFourth a = new EveryFourth();\n        Hello.ThirdIterator b = new Hello().new ThirdIterator();\n    }\n\n}','Inner Classes',0,0,NULL,5),(470,'A nested interface declared static is redundant. A nested interface is automatically static. \nstatic can be removed without and affect on semantics. Similar to public on interface methods \nor public final on interface fields. \n\nIt doen\'t change the fact that code without access to Foo wont have access to Foo.Bar interface.\n\nIt is acceptable to use if you excpect it only to be used from the enclosing class\n\npublic class Foo {\n	public interface Bar {\n		void callback();\n	}\n	public static void registerCallback(Bar bar){...}\n}\n//elsewhere\nFoo.registerCallback(new Foo.Bar() {\n	public void callback() {...}\n});','public class Hello {\n    private final int SIZE = 100;\n    private int[] array;\n\n    \n    static interface DSIterator extends java.util.Iterator<Integer> { }\n    \n    private class ThirdIterator implements DSIterator{\n        private int nextIndex = 0;\n        public ThirdIterator(){\n            for(int ix=0; ix<SIZE; ix++){\n                array[ix] = ix;\n            }\n        }\n        \n        public boolean hasNext(){\n            return (nextIndex <= SIZE - 1);\n        }\n        \n     ......','Inner Classes',0,0,NULL,5),(471,'does not compile without outer reference for inner interface.\n\nshould be:\n\n	class Dog implements Hello.Petable {\n    \n ','public class Hello {\n    private final int SIZE = 100;\n    private int[] array;\n\n    \n    interface DSIterator extends java.util.Iterator<Integer> { }\n    \n    interface Petable {\n        void speak();\n        void wag();\n    }\n    \n    private class ThirdIterator implements DSIterator{\n        private int nextIndex = 0;\n        public ThirdIterator(){\n            for(int ix=0; ix<SIZE; ix++){\n                array[ix] = ix;\n            }\n        }\n        \n        public boolean hasNext(){\n            return (nextIndex <= SIZE - 1);\n        }\n        \n        public Integer next(){\n            Integer retValue = Integer.valueOf(array[nextIndex]);\n            \n            nextIndex += 3;\n            return retValue;\n            \n        }\n        \n    }\n    \n    private static class EveryFourth implements DSIterator{\n        private int nextIndex = 0;\n        private static final int SIZE = 1000;\n        private int[] array = new int[SIZE];\n        \n        public EveryFourth(){\n           for(int i =0; i<100; i++){\n               array[i] = i;\n           }\n        }\n        \n        public boolean hasNext(){\n            return (nextIndex <= SIZE-1);\n        }\n        \n        public Integer next() {\n            Integer retValue = Integer.valueOf(array[nextIndex]);\n            \n            nextIndex += 4;\n            return retValue;\n        }\n    }\n    \n\n    public static void main(String[] args) {\n        \n        EveryFourth a = new EveryFourth();\n        Hello.ThirdIterator b = new Hello().new ThirdIterator();\n        \n    \n    }\n\n}\n\nclass Dog implements Petable {\n    \n    public void bark(){\n        \n    }\n\n    @Override\n    public void speak() {\n        throw new UnsupportedOperationException(\"Not supported yet.\"); //To change body of generated methods, choose Tools | Templates.\n    }\n\n    @Override\n    public void wag() {\n        throw new UnsupportedOperationException(\"Not supported yet.\"); //To change body of generated methods, choose Tools | Templates.\n    }\n    \n}','Inner Classes',0,0,NULL,5),(472,'how to instantiate an inner class object from outside the outter class instance code.','class MyOuter{\n	private int x = 7;\n\n	class MyInner{\n	public void seeOuter(){\n		sout( x );\n	}\n\n}\n\nclass OCP{\n	public static void main(SA){\n		MyOuter mo = new MyOuter();\n		MYOuter.MyInner inner = mo.new MyInner();\n		inner.seeOuter();\n	}\n}','Inner Classes',0,0,NULL,5),(473,'one liner','psvm(SA){\n	MyOuter.MyInner inner = new MyOuter().new MyInner();\n	inner.seeOuter();\n}','Inner Classes',0,0,NULL,5),(474,'\n	The rules for an inner class to reference itself or the outer class instance are as follows:\n\n	To reference the inner class instance itself from within the inner class code,\n		use this\n\n	toreference the \"outer this\" from within the inner class code,\n		use MyOuter.this.','class MyOuter{\n    private int x = 7;\n    public void makeInner() {\n        MyInner in = new MyInner();\n       in.seeOuter();\n   }\n\n    class MyInner {	\n           public void seeOuter {\n	sout( \"Outer x is \" + x );\n	sout(\"Inner class ref is \" + this);\n	sout( \"Outer class ref is \" + MyOuter.this );\n            }\n}\n\n      psvm(sa) {\n	MyOuter.MyInner inner = new MyOuter().new MyInner();\n	inner.seeOuter();\n     }\n}\n		','Inner Classes',0,0,NULL,5),(475,'final\nabstract\npublic \nprivate\nprotected\nstatic\nstrictfp','what member modifiers can be applied to an inner class	','Inner Classes',0,0,NULL,5),(476,'How to properly use a method local inner class','class MyOuter2 {\n	private String x = \"Outer2\";\n	void doStuff() {\n	        class MyInner {\n		public void seeOuter() {\n	                               sout(\" outer x is \" + x );\n		}\n	        }\n	\n	MyInner mi = new MyInner(); // THIS LINE MUST COME AFTER THE CLASS\n\n	mi.seeOuter();\n	}\n}\n\n	','Inner Classes',0,0,NULL,5),(477,'WayInner: 7\n\nthe proper way to use a method local inner ','public class Hello {\n   \n    public static void main(String[] args) {\n        Hello h = new Hello();\n        h.methodlocal();\n    }\n    \n    public void methodlocal(){\n        \n        class WayInner {\n            private int size;\n        \n            public WayInner(int x){ size = x;}\n            public void printDetail(){\n                System.out.println(\"WayInner: \"+ size);\n            }\n        }\n        \n        WayInner a = new WayInner(7);\n        a.printDetail();\n    }\n\n}','Inner Classes',0,0,NULL,5),(478,'will not compile in java 7. \n\nlocal varialbe cannot be accesed from within inner class. \n\nLocal varialbe exist on the stack and only exist for the lifetime of the method. \n\nwhen the method ends the local varialbes are destroyed, however the inner class object might still live on\n ','public class Hello {\n   \n    public static void main(String[] args) {\n        Hello h = new Hello();\n        h.methodlocal();\n    }\n    \n    public void methodlocal(){\n        int y = 56;\n        \n        class WayInner {\n            public int size;\n        \n            public WayInner(int x){ size = x;}\n            public void printDetail(){\n                System.out.println(\"WayInner: \"+ size);\n            }\n            \n            public void showall(){\n                System.out.println(size+\" \"+y);\n            }\n        }\n        \n        WayInner a = new WayInner(7);\n        a.printDetail();\n        a.showall();\n        \n    }\n\n}','Inner Classes',0,0,NULL,5),(479,'will compile method local inner class can only access local variables if they are marked final.','public class Hello {\n   \n    public static void main(String[] args) {\n        Hello h = new Hello();\n        h.methodlocal();\n    }\n    \n    public void methodlocal(){\n        final int y = 56;\n        \n        class Zombie {\n            public int size;\n        \n            public Zombie(int x){ size = x;}\n            public void mone(){\n                System.out.println(\"ughhhg: \"+ size);\n            }\n            \n            public void accessTheLiving(){\n                System.out.println(\"local var: \"+y);\n            }\n            \n        }\n        \n        Zombie zom = new Zombie(7);\n        \n    }\n\n}','Inner Classes',0,0,NULL,5),(480,'will not compile method local inner classes cannot be marked public private protected static or transient.','public class Hello {\n   \n    public static void main(String[] args) {\n        Hello h = new Hello();\n        h.methodlocal();\n    }\n    \n    public void methodlocal(){\n        final int y = 56;\n        \n        protected class Zombie {\n            public int size;\n        \n            public Zombie(int x){ size = x;}\n            public void mone(){\n                System.out.println(\"ughhhg: \"+ size);\n            }\n            \n            public void accessTheLiving(){\n                System.out.println(\"local var: \"+y);\n            }\n            \n        }\n        \n        Zombie zom = new Zombie(7);\n        \n    }\n\n}','Inner Classes',0,0,NULL,5),(481,'will not compile ML inner class cannot be marked static. ','public class Hello {\n   \n    public static void main(String[] args) {\n        Hello h = new Hello();\n        h.methodlocal();\n    }\n    \n    public void methodlocal(){\n        final int y = 56;\n        \n        static class Zombie {\n            public int size;\n        \n            public Zombie(int x){ size = x;}\n            public void mone(){\n                System.out.println(\"ughhhg: \"+ size);\n            }\n            \n            public void accessTheLiving(){\n                System.out.println(\"local var: \"+y);\n            }\n            \n        }\n        \n        Zombie zom = new Zombie(7);\n        \n    }\n\n}','Inner Classes',0,0,NULL,5),(482,'will not compile \n\nillegal static declaration in method local inner class. ','public class Hello {\n   \n    public static void main(String[] args) {\n        Hello h = new Hello();\n        h.methodlocal();\n    }\n    \n    public void methodlocal(){\n        final int y = 56;\n        \n        class Zombie {\n            public int size;\n        \n            public Zombie(int x){ size = x;}\n            public static void mone(){\n                System.out.println(\"ughhhg: \"+ size);\n            }\n            \n            public void accessTheLiving(){\n                System.out.println(\"local var: \"+y);\n            }\n            \n        }\n        \n        Zombie zom = new Zombie(7);\n        \n    }\n\n}','Inner Classes',0,0,NULL,5),(483,'will not compile\n\nillegal modifier static is only allowed in constant decalartations. \n\nto compile make num final','public class Hello {\n   \n    public static void main(String[] args) {\n        Hello h = new Hello();\n        h.methodlocal();\n    }\n    \n    public void methodlocal(){\n        final int y = 56;\n        \n        \n        class Zombie {\n            public int size;\n            public static int num = 5;\n        \n            public Zombie(int x){ size = x;}\n            public void mone(){\n                System.out.println(\"ughhhg: \"+ size);\n            }\n            \n            public void accessTheLiving(){\n                System.out.println(\"local var: \"+y);\n            }\n            \n        }\n        \n        Zombie zom = new Zombie(7);\n        \n    }\n\n}','Inner Classes',0,0,NULL,5),(484,'compiles fine.\n\nto use static in an inner class it must be marked final','public class Hello {\n   \n    public static void main(String[] args) {\n        Hello h = new Hello();\n        h.methodlocal();\n    }\n    \n    public void methodlocal(){\n        final int y = 56;\n        \n        \n        class Zombie {\n            public int size;\n            public static final int num = 5;\n        \n            public Zombie(int x){ size = x;}\n            public void mone(){\n                System.out.println(\"ughhhg: \"+ size);\n            }\n            \n            public void accessTheLiving(){\n                System.out.println(\"local var: \"+y);\n            }\n            \n        }\n        \n        Zombie zom = new Zombie(7);\n        \n    }\n\n}','Inner Classes',0,0,NULL,5),(485,'','For inner classes \'static\' is only allowed for constant variable declarations. ','Inner Classes',0,0,NULL,5),(486,'does not compile, \n\neven if the method is static ML innner class cannot decalre staic unless it is a static final constant. ','public class Hello {\n   \n    public static void main(String[] args) {\n        Hello h = new Hello();\n        h.methodlocal();\n    }\n    \n    public static void methodlocal(){\n        final int y = 56;\n        \n        \n        class Zombie {\n            public int size;\n            public static final int num = 5;\n        \n            public Zombie(int x){ size = x;}\n            public static final void mone(){\n                System.out.println(\"ughhhg: \"+ size);\n            }\n            \n            public void accessTheLiving(){\n                System.out.println(\"local var: \"+y);\n            }\n            \n        }\n        \n        Zombie zom = new Zombie(7);\n        \n    }\n\n}','Inner Classes',0,0,NULL,5),(487,'does not compile\n\na MLIC declared in a static method cannot access instance varialbes of the outerclass. \n\nso\n sout(name) does not compile here. \n\nit can however access those static variables, if it was just the statics \nit would print:\n\n	Gemini\n	Gemini\n	Eunech','public class Hello {\n    private String name = \"marco\";\n    private final static String gem = \"Gemini\";\n    private static String west = \"Eunech\";\n   \n    public static void main(String[] args) {\n        Hello h = new Hello();\n        h.methodlocal();\n    }\n    \n    public static void methodlocal(){\n        final int y = 56;\n        //System.out.println(name); //wouldnt compile\n        System.out.println(gem);\n        \n        \n        class Zombie {\n            public int size;\n            public static final int num = 5;\n        \n            public Zombie(int x){ size = x; System.out.println(gem); System.out.println(west); System.out.println(name); }\n            public void mone(){\n                System.out.println(\"ughhhg: \"+ size);\n            }\n            \n            public void accessTheLiving(){\n                System.out.println(\"local var: \"+y);\n            }\n            \n        }\n        \n        Zombie zom = new Zombie(7);\n        \n    }\n\n}','Inner Classes',0,0,NULL,5),(488,'this compiles fine \nMLIC in a instance method can access both static and instance variables','public class Hello {\n    private String name = \"marco\";\n    private final static String gem = \"Gemini\";\n    private static String west = \"Eunech\";\n   \n    public static void main(String[] args) {\n        Hello h = new Hello();\n        h.methodlocal();\n    }\n    \n    public void methodlocal(){\n        final int y = 56;\n        //System.out.println(name); //wouldnt compile\n        System.out.println(gem);\n        \n        \n        class Zombie {\n            public int size;\n            public static final int num = 5;\n        \n            public Zombie(int x){ size = x; System.out.println(gem); System.out.println(west); System.out.println(name); }\n            public void mone(){\n                System.out.println(\"ughhhg: \"+ size);\n            }\n            \n            public void accessTheLiving(){\n                System.out.println(\"local var: \"+y);\n            }\n            \n        }\n        \n        Zombie zom = new Zombie(7);\n        \n    }\n\n}','Inner Classes',0,0,NULL,5),(489,'h.buck() will not compile because you can only call the superclasses methods on a polymorphic reference','class Horse extends Animal {\n        void buck() { }\n}\n\nclass Animal {\n        void eat() { }\n}\nclass Test {\n        public static void main(String[] atrgs) {\n	Animal h = new Horse();\n	h.eat();\n	h.buck();\n       }\n}	','Inner Classes',0,0,NULL,5),(490,'here smalls.actFly() compiles \n\nhowever, getLoot() is defined in the anonyous subclass so polynorphically it cannot compile.\n\nThe only way to use methods declared in the anonymous subclass is to override methods of \nthe super class where overriding rules still apply. ','public class Hello {\n   \n    public static void main(String[] args) {\n        Biggie smalls = new Biggie(){\n            public void getLoot(){\n                System.out.println(\"Gimmie the loot!\");\n            }\n            \n        };\n        \n        smalls.actFly();\n        smalls.getLoot();\n        \n      \n    }\n\n}\n\nclass Biggie {\n    public void actFly(){\n        System.out.println(\"Shit so fly\");\n    }\n    public static void getPaid(){\n        System.out.println(\"Its so easy!\");\n    }\n    public int getFemaleDigits(){\n        return 5556784;\n    }\n}','Inner Classes',0,0,NULL,5),(491,'proper override','public class Hello {\n   \n    public static void main(String[] args) {\n        Biggie smalls = new Biggie(){\n            private void getLoot(){\n                System.out.println(\"Gimmie the loot!\");\n            }\n            \n            public void actFly(){\n                System.out.println(\"Still acting fly\");\n            }\n            \n        };\n        \n        smalls.actFly();\n        smalls.actFly();\n    }\n\n}\n\nclass Biggie {\n    public void actFly(){\n        System.out.println(\"Shit so fly\");\n    }\n    public static void getPaid(){\n        System.out.println(\"Its so easy!\");\n    }\n    public int getFemaleDigits(){\n        return 5556784;\n    }\n}','Inner Classes',0,0,NULL,5),(492,'will not compile override methods cannot return a different type unless its a subtype','public class Hello {\n   \n    public static void main(String[] args) {\n        Biggie smalls = new Biggie(){\n            private void getLoot(){\n                System.out.println(\"Gimmie the loot!\");\n            }\n            \n            public int actFly(){\n                int x = 66;\n                System.out.println(\"Still acting fly\");\n                return x;\n            }\n            \n        };\n        \n        smalls.actFly();\n        smalls.actFly();\n    }\n\n}\n\nclass Biggie {\n    public void actFly(){\n        System.out.println(\"Shit so fly\");\n    }\n    public static void getPaid(){\n        System.out.println(\"Its so easy!\");\n    }\n    public int getFemaleDigits(){\n        return 5556784;\n    }\n}','Inner Classes',0,0,NULL,5),(493,'this will compile just fine. \n\nan override method is allowed to have less reestricted access but not more,\n\nan override method must have the same return type or it can return a subclass. ','public class Hello {\n   \n    public static void main(String[] args) {\n        Biggie smalls = new Biggie(){\n            private void getLoot(){\n                System.out.println(\"Gimmie the loot!\");\n            }\n            \n            public void actFly(){\n                System.out.println(\"Still acting fly\");\n            }\n            \n            public Integer getFemalDigits(){\n                return 5671123;\n            }  \n        };\n        \n        smalls.actFly();\n        smalls.actFly();\n    }\n\n}\n\nclass Biggie {\n    protected void actFly(){\n        System.out.println(\"Shit so fly\");\n    }\n    public static void getPaid(){\n        System.out.println(\"Its so easy!\");\n    }\n    public Number getFemaleDigits(){\n        return 5556784;\n    }\n}','Inner Classes',0,0,NULL,5),(494,'will not compile, \n\nyou cannot override a method marked static. \n\nThe only way you could make this work is by making getPaid in the anonymous\nclass static which would \'hide\' the superclass static method not override it.\n\nunfortuanlytel you cannot put a static method in an anonymous class. \n\n\n\nOver-riding basically supports late binding . Therefore, which method will be called is decided at run time.It is for non-static methods. Hiding is for all other members (static methods , instance members, static members). It is based on the early binding . More clearly , the method or member to be called or used is decided during compile time.\n\nIn your example, the first call , Animal.testClassMethod() is a call to a static method,hence, it is pretty sure as to which method is going to be called.\n\nIn the second call,myAnimal.testInstanceMethod(), it calls a non-static method. It is what you call run-time polymorphism. It is not decided until run time which method is to be called.\n\nFor further clarification, read this.\n','public class Hello {\n   \n    public static void main(String[] args) {\n        Biggie smalls = new Biggie(){\n            private void getLoot(){\n                System.out.println(\"Gimmie the loot!\");\n            }\n            \n            public void actFly(){\n                System.out.println(\"Still acting fly\");\n            }\n            \n            public Integer getFemalDigits(){\n                return 5671123;\n            }  \n            \n            public void getPaid(){\n                System.out.println(\"Boy I get money!\");\n            }\n        };\n        \n        smalls.actFly();\n        smalls.actFly();\n    }\n\n}\n\nclass Biggie {\n    protected void actFly(){\n        System.out.println(\"Shit so fly\");\n    }\n    public static void getPaid(){\n        System.out.println(\"Its so easy!\");\n    }\n    public Number getFemaleDigits(){\n        return 5556784;\n    }\n}','Inner Classes',0,0,NULL,5),(495,'Will not compile\n\nstatic definitions not allowed in inner classes except for constant varaible definintions. ','public class Hello {\n   \n    public static void main(String[] args) {\n        Biggie smalls = new Biggie(){\n            private void getLoot(){\n                System.out.println(\"Gimmie the loot!\");\n            }\n            \n            public void actFly(){\n                System.out.println(\"Still acting fly\");\n            }\n            \n            public Integer getFemalDigits(){\n                return 5671123;\n            }  \n            \n            public static void getPaid(){\n                System.out.println(\"Boy I get money!\");\n            }\n        };\n        \n        smalls.actFly();\n        smalls.actFly();\n    }\n\n}\n\nclass Biggie {\n    protected void actFly(){\n        System.out.println(\"Shit so fly\");\n    }\n    public static void getPaid(){\n        System.out.println(\"Its so easy!\");\n    }\n    public Number getFemaleDigits(){\n        return 5556784;\n    }\n}','Inner Classes',0,0,NULL,5),(496,'this compiles fine,\n\n','class Biggie {\n    public static int thashitt = 568;\n    protected void actFly(){\n        System.out.println(\"Shit so fly\");\n    }\n    public static void getPaid(){\n        System.out.println(\"Its so easy!\");\n    }\n    public Number getFemaleDigits(){\n        return 5556784;\n    }\n}\n\nclass Benzino extends Biggie{\n    \n    public void printThaShitt(){\n        System.out.println(thashitt);\n    }\n    \n    public static void getPaid(){\n        System.out.println(\"It\'s somewhat difficult\");\n    }\n    \n    public Integer getFemaleDigits(){\n        return null;\n    }\n    \n}','Inner Classes',0,0,NULL,5),(497,'Still acting fly\n5671123\nIts so easy!\n\nthe reference smalls is of type anonymous class so its methods are theoverriden methods in the anonymous \nclass\n\nwhen getPaid() is called on benz you are accessing a static method from a reference variable, so \nthe Biggie version is used because thats the type of the reference variable, \n\nstatic methods cannot be overridden but they can be hidden. ','public class Hello {\n   \n    public static void main(String[] args) {\n        Biggie smalls = new Biggie(){\n            private void getLoot(){\n                System.out.println(\"Gimmie the loot!\");\n            }\n            \n            public void actFly(){\n                System.out.println(\"Still acting fly\");\n            }\n            \n            public Integer getFemaleDigits(){\n                return 5671123;\n            }  \n\n        };\n        \n        smalls.actFly();\n        System.out.println(smalls.getFemaleDigits());\n        \n        Biggie benz = new Benzino();\n        benz.getPaid();\n    }\n\n}\n\nclass Biggie {\n    public static int thashitt = 568;\n    protected void actFly(){\n        System.out.println(\"Shit so fly\");\n    }\n    public static void getPaid(){\n        System.out.println(\"Its so easy!\");\n    }\n    public Number getFemaleDigits(){\n        return 5556784;\n    }\n}\n\nclass Benzino extends Biggie{\n    \n    public void printThaShitt(){\n        System.out.println(thashitt);\n    }\n    \n    public static void getPaid(){\n        System.out.println(\"It\'s somewhat difficult\");\n    }\n    \n    public Integer getFemaleDigits(){\n        return null;\n    }\n    \n}','Inner Classes',0,0,NULL,5),(498,'Still acting fly\n5671123\nIt\'s somewhat difficult','public class Hello {\n   \n    public static void main(String[] args) {\n        Biggie smalls = new Biggie(){\n            private void getLoot(){\n                System.out.println(\"Gimmie the loot!\");\n            }\n            \n            public void actFly(){\n                System.out.println(\"Still acting fly\");\n            }\n            \n            public Integer getFemaleDigits(){\n                return 5671123;\n            }  \n\n        };\n        \n        smalls.actFly();\n        System.out.println(smalls.getFemaleDigits());\n        \n        Benzino benz = new Benzino();\n        benz.getPaid();\n    }\n\n}\n\nclass Biggie {\n    public static int thashitt = 568;\n    protected void actFly(){\n        System.out.println(\"Shit so fly\");\n    }\n    public static void getPaid(){\n        System.out.println(\"Its so easy!\");\n    }\n    public Number getFemaleDigits(){\n        return 5556784;\n    }\n}\n\nclass Benzino extends Biggie{\n    \n    public void printThaShitt(){\n        System.out.println(thashitt);\n    }\n    \n    public static void getPaid(){\n        System.out.println(\"It\'s somewhat difficult\");\n    }\n    \n    public Integer getFemaleDigits(){\n        return null;\n    }\n    \n}','Inner Classes',0,0,NULL,5),(499,'p.pop(); is ok because popcorn has a pop method\n\np.sizzle();  is illegal because popcorn does not have sizzle().\n\n','class Popcorn {\n	public void pop(){\n		sout(\"popcorn\");\n	}\n}\n\nclass Food {\n	Popcorn p = new Popcorn() {\n		public void sizzle(){\n			sout(\"anonymouse sizzling popcorn\");\n		}\n\n		public void pop(){\n			sout(\"anonumous popcorn\");\n		}\n	};\n\n	public void popIt(){\n		p.pop();\n		p.sizzle();\n	}\n}','Inner Classes',0,0,NULL,5),(500,'will not compile class Benzino does not have that method. ','public class Hello {\n   \n    public static void main(String[] args) {\n        Biggie benz = new Benzino();\n        benz.printThaShitt();\n    }\n\n}\n\nclass Biggie {\n    public static int thashitt = 568;\n    protected void actFly(){\n        System.out.println(\"Shit so fly\");\n    }\n    public static void getPaid(){\n        System.out.println(\"Its so easy!\");\n    }\n    public Number getFemaleDigits(){\n        return 5556784;\n    }\n}\n\nclass Benzino extends Biggie{\n    \n    public void printThaShitt(){\n        System.out.println(thashitt);\n        getPaid();\n        super.getPaid();\n        Biggie.getPaid();\n    }\n    \n    public static void getPaid(){\n        System.out.println(\"It\'s somewhat difficult\");\n    }\n    \n    public Integer getFemaleDigits(){\n        return null;\n    }\n    \n}','Inner Classes',0,0,NULL,5),(501,'568\nIt\'s somewhat difficult\nIts so easy!\nIts so easy!\n\n\ngetPaid() is used plainly as is it calls Benzinos static method, \n\nall the others access the super class. \n\nStatic variables in Java are not inherited, they exist only in the class which declares them; \nhowever, they can be accessed implicitly by referring to an instance or subclass (or subclass instance) of the class which defines the \nstatic variable. \n(Static variable handling is one of the few confusing parts of the Java language, IMHO.)','public class Hello {\n   \n    public static void main(String[] args) {\n        Benzino benz = new Benzino();\n        benz.printThaShitt();\n    }\n\n}\n\nclass Biggie {\n    public static int thashitt = 568;\n    protected void actFly(){\n        System.out.println(\"Shit so fly\");\n    }\n    public static void getPaid(){\n        System.out.println(\"Its so easy!\");\n    }\n    public Number getFemaleDigits(){\n        return 5556784;\n    }\n}\n\nclass Benzino extends Biggie{\n    \n    public void printThaShitt(){\n        System.out.println(thashitt);\n        getPaid();\n        super.getPaid();\n        Biggie.getPaid();\n    }\n    \n    public static void getPaid(){\n        System.out.println(\"It\'s somewhat difficult\");\n    }\n    \n    public Integer getFemaleDigits(){\n        return null;\n    }\n    \n}\n','Inner Classes',0,0,NULL,5),(502,'this shows that static methods can be overloaded','public class Test {\n    public static void foo() {\n        System.out.println(\"Test.foo() called \");\n    }\n    public static void foo(int a) { \n        System.out.println(\"Test.foo(int) called \");\n    }\n    public static void main(String args[])\n    { \n        Test.foo();\n        Test.foo(10);\n    }\n}','Inner Classes',0,0,NULL,5),(503,'will not compile, you cannot overload based on static keyword alone','public class Test {\n    public static void foo() {\n        System.out.println(\"Test.foo() called \");\n    }\n    public void foo() { \n        System.out.println(\"Test.foo(int) called \");\n    }\n    public static void main(String args[]) { \n        Test.foo();\n    }\n}','Inner Classes',0,0,NULL,5),(504,'will not compile, \n\nanonymous class of stick is not abstract and does not overrride interface\nmethods\n\n','public class Hello {\n\n   \n    public static void main(String[] args) {\n        Burnable stick = new Burnable(){\n            \n        };\n    }\n\n}\n\ninterface Burnable{\n    int people = 10;\n    void burn();\n    void shakeoff();\n    int unburn();\n    \n}','Inner Classes',0,0,NULL,5),(505,'does not compile, \n\nanonymous subclass does not impelement all abstract methods ','public class Hello {\n\n   \n    public static void main(String[] args) {\n        Burnable stick = new Burnable(){\n            public void burn(){\n                System.out.println(\"Theres \"+people+\" people here so get the fire going\");\n            }\n            \n        };\n    }\n\n}\n\ninterface Burnable{\n    int people = 10;\n    void burn();\n    void shakeoff();\n    int unburn();\n    \n}','Inner Classes',0,0,NULL,5),(506,'This type of anonomuous inner class implemtents an interface\n\nThis is the only time you can use new with an interface.\n\nIt compiles because all of the abstract methods are implemented\n\n','public class Hello {\n\n    public static void main(String[] args) {\n        \n        Burnable stick = new Burnable(){\n            public void burn(){\n                System.out.println(\"Theres \"+people+\" people here so get the fire going\");\n            }\n            \n            public int unburn(){\n                System.out.println(\"That\'s impossible\");\n                return 0;\n            }\n            \n            public void shakeoff(){\n                System.out.println(\"That was my shoe!\");\n            }\n            \n        };\n    }\n\n}\n\ninterface Burnable{\n    int people = 10;\n    void burn();\n    void shakeoff();\n    int unburn();\n}\n','Inner Classes',0,0,NULL,5),(507,'will not compile interfaces are 100% abstract, they can have nothing\nconcrete','interface Burnable{\n    int people = 10;\n    void burn();\n    void shakeoff();\n    int unburn();\n    void people(){\n        System.out.println(people+\" \");\n    }\n}','Inner Classes',0,0,NULL,5),(508,'Theres 8 people here so get the fire going','public class Hello {\n\n    public static void main(String[] args) {\n        \n        Burnable stick = new Burnable(){\n            int people = 8;\n            public void burn(){\n                System.out.println(\"Theres \"+people+\" people here so get the fire going\");\n            }\n            \n            public int unburn(){\n                System.out.println(\"That\'s impossible\");\n                return 0;\n            }\n            \n            public void shakeoff(){\n                System.out.println(\"That was my shoe!\");\n            }\n            \n        };\n        \n        stick.burn();\n    }\n\n}\n\ninterface Burnable{\n    int people = 10;\n    void burn();\n    void shakeoff();\n    int unburn();\n}\n','Inner Classes',0,0,NULL,5),(509,'Will not compile, shakeoff() is overloaded in anonymous subclass. \n\nThe overload is legal using it outside the inner class is not\n\nthat method is an overload it is created in the anonnymous subclass and\ncant be used on the Burnable refernence','public class Hello {\n\n    public static void main(String[] args) {\n        \n        Burnable stick = new Burnable(){\n            int people = 8;\n            public void burn(){\n                System.out.println(\"Theres \"+people+\" people here so get the fire going\");\n            }\n            \n            public int unburn(){\n                System.out.println(\"That\'s impossible\");\n                return 0;\n            }\n            \n            public void shakeoff(int x){\n                System.out.println(\"That was my shoe!\"+x);\n            }\n            \n            public void shakeoff(){\n                System.out.println(\"its off\");\n            }\n            \n            \n            \n        };\n        \n        stick.burn();\n        stick.shakeoff();\n    }\n\n}\n\ninterface Burnable{\n    int people = 10;\n    void burn();\n    void shakeoff(int z);\n    int unburn();\n}','Inner Classes',0,0,NULL,5),(510,'gimmie all the balls!','public class Hello {\n\n    public static void main(String[] args) {\n        Gym.BasketBallCourt bc = new Gym.BasketBallCourt();\n        bc.collectBalls();\n    }\n\n}\n\nclass Gym{\n    public int weights = 8000;\n    public String name = \"Max\'s gym\";\n    public int price = 50;\n    \n    public void pitch(){\n        System.out.println(\"Were the best gym\");\n    }\n    \n    static class BasketBallCourt {\n        private int courts = 2;\n        \n        public void collectBalls(){\n            System.out.println(\"gimmmie all the balls!\");\n        }\n        \n        public int Scoreboard(){\n            return 114;\n        }\n    }\n}','Inner Classes',0,0,NULL,5),(511,'will not compile, static classes are like static members of the enclosing\nclass they cannot access instance varialbes','class Gym{\n    public int weights = 8000;\n    public String name = \"Max\'s gym\";\n    public int price = 50;\n    \n    public void pitch(){\n        System.out.println(\"Were the best gym\");\n    }\n    \n    static class BasketBallCourt {\n        private int courts = 2;\n        \n        public void collectBalls(){\n            System.out.println(\"gimmmie all the balls!\");\n        }\n        \n        public void gymPrice(){\n            System.out.println(name+\" \"+price);\n        }\n        \n        public int Scoreboard(){\n            return 114;\n        }\n    }','Inner Classes',0,0,NULL,5),(512,'This compiles fine static inner classes can have static fields and methods\n','class Gym{\n    public int weights = 8000;\n    public String name = \"Max\'s gym\";\n    public int price = 50;\n    \n    public void pitch(){\n        System.out.println(\"Were the best gym\");\n    }\n    \n    static class BasketBallCourt {\n        private static int courts = 2;\n        \n        public void collectBalls(){\n            System.out.println(\"gimmmie all the balls!\");\n        }\n        \n        public void gymPrice(){\n            Gym g = new Gym();\n            System.out.println(g.price);\n        }\n        \n        public int Scoreboard(){\n            return 114;\n        }\n    }\n}','Inner Classes',0,0,NULL,5),(513,'this compiles fine, shows how to properly instantiate static nested clases','public class Hello {\n\n    public static void main(String[] args) {\n        Gym.BasketBallCourt bc = new Gym.BasketBallCourt();\n        bc.collectBalls();\n    }\n\n}\n\nclass Gym{\n    public int weights = 8000;\n    public String name = \"Max\'s gym\";\n    public int price = 50;\n    \n    public void pitch(){\n        BasketBallCourt bc = new BasketBallCourt();\n        System.out.println(\"Were the best gym\");\n        System.out.println(\"Our court is huge too! \"+bc.courts());\n    }\n    \n    static class BasketBallCourt {\n        private static int courts = 2;\n        \n        public static void collectBalls(){\n            System.out.println(\"gimmmie all the balls!\");\n        }\n        public int courts(){\n            return courts;\n        }\n        \n        public void gymPrice(){\n            Gym g = new Gym();\n            System.out.println(g.price);\n        }\n        \n        public int Scoreboard(){\n            return 114;\n        }\n    }\n}','Inner Classes',0,0,NULL,5),(514,'will not compile, that is not the right instantiation of a static nested class','public class Hello {\n\n    public static void main(String[] args) {\n        Gym.BasketBallCourt bc = new Gym.BasketBallCourt();\n        Gym g = new Gym();\n        \n        Gym.BasketBallCourt bc3 = g.new BasketBallCourt();\n        \n        g.pitch();\n        \n    }\n\n}\n\nclass Gym{\n    public int weights = 8000;\n    public String name = \"Max\'s gym\";\n    public int price = 50;\n    \n    public void pitch(){\n        BasketBallCourt bc = new BasketBallCourt();\n        System.out.println(\"Were the best gym\");\n        System.out.println(\"Our court is huge too! \"+bc.courts());\n    }\n    \n    static class BasketBallCourt {\n        private static int courts = 2;\n        \n        public static void collectBalls(){\n            System.out.println(\"gimmmie all the balls!\");\n        }\n        public int courts(){\n            return courts;\n        }\n        \n        public void gymPrice(){\n            Gym g = new Gym();\n            System.out.println(g.price);\n        }\n        \n        public int Scoreboard(){\n            return 114;\n        }\n    }\n}','Inner Classes',0,0,NULL,5),(515,'114\ngimmie all the balls','public class Hello {\n\n    public static void main(String[] args) {\n        Gym.BasketBallCourt bc = new Gym.BasketBallCourt();\n        Gym g = new Gym();\n        \n        Gym.BasketBallCourt bc3 = new Gym.BasketBallCourt();\n        \n        bc3.Scoreboard();\n        \n        Gym.BasketBallCourt.collectBalls();\n        \n    }\n\n}\n\nclass Gym{\n    public int weights = 8000;\n    public String name = \"Max\'s gym\";\n    public int price = 50;\n    \n    public void pitch(){\n        BasketBallCourt bc = new BasketBallCourt();\n        System.out.println(\"Were the best gym\");\n        System.out.println(\"Our court is huge too! \"+bc.courts());\n    }\n    \n    static class BasketBallCourt {\n        private static int courts = 2;\n        \n        public static void collectBalls(){\n            System.out.println(\"gimmmie all the balls!\");\n        }\n        public int courts(){\n            return courts;\n        }\n        \n        public void gymPrice(){\n            Gym g = new Gym();\n            System.out.println(g.price);\n        }\n        \n        public int Scoreboard(){\n            return 114;\n        }\n    }\n}','Inner Classes',0,0,NULL,5),(516,'114','public class Hello {\n\n    public static void main(String[] args) {\n        Gym.BasketBallCourt gbg = new Gym().new BasketBallCourt();\n        System.out.println(gbg.Scoreboard());\n        \n    }\n\n}\n\nclass Gym{\n    public int weights = 8000;\n    public String name = \"Max\'s gym\";\n    public int price = 50;\n    \n    public void pitch(){\n        BasketBallCourt bc = new BasketBallCourt();\n        System.out.println(\"Were the best gym\");\n    }\n    \n    class BasketBallCourt {\n        \n        public void collectBalls(){\n            System.out.println(\"gimmmie all the balls!\");\n        }\n        \n        public void gymPrice(){\n            Gym g = new Gym();\n            System.out.println(g.price);\n        }\n        \n        public int Scoreboard(){\n            return 114;\n        }\n    }\n}','Inner Classes',0,0,NULL,5),(517,'does not compile because of private modifier','public class Hello {\n\n    public static void main(String[] args) {\n        Gym.BasketBallCourt gbg = new Gym().new BasketBallCourt();\n        \n    }\n\n}\n\nclass Gym{\n    public int weights = 8000;\n    public String name = \"Max\'s gym\";\n    public int price = 50;\n    \n    public void pitch(){\n        BasketBallCourt bc = new BasketBallCourt();\n        System.out.println(\"Were the best gym\");\n    }\n    \n    private class BasketBallCourt {\n        \n        public void collectBalls(){\n            System.out.println(\"gimmmie all the balls!\");\n        }\n        \n        public void gymPrice(){\n            Gym g = new Gym();\n            System.out.println(g.price);\n        }\n        \n        public int Scoreboard(){\n            return 114;\n        }\n    }\n}','Inner Classes',0,0,NULL,5),(518,'this compiles fine','public class Hello {\n\n    public static void main(String[] args) {\n        Gym.BasketBallCourt gbg = new Gym().new BasketBallCourt();\n        \n    }\n\n}\n\nclass Gym{\n    public int weights = 8000;\n    public String name = \"Max\'s gym\";\n    public int price = 50;\n    \n    public void pitch(){\n        BasketBallCourt bc = new BasketBallCourt();\n        System.out.println(\"Were the best gym\");\n    }\n    \n    protected class BasketBallCourt {\n        \n        public void collectBalls(){\n            System.out.println(\"gimmmie all the balls!\");\n        }\n        \n        public void gymPrice(){\n            Gym g = new Gym();\n            System.out.println(g.price);\n        }\n        \n        public int Scoreboard(){\n            return 114;\n        }\n    }\n}','Inner Classes',0,0,NULL,5),(519,'oooh ahhh\n\nsince inner classes are members of the enclsoing class just like anything else\nthey are inherited too.','public class Hello {\n\n    public static void main(String[] args) {\n        LifeTime lt = new LifeTime();\n        lt.showLifeTimesCourt();    \n    }\n\n}\n\nclass Gym{\n    public int weights = 8000;\n    public String name = \"Max\'s gym\";\n    public int price = 50;\n    \n    public void pitch(){\n        BasketBallCourt bc = new BasketBallCourt();\n        System.out.println(\"Were the best gym\");\n    }\n    \n    protected class BasketBallCourt {\n        \n        public void collectBalls(){\n            System.out.println(\"gimmmie all the balls!\");\n        }\n        \n        public void showCourt(){\n            System.out.println(\"oooh ahhh\");\n        }\n        \n        public void gymPrice(){\n            Gym g = new Gym();\n            System.out.println(g.price);\n        }\n        \n        public int Scoreboard(){\n            return 114;\n        }\n    }\n}\n\nclass LifeTime extends Gym{\n    public void showLifeTimesCourt(){\n        BasketBallCourt b = new BasketBallCourt();\n        b.showCourt();\n    }\n}','Inner Classes',0,0,NULL,5),(520,'this compiles and runs','public class Hello {\n\n    public static void main(String[] args) {\n       LifeTime lt = new LifeTime();\n       Gym.BasketBallCourt bc = lt.new BasketBallCourt();\n       \n    }\n\n}\n\nclass Gym{\n    public int weights = 8000;\n    public String name = \"Max\'s gym\";\n    public int price = 50;\n    \n    public void pitch(){\n        BasketBallCourt bc = new BasketBallCourt();\n        System.out.println(\"Were the best gym\");\n    }\n    \n    protected class BasketBallCourt {\n        \n        public void collectBalls(){\n            System.out.println(\"gimmmie all the balls!\");\n        }\n        \n        public void showCourt(){\n            System.out.println(\"oooh ahhh\");\n        }\n        \n        public void gymPrice(){\n            Gym g = new Gym();\n            System.out.println(g.price);\n        }\n        \n        public int Scoreboard(){\n            return 114;\n        }\n    }\n}\n\nclass LifeTime extends Gym{\n    public void showLifeTimesCourt(){\n        BasketBallCourt b = new BasketBallCourt();\n        b.showCourt();\n    }\n}','Inner Classes',0,0,NULL,5),(521,'How to access this reference of outer class','public class Hello {\n\n    public static void main(String[] args) {\n       Gym lt = new Gym();\n       Gym.BasketBallCourt bc = lt.new BasketBallCourt();\n       \n    }\n\n}\n\nclass Gym{\n    public int weights = 8000;\n    public String name = \"Max\'s gym\";\n    public int price = 50;\n    \n    public void pitch(){\n        BasketBallCourt bc = new BasketBallCourt();\n        System.out.println(\"Were the best gym\");\n    }\n    \n    protected class BasketBallCourt {\n        public String name = \"Maxs court\";\n        \n        public void collectBalls(){\n            System.out.println(\"gimmmie all the balls!\");\n        }\n        \n        public void showCourt(){\n            System.out.println(\" \"+name);\n            System.out.println(\"oooh ahhh\");\n        }\n        \n        public void gymPrice(){\n            System.out.println(\" \"+Gym.this.name);\n            System.out.println(Gym.this.price);\n        }\n        \n        public int Scoreboard(){\n            return 114;\n        }\n    }\n}','Inner Classes',0,0,NULL,5),(522,'compiles fine','public class Hello {\n\n    public static void main(String[] args) {\n       LifeTime lt = new LifeTime();\n       Gym.BasketBallCourt bc = lt.new BasketBallCourt();\n       \n    }\n\n}\n\nclass Gym{\n    public int weights = 8000;\n    public String name = \"Max\'s gym\";\n    public int price = 50;\n    \n    public void pitch(){\n        BasketBallCourt bc = new BasketBallCourt();\n        System.out.println(\"Were the best gym\");\n    }\n    \n    protected class BasketBallCourt {\n        public String name = \"Maxs court\";\n        \n        public void collectBalls(){\n            System.out.println(\"gimmmie all the balls!\");\n        }\n        \n        public void showCourt(){\n            System.out.println(\" \"+name);\n            System.out.println(\"oooh ahhh\");\n        }\n        \n        public void gymPrice(){\n            System.out.println(\" \"+Gym.this.name);\n            System.out.println(Gym.this.price);\n        }\n        \n        public int Scoreboard(){\n            return 114;\n        }\n    }\n}\n\nclass LifeTime extends Gym{\n    public void showLifeTimesCourt(){\n        final int time = 530;\n        class SalesRep{\n            public void appointment(){\n                System.out.println(\"The time of our appointment is: \"+time);\n            }\n            \n        }\n        SalesRep sr = new SalesRep();\n        sr.appointment();\n        BasketBallCourt b = new BasketBallCourt();\n        b.showCourt();\n    }\n}','Inner Classes',0,0,NULL,5),(523,'compilation fails, non final local variable is access from Method local inner \nclass.','package hello;\n\nimport java.awt.Container;\nimport java.awt.EventQueue;\nimport java.awt.event.ActionEvent;\nimport java.awt.event.InputEvent;\nimport java.awt.event.KeyEvent;\nimport java.io.IOException;\nimport java.io.Serializable;\nimport java.nio.file.DirectoryStream;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Hashtable;\nimport java.util.Iterator;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.NavigableMap;\nimport java.util.PriorityQueue;\nimport java.util.Set;\nimport java.util.SortedMap;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport javax.swing.AbstractAction;\nimport javax.swing.GroupLayout;\nimport javax.swing.InputMap;\nimport javax.swing.JButton;\nimport javax.swing.JComponent;\nimport javax.swing.JFrame;\nimport javax.swing.JPanel;\nimport javax.swing.KeyStroke;\n\npublic class Hello {\n\n    public static void main(String[] args) {\n       LifeTime lt = new LifeTime();\n       Gym.BasketBallCourt bc = lt.new BasketBallCourt();\n       \n    }\n\n}\n\nclass Gym{\n    public int weights = 8000;\n    public String name = \"Max\'s gym\";\n    public int price = 50;\n    \n    public void pitch(){\n        BasketBallCourt bc = new BasketBallCourt();\n        System.out.println(\"Were the best gym\");\n    }\n    \n    protected class BasketBallCourt {\n        public String name = \"Maxs court\";\n        \n        public void collectBalls(){\n            System.out.println(\"gimmmie all the balls!\");\n        }\n        \n        public void showCourt(){\n            System.out.println(\" \"+name);\n            System.out.println(\"oooh ahhh\");\n        }\n        \n        public void gymPrice(){\n            System.out.println(\" \"+Gym.this.name);\n            System.out.println(Gym.this.price);\n        }\n        \n        public int Scoreboard(){\n            return 114;\n        }\n    }\n}\n\nclass LifeTime extends Gym{\n    public void showLifeTimesCourt(){\n        int time = 530;\n        class SalesRep{\n            public void appointment(){\n                System.out.println(\"The time of our appointment is: \"+time);\n            }\n            \n        }\n        SalesRep sr = new SalesRep();\n        sr.appointment();\n        BasketBallCourt b = new BasketBallCourt();\n        b.showCourt();\n    }\n}\n\n\n','Inner Classes',0,0,NULL,5),(524,'Method inner classes cannot be declared protected public private or static','class Gym{\n    public int weights = 8000;\n    public String name = \"Max\'s gym\";\n    public int price = 50;\n    \n    public void pitch(){\n        BasketBallCourt bc = new BasketBallCourt();\n        System.out.println(\"Were the best gym\");\n    }\n    \n    protected class BasketBallCourt {\n        public String name = \"Maxs court\";\n        \n        public void collectBalls(){\n            System.out.println(\"gimmmie all the balls!\");\n        }\n        \n        public void showCourt(){\n            System.out.println(\" \"+name);\n            System.out.println(\"oooh ahhh\");\n        }\n        \n        public void gymPrice(){\n            System.out.println(\" \"+Gym.this.name);\n            System.out.println(Gym.this.price);\n        }\n        \n        public int Scoreboard(){\n            return 114;\n        }\n    }\n}\n\nclass LifeTime extends Gym{\n    public void showLifeTimesCourt(){\n        int time = 530;\n        protected class SalesRep{\n            public void appointment(){\n                System.out.println(\"The time of our appointment is: \"+time);\n            }\n            \n        }\n        SalesRep sr = new SalesRep();\n        sr.appointment();\n        BasketBallCourt b = new BasketBallCourt();\n        b.showCourt();\n    }\n}','Inner Classes',0,0,NULL,5),(525,'This compiles fine, you can create an anonymous inner class with a subclass\nthen assign it to a superclass reference. ','public class Hello {\n    public static void main(String[] args) {\n       Gym g = new LifeTime() {\n           public void showLifeTimeCourt(){\n               System.out.println(\"LT on meridean\");\n           }\n       };\n    }\n}\n\nclass Gym{\n    public int weights = 8000;\n    public String name = \"Max\'s gym\";\n    public int price = 50;\n    \n    public void pitch(){\n        BasketBallCourt bc = new BasketBallCourt();\n        System.out.println(\"Were the best gym\");\n    }\n    \n    static class BasketBallCourt {\n        public String name = \"Maxs court\";\n        \n        public void collectBalls(){\n            System.out.println(\"gimmmie all the balls!\");\n        }\n        \n        public void showCourt(){\n            System.out.println(\" \"+name);\n            System.out.println(\"oooh ahhh\");\n        }\n        \n        public void gymPrice(){\n\n        }\n        \n        public int Scoreboard(){\n            return 114;\n        }\n    }\n}\n\nclass LifeTime extends Gym{\n    \n    public void showLifeTimesCourt(){\n        final int time = 530;\n        BasketBallCourt bc = new BasketBallCourt();\n        bc.collectBalls();\n    }\n}','Inner Classes',0,0,NULL,5),(526,'shark.devourSeal() does not compile. \n\nthe anonymous class is declared with a reference type of AquaticLife\nso you can only use methods of that class','public class Hello {\n    public static void main(String[] args) {\n        \n        AquaticLife shark = new Shark(){\n            String unknown = \"unknown species\";\n            public void species(){\n                System.out.println(unknown);\n            }\n        };\n        \n        shark.swim();\n        shark.devourSeal();\n  \n    }\n}\n\nclass AquaticLife{ \n    public void swim(){ \n        System.out.println(\"Bubbles\");\n    }\n     \n    public void useGills(){\n        System.out.println(\"ahhh\");\n    }\n}\n\nclass Shark extends AquaticLife{\n    public void devourSeal(){\n        System.out.println(\"chomp\");\n    }\n    \n    public void swin(){\n        System.out.println(\"Swims up to 60mph\");\n    }\n    public void electricSense(){\n        System.out.println(\"I can feel you in the water\");\n    }\n}','Inner Classes',0,0,NULL,5),(527,'an inner class can extend the outlying classs','class AquaticLife{ \n    public void swim(){ \n        System.out.println(\"Bubbles\");\n    }\n     \n    public void useGills(){\n        System.out.println(\"ahhh\");\n    }\n    \n    class BottomFeeder extends AquaticLife {\n        public void useGills(){\n            System.out.println(\"I dont have gills\");\n        }\n    }\n}','Inner Classes',0,0,NULL,5),(528,'It can be abstract,\n	that would mean a concrete class would have to be created in the \n	method so that would probably not be very useful\n\nIt can access private members of the enclosing class\n--------------------------------------------------------\nIt can be marked final but it doesnt\' have to be\n\na method local inner class cannot be marked public, or static','which are true about a method local inner class ?\n\nIt must be marked final\nIt can be marked abstract\nIt can be marked public \nIt can be marked static \nIt can access private members of the enclosing class','Inner Classes',0,0,NULL,5),(529,'Compilation fails with an error at the line where the semicolon should be \nafter the inner class','public class TestObj {\n	public static void main(SA){\n		Object ob = new Object() {\n			public boolean equals(Object ob){\n				return true;\n			}\n		}\n		sout(ob.equals(\"FRED\");\n	}\n}','Inner Classes',0,0,NULL,5),(530,'compilation fails at sout(ob.name);\n\nif the reference variable is of type Object you can only access members \ndefined class Object','public class HorseTest {\n	public static void main(SA){\n		class Horse {\n			public String name;\n			public Horse(String s) {\n				name = s;\n			}\n		}\n		Object ob = new Horse(\"Zippo\");\n		sout(ob.name);\n	}\n}','Inner Classes',0,0,NULL,5),(531,'57 22\n\nto create an instance of an inner class you have to create it with an \nouter class reference here AbstractTest is abstract so it had to be\ninstantiated with an anonymous inner class to have a concrete reference\nto tie the new anonymous class of type Bar to. ','public abstract class AbstractTest {\n	public int getNum(){\n		return 45;\n	}\n	public abstract class Bar {\n		public int getNum(){\n			return 38;\n		}\n	}\n	public staic void main(String[] args) {\n		AbstractTest t = new AbstractTest(){\n			public int getNum() {\n				return 22;\n			}\n		};\n		AbstractTest.Bar f = t.new Bar() {\n			public int getNum(){\n				return 57;\n			}\n		};\n		sout(f.getNum() + \" \" + t.getNum() );\n	}\n}','Inner Classes',0,0,NULL,5),(532,'Cathedral.Sanctum s = c.new Sanctum();\n\nor\n\nCathedral.Sanctum s1 = new Cathedral().new Sanctum();','public class Tour {\n	public static void main(SA){\n		Cathedral c = new Cathedral();\n		// insert code\n		s.go();\n	}\n}\n\nclass Cathedral {\n	class Sanctum {\n		void go() { sout(\"spooky\"); }\n	}\n}\n\nproperly instantiate Sanctume','Inner Classes',0,0,NULL,5),(533,'Will not compile Hello is abstract cannot be instantiated lol ','public abstract class Hello {\n    public static void main(String[] args) {\n        new Hello().test();\n        \n    }\n    \n    void test() {\n        class Breaker{ void foo(){ System.out.println(\"Inner\"); } }\n    }\n    \n    class Breaker {\n        void foo(){\n            System.out.println(\"middle\");\n        }\n    }\n}\n\nclass Breaker{\n    void foo(){\n        System.out.println(\"Outer\");\n    }\n    \n}','Inner Classes',0,0,NULL,5),(534,'middle\n\nThe closest scoped class is middle. The inner class is declared after the\ncall to foo() and the Outer class comes after any inner classes','public class Hello {\n    public static void main(String[] args) {\n        new Hello().test();\n        \n    }\n    \n    void test() {\n        new Breaker().foo();\n        class Breaker{ void foo(){ System.out.println(\"Inner\"); } }\n    }\n    \n    class Breaker {\n        void foo(){\n            System.out.println(\"middle\");\n        }\n    }\n}\n\nclass Breaker{\n    void foo(){\n        System.out.println(\"Outer\");\n    }\n    \n}','Inner Classes',0,0,NULL,5),(535,'the call to blue in main fails because it is called before the anon class\nis created. \n\nanonymous class bigBlue works fine, you can define anonymous classes as\nmembers \n\nalso anon class blue forgets to end with a ; \n\nabsract classes cannnot have private abstract members, how would they\nbe instantiated ?\n\nbecaue of that BlueGill cannot properly override method numberOfFins()\n\nan overriding method can choose not to throw the same exception or can \nthrow a narrower one. \n','public class Hello {\n    public static void main(String[] args) {\n        blue.biteHook();\n        \n        BlueGill blue = new BlueGill(){\n            public void biteHook(){\n                System.out.println(\"Not This Time\");\n            }\n        }\n        \n    }\n    \n    BlueGill bigBlue = new BlueGill(){\n        public int bubble() throws IOException {\n            System.out.println(\"Big Bubbles\");\n            return 5;\n        }\n        \n    };\n}\n\nabstract class Fish {\n    public abstract void swim();\n    private abstract int numberOfFins();\n    \n}\n\nclass BlueGill extends Fish {\n    public void swim(){\n        System.out.println(\"Swims in lakes\");\n    }\n    \n    public void biteHook() throws IOException {\n        System.out.println(\"What the hell\");\n    }\n    \n    public int bubble() throws Exception{\n        System.out.println(\"bubble bubble\");\n        return 2;\n    }\n}','Inner Classes',0,0,NULL,5),(536,'numberOfFins() in abstract class Fish does not throw SQLException\n	so the override in BlueGill cannot throw a new Exception.\n\nbiteHook is declared in BlueGill then overriden in the annon class with\nthe same exception so its ok.\n\nthen the anon class does not override the method numberOfFins which was \nnot properly overriden in the abstract class so that makes the anon class\nnot compile. If it had overriden numberOfFins() then it could have compiled\n\nstill though the NOF in BlueGill threw that SQLException so it wont ever compile..','public class Hello {\n    public static void main(String[] args) {     \n        BlueGill blue = new BlueGill(){\n            public void biteHook() throws IOException{\n                System.out.println(\"Not This Time\");\n            }\n            public void biteHook(boolean yesno) throws NullPointerException{\n                System.out.println(\"That worm looks so tasty\");\n            }\n            \n        };\n        \n    }\n}\n\nabstract class Fish {\n    public abstract void swim() throws Exception;\n    public abstract int numberOfFins();\n    public static void breathe(){\n        System.out.println(\"ahhh\");\n    }\n    \n    \n}\n\nclass BlueGill extends Fish {\n    public void swim(){\n        breathe();\n        System.out.println(\"Swims in lakes\");\n    }\n    \n    public void biteHook() throws IOException {\n        System.out.println(\"What the hell\");\n    }\n    \n    public int numberOfFins() throws SQLException {\n        return 4;\n    }\n    \n    public int bubble() throws Exception{\n        System.out.println(\"bubble bubble\");\n        return 2;\n    }\n}','Inner Classes',0,0,NULL,5),(537,'{ Car.this.drive(); }\n\nEngine() { Car.this.drive(); }','public class  Car {\n	class Engine {\n		// insert here\n	}\n	public static void main(SA){\n		new Car().go();\n	}\n	void go() {\n		new Engine();\n	}\n	void drive() { sout(\"hi\"); }\n}\n\n// what can be given at insert here to produce \"hi\" ?\n','Inner Classes',0,0,NULL,5),(538,'no output is produced, the inner classes are valid and the exceptions are \nthrown properly','public class City {\n	class Manhattan {\n		void doStuff() throws Exception { sout(\"x \"); }\n	}\n	class Timesquare extends Manhattan {\n		void doStuff throws Exception {  }\n	}\n\n	public static void main(Stringp]] args) throws Exception{\n		new City().go();\n	}\n	void go() throws Exception { new Timesquare().doStuff(); }\n}','Inner Classes',0,0,NULL,5),(539,'21','public class Navel {\n	private int size = 7;\n	private static int length = 3;\n	public static void main(String[] args) {\n		new Navel().go();\n	}\n	void go(){\n		int size = 5;\n		sout( new Gazer().adder() );\n	}\n	class Gazer {\n		int adder() { return size * length; }\n	}\n}	','Inner Classes',0,0,NULL,5),(540,'ahhh\nahhh\nSwims in a lake','public class Hello {\n    public static void main(String[] args) {     \n        BlueGill blue = new BlueGill();\n        blue.breathe();\n        blue.swim();\n        \n    }\n}\n\nabstract class Fish {\n    public abstract void swim() throws Exception;\n    public abstract int numberOfFins();\n    public static void breathe(){\n        System.out.println(\"ahhh\");\n    }   \n}\n\nclass BlueGill extends Fish {\n    public void swim(){\n        breathe();     \n        System.out.println(\"Swims in a lake\");\n    }\n    \n    public int numberOfFins(){\n        return 5;    \n    }   \n}','Inner Classes',0,0,NULL,5),(541,'ahhh','public class Hello {\n    public static void main(String[] args) {     \n        BlueGill blue = new BlueGill();\n        \n        Fish.breathe();\n        \n    }\n}\n\nabstract class Fish {\n    public abstract void swim() throws Exception;\n    public abstract int numberOfFins();\n    public static void breathe(){\n        System.out.println(\"ahhh\");\n    }   \n}\n\nclass BlueGill extends Fish {\n    public void swim(){\n        breathe();     \n        System.out.println(\"Swims in a lake\");\n    }\n    \n    public int numberOfFins(){\n        return 5;    \n    }   \n}','Inner Classes',0,0,NULL,5),(542,'compiles','abstract class Fish {\n    public static int species = 100;\n    public abstract void swim() throws Exception;\n    public abstract int numberOfFins();\n    public static void breathe(){\n        System.out.println(\"ahhh\");\n    }   \n}\n\nclass BlueGill extends Fish {\n    public void swim(){\n        breathe();     \n        System.out.println(species);\n        System.out.println(\"Swims in a lake\");\n    }\n    \n    public int numberOfFins(){\n        return 5;    \n    }   \n}','Inner Classes',0,0,NULL,5),(543,'compilation fails, \nClass sorter must be delcared static to be used in static methood main. ','public class Pockets {\n	public static void main(SA){\n		String[] sa = {\"nickle\",\"button\", \"key\", \"lint\" };\n		Sorter s = new Sorter();\n		for(String s2: sa) sout( s2+\" \" );\n		Arrays.sort(sa,s);\n		sout();\n		for(String s2 : sa) sout( s2+\" \" );\n		\n	}\n	class Sorter implements Comparator<String> {	\n		public int compare(String a, String b) {\n			return b.compareTo(a);\n		}\n	}\n}','Collections',0,0,NULL,5),(544,'ahhh\n100\nSwims in a lake','public class Hello {\n    public static void main(String[] args) {     \n        BlueGill blue = new BlueGill();\n        blue.swim();\n        \n    }\n}\nclass BlueGill extends Fish {\n    public void swim(){\n        breathe();     \n        System.out.println(species);\n        System.out.println(\"Swims in a lake\");\n    }\n    \n    public int numberOfFins(){\n        return 5;    \n    }   \n}\n\nabstract class Fish {\n    public static int species = 100;\n    public abstract void swim() throws Exception;\n    public abstract int numberOfFins();\n    public static void breathe(){\n        System.out.println(\"ahhh\");\n    }   \n}\n   ','Inner Classes',0,0,NULL,5),(545,'will not compile, BlueGill is an inner class therefor must be declared static\nto be used in static method main. ','public class Hello {\n    public static void main(String[] args) {     \n        BlueGill blue = new BlueGill();\n        blue.swim();\n        \n    }\n class BlueGill extends Fish {\n    public void swim(){\n        breathe();     \n        System.out.println(species);\n        System.out.println(\"Swims in a lake\");\n    }\n    \n    public int numberOfFins(){\n        return 5;    \n    }   \n}\n}\n\nabstract class Fish {\n    public static int species = 100;\n    public abstract void swim() throws Exception;\n    public abstract int numberOfFins();\n    public static void breathe(){\n        System.out.println(\"ahhh\");\n    }   \n}','Inner Classes',0,0,NULL,5),(546,'ahhh\n100\nSwims in lake','public class Hello {\n    public static void main(String[] args) {     \n        BlueGill blue = new BlueGill();\n        blue.swim();\n        \n    }\n static class BlueGill extends Fish {\n    public void swim(){\n        breathe();     \n        System.out.println(species);\n        System.out.println(\"Swims in a lake\");\n    }\n    \n    public int numberOfFins(){\n        return 5;    \n    }   \n}\n}\n\nabstract class Fish {\n    public static int species = 100;\n    public abstract void swim() throws Exception;\n    public abstract int numberOfFins();\n    public static void breathe(){\n        System.out.println(\"ahhh\");\n    }   \n}','Inner Classes',0,0,NULL,5),(547,'Arraylist doesn\'t have a method that returns the given object. \n\nalso you cannot return null when the return type is primitive.','public class Hello {\n    public static void main(String[] args) {     \n        Locker<SchoolSupplies> locker = new Locker<>();\n        locker.stuff.add(new Book(\"AAA\"));\n        locker.stuff.add(new Book(\"BBB\"));\n        \n        System.out.println(locker.getOut(new Book(\"AAA\")));\n        \n    }\n}\n\nclass Locker<T> {\n    ArrayList<T> stuff = new ArrayList<T>();\n    public T getOut(T that){\n        return stuff.get(that);\n    }\n}\n\nabstract class SchoolSupplies{\n    public abstract void use();\n    public abstract int lend();\n    public abstract boolean isCool();\n}\n\nclass Book extends SchoolSupplies{\n    private String name;\n    Book(String n){\n        name = n;\n    }\n    public void use(){\n        System.out.println(\"Read it\");\n    }\n    \n    public int lend(){\n        System.out.println(\"I need back by 4th\");\n        return 4;\n    }\n    \n    public boolean isCool(){\n        return false;\n    }\n}\n\nclass Pen extends SchoolSupplies {\n    public void use(){\n        System.out.println(\"doodle\");\n    }\n    \n    public int lend(){\n        System.out.println(\"just have it\");\n        return null;\n    }\n    \n    public boolean isCool(){\n        return true;\n    }\n}','Inner Classes',0,0,NULL,5),(548,'compiles with a warning','public class Hello {\n    public static void main(String[] args) {     \n\n        List<Animal> animals = new ArrayList<Animal>();\n        animals.add(new Dog());\n        animals.add(new Cat());\n        \n        addAnimal(animals);\n    \n    }\n    \n    public static void addAnimal(List animals) {\n	animals.add(new Object());\n    }\n}','Generics',0,0,NULL,5),(549,'will not compile,\n\ndefault constructors in Dog and Cat do not give proper calls to super()\nanimal non-defautl constructor','public class Hello {\n    public static void main(String[] args) {     \n\n        Animal a = new Animal(6,\"dog\");\n        System.out.println(a.getSize());\n    \n    }\n\n}\n        \nclass Animal implements Comparable<Animal>{\n    private int size;\n    private String name;\n    public Animal(int s, String n){\n        size = s;\n        name = n;\n        \n    }\n    public int getSize(){\n        return size;\n    }\n    public int compareTo(Animal a){\n        int asize = a.getSize();\n        int bsize = this.size;\n        \n        if(asize < bsize)\n            return 1;\n        else if(asize == bsize)\n            return 0;\n        else\n            return -1;\n        \n        \n    }\n    \n    public String toString(){\n        return name;\n    }\n}\n\nclass Dog extends Animal{}\nclass Cat extends Animal{} ','General',0,0,NULL,5),(550,'will not compile,\n\n	should be...\n		for(Shaveable s : sList){\n			...','public class Hello {\n    public static void main(String[] args) {     \n        List<Spankable> spanklist = new ArrayList<>();\n        spanklist.add(new Doll());\n        spanklist.add(new Doll());\n        \n    }\n    \n    public static void runit(List<? extends Shaveable> sList){\n        for(Spankable s : sList){\n            s.shave();\n        }\n    }\n\n}\n\ninterface Shaveable{\n    public void shave();\n}\n\ninterface Spankable extends Shaveable{\n    public void spank();\n}\n\nclass Doll implements Spankable{\n    public void spank(){\n        System.out.println(\"OW!\");\n    }\n    \n    public void shave(){\n        System.out.println(\"HMMM : O\");\n    }\n}','General',0,0,NULL,5),(551,'compiles\n\nhmmm : O\nhmmm : O','public class Hello {\n    public static void main(String[] args) {     \n        List<Spankable> spanklist = new ArrayList<>();\n        spanklist.add(new Doll());\n        spanklist.add(new Doll());\n        \n    }\n    \n    public static void runit(List<? extends Shaveable> sList){\n        for(Shaveable s : sList){\n            s.shave();\n        }\n    }\n\n}\n\ninterface Shaveable{\n    public void shave();\n}\n\ninterface Spankable extends Shaveable{\n    public void spank();\n}\n\nclass Doll implements Spankable{\n    public void spank(){\n        System.out.println(\"OW!\");\n    }\n    \n    public void shave(){\n        System.out.println(\"HMMM : O\");\n    }\n}','General',0,0,NULL,5),(552,'HMMM : O\nHMMM : O\n\n','public class Hello {\n    public static void main(String[] args) {     \n        List<Spankable> spanklist = new ArrayList<>();\n        spanklist.add(new Doll());\n        spanklist.add(new Doll());\n        \n        runit(spanklist);\n        \n    }\n    \n    public static void runit(List<? extends Spankable> sList){\n        for(Shaveable s : sList){\n            s.shave();\n        }\n    }\n\n}\n\ninterface Shaveable{\n    public void shave();\n}\n\ninterface Spankable extends Shaveable{\n    public void spank();\n}\n\nclass Doll implements Spankable{\n    public void spank(){\n        System.out.println(\"OW!\");\n    }\n    \n    public void shave(){\n        System.out.println(\"HMMM : O\");\n    }\n}','General',0,0,NULL,5),(553,'HMMM : O\nHMMM : O','class Hello {\n    public static void main(String[] args) {     \n        List<Spankable> spanklist = new ArrayList<>();\n        spanklist.add(new Doll());\n        spanklist.add(new Doll());\n        \n        runit(spanklist);\n        \n    }\n    \n    public static void runit(List<? extends Shaveable> sList){\n        for(Shaveable s : sList){\n            s.shave();\n        }\n    }\n\n}\n\ninterface Shaveable{\n    public void shave();\n}\n\ninterface Spankable extends Shaveable{\n    public void spank();\n}\n\nclass Doll implements Spankable{\n    public void spank(){\n        System.out.println(\"OW!\");\n    }\n    \n    public void shave(){\n        System.out.println(\"HMMM : O\");\n    }\n}                     ','General',0,0,NULL,5),(554,'HMMM : O\nHMMM : O','class Hello {\n    public static void main(String[] args) {     \n        List<Doll> spanklist = new ArrayList<>();\n        spanklist.add(new Doll());\n        spanklist.add(new Doll());\n        \n        runit(spanklist);\n        \n    }\n    \n    public static void runit(List<? extends Shaveable> sList){\n        for(Shaveable s : sList){\n            s.shave();\n        }\n    }\n\n}\n\ninterface Shaveable{\n    public void shave();\n}\n\ninterface Spankable extends Shaveable{\n    public void spank();\n}\n\nclass Doll implements Spankable{\n    public void spank(){\n        System.out.println(\"OW!\");\n    }\n    \n    public void shave(){\n        System.out.println(\"HMMM : O\");\n    }\n}                  ','General',0,0,NULL,5),(555,'/tmp/google/file.txt','class Hello {\n    public static void main(String[] args) {     \n        Path p1 = Paths.get(\"/home/max/tmp\");\n        Path p2 = Paths.get(\"/tmp/google/file.txt\");\n        System.out.println(p1.resolve(p2));\n        \n    }\n\n}','General',0,0,NULL,5),(556,'/home/max/tmp/tmp/google/file.txt','class Hello {\n    public static void main(String[] args) {     \n        Path p1 = Paths.get(\"/home/max/tmp\");\n        Path p2 = Paths.get(\"tmp/google/file.txt\");\n        System.out.println(p1.resolve(p2));\n        \n    }\n\n}','IO',0,0,NULL,5),(557,'/home/max/tmp/google/file.txt','class Hello {\n    public static void main(String[] args) {     \n        Path p1 = Paths.get(\"/home/max/tmp\");\n        Path p2 = Paths.get(\"google/file.txt\");\n        System.out.println(p1.resolve(p2));\n        \n    }\n\n}','IO',0,0,NULL,5),(558,'/home/max/tmp/file.txt','class Hello {\n    public static void main(String[] args) {     \n        Path p1 = Paths.get(\"/home/max/tmp\");\n        Path p2 = Paths.get(\"file.txt\");\n        System.out.println(p1.resolve(p2));\n        \n    }\n\n}','General',0,0,NULL,5),(559,'home/max/tmp/file.txt','class Hello {\n    public static void main(String[] args) {     \n        Path p1 = Paths.get(\"home/max/tmp\");\n        Path p2 = Paths.get(\"file.txt\");\n        System.out.println(p1.resolve(p2));\n        \n    }\n\n}','General',0,0,NULL,5),(560,'home/max/tmp/file.txt/file.txt','class Hello {\n    public static void main(String[] args) {     \n        Path p1 = Paths.get(\"home/max/tmp/file.txt\");\n        Path p2 = Paths.get(\"file.txt\");\n        System.out.println(p1.resolve(p2));\n        \n    }\n\n}','General',0,0,NULL,5),(561,'file.txt','class Hello {\n    public static void main(String[] args) {     \n        Path p1 = Paths.get(\"\");\n        Path p2 = Paths.get(\"file.txt\");\n        System.out.println(p1.resolve(p2));\n        \n    }\n\n}','General',0,0,NULL,5),(562,'home/max/tmp/file.txt','class Hello {\n    public static void main(String[] args) {     \n        Path p1 = Paths.get(\"home/max/tmp/file.txt\");\n        Path p2 = Paths.get(\"\");\n        System.out.println(p1.resolve(p2));\n        \n    }\n\n}','General',0,0,NULL,5),(563,'file.txt/home/max/tmp/file.txt','class Hello {\n    public static void main(String[] args) {     \n        Path p1 = Paths.get(\"home/max/tmp/file.txt\");\n        Path p2 = Paths.get(\"file.txt\");\n        System.out.println(p2.resolve(p1));\n        \n    }\n\n}','General',0,0,NULL,5),(564,'true\n\nHowever Animal does not have an instanceof test in its boolean so be \ncareful you could get a classcastexception','public class Hello<T> {\n    public static void main(String[] args){\n\n        ArrayList<? extends Animal> c = makeArrayList(new Animal(5));\n        \n        Animal max = new Animal(100);\n        Animal bear = new Animal(45);\n        Animal Hippo = new Animal(45);\n        \n        System.out.println(bear.equals(Hippo));    \n    } \n    public static <G extends Animal> ArrayList<G> makeArrayList(G g){\n        ArrayList<G> genlist = new ArrayList();\n        genlist.add(g);\n        return genlist;\n        \n    }\n}\n\nclass Animal{\n    private int size;\n    public Animal(int s){\n        size = s;\n    }\n    public void makeSound(){\n            System.out.println(\"Sound!\");\n            \n    }\n    \n    public int getSize(){\n        return size;\n    }\n\n    public boolean equals(Object o){\n        // equals without instanceof \n        if(((Animal)o).getSize() == this.size){\n            return true;\n        } else {\n            return false;\n        }\n        \n    }\n}\n\nclass Flower {\n    public void pretty(){\n        System.out.println(\"i look so pretty\");\n    }\n}','General',0,0,NULL,5),(565,'ClassCastException','public class Hello<T> {\n    public static void main(String[] args){\n\n        ArrayList<? extends Animal> c = makeArrayList(new Animal(5));\n        \n        Animal max = new Animal(100);\n        Animal bear = new Animal(45);\n        Animal Hippo = new Animal(45);\n        Flower flower = new Flower();\n        \n        System.out.println(bear.equals(Hippo));  \n        System.out.println(max.equals(flower));\n    } \n    public static <G extends Animal> ArrayList<G> makeArrayList(G g){\n        ArrayList<G> genlist = new ArrayList();\n        genlist.add(g);\n        return genlist;\n        \n    }\n}\n\nclass Animal{\n    private int size;\n    public Animal(int s){\n        size = s;\n    }\n    public void makeSound(){\n            System.out.println(\"Sound!\");\n            \n    }\n    \n    public int getSize(){\n        return size;\n    }\n\n    public boolean equals(Object o){\n        // equals without instanceof \n        if(((Animal)o).getSize() == this.size){\n            return true;\n        } else {\n            return false;\n        }\n        \n    }\n}\n\nclass Flower {\n    public void pretty(){\n        System.out.println(\"i look so pretty\");\n    }\n}','General',0,0,NULL,5),(566,'instanceMethod() in Bar\nclassMethod() in Foo\n\nBriefly, when you override a method, you still get the benefits of run-time polymorphism, and when you hide, you don\'t\n\nWhy do we get instanceMethod from Bar, but classMethod() from Foo? Aren\'t we using the same instance f to access both of these? Yes we are - but since one is overriding and the other is hiding, we see different behavior.\n\nSince instanceMethod() is (drum roll please...) an instance method, in which Bar overrides the method from Foo, at run time the JVM uses the actual class of the instance f to determine which method to run. Although f was declared as a Foo, the actual instance we created was a new Bar(). So at runtime, the JVM finds that f is a Bar instance, and so it calls instanceMethod() in Bar rather than the one in Foo. That\'s how Java normally works for instance methods.\n\nWith classMethod() though. since (ahem) it\'s a class method, the compiler and JVM don\'t expect to need an actual instance to invoke the method. And even if you provide one (which we did: the instance referred to by f) the JVM will never look at it. The compiler will only look at the declared type of the reference, and use that declared type to determine, at compile time, which method to call. Since f is declared as type Foo, the compiler looks at f.classMethod() and decides it means Foo.classMethod. It doesn\'t matter that the instance reffered to by f is actually a Bar - for static methods, the compiler only uses the declared type of the reference. That\'s what we mean when we say a static method does not have run-time polymorphism.\n\nBecause instance methods and class methods have this important difference in behavior, we use different terms - \"overriding\" for instance methods and \"hiding\" for class methods - to distinguish between the two cases. And when we say you can\'t override a static method, what that means is that even if you write code that looks like it\'s overriding a static method (like the first Foo and Bar at the top of this page) - it won\'t behave like an overridden method. ','class Foo {\n    public static void classMethod() {\n        System.out.println(\"classMethod() in Foo\");\n    }\n \n    public void instanceMethod() {\n        System.out.println(\"instanceMethod() in Foo\");\n    }\n}\n \nclass Bar extends Foo {\n    public static void classMethod() {\n        System.out.println(\"classMethod() in Bar\");\n    }\n \n    public void instanceMethod() {\n        System.out.println(\"instanceMethod() in Bar\");\n    }\n}\n  \nclass Test {\n    public static void main(String[] args) {\n        Foo f = new Bar();\n        f.instanceMethod();\n        f.classMethod();\n    }\n}','General',0,0,NULL,5),(567,'all animals eat\nall animals eat\nall animals eat\nEat salmon\n\nIt is allowed to call a static method of the class on an instance \nvariable, but it is confusing and not recomneded. \n\nstatic variables are not overriden by subclass methods they are hidden\n\nso, at runtime there will be no polymorphism for static methods','class Bear extends Animal{\n    private static int ALLBEARSAREBIG = 100;\n    \n    public Bear(){\n        super(ALLBEARSAREBIG);\n        \n    }\n    \n    public static void eat(){\n        System.out.println(\"Eat salmon\");\n    }\n    \n}\n\nclass Animal{\n    private int size;\n    public Animal(int s){\n        size = s;\n    }\n    public static void eat(){\n        System.out.println(\"all animals eat\");\n    }\n    public void makeSound(){\n            System.out.println(\"Sound!\");\n            \n    }\n    \n    public int getSize(){\n        return size;\n    }\n\n    public boolean equals(Object o){\n        // equals without instanceof \n        if(((Animal)o).getSize() == this.size){\n            return true;\n        } else {\n            return false;\n        }\n        \n    }\n}\n\npublic class Hello<T> {\n    public static void main(String[] args){\n        Animal cat = new Animal(5);\n        Animal bear = new Bear();\n        \n        cat.eat();\n        Animal.eat();\n        bear.eat();\n        Bear.eat();\n\n    } \n }','General',0,0,NULL,5),(568,'will not compile you cannot override a static method\n\nto fix change eat in Bear to static or do something else with the other class\nand varialbes','public class Hello<T> {\n    public static void main(String[] args){\n        Animal cat = new Animal(5);\n        Animal bear = new Bear();\n        \n        cat.eat();\n        Animal.eat();\n        bear.eat();\n        Bear.eat();\n\n    } \n }\n\nclass Animal{\n    private int size;\n    public Animal(int s){\n        size = s;\n    }\n    public static void eat(){\n        System.out.println(\"all animals eat\");\n    }\n    public void makeSound(){\n            System.out.println(\"Sound!\");\n            \n    }\n    \n    public int getSize(){\n        return size;\n    }\n\n    public boolean equals(Object o){\n        // equals without instanceof \n        if(((Animal)o).getSize() == this.size){\n            return true;\n        } else {\n            return false;\n        }\n        \n    }\n}\n\nclass Bear extends Animal{\n    private static int ALLBEARSAREBIG = 100;\n    \n    public Bear(){\n        super(ALLBEARSAREBIG);\n        \n    }\n    \n    public void eat(){\n        System.out.println(\"Eat salmon\");\n    }\n    \n}','General',0,0,NULL,5),(569,'will not compile,\n\ncall to super in Bear defautl constructor does not fit with ANimal int constructor\n\nremeber if you provide a parameterized constructor the implicit defautl one\ngoes away','public class Hello<T> {\n    public static void main(String[] args){\n        Animal cat = new Animal(5);\n        Animal bear = new Bear();\n        \n        cat.eat();\n        Animal.eat();\n        bear.eat();\n        Bear.eat();\n\n    } \n }\n\nclass Animal{\n    private int size;\n    public Animal(int s){\n        size = s;\n    }\n    public static void eat(){\n        System.out.println(\"all animals eat\");\n    }\n    public void makeSound(){\n            System.out.println(\"Sound!\");\n            \n    }\n    \n    public int getSize(){\n        return size;\n    }\n\n    public boolean equals(Object o){\n        // equals without instanceof \n        if(((Animal)o).getSize() == this.size){\n            return true;\n        } else {\n            return false;\n        }\n        \n    }\n}\n\nclass Bear extends Animal{\n\n    \n    public Bear(){\n        \n    }\n    \n    public static void eat(){\n        System.out.println(\"Eat salmon\");\n    }\n    \n}\n\nclass Flower {\n    public void pretty(){\n        System.out.println(\"i look so pretty\");\n    }\n}','General',0,0,NULL,5),(570,'Will not compile, reference to resolve is ambiguous. \n\nboth resolve(String) and resolve(Path) match','Path p1 = Paths.get(\"/home/maxbisesi/file.txt\");\n        System.out.println(p1.resolve(null));','IO',0,0,NULL,5),(571,'Compiles fine! you can use the overloaded method within the inner class\n\nTheres 8 people here so get the fire going','public class Hello {\n\n    public static void main(String[] args) {\n        \n        Burnable stick = new Burnable(){\n            int people = 8;\n            public void burn(){\n                System.out.println(\"Theres \"+people+\" people here so get the fire going\");\n            }\n            \n            public int unburn(){\n                System.out.println(\"That\'s impossible\");\n                return 0;\n            }\n            \n            public void shakeoff(int x){\n                System.out.println(\"That was my shoe!\"+x);\n            }\n            \n            public void shakeoff(){\n                \n                this.shakeoff(4);\n                System.out.println(\"its off\");\n            }\n            \n            \n            \n        };\n        \n        stick.burn();\n    }\n\n}\n\ninterface Burnable{\n    int people = 10;\n    void burn();\n    void shakeoff(int z);\n    int unburn();\n}','Inner Classes',0,0,NULL,5),(572,'','The thread is the worker and the runnable is the job to be done','Threads',0,0,NULL,5),(573,'Thread()\nThread(Runnable target)\nThread(Runnable target, String name)\nThread(String name)','Thread Constructors','Threads',0,0,NULL,5),(574,'after the run() is complete','When is a thread considered dead?','Threads',0,0,NULL,5),(575,'It is not guarenteed that the threads will be started in the order that\nthey are declared. Or that they will finish and start at the same time\n\nor that a loop will complete once it has begun.','Nothing is guarenteed in threading other than Each thread will start and each thread\nwill run to completion. ','Threads',0,0,NULL,5),(576,'','The order in which runnable threads are chosen to run is not guarenteed.','Threads',0,0,NULL,5),(577,'Will not compile, unreported Exception InteruptedException must be caught\nor thrown. ','public class Hello {\n    public static void main(String[] dicks){\n       Thread t = new Thread(new FooRunnable());\n       t.start();\n              \n\n    }\n}\n\nclass FooRunnable implements Runnable {\n    public void run(){\n        for(int x = 1; x <= 100; x++){\n            if((x % 10) == 0){\n                System.out.println(\"next 10\");\n            }\n            System.out.println(x+\" \");\n            Thread.sleep(1000); \n            }\n            \n        }\n    }\n}','Threads',0,0,NULL,5),(578,'','A thread gets a default priority that is the default priority of the thread of\nexecution that creates it. ','Threads',0,0,NULL,5),(579,'default thread priority is 5','FooRunnable r = new FooRunnable();\nThread t = new Thread(r);\nt.setPriority(8);\nt.start();\n','Threads',0,0,NULL,5),(580,'Thread.MIN_PRIORITY (1)\nThread.NORM_PRIORITY (5)\nThread.MAX_PRIORITY (10)\n','Thread class constants ','Threads',0,0,NULL,5),(581,'will cause a thread to go from running to runnable, but it might not do\nanything at all. ','Thread.yeild()','Threads',0,0,NULL,5),(582,'FALSE','join() is static','Threads',0,0,NULL,5),(583,'takes the currently running thread(if this were in the main method then that\nwould be the main thread) and joins it onto the end of the thread\nreferenced by t. \n\n','Thread t = new Thread();\nt.start();\nt.join();','Threads',0,0,NULL,5),(584,'will not compile, only methods or blocks can be synchronized not variables\nor classes','public class Hello implements Runnable{\n    private synchronized Account acct = new Account(50);\n    \n    public static void main(String[] dicks){\n       Hello h = new Hello();\n       Thread one = new Thread(h);\n       Thread two = new Thread(h);\n       one.setName(\"Max\");\n       two.setName(\"Angela\");\n       \n       one.start();\n       two.start();\n\n    }\n    \n    public void run(){\n        for(int x = 0; x < 5; x++){\n            makeWithdrawl(10);\n            if(acct.getBalance() < 0){\n                System.out.println(\"account is overdrawn\");\n            }\n        }\n    }\n    \n    private synchronized void makeWithdrawl(int amt){\n        //this operation is not atomic\n        if(acct.getBalance() >= amt){\n            System.out.println(Thread.currentThread().getName()+\" is going to withdraw\");\n            \n            try{\n                Thread.sleep(500);\n            } catch(InterruptedException e){\n                \n            }\n            \n            acct.withdraw(amt);\n            System.out.println(Thread.currentThread().getName() + \" completes the withdraw\");\n        } else {\n            System.out.println(\"insufficinet funds for: \" + Thread.currentThread().getName() );\n        }\n    }\n}','Threads',0,0,NULL,5),(585,'','If a thread goes to sleeep it holds any locks it has','Threads',0,0,NULL,5),(586,'will not compile, method local inner classes must be declared before they \nare used. ','private JPanel createAddFlashCardPanel() {\n        JPanel jp = new JPanel(new FlowLayout());\n        \n        \n        JTextArea ja = new JTextArea(17,78);\n        ja.setWrapStyleWord(true);\n        JScrollPane question = new JScrollPane(ja);\n        ja.setTabSize(5);\n        ja.setFont(textfont);\n        \n        \n        AbstractDocument doc = (AbstractDocument) ja.getDocument();\n        doc.addDocumentListener(new TextChanger());\n        \n        class TextChanger implements DocumentListener {\n\n        @Override\n        public void insertUpdate(DocumentEvent e) {\n            try{\n                String addedtext = doc.getText(e.getOffset(), e.getLength());\n                System.out.println(addedtext);\n            } catch(BadLocationException blexc){\n                \n            }\n        }\n        @Override\n        public void removeUpdate(DocumentEvent e) {\n            \n        }\n        @Override\n        public void changedUpdate(DocumentEvent e) {\n            \n        }\n       \n    }\n  \n    ','Threads',0,0,NULL,5),(587,'will not compile, foundcards is defined only in the scope of the try{}\n\nto fix \n\nput it above try{ } ',' private SwingWorker<String, String> worker = new SwingWorker<String, String>() {\n        public String doInBackground() {\n            while (!searchwords.isEmpty()) {\n                String word = searchwords.poll();\n                if(word == null){\n                    continue;\n                }\n                \n                try{\n                    ArrayList<Card> foundcards = Database.searchDatabase(word);\n                } catch (IOException e){\n                    System.out.println(\"problem serarch db\");\n                }\n\n                for (Card c : foundcards) {\n\n                }\n\n            }\n        }','Threads',0,0,NULL,5),(588,'public static int getCount() {\n	synchronized(MyClass.class) {\n		return count;\n	}\n}\n\n- there is only one copyy of static data you\'re trying to protect so you\nonly need one lock per class to synchronize static methods- a lock for the whole class.\n\nevery class loaded in java has a corresponding instance of java.lang.Class\nrepresenting that Class. It\'s that Class instance used to lock on \nstatic methods. ','public static synchronized int getCount() {\n	return count;\n}\n\nhow to could this method be re made excactly using a synchronized block ?','Threads',0,0,NULL,5),(589,'100x A\n\n100x AA\n\n100x AAA\n\nall these threads synchronize onto the same object','public class Hello extends Thread {\n   StringBuilder sb;\n    \n    public Hello(StringBuilder stb){\n        sb = stb;\n    }\n   \n    \n    public static void main(String[] dicks){\n        StringBuilder sbmain = new StringBuilder(\"A\");  \n        Hello a = new Hello(sbmain);\n        Hello b = new Hello(sbmain);\n        Hello c = new Hello(sbmain);\n        a.start();\n        b.start();\n        c.start();\n    }\n    \n    public void run(){\n        \n        synchronized(sb){\n            for(int i = 0; i < 100; i++){\n                System.out.println(sb);\n            }\n            sb.append(\"A\");  \n        }\n    }\n}','Threads',0,0,NULL,5),(590,'un predicatable results - without synch. you cannot be sure what thread will\nwill be executing when. ','public class Hello extends Thread {\n   StringBuilder sb;\n    \n    public Hello(StringBuilder stb){\n        sb = stb;\n    }\n   \n    public static void main(String[] dicks){\n        StringBuilder sbmain = new StringBuilder(\"A\");  \n        Hello a = new Hello(sbmain);\n        Hello b = new Hello(sbmain);\n        Hello c = new Hello(sbmain);\n        a.start();\n        b.start();\n        c.start();\n    }  \n    public void run(){\n            for(int i = 0; i < 1000; i++){\n                System.out.println(i+\" \"+sb);\n            }\n            sb.append(\"A\");   \n    }\n}','Threads',0,0,NULL,5),(591,'got it','Threads calling non-static synchronized methods in the same class will only\nblock each other if they\'re invoked using THE SAME INSTANCE. that\'s because theyeach\nlock on this instance, and if they\'re called using two differenct instances,\nthey get two locks, which do not interfere with each other. ','Threads',0,0,NULL,5),(592,'got it ','Threads calling static synchronized methods in the same class will always \nblock each other- they all lock on the same class instance. ','Threads',0,0,NULL,5),(593,'','a static synchronized method and a non-static synhcronized method will not block\neach other, ever. the static method locks on a Class instance, while the non\nstatic locks on this instance. These actions do not interfere with each other.','Threads',0,0,NULL,5),(594,'','Generally use synchronization anytime more than one thread is accessing mutable\ndata. Dont worry about local varialbes each thread gets its own copy of those\nTwo threads executing the same method at the same time will use different\ncopiies of local variables.\n	However:\n		do worry about static and non sttaic fields if they contain data that \n		can be changed. ','Threads',0,0,NULL,5),(595,'5\n5\n5','public class Hello {\n    \n   public static void main (String [] args){\n       Thing thing = new Thing();\n       \n       new Thread(new Accessor(thing),\"Max\").start();\n       new Thread(new Accessor(thing),\"Bart\").start();\n       new Thread(new Accessor(thing),\"Thread C\").start();\n \n   }\n}\n\nclass Accessor implements Runnable{\n    private Thing thisthing;\n    \n    public Accessor(Thing x){\n        thisthing = x;\n    }\n    \n    public void run(){\n        thisthing.setNonstaticField(5);\n        System.out.println(thisthing.getNonstaticField());\n    }\n}\n\nclass Thing {\n    private static int staticField;\n    private int nonstaticField;\n    \n    public static synchronized int getStaticField(){\n        return staticField;\n    }\n    \n    public static synchronized void setStaticField(int x){\n        //use class not this\n        Thing.staticField = x;\n    }\n    \n    public synchronized int getNonstaticField(){\n        return nonstaticField;\n    }\n    \n    public synchronized void setNonstaticField(int y){\n        this.nonstaticField = y;\n    }\n}','Threads',0,0,NULL,5),(596,'un predictable results, to make predictable\n\nput loop code inside a synhcronized block that locks onto thisthing!','public class Hello {\n    \n   public static void main (String [] args){\n       Thing thing = new Thing();\n       \n       new Thread(new Accessor(thing),\"Max\").start();\n       new Thread(new Accessor(thing),\"Bart\").start();\n       new Thread(new Accessor(thing),\"Thread C\").start();\n \n   }\n}\n\nclass Accessor implements Runnable{\n    private Thing thisthing;\n    \n    public Accessor(Thing x){\n        thisthing = x;\n    }\n    \n    public void run(){\n        for(int i = 1; i <= 10; i++){\n            thisthing.setNonstaticField(i);\n            System.out.println(thisthing.getNonstaticField());\n        }\n    }\n}\n\nclass Thing {\n    private static int staticField;\n    private int nonstaticField;\n    \n    public static synchronized int getStaticField(){\n        return staticField;\n    }\n    \n    public static synchronized void setStaticField(int x){\n        //use class not this\n        Thing.staticField = x;\n    }\n    \n    public synchronized int getNonstaticField(){\n        return nonstaticField;\n    }\n    \n    public synchronized void setNonstaticField(int y){\n        this.nonstaticField = y;\n    }\n}','Threads',0,0,NULL,5),(597,'run:\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n','public class Hello {\n    \n   public static void main (String [] args){\n       Thing thing = new Thing();\n       \n       new Thread(new Accessor(thing),\"Max\").start();\n       new Thread(new Accessor(thing),\"Bart\").start();\n       new Thread(new Accessor(thing),\"Thread C\").start();\n \n   }\n}\n\nclass Accessor implements Runnable{\n    private Thing thisthing;\n    \n    public Accessor(Thing x){\n        thisthing = x;\n    }\n    \n    public void run(){\n        synchronized(thisthing){\n            for(int i = 1; i <= 10; i++){\n              thisthing.setNonstaticField(i);\n             System.out.println(thisthing.getNonstaticField());\n         }\n        }\n    }\n}\n\nclass Thing {\n    private static int staticField;\n    private int nonstaticField;\n    \n    public static synchronized int getStaticField(){\n        return staticField;\n    }\n    \n    public static synchronized void setStaticField(int x){\n        //use class not this\n        Thing.staticField = x;\n    }\n    \n    public synchronized int getNonstaticField(){\n        return nonstaticField;\n    }\n    \n    public synchronized void setNonstaticField(int y){\n        this.nonstaticField = y;\n    }\n}','Threads',0,0,NULL,5),(598,'SynchronizedRGB must be used carefully to avoid being seen in an inconsistent state. Suppose, for example, a thread executes the following code:\n\nSynchronizedRGB color =\n    new SynchronizedRGB(0, 0, 0, \"Pitch Black\");\n...\nint myColorInt = color.getRGB();      //Statement 1\nString myColorName = color.getName(); //Statement 2\n\nIf another thread invokes color.set after Statement 1 but before Statement 2, the value of myColorInt won\'t match the value of myColorName. To avoid this outcome, the two statements must be bound together:\n\nsynchronized (color) {\n    int myColorInt = color.getRGB();\n    String myColorName = color.getName();\n} \n\nThis kind of inconsistency is only possible for mutable objects — it will not be an issue for the immutable version of SynchronizedRGB.','class SynchronizedRGB {\n\n    // Values must be between 0 and 255.\n    private int red;\n    private int green;\n    private int blue;\n    private String name;\n\n    private void check(int red,\n                       int green,\n                       int blue) {\n        if (red < 0 || red > 255\n            || green < 0 || green > 255\n            || blue < 0 || blue > 255) {\n            throw new IllegalArgumentException();\n        }\n    }\n\n    public SynchronizedRGB(int red,\n                           int green,\n                           int blue,\n                           String name) {\n        check(red, green, blue);\n        this.red = red;\n        this.green = green;\n        this.blue = blue;\n        this.name = name;\n    }\n\n    public void set(int red,\n                    int green,\n                    int blue,\n                    String name) {\n        check(red, green, blue);\n        synchronized (this) {\n            this.red = red;\n            this.green = green;\n            this.blue = blue;\n            this.name = name;\n        }\n    }\n\n    public synchronized int getRGB() {\n        return ((red << 16) | (green << 8) | blue);\n    }\n\n    public synchronized String getName() {\n        return name;\n    }\n\n    public synchronized void invert() {\n        red = 255 - red;\n        green = 255 - green;\n        blue = 255 - blue;\n        name = \"Inverse of \" + name;\n    }\n}','Threads',0,0,NULL,5),(599,'run:\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n30 \n29 \n28 \n27 \n26 \n25 \n24 \n23 \n22 \n21 \n20 \n19 \n18 \n17 \n16 \n15 \n14 \n13 \n12 \n11 \n30 \n29 \n28 \n27 \n26 \n25 \n24 \n23 \n22 \n21 \n20 \n19 \n18 \n17 \n16 \n15 \n14 \n13 \n12 \n11 \n30 \n29 \n28 \n27 \n26 \n25 \n24 \n23 \n22 \n21 \n20 \n19 \n18 \n17 \n16 \n15 \n14 \n13 \n12 \n11 \n\n','public class Hello {\n    \n   public static void main (String [] args){\n       Thing thing = new Thing();\n       \n       new Thread(new Accessor(thing),\"Max\").start();\n       new Thread(new Accessor(thing),\"Bart\").start();\n       new Thread(new Accessor(thing),\"Thread C\").start();\n       new Thread(new staticAccessor(),\"stat Max\").start();\n       new Thread(new staticAccessor(),\"stat bart\").start();\n       new Thread(new staticAccessor(),\"stat c\").start();\n \n   }\n}\n\nclass Accessor implements Runnable{\n    private Thing thisthing;\n    \n    public Accessor(Thing x){\n        thisthing = x;\n    }\n    \n    public void run(){\n        synchronized(thisthing){\n            for(int i = 1; i <= 10; i++){\n              thisthing.setNonstaticField(i);\n             System.out.println(thisthing.getNonstaticField());\n         }\n        }\n    }\n}\n\nclass staticAccessor implements Runnable {\n    \n    public void run(){\n        synchronized(Thing.class){\n            for(int i = 30; i > 10; i--){\n                Thing.setStaticField(i);\n                System.out.println(Thing.getStaticField()+\" \");\n            }\n        }\n    }\n    \n}','Threads',0,0,NULL,5),(600,'this class may deadlock','class DeadlockRisk {\n    private static class Resource {\n        public int value;\n    }\n    \n    private Resource resA = new Resource();\n    private Resource resB = new Resource();\n    \n    public int read() {\n        synchronized(resA) { // may deadlock\n            synchronized(resB) {\n                return resB.value + resA.value;\n            }\n        }\n    }\n    \n    public void write(int a, int b){\n        synchronized(resB){//may deadlock\n            synchronized(resA){\n                resA.value = a;\n                resB.value = b;\n            }\n        }\n    }\n}','Threads',0,0,NULL,5),(601,'','wait() notify() and notifyAll() must be called from within a synhcronized\ncontext! A thread can\'t invoke a wait or notify method on an object unless it owns \nthat object\'s lock','Threads',0,0,NULL,5),(602,'run:\nwaiting for b to complete...\nTotal is 4950\n\n','public class Hello {\n    \n   public static void main (String [] args){\n       \n       ThreadB b = new ThreadB();\n       b.start();\n       \n       synchronized(b) {\n           try {\n               System.out.println(\"waiting for b to complete...\");\n               b.wait();\n           } catch(InterruptedException e) { }\n           \n           System.out.println(\"Total is \" + b.total);\n       }\n \n   }\n  \n}\n\nclass ThreadB extends Thread {\n       int total;\n       \n       public void run() {\n           synchronized(this) {\n               for(int i = 0; i<100; i++){\n                   total += i;\n               }\n               \n               notify();\n           }\n       }\n   }','Threads',0,0,NULL,5),(603,'will not compile non static variable this cannot be referenced from\na static context. ','public class Hello {\n    \n   public static void main (String [] args){\n       \n       ThreadB b = new ThreadB();\n       b.start();\n       \n       synchronized(this) {\n           try {\n               System.out.println(\"waiting for b to complete...\");\n               b.wait();\n           } catch(InterruptedException e) { }\n           \n           System.out.println(\"Total is \" + b.total);\n       }\n \n   }\n  \n}','Threads',0,0,NULL,5),(604,'','use notifyAll() to signal all waiting threads,\nnotify() will only signal one unspecified thread.','Threads',0,0,NULL,5),(605,'this programm will wait indefinately, \nbecause the calculator was never started so the threads will continuously\nwait for it. ','public class Hello {\n    \n   public static void main (String [] args){\n      \n        Calculator cal = new Calculator();\n        new Reader(cal).start();\n        new Reader(cal).start();\n        new Reader(cal).start();\n\n   }\n  \n}\n\nclass Reader extends Thread {\n    Calculator c;\n    \n    public Reader(Calculator calc) {\n        c = calc;\n    }\n    \n    public void run(){\n        synchronized(c) {\n            try {\n                System.out.println(\"Waiting for calc\");\n                    c.wait();\n            } catch(InterruptedException e){ }\n                \n            System.out.println(\"Total is: \"+ c.total);\n            \n        }\n    }\n}\n\nclass Calculator implements Runnable {\n    int total;\n    \n    public void run() {\n        synchronized(this) {\n            for(int i = 0; i < 100; i++){\n                total += i;\n            }\n            notifyAll();\n        }\n    }\n}','Threads',0,0,NULL,5),(606,'will not compile, run() in Calculator cannot override run() in Runnable\noverriding method is static','public class Hello {\n    \n   public static void main (String [] args){\n      \n        Calculator cal = new Calculator();\n        new Reader(cal).start();\n        new Reader(cal).start();\n        new Reader(cal).start();\n        new Thread(cal).start();\n\n   }\n  \n}\n\nclass Reader extends Thread {\n    Calculator c;\n    \n    public Reader(Calculator calc) {\n        c = calc;\n    }\n    \n    public void run(){\n        synchronized(c) {\n            try {\n                System.out.println(\"Waiting for calc\");\n                    c.wait();\n            } catch(InterruptedException e){ }\n                \n            System.out.println(\"Total is: \"+ c.total);\n            \n        }\n    }\n}\n\nclass Calculator implements Runnable {\n    int total;\n    \n    public static void run() {\n        synchronized(this) {\n            for(int i = 0; i < 100; i++){\n                total += i;\n            }\n            notifyAll();\n        }\n    }\n}','Threads',0,0,NULL,5),(607,'Will not compile Collections.asList() does not exist \n\nyour thinking of Arrays.asList();','public String getSection(){\n	String[] sections = {\"ABD\",\"AfG\",\"HTL\",\"AtL\",\"MAX\",\"AKH\",\"TYU\"};	\n     List<String> sectionList = Collections.asList(sections);\n     Collections.shuffle(sectionList);\n     String ret = sectionList.get(counter);\n	counter++;\n	return ret;\n}','Threads',0,0,NULL,5),(608,'will not compile, \n\nList<String> coming from Arrays.asList cannot be converted to ArrayList.\n\nTherefore secionList should be a List<String>\n',' public String getSection(){\n            String[] sections = {\"ABD\",\"AfG\",\"HTL\",\"AtL\",\"MAX\",\"AKH\",\"TYU\"};\n            ArrayList sectionList = Arrays.asList(sections); \n            Collections.shuffle(sectionList);\n            String ret = sectionList.get(counter);\n            counter++;\n            return ret;\n        }','Threads',0,0,NULL,5),(609,'It will print an undeterminable series of codes though they will be in order,\n\nthe getSection() method has a block that is synchronized on the CodeMake.class\nobject but that only protects static methods.\n\nso when one thread is synched on CodeMaker.class no other thread can execute \nthat same block of code, here it is no applicable because all the threads \nhave the same block of code. That counter is the same for all threads,\nwhile the sections array is copied across all instances. The array is \nnot mutated in any way though. ','class CodeMaker{\n    private String code = \": \";\n    private static int counter = 0;\n    private String[] sections = {\"ABD\",\"AfG\",\"HTL\",\"AtL\",\"MAX\",\"AKH\",\"TYU\"};\n    \n    \n    class SectionGenerator implements Runnable{\n        //private static int counter = 0; cannot have static members in inner class\n           \n        public String getSection(){\n            \n            synchronized(CodeMaker.class){\n                //sections.size()\n                if(counter < sections.length){\n                    String sec = sections[counter];\n                    counter++;\n                    return sec;\n                }\n            }\n            return null;\n        }\n        \n        public void run() {\n            code += getSection() + \" : \";\n        }\n\n    }\n    \n    public void coder(){\n        for(int i = 0; i < 7; i++){\n            new Thread(new SectionGenerator()).start();\n        }\n        System.out.println(\"code: \"+code);\n    }\n    \n    \n}','Threads',0,0,NULL,5),(610,'will not compile illegal modifier static in inner class, \n\nto fix you would have to make counter final but that would defeat the\npurpose of having a counter!','class CodeMaker{\n    private String code = \": \";\n    private String[] sections = {\"ABD\",\"AfG\",\"HTL\",\"AtL\",\"MAX\",\"AKH\",\"TYU\"};\n    \n    \n    class SectionGenerator implements Runnable{\n        private static int counter = 0;\n           \n        public String getSection(){\n            \n            synchronized(CodeMaker.class){\n                //sections.size()\n                if(counter < sections.length){\n                    String sec = sections[counter];\n                    counter++;\n                    return sec;\n                }\n            }\n            return null;\n        }\n        \n        public void run() {\n            code += getSection() + \" : \";\n        }\n\n    }\n    \n    public void coder(){\n        for(int i = 0; i <= 7; i++){\n            new Thread(new SectionGenerator()).start();\n        }\n        System.out.println(\"code: \"+code);\n    }\n    \n    \n}','Threads',0,0,NULL,5),(611,'will not compile, an array does not have a size() method \nit has a length attribute','class CodeMaker{\n    private String code = \": \";\n    private static int counter = 0;\n    private String[] sections = {\"ABD\",\"AfG\",\"HTL\",\"AtL\",\"MAX\",\"AKH\",\"TYU\"};\n    \n    \n    class SectionGenerator implements Runnable{\n           \n        public String getSection(){\n            \n            synchronized(CodeMaker.class){\n                if(counter < sections.size()){\n                    String sec = sections[counter];\n                    counter++;\n                    return sec;\n                }\n            }\n            return null;\n        }\n        \n        public void run() {\n            code += getSection() + \" : \";\n        }\n\n    }\n    \n    public void coder(){\n        for(int i = 0; i <= 7; i++){\n            new Thread(new SectionGenerator()).start();\n        }\n        System.out.println(\"code: \"+code);\n    }\n    \n    \n}','Threads',0,0,NULL,5),(612,'code: : AfG : HTL : AtL : MAX : \ncode: : ABD : AfG : HTL : AtL : MAX : AKH : TYU : \ncode: : ABD : AfG : HTL : AtL : MAX : AKH : TYU :\ncode: : ABD : HTL : AtL : MAX : AKH : TYU : \ncode: : ABD : AfG : HTL : AtL : MAX : AKH : TYU : \n\n...results from a few different runs. Without synchronization you cannot\nbe sure what will print because one thread could come in bewteen execution\nof getSection() and disrupt the results. This however will not change the\norder in which the code are retrieved because no matter \nhow choatic the threads execute there is no code that will\ncause static int counter to decrease or increase more than one. \n','class CodeMaker{\n    private String code = \": \";\n    private static int counter = 0;\n    private String[] sections = {\"ABD\",\"AfG\",\"HTL\",\"AtL\",\"MAX\",\"AKH\",\"TYU\"};\n    \n    \n    class SectionGenerator implements Runnable{\n           \n        public String getSection(){\n            \n                if(counter < sections.length){\n                    String sec = sections[counter];\n                    counter++;\n                    return sec;\n                }\n            \n            return null;\n        }\n        \n        public void run() {\n            code += getSection() + \" : \";\n        }\n\n    }\n    \n    public void coder(){\n        for(int i = 0; i <= 7; i++){\n            new Thread(new SectionGenerator()).start();\n        }\n        System.out.println(\"code: \"+code);\n    }\n    \n    \n}','Threads',0,0,NULL,5),(613,'This code will not print accurate results as in it will not reliably\nprint all the sections. \n\nThis is becaue the reading of a code and tacking it into the complete \ncode is not an atomic operation. \n\nto uniformly print all the codes you would do this:\n\n	class SectionGenerator implements Runnable{\n\n        public void run() {\n            synchronized(CodeMaker.class){\n            \n                if(counter < sections.length){\n                    String sec = sections[counter];\n                    counter++;\n                    code += sec + \" : \";\n                }\n\n                \n            }\n        }\n\n    }','class CodeMaker{\n    private String code = \": \";\n    private int counter = 0;\n    private static String[] sections = {\"ABD\",\"AfG\",\"HTL\",\"AtL\",\"MAX\",\"AKH\",\"TYU\"};\n    \n    \n    class SectionGenerator implements Runnable{\n           \n        public String getSection(){\n            \n            synchronized(CodeMaker.class){\n            \n                if(counter < sections.length){\n                    String sec = sections[counter];\n                    counter++;\n                    return sec;\n                }\n                \n                return null;\n                \n            }\n            \n            \n        }\n        \n        public void run() {\n            code += getSection() + \" : \";\n        }\n\n    }\n    \n    public void coder(){\n        for(int i = 0; i <= 7; i++){\n            new Thread(new SectionGenerator()).start();\n        }\n        System.out.println(\"code: \"+code);\n    }\n    \n    \n}\n\npublic class Hello {\n    \n   public static void main (String [] args){\n      new CodeMaker().coder();\n\n   }\n  \n}','Threads',0,0,NULL,5),(614,'will print:\n\ncode: : ABD : AfG : HTL : AtL : MAX : AKH : TYU :\n\nevery time. \n\nin previous questions counter was not static, if that were the case here\nresults would not be predictable. ','class CodeMaker{\n    private String code = \": \";\n    private int counter = 0;\n    private static String[] sections = {\"ABD\",\"AfG\",\"HTL\",\"AtL\",\"MAX\",\"AKH\",\"TYU\"};\n    \n    \n    class SectionGenerator implements Runnable{\n\n        public void run() {\n            synchronized(CodeMaker.class){\n            \n                if(counter < sections.length){\n                    String sec = sections[counter];\n                    counter++;\n                    code += sec + \" : \";\n                }\n\n                \n            }\n        }\n\n    }\n    \n    public void coder(){\n        for(int i = 0; i <= 7; i++){\n            new Thread(new SectionGenerator()).start();\n        }\n        System.out.println(\"code: \"+code);\n    }\n    \n    \n}\n\npublic class Hello {\n    \n   public static void main (String [] args){\n      new CodeMaker().coder();\n\n   }\n  \n}','Threads',0,0,NULL,5),(615,'will produce unpredictable results because counter is not static, so\nits access is not locked by synchronization onto CodeMaker.class\n','public class Hello {\n    \n   public static void main (String [] args){\n      new CodeMaker().coder();\n\n   }\n  \n}\n\nclass CodeMaker{\n    private String code = \": \";\n    private int counter = 0;\n    private static String[] sections = {\"ABD\",\"AfG\",\"HTL\",\"AtL\",\"MAX\",\"AKH\",\"TYU\"};\n    \n    \n    class SectionGenerator implements Runnable{\n\n        public void run() {\n            synchronized(CodeMaker.class){\n            \n                if(counter < sections.length){\n                    String sec = sections[counter];\n                    counter++;\n                    code += sec + \" : \";\n                }\n                \n            }\n        }\n\n    }\n    \n    public void coder(){\n        for(int i = 0; i <= 7; i++){\n            new Thread(new SectionGenerator()).start();\n        }\n        System.out.println(\"code: \"+code);\n    }\n    \n    \n}','Threads',0,0,NULL,5),(616,'without synchronization here the results will be wildly unpredictable.','class statPrinter {\n    private int counter = 0;\n    \n    class Adder implements Runnable {\n        \n        public void run(){\n                //Thread.sleep(1000); with no try\n                counter++;\n                System.out.println(counter + \", Adder +1 \");  \n        }\n    }\n    \n    class Minuser implements Runnable {\n        public void run() {\n                counter--;\n                System.out.println(counter+\", Minuser -1 \");    \n        }\n    }\n    \n    public void test(){\n        for(int i = 0; i < 100; i++){\n            new Thread(new Adder()).start();\n            new Thread(new Minuser()).start();\n            \n        }\n    }\n}','Threads',0,0,NULL,5),(617,'will not compile, unreported interrupt exception coming from \nThread.sleep();\n\nmust wrap in try catch or declare it to be thrown','class statPrinter {\n    private int counter = 0;\n    \n    class Adder implements Runnable {\n        \n        public void run(){\n                Thread.sleep(1000); \n                counter++;\n                System.out.println(counter + \", Adder +1 \");  \n        }\n    }\n    \n    class Minuser implements Runnable {\n        public void run() {\n                Thread.sleep(500);\n                counter--;\n                System.out.println(counter+\", Minuser -1 \");    \n        }\n    }\n    \n    public void test(){\n        for(int i = 0; i < 100; i++){\n            new Thread(new Adder()).start();\n            new Thread(new Minuser()).start();\n            \n        }\n    }\n}','Threads',0,0,NULL,5),(618,'These results are unpredicatable, \n\nyes run() can be synched, these two methods synchronize on the current\nobject, all that means is that theyre code \n\n	counter++;\n     System.out.println(counter+\", Minuser -1 \"); \n\n	counter--;\n      System.out.println(counter+\", Minuser -1 \"); 	\n\nwill run in order completely without being interrupted by another thread.\n\nhowever that does not stop another thread from jumping the gun and being\nrun twice though!\n\n','class statPrinter {\n    private int counter = 0;\n    \n    class Adder implements Runnable {\n        \n        public synchronized void run(){\n                counter++;\n                System.out.println(counter + \", Adder +1 \");  \n        }\n    }\n    \n    class Minuser implements Runnable {\n        public synchronized void run() {\n                counter--;\n                System.out.println(counter+\", Minuser -1 \");    \n        }\n    }\n    \n    public void test(){\n        for(int i = 0; i < 100; i++){\n            new Thread(new Adder()).start();\n            new Thread(new Minuser()).start();\n            \n        }\n    }\n}','Threads',0,0,NULL,5),(619,'this will give unpredictable results, \n\npublic void run() {\n            synchronized(this){\n                counter--;\n                System.out.println(counter+\", Minuser -1 \");   \n            }\n        }\n\nis the same as\n\npublic synchronized void run(){\n	...\n}\n\n\nthey both lock onto the current obejct, meaning no other thread can\naccess that object. The variable of concern here though is counter which\nis a variable of the statPrinter object. ','class statPrinter {\n    private int counter = 0;\n    \n    class Adder implements Runnable {\n        \n        public void run(){\n            synchronized(this){\n                counter++;\n                System.out.println(counter + \", Adder +1 \");  \n            }\n        }\n    }\n    \n    class Minuser implements Runnable {\n        public void run() {\n            synchronized(this){\n                counter--;\n                System.out.println(counter+\", Minuser -1 \");   \n            }\n        }\n    }\n    \n    public void test(){\n        for(int i = 0; i < 100; i++){\n            new Thread(new Adder()).start();\n            new Thread(new Minuser()).start();\n            \n        }\n    }\n}','Threads',0,0,NULL,5),(620,'Will not compile you cannot intitialize an array with shorthand like that.\nBecause, at the time of creation java wants to know excactly how \nmuch memory to allocate when you jsut create the reference you basically\ncreate nothing.\n\nin the constructor you whene you initialize you have to excplicitly\ncreate the memory with the new array using new. \n\nto compile do this:\n	\n	sections = new String[]{\"ABD\",\"AfG\",\"HTL\",\"AtL\",\"MAX\",\"AKH\",\"TYU\"};','class CodeMaker{\n    private String code;\n    private int counter;\n    private static String[] sections;\n    private ArrayList<String> al;\n    \n    public CodeMaker(){\n        code = \": \";\n        counter = 0;\n        sections = {\"ABD\",\"AfG\",\"HTL\",\"AtL\",\"MAX\",\"AKH\",\"TYU\"};\n        al = new ArrayList<>();\n    }\n    \n    \n    class SectionGenerator implements Runnable{\n\n        public void run() {\n            synchronized(CodeMaker.class){\n            \n                if(counter < sections.length){\n                    String sec = sections[counter];\n                    counter++;\n                    code += sec + \" : \";\n                }\n                \n            }\n        }\n\n    }\n    \n    public void coder(){\n        for(int i = 0; i <= 10; i++){\n            new Thread(new SectionGenerator()).start();\n        }\n        System.out.println(\"code: \"+code);\n    }\n    \n    \n}','Threads',0,0,NULL,5),(621,'will not compile, Constructors cannot be synchronized. ','class CodeMaker{\n    private String code;\n    private int counter;\n    private static String[] sections;\n    private ArrayList<String> al;\n    \n    public synchronized CodeMaker(){\n        code = \": \";\n        counter = 0;\n        sections = new String[]{\"ABD\",\"AfG\",\"HTL\",\"AtL\",\"MAX\",\"AKH\",\"TYU\"};\n        al = new ArrayList<>();\n    }\n    \n    \n    class SectionGenerator implements Runnable{\n\n        public void run() {\n            synchronized(CodeMaker.class){\n            \n                if(counter < sections.length){\n                    String sec = sections[counter];\n                    counter++;\n                    code += sec + \" : \";\n                }\n                \n            }\n        }\n\n    }\n    \n    public void coder(){\n        for(int i = 0; i <= 10; i++){\n            new Thread(new SectionGenerator()).start();\n        }\n        System.out.println(\"code: \"+code);\n    }\n    \n    \n}','Threads',0,0,NULL,5),(622,'will not compile becaue of wait(),\n\nureported exception, interruptedexception, must be caught or thrown\n\n','class CodeMaker  extends Thread {\n    private String code;\n    private int counter;\n    private ArrayList<String> al;\n    private char[] letters = {\'A\',\'B\',\'C\',\'D\',\'E\',\'F\',\'G\',\'H\',\'I\'};\n    \n    public CodeMaker(){\n        counter = 0;\n        al = new ArrayList<>();\n    }\n\n    class SectionGenerator implements Runnable{\n        private String sec = \"\";\n        private Random ran;\n\n        public void run() {\n            //tried to use notify outside of synchronized context\n            synchronized(this){\n                int x = ran.nextInt(3);\n                int y = ran.nextInt(3);\n                int z = ran.nextInt(3);\n            \n            \n                sec += letters[x];\n                sec += letters[y];\n                sec += letters[z];\n                notifyAll();\n            }\n        }\n        \n        public synchronized String section(){\n            return sec;\n        }\n\n    }\n    \n    class NumberGenerator implements Runnable{\n        private String number = \"\";\n        private Random ran;\n        \n        public void run(){\n            //tried to use notify outside of synchronized context\n            synchronized(this){\n                int x1 = ran.nextInt(100);\n                int x2 = ran.nextInt(100);\n                int x3 = ran.nextInt(100);\n            \n                number+= x1+\".\"+x2+\".\"+x3;\n                notifyAll();\n            }\n        }\n        \n        public synchronized String Number(){\n            return number;\n        }\n    }\n    \n   public void run(){\n       \n       SectionGenerator sg1 = new SectionGenerator();\n       NumberGenerator ng1 = new NumberGenerator();\n       Thread t1 = new Thread(sg1);\n       Thread t2 = new Thread(ng1);\n       \n       t1.start();\n       t2.start();\n       \n       t1.wait();\n       code += sg1.section();\n       t2.wait();\n       code += ng1.Number();\n       \n       System.out.println(code);\n\n       \n   }\n    \n    \n}\n','Threads',0,0,NULL,5),(623,'will not compile, not a proper override of run(),\n\noverrides cannot throw new or broader checked exceptions','class CodeMaker  extends Thread {\n    private String code;\n    private int counter;\n    private ArrayList<String> al;\n    private char[] letters = {\'A\',\'B\',\'C\',\'D\',\'E\',\'F\',\'G\',\'H\',\'I\'};\n    \n    public CodeMaker(){\n        counter = 0;\n        al = new ArrayList<>();\n    }\n\n    class SectionGenerator implements Runnable{\n        private String sec = \"\";\n        private Random ran;\n\n        public void run() {\n            //tried to use notify outside of synchronized context\n            synchronized(this){\n                int x = ran.nextInt(3);\n                int y = ran.nextInt(3);\n                int z = ran.nextInt(3);\n            \n            \n                sec += letters[x];\n                sec += letters[y];\n                sec += letters[z];\n                notifyAll();\n            }\n        }\n        \n        public synchronized String section(){\n            return sec;\n        }\n\n    }\n    \n    class NumberGenerator implements Runnable{\n        private String number = \"\";\n        private Random ran;\n        \n        public void run(){\n            //tried to use notify outside of synchronized context\n            synchronized(this){\n                int x1 = ran.nextInt(100);\n                int x2 = ran.nextInt(100);\n                int x3 = ran.nextInt(100);\n            \n                number+= x1+\".\"+x2+\".\"+x3;\n                notifyAll();\n            }\n        }\n        \n        public synchronized String Number(){\n            return number;\n        }\n    }\n    \n   public void run() throws InterruptedException {\n       \n       SectionGenerator sg1 = new SectionGenerator();\n       NumberGenerator ng1 = new NumberGenerator();\n       Thread t1 = new Thread(sg1);\n       Thread t2 = new Thread(ng1);\n       \n       t1.start();\n       t2.start();\n       \n       t1.wait();\n       code += sg1.section();\n       t2.wait();\n       code += ng1.Number();\n       \n       System.out.println(code);\n\n       \n   }\n    \n    \n}','Threads',0,0,NULL,5),(624,'NPE, ran is nevere intitialized. ','public class Hello extends Thread {\n    public static void main(String[] args){\n        new CodeMaker().start();\n    }\n}\n\nclass CodeMaker  extends Thread {\n    private String code;\n    private int counter;\n    private ArrayList<String> al;\n    private char[] letters = {\'A\',\'B\',\'C\',\'D\',\'E\',\'F\',\'G\',\'H\',\'I\'};\n    \n    public CodeMaker(){\n        counter = 0;\n        al = new ArrayList<>();\n    }\n\n    class SectionGenerator implements Runnable{\n        private String sec = \"\";\n        private Random ran;\n\n        public void run() {\n            //tried to use notify outside of synchronized context\n            synchronized(this){\n                int x = ran.nextInt(3);\n                int y = ran.nextInt(3);\n                int z = ran.nextInt(3);\n            \n            \n                sec += letters[x];\n                sec += letters[y];\n                sec += letters[z];\n                notifyAll();\n            }\n        }\n        \n        public synchronized String section(){\n            return sec;\n        }\n\n    }\n    \n    class NumberGenerator implements Runnable{\n        private String number = \"\";\n        private Random ran;\n        \n        public void run(){\n            //tried to use notify outside of synchronized context\n            synchronized(this){\n                int x1 = ran.nextInt(100);\n                int x2 = ran.nextInt(100);\n                int x3 = ran.nextInt(100);\n            \n                number += x1+\".\"+x2+\".\"+x3;\n                notifyAll();\n            }\n        }\n        \n        public synchronized String Number(){\n            return number;\n        }\n    }\n    \n   public synchronized void run(){\n       \n       SectionGenerator sg1 = new SectionGenerator();\n       NumberGenerator ng1 = new NumberGenerator();\n       Thread t1 = new Thread(sg1);\n       Thread t2 = new Thread(ng1);\n       \n       t1.start();\n       t2.start();\n       \n       try{\n        t1.wait();\n        code += sg1.section();\n        t2.wait();\n        code += ng1.Number();\n       } catch(InterruptedException e){\n           \n       }\n       System.out.println(code);\n\n       \n   }\n    \n    \n}','Threads',0,0,NULL,5),(625,'IllegalMonitorStateException, ','public class Hello extends Thread {\n    public static void main(String[] args){\n        new CodeMaker().start();\n    }\n}\n\nclass CodeMaker  extends Thread {\n    private String code;\n    private int counter;\n    private ArrayList<String> al;\n    private char[] letters = {\'A\',\'B\',\'C\',\'D\',\'E\',\'F\',\'G\',\'H\',\'I\'};\n    \n    public CodeMaker(){\n        counter = 0;\n        al = new ArrayList<>();\n    }\n\n    class SectionGenerator implements Runnable{\n        private String sec = \"\";\n        private Random ran = new Random();\n\n        public void run() {\n            //tried to use notify outside of synchronized context\n            synchronized(this){\n                int x = ran.nextInt(3);\n                int y = ran.nextInt(3);\n                int z = ran.nextInt(3);\n            \n            \n                sec += letters[x];\n                sec += letters[y];\n                sec += letters[z];\n                notifyAll();\n            }\n        }\n        \n        public synchronized String section(){\n            return sec;\n        }\n\n    }\n    \n    class NumberGenerator implements Runnable{\n        private String number = \"\";\n        private Random ran = new Random();\n        \n        public void run(){\n            //tried to use notify outside of synchronized context\n            synchronized(this){\n                int x1 = ran.nextInt(100);\n                int x2 = ran.nextInt(100);\n                int x3 = ran.nextInt(100);\n            \n                number += x1+\".\"+x2+\".\"+x3;\n                notifyAll();\n            }\n        }\n        \n        public synchronized String Number(){\n            return number;\n        }\n    }\n    \n   public synchronized void run(){\n       \n       SectionGenerator sg1 = new SectionGenerator();\n       NumberGenerator ng1 = new NumberGenerator();\n       Thread t1 = new Thread(sg1);\n       Thread t2 = new Thread(ng1);\n       \n       t1.start();\n       t2.start();\n       \n       try{\n        t1.wait();\n        code += sg1.section();\n        t2.wait();\n        code += ng1.Number();\n       } catch(InterruptedException e){\n           \n       }\n       System.out.println(code);\n\n       \n   }\n    \n    \n}','Threads',0,0,NULL,5),(626,'will not compile, static classes are not allowed in inner classes,\n\nonly static final varialbe definitions is allowed.','public class Hello extends Thread {\n    public static void main(String[] args){\n        \n    }\n    \n    class Operator extends Thread {\n        Machine machine = new Machine();\n        Machine.MachineInstructions job;\n        \n        public void run(){\n            while(true){\n                String shape = getShapeFromUser();\n                job = calculateNewInstructionsFor(shape);\n                \n                machine.addJob(job);\n            }\n        }\n        \n        public Machine.MachineInstructions calculateNewInstructionsFor(String x){\n            // dah duh duu da du\n            return machine.new MachineInstructions();\n        }\n        \n        public String getShapeFromUser(){\n            System.out.println(\"What shape? square ok thanks\");\n            return \"Square\";\n        }\n        \n    }\n    \n    class Machine extends Thread {\n        List<MachineInstructions> joblist = new ArrayList<>(0);\n        \n        public void addJob(MachineInstructions job){\n            synchronized(joblist){\n                joblist.add(job);\n                joblist.notify();\n            }\n        }\n        \n        public void run(){\n            while(true) {\n                synchronized(joblist) {\n                    //wait until at least one job is available\n                    while(joblist.isEmpty()) {\n                        try{\n                            joblist.wait();\n                        } catch(InterruptedException ei){\n                            \n                        }\n                        \n                        //if we get here you know the list is\'nt empty\n                        MachineInstructions inst = joblist.remove(0);\n                        \n                    }\n                }\n            }\n        }\n        \n        \n        static class MachineInstructions {\n            \n        }\n    }\n}','Threads',0,0,NULL,5),(627,'will not compile, non static inner classes cannot be accessed from static\nmain','public class Hello extends Thread {\n    public static void main(String[] args){\n        new Operator().start();\n        new Machine().start();\n    }\n    \n    class Operator extends Thread {\n        Machine machine = new Machine();\n        Machine.MachineInstructions job;\n        \n        public void run(){\n            while(true){\n                String shape = getShapeFromUser();\n                job = calculateNewInstructionsFor(shape);\n                \n                machine.addJob(job);\n            }\n        }\n        \n        public Machine.MachineInstructions calculateNewInstructionsFor(String x){\n            // dah duh duu da du\n            return machine.new MachineInstructions(x);\n        }\n        \n        public String getShapeFromUser(){\n            System.out.println(\"What shape? square ok thanks\");\n            return \"Square\";\n        }\n        \n    }\n    \n    class Machine extends Thread {\n        List<MachineInstructions> joblist = new ArrayList<>();\n        \n        public void addJob(MachineInstructions job){\n            synchronized(joblist){\n                joblist.add(job);\n                joblist.notify();\n            }\n        }\n        \n        public void run(){\n            while(true) {\n                synchronized(joblist) {\n                    //wait until at least one job is available\n                    while(joblist.isEmpty()) {\n                        try{\n                            joblist.wait();\n                        } catch(InterruptedException ei){\n                            \n                        }\n                        \n                        //if we get here you know the list is\'nt empty\n                        MachineInstructions inst = joblist.remove(0);\n                        \n                        \n                    }\n                }\n            }\n        }\n        \n        \n        class MachineInstructions {\n            private String shape;\n            \n            public MachinInstructions(String shape){\n                this.shape = shape;\n            }\n            public void produceShape(){\n                System.out.println(\"Here\'s your :\"+shape);\n            }\n            \n        }\n    }\n}','Threads',0,0,NULL,5),(628,'will not compile non static instance variable cannot be referenced \nfrom static main','public class Hello extends Thread {\n    Operator op = new Operator();\n    Machine m = new Machine();\n    public static void main(String[] args){\n        op.start();\n        m.start();\n    }\n    \n    class Operator extends Thread {\n        Machine machine = new Machine();\n        Machine.MachineInstructions job;\n        \n        public void run(){\n            while(true){\n                String shape = getShapeFromUser();\n                job = calculateNewInstructionsFor(shape);\n                \n                machine.addJob(job);\n            }\n        }\n        \n        public Machine.MachineInstructions calculateNewInstructionsFor(String x){\n            // dah duh duu da du\n            return machine.new MachineInstructions(x);\n        }\n        \n        public String getShapeFromUser(){\n            System.out.println(\"What shape? square ok thanks\");\n            return \"Square\";\n        }\n        \n    }\n    \n    class Machine extends Thread {\n        List<MachineInstructions> joblist = new ArrayList<>();\n        \n        public void addJob(MachineInstructions job){\n            synchronized(joblist){\n                joblist.add(job);\n                joblist.notify();\n            }\n        }\n        \n        public void run(){\n            while(true) {\n                synchronized(joblist) {\n                    //wait until at least one job is available\n                    while(joblist.isEmpty()) {\n                        try{\n                            joblist.wait();\n                        } catch(InterruptedException ei){\n                            \n                        }\n                        \n                        //if we get here you know the list is\'nt empty\n                        MachineInstructions inst = joblist.remove(0);\n                        \n                        \n                    }\n                }\n            }\n        }\n        \n        \n        class MachineInstructions {\n            private String shape;\n            \n            public MachinInstructions(String shape){\n                this.shape = shape;\n            }\n            public void produceShape(){\n                System.out.println(\"Here\'s your :\"+shape);\n            }\n            \n        }\n    }\n}','Threads',0,0,NULL,5),(629,'will not compile non static variable this cannot be reference from a static\ncontext. \n\nthe inner classes are instance classes so, even though you define \nthe variables as static they have to use this to access the inner class\n\nso it will still not compile','public class Hello extends Thread {\n    private static Operator op = new Operator();\n    private static Machine m = new Machine();\n    public static void main(String[] args){\n        op.start();\n        m.start();\n    }\n    \n    class Operator extends Thread {\n        Machine machine = new Machine();\n        Machine.MachineInstructions job;\n        \n        public void run(){\n            while(true){\n                String shape = getShapeFromUser();\n                job = calculateNewInstructionsFor(shape);\n                \n                machine.addJob(job);\n            }\n        }\n        \n        public Machine.MachineInstructions calculateNewInstructionsFor(String x){\n            // dah duh duu da du\n            return machine.new MachineInstructions(x);\n        }\n        \n        public String getShapeFromUser(){\n            System.out.println(\"What shape? square ok thanks\");\n            return \"Square\";\n        }\n        \n    }\n    \n    class Machine extends Thread {\n        List<MachineInstructions> joblist = new ArrayList<>();\n        \n        public void addJob(MachineInstructions job){\n            synchronized(joblist){\n                joblist.add(job);\n                joblist.notify();\n            }\n        }\n        \n        public void run(){\n            while(true) {\n                synchronized(joblist) {\n                    //wait until at least one job is available\n                    while(joblist.isEmpty()) {\n                        try{\n                            joblist.wait();\n                        } catch(InterruptedException ei){\n                            \n                        }\n                        \n                        //if we get here you know the list is\'nt empty\n                        MachineInstructions inst = joblist.remove(0);\n                        \n                        \n                    }\n                }\n            }\n        }\n        \n        \n        class MachineInstructions {\n            private String shape;\n            \n            public MachinInstructions(String shape){\n                this.shape = shape;\n            }\n            public void produceShape(){\n                System.out.println(\"Here\'s your :\"+shape);\n            }\n            \n        }\n    }\n}','Threads',0,0,NULL,5),(630,'will produce: \n	What shape? square ok thanks\n	What shape? square ok thanks\n	What shape? square ok thanks\n	What shape? square ok thanks\n...ad infinum\n\nThe conintinuos loops are meant to keep checking for new shapes. \n\nnotice that one of the threads is alwasy synched in with the jobslist\n\nthey then use wait and notify to bounce back and forth.','public class Hello extends Thread {\n \n    public static void main(String[] args){\n        Hello h = new Hello();\n        h.new Operator().start();\n        h.new Machine().start();\n    }\n    \n    class Operator extends Thread {\n        Machine machine = new Machine();\n        Machine.MachineInstructions job;\n        \n        public void run(){\n            while(true){\n                String shape = getShapeFromUser();\n                job = calculateNewInstructionsFor(shape);\n                \n                machine.addJob(job);\n            }\n        }\n        \n        public Machine.MachineInstructions calculateNewInstructionsFor(String x){\n            // dah duh duu da du\n            return machine.new MachineInstructions(x);\n        }\n        \n        public String getShapeFromUser(){\n            System.out.println(\"What shape? square ok thanks\");\n            return \"Square\";\n        }\n        \n    }\n    \n    class Machine extends Thread {\n        List<MachineInstructions> joblist = new ArrayList<>();\n        \n        public void addJob(MachineInstructions job){\n            synchronized(joblist){\n                joblist.add(job);\n                joblist.notify();\n            }\n        }\n        \n        public void run(){\n            while(true) {\n                synchronized(joblist) {\n                    //wait until at least one job is available\n                    while(joblist.isEmpty()) {\n                        try{\n                            joblist.wait();\n                        } catch(InterruptedException ei){\n                            \n                        }\n                        \n                        //if we get here you know the list is\'nt empty\n                        MachineInstructions inst = joblist.remove(0);\n                        \n                        \n                    }\n                }\n            }\n        }\n        \n        \n        class MachineInstructions {\n            private String shape;\n            \n            public MachineInstructions(String shape){\n                this.shape = shape;\n            }\n            public void produceShape(){\n                System.out.println(\"Here\'s your :\"+shape);\n            }\n            \n        }\n    }\n}','Threads',0,0,NULL,5),(631,'IllegalMonitorStateException\n\nwait in thread machine is called from outside a synchronized context\n\nyou have to synchronized on an object to wait on it. ','public class Hello extends Thread {\n \n    public static void main(String[] args){\n        Hello h = new Hello();\n        h.new Operator().start();\n        h.new Machine().start();\n    }\n    \n    class Operator extends Thread {\n        Machine machine = new Machine();\n        Machine.MachineInstructions job;\n        \n        public void run(){\n            while(true){\n                String shape = getShapeFromUser();\n                job = calculateNewInstructionsFor(shape);\n                \n                machine.addJob(job);\n            }\n        }\n        \n        public Machine.MachineInstructions calculateNewInstructionsFor(String x){\n            // dah duh duu da du\n            return machine.new MachineInstructions(x);\n        }\n        \n        public String getShapeFromUser(){\n            System.out.println(\"What shape? square ok thanks\");\n            return \"Square\";\n        }\n        \n    }\n    \n    class Machine extends Thread {\n        List<MachineInstructions> joblist = new ArrayList<>();\n        \n        public void addJob(MachineInstructions job){\n            synchronized(joblist){\n                joblist.add(job);\n                joblist.notify();\n            }\n        }\n        \n        public void run(){\n            while(true) {\n                    //wait until at least one job is available\n                    while(joblist.isEmpty()) {\n                        try{\n                            joblist.wait();\n                        } catch(InterruptedException ei){\n                            \n                        }\n                        \n                        //if we get here you know the list is\'nt empty\n                        MachineInstructions inst = joblist.remove(0);\n                        \n                        \n                    }\n            }\n        }\n        \n        \n        class MachineInstructions {\n            private String shape;\n            \n            public MachineInstructions(String shape){\n                this.shape = shape;\n            }\n            public void produceShape(){\n                System.out.println(\"Here\'s your :\"+shape);\n            }\n            \n        }\n    }\n}','Threads',0,0,NULL,5),(632,'IllegalMonitorStateException, \n\nnotify() in addJob is called without being synched with joblist.\n\nyou have to be synched on an object to wait on it or notify it.\n\nRemember you wait and notify objects not threads. ','public class Hello extends Thread {\n \n    public static void main(String[] args){\n        Hello h = new Hello();\n        h.new Operator().start();\n        h.new Machine().start();\n    }\n    \n    class Operator extends Thread {\n        Machine machine = new Machine();\n        Machine.MachineInstructions job;\n        \n        public void run(){\n            while(true){\n                String shape = getShapeFromUser();\n                job = calculateNewInstructionsFor(shape);\n                \n                machine.addJob(job);\n            }\n        }\n        \n        public Machine.MachineInstructions calculateNewInstructionsFor(String x){\n            // dah duh duu da du\n            return machine.new MachineInstructions(x);\n        }\n        \n        public String getShapeFromUser(){\n            System.out.println(\"What shape? square ok thanks\");\n            return \"Square\";\n        }\n        \n    }\n    \n    class Machine extends Thread {\n        List<MachineInstructions> joblist = new ArrayList<>();\n        \n        public void addJob(MachineInstructions job){\n                joblist.add(job);\n                joblist.notify();\n        }\n        \n        public void run(){\n            while(true) {\n                synchronized(joblist) {\n                    //wait until at least one job is available\n                    while(joblist.isEmpty()) {\n                        try{\n                            joblist.wait();\n                        } catch(InterruptedException ei){\n                            \n                        }\n                        \n                        //if we get here you know the list is\'nt empty\n                        MachineInstructions inst = joblist.remove(0);\n                        \n                        \n                    }\n                }\n            }\n        }\n        \n        \n        class MachineInstructions {\n            private String shape;\n            \n            public MachineInstructions(String shape){\n                this.shape = shape;\n            }\n            public void produceShape(){\n                System.out.println(\"Here\'s your :\"+shape);\n            }\n            \n        }\n    }\n}','Threads',0,0,NULL,5),(633,'Here butterfingers is unable to get his meaty claws on the same machine \nthe operator is using becasue those two are instance classes created \nin static main, joblist is an instance variable so the one they are \nusing belongs to the instance created in main. \n\nButterFinger created his own seperated machine to fuck with here, good\nso the output will be \n\nWhat shape? square ok thanks\nWhat shape? square ok thanks\nWhat shape? square ok thanks\nWhat shape? square ok thanks     for ever and ever. ','//ignore the answer try to figure out what wrong with this thin\npublic class Hello extends Thread {\n \n    public static void main(String[] args){\n        Hello h = new Hello();\n        h.new Operator().start();\n        h.new Machine().start();\n        new ButterFinger().start();\n    }\n    \n    class Operator extends Thread {\n        Machine machine = new Machine();\n        Machine.MachineInstructions job;\n        \n        public void run(){\n            while(true){\n                String shape = getShapeFromUser();\n                job = calculateNewInstructionsFor(shape);\n                \n                machine.addJob(job);\n            }\n        }\n        \n        public Machine.MachineInstructions calculateNewInstructionsFor(String x){\n            // dah duh duu da du\n            return machine.new MachineInstructions(x);\n        }\n        \n        public String getShapeFromUser(){\n            System.out.println(\"What shape? square ok thanks\");\n            return \"Square\";\n        }\n        \n    }\n    \n    class Machine extends Thread {\n        private List<MachineInstructions> joblist = new ArrayList<>();\n        \n        public void addJob(MachineInstructions job){\n            synchronized(joblist){\n                joblist.add(job);\n                joblist.notifyAll();\n            }\n        }\n        \n        public void run(){\n            while(true) {\n                synchronized(joblist) {\n                    //wait until at least one job is available\n                    while(joblist.isEmpty()) {\n                        try{\n                            joblist.wait();\n                        } catch(InterruptedException ei){\n                            \n                        }\n                        \n                        //if we get here you know the list is\'nt empty\n                        MachineInstructions inst = joblist.remove(0);\n                        \n                        \n                    }\n                }\n            }\n        }\n        \n        \n        class MachineInstructions {\n            private String shape;\n            \n            public MachineInstructions(String shape){\n                this.shape = shape;\n            }\n            public void produceShape(){\n                System.out.println(\"Here\'s your :\"+shape);\n            }\n            \n        }\n    }\n     \n}\n\nclass ButterFinger extends Thread {\n    private Hello h = new Hello();\n    private Hello.Machine machine = h.new Machine();\n    \n        public void run(){\n            while(true){\n                machine.addJob(machine.new MachineInstructions(\"Whoops I fucked up\"));\n            }\n            \n        }\n}','Threads',0,0,NULL,5),(634,'Butterfinger now has the right machine however the main method never\nstarts him so the output is still \n\nwhat shape? square ok thanks\nWhat shape? square ok thanks\nWhat shape? square ok thanks\nWhat shape? square ok thanks    forever...\n\nno,\n\n	Operator and Machine have no way to connect. Operator has its own\n	version of machine and therefore does not connect with the machine\n	thread that was started in main. ','public class Hello extends Thread {\n    Operator op = new Operator();\n    Machine m = new Machine();\n \n    public static void main(String[] args){\n       Hello h = new Hello();\n       h.op.start();\n       h.m.start();\n    }\n    \n    class Operator extends Thread {\n        Machine machine = new Machine();\n        Machine.MachineInstructions job;\n        \n        public void run(){\n            while(true){\n                String shape = getShapeFromUser();\n                job = calculateNewInstructionsFor(shape);\n                \n                machine.addJob(job);\n            }\n        }\n        \n        public Machine.MachineInstructions calculateNewInstructionsFor(String x){\n            // dah duh duu da du\n            return machine.new MachineInstructions(x);\n        }\n        \n        public String getShapeFromUser(){\n            System.out.println(\"What shape? square ok thanks\");\n            return \"Square\";\n        }\n        \n    }\n    \n    class Machine extends Thread {\n        private List<MachineInstructions> joblist = new ArrayList<>();\n        \n        public void addJob(MachineInstructions job){\n            synchronized(joblist){\n                joblist.add(job);\n                joblist.notifyAll();\n            }\n        }\n        \n        public void run(){\n            while(true) {\n                synchronized(joblist) {\n                    //wait until at least one job is available\n                    while(joblist.isEmpty()) {\n                        try{\n                            joblist.wait();\n                        } catch(InterruptedException ei){\n                            \n                        }\n                        \n                        //if we get here you know the list is\'nt empty\n                        MachineInstructions inst = joblist.remove(0);\n                        \n                        \n                    }\n                }\n            }\n        }\n        \n        \n        class MachineInstructions {\n            private String shape;\n            \n            public MachineInstructions(String shape){\n                this.shape = shape;\n            }\n            public void produceShape(){\n                System.out.println(\"Here\'s your :\"+shape);\n            }\n            \n        }\n    }\n     \n}\n\nclass ButterFinger extends Thread {\n    private Hello h = new Hello();\n    \n        public void run(){\n            while(true){\n                h.m.addJob(h.m.new MachineInstructions(\"Whoops I fucked up\"));\n            }\n            \n        }\n}','Threads',0,0,NULL,5),(635,'IllegalMonitorStateException\n\nyou cannot call start() on a thread more than once. ','public class Hello {\n    public static void main(String[] args){\n        CodeMaker cm = new CodeMaker();\n        \n        for(int i = 0; i<10; i++){\n            cm.start();\n        }\n        \n    }\n}\n\nclass CodeMaker  extends Thread {\n    private String code;\n    private int counter;\n    private ArrayList<String> al;\n    private char[] letters = {\'A\',\'B\',\'C\',\'D\',\'E\',\'F\',\'G\',\'H\',\'I\'};\n    \n    public CodeMaker(){\n        counter = 0;\n        al = new ArrayList<>();\n    }\n\n    class SectionGenerator implements Runnable{\n        private String sec = \"\";\n        private Random ran = new Random();\n\n        public void run() {\n            //tried to use notify outside of synchronized context\n            synchronized(this){\n                int x = ran.nextInt(3);\n                int y = ran.nextInt(3);\n                int z = ran.nextInt(3);\n            \n            \n                sec += letters[x];\n                sec += letters[y];\n                sec += letters[z];\n                notifyAll();\n            }\n        }\n        \n        public synchronized String section(){\n            return sec;\n        }\n\n    }\n    \n    class NumberGenerator implements Runnable{\n        private String number = \"\";\n        private Random ran = new Random();\n        \n        public void run(){\n            //tried to use notify outside of synchronized context\n            synchronized(this){\n                int x1 = ran.nextInt(100);\n                int x2 = ran.nextInt(100);\n                int x3 = ran.nextInt(100);\n            \n                number += x1+\".\"+x2+\".\"+x3;\n                notifyAll();\n            }\n        }\n        \n        public synchronized String Number(){\n            return number;\n        }\n    }\n    \n    \n   public synchronized void run(){\n       \n       SectionGenerator sg1 = new SectionGenerator();\n       NumberGenerator ng1 = new NumberGenerator();\n       Thread t1 = new Thread(sg1);\n       Thread t2 = new Thread(ng1);\n       \n       t1.start();\n       t2.start();\n       \n       try{\n        t1.wait();\n        code += sg1.section();\n        t2.wait();\n        code += ng1.Number();\n       } catch(InterruptedException e){\n           \n       }\n       System.out.println(code);\n   }    ','Threads',0,0,NULL,5),(636,'','You can call start() on a Thread object only once, otherwise you get an\nIllegalThreadStateException\n\nyou can however create many threads from the same runnable','Threads',0,0,NULL,5),(637,'New State\n\nA thread that is created but not yet started is in the new state and not yet alive','public class Hello implements Runnable {\n\n    public static void main(String[] args) {\n        Thread t = new Thread(new Hello());\n    }\n    \n    public void run() {\n        System.out.println(\"run once\");\n    }\n}\n\n\nwhat state is this thread in ?\n\n','Threads',0,0,NULL,5),(638,' got it ? ','Once a thread is started it goes into the runnable state,\n\nThe schedular can move a thread back and forth between the runnable state and \nthe running state. \n\nA running thread may enter a blocked / waiting state by a wait, sleep, or join \ncall\n\na running thread can enter the blocked/ waiting state because it cant acquire the lock \nfor a synchroized block\n\na dead thread cannot be started again.','Threads',0,0,NULL,5),(639,'','sleeping is used to delay execution for a period of time and .. \n\nno locks are released when a thread goes to sleep','Threads',0,0,NULL,5),(640,'','A sleeping thread is thread is guarenteed to sleep for at least the time specified\nin the argument to sleep() but there is not guarentee is actually return to running\n\nthe sleep mehtod is static so it only affects the currently running thread. ','Threads',0,0,NULL,5),(641,'','unless explicitly set a thread\'s priority will have the same priority as the thread\nthat created it. ','Threads',0,0,NULL,5),(642,'','when one thread call join() on another thread, the currently running thhread\nwill wait until the thread it joins with has completed. Think of join() as saying\n\n\"Hey thread I want to join on to the end of you. let me know when you\'re done, so \nI can enter the runnable state\"','Threads',0,0,NULL,5),(643,'','While only one thread can be accessing synchronized code of a particular\ninstance, multiple threads can still access the same object\'s unsynchronized code.\n\nWhen a thread goes to sleep its locks will be unavailable to other threads.','Threads',0,0,NULL,5),(644,'','Object.wait() = add me to your waiting list.','Threads',0,0,NULL,5),(645,'','notify() is used to send a signal to onne and onnly one of the threads that \nare waiting, it cannot specify which thread will be notified.','Threads',0,0,NULL,5),(646,'','wait() notify() and notifyAll() must called from within a synchronized context\nthe synchronization must be with the object that the thread is calling one of these\nmethhods on !','Threads',0,0,NULL,5),(647,'the third one','Runnable target = new MyRunnable();\nThread myThread = new Thread(target);\n\n\npublic class MyRunnable extends Runnable{public void run(){}}\npublic class MyRunnable implements Runnable{public void start{}}\npublic class MyRunnable implements Runnable{public void run(){}}\n','Threads',0,0,NULL,5),(648,'0..1..2..','public class Hello extends Thread {\n    public static void main(String[] args){\n       Hello h = new Hello();\n       Thread x = new Thread(h);\n       h.start();\n        \n    }\n    \n    public void run() {\n        for(int i=0; i<3; ++i)\n            System.out.print(i+\"...\");\n    }\n}','Threads',0,0,NULL,5),(649,'will not compile .sleep() must be enclosed in a try block to catch its\nInterruptedException','public class Hello {\n    public static void main(String[] args){\n       printAll(args);\n        \n    }\n    \n    public static void printAll(String[] lines){\n        for(int i = 0; i<lines.length; i++){\n            System.out.println(lines[i]);\n            Thread.currentThread().sleep(1000);\n        }\n    }\n}\n\nwhat is the result','Threads',0,0,NULL,5),(650,'public synchronized int read() { return a+b; }\npublic synchronized void set(int a, int b){this.a = a; this.b = b;}\n\npublic int read(){ synchronized(this){ return a+b; } }\npublic void set(int a, int b){synchronized(this){ this.a = a; this.b = b;} }\n\n\n','you have two private variables a and b. prevent concurrent access problems using\ntheir read() and set(int a, int b){} methods.','Threads',0,0,NULL,5),(651,'1 2 \n\nIllegalMonitorStateException is unchecked and thrown by trying to wait\nsomething yyou do not own the lock to!','public class WaitTest {\n	public static void main(String[] args){\n		sout(\"1\");\n		synchronized(args){\n			sout(\"2\");\n			try{\n				args.wait();\n			} catch(InterruptedException e) {\n			}\n		}\n		sout(\"3\");\n	}\n}\n\n1. IllegalMonitorStateException\n2. will not compile\n3. 1 2 3\n4. 1 2\n5. fails to compile because of wait() illegalMonitorstatexception','Threads',0,0,NULL,5),(652,'After object B is notified, or after two seconds. ','the following method is called from thread A on an object B and it is properly synchronized\n\nwait(2000);\n\nafter calling the method when will thread A becoma a canidate to get another \nturn at the CPU ?\n','Threads',0,0,NULL,5),(653,'1 4','which are true ?\n\n1 the notifyAll() must be called from a synchronized context\n2 to call wati() an object must own the lock on the thread\n3 the notify() method is defined in class java.lang.thread\n4 when a thread is waiting as a result of wait() it releases its lock\n5 notify() method causes a thread to imeediately release its lock\n6 the difference between notify() and notifyAll() is that notifyAll() notifies\nall waiting threads regardless of the object theyre waiting on','Threads',0,0,NULL,5),(654,'synchronize both log() and getContents()\n\neven though stringbuffer is synchronized internally, append is called \nmultiple times so anythread could get in there in between calls','public class Logger {\n	private StringBuilder contents = new StringBuilder();\n	public void log(String mess){\n		contents.append(System.currentTimeMillis());\n		contents.append(\": \");\n		contents.append(Thread.currentThread().getName());\n		contents.append(mess);\n	}\n\n	public String getContents() { return contents.toString(); }\n}\n\nhow can you enxure that instances of this class can be safely used by multiple \nthreads ?\n\nreplace StringBuilder with thread-safe StringBuffer ?','Threads',0,0,NULL,5),(655,'IllegalMonitorStateException is thrown because the main thread does not \nhave a lock on t before it decides to wait on it. ','public static synchronized void main(Stirng[] args) throws InterruptedException {\n	Thread t = new Thread();\n	t.start();\n	sout(\"X\");\n	t.wait(10000);\n	sout(\"y\");\n}','Threads',0,0,NULL,5),(656,'MyThread foo','class MyThread extends Thread {\n	MyThread() {\n		sout(\"MyThread\");\n	}\n	public void run(){\n		sout(\"bar\");\n	}\n\n	public void run(String s){\n		sout(\"baz\");\n	}\n}\n\npublic class Test {\n	psvm(sa){\n		Thread t = new MyThread(){\n			public void run(){\n				sout(\"foo\");\n			}\n		};\n		t.start();\n	}\n}\n		','Threads',0,0,NULL,5),(657,'will not compile unreported IOException from newWatchService() and \npath.register()','public class Hello {\n    public static void main(String[] args){\n       WatchService watchService\n          = FileSystems.getDefault().newWatchService();\n \n        Path path = Paths.get(System.getProperty(\"user.home\"));\n \n        path.register(\n          watchService, \n            StandardWatchEventKinds.ENTRY_CREATE, \n              StandardWatchEventKinds.ENTRY_DELETE, \n                StandardWatchEventKinds.ENTRY_MODIFY);\n \n        WatchKey key;\n        while ((key = watchService.take()) != null) {\n            for (WatchEvent<?> event : key.pollEvents()) {\n                System.out.println(\n                  \"Event kind:\" + event.kind() \n                    + \". File affected: \" + event.context() + \".\");\n            }\n            key.reset();\n        }\n        \n    }\n    \n    \n}','IO',0,0,NULL,5),(658,'will not compile take() throws an InterruptedException because \nit will wait if there are no events present','public class Hello {\n    public static void main(String[] args) throws IOException{\n       WatchService watchService\n          = FileSystems.getDefault().newWatchService();\n \n        Path path = Paths.get(System.getProperty(\"user.home\"));\n \n        path.register(\n          watchService, \n            StandardWatchEventKinds.ENTRY_CREATE, \n              StandardWatchEventKinds.ENTRY_DELETE, \n                StandardWatchEventKinds.ENTRY_MODIFY);\n \n        WatchKey key;\n        while ((key = watchService.take()) != null) {\n            for (WatchEvent<?> event : key.pollEvents()) {\n                System.out.println(\n                  \"Event kind:\" + event.kind() \n                    + \". File affected: \" + event.context() + \".\");\n            }\n            key.reset();\n        }\n        \n    }\n    \n    \n}','IO',0,0,NULL,5),(659,'compiles fine if you were to delete a file from home directory \nyou would get a notice like this: \n	\n	Event kind:ENTRY_CREATE. File affected: Untitled Document.\n\n','public class Hello {\n    public static void main(String[] args) throws IOException, InterruptedException {\n       WatchService watchService\n          = FileSystems.getDefault().newWatchService();\n \n        Path path = Paths.get(System.getProperty(\"user.home\"));\n \n        path.register(\n          watchService, \n            StandardWatchEventKinds.ENTRY_CREATE, \n              StandardWatchEventKinds.ENTRY_DELETE, \n                StandardWatchEventKinds.ENTRY_MODIFY);\n \n        WatchKey key;\n        while ((key = watchService.take()) != null) {\n            for (WatchEvent<?> event : key.pollEvents()) {\n                System.out.println(\n                  \"Event kind:\" + event.kind() \n                    + \". File affected: \" + event.context() + \".\");\n            }\n            key.reset();\n        }\n        \n    }\n    \n    \n}','IO',0,0,NULL,5),(660,'this would run one time, if there were no WatchEvents immediately available\nit would end.\nPoll() gets events and does not wait. \n\n','public class Hello {\n    public static void main(String[] args) throws IOException {\n       WatchService watchService\n          = FileSystems.getDefault().newWatchService();\n \n        Path path = Paths.get(System.getProperty(\"user.home\"));\n \n        path.register(\n          watchService, \n            StandardWatchEventKinds.ENTRY_CREATE, \n              StandardWatchEventKinds.ENTRY_DELETE, \n                StandardWatchEventKinds.ENTRY_MODIFY);\n \n        WatchKey key;\n        while ((key = watchService.poll()) != null) {\n            for (WatchEvent<?> event : key.pollEvents()) {\n                System.out.println(\n                  \"Event kind:\" + event.kind() \n                    + \". File affected: \" + event.context() + \".\");\n            }\n            key.reset();\n        }\n        \n    }\n    \n    \n}','IO',0,0,NULL,5),(661,'...just a good example','Path path = Paths.get(\"/home\");\nWatchService watchService = FileSystems.getDefault().newWatchService();\nWatchKey watchKey = path.register(watchService,ENTRY_CREATE,ENTRY_DELETE,ENTRY_MODIFY);\n\nprivate boolean notDone = true;\nwhile(notDone){\n    try{\n         WatchKey watchKey = watchService.poll(60,TimeUnit.SECONDS);\n         List<WatchEvent.Kind<?>> events = watchKey.pollEvents();\n         for(WatchEvent event : events){\n            ...process the events\n         }\n         if(!watchKey.reset()){\n            ...handle situation no longer valid\n         }\n     }catch(InterruptedException e){\n            Thread.currentThread().interrupt();\n     }','IO',0,0,NULL,5),(662,'will not compile, Subleaser does not implemnet runnable!\n\nAlso the two threads synchronize on their very own messageboards so \nthey have no problem getting access to them and printing their messages.\n\nSecondly Nothing is ever printed from the MessageBoard.','public class Hello {\n    public static void main(String[] dicks){\n        Thread t1 = new Thread(new Advertiser());\n        Thread t2 = new Thread(new Subleaser());\n    }\n\n}    \n\nclass MessageBoard {\n    private StringBuilder contents = new StringBuilder();\n    \n    public synchronized void postMessage(String s){\n        contents.append(s + \" \");\n    }\n    \n    public synchronized String readBoard(){\n        return contents.toString();\n    }\n    \n    public StringBuilder takeTurnAtBoard(){\n        return contents;\n    }\n}\n\nclass Advertiser implements Runnable{\n    protected MessageBoard mb = new MessageBoard();\n    public void run(){\n        synchronized(mb){\n            mb.postMessage(\"Attention!\");\n            mb.postMessage(\"Platonics\");\n            mb.postMessage(\"Lost Dog! 1000$ reward\");\n            mb.postMessage(\"Sex Change coupon\");\n            \n            System.out.println(mb.readBoard());\n        } \n    }\n}\n\nclass Subleaser{\n    private MessageBoard mb = new MessageBoard();\n    \n    public void run(){\n        synchronized(mb){\n            mb.postMessage(\"1000 a month!\");\n            mb.postMessage(\"two br\");\n            mb.postMessage(\"no dogs allowed!\");\n        }\n    }\n}','Threads',0,0,NULL,5),(663,'subleaser  1000 a month! two br no dogs allowed! \nadvertiser  Attention! Platonics Lost Dog! 1000$ reward Sex Change coupon \n\nadvertiser  Attention! Platonics Lost Dog! 1000$ reward Sex Change coupon \nsubleaser  1000 a month! two br no dogs allowed!\n\nthese results can be unpredictable, though the methods are synched\nnothing is stopping another thread from coming in between append calls.\n\nto make the ressults truly predictable synchronized the postmessage calls in a block\non mb','public class Hello {\n    public static void main(String[] dicks){\n        Thread t1 = new Thread(new Advertiser(),\"advertiser\");\n        Thread t2 = new Thread(new Subleaser(),\"subleaser\");\n        \n        t1.start();\n        t2.start();\n    }\n\n}    \n\nclass MessageBoard {\n    private StringBuilder contents = new StringBuilder();\n    \n    public synchronized void postMessage(String s){\n        contents.append(s);\n        contents.append(\" \");\n    }\n    \n    public synchronized String readBoard(){\n        return contents.toString();\n    }\n    \n    public StringBuilder takeTurnAtBoard(){\n        return contents;\n    }\n}\n\nclass Advertiser implements Runnable{\n    protected MessageBoard mb = new MessageBoard();\n    public void run(){\n            //Thread.getName() static method cannot be called from non static\n            mb.postMessage(Thread.currentThread().getName()+\" \");\n            mb.postMessage(\"Attention!\");\n            mb.postMessage(\"Platonics\");\n            mb.postMessage(\"Lost Dog! 1000$ reward\");\n            mb.postMessage(\"Sex Change coupon\");\n            \n            System.out.println(mb.readBoard());\n        \n    }\n}\n\nclass Subleaser implements Runnable{\n    private MessageBoard mb = new MessageBoard();\n    \n    public void run(){\n            mb.postMessage(Thread.currentThread().getName()+\" \");\n            mb.postMessage(\"1000 a month!\");\n            mb.postMessage(\"two br\");\n            mb.postMessage(\"no dogs allowed!\");\n            \n            System.out.println(mb.readBoard());\n        }\n}','IO',0,0,NULL,5),(664,'these can be quiet unpredictable:\n\n	subleaser  two br no dogs allowed! 1200$ a month advertiser  Attention! Lost Dog! 1000$ reward Sex Change coupon \nsubleaser  two br no dogs allowed! 1200$ a month advertiser  Attention! Lost Dog! 1000$ reward Sex Change coupon \n\nBoth threads are operating on the same instance, that instances objects\nmethods are synchronized but that doesn\'t stop the other thread from coming\ninbetween calls to postMessage()','public class Hello {\n    public static void main(String[] dicks){\n        MessageBoard mb = new MessageBoard();\n        Thread t1 = new Thread(new Advertiser(mb),\"advertiser\");\n        Thread t2 = new Thread(new Subleaser(mb),\"subleaser\");\n        \n        t1.start();\n        t2.start();\n    }\n\n}    \n\nclass MessageBoard {\n    private StringBuilder contents = new StringBuilder();\n    \n    public synchronized void postMessage(String s){\n        contents.append(s);\n        contents.append(\" \");\n    }\n    \n    public synchronized String readBoard(){\n        return contents.toString();\n    }\n    \n    public StringBuilder takeTurnAtBoard(){\n        return contents;\n    }\n}\n\nclass Advertiser implements Runnable{\n    protected MessageBoard mb;\n    \n    public Advertiser(MessageBoard mb){\n        this.mb = mb;\n    }\n    public void run(){\n            //Thread.getName() static method cannot be called from non static\n            mb.postMessage(Thread.currentThread().getName()+\" \");\n            mb.postMessage(\"Attention!\");\n            mb.postMessage(\"Lost Dog! 1000$ reward\");\n            mb.postMessage(\"Sex Change coupon\");\n            \n            System.out.println(mb.readBoard());\n        \n    }\n}\n\nclass Subleaser implements Runnable{\n    private MessageBoard mb;\n    \n    public Subleaser(MessageBoard mb){\n        this.mb = mb;\n    }\n    \n    public void run(){\n            mb.postMessage(Thread.currentThread().getName()+\" \");\n            mb.postMessage(\"two br\");\n            mb.postMessage(\"no dogs allowed!\");\n            mb.postMessage(\"1200$ a month\");\n            \n            System.out.println(mb.readBoard());\n        }\n}\n','IO',0,0,NULL,5),(665,'You can be assured that these results will be predictable,\n\nThe synchronized blocks get a hold of the lock so it is just a compettion\nof which thread will lock first. ','public class Hello {\n    public static void main(String[] dicks){\n        MessageBoard mb = new MessageBoard();\n        Thread t1 = new Thread(new Advertiser(mb),\"advertiser\");\n        Thread t2 = new Thread(new Subleaser(mb),\"subleaser\");\n        \n        t1.start();\n        t2.start();\n    }\n\n}    \n\nclass MessageBoard {\n    private StringBuilder contents = new StringBuilder();\n    \n    public synchronized void postMessage(String s){\n        contents.append(s);\n        contents.append(\" \");\n    }\n    \n    public synchronized String readBoard(){\n        return contents.toString();\n    }\n    \n    public StringBuilder takeTurnAtBoard(){\n        return contents;\n    }\n}\n\nclass Advertiser implements Runnable{\n    protected MessageBoard mb;\n    \n    public Advertiser(MessageBoard mb){\n        this.mb = mb;\n    }\n    public void run(){\n        synchronized(mb){\n            //Thread.getName() static method cannot be called from non static\n            mb.postMessage(Thread.currentThread().getName()+\" \");\n            mb.postMessage(\"Attention!\");\n            mb.postMessage(\"Lost Dog! 1000$ reward\");\n            mb.postMessage(\"Sex Change coupon\");\n            \n            System.out.println(mb.readBoard());\n        }\n    }\n}\n\nclass Subleaser implements Runnable{\n    private MessageBoard mb;\n    \n    public Subleaser(MessageBoard mb){\n        this.mb = mb;\n    }\n    \n    public void run(){\n        synchronized(mb){\n            mb.postMessage(Thread.currentThread().getName()+\" \");\n            mb.postMessage(\"two br\");\n            mb.postMessage(\"no dogs allowed!\");\n            mb.postMessage(\"1200$ a month\");\n            \n            System.out.println(mb.readBoard());\n        }\n        }\n        \n}\n','IO',0,0,NULL,5),(666,'foo.txt ENTRY_DELETE\n\n... Watcher only watches one directory at a time, not subdirectories','public class Hello {\n    public static void main(String[] dicks) throws InterruptedException {\n        try{\n            WatchService watcher = FileSystems.getDefault().newWatchService();\n            Path home = Paths.get(\"/home/maxbisesi\");\n            home.register(watcher, StandardWatchEventKinds.ENTRY_CREATE,StandardWatchEventKinds.ENTRY_DELETE);\n            \n            WatchKey key;\n            \n            //throws interruptedException \n            while((key = watcher.take()) != null) {\n                for(WatchEvent<?> event : key.pollEvents()){\n                    System.out.println(event.context() + \" \" + event.kind());\n              }\n           }\n        } catch(IOException ei){\n            \n        }    \n    }\n\n}    \n\nI delete foo.txt out of the home directory then go into Documents and delete\nindex.html. What is the result ?','IO',0,0,NULL,5),(667,'1. 4 4 \n2. does not compile\n3. prints nothign , but starts a new thread\n4. creates a new thread and invokes run() directlyy\n5. creates and starts a new thread. ','public class Starter implements Runnable {\n	void go(long id) {\n		sout(id);\n	}\n\n	public static void main(String[] args){\n		sout(Thread.currentThread().getId() + \" \");\n		//insert code\n	}\n	public void run() { go(Thread.currentThread().getId()); }\n}\n\n1. new Starter().run();\n2. new Starter().start();\n3. new Thread(new Starter());\n4. new Thread(new Starter()).run();\n5. new Thread(new Starter()).start();','IO',0,0,NULL,5),(668,'will not commpile, join throws interruptedexception ','public class Hello implements Runnable {\n    public void run(){\n        System.out.println(\"r1 \");\n        System.out.println(\"r2 \");\n    }\n    public static void main(String[] args){\n        Thread t = new Thread(new Hello());\n        t.start();\n        System.out.println(\"m1 \");\n        t.join();\n        System.out.println(\"m2 \");\n    }\n}','IO',0,0,NULL,5),(669,'could be:\n\nm1 r1 r2 m2\nr1 m1 r2 m2\nr1 r2 m1 m2\n\njoin throws interruptedexception, it causes main to join onto the end\nof the thread t and wait till its done to continue. ','public class Hello implements Runnable {\n    public void run(){\n        System.out.println(\"r1 \");\n        System.out.println(\"r2 \");\n    }\n    public static void main(String[] args){\n        Thread t = new Thread(new Hello());\n        t.start();\n        System.out.println(\"m1 \");\n        try{\n            t.join();\n        } catch(InterruptedException e){\n            \n        }\n        System.out.println(\"m2 \");\n    }\n}','IO',0,0,NULL,5),(670,'NullpointerException,\n\nthis one is hard to spot but c is initialized in the go method, an \ninstance method. The two threads start their own new instance and go\ndirectly to the run() method, without go() c never gets initialized. \n\nfor this to work c would have to be static. \n','public class Hello implements Runnable {\n    Chicks c;\n    public void run(){\n       c.yack(Thread.currentThread().getId());\n    }\n    public static void main(String[] args){\n        new Hello().go();\n       \n    }\n    \n    void go(){\n        c = new Chicks();\n        new Thread(new Hello()).start();\n        new Thread(new Hello()).start();\n    }\n}\n\nclass Chicks {\n    synchronized void yack(long id){\n        for(int x = 1; x <3; x++){\n            System.out.println(id + \" \");\n            Thread.yield();\n        }\n    }\n}','IO',0,0,NULL,5),(671,'8\n8\n9\n9','public class Hello implements Runnable {\n    static Chicks c;\n    public void run(){\n       c.yack(Thread.currentThread().getId());\n    }\n    public static void main(String[] args){\n        new Hello().go();\n       \n    }\n    \n    void go(){\n        c = new Chicks();\n        new Thread(new Hello()).start();\n        new Thread(new Hello()).start();\n    }\n}\n\nclass Chicks {\n    synchronized void yack(long id){\n        for(int x = 1; x <3; x++){\n            System.out.println(id + \" \");\n            Thread.yield();\n        }\n    }\n}','IO',0,0,NULL,5),(672,'','public class Hello implements Runnable {\n    static Chicks c;\n    public void run(){\n       c.yack(Thread.currentThread().getId());\n    }\n    public static void main(String[] args){\n        new Hello().go();\n       \n    }\n    \n    void go(){\n        c = new Chicks();\n        new Thread(new Hello()).start();\n        new Thread(new Hello()).start();\n    }\n}\n\nclass Chicks {\n    static long flag = 0;\n    synchronized void yack(long id){\n        if(flag == 0) flag = id;\n        for(int x = 1; x <3; x++){\n            if(flag == id) System.out.println(\"yada yada \");\n            else System.out.println(\"ehh \");\n        }\n    }\n}','IO',0,0,NULL,5),(673,'the output could be 8 9 8 9\n\n..it could be anything really','public class Hello implements Runnable {\n    public void run(){\n       move(Thread.currentThread().getId());\n    }\n    \n    void move(long id){\n        System.out.println(id + \" \");\n        System.out.println(id + \" \");\n    }\n    public static void main(String[] args){\n        Hello h = new Hello();\n        new Thread(h).start();\n        new Thread(new Hello()).start();\n    }\n}','IO',0,0,NULL,5),(674,'the output could be 4 2 4 2\n\nWhile the method is synhcronized it is being invoked by two different\nobjects so they could print in any order still \n\n','public class Hello implements Runnable {\n    public void run(){\n       move(Thread.currentThread().getId());\n    }\n    \n    synchronized void move(long id){\n        System.out.println(id + \" \");\n        System.out.println(id + \" \");\n    }\n    public static void main(String[] args){\n        Hello h = new Hello();\n        new Thread(h).start();\n        new Thread(new Hello()).start();\n    }\n}','IO',0,0,NULL,5),(675,'test','test	','IO',0,0,NULL,5),(676,'add  and  remove','Which method from a CopyOnWriteArrayList will caue a new copy of the internal\narray to be created ?','IO',0,0,NULL,5),(677,'2018699554\n1311053135\nlocked thread Thread1\nunable to lock thread Thread2 will re try again\nunlocked locked thread Thread1\nlocked thread Thread2\nunlocked locked thread Thread2\n\nThe two threads use two different Runnables, but they are both vying for the same\nlock. ','public class Hello {\n    public static void main(String[] args){\n        new ReentrantLockingDemo().go();\n    }\n}\n\nclass ReentrantLockingDemo {\n\n    final Lock lock = new ReentrantLock();\n\n    public void go() {\n\n        Runnable run1 = newRunable();\n        Thread t1 = new Thread(run1, \"Thread1\");\n        System.out.println(run1.hashCode());\n        t1.start();\n\n        Runnable run2 = newRunable();\n        Thread t2 = new Thread(run2, \"Thread2\");\n        System.out.println(run2.hashCode());\n        t2.start();\n\n    }\n\n    private Runnable newRunable() {\n        return new Runnable() {\n            public int hashCode() {\n                return super.hashCode();\n            }\n            public void run() {\n                do {\n                    try {\n                        if (lock.tryLock(500, TimeUnit.MILLISECONDS)) {\n                            try {\n                                System.out.println(\"locked thread \"\n                                        + Thread.currentThread().getName());\n                                Thread.sleep(1000);\n                            } finally {\n                                lock.unlock();\n                                System.out.println(\"unlocked locked thread \"\n                                        + Thread.currentThread().getName());\n                            }\n                            break;\n                        } else {\n                            System.out.println(\"unable to lock thread \"\n                                    + Thread.currentThread().getName()\n                                    + \" will re try again\");\n                        }\n                    } catch (InterruptedException e) {\n                        e.printStackTrace();\n                    }\n                } while (true);\n            }     \n        };\n    }\n\n}','IO',0,0,NULL,5),(678,'How a join should be used and implemented. \n\n100 Rens followed by 100 stimpys','public class ThreadTest {\n	class InnerRun implements Runnable {\n		public void run() {\n			for(int x = 0; x < 100; x++){\n				try{\n					Thread.sleep(5);\n				} catch(Exception e) {}\n				sout( \"Ren\" );\n			}\n		}\n	}\n\n	class InnerRunTwo implements Runnable {\n		Thread other;\n		public InnerRunTwo(Thread x){ other = x; }\n		public void run() {\n			try{\n				other.join();\n			} catch(Exception e) { }\n			for(int x = 0; x < 100; x++){\n			   try{\n				Thread.sleep(5);\n			   } catch( Exception e) { }\n			   sout( \"stimpy\" );\n			}\n		}	\n	}\nvoid start(){\n	InnerRun ir = new InnerRun();\n	Thread t = new Thread(ir);\n	InnerRunTwo irr = new InnerRunTwo(t);\n	Thread u = new Thread(irr);\n		t.start();	\n		u.start();\n}\npsvm(SA){ ThreadTest tt = new ThreadTest(); tt.start(); }\n}','IO',0,0,NULL,5),(679,'run:\nInstance locked by: Thread-0\n0\nInstance locked by: Thread-0\n1\nInstance locked by: Thread-0\n2\nInstance locked by: Thread-0\n3\nInstance locked by: Thread-0\n4\nInstance locked by: Thread-0\n5\nInstance locked by: Thread-0\n6\nInstance locked by: Thread-0\n7\nInstance locked by: Thread-0\n8\nInstance locked by: Thread-0\n9\nInstance locked by: Thread-0\n10\nBUILD STOPPED (total time: 10 seconds)\n','public class Hello {\n    public static void main(String[] args){\n        Data data = new Data();\n        DataThread dt = new DataThread(data);\n        Thread t1 = new Thread(dt);\n        Thread t2 = new Thread(dt);\n        Thread t3 = new Thread(dt);\n        Thread t4 = new Thread(dt);\n        Thread t5 = new Thread(dt);\n        \n        t1.start();\n        t2.start();\n        t3.start();\n        t4.start();\n        t5.start();\n        \n    }\n}\n\nclass Data {\n    public Object lock = new Object();\n    public static Object staticLock = new Object();\n    \n    public synchronized void instanceLocked(){\n        System.out.println(\"Instance locked by: \"+Thread.currentThread().getName());\n    }\n    \n    public static synchronized void classLocked(){\n        System.out.println(\"class locked by: \"+Thread.currentThread().getName());\n        while(true){\n            \n        }\n    }\n}\n\nclass DataThread implements Runnable {\n    private Data data;\n    \n    public DataThread(Data data){\n        this.data = data;\n    }\n    public void run(){\n        synchronized(data.lock){\n            \n            for(int i = 0; i<100; i++){\n                data.instanceLocked();\n                System.out.println(i);\n                \n                try{\n                    Thread.sleep(1000);\n                } catch(InterruptedException e){\n                    \n                }\n            }\n            \n        }\n    }\n    \n}','IO',0,0,NULL,5),(680,'Gaston: Alphonse has bowed to me!\nAlphonse: Gaston started to bow to me, but saw that I was already bowing to him.\nAlphonse: Gaston has bowed back to me!\nAlphonse: Gaston has bowed to me!\nGaston: Alphonse has bowed back to me!\nAlphonse: Gaston has bowed to me!\nGaston: Alphonse has bowed back to me!\nGaston: Alphonse has bowed to me!\nAlphonse: Gaston has bowed back to me!\nAlphonse: Gaston has bowed to me!\nGaston: Alphonse has bowed back to me!\nGaston: Alphonse has bowed to me!\nAlphonse: Gaston has bowed back to me!\nAlphonse: Gaston has bowed to me!\nGaston: Alphonse has bowed back to me!\nGaston: Alphonse has bowed to me!\nAlphonse: Gaston has bowed back to me!\nAlphonse: Gaston has bowed to me!\nGaston: Alphonse has bowed back to me!\nGaston: Alphonse has bowed to me!\nAlphonse: Gaston has bowed back to me!\nGaston: Alphonse has bowed to me!\nAlphonse: Gaston has bowed back to me!\nAlphonse: Gaston has bowed to me!\nGaston: Alphonse has bowed back to me!\nAlphonse: Gaston has bowed to me!\nGaston: Alphonse has bowed back to me!\nGaston: Alphonse has bowed to me!\nAlphonse: Gaston has bowed back to me!\nAlphonse: Gaston has bowed to me!\nGaston: Alphonse has bowed back to me!\nGaston: Alphonse started to bow to me, but saw that I was already bowing to him.\nAlphonse: Gaston has bowed to me!\nGaston: Alphonse has bowed back to me!\nAlphonse: Gaston has bowed to me!\nGaston: Alphonse has bowed back to me!','public class Hello {\n    public static void main(String[] args){\n         final Safelock.Friend alphonse =\n            new Safelock.Friend(\"Alphonse\");\n        final Safelock.Friend gaston =\n            new Safelock.Friend(\"Gaston\");\n        new Thread(new Safelock.BowLoop(alphonse, gaston)).start();\n        new Thread(new Safelock.BowLoop(gaston, alphonse)).start();\n    }\n}\n\nclass Safelock {\n    static class Friend {\n        private final String name;\n        private final Lock lock = new ReentrantLock();\n\n        public Friend(String name) {\n            this.name = name;\n        }\n\n        public String getName() {\n            return this.name;\n        }\n\n        public boolean impendingBow(Friend bower) {\n            Boolean myLock = false;\n            Boolean yourLock = false;\n            try {\n                myLock = lock.tryLock();\n                yourLock = bower.lock.tryLock();\n            } finally {\n                if (! (myLock && yourLock)) {\n                    if (myLock) {\n                        lock.unlock();\n                    }\n                    if (yourLock) {\n                        bower.lock.unlock();\n                    }\n                }\n            }\n            return myLock && yourLock;\n        }\n            \n        public void bow(Friend bower) {\n            if (impendingBow(bower)) {\n                try {\n                    System.out.format(\"%s: %s has\"\n                        + \" bowed to me!%n\", \n                        this.name, bower.getName());\n                    bower.bowBack(this);\n                } finally {\n                    lock.unlock();\n                    bower.lock.unlock();\n                }\n            } else {\n                System.out.format(\"%s: %s started\"\n                    + \" to bow to me, but saw that\"\n                    + \" I was already bowing to\"\n                    + \" him.%n\",\n                    this.name, bower.getName());\n            }\n        }\n\n        public void bowBack(Friend bower) {\n            System.out.format(\"%s: %s has\" +\n                \" bowed back to me!%n\",\n                this.name, bower.getName());\n        }\n    }\n\n    static class BowLoop implements Runnable {\n        private Friend bower;\n        private Friend bowee;\n\n        public BowLoop(Friend bower, Friend bowee) {\n            this.bower = bower;\n            this.bowee = bowee;\n        }\n    \n        public void run() {\n            Random random = new Random();\n            for (;;) {\n                try {\n                    Thread.sleep(random.nextInt(10));\n                } catch (InterruptedException e) {}\n                bowee.bow(bower);\n            }\n        }\n    }\n}','IO',0,0,NULL,5),(681,'good example of Conditions','class BoundedBuffer {\n   final Lock lock = new ReentrantLock();\n   final Condition notFull  = lock.newCondition(); \n   final Condition notEmpty = lock.newCondition(); \n\n   final Object[] items = new Object[100];\n   int putptr, takeptr, count;\n\n   public void put(Object x) throws InterruptedException {\n     lock.lock();\n     try {\n       while (count == items.length)\n         notFull.await();\n       items[putptr] = x;\n       if (++putptr == items.length) putptr = 0;\n       ++count;\n       notEmpty.signal();\n     } finally {\n       lock.unlock();\n     }\n   }\n\n   public Object take() throws InterruptedException {\n     lock.lock();\n     try {\n       while (count == 0)\n         notEmpty.await();\n       Object x = items[takeptr];\n       if (++takeptr == items.length) takeptr = 0;\n       --count;\n       notFull.signal();\n       return x;\n     } finally {\n       lock.unlock();\n     }\n   }\n }','IO',0,0,NULL,5),(682,'Will not compile, ArrayList listData is a raw type so in the foreach loop\nyou assign them to an Integer, you would have had to cast','class DataThread implements Runnable {\n    private Data data;\n    private ArrayList listData;\n    \n    public DataThread(Data data){\n        this.data = data;\n    }\n    public void run(){\n            data.lock.lock();\n            try{\n                listData = data.produceData();\n            try{\n               data.done.await();\n            } catch(InterruptedException e){\n                \n            }\n            \n            for(Integer i : listData){\n                System.out.println(i);\n            }\n            } finally {\n                data.lock.unlock();\n            }\n    }\n    \n}','IO',0,0,NULL,5),(683,'With ReentrantReadWriteLock you can grant write access to only one thread, but\nit is possible to allow many threads to be reading at the same time. ','public class Hello {\n    private List<Integer> integers = new ArrayList<>();\n    private ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();\n    \n    public void add(Integer i){\n        rwl.writeLock().lock();\n        try {\n            integers.add(i);\n        } finally {\n            rwl.writeLock().unlock();\n        }\n    }\n    \n    public int findMax() {\n        rwl.readLock().lock();\n        try {\n            return Collections.max(integers);\n        } finally {\n            rwl.readLock().unlock();\n        }\n    }\n    public static void main(String[] args){\n      \n    }\n\n}','IO',0,0,NULL,5),(684,'','read-only(immutabel) objects are always thread safe. ','IO',0,0,NULL,5),(685,'your data sets remain small and the number of read operations and traversals greatly outnumber\nmodifications to the collection. \n\nCopy on write collections work by copying their internal array of data with\nany mutating operation. This copied array will replace the original read only\narrray. \n\nThis allows it to be safely shared between multiple threads. ','Use copy on write collections when...','IO',0,0,NULL,5),(686,'','Just because a collection is thread safe does not make the elements stored within\nthread safe','IO',0,0,NULL,5),(687,'','The Iterator for a concurrent collection is weakly consistent; it can return elements \nfrom the point in time the Iterator was created or LATER. This means that \nwhile looping through a concurrent collection, you might observel elements that\nare being inserted by other threads. also you might see only some of the elements\nthat another thread is inserting. ','IO',0,0,NULL,5),(688,'ConcurrentSkipListMap and ConcurrentSkipListSet \n\n-They require the use of comparable and comparotr to enable ordering. ','Which concurrent Collections are sorted ?','IO',0,0,NULL,5),(689,'','copy on write and concurrent collections are centered on the idea of multiple\nthreads sharing data. \n\nA BlockingQueue is used to exchnage data between two or more threads while causing\nsome of the threads to wait until the point in time when the data can be \ntransfered. ','IO',0,0,NULL,5),(690,'4\n4\n3\n6\n8\n\nto indicate that you want a pattern to be surrounded by other similar characteres\nsurround it with non word boundaries. If you did want the character to \nbee alone surround it with word boudaries.','class Hello {\n    public static void main(String[] args) {     \n        Pattern p = Pattern.compile(\"\\\\B\\\\d\\\\B\");\n        Matcher m = p.matcher(\"Th4t\'ll b3 the d4y, on th3 v3ry l6ast d8y\");\n        \n        while(m.find()){\n            System.out.println(m.group());\n        }\n        \n    }\n\n}','Strings',0,0,NULL,5),(691,'ArrayBlockingQueue\nLinkedBlockingQueue\nLinkedBlockingQueue\nPriorityBlockingQueue\nDelayQueue\nLinkedTransferQueue\nSynchronousQueue\n','BlockingQueue implementations','Concurrency',1,0,NULL,5),(692,'','A blocking collection, depending on the method being called, may cause a thread to block\nuntil another threads calls a corresponding method on the collection. \n\nif you attempt to reemove an element() by calling take() on any BlockingQueue\nthat is empty, the operation will block until another thread inserts an element.\n','Concurrency',0,0,NULL,5),(693,'Returns true if object added,\n\nfalse if duplicate objects are not allowed.\n\nThrows IllegalStateException if the queue is bounded and full','BlockingQueue method:\n\nadd(E e)','Concurrency',0,0,NULL,5),(694,'returns true if object added, false if the queue is bounded and full','BlockingQueue method:\n\noffer(E e)','Concurrency',0,0,NULL,5),(695,'returns void.\n\nwill block until space in the queue becomes available if needed ','BlockingQueue method:\n\nput(E e)','Concurrency',0,0,NULL,5),(696,'returns false if the object was not able to be inserted before the time idicated,\n','offer(E e, long timeout, TimeUnit unit)','Concurrency',0,0,NULL,5),(697,'returns true if an equal object was found in the queue and removed; \notherwise returns false.','BlockingQueue method:\n\nremove(Object o)','Concurrency',0,0,NULL,5),(698,'removes the first object in the queue and returns it. \n\nif the timeout expires before an object can be removed becaue the queue is empty\nthen a null will be returned. ','BlockingQueue method:\n\npoll(long timeout, TimeUnit unit)','Concurrency',0,0,NULL,5),(699,'Removes and returns the first object in the queue, blocking if needed until the \nobject becomes available. \n\nonly throws InterruptedException','BlockingQueue method:\n\ntake()','Concurrency',0,0,NULL,5),(700,'removes and returns the first object in the queue and returns null if the queue is empty\n','BlockingQueue method:\n\npoll()','Concurrency',0,0,NULL,5),(701,'Gets the head of the queue without removing it, Throws a NoSuchElementException\nif the queue is empty. ','BlockingQueue method:\n\nelement()','Concurrency',0,0,NULL,5),(702,'gets the head of the queue without removing it, Returns a null if the queue is \nempty. ','BlockingQueue method:\n\npeek()','Concurrency',0,0,NULL,5),(703,'The second put(35) will block until previous values is removed by another thread.','BlockingQueue<Integer> bq = new ArrayBlockingQueue<>(1);\n\ntry{\n	bq.put(34);\n	bq.put(35);\n} catch(InterruptedException e) {}','Concurrency',0,0,NULL,5),(704,'...is a speciel type of bounded blocking queue; it has a capacity of \nzero. The first thread to attempt either an insert or remvoe operaion\non a synchronousQueue will block until another thread performs the opposite \noperation. USe this when you need threads to meet up and exchange an object.','SynchronousQueue','Concurrency',0,0,NULL,5),(705,'5\n9\n\nThe iterator was obtained before the 3 was added. As long as the reference to \nthe iterator is maintained it will only provide access to 5 9.\n\nIt is ConcurrentCollections that will remain weakly consistant with the changes\nmade by other threads, This is a copyonwrite array list which is thread safe but\nnot concurrent.','public class Hello {\n    public static void main(String[] args){\n       CopyOnWriteArrayList<Integer> list = new CopyOnWriteArrayList<>();\n       \n       list.add(5);\n       list.add(9);\n       Iterator<Integer> it = list.iterator();\n       \n       list.add(3);\n       \n       while(it.hasNext()){\n           System.out.println(it.next());\n       }\n    }\n}','Concurrency',0,0,NULL,5),(706,'5\n9\n4\n\nThe iterator is obtained before the element at index 2 is removed.','public class Hello {\n    public static void main(String[] args){\n       CopyOnWriteArrayList<Integer> cowlist = new CopyOnWriteArrayList<>();\n       \n       cowlist.add(5);\n       cowlist.add(9);\n       cowlist.add(4);\n       \n       Iterator<Integer> it = cowlist.iterator();\n       \n       cowlist.remove(2);\n       \n       while(it.hasNext()){\n           System.out.println(it.next());\n       }\n       \n    }\n}','Concurrency',0,0,NULL,5),(707,'IndexOutofBoundsException \n\nthis can be confusing here the remove(int index) is being used. \n\nto fix do this\n\ncowlist.remove(new Integer(5));','public class Hello {\n    public static void main(String[] args){\n       CopyOnWriteArrayList<Integer> cowlist = new CopyOnWriteArrayList<>();\n       \n       cowlist.add(5);\n       cowlist.add(9);\n       cowlist.add(4);\n       \n       Iterator<Integer> it = cowlist.iterator();\n       \n       cowlist.remove(5);\n       \n       while(it.hasNext()){\n           System.out.println(it.next());\n       }\n       \n    }\n}','Concurrency',0,0,NULL,5),(708,'add and remove. These are the only methods shown that modify the list','Which methods from copyonwritearraylist will cause a new copy of the internal\narray to be created\n\nadd\nget\niterator\nremove','Concurrency',0,0,NULL,5),(709,'only put()','ArrayBlockingQueue<Integer> abq = new ArrayBlockingQueue<>(10);\n\nwhich operation can block indefinitely\n\nabq.add(1);\nabq.offer(1);\nabq.put(1);\nabq.offer(1,5,TimeUnit.SECONDS);','Concurrency',0,0,NULL,5),(710,'IllegalStateEXception queue is full','public class Hello implements Runnable {\n    private static ArrayBlockingQueue<Integer> abq = new ArrayBlockingQueue<>(10);\n    public static void main(String[] args){\n       Hello h = new Hello();\n       Thread t1 = new Thread(h);\n       Thread t2 = new Thread(h);\n       Thread t3 = new Thread(h);\n       Thread t4 = new Thread(h);\n       \n       t1.start();\n       t2.start();\n       t3.start();\n       t4.start();\n       \n    }\n    public void run(){\n        for(int i = 0; i<5; i++){\n            abq.add(i);\n        }\n    }\n}','Concurrency',0,0,NULL,5),(711,'true\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\nException in thread \"Thread-2\" java.lang.IllegalStateException: Queue full\n	at java.util.AbstractQueue.add(AbstractQueue.java:98)\n	at java.util.concurrent.ArrayBlockingQueue.add(ArrayBlockingQueue.java:312)\n	at hello.Hello.run(Hello.java:27)\n	at java.lang.Thread.run(Thread.java:745)\nException in thread \"Thread-3\" java.lang.IllegalStateException: Queue full\n	at java.util.AbstractQueue.add(AbstractQueue.java:98)\n	at java.util.concurrent.ArrayBlockingQueue.add(ArrayBlockingQueue.java:312)\n	at hello.Hello.run(Hello.java:27)\n	at java.lang.Thread.run(Thread.java:745)','public class Hello implements Runnable {\n    private static ArrayBlockingQueue<Integer> abq = new ArrayBlockingQueue<>(10);\n    public static void main(String[] args){\n       Hello h = new Hello();\n       Thread t1 = new Thread(h);\n       Thread t2 = new Thread(h);\n       Thread t3 = new Thread(h);\n       Thread t4 = new Thread(h);\n       \n       t1.start();\n       t2.start();\n       t3.start();\n       t4.start();\n       \n    }\n    public void run(){\n        for(int i = 0; i<5; i++){\n            System.out.println(abq.add(i));\n        }\n    }\n}','Concurrency',0,0,NULL,5),(712,'offer() Inserts the specified element at the tail of this queue if \nit is possible to do so immediately \nwithout exceeding the queue\'s capacity, \nreturning true upon success and false if this queue is full. \nThis method is generally preferable to method add(E), which can fail to insert an element \nonly by throwing an exception.\n\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\nfalse\nfalse\nfalse\nfalse\nfalse\nfalse\nfalse\nfalse\nfalse\nfalse','public class Hello implements Runnable {\n    private static ArrayBlockingQueue<Integer> abq = new ArrayBlockingQueue<>(10);\n    public static void main(String[] args){\n       Hello h = new Hello();\n       Thread t1 = new Thread(h);\n       Thread t2 = new Thread(h);\n       Thread t3 = new Thread(h);\n       Thread t4 = new Thread(h);\n       \n       t1.start();\n       t2.start();\n       t3.start();\n       t4.start();\n       \n    }\n    public void run(){\n        for(int i = 0; i<5; i++){\n            System.out.println(abq.offer(i));\n        }\n    }\n}','Concurrency',0,0,NULL,5),(713,'will not compile, .put() return void and blocks until space becomes available\n\n\'void\' is not allowed is sout();','public class Hello implements Runnable {\n    private static ArrayBlockingQueue<Integer> abq = new ArrayBlockingQueue<>(10);\n    public static void main(String[] args){\n       Hello h = new Hello();\n       Thread t1 = new Thread(h);\n       Thread t2 = new Thread(h);\n       Thread t3 = new Thread(h);\n       Thread t4 = new Thread(h);\n       \n       t1.start();\n       t2.start();\n       t3.start();\n       t4.start();\n       \n    }\n    public void run(){\n        for(int i = 0; i<5; i++){\n            System.out.println(abq.put(i));\n        }\n    }\n}','Concurrency',0,0,NULL,5),(714,'Will not compile,\n\nput will block, therefore it may throw an interruptedException\n\nsurround with try catch','public class Hello implements Runnable {\n    private static ArrayBlockingQueue<Integer> abq = new ArrayBlockingQueue<>(10);\n    public static void main(String[] args){\n       Hello h = new Hello();\n       Thread t1 = new Thread(h);\n       Thread t2 = new Thread(h);\n       Thread t3 = new Thread(h);\n       Thread t4 = new Thread(h);\n       \n       t1.start();\n       t2.start();\n       t3.start();\n       t4.start();\n       \n    }\n    public void run(){\n        for(int i = 0; i<5; i++){\n            abq.put(i);\n        }\n    }\n}','Concurrency',0,0,NULL,5),(715,'will run indefinitely, put will block until space becomes available, here \nit will never become available because there is no code removing objects','public class Hello implements Runnable {\n    private static ArrayBlockingQueue<Integer> abq = new ArrayBlockingQueue<>(10);\n    public static void main(String[] args){\n       Hello h = new Hello();\n       Thread t1 = new Thread(h);\n       Thread t2 = new Thread(h);\n       Thread t3 = new Thread(h);\n       Thread t4 = new Thread(h);\n       \n       t1.start();\n       t2.start();\n       t3.start();\n       t4.start();\n       \n    }\n    public void run(){\n        for(int i = 0; i<5; i++){\n            try{\n                abq.put(i);\n            } catch(InterruptedException e){}\n        }\n    }\n}','Concurrency',0,0,NULL,5),(716,'peek() returns the head without removing it. returns null if empty\nThread-0removed element: 0\nThread-0removed element: 0\nThread-0removed element: 0\nThread-0removed element: 0\nThread-0removed element: 0\nThread-2removed element: 0\nThread-2removed element: 0\nThread-2removed element: 0\nThread-2removed element: 0\nThread-2removed element: 0\nThread-3removed element: 0\nThread-3removed element: 0\nThread-3removed element: 0\nThread-3removed element: 0\nThread-3removed element: 0\nThread-1removed element: 0\nThread-1removed element: 0\nThread-1removed element: 0\nThread-1removed element: 0\nThread-1removed element: 0\n','public class Hello implements Runnable {\n    private static ArrayBlockingQueue<Integer> abq = new ArrayBlockingQueue<>(10);\n    public static void main(String[] args){\n        for(int i = 0; i<10; i++)\n                abq.add(i);\n  \n       Hello h = new Hello();\n       Thread t1 = new Thread(h);\n       Thread t2 = new Thread(h);\n       Thread t3 = new Thread(h);\n       Thread t4 = new Thread(h);\n       \n       t1.start();\n       t2.start();\n       t3.start();\n       t4.start();\n       \n    }\n    public void run(){\n        for(int i = 0; i<5; i++){\n            System.out.println(Thread.currentThread().getName()+\"removed element: \"+abq.peek());\n        }\n        \n    }\n}','Concurrency',0,0,NULL,5),(717,'','ArrayBlockingQueue<E>\n\nA bounded blocking queue backed by an array. \nThis queue orders elements FIFO (first-in-first-out). \nThe head of the queue is that element that has been on the queue the longest time. \nThe tail of the queue is that element that has been on the queue the shortest time. \nNew elements are inserted at the tail of the queue, and the queue retrieval operations obtain elements at the head of the queue.\n\nThis is a classic \"bounded buffer\", in which a fixed-sized array holds elements inserted by producers and extracted by consumers. \nOnce created, the capacity cannot be changed. Attempts to put an element into a full queue will result in the operation blocking; \nattempts to take an element from an empty queue will similarly block. ','Concurrency',0,0,NULL,5),(718,'PutThread:Put One\nTakerThread:Retrieve using take\nTakerThread:take() returned One\nPutThread:Returned from put\n\nSyncQueue is used to make two threads meet up and hand off an object. \n\nBoth insertion and removal operations will block until the other thread\ndoes the inverse thus making the threads meet and exchange. ','public class Hello {\n    public static void main(String[] args){\n        SynchronousQueue<String> sq = new SynchronousQueue<String>();\n        Thread putThread = new Thread(new PutRunnable<String>(sq, \"One\"), \"PutThread\");\n        putThread.start();\n        Thread takerThread = new Thread(new TakerRunnable<String>(sq), \"TakerThread\");\n        takerThread.start();\n\n    }\n}\n\n class PutRunnable<T> implements Runnable {\n    private T value;\n    private SynchronousQueue<T> syncQ;\n    PutRunnable(SynchronousQueue<T> syncQ, T value) {\n        this.syncQ = syncQ;\n        this.value = value;\n    }\n    public void run() {\n        try {\n            PrintUtils.print(\"Put \" + value);\n            syncQ.put(value);\n            PrintUtils.print(\"Returned from put\");\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n \n}\nclass TakerRunnable<T> implements Runnable {\n    private T value;\n    private SynchronousQueue<T> syncQ;\n    TakerRunnable(SynchronousQueue<T> syncQ) {\n        this.syncQ = syncQ;\n    }\n    public void run() {\n        try {\n            PrintUtils.print(\"Retrieve using take\");\n            value = syncQ.take();\n            PrintUtils.print(\"take() returned \" + value);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n    public T getValue() {\n        return value;\n    }\n}\n\nclass PrintUtils {\n    public static void print(String s) {\n        System.out.println(Thread.currentThread().getName() + \":\" + s);\n    }\n}','Concurrency',0,0,NULL,5),(719,'LinkedTranserQueue implements the BlockingQueue, TransferQueue, and Queue interfaces\n\nit is used here to demonstrate all the inserting and removing methods.','public class Hello {\n    \n    private static TransferQueue<Integer> tq = new LinkedTransferQueue<>();\n\n    public static void main(String[] args){\n        boolean b1 = tq.add(1); // true if added, IllegalStateException if full\n        \n        try{\n            //both of these throw interruptedExceptions because they block and wait\n            \n            tq.put(2);  //blocks if bounded or full\n        \n            tq.transfer(88); //blocks until element is consumed\n            \n        } catch(InterruptedException e){ }\n        \n        tq.tryTransfer(7); // returns true if consumed by the awaiting thread, or false without adding if there was no awaiting consumer.\n            // does not block therefore does not throw interruptedException\n        \n        try {\n            \n            //will wait the given time, blocking, then will return if not consumed\n            boolean b7 = tq.tryTransfer(99,10,TimeUnit.SECONDS);\n            \n        } catch(InterruptedException e){ }\n\n    }\n    \n    public static void methodsToRetrieve(){\n        Integer i1 = tq.element(); // gets without removing, throws NoSuchElementException if empty\n        \n        Integer i2 = tq.peek(); // gets without removing, null if empty\n        \n        Integer i3 = tq.poll(); //returns and removes the head, null if empty\n        \n        try{\n            Integer i4 = tq.poll(10,TimeUnit.MILLISECONDS); // removes the head, waits the specified time beffore returning null if empty\n        } catch(InterruptedException e) { }\n        \n        Integer i5 = tq.remove(); // removes the head of the queue throws NoSuchElementException if empty\n                \n        try{\n            Integer i6 = tq.take(); //removes the head blocks until an element is ready,\n        } catch(InterruptedException e) { }\n                \n    }','Concurrency',0,0,NULL,5),(720,'will not compile, LinkedTransferQueue is not bounded and cannot be supplied with\na size argument','public class Hello {\n    \n    private static TransferQueue<Integer> tq = new LinkedTransferQueue<>(45);\n\n    public static void main(String[] args){\n        boolean b1 = tq.add(1); // true if added, IllegalStateException if full\n        \n        try{\n            //both of these throw interruptedExceptions because they block and wait\n            \n            tq.put(2);  //blocks if bounded or full\n        \n            tq.transfer(88); //blocks until element is consumed\n            \n        } catch(InterruptedException e){ }\n        \n        tq.tryTransfer(7); // returns true if consumed by the awaiting thread, or false without adding if there was no awaiting consumer.\n            // does not block therefore does not throw interruptedException\n        \n        try {\n            \n            //will wait the given time, blocking, then will return if not consumed\n            boolean b7 = tq.tryTransfer(99,10,TimeUnit.SECONDS);\n            \n        } catch(InterruptedException e){ }\n\n    }\n    \n    public static void methodsToRetrieve(){\n        Integer i1 = tq.element(); // gets without removing, throws NoSuchElementException if empty\n        \n        Integer i2 = tq.peek(); // gets without removing, null if empty\n        \n        Integer i3 = tq.poll(); //returns and removes the head, null if empty\n        \n        try{\n            Integer i4 = tq.poll(10,TimeUnit.MILLISECONDS); // removes the head, waits the specified time beffore returning null if empty\n        } catch(InterruptedException e) { }\n        \n        Integer i5 = tq.remove(); // removes the head of the queue throws NoSuchElementException if empty\n                \n        try{\n            Integer i6 = tq.take(); //removes the head blocks until an element is ready,\n        } catch(InterruptedException e) { }\n                \n    }','Concurrency',0,0,NULL,5),(721,'will not compile, put and transfer block and wait, therefore they throw \nInterruptedExceptions','public class Hello {\n    \n    private static TransferQueue<Integer> tq = new LinkedTransferQueue<>();\n\n    public static void main(String[] args){\n        boolean b1 = tq.add(1); // true if added, IllegalStateException if full\n            \n        tq.put(2);  //blocks if bounded or full\n        \n        tq.transfer(88); //blocks until element is consumed\n        \n        tq.tryTransfer(7); // returns true if consumed by the awaiting thread, or false without adding if there was no awaiting consumer.\n            // does not block therefore does not throw interruptedException\n        \n        try {\n            \n            //will wait the given time, blocking, then will return if not consumed\n            boolean b7 = tq.tryTransfer(99,10,TimeUnit.SECONDS);\n            \n        } catch(InterruptedException e){ }\n\n    }\n    \n    public static void methodsToRetrieve(){\n        Integer i1 = tq.element(); // gets without removing, throws NoSuchElementException if empty\n        \n        Integer i2 = tq.peek(); // gets without removing, null if empty\n        \n        Integer i3 = tq.poll(); //returns and removes the head, null if empty\n        \n        try{\n            Integer i4 = tq.poll(10,TimeUnit.MILLISECONDS); // removes the head, waits the specified time beffore returning null if empty\n        } catch(InterruptedException e) { }\n        \n        Integer i5 = tq.remove(); // removes the head of the queue throws NoSuchElementException if empty\n                \n        try{\n            Integer i6 = tq.take(); //removes the head blocks until an element is ready,\n        } catch(InterruptedException e) { }\n                \n    }','Concurrency',1,0,NULL,5),(722,'This shows the proper use of take() which will block until a book is available,\noffer is also properlyy used becaue it will only add if the queue is not full\nif it is it simply doesn\'t add it and doesn\'t throw an exception or anything.\n\nThis ones good try Topics of Destruction. Enjoy!\nMike chekced out Topics of Destruction\nThis ones good try War what is it good for. Enjoy!\nMax chekced out War what is it good for\nThis ones good try LOTR. Enjoy!\nPriebe chekced out LOTR\nThis ones good try Manson, the secret life. Enjoy!\nDom chekced out Manson, the secret life\nMike: Im done with Topics of Destruction here take it back!\nThis ones good try Topics of Destruction. Enjoy!\nMike chekced out Topics of Destruction\nPriebe: Im done with LOTR here take it back!\nThis ones good try LOTR. Enjoy!\nPriebe chekced out LOTR\nDom: Im done with Manson, the secret life here take it back!\nThis ones good try Manson, the secret life. Enjoy!\nDom chekced out Manson, the secret life\nMike: Im done with Topics of Destruction here take it back!\nThis ones good try Topics of Destruction. Enjoy!\nMike chekced out Topics of Destruction\nMax: Im done with War what is it good for here take it back!\nThis ones good try War what is it good for. Enjoy!\nMax chekced out War what is it good for\nPriebe: Im done with LOTR here take it back!\nThis ones good try LOTR. Enjoy!\nPriebe chekced out LOTR\nMike: Im done with Topics of Destruction here take it back!\nThis ones good try Topics of Destruction. Enjoy!\nMike chekced out Topics of Destruction\nPriebe: Im done with LOTR here take it back!\nThis ones good try LOTR. Enjoy!\nPriebe chekced out LOTR','public class Hello {\n    \n    public static void main(String[] args){\n        Library library = new Library();\n        \n        new Thread(library).start();\n        \n        new Thread(new Renter(library,\"Mike\")).start();\n        new Thread(new Renter(library,\"Max\")).start();\n        new Thread(new Renter(library,\"Priebe\")).start();\n        new Thread(new Renter(library,\"Dom\")).start();\n    }\n}\n\nclass Library implements Runnable{\n    private TransferQueue<Book> shelves = new LinkedTransferQueue<>();\n    \n    public Library() {\n        shelves.add(new Book(\"Topics of Destruction\"));\n        shelves.add(new Book(\"War what is it good for\"));\n        shelves.add(new Book(\"LOTR\"));\n        shelves.add(new Book(\"Manson, the secret life\"));\n    }\n    \n    public void run(){\n        while(true){ }\n    }\n    \n    public Book lend(){\n        \n        try {\n            Book book = shelves.take();\n            System.out.println(\"This ones good try \"+book.getName()+\". Enjoy!\");\n            return book;\n        } catch(InterruptedException e){ }\n        \n        return new Book(\"Free Library Pamphlet on plagarism\");\n    }\n    \n    public void accept(Book book){\n        shelves.offer(book);\n       \n    }\n}\n\nclass Renter implements Runnable {\n    private Library lib;\n    private String name;\n    public Renter(Library lib,String x){\n        name = x;\n        this.lib = lib;\n    }\n    public void run(){\n        while(true){\n            Book book = lib.lend();\n            System.out.println(name+\" chekced out \"+book.getName());\n            try{\n                Thread.sleep(ThreadLocalRandom.current().nextInt(1000,5000));\n            } catch(InterruptedException e) { }\n            \n            System.out.println(name+\": Im done with \"+book.getName()+\" here take it back!\");\n            lib.accept(book);\n        }\n    }\n}\n\n\nclass Book{\n    private String name;\n    public Book(String x ){\n        name = x;\n    }\n    \n    public String getName(){\n        return name;\n    }\n    \n}','Concurrency',0,0,NULL,5),(723,'element() throws NoSuchElementException,\n\n','public class Hello {\n    \n    public static void main(String[] args){\n        Library library = new Library();\n        \n        new Thread(library).start();\n        \n        new Thread(new Renter(library,\"Mike\")).start();\n        new Thread(new Renter(library,\"Max\")).start();\n        new Thread(new Renter(library,\"Priebe\")).start();\n        new Thread(new Renter(library,\"Dom\")).start();\n    }\n}\n\nclass Library implements Runnable{\n    private TransferQueue<Book> shelves = new LinkedTransferQueue<>();\n    \n    public Library() {\n        shelves.add(new Book(\"Capulets and Montagues, the unknown link\"));\n        shelves.add(new Book(\"War What is it Good For\"));\n        shelves.add(new Book(\"Virtuous Villians\"));\n        shelves.add(new Book(\"Love in the Water\"));\n    }\n    \n    public void run(){\n        while(true){ }\n    }\n    \n    public Book lend(){\n        \n        try {\n            Book book = shelves.element();\n            System.out.println(\"This ones good try \"+book.getName()+\". Enjoy!\");\n            return book;\n        } catch(NoSuchElementException e){System.out.println(\"I\'m sorry sir we dont have that book right now\"); }\n        \n        return new Book(\"Free Library Pamphlet on plagarism\");\n    }\n    \n    public void accept(Book book){\n        shelves.offer(book);\n       \n    }\n}\n\nclass Renter implements Runnable {\n    private Library lib;\n    private String name;\n    public Renter(Library lib,String x){\n        name = x;\n        this.lib = lib;\n    }\n    public void run(){\n        while(true){\n            Book book = lib.lend();\n            System.out.println(name+\" chekced out \"+book.getName());\n            try{\n                Thread.sleep(ThreadLocalRandom.current().nextInt(1000,5000));\n            } catch(InterruptedException e) { }\n            \n            System.out.println(name+\": Im done with \"+book.getName()+\" here take it back!\");\n            lib.accept(book);\n        }\n    }\n}\n\nclass Book{\n    private String name;\n    public Book(String x ){\n        name = x;\n    }\n    \n    public String getName(){\n        return name;\n    }\n    \n}','Concurrency',0,0,NULL,5),(724,'The same book keeps getting checked out because peek()\nreturns but does not remove the element\n\nThis ones good try Capulets and Montagues, the unknown link. Enjoy!\nMike chekced out Capulets and Montagues, the unknown link\nThis ones good try Capulets and Montagues, the unknown link. Enjoy!\nMax chekced out Capulets and Montagues, the unknown link\nThis ones good try Capulets and Montagues, the unknown link. Enjoy!\nPriebe chekced out Capulets and Montagues, the unknown link\nThis ones good try Capulets and Montagues, the unknown link. Enjoy!\nDom chekced out Capulets and Montagues, the unknown link\nDom: Im done with Capulets and Montagues, the unknown link here take it back!\nThis ones good try Capulets and Montagues, the unknown link. Enjoy!\nDom chekced out Capulets and Montagues, the unknown link\nMike: Im done with Capulets and Montagues, the unknown link here take it back!\nThis ones good try Capulets and Montagues, the unknown link. Enjoy!\nMike chekced out Capulets and Montagues, the unknown link\nPriebe: Im done with Capulets and Montagues, the unknown link here take it back!\nThis ones good try Capulets and Montagues, the unknown link. Enjoy!\nPriebe chekced out Capulets and Montagues, the unknown link\nMax: Im done with Capulets and Montagues, the unknown link here take it back!\nThis ones good try Capulets and Montagues, the unknown link. Enjoy!\nMax chekced out Capulets and Montagues, the unknown link\nDom: Im done with Capulets and Montagues, the unknown link here take it back!','public class Hello {\n    \n    public static void main(String[] args){\n        Library library = new Library();\n        \n        new Thread(library).start();\n        \n        new Thread(new Renter(library,\"Mike\")).start();\n        new Thread(new Renter(library,\"Max\")).start();\n        new Thread(new Renter(library,\"Priebe\")).start();\n        new Thread(new Renter(library,\"Dom\")).start();\n    }\n}\n\nclass Library implements Runnable{\n    private TransferQueue<Book> shelves = new LinkedTransferQueue<>();\n    \n    public Library() {\n        shelves.add(new Book(\"Capulets and Montagues, the unknown link\"));\n        shelves.add(new Book(\"War What is it Good For\"));\n        shelves.add(new Book(\"Virtuous Villians\"));\n        shelves.add(new Book(\"Love in the Water\"));\n    }\n    \n    public void run(){\n        while(true){ }\n    }\n    \n    public Book lend(){\n\n            Book book = shelves.peek();\n            System.out.println(\"This ones good try \"+book.getName()+\". Enjoy!\");\n        \n            if(book == null){\n                return new Book(\"Free Library Pamphlet on plagarism\");\n            } else {\n                return book;\n            }\n    }\n    \n    public void accept(Book book){\n        shelves.offer(book);\n       \n    }\n}\n\nclass Renter implements Runnable {\n    private Library lib;\n    private String name;\n    public Renter(Library lib,String x){\n        name = x;\n        this.lib = lib;\n    }\n    public void run(){\n        while(true){\n            Book book = lib.lend();\n            System.out.println(name+\" chekced out \"+book.getName());\n            try{\n                Thread.sleep(ThreadLocalRandom.current().nextInt(1000,5000));\n            } catch(InterruptedException e) { }\n            \n            System.out.println(name+\": Im done with \"+book.getName()+\" here take it back!\");\n            lib.accept(book);\n        }\n    }\n}\n\nclass Book{\n    private String name;\n    public Book(String x ){\n        name = x;\n    }\n    \n    public String getName(){\n        return name;\n    }\n    \n}','Concurrency',0,0,NULL,5),(725,'does not compile, \n\nput() will block if there is no space available therefor it throws an\n\nInterruptedException','public class Hello {\n    \n    public static void main(String[] args){\n        Library library = new Library();\n        \n        new Thread(library).start();\n        \n        new Thread(new Renter(library,\"Mike\")).start();\n        new Thread(new Renter(library,\"Max\")).start();\n        new Thread(new Renter(library,\"Priebe\")).start();\n        new Thread(new Renter(library,\"Dom\")).start();\n    }\n}\n\nclass Library implements Runnable{\n    private TransferQueue<Book> shelves = new LinkedTransferQueue<>();\n    \n    public Library() {\n        shelves.add(new Book(\"Capulets and Montagues, the unknown link\"));\n        shelves.add(new Book(\"War What is it Good For\"));\n        shelves.add(new Book(\"Virtuous Villians\"));\n        shelves.add(new Book(\"Love in the Water\"));\n    }\n    \n    public void run(){\n        while(true){ }\n    }\n    \n    public Book lend(){\n\n            Book book = shelves.poll();\n            System.out.println(\"This ones good try \"+book.getName()+\". Enjoy!\");\n        \n            if(book == null){\n                return new Book(\"Free Library Pamphlet on plagarism\");\n            } else {\n                return book;\n            }\n    }\n    \n    public void accept(Book book){\n        shelves.put(book);\n       \n    }\n}\n\nclass Renter implements Runnable {\n    private Library lib;\n    private String name;\n    public Renter(Library lib,String x){\n        name = x;\n        this.lib = lib;\n    }\n    public void run(){\n        while(true){\n            Book book = lib.lend();\n            System.out.println(name+\" chekced out \"+book.getName());\n            try{\n                Thread.sleep(ThreadLocalRandom.current().nextInt(1000,5000));\n            } catch(InterruptedException e) { }\n            \n            System.out.println(name+\": Im done with \"+book.getName()+\" here take it back!\");\n            lib.accept(book);\n        }\n    }\n}\n\nclass Book{\n    private String name;\n    public Book(String x ){\n        name = x;\n    }\n    \n    public String getName(){\n        return name;\n    }\n    \n}','Concurrency',0,0,NULL,5),(726,'take()','Which BlockingCollection method will block if needed until an object becomes\navailabel','Concurrency',0,0,NULL,5),(727,'element()','Which BlockingCollection method throws nosuchelementexception','Concurrency',0,0,NULL,5),(728,'add()','Which BlockingQueue method throws an illegalstateexception if the queueu is bounded and full ? ','Concurrency',0,0,NULL,5),(729,'offer() and offer(e, long timeout, timeunit)','Whic BlockingQueue method returns true if it was added and false if \nthe queueu was full but also provides a timeout overloaded option','Concurrency',0,0,NULL,5),(730,'','','blank',0,0,NULL,5),(731,'String43\nString7\n43\n7\n53\n2','	String a = \"String\";\n        int b = 4;\n        int c = 3;\n        System.out.println(a+b+c);\n        System.out.println(a+(b+c));\n        System.out.println(\"\" + b + 3);\n        System.out.println(b+3);\n        System.out.println(++b + \"\" + c--);\n        System.out.println(c);','Strings',0,0,NULL,5),(732,'','','blank',0,0,NULL,5),(733,'Cached thread pools will create new threads as needed and reuse threads that \nhave become free. Thread that have been idle for 60 seconds are removed.\n\nCan create more threads than system can handle so watch out. ','ExecutorService ex = Executors.newCachedThreadPool();','Executors',0,0,NULL,5),(734,'constructed with an int argument that specifies the number of threads to use\nto execute the tasks. Most common. Prevents system from being overloaded\nwith too many threads. \n\nBase number of threads on some kind of system resource. \n\nuse java.lang.Runtime\n\nRuntime rt = Runtime.getRuntime();\nint cpus = rt.availabeProcessors();','ExecutorService ex = Executors.newFixedThreadPool(4);\n','Executors',0,0,NULL,5),(735,'ThreadPoolExecutor tpe = (ThreadPoolExecutor) Executors.newFixedThreadPool(4);\ntpe.setCorePoolSize(8);\ntpe.setMaximumPoolSize(8);','How to adust the thread count of a pool at runtime\n\n','Executors',0,0,NULL,5),(736,'        ExecutorService ex = Executors.newSingleThreadExecutor(); \n\nwil not compile, it is singlethreadexecutor not singlethreadPool\n\n**Also you shutdown the ExecutorService not the Future!','public class Hello {\n    public static void main(String[] args){\n        ExecutorService ex = Executors.newSingleThreadPool();\n\n        Future<Integer> futint = ex.submit(new FileCounter());\n        \n        System.out.println(\"Do other things while the files are getting counted\");\n        \n        try{\n            int count = futint.get();\n            System.out.println(count);\n            futint.shutdown();\n        }catch(ExecutionException | InterruptedException e){\n            \n        }\n        \n    }\n    \n    \n}\n\nclass FileCounter implements Callable<Integer>{\n    private int fileCount = 0;\n    public Integer call() throws IOException{\n        fileCount = count(Paths.get(\"/home/maxbisesi/Documents\"));\n        return fileCount; \n    }\n    \n    public Integer count(Path d) throws IOException {\n        int count = 0;\n	try(DirectoryStream<Path> stream = Files.newDirectoryStream(d)){\n		for(Path path: stream){\n			count++;\n		}\n	}\n        return count;\n    }\n}','Executors',0,0,NULL,5),(737,'','Scheduled Thread pool:\n	scheduled after a delay or at repeating intervals\n\npublic class Hello {\n    \n    public static void main(String[] args){\n     ScheduledExecutorService ftses = Executors.newScheduledThreadPool(4);\n     \n     ftses.schedule(r, 5, TimeUnit.SECONDS); //run once after a delay\n     \n     ftses.scheduleAtFixedRate(r, 2,5,TimeUnit.SECONDS); //begin after 2 sec delay and begin again every 5\n     \n     ftses.scheduleWithFixedDelay(r, 2, 5, TimeUnit.SECONDS); //begin after 2 sec delay and again 5 seconds after the last exection\n}','Executors',0,0,NULL,5),(738,'Callable and Runnable','an ExecutorService can take what two kinds of objects ?','Executors',0,0,NULL,5),(739,'being able to return a result','What is the primary benifit of using a Callable ?','Executors',0,0,NULL,5),(740,'InterruptedException and ExecutionException','submitting a Callable to an ExecutorService returns a Future reference.\n\nwhat are two possible exceptions that could result ?','Executors',0,0,NULL,5),(741,'raised when an exception was thrown during the execution of the callable\'s\ncall()','ExecutionException','Executors',0,0,NULL,5),(742,'When a callable task is submitted to an executor the task will go run,\ncalling for its return value will block until it is done so otherwise go on \nwith your program until you are ready to use that result. In this code the rest\nof main is executed only after the future is returned.\nrunning...1\nrunning...2\nrunning...3\nrunning...4\nrunning...5\nrunning...6\nrunning...7\nrunning...8\nrunning...9\nrunning...10\nRan: 10\nmain: 0\nmain: 1\nmain: 2\nmain: 3\nmain: 4\nmain: 5\nmain: 6\nmain: 7\nmain: 8\nmain: 9\n','public class Hello {\n    \n    public static void main(String[] args){\n        Callable<Integer> c = new LoopCounter();\n        \n        ExecutorService ex = Executors.newCachedThreadPool();\n        \n        Future<Integer> f = ex.submit(c); //finishes in the future\n        \n        try{\n            Integer v = f.get(); // will block until done\n            System.out.println(\"Ran: \" + v);\n        } catch(InterruptedException | ExecutionException iex){\n            System.out.println(\"Failed\");\n        }\n        \n        for(int i = 0; i<10; i++){\n            System.out.println(\"main: \"+ i);\n        }\n    }\n}\n\nclass LoopCounter implements Callable<Integer> {\n    \n    public Integer call(){\n        int count = ThreadLocalRandom.current().nextInt(1,11);\n        for(int i = 1; i <= count; i++){\n                System.out.println(\"running...\" + i);\n        }\n        return count;\n    }\n}','Executors',0,0,NULL,5),(743,'got it ','Using Executors takes away the need for synchronization, waiting, joining and \nnotifying','Executors',0,0,NULL,5),(744,'The program will complete normally, without shutdown() it would continue to run,\nit is best to shutdown an executor service in order to free up threads.','public class Hello {\n    \n    public static void main(String[] args){\n        Callable<Integer> c = new LoopCounter();\n        \n        ExecutorService ex = Executors.newCachedThreadPool();\n        \n        Future<Integer> f = ex.submit(c); //finishes in the future\n        \n        try{\n            Integer v = f.get(); // will block until done\n            System.out.println(\"Ran: \" + v);\n        } catch(InterruptedException | ExecutionException iex){\n            System.out.println(\"Failed\");\n        }\n        \n        for(int i = 0; i<10; i++){\n            System.out.println(\"main: \"+ i);\n        }\n        \n        ex.shutdown();\n    }\n}\n\nclass LoopCounter implements Callable<Integer> {\n    \n    public Integer call(){\n        int count = ThreadLocalRandom.current().nextInt(1,11);\n        for(int i = 1; i <= count; i++){\n                System.out.println(\"running...\" + i);\n        }\n        return count;\n    }\n}','Executors',0,0,NULL,5),(745,'','ExecutorService ex = ...\n//......\n\nex.shutdown(); // no more new tasks but finish existing tasks\n\ntry{\n	boolean term = ex.awaitTermination(2,TimeUnit.SECONDS);\n		//wait two seconds for running tasks to finsish\n} catch(InterruptedException ex) {\n	//did not wait full two seconds\n} finally {\n   if(!ex.isTerminated()) // are all tasks done ?\n   {\n	List<Runnable> unfinished = ex.shutdownNow();\n		// a collection of unfished tasks\n   }\n}','Executors',0,0,NULL,5),(746,'breaks a big task down into smaller parts\n\n','class RandomInitRA extends RecursiveAction {\n    private static final int THRESHOLD = 10000;\n    private int[] data;\n    private int start;\n    private int end;\n    \n    public RandomInitRA(int[] data, int start, int end) {\n        this.data = data;\n        this.start = start;\n        this.end = end;\n    }\n    \n    protected void compute() {\n        if(end - start <= THRESHOLD) {\n            // if this is a manageable amount of work do the task\n            for(int i = start; i<end; i++){\n                data[i] = ThreadLocalRandom.current().nextInt();\n            }\n        } else { //task too big\n            int halfway = ((end - start) / 2) + start;\n            RandomInitRA a1 = new RandomInitRA(data,start,halfway);\n            a1.fork();\n            RandomInitRA a2 = new RandomInitRA(data,halfway,end);\n            a2.compute();\n            a1.join();\n        }\n    }\n}','Executors',0,0,NULL,5),(747,'use invokeAll instead of the fork join compute, \nRecursiveAction does not reutrn a value so you should not excpect a value\nfrom invoke all. ','class RandomInitRA extends RecursiveAction {\n    private static final int THRESHOLD = 10000;\n    private int[] data;\n    private int start;\n    private int end;\n    \n    public RandomInitRA(int[] data, int start, int end) {\n        this.data = data;\n        this.start = start;\n        this.end = end;\n    }\n    \n    protected void compute() {\n        if(end - start <= THRESHOLD) {\n            // if this is a manageable amount of work do the task\n            for(int i = start; i<end; i++){\n                data[i] = ThreadLocalRandom.current().nextInt();\n            }\n        } else { //task too big\n            int halfway = ((end - start) / 2) + start;\n            RandomInitRA a1 = new RandomInitRA(data,start,halfway);\n            RandomInitRA a2 = new RandomInitRA(data,halfway,end);\n            invokeAll(a1,a2);\n        }\n    }\n}','Executors',0,0,NULL,5),(748,'will not compile, return type of compute from RecursiveAction is void as\nRAs do not return values. ','class RandomInitRA extends RecursiveAction {\n    private static final int THRESHOLD = 10000;\n    private int[] data;\n    private int start;\n    private int end;\n    \n    public RandomInitRA(int[] data, int start, int end) {\n        this.data = data;\n        this.start = start;\n        this.end = end;\n    }\n    \n    protected int compute() {\n        if(end - start <= THRESHOLD) {\n            // if this is a manageable amount of work do the task\n            for(int i = start; i<end; i++){\n                data[i] = ThreadLocalRandom.current().nextInt();\n            }\n        } else { //task too big\n            int halfway = ((end - start) / 2) + start;\n            RandomInitRA a1 = new RandomInitRA(data,start,halfway);\n            RandomInitRA a2 = new RandomInitRA(data,halfway,end);\n            invokeAll(a1,a2);\n        }\n    }\n}','Executors',0,0,NULL,5),(749,'int[] data = new int[10_000_000];\nForkJoinPool fjpool = new ForkJoinPool();\nRandomInitRA ra = new RandomInitRA(data,0,data.length);\n        \nfjpool.invoke(ra);','public class Hello{\n    public static void main(String[]  args){\n        \n        \n        \n    }\n}\n \nclass RandomInitRA extends RecursiveAction {\n    private static final int THRESHOLD = 10000;\n    private int[] data;\n    private int start;\n    private int end;\n    \n    public RandomInitRA(int[] data, int start, int end) {\n        this.data = data;\n        this.start = start;\n        this.end = end;\n    }\n    \n    protected void compute() {\n        if(end - start <= THRESHOLD) {\n            // if this is a manageable amount of work do the task\n            for(int i = start; i<end; i++){\n                data[i] = ThreadLocalRandom.current().nextInt();\n            }\n        } else { //task too big\n            int halfway = ((end - start) / 2) + start;\n            RandomInitRA a1 = new RandomInitRA(data,start,halfway);\n            RandomInitRA a2 = new RandomInitRA(data,halfway,end);\n            invokeAll(a1,a2);\n        }\n    }\n}\n\n//given that the task of this RA is to fill a big array with random numbers\n// how would you start it in main given int[] data = new int[10_000_000];','Executors',0,0,NULL,5),(750,'the forkjoinpool method is invoke() not invokeAll()\n\nit should be:\n\n	fjpool.invoke(ra);\n\nThere is an invokeAll() but it takes a collection of callable and returns \na list of futures. \n\nnotice too that it doesn\'t return a value, technically it is of type Void, and\nnull is the only valid type for Void','public class Hello{\n    public static void main(String[]  args){\n        int[] data = new int[10_000_000];\n        ForkJoinPool fjpool = new ForkJoinPool();\n        RandomInitRA ra = new RandomInitRA(data,0,data.length);\n        \n        fjpool.invokeAll(ra);\n    }\n}\n \nclass RandomInitRA extends RecursiveAction {\n    private static final int THRESHOLD = 10000;\n    private int[] data;\n    private int start;\n    private int end;\n    \n    public RandomInitRA(int[] data, int start, int end) {\n        this.data = data;\n        this.start = start;\n        this.end = end;\n    }\n    \n    protected void compute() {\n        if(end - start <= THRESHOLD) {\n            // if this is a manageable amount of work do the task\n            for(int i = start; i<end; i++){\n                data[i] = ThreadLocalRandom.current().nextInt();\n            }\n        } else { //task too big\n            int halfway = ((end - start) / 2) + start;\n            RandomInitRA a1 = new RandomInitRA(data,start,halfway);\n            RandomInitRA a2 = new RandomInitRA(data,halfway,end);\n            invokeAll(a1,a2);\n        }\n    }\n}','Executors',0,0,NULL,5),(751,'RecursiveAction RecursiveTask','Two subclasses of ForkJoinTask<V>','Executors',0,0,NULL,5),(752,'this will compile \n\nan overriden method CAN have less restrive access, but not more restrictive.\n\ncompute() is protected in abstract class','class RandomInitRA extends RecursiveAction {\n    private static final int THRESHOLD = 10000;\n    private int[] data;\n    private int start;\n    private int end;\n    \n    public RandomInitRA(int[] data, int start, int end) {\n        this.data = data;\n        this.start = start;\n        this.end = end;\n    }\n    \n    public void compute() {\n        if(end - start <= THRESHOLD) {\n            // if this is a manageable amount of work do the task\n            for(int i = start; i<end; i++){\n                data[i] = ThreadLocalRandom.current().nextInt();\n            }\n        } else { //task too big\n            int halfway = ((end - start) / 2) + start;\n            RandomInitRA a1 = new RandomInitRA(data,start,halfway);\n            RandomInitRA a2 = new RandomInitRA(data,halfway,end);\n            invokeAll(a1,a2);\n        }\n    }\n}','Executors',0,0,NULL,5),(753,'','','Executors',0,0,NULL,5),(754,'will not compile an overriden method CAN have more restrictive access but not \nless. private is less than public.','class RandomInitRA extends RecursiveAction {\n    private static final int THRESHOLD = 10000;\n    private int[] data;\n    private int start;\n    private int end;\n    \n    public RandomInitRA(int[] data, int start, int end) {\n        this.data = data;\n        this.start = start;\n        this.end = end;\n    }\n    \n    private void compute() {\n        if(end - start <= THRESHOLD) {\n            // if this is a manageable amount of work do the task\n            for(int i = start; i<end; i++){\n                data[i] = ThreadLocalRandom.current().nextInt();\n            }\n        } else { //task too big\n            int halfway = ((end - start) / 2) + start;\n            RandomInitRA a1 = new RandomInitRA(data,start,halfway);\n            RandomInitRA a2 = new RandomInitRA(data,halfway,end);\n            invokeAll(a1,a2);\n        }\n    }\n}','Executors',0,0,NULL,5),(755,'will not compile, an overriden method cannot have more restrictive access\ndefault is more restrictive than protected.','class RandomInitRA extends RecursiveAction {\n    private static final int THRESHOLD = 10000;\n    private int[] data;\n    private int start;\n    private int end;\n    \n    public RandomInitRA(int[] data, int start, int end) {\n        this.data = data;\n        this.start = start;\n        this.end = end;\n    }\n    \n    void compute() {\n        if(end - start <= THRESHOLD) {\n            // if this is a manageable amount of work do the task\n            for(int i = start; i<end; i++){\n                data[i] = ThreadLocalRandom.current().nextInt();\n            }\n        } else { //task too big\n            int halfway = ((end - start) / 2) + start;\n            RandomInitRA a1 = new RandomInitRA(data,start,halfway);\n            RandomInitRA a2 = new RandomInitRA(data,halfway,end);\n            invokeAll(a1,a2);\n        }\n    }\n}','Executors',0,0,NULL,5),(756,'RecursiveTask<V> returns a value\n\nfor this particular example you should initialize the array with random \nnumber using RandomInitRecursiveAction that doesn\'t return a result. \n\npublic static void main(String[] args) {\n        int[] bigdata = new int[20000];\n        ForkJoinPool fj = new ForkJoinPool();\n        FindMaxPosition fmp = new FindMaxPosition(bigdata,0,bigdata.length);\n        Integer i = fj.invoke(fmp);\n        \n    }','class FindMaxPosition extends RecursiveTask<Integer> {\n     private static final int THRESHOLD = 10000;\n    private int[] data;\n    private int start;\n    private int end;\n    \n    public FindMaxPosition(int[] data, int start, int end) {\n        this.data = data;\n        this.start = start;\n        this.end = end;\n    }\n    \n    public Integer compute() {\n        if (end - start <= THRESHOLD){\n            int position = 0;\n            for(int i = start; i < end; i++){\n                 if(data[i] > data[position]) {\n                     position = i;\n                 }\n            }\n            \n            return position;\n        } else { //task is too big, split it\n            int halfway = ((end - start) / 2) + start;\n            FindMaxPosition p1 = new FindMaxPosition(data,start,halfway);\n            p1.fork();\n            FindMaxPosition p2 = new FindMaxPosition(data,start,halfway);\n            int pos2 = p2.compute();\n            int pos1 = p1.join();\n            \n            //these forked tasks found the greatest value in their subsections now compare the two results \n            \n            if(data[pos1] > data[pos2]) {\n                return pos1;\n            } else if(data[pos1] < data[pos2]){\n                return pos2;\n            } else {\n                return pos1 < pos2 ? pos1 : pos2;\n            }\n        }\n        \n    }\n}','Executors',0,0,NULL,5),(757,'This will create an array of 10000000 elements then, find the biggest value in it\n','public class Hello{\n    public static void main(String[]  args){\n        int[] data = new int[10_000_000];\n        ForkJoinPool fjpool = new ForkJoinPool();\n        RandomInitRA ra = new RandomInitRA(data,0,data.length);\n        fjpool.invoke(ra);\n        \n        FindMaxPosition task = new FindMaxPosition(data,0,data.length);\n        Integer position = fjpool.invoke(task);\n        System.out.println(\"Bigggest value:;\"+ data[position]);\n    }\n}\n\nclass FindMaxPosition extends RecursiveTask<Integer> {\n     private static final int THRESHOLD = 10000;\n    private int[] data;\n    private int start;\n    private int end;\n    \n    public FindMaxPosition(int[] data, int start, int end) {\n        this.data = data;\n        this.start = start;\n        this.end = end;\n    }\n    \n    public Integer compute() {\n        if (end - start <= THRESHOLD){\n            int position = 0;\n            for(int i = start; i < end; i++){\n                 if(data[i] > data[position]) {\n                     position = i;\n                 }\n            }\n            \n            return position;\n        } else { //task is too big, split it\n            int halfway = ((end - start) / 2) + start;\n            FindMaxPosition p1 = new FindMaxPosition(data,start,halfway);\n            p1.fork();\n            FindMaxPosition p2 = new FindMaxPosition(data,start,halfway);\n            int pos2 = p2.compute();\n            int pos1 = p1.join();\n            \n            //these forked tasks found the greatest value in their subsections now compare the two results \n            \n            if(data[pos1] > data[pos2]) {\n                return pos1;\n            } else if(data[pos1] < data[pos2]){\n                return pos2;\n            } else {\n                return pos1 < pos2 ? pos1 : pos2;\n            }\n        }\n        \n    }\n}\n \nclass RandomInitRA extends RecursiveAction {\n    private static final int THRESHOLD = 10000;\n    private int[] data;\n    private int start;\n    private int end;\n    \n    public RandomInitRA(int[] data, int start, int end) {\n        this.data = data;\n        this.start = start;\n        this.end = end;\n    }\n    \n    protected void compute() {\n        if(end - start <= THRESHOLD) {\n            // if this is a manageable amount of work do the task\n            for(int i = start; i<end; i++){\n                data[i] = ThreadLocalRandom.current().nextInt();\n            }\n        } else { //task too big\n            int halfway = ((end - start) / 2) + start;\n            RandomInitRA a1 = new RandomInitRA(data,start,halfway);\n            RandomInitRA a2 = new RandomInitRA(data,halfway,end);\n            invokeAll(a1,a2);\n        }\n    }\n}','Executors',0,0,NULL,5),(758,'ages.remove(\"John\",23);\n\npublic boolean remove(Object key,\n             Object value)\n\nRemoves the entry for a key only if currently mapped to a given value. This is equivalent to\n\n   if (map.containsKey(key) && map.get(key).equals(value)) {\n       map.remove(key);\n       return true;\n   } else return false;\n\nexcept that the action is performed ATOMICALLY.\n\nThere is another remove method that comes from the map Interface...\nthat is the standard remove function.\n\npublic V remove(Object key)\n\nRemoves the key (and its corresponding value) from this map. This method does nothing if the key is not in the map.\n\nSpecified by:\n    remove in interface Map<K,V>\nOverrides:\n    remove in class AbstractMap<K,V>\nParameters:\n    key - the key that needs to be removed\nReturns:\n    the previous value associated with key, or null if there was no mapping for key','ConcurrentMap<String,Integer> ages = new ConcurrentHashMap<>();\nages.put(\"John\",23);\n\nWhich method would delete Joh from the map only if his value was still equal \nto 23','Concurrency',0,0,NULL,5),(759,'i.addAndGet(9);\ni.getAndAdd(9);','AtomicInteger i = new AtomicInteger();\ntwo methods to atomically increment by 9?','Concurrency',0,0,NULL,5),(760,'only one thread at a time can access the write lock where multiple threads\ncan access the readLock','class LeaderBoard {\n    private ReadWriteLock rwl = new ReentrantReadWriteLock();\n    private List<Integer> highScores = new ArrayList<Integer>();\n    public void addScore(Integer score){\n        Lock lock = rwl.writeLock();\n        lock.lock();\n        \n        try{\n            if(highScores.size() < 10) {\n                highScores.add(score);\n            } else if(highScores.get(highScores.size() - 1) < score) {\n                highScores.set(highScores.size() - 1, score);\n            } else {\n                return;\n            }\n            \n            Collections.sort(highScores,Collections.reverseOrder());\n        } finally{\n            lock.unlock();\n        }\n    }\n    \n    public List getHighScores(){\n        Lock lock = rwl.readLock();\n        lock.lock();\n        try{\n            return Collections.unmodifiableList(highScores);\n        } finally {\n            lock.unlock();\n        }\n    }\n}','Concurrency',0,0,NULL,5),(761,'IllegalMonitorStateExcetion rwl.writeLock() was not locked before it was unloked\n','public class Hello {\n\n    public static void main(String[] args) {\n       LeaderBoard lb = new LeaderBoard();\n       lb.addScore(56);\n    }\n    \n}\n\nclass LeaderBoard {\n    private ReadWriteLock rwl = new ReentrantReadWriteLock();\n    private List<Integer> highScores = new ArrayList<Integer>();\n    public void addScore(Integer score){\n        Lock lock = rwl.writeLock();\n        \n        try{\n            if(highScores.size() < 10) {\n                highScores.add(score);\n            } else if(highScores.get(highScores.size() - 1) < score) {\n                highScores.set(highScores.size() - 1, score);\n            } else {\n                return;\n            }\n            \n            Collections.sort(highScores,Collections.reverseOrder());\n        } finally{\n            lock.unlock();\n        }\n    }\n    \n    public List getHighScores(){\n        Lock lock = rwl.readLock();\n        lock.lock();\n        try{\n            return Collections.unmodifiableList(highScores);\n        } finally {\n            lock.unlock();\n        }\n    }\n}','Concurrency',0,0,NULL,5),(762,'compiles fine, The writeLock is locked but never unlocked,that will not throw\nan exception.','public class Hello {\n\n    public static void main(String[] args) {\n       LeaderBoard lb = new LeaderBoard();\n       lb.addScore(5);\n    }\n    \n}\n\nclass LeaderBoard {\n    private ReadWriteLock rwl = new ReentrantReadWriteLock();\n    private List<Integer> highScores = new ArrayList<Integer>();\n    public void addScore(Integer score){\n        Lock lock = rwl.writeLock();\n        lock.lock();\n        try{\n            if(highScores.size() < 10) {\n                highScores.add(score);\n            } else if(highScores.get(highScores.size() - 1) < score) {\n                highScores.set(highScores.size() - 1, score);\n            } else {\n                return;\n            }\n            \n            Collections.sort(highScores,Collections.reverseOrder());\n        } finally{\n\n        }\n    }\n    \n    public List getHighScores(){\n        Lock lock = rwl.readLock();\n        lock.lock();\n        try{\n            return Collections.unmodifiableList(highScores);\n        } finally {\n            lock.unlock();\n        }\n    }\n}','Concurrency',0,0,NULL,5),(763,'Thread-0 []\nThread-2 []\nThread-1 []\n... and will keep running\n\nsince the readlock is never unlocked() in getHighScores() the three threads will\nacquire the read lock but never release it. \n\nThat will prevent any of them from getting the write lock. RRWL allows multiple\nthreads to read at the same time but will wait for an exclusive lock before\nallowing threads to write to it. meaning no other thread can be reading while\nanother thread is writing to the locked object!','public class Hello {\n\n    public static void main(String[] args) {\n       LeaderBoard lb = new LeaderBoard();\n       Player a = new Player(lb);\n       Player b = new Player(lb);\n       Player c = new Player(lb);\n       \n       a.start();\n       b.start();\n       c.start();\n    }\n    \n}\n\nclass LeaderBoard {\n    private ReadWriteLock rwl = new ReentrantReadWriteLock();\n    private List<Integer> highScores = new ArrayList<Integer>();\n    public void addScore(Integer score){\n        Lock lock = rwl.writeLock();\n        lock.lock();\n        try{\n            if(highScores.size() < 10) {\n                highScores.add(score);\n            } else if(highScores.get(highScores.size() - 1) < score) {\n                highScores.set(highScores.size() - 1, score);\n            } else {\n                return;\n            }\n            \n            Collections.sort(highScores,Collections.reverseOrder());\n        } finally{\n            lock.unlock();\n        }\n    }\n    \n    public List getHighScores(){\n        Lock lock = rwl.readLock();\n        lock.lock();\n        try{\n            return Collections.unmodifiableList(highScores);\n        } finally {\n\n        }\n    }\n}\n\nclass Player extends Thread {\n    private LeaderBoard lb;\n    public Player(LeaderBoard x){\n        lb = x;\n        \n    }\n    public void run(){\n        System.out.println(Thread.currentThread().getName()+\" \"+lb.getHighScores());\n        for(int i = 0; i<3; i++){\n            postHighScore();\n        }    \n    }\n    \n    public void postHighScore(){\n        lb.addScore(ThreadLocalRandom.current().nextInt());\n    }\n}\n','Concurrency',0,0,NULL,5),(764,'\n\nFirst, InputStreamReader can handle all input streams, not just files. Other examples are network connections, classpath resources and ZIP files.\n\nSecond, FileReader does not allow you to specify an encoding and instead uses the plaform default encoding, which makes it pretty much useless as using it will result in corrupted data when the code is run on systems with different platform default encodings.\n\nIn short, forget that FileReader exists.\n','I can\'t seem to determine any difference between InputStreamReader and FileReader besides the way the two are initialized. \nIs there any benefit to using one or the other? \nMost other articles cover FileInputStream vs InputStreamReader, but I am contrasting with FileReader instead. \nSeems to me they both have the same purpose.','General',0,0,NULL,5),(765,'-This is impossible to do.\n The reason to not include it, is the wide range of input types it supports. One example is streams. These don\'t store the results after they have been passed on,\n so they don\'t support resetting.\n So the elegant way is to create a new Scanner. \n If you give it many custom settings, create a factory method.\n\n-There is no \"counter\" in the Scanner object. \n Instead think of it as more like a conveyor belt. \n The belt has no knowledge or care about what\'s on it. \n It just keeps spitting things out at you while there are items left on it. \n And once you take them, they\'re gone from it for good.\n','while (scanNumOfLines.hasNextLine())    \n    {\n    NumOfLines ++;\n    scanNumOfLines.nextLine();\n    }\n    System.out.println(\"NumOfLines = \"+NumOfLines);\n\nSo it counts fine, but I want to re-use the scanner for another purpose, but the nextLine has moved to the last line of the file, and I want to reset it back to the first line.\n\n(Instead, I had to use another scanner for the other purpose, and to me this seems less elegant than it should be.)\n\nI\'m sure there must be a scanner method that resets the counter to zero?','General',0,0,NULL,5),(766,'- \n\nAs a formal method parameter is a local variable, you can access them from inner anonymous classes only if they are declared as final.\n\nThis saves you from declaring another local final variable in the method body:\n\n void m(final int param) {\n        new Thread(new Runnable() {\n            public void run() {\n                System.err.println(param);\n            }\n        }).start();\n    }\n\n\n\n\n- final is used here to ensure the two indexes i and j won\'t accidentally be reset by the method. It\'s a handy way to protect against an insidious bug that erroneously changes the value of your parameters. \nGenerally speaking, short methods are a better way to protect from this class of errors,\nbut final parameters can be a useful addition to your coding style.\nNote that final parameters are not considered part of the method signature, and are ignored by the compiler when resolving method calls. Parameters can be declared final (or not) with no influence on how the method is overriden.\n\n-Might be better to use objects rather than primitives for this example, as primitive changes will always only be visible inside the method. \nAnd in the case of objects, you can still change them. You just can\'t point at a new object. In fact now I think about it, final doesn\'t really change anything \ncompared to leaving it out, other than saving a variable declaration with AICs and having the compiler point out accidental modifications of parameters that \nyou didn\'t want to modify for some reason.\n\n\n\nThe final prevents you from assining a new value to the variable, and this can be helpful in catching typos. \nStylistically you might like to keep the parameters received unchanged and assign only to local variables, \nso final would help to enforce that style.\n\npublic int example(final int basicRate){\n    int discountRate;\n\n    discountRate = basicRate - 10;\n    // ... lots of code here \n    if ( isGoldCustomer ) {\n        basicRate--;  // typo, we intended to say discountRate--, final catches this\n    }\n    // ... more code here\n\n    return discountRate;\n}\n\n','What difference that final makes between the code below. Is there any advantage in declaring the arguments as final.\n\npublic String changeTimezone( Timestamp stamp, Timezone fTz, Timezone toTz){  \n    return ....\n}\n\npublic String changeTimezone(final Timestamp stamp, final Timezone fTz, \n        final Timezone toTz){\n    return ....\n}\n\n','General',0,0,NULL,5),(767,'compiles fine','abstract class A {\n    public abstract void foo(final String s);\n}\n\nclass B extends A {\n    public void foo(String x){\n        System.out.println(x);\n    }\n}','General',0,0,NULL,5),(768,'only the first,\n\nthe only argument constructor for cachedthreadpool takes a threadfactory.\n\na fixed thread pool has to have a size.','Executor ex = Executors.newFixedThreadPool(9);\nExecutor ex2 = Executors.newFixedThreadPool();\nExecutor ex3 = Executor.newFixedThreadPool(9);\nExecutor ex4 = Executors.newCachedThreadPool(7);\n\nwhich can compile ?','Executors',0,0,NULL,5),(769,'will not compile, unreported exception ExecutionException thrown by .get()','private Integer executeTask (ExecutorService service, Callable<Integer> task){\n        try{\n            Future<Integer> future = service.submit(task);\n            return future.get();\n        } catch(InterruptedException e){\n            return null;\n        }\n    }','Executors',0,0,NULL,5),(770,'will not compile, unreported Exeption InterruptedException thrown by .get()\n\nshould be :\n\n	catch(ExecutionException | InterruptedException e){\n            return null;\n        }','private Integer executeTask (ExecutorService service, Callable<Integer> task){\n        try{\n            Future<Integer> future = service.submit(task);\n            return future.get();\n        } catch(ExecutionException e){\n            return null;\n        }\n    }','Executors',0,0,NULL,5),(771,'will execute the submitted task\n\nfuture.get() will block until the activity is done.',' private Integer executeTask (ExecutorService service, Callable<Integer> task){\n        try{\n            Future<Integer> future = service.submit(task);\n            return future.get();\n        } catch(InterruptedException | ExecutionException e){\n            return null;\n        }\n    }','Executors',0,0,NULL,5),(772,'try{\n	Future<Integer> future = service.submit(task);\n	return future.get();\n} catch(InterruptedException | ExecutionException e){\n   	return null;\n}\n\nor ...\n\ntry{\n	Future<Integer> future = service.submit(task);\n	return future.get();\n} catch(Exception e){\n   	return null;\n}\n\n.get() will block until a result is available',' private Integer executeTask (ExecutorService service, Callable<Integer> task){\n        // insert code \n    }\n\nwhat code could you insert here to execute the task using the service','Executors',0,0,NULL,5),(773,'FALSE, A Callable<E> can do that a runnable cannot do either of those things.','A runnable can return a result and throw an exception','Executors',0,0,NULL,5),(774,'1 and 5\n\nWhen creating multiple forkjointask instances all tasks except one shuld be forked\nfirst so that they can be picked up by other forkjoin worker threads.\nThe final task should then be executed within the same thread by calling compute()\nbefore calling join on all the forked threads to await their results. \n\ncallin methods in the wrong order will not cause compiler error so care must be taken','With RecursiveTask subclasses which are true ?\n\n1.fork() and join() should be called on the same task.\n2.fork() and compute() should be called on the same task.\n3.compute() and join() should be called on the same task.\n4.compute() should be called before fork()\n5.fork() should be called before compute()\n6.join() should be called after fork() but before compute()','Concurrency',0,0,NULL,5),(775,'55','public class Hello {\n\n    public static void main(String[] args) {\n        Fibonacci fibonacci = new Fibonacci(10);\n        ForkJoinPool pool = new ForkJoinPool();\n        System.out.println(pool.invoke(fibonacci));\n    }\n}\n\nclass Fibonacci extends RecursiveTask<Long> {\n    final long n;\n    \n    Fibonacci(long n) {\n        this.n = n;\n    }\n    \n    public Long compute() {\n        if (n<=10) {\n            return do_fibonacci(n);\n        }\n        ForkJoinTask<Long> subTask = new Fibonacci(n-1).fork();\n        return new Fibonacci(n-2).compute() + subTask.join();\n    }\n    \n    static long do_fibonacci(long n) {\n        if ( n<=1 ) return n;\n        return do_fibonacci(n-1) + do_fibonacci(n-2);\n    }\n}','Concurrency',0,0,NULL,5),(776,'55, join() returns the result of the forked procedure. \n\nfork() and join() should be called on the same, Task','public class Hello {\n\n    public static void main(String[] args) {\n        Fibonacci fibonacci = new Fibonacci(10);\n        ForkJoinPool pool = new ForkJoinPool();\n        System.out.println(pool.invoke(fibonacci));\n    }\n}\n\nclass Fibonacci extends RecursiveTask<Long> {\n    final long n;\n    \n    Fibonacci(long n) {\n        this.n = n;\n    }\n    \n    public Long compute() {\n        if (n<=10) {\n            return do_fibonacci(n);\n        }\n        //ForkJoinTask<Long> subTask = new Fibonacci(n-1).fork();\n        //return new Fibonacci(n-2).compute() + subTask.join();\n        //same as ...\n        ForkJoinTask<Long> f1 = new Fibonacci(n-1);\n        Fibonacci f2 = new Fibonacci(n-2);\n        f1.fork();\n        Long l1 = f2.compute();\n        Long l2 = f1.join();\n        return l1+l2;\n    }\n    \n    static long do_fibonacci(long n) {\n        if ( n<=1 ) return n;\n        return do_fibonacci(n-1) + do_fibonacci(n-2);\n    }\n}','Concurrency',0,0,NULL,5),(777,'Polymorphism bites you in the ass here again,\nclass Fibonacci has a compute method not FJT','class Fibonacci extends RecursiveTask<Long> {\n    final long n;\n    \n    Fibonacci(long n) {\n        this.n = n;\n    }\n    \n    public Long compute() {\n        if (n<=10) {\n            return do_fibonacci(n);\n        }\n        //ForkJoinTask<Long> subTask = new Fibonacci(n-1).fork();\n        //return new Fibonacci(n-2).compute() + subTask.join();\n        //same as ...\n        ForkJoinTask<Long> f1 = new Fibonacci(n-1);\n        ForkJoinTask<Long> f2 = new Fibonacci(n-2);\n        f1.fork();\n        Long l1 = f2.compute();\n        Long l2 = f1.join();\n        return l1+l2;\n    }\n    \n    static long do_fibonacci(long n) {\n        if ( n<=1 ) return n;\n        return do_fibonacci(n-1) + do_fibonacci(n-2);\n    }\n}','Concurrency',0,0,NULL,5),(778,'type fibonacci does not take parameters','public class Hello {\n\n    public static void main(String[] args) {\n        Fibonacci fibonacci = new Fibonacci(10);\n        ForkJoinPool pool = new ForkJoinPool();\n        System.out.println(pool.invoke(fibonacci));\n    }\n}\n\nclass Fibonacci extends RecursiveTask<Long> {\n    final long n;\n    \n    Fibonacci(long n) {\n        this.n = n;\n    }\n    \n    public Long compute() {\n        if (n<=10) {\n            return do_fibonacci(n);\n        }\n        //ForkJoinTask<Long> subTask = new Fibonacci(n-1).fork();\n        //return new Fibonacci(n-2).compute() + subTask.join();\n        //same as ...\n        ForkJoinTask<Long> f1 = new Fibonacci(n-1);\n        Fibonacci<Long> f2 = new Fibonacci(n-2);\n        f1.fork();\n        Long l1 = f2.compute();\n        Long l2 = f1.join();\n        return l1+l2;\n    }\n    \n    static long do_fibonacci(long n) {\n        if ( n<=1 ) return n;\n        return do_fibonacci(n-1) + do_fibonacci(n-2);\n    }\n}','General',0,0,NULL,5),(779,'this program will never complete subtask is never forked so using join() will \nnever be able to return a result and it will block forever. \n\nto fix \n\nsubtask.fork();\n\n	ForkJoinTask<Long> subTask = new Fibonacci(n-1).fork();\n        ret = new Fibonacci(n-2).compute() + subTask.join();\n        result[(int)n] = new Long(ret);\n        return ret;','public class Hello {\n\n    public static void main(String[] args) {\n         Fibonacci fibonacci = new Fibonacci(15);\n         ForkJoinPool pool = new ForkJoinPool();\n         System.out.println(pool.invoke(fibonacci));\n    }\n}\n\n\nclass Fibonacci extends RecursiveTask<Long> {\n    final long n;\n    public static Long[] result = new Long[2];\n    public static int max_num = 1;\n    \n    public static void set_max(int num) {\n        result[0] = new Long(1);\n        result[1] = new Long(1);\n        if ( num > max_num ) {\n            Long[] new_result = new Long[num+1];\n            \n            for (int i=0; i<=max_num; i++) {\n                new_result[i] = result[i];\n            }\n            \n            result = new_result;\n            \n            for (int i=max_num+1; i<=num; i++) {\n                result[i] = new Long(0);\n            }\n            max_num = num;            \n        }\n    }\n    \n    Fibonacci(long n) {\n        this.n = n;\n        if ( n > 1 )\n            set_max((int)n);\n    }\n        \n    public Long compute() {\n        Long ret;\n        if ( result[(int)n].longValue() != 0 ) {\n            return result[(int)n];\n        }\n        if (n<=10) {\n            return do_fibonacci(n);\n        }\n        ForkJoinTask<Long> subTask = new Fibonacci(n-1);\n        ret = new Fibonacci(n-2).compute() + subTask.join();\n        result[(int)n] = new Long(ret);\n        return ret;\n    }\n    \n    static long do_fibonacci(long n) {\n        long ret;\n        if (result[(int)n].longValue() != 0) {\n            ret = result[(int)n].longValue();\n        } else {\n            long ret_n_1 = do_fibonacci(n-1);\n            long ret_n_2 = do_fibonacci(n-2);\n            ret = ret_n_1 + ret_n_2;\n            result[(int)n] = new Long(ret);\n        }\n        return ret;\n    }\n}','General',0,0,NULL,5),(780,'will wait forever a subtask has to be fork()ed before it can rejoin the \nmain task. ','public class Hello {\n\n    public static void main(String[] args) {\n         Fibonacci fibonacci = new Fibonacci(15);\n         ForkJoinPool pool = new ForkJoinPool();\n         System.out.println(pool.invoke(fibonacci));\n    }\n}\n\n\nclass Fibonacci extends RecursiveTask<Long> {\n    final long n;\n    public static Long[] result = new Long[2];\n    public static int max_num = 1;\n    \n    public static void set_max(int num) {\n        result[0] = new Long(1);\n        result[1] = new Long(1);\n        if ( num > max_num ) {\n            Long[] new_result = new Long[num+1];\n            \n            for (int i=0; i<=max_num; i++) {\n                new_result[i] = result[i];\n            }\n            \n            result = new_result;\n            \n            for (int i=max_num+1; i<=num; i++) {\n                result[i] = new Long(0);\n            }\n            max_num = num;            \n        }\n    }\n    \n    Fibonacci(long n) {\n        this.n = n;\n        if ( n > 1 )\n            set_max((int)n);\n    }\n        \n    public Long compute() {\n        Long ret;\n        if ( result[(int)n].longValue() != 0 ) {\n            return result[(int)n];\n        }\n        if (n<=10) {\n            return do_fibonacci(n);\n        }\n        ForkJoinTask<Long> subTask = new Fibonacci(n-1);\n        ret = new Fibonacci(n-2).compute() + subTask.join();\n        subTask.fork();\n        result[(int)n] = new Long(ret);\n        return ret;\n    }\n    \n    static long do_fibonacci(long n) {\n        long ret;\n        if (result[(int)n].longValue() != 0) {\n            ret = result[(int)n].longValue();\n        } else {\n            long ret_n_1 = do_fibonacci(n-1);\n            long ret_n_2 = do_fibonacci(n-2);\n            ret = ret_n_1 + ret_n_2;\n            result[(int)n] = new Long(ret);\n        }\n        return ret;\n    }\n}','General',0,0,NULL,5),(781,'This is the same behavior of your typical ReadWriteLock usage case if there\n is available data for reading. If no data exists, then a reader becomes a\n \"writer\" (in the lock sense) and waits until some data is available. The \ncycle repeats until some available data is returned (or until an interrupt \noccurs).\n\nSince you\'re using a ReadWriteLock, it means you\'re expecting a much \ngreater number of reads than writes and so you chose a lock that minimizes \ncontention between reader threads (the readLock).\n\nThe method waitForData() turns readers into \"writers\" because they lock on\n the writeLock instead, resulting in an increased contention between all\n threads (readers and writers). However, since writes are assumed to be \nmuch rarer than reads, a situation where data keeps toggling fast \nbetween \"available\" and \"unavailable\" is not expected. In other words, \nassuming writes are rare:\n\n    If there is no available data for reading, then virtually all readers\n will typically block in the method waitForData() after some time, and\n will all be notified at the same time when some new data is written.\n\n    If there is some available data for reading, then all readers will\n simply read it without creating any contention among the threads when \nlocking the readLock.\n','private final ReentrantReadWriteLock    rwl         = new ReentrantReadWriteLock();\nprotected final Lock                    readLock    = rwl.readLock();\nprotected final Lock                    writeLock   = rwl.writeLock();\nprotected final Condition               hasData     = writeLock.newCondition();\n\n\npublic void write() {\n\n    writeLock.lock();\n    try {\n        // write data\n        // ...\n        if (something_written) {\n            hasData.signalAll();\n        }\n    }\n    finally {\n        writeLock.unlock();\n    }\n}\n\n// replace Object by something else\npublic Object read() throws InterruptedException {\n\n    Object data = tryRead();\n\n    while (data == null) {\n        waitForData();\n        data = tryRead();\n    }\n\n    return data;\n}\n\n// replace Object by something else\nprivate Object tryRead() {\n\n    readLock.lock();\n    try {\n        Object data = null;\n        // read data\n        // ...\n        // if there no data available, return null\n        return data;\n    }\n    finally {\n        readLock.unlock();\n    }\n}\n\nprivate void waitForData() throws InterruptedException {\n\n    writeLock.lock();\n    try {\n        boolean data_available = // check data\n        while (!data_available) {\n            hasData.await(1000L, TimeUnit.MILLISECONDS);\n            data_available = // check data\n        }\n    }\n    finally {\n        writeLock.unlock();\n    }\n}\n','Concurrency',0,0,NULL,5),(782,'What this does is force your reader thread to sleep until some data is written by the writer thread .','private final ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();\nprotected final Lock readLock = rwl.readLock();\nprotected final Lock writeLock = rwl.writeLock();\nprotected final Condition hasData = writeLock.newCondition();\nprivate HashMap myData = new HashMap(); //example structure to read and write\n\nprivate final ReentrantLock dataArrivalLock = new ReentrantLock();\nprivate final Condition dataArrivalSignal = dataArrivalLock.newCondition();\n\nYour writer method pattern :\n\ntry {\n   writeLock.lock();    \n\n   //...\n   myData.put(\"foo\",\"ffoo\"); //write something !!\n   if( something_written ) {\n      hasData.signalAll();\n   }\n\n}\nfinally {\n   writeLock.unlock();\n}\n  try {\n                //signal other threads that data has been put in\n                dataArrivalLock.lock();\n                dataArrivalSignal.signalAll();\n\n            } finally {\n                dataArrivalLock.unlock();\n            }\n\nYour reader method pattern\n\ntry {\n            boolean gotData = false;\n            while (!gotData) {\n                try {\n                    readLock.lock();\n                    if (myData.size() > 0) {\n                        gotData = true;\n                        //retrieve the data that is written by writer thred!!\n                        myData.get(\"foo\");\n                    }\n                } finally {\n                    readLock.unlock();\n                }\n                if(!gotData) {\n //sleep the reader thread for x milliseconds. x depends on your application requirement\n                  //   Thread.sleep(250);\n                    try {\n                        //instead of Thread.sleep(), use the dataArrivalLock signal to wakeup\n                        dataArrivalLock.lock();\n                        dataArrivalSignal.await();\n                        //based on how the application works a timed wait might be better !!\n                        //dataArrivalSignal.await(250);\n                    } finally {\n                        dataArrivalLock.unlock();\n                    }\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        } ','Concurrency',0,0,NULL,5),(783,'Read lock does not support Conditions so calling newCondition() will cause \nan UnsupportedOperationException','class CarRadio extends Thread {\n    \n    public void run(){\n      while(true){  \n        Song nextSong = DJ.spinNextTrack();\n        play(nextSong);\n        try{ Thread.sleep(2000); } catch(InterruptedException e) { }\n      }\n    }\n    public void play(Song song){\n        System.out.println(\"CarRadio: \"+song.getClip());\n    }\n    \n}\n\nclass DJ {\n    private final static LinkedList<Song> queue = new LinkedList<>();\n    private final static ReentrantReadWriteLock queueLock = new ReentrantReadWriteLock();\n    private final static Lock readLock = queueLock.readLock();\n    private final static Lock writeLock = queueLock.writeLock();\n    private final static Condition newSong = writeLock.newCondition();\n    private final static Condition readSong = readLock.newCondition();\n    private final static DJ INSTANCE = new DJ();\n    \n    private DJ(){\n\n    }\n    \n    public static DJ callDJ(){\n        return INSTANCE;\n    }\n\n    public static Song spinNextTrack(){\n        readLock.lock();\n        try{\n            if(queue.isEmpty()){\n                try { newSong.await(); }catch(InterruptedException e) { }\n            }\n            return queue.poll(); \n        } finally {\n            readLock.unlock();\n        }      \n    }\n\n    public static void addToQueue(Song song){\n        writeLock.lock();\n        try{\n            //this lock blocks until acquired\n            //queueLock.writeLock().lock();\n            queue.add(song);\n            newSong.signalAll();\n        } finally{\n            writeLock.unlock();\n        }\n    }\n}\n\nclass ConstantPop extends Thread {\n    private String[] sounds = {\" Lah \", \" La La \", \" Naaahh \", \" YOLO \" };\n    private static int songCounter = 0;\n    \n    public void run(){\n        while(true){\n            Song hotNewSong = studio();\n            DJ.addToQueue(hotNewSong);\n            try { Thread.sleep(2000); } catch(InterruptedException e) { }  \n        }\n    }\n    private Song studio(){\n        StringBuilder sb = new StringBuilder();\n        for(int i = 0; i<=3; i++){\n            sb.append(sounds[ThreadLocalRandom.current().nextInt(0,3)]);\n        }\n        songCounter++;\n        return new Song(\"PopSong.\"+songCounter,sb.toString());\n    }\n}','Concurrency',0,0,NULL,5),(784,'Copy on write, because they mkae a new copy of the collection for each write.','Which Collection from java.util.concurrent is best when there are more reads\nthan writes','Concurrency',0,0,NULL,5),(785,'putIfAbsent(K key, V value)\n\nremove(Object key, Object value)\n\nreplace(K key, V value)\n\nreplace(K key, V oldValue, V newValue)','ConcurrentSkipListMap and concurrentMap atomic methods','Concurrency',0,0,NULL,5),(786,'a concrete class with static methods is used to create instances of objects \nthat implement an interface.','Factory patter:','Concurrency',0,0,NULL,5),(787,'Factory,\n\nfactory is used to create instances of classes that implement an interface.\nCan be used at runtime to decide which object to create at runtime','what pattern ?\n\npublic interface Vehicle {\n	public void start();\n	public void stop();\n}\n\npublic class Car implements Vehicle {\n	public void start() { }\n	public void stop() { }\n}\n\npublic class CarManufacturer {\n	public static Vehicle getVehicle(String type) {\n		//create an instance of the type passed in\n	}\n}\n\nclass MyClass {\n	psmv(sa) {\n		Vehicle ferrari = CarManufacturer.getVehicle(\"Ferrari\");\n	\n		ferrari.start();\n	}\n}','Concurrency',0,0,NULL,5),(788,'','for jdbc 3.0 drivers and earlier you are responsible for loading the class\nusing static forName(). Later driver classes are loaded automatically.','Concurrency',0,0,NULL,5),(789,'10001\nGeorgi\nFacello\n10002\nBezalel\nSimmel\n10003\nParto\nBamford\n10004\nChirstian\nKoblick\n10005\nKyoichi\nMaliniak\n10006\nAnneke\nPreusig\n10007\nTzvetan\nZielinski\n10008\nSaniya\nKalloufi\n10009\nSumant\nPeac\n10010\nDuangkaew\nPiveteau','public class Hello {\n    public static void main(String[] args){\n        try {\n            Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\");\n            Statement st = conn.createStatement();\n            String query = \"Select * From employees limit 10\";\n            ResultSet rs = st.executeQuery(query);\n            while(rs.next()){\n                System.out.println(rs.getInt(\"emp_no\"));\n                System.out.println(rs.getString(\"first_name\"));\n                System.out.println(rs.getString(\"last_name\"));\n            } \n            \n        } catch(SQLException e){ }\n        \n    }\n}\n','Concurrency',0,0,NULL,5),(790,'will not compile, executeUPdate returns an int of updated rows.','public class Hello {\n    public static void main(String[] args){\n        try {\n            Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\");\n            Statement st = conn.createStatement();\n            String update = \"update employee set emp_no = 11111 where first_name = Georgi\";\n            ResultSet rs = st.executeUpdate(update);\n            while(rs.next()){\n                System.out.println(rs.getInt(\"emp_no\"));\n                System.out.println(rs.getString(\"first_name\"));\n                System.out.println(rs.getString(\"last_name\"));\n            } \n            \n        } catch(SQLException e){ }\n        \n    }\n}','Concurrency',0,0,NULL,5),(791,'execute(String sql) \n\nthe return value is true if the result is a result set and false if the \nquery is an update count or no results. \n\n','what jdbc method would you use when you are unsure of the result of a query\nor update','Concurrency',0,0,NULL,5),(792,'false \n\nexecute returns true if it returns a result set and false for an update count','public class Hello {\n    public static void main(String[] args){\n        try {\n            Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\");\n            Statement st = conn.createStatement();\n            String update = \"Update employees Set first_name = \'Big John\' where first_name = \'Georgi\'\";\n            boolean b = st.execute(update);\n            System.out.println(b);\n        } catch(SQLException e){System.out.println(\"something went wrong\"); }\n        \n    }\n}','Concurrency',0,0,NULL,5),(793,'if getUpdateCount() returns -1 then there were no results.','public class Hello {\n    public static void main(String[] args){\n        try {\n            Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\");\n            Statement st = conn.createStatement();\n            String update = \"Update employees Set first_name = \'Big John\' where first_name = \'Georgi\'\";\n            boolean b = st.execute(update);\n            if(b){\n                //ResultSet res = update.getResultSet();\n                ResultSet res = st.getResultSet();\n            } else {\n                int numrows = st.getUpdateCount();\n                if(numrows == -1){\n                    System.out.println(\"No Results\");\n                }\n            }\n        } catch(SQLException e){System.out.println(\"something went wrong\"); }\n        \n    }\n}','Concurrency',0,0,NULL,5),(794,'will not compiles, getResultSet is from a statement object','public class Hello {\n    public static void main(String[] args){\n        try {\n            Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\");\n            Statement st = conn.createStatement();\n            String update = \"Update employees Set first_name = \'Big John\' where first_name = \'Georgi\'\";\n            boolean b = st.execute(update);\n            if(b){\n                ResultSet res = update.getResultSet();\n            } else {\n                int numrows = st.getUpdateCount();\n                if(numrows == -1){\n                    System.out.println(\"No Results\");\n                }\n            }\n        } catch(SQLException e){System.out.println(\"something went wrong\"); }\n        \n    }\n}','Concurrency',0,0,NULL,5),(795,'something went wrong\n\nyou have to always call next() before processing a rown from a result set \nthe cursors starts out as before the first row.\n\nIt is a sqlexception to try to get a row when it is before the first row.','public class Hello {\n    public static void main(String[] args){\n        try {\n            Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\");\n            Statement st = conn.createStatement();\n            String update = \"Select first_name from employees\";\n            boolean b = st.execute(update);\n            if(b){\n                //ResultSet res = update.getResultSet();\n                ResultSet res = st.getResultSet();\n                System.out.println(res.getString(\"first_name\"));\n            } else {\n                int numrows = st.getUpdateCount();\n                if(numrows == -1){\n                    System.out.println(\"No Results\");\n                }\n            }\n            \n            \n        } catch(SQLException e){System.out.println(\"something went wrong\"); }\n        \n    }\n}','Concurrency',0,0,NULL,5),(796,'Big John','public class Hello {\n    public static void main(String[] args){\n        try {\n            Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\");\n            Statement st = conn.createStatement();\n            String update = \"Select first_name from employees\";\n            boolean b = st.execute(update);\n            if(b){\n                //ResultSet res = update.getResultSet();\n                ResultSet res = st.getResultSet();\n                res.next();\n                System.out.println(res.getString(\"first_name\"));\n            } else {\n                int numrows = st.getUpdateCount();\n                if(numrows == -1){\n                    System.out.println(\"No Results\");\n                }\n            }\n            \n            \n        } catch(SQLException e){System.out.println(\"something went wrong\"); }\n        \n    }\n}\n','Concurrency',0,0,NULL,5),(797,'SQLException invalid value for getInt()\n\nyour sql query only selected the firstnames, there are no other coluns to get\ninfo from. ','ublic class Hello {\n    public static void main(String[] args){\n        try {\n            Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\");\n            Statement st = conn.createStatement();\n            String update = \"Select first_name from employees\";\n            boolean b = st.execute(update);\n            if(b){\n                ResultSet res = st.getResultSet();\n                res.next();\n                System.out.println(res.getInt(1));\n                System.out.println(res.getDate(2));\n                System.out.println(res.getString(3));\n                \n            } else {\n                int numrows = st.getUpdateCount();\n                if(numrows == -1){\n                    System.out.println(\"No Results\");\n                }\n            }\n            \n            \n        } catch(SQLException e){System.out.println(e); }\n        \n    }\n}','JDBC',0,0,NULL,5),(798,'run:\n10001\n1953-09-02\nBig John\nBUILD SUCCESSFUL (total time: 1 second)\n','public class Hello {\n    public static void main(String[] args){\n        try {\n            Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\");\n            Statement st = conn.createStatement();\n            String update = \"Select * from employees\";\n            boolean b = st.execute(update);\n            if(b){\n                ResultSet res = st.getResultSet();\n                res.next();\n                System.out.println(res.getInt(1));\n                System.out.println(res.getDate(2));\n                System.out.println(res.getString(3));\n                \n            } else {\n                int numrows = st.getUpdateCount();\n                if(numrows == -1){\n                    System.out.println(\"No Results\");\n                }\n            }\n            \n            \n        } catch(SQLException e){System.out.println(e); }\n        \n    }\n}','JDBC',0,0,NULL,5),(799,'sql exception index out of range,\n\nindexs range from 1 to the size','public class Hello {\n    public static void main(String[] args){\n        try {\n            Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\");\n            Statement st = conn.createStatement();\n            String update = \"Select * from employees\";\n            boolean b = st.execute(update);\n            if(b){\n                ResultSet res = st.getResultSet();\n                res.next();\n                System.out.println(res.getInt(0));\n                System.out.println(res.getDate(1));\n                System.out.println(res.getString(2));\n                \n            } else {\n                int numrows = st.getUpdateCount();\n                if(numrows == -1){\n                    System.out.println(\"No Results\");\n                }\n            }\n            \n            \n        } catch(SQLException e){System.out.println(e); }\n        \n    }\n}','JDBC',0,0,NULL,5),(800,'sqlexception, next() was not called before processing a result set','public class Hello {\n    public static void main(String[] args){\n        try {\n            Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\");\n            Statement st = conn.createStatement();\n            String update = \"Select * from employees\";\n            boolean b = st.execute(update);\n            if(b){\n                ResultSet res = st.getResultSet();\n                System.out.println(res.getInt(1));\n                System.out.println(res.getDate(2));\n                System.out.println(res.getString(3));\n                \n            } else {\n                int numrows = st.getUpdateCount();\n                if(numrows == -1){\n                    System.out.println(\"No Results\");\n                }\n            }\n            \n            \n        } catch(SQLException e){System.out.println(e); }\n        \n    }\n}\n','JDBC',0,0,NULL,5),(801,'sql Date stores in the form yyyy mm dd','java.sql.Date extends java.util.Date\n\nwhats the main difference\n\njava.sql.Date pubDate = rs.getDate(\"PubDate\");','JDBC',0,0,NULL,5),(802,'\"hh:mm:ss\"','java.sql.Time time = rs.getTime(\"FinishTime\");\n\nwhat form does this kind of Time take ?','JDBC',0,0,NULL,5),(803,'','use getObject for a general purpose get()\n\njdbc will return a wrapper for the appropriate sql type.\n\nso a sql int would return integer\n\nObject o = rs.getObject(\"AuthorID\");\nif( o instanceof Integer){\n	//do\n}','JDBC',0,0,NULL,5),(804,'String query = \"  \";\nResultSet res = stmt.executeQuery(query);\nReslutSetMetaData rsmd = rs.getMetaData();\nrs.next();\nint colCount = rsmd.getColumnCount();','How can you figure out the number of columns in a ResultSet ?','JDBC',0,0,NULL,5),(805,'employees\nemp_no\n11\nemployees\nbirth_date\n10\nemployees\nfirst_name\n14\nemployees\nlast_name\n16\nemployees\ngender\n1\nemployees\nhire_date\n10','public class Hello {\n    public static void main(String[] args){\n        try {\n            Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\");\n            Statement st = conn.createStatement();\n            String q = \"Select * from employees\";\n            \n            ResultSet rs = st.executeQuery(q);\n            ResultSetMetaData rmd = rs.getMetaData();\n            int cols = rmd.getColumnCount();\n            \n            for(int i = 1; i <= cols; i++){\n                System.out.println(rmd.getTableName(i));\n                System.out.println(rmd.getColumnName(i));\n                System.out.println(rmd.getColumnDisplaySize(i));\n            } \n        } catch(SQLException e){System.out.println(e); }\n        \n    }\n}','JDBC',0,0,NULL,5),(806,'First entry:\nMicheal Boyd\nLast entry:\nKenroku Malabarba\nrow: 20\nKyoichi Maliniak\nrow: 30\nGuoxiang Nooteboom','public class Hello {\n    public static void main(String[] args){\n        try {\n            Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\");\n            Statement st = conn.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE,ResultSet.CONCUR_READ_ONLY);\n            String q = \"Select * From employees limit 100\";\n            ResultSet rs = st.executeQuery(q);\n            \n            rs.first();\n            System.out.println(\"First entry:\");\n            System.out.println(rs.getString(\"first_name\") + \" \" +rs.getString(\"last_name\"));\n            \n            rs.last();\n            System.out.println(\"Last entry:\");\n            System.out.println(rs.getString(\"first_name\") + \" \" +rs.getString(\"last_name\"));\n            \n            rs.absolute(20);\n            System.out.println(\"row: \"+ rs.getRow());\n            System.out.println(rs.getString(\"first_name\") + \" \" +rs.getString(\"last_name\"));\n            \n            rs.relative(10);\n            System.out.println(\"row: \"+ rs.getRow());\n            System.out.println(rs.getString(\"first_name\") + \" \" +rs.getString(\"last_name\"));  \n        } catch(SQLException e){System.out.println(e); }\n        \n    }\n}','JDBC',0,0,NULL,5),(807,'true','Once created you cannot change the concurrency or Cursor type of an existing\nstatement object.','JDBC',0,0,NULL,5),(808,'','if cursor or concurrency settings are not supported then the driver will show\na warning and silently revert to default settings. ','JDBC',0,0,NULL,5),(809,'what is b? :8\n','public class Hello {\n    public static void main(String[] args){\n       int a = 8;\n        System.out.println(\"what is b? :\"+a++);\n    }\n}','JDBC',0,0,NULL,5),(810,'method local inner classes cannot access non final local variables,\n\nalso method local classes are just like local variables they cannot be \n	static private public protected or anything else','public class Hello {\n   \n    public static void main(String[] args) {\n        Hello h = new Hello();\n        h.methodlocal();\n    }\n    \n    public void methodlocal(){\n        int y = 56;\n        \n        private class Zombie {\n            public int size;\n        \n            public Zombie(int x){ size = x;}\n            public void mone(){\n                System.out.println(\"ughhhg: \"+ size);\n            }\n            \n            public void accessTheLiving(){\n                System.out.println(\"local var: \"+y);\n            }\n            \n        }\n        \n        Zombie zom = new Zombie(7);\n        \n    }\n\n}','JDBC',1,0,NULL,5),(811,'compiles fine','public class Hello {\n    public static void main(String[] args){\n        List<Animal> animals = new ArrayList<Animal>();\n        animals.add(new Dog());\n        animals.add(new Animal());\n    }\n    public static void addAnimal(List<Object> animals) {\n	animals.add(new Dog());\n    }\n}\n\nclass Dog extends Animal {}\nclass Animal { }','JDBC',0,0,NULL,5),(812,'will not compile, \n\nfirst you cant add to a collection defined with ? extends. \n\nsecond, since dest is defined with ? super it is saying that that collection\ncan be of any type of super class of G,thouhg you can still add only G. \n\nTherefore the iterator will return objects not Gs.\n\nYou are taking from dest and adding to src. dest is the producer and src is the\nconsumer. Producers extend Consumers Super. ITs backward here. ','public class Hello<T> {\n    \n    public static void main(String[] args){\n        ArrayList<Beagle> a = new ArrayList<>();\n        ArrayList<Animal> b = new ArrayList<>();\n        \n        Hello<String> x = new Hello<>();\n        \n        \n        \n        x.copyColl(a,b);\n        \n\n    } \n    public <G extends Being> void copyColl(Collection<? extends G> src, Collection<? super G> dest){\n        \n        for(G n : dest)\n            src.add(n);\n        \n    }\n}\n\nclass Beagle extends Animal { }\nclass Animal extends Being {} \nclass Being { }','Collections',0,0,NULL,5),(813,'will not compile redwolf does not extend beagle','public class Hello<T> {\n    \n    public static void main(String[] args){\n        ArrayList<RedWolf> a = new ArrayList<>();\n        ArrayList<Animal> b = new ArrayList<>();\n        \n        Hello<String> x = new Hello<>();\n        \n        \n        \n        x.copyColl(a,b);\n        \n\n    } \n    public <G extends Beagle> void copyColl(Collection<? extends G> src, Collection<? super G> dest){\n        \n        for(G g : src)\n            dest.add(g);\n        \n    }\n}\n\n\nclass GoodBeagles extends Beagle { }\nclass Beagle extends Animal { }\nclass Animal extends Being {} \nclass Being { }\nclass Wolf { } \nclass RedWolf{ }','Collections',0,0,NULL,5),(814,'shows the number of rows ','public class Hello {\n    public static void main(String[] dicks){\n         try {\n            Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\");\n            Statement st = conn.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_UPDATABLE);\n            String q = \"Select * from employees\";\n            ResultSet rs = st.executeQuery(q);\n            \n            if(rs.last()){\n               int rowCount = rs.getRow();\n               rs.beforeFirst();\n                System.out.println(rowCount);\n            }\n            \n            \n        } catch(SQLException e){System.out.println(e); }\n    }\n}','Collections',0,0,NULL,5),(815,'91\n\nif absolute takes a - number it starts from the last row and works backward. \n\nreturns false if the cursor is beyond the lst row or beffore the first','public class Hello {\n    public static void main(String[] dicks){\n         try {\n            Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\");\n            Statement st = conn.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_UPDATABLE);\n            String q = \"Select * from employees limit 100\";\n            ResultSet rs = st.executeQuery(q);\n            rs.absolute(-10);\n             System.out.println(rs.getRow()); \n        } catch(SQLException e){System.out.println(e); }\n    }\n}','Collections',0,0,NULL,5),(816,'Sachin Tsukuda','public class Hello extends Thread {\n    public static void main(String[] args){\n        try(Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees\", \"root\", \"Basketball12\")){\n            String getAllEmployeeNames = \"select first_name,last_name from employees\";\n            Statement st1 = conn.createStatement();\n            \n            ResultSet empnames = st1.executeQuery(getAllEmployeeNames);\n            \n            empnames.last();\n            \n            System.out.println(empnames.getString(\"first_name\")+\" \"+empnames.getString(\"last_name\"));\n            \n        }catch(SQLException e){\n            System.out.println(e);\n        }\n    }\n}','JDBC',0,0,NULL,5),(817,'0','public class Hello {\n    public static void main(String[] dicks){\n         try {\n            Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\");\n            Statement st = conn.createStatement(ResultSet.TYPE_FORWARD_ONLY,ResultSet.CONCUR_UPDATABLE);\n            String q = \"Select * from employees limit 100\";\n            ResultSet rs = st.executeQuery(q);\n            System.out.println(rs.getRow()); \n        } catch(SQLException e){System.out.println(e); }\n    }\n}','JDBC',0,0,NULL,5),(818,'also 0','public class Hello {\n    public static void main(String[] dicks){\n         try {\n            Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\");\n            Statement st = conn.createStatement(ResultSet.TYPE_FORWARD_ONLY,ResultSet.CONCUR_UPDATABLE);\n            String q = \"Select * from employees limit 100\";\n            ResultSet rs = st.executeQuery(q);\n            rs.afterLast();\n            System.out.println(rs.getRow()); \n        } catch(SQLException e){System.out.println(e); }\n    }\n}','JDBC',0,0,NULL,5),(819,'run:\n0\njava.sql.SQLException: No operations allowed after statement closed.\nBUILD SUCCESSFUL (total time: 0 seconds)\n\nit is not an exception to call getRow after the last row or before the first.\nit will simply give zero. \n','public class Hello {\n    public static void main(String[] dicks){\n         try {\n            Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\");\n            Statement st = conn.createStatement(ResultSet.TYPE_FORWARD_ONLY,ResultSet.CONCUR_UPDATABLE);\n            String q = \"Select * from employees limit 100\";\n            String q2 = \"Select * from salaries limit 100\";\n            ResultSet rs = st.executeQuery(q);\n            rs.afterLast();\n            System.out.println(rs.getRow()); \n            conn.close();\n            rs = st.executeQuery(q2);\n            while(rs.next()){\n                System.out.println(rs.getInt(\"salary\"));\n            }\n        } catch(SQLException e){System.out.println(e); }\n    }\n}','JDBC',0,0,NULL,5),(820,'0','public class Hello {\n    public static void main(String[] dicks){\n         try(Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\");\n            Statement st = conn.createStatement(ResultSet.TYPE_FORWARD_ONLY,ResultSet.CONCUR_UPDATABLE);) {\n            String q = \"Select * from employees limit 100\";\n            String q2 = \"Select * from salaries limit 100\";\n            ResultSet rs = st.executeQuery(q);\n            rs.afterLast();\n            System.out.println(rs.getRow()); \n        } catch(SQLException e){System.out.println(e); }\n    }\n}','JDBC',0,0,NULL,5),(821,'Class.forName(\"org.abc.mmmysql.Driver\");','String url = \"   \";\nString user = \"  \";\nString pwd = \"    \";\n\n// insert here\nConnection conn = DriverManaget.getConnection(url,user,pwd);\n\nwhat would you use to load a JDBC 3.0 driver class','JDBC',0,0,NULL,5),(822,'Must include a MEAT-INF file, this allows the driver to autoload.\n\nMust provide implementations of Driver, Connection, Statement, ResultSet\ninterfaces\n\nMust support transactions\n\n','What does it take for a driver to be jdbc 4.0 compliant ?	','JDBC',0,0,NULL,5),(823,'3\n4\n6','What three are availabe through an instance of DatabaseMetaData ?\n\n1 number of columns returned\n2 number of rows returned\n3 name of jdbc driver\n4 default transaciton isolation level\n5 last query used\n6 names of stored procedures\n7 current Savepoint name','JDBC',0,0,NULL,5),(824,'SQLException, next() wass not called the cursors starts of pointing to BEFORE\nthe first row. ','try {\n	Statement st = conn.createStatement();\n	String query = \"Select * From Author Where LastName Like \'Rand%\'\";\n	Resultset rs = st.executeQuery(query);\n	if(rs == null) {\n		sout( \"no results\" );\n	} else {\n		sout(rs.getString(\"FirstName\");\n	}\n} catch(SQLException se) {\n	sout(\"SQLException\");\n}','JDBC',0,0,NULL,5),(825,'SQLException\n\nexecuteQuery cannot be used to execute update insrt delete or ddl statements \nor it will throw a sqlexception. \n','public class Hello {\n    public static void main(String[] dicks){\n         try(Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employee?useSSL=false\", \"root\", \"Basketball12\")){\n             String query = \"Update employees set first_name = \'Hefty\' where emp_no = 10001\"; \n             Statement st = conn.createStatement();\n             st.executeQuery(query);\n         } catch(SQLException e){\n             System.out.println(\"SQLException\");\n         }\n    }\n \n}','JDBC',0,0,NULL,5),(826,'SQLException\n\ntrying to access a closed ResultSet. ','try {\n	ResultSet rs = null;\n	try (Statement st = conn.createStatement()) {\n		String query = \"Select * From Customer\";\n		rs = st.executeQuery(query);\n	} catch(SQLException se) {\n		sout(\"Illegal query\");	\n	}\n\n	while (rs.next()) {\n		//process customers \n	}\n} catch(SQLException e) {\n	sout(\"SQLException\");\n}','JDBC',0,0,NULL,5),(827,'these would all produce their indicated rsults, update will produce and update count\neven if no rows are affected','Statement st = conn.createStatement();\nResultSet rs;\nString query = \"<QUERY HERE>\";\nst.execute(query);\nif ((Rs = st.getResultSet()) != null) {\n	sout(\"Results\");\n}\nif (st.getUpdateCount() > -1) {\n	sout(\"update\");\n}\n\nSelect * from customer\ninsert into ...\nupdate...\ndelete...','JDBC',0,0,NULL,5),(828,'exception\n\nparameters are numbered starting from 1 not 0.','String q = \"update customer set Last_name = ? Where Customer_id = ?\";\ntry {\n	PreparedStatement pt = conn.prepareStatement(q);\n	pt.setString(0,\"Smith\");\n	pt.setString(1,\"5001\");\n	int result = pt.executeUpdate();\n	if(result != 1) sout(\"error\");\n} catch(SQLException e) {\n	sout(\"Exception\");\n}','JDBC',0,0,NULL,5),(829,'yes yes sqlexception everything is smooth on the first iteration, but \nthe second the preparedstatement index paramenters will be 3 and 4 when there\nare only two parameters, this will cause the exc.','try {\n	String[] searchPair = {\"%a%\", \"%b%\",\"%c%\",\"%d%\" };\n	String query = \"Sleect ... ? ... ?\";\n	PreparedStatement pt = conn.PrepareStatement(query);\n	for(int i = 0; i < searchPair.length; i+=2) {\n		pt.setString(i+1, searchPAir[i]);\n		pt.setString(i+2, searchPair[i++]);\n		ResultSet rs = pt.executeQuery();\n		while(rs.next()) {\n			sout(\"yes\");\n		}\n	}\n} catch(Sqlexcepiton ee) {\n	sout	(\"SQLException\");\n}\n			','JDBC',0,0,NULL,5),(830,'Collections of type ? can be assigned to by any type of list but cannot be\nadded to. ','public class Hello {\n    public static void main(String[] dicks){\n         List<?> list = new ArrayList<Dog>();\n         list.add(new Dog());\n         list.add(new Dog());\n         list.add(new Dog());\n    }\n \n}\n\nclass Dog {\n    \n}','Collections',0,0,NULL,5),(831,'will not compile, object cannot be converted to Dog.\nThe objects comming out of a List<?> are Objects.','public class Hello {\n    public static void main(String[] dicks){\n         List<Dog> Doglist = new ArrayList<Dog>();\n         Doglist.add(new Dog(\"Charly\"));\n         Doglist.add(new Dog(\"Baily\"));\n         Doglist.add(new Dog(\"Wiley\"));\n         \n         List<?> unmodifiableDogList = Doglist;\n         \n         for(Dog d : unmodifiableDogList){\n             System.out.println(d.getName());\n         }\n    }\n \n}\n\nclass Dog {\n    private String name;\n    public Dog(String s ){\n        name = s;\n    }\n    \n    public String getName(){\n        return name;\n    }\n    \n}','Collections',0,0,NULL,5),(832,'althought the base type here is ArrayList Doglist is defined as a list \nso it cannot be assigned to an ArrayList ','public class Hello {\n    public static void main(String[] dicks){\n         List<Dog> Doglist = new ArrayList<Dog>();\n         Doglist.add(new Dog(\"Charly\"));\n         Doglist.add(new Dog(\"Baily\"));\n         Doglist.add(new Dog(\"Wiley\"));\n         \n         ArrayList<?> unmodifiableDogList = Doglist;\n         \n         for(Object d : unmodifiableDogList){\n             System.out.println(d.getName());\n         }\n    }\n \n}\n\nclass Dog {\n    private String name;\n    public Dog(String s ){\n        name = s;\n    }\n    \n    public String getName(){\n        return name;\n    }\n    \n}','Collections',0,0,NULL,5),(833,'compiles fine the reference type is still defined as a raw type','public class Hello<T> {\n    public static void main(String[] args){\n        \n        Dog d = new Dog();\n        \n        ArrayList x = makeArrayList(d);\n        \n        ArrayList c = new ArrayList<String>();\n        c.add(new Dog());\n        c.add(90);\n\n    } \n    public static <G> ArrayList<G> makeArrayList(G g){\n        ArrayList<G> genlist = new ArrayList();\n        genlist.add(g);\n        return genlist;\n        \n    }\n}\n\nclass Dog {\n    \n}','Collections',0,0,NULL,5),(834,'will not compile, all those methods throw IOExceptions','public class Hello {\n    public static void main(String[] args){\n       File file1 = new File(\"~/Public/TestDir/file1\");\n       File file2 = new File(\"~/Public/TestDir/file2\");\n       File dir = new File(\"~/Public/TestDir\");\n       \n       if(dir.exists() && dir.isDirectory()){\n           file1.createNewFile();\n           file2.createNewFile();\n       } else {\n           dir.mkdir();\n           file1.createNewFile();\n           file2.createNewFile();\n       }\n    } \n}','IO',1,0,NULL,5),(835,'fine','public class Hello<T> {\n    \n    public static void main(String[] args){\n        \n        Dog d = new Dog();\n        \n        ArrayList<? extends Dog> c = new ArrayList<Beagle>();\n        Animal a = c.get(0);\n    } \n}\n\nclass Animal{}\nclass Dog extends Animal { }\nclass Beagle extends Dog { }','Generics',0,0,NULL,5),(836,'will not compile wrong number of type arguments, \nthis is a generic method, \n\nit should be <? extends Animal>','public class Hello<T> {\n    \n    public static void main(String[] args){\n        ArrayList<Animal> a;\n        ArrayList<Beagle> b;\n        \n        Hello<String> x = new Hello<>();\n        \n        x.copyColl(a,b);\n        \n\n    } \n    public <G> void copyColl(Collection<G extends Animal> src, Collection<G> dest){\n        \n        for(G n : src)\n            dest.add(n);\n        \n    }\n}\n\nclass Animal{}\nclass Dog extends Animal { }\nclass Beagle extends Dog { }','Generics',0,0,NULL,5),(837,'in java 7 and beyond the compiler can infer the type from the return type !','public class Hello<T> {\n    \n    public static void main(String[] args) {\n        Cat cat = parse(\"cat\");\n        Dog dog = parse(\"dog\");\n        System.out.println(\"the cat object is a \" + cat);\n        System.out.println(\"the dog object is a \" + dog);\n    }\n\n    private static class Dog {\n        public String toString() { return \"dog\"; }\n    }\n\n    private static class Cat {\n        public String toString() { return \"cat\"; }\n    }\n\n    private static Object untypedParse(String stringToParse) {\n        if(stringToParse.equals(\"dog\")) {\n            return new Dog();\n        } else if(stringToParse.equals(\"cat\")) {\n            return new Cat();\n        } else {\n            throw new RuntimeException(\"not expected\");\n        }\n    }\n\n    public static <T> T parse(String stringToParse) {\n        return (T)untypedParse(stringToParse);\n    }\n\n}','Generics',0,0,NULL,5),(838,'First it should be: public static <T> T fromXML<T>(String xml)\n\nIn Java, generics are compile-time only data, which are lost at run time. \nSo, if you called a method like that, the JVM would have no way of knowing what T.class was. \nThe normal way to get around this is to pass a class instance object as a parameter to the method, \nlike this:\n\npublic static <T> T fromXml(Class<T> clazz, String xml) {\n  try {\n    JAXBContext context = JAXBContext.newInstance(clazz);\n    Unmarshaller um = context.createUnmarshaller();\n    return (T)um.unmarshal(new StringReader(xml));\n  } catch (JAXBException je) {\n    throw new RuntimeException(\"Error interpreting XML response\", je);\n  }\n}\n\nfromXml(SomeSubObject.class, \"<xml/>\");\n\n','//How to fix this\npublic static T fromXml<T>(String xml) {\n  try {\n    JAXBContext context = JAXBContext.newInstance(T.class);\n    Unmarshaller um = context.createUnmarshaller();\n    return (T)um.unmarshal(new StringReader(xml));\n  } catch (JAXBException je) {\n    throw new RuntimeException(\"Error interpreting XML response\", je);\n  }\n}\n\n//Also the call doesn\'t work...\nfromXml<SomeSubObject>(\"<xml/>\");','Generics',0,0,NULL,5),(839,'java.sql.SQLException: Parameter index out of range (4 > number of parameters, which is 3).','public class Hello<T> {\n    \n    public static void main(String[] args){\n        try (Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\")){\n            String prepInsert = \"Insert into employees values(?,\'1962-11-07\',?,?,\'F\',\'1962-11-07\')\";\n            PreparedStatement ps = conn.prepareStatement(prepInsert,ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_UPDATABLE);\n            ps.setInt(1,555);\n            ps.setString(3,\"Angela\");\n            ps.setString(4,\"Horton\");\n            \n            int rowsupdated = ps.executeUpdate();\n            \n            System.out.println(rowsupdated);\n\n        }catch(Exception e){\n            System.out.println(e);\n            \n        }\n        \n    }\n}','JDBC',0,0,NULL,5),(840,'1\n1\n\nyou can use a prepared statement multiple times','public class Hello<T> {\n    \n    public static void main(String[] args){\n        try (Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\")){\n            String prepInsert = \"Insert into employees values(?,\'1962-11-07\',?,?,\'F\',\'1962-11-07\')\";\n            PreparedStatement ps = conn.prepareStatement(prepInsert,ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_UPDATABLE);\n            ps.setInt(1,556);\n            ps.setString(2,\"Angela\");\n            ps.setString(3,\"Horton2\");\n            \n            int rowsupdated = ps.executeUpdate();\n            System.out.println(rowsupdated);\n            \n            ps.setInt(1,666);\n            ps.setString(2,\"MAX\");\n            ps.setString(3,\"AMILLION\");\n            \n            rowsupdated = ps.executeUpdate();\n            \n            System.out.println(rowsupdated);\n\n        }catch(Exception e){\n            System.out.println(e);\n            \n        }\n        \n    }\n}','JDBC',0,0,NULL,5),(841,'Angela 555','public class Hello<T> {\n    \n    public static void main(String[] args){\n        try (Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\")){\n            String prepInsert = \"Select * from employees where first_name = ? OR last_name = ?\";\n            PreparedStatement ps = conn.prepareStatement(prepInsert,ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_UPDATABLE);\n            ps.setString(1,\"Georgi\");\n            ps.setString(2,\"Horton\");\n            \n            ResultSet rs = ps.executeQuery();\n            \n            while(rs.next()){\n                System.out.println(rs.getString(\"first_name\")+\" \"+rs.getString(\"emp_no\"));\n            }\n        }catch(Exception e){\n            System.out.println(e);           \n        }\n    }\n}','JDBC',0,0,NULL,5),(842,'com.mysql.jdbc.exceptions.jdbc4.MySQLSyntaxErrorException: You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near \'? OR last_name = ?\' at line 1\n\npreparedstatement execute query does not take a String parameter, it already\nknows the query to execute. ','public class Hello<T> {\n    \n    public static void main(String[] args){\n        try (Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\")){\n            String prepInsert = \"Select * from employees where first_name = ? OR last_name = ?\";\n            PreparedStatement ps = conn.prepareStatement(prepInsert,ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_UPDATABLE);\n            ps.setString(1,\"Georgi\");\n            ps.setString(2,\"Horton\");\n            \n            ResultSet rs = ps.executeQuery(prepInsert);\n            \n            while(rs.next()){\n                System.out.println(rs.getString(\"first_name\")+\" \"+rs.getString(\"emp_no\"));\n            }\n        }catch(Exception e){\n            System.out.println(e);           \n        }\n    }\n}','JDBC',0,0,NULL,5),(843,'calls the stored proceudre getBooksInDateRange','int customerID = 5001;\njava.sql.Date fromDate = ...;\njava.sql.Date toDate = ...;\nString getBooksInDateRange = \"{call getBooksDateRange(?,?,?)}\";\n\nCallableStatement cstmt = conn.prepareCall(getBooksInDateRange,ResultSet.TYPE_SCROLL_INSESNSITIVE,ResultSet.CONCUR_UPDATABLE);\n\ncstmt.setInt(1,customerID);\ncstmt.setDate(2,fromDate);\ncstmt.setDate(3,toDate);\nResultSet rs = cstmt.executeQuery();\n\n\n','JDBC',0,0,NULL,5),(844,'to use a stored procedure you have to register the out parameter \nfirst. As shown here. ','int customerID = 5001;\njava.sql.Date fromDate = ...;\njava.sql.Date toDate = ...;\nString getBooksInDateRange = \"{? =call customerTotal (?)}\";\n\nCallableStatement cstmt = conn.prepareCall(getBooksInDateRange,ResultSet.TYPE_SCROLL_INSESNSITIVE,ResultSet.CONCUR_UPDATABLE);\n\ncstmt.registerOutParameter(1,java.sql.Types.DOUBLE);\n\ncstmt.setInt(2,customerID);\n\ncstmt.execute(); // not returning a resultset\n\nint total = cstmt.getDouble(1);\n','JDBC',0,0,NULL,5),(845,'sqlexception execute doesn\'t take a parameter','int customerID = 5001;\njava.sql.Date fromDate = ...;\njava.sql.Date toDate = ...;\nString getBooksInDateRange = \"{? =call customerTotal (?)}\";\n\nCallableStatement cstmt = conn.prepareCall(getBooksInDateRange,ResultSet.TYPE_SCROLL_INSESNSITIVE,ResultSet.CONCUR_UPDATABLE);\n\ncstmt.registerOutParameter(1,java.sql.Types.DOUBLE);\n\ncstmt.setInt(2,customerID);\n\ncstmt.execute(getBookInDateRange); // not returning a resultset\n\nint total = cstmt.getDouble(1);\n                                  ','JDBC',0,0,NULL,5),(846,'registers an INOUT parameter','int customerID = 5001;\nint numberOfOrders;\nCallableStatement ct = conn.prepareCall(\"{call customerOrderCount (?) }\");\nct.setInt(1,customerID);\nct.registerOutParameter(1.java.sql.Types.INTEGER);  // the out\n\nct.execute();\n\nint numberoforders = ct.getInt(1);','JDBC',0,0,NULL,5),(847,'storedprocedures is code thta you dont have insight to and if you invoke executeQuery()\non a procedure that doesn\'t return a result set you get a sqlException\n\nso its best to use execute()','int customerID = 5001;\nint numberOfOrders;\nCallableStatement ct = conn.prepareCall(\"{call customerOrderCount (?) }\");\nct.setInt(1,customerID);\nct.registerOutParameter(1.java.sql.Types.INTEGER);  // the out\n\nct.executeQuery();\n\nint numberoforders = ct.getInt(1);','JDBC',0,0,NULL,5),(848,'','int customerID = 5001;\nint numberOfOrders;\nCallableStatement ct = conn.prepareCall(\"{call customerOrderCount (?) }\");\nct.setInt(1,customerID);\nct.registerOutParameter(1.java.sql.Types.INTEGER);  // the out\n\nct.execute();\n\nint numberoforders = ct.getInt(1);\n\nif(ct.getMoreResults()) // returns true if there is a resultset to get. ','JDBC',0,0,NULL,5),(849,'','RowSetFactory rsf = RowSetProvider.newFactory();\nJdbcRowSet jrs = rsf.createJdbcRowSet();\n// Provider returns a facotry that will create Rowset objects from\n// the reference implementation\n\n//with the factory it is easy to swap out the implementation\n\nRowSetFactorys rsf2 = RowSetProvider.newFactory(\"com.example.MyRowSetProvider\",null);\nJdbcRowSet jrs = rsf.createJdbcRowSet();','JDBC',0,0,NULL,5),(850,'prints the first 100 employees\' full names\n\nyou construct a JdbcRowSet from a RowSetProvider.newFactory().createJdbcRowSet();\n\ninstead of statement conncection and resultSet you use RowSet commands\nto set the uname, pw and url. \n\nthen simply execute it. ','public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n        try(JdbcRowSet jrs = RowSetProvider.newFactory().createJdbcRowSet()){\n            String query = \"Select * from employees limit 100\";\n            jrs.setCommand(query);\n            jrs.setUrl(url);\n            jrs.setUsername(user);\n            jrs.setPassword(pw);\n            jrs.execute();\n            while(jrs.next()){\n                System.out.println(jrs.getString(\"first_name\") + \" \" + jrs.getString(\"last_name\"));\n            }    \n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n}','JDBC',0,0,NULL,5),(851,'will not compile the proper way to create a JdbcRowSet is\n\n	JdbcRowSet jrs = RowSetProvider.newFactory().createJdbcRowSet()','public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n        try(JdbcRowSet jrs = RowSetProvider.createJdbcRowSet()){\n            String query = \"Select * from employees limit 100\";\n            jrs.setCommand(query);\n            jrs.setUrl(url);\n            jrs.setUsername(user);\n            jrs.setPassword(pw);\n            jrs.execute();\n            while(jrs.next()){\n                System.out.println(jrs.getString(\"first_name\") + \" \" + jrs.getString(\"last_name\"));\n            }    \n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n}','JDBC',0,0,NULL,5),(852,'Will not compil creating a JdbcRowSet throws an sql exception so it is usually\ncreated in a try() - catch block, \n\nNot to mention every other of those commands throws an sqlexception','public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n            JdbcRowSet jrs = RowSetProvider.newFactory().createJdbcRowSet();\n            String query = \"Select * from employees limit 100\";\n            jrs.setCommand(query);\n            jrs.setUrl(url);\n            jrs.setUsername(user);\n            jrs.setPassword(pw);\n            jrs.execute();\n            while(jrs.next()){\n                System.out.println(jrs.getString(\"first_name\") + \" \" + jrs.getString(\"last_name\"));\n            }    \n    }\n}','JDBC',0,0,NULL,5),(853,'NullPointerException, the username and password and url were not set, \n\nIT could Also throw an sqlexception for this,\n\nexecute fills the rowset with data. Just alswyas make sure that data is set.','public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n        try(JdbcRowSet jrs = RowSetProvider.newFactory().createJdbcRowSet()){\n            String query = \"Select * from employee limit 100\";\n            jrs.setCommand(query);\n            jrs.execute();\n            while(jrs.next()){\n                System.out.println(jrs.getString(\"first_name\") + \" \" + jrs.getString(\"last_name\"));\n            }    \n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n}','JDBC',0,0,NULL,5),(854,'RowSet extends Result set so it is a result set\n\nseting the type still uses the resultset types. ','public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n        try(JdbcRowSet jrs = RowSetProvider.newFactory().createJdbcRowSet()){\n            String query = \"Select * from employees limit 100\";\n            jrs.setCommand(query);\n            jrs.setUrl(url);\n            jrs.setUsername(user);\n            jrs.setPassword(pw);\n            jrs.setType(ResultSet.TYPE_SCROLL_INSENSITIVE);\n            jrs.execute();\n            while(jrs.next()){\n                System.out.println(jrs.getString(\"first_name\") + \" \" + jrs.getString(\"last_name\"));\n            }    \n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n}','JDBC',0,0,NULL,5),(855,'will not compile,\n\nResultSet.TYPE_SCROLL_INSENSITIVE\n\nThose fields are inherited from ResultSet. \n\nFields inherited from interface java.sql.ResultSet\nCONCUR_READ_ONLY, \nCONCUR_UPDATABLE, \nTYPE_FORWARD_ONLY, \nTYPE_SCROLL_INSENSITIVE, \nTYPE_SCROLL_SENSITIVE','public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n        try(JdbcRowSet jrs = RowSetProvider.newFactory().createJdbcRowSet()){\n            String query = \"Select * from employees limit 100\";\n            jrs.setCommand(query);\n            jrs.setUrl(url);\n            jrs.setUsername(user);\n            jrs.setPassword(pw);\n            jrs.setType(RowSet.TYPE_SCROLL_INSENSITIVE);\n            jrs.execute();\n            while(jrs.next()){\n                System.out.println(jrs.getString(\"first_name\") + \" \" + jrs.getString(\"last_name\"));\n            }    \n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n}','JDBC',0,0,NULL,5),(856,'SQLException, you cannot Update insert or delete with execute() on a RowSet.\n\nto update the data you just update the data on your JdbcRowSet.\n\nthere are no executeQuery() or executeUpdate methods for RowSets. ','public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n        try(JdbcRowSet jrs = RowSetProvider.newFactory().createJdbcRowSet()){\n            String query = \"Update employees set first_name = \'Mike\' where emp_no = 789\";\n            jrs.setCommand(query);\n            jrs.setUrl(url);\n            jrs.setUsername(user);\n            jrs.setPassword(pw);\n            jrs.setType(ResultSet.TYPE_SCROLL_INSENSITIVE);\n            jrs.execute();\n            while(jrs.next()){\n                System.out.println(jrs.getString(\"first_name\") + \" \" + jrs.getString(\"last_name\"));\n            }    \n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n}','JDBC',0,0,NULL,5),(857,'will not compile there is no executeUpdate() for RowSets,\nbecause you do not update insert or delete in this way. You use the update api.\n\nThis would be a sql exception anyway because you cannot perform update \ninsert or deletes with a sql command and a jdbc rowset.','public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n        try(JdbcRowSet jrs = RowSetProvider.newFactory().createJdbcRowSet()){\n            String query = \"Update employees set first_name = \'Mike\' where emp_no = 789\";\n            jrs.setCommand(query);\n            jrs.setUrl(url);\n            jrs.setUsername(user);\n            jrs.setPassword(pw);\n            jrs.setType(ResultSet.TYPE_SCROLL_INSENSITIVE);\n            jrs.executeUpdate();\n            while(jrs.next()){\n                System.out.println(jrs.getString(\"first_name\") + \" \" + jrs.getString(\"last_name\"));\n            }    \n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n}','JDBC',0,0,NULL,5),(858,'will not compiles there is no executeQuery() with Jdbcrowsets. The Command is \nexecute()','public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n        try(JdbcRowSet jrs = RowSetProvider.newFactory().createJdbcRowSet()){\n            String query = \"Select * from employees limit 100\";\n            jrs.setCommand(query);\n            jrs.setUrl(url);\n            jrs.setUsername(user);\n            jrs.setPassword(pw);\n            jrs.setType(ResultSet.TYPE_SCROLL_INSENSITIVE);\n            jrs.executeQuery();\n            while(jrs.next()){\n                System.out.println(jrs.getString(\"first_name\") + \" \" + jrs.getString(\"last_name\"));\n            }    \n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n}','JDBC',0,0,NULL,5),(859,'first set the user pw and url with:\n\n	       jrs.setUrl(url);\n            jrs.setUsername(user);\n            jrs.setPassword(pw);\n\nthen set the command: \n		String query = \"Select * from employees limit 100\";\n            jrs.setCommand(query);\n\nthen use the only command to execute:\n\nexecute()','How do you execute a query with a JdbcRowSet object ? ','JDBC',0,0,NULL,5),(860,'NullpointerExeption you never set the command, could be an sqlException too\n\ndont forget to:\n\nsetCommand(query);','public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n        try(JdbcRowSet jrs = RowSetProvider.newFactory().createJdbcRowSet()){\n            String query = \"Select * from employees limit 100\";\n            jrs.setUrl(url);\n            jrs.setUsername(user);\n            jrs.setPassword(pw);\n            jrs.setType(ResultSet.TYPE_SCROLL_INSENSITIVE);\n            jrs.execute();\n            while(jrs.next()){\n                System.out.println(jrs.getString(\"first_name\") + \" \" + jrs.getString(\"last_name\"));\n            }    \n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n}','JDBC',0,0,NULL,5),(861,'will not copile the method is setCommand not setQuery','public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n        try(JdbcRowSet jrs = RowSetProvider.newFactory().createJdbcRowSet()){\n            String query = \"Select * from employees limit 100\";\n            jrs.setQuery(query);\n            jrs.setUrl(url);\n            jrs.setUsername(user);\n            jrs.setPassword(pw);\n            jrs.execute();\n            while(jrs.next()){\n                System.out.println(jrs.getString(\"first_name\") + \" \" + jrs.getString(\"last_name\"));\n            }    \n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n}','JDBC',0,0,NULL,5),(862,'','You can update data in the database with a resultset but thats not on the \nexam so DONT WORRY ABOUT IT. \n\nyou can do the same with RowSet and that IS on the exam so thats what you shuld focus on','JDBC',0,0,NULL,5),(863,'change the last employees first name to \'Big Max\'','public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n        try(JdbcRowSet jrs = RowSetProvider.newFactory().createJdbcRowSet()){\n            String query = \"Select * from employees limit 100\";\n            jrs.setCommand(query);\n            jrs.setUrl(url);\n            jrs.setUsername(user);\n            jrs.setPassword(pw);\n            jrs.execute();\n            while(jrs.next()){\n                System.out.println(jrs.getString(\"first_name\") + \" \" + jrs.getString(\"last_name\"));\n            }\n            jrs.last();\n            jrs.updateString(\"first_name\",\"Big Max\");\n            jrs.updateRow();\n            \n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n}','JDBC',0,0,NULL,5),(864,'This will print nothing, the cursor is already at the last poisiton so\nthere is not next for jrs to go to to fix add \n\n	jrs.first()\n\njust before the while loop.','public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n        try(JdbcRowSet jrs = RowSetProvider.newFactory().createJdbcRowSet()){\n            String query = \"Select * from employees limit 100\";\n            jrs.setCommand(query);\n            jrs.setUrl(url);\n            jrs.setUsername(user);\n            jrs.setPassword(pw);\n            jrs.execute();\n            \n            jrs.last();\n            jrs.updateString(\"first_name\",\"Big Max\");\n            jrs.updateRow();\n\n            while(jrs.next()){\n                System.out.println(jrs.getString(\"first_name\") + \" \" + jrs.getString(\"last_name\"));\n            }\n            \n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n}','JDBC',0,0,NULL,5),(865,'will show the updated rows ','public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n        try(JdbcRowSet jrs = RowSetProvider.newFactory().createJdbcRowSet()){\n            String query = \"Select * from employees limit 100\";\n            jrs.setCommand(query);\n            jrs.setUrl(url);\n            jrs.setUsername(user);\n            jrs.setPassword(pw);\n            jrs.execute();\n            \n            jrs.last();\n            jrs.updateString(\"first_name\",\"Big Max\");\n            jrs.updateRow();\n            jrs.first();\n            while(jrs.next()){\n                System.out.println(jrs.getString(\"first_name\") + \" \" + jrs.getString(\"last_name\"));\n            }\n            \n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n}','JDBC',0,0,NULL,5),(866,'will update the first row of the RowSet and write teh changes to the database\n\nprints: Big Max Big Dick Bisesi','public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n        try(JdbcRowSet jrs = RowSetProvider.newFactory().createJdbcRowSet()){\n            String query = \"Select * from employees limit 100\";\n            jrs.setCommand(query);\n            jrs.setUrl(url);\n            jrs.setUsername(user);\n            jrs.setPassword(pw);\n            jrs.execute();\n            jrs.first();\n            jrs.updateString(\"first_name\",\"Big Max\");\n            jrs.updateString(\"last_name\",\"Big Dick Bisesi\");\n            jrs.updateRow();\n            System.out.println(jrs.getString(\"first_name\") + \" \" + jrs.getString(\"last_name\"));\n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n}','JDBC',0,0,NULL,5),(867,'SQLException: Invalid State\n\nexecute() was never used.','public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n        try(JdbcRowSet jrs = RowSetProvider.newFactory().createJdbcRowSet()){\n            String query = \"Select * from employees limit 100\";\n            jrs.setCommand(query);\n            jrs.setUrl(url);\n            jrs.setUsername(user);\n            jrs.setPassword(pw);\n            jrs.first();\n            jrs.updateString(\"first_name\",\"Big Max\");\n            jrs.updateString(\"last_name\",\"Big Dick Bisesi\");\n            jrs.updateRow();\n            System.out.println(jrs.getString(\"first_name\") + \" \" + jrs.getString(\"last_name\"));\n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n}','JDBC',0,0,NULL,5),(868,'NullPointerException the cursor is before the first row','public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n        try(JdbcRowSet jrs = RowSetProvider.newFactory().createJdbcRowSet()){\n            String query = \"Select * from employees limit 100\";\n            jrs.setCommand(query);\n            jrs.setUrl(url);\n            jrs.setUsername(user);\n            jrs.setPassword(pw);\n            jrs.execute();\n            jrs.beforeFirst();\n            jrs.updateString(\"first_name\",\"Big Max\");\n            jrs.updateString(\"last_name\",\"Big Dick Bisesi\");\n            jrs.updateRow();\n            System.out.println(jrs.getString(\"first_name\") + \" \" + jrs.getString(\"last_name\"));\n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n}','JDBC',0,0,NULL,5),(869,'NPE moving to absolute(0) moves to before the first row. \n\nmoving abosolute(-n) starts at the last row and moves the cursor backward','public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n        try(JdbcRowSet jrs = RowSetProvider.newFactory().createJdbcRowSet()){\n            String query = \"Select * from employees limit 100\";\n            jrs.setCommand(query);\n            jrs.setUrl(url);\n            jrs.setUsername(user);\n            jrs.setPassword(pw);\n            jrs.execute();\n            jrs.absolute(0);\n            jrs.updateString(\"first_name\",\"Big Max\");\n            jrs.updateString(\"last_name\",\"Big Dick Bisesi\");\n            jrs.updateRow();\n            System.out.println(jrs.getString(\"first_name\") + \" \" + jrs.getString(\"last_name\"));\n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n}','JDBC',0,0,NULL,5),(870,'changes the fifth row in the rowset.\n\nAngela Bit Butt Horton','public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n        try(JdbcRowSet jrs = RowSetProvider.newFactory().createJdbcRowSet()){\n            String query = \"Select * from employees limit 100\";\n            jrs.setCommand(query);\n            jrs.setUrl(url);\n            jrs.setUsername(user);\n            jrs.setPassword(pw);\n            jrs.execute();\n            jrs.absolute(5);\n            jrs.updateString(\"first_name\",\"Angela\");\n            jrs.updateString(\"last_name\",\"Big Butt Horton\");\n            jrs.updateRow();\n            System.out.println(jrs.getString(\"first_name\") + \" \" + jrs.getString(\"last_name\"));\n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n}','JDBC',0,0,NULL,5),(871,'jrs.moveToInsertRow();\njrs.updateString(\"first_name\",\"Jonny\");\njrs.udateString...\njrs.updateInt...\njrs.insertRow();\njrs.moveToCurrentRow();','How to insert a new row into a RowSet ?','JDBC',0,0,NULL,5),(872,'sqlexception: invalid state there is no rowset to perforem these changes on \nbecause execute() wasn\'t called.','public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n        try(JdbcRowSet jrs = RowSetProvider.newFactory().createJdbcRowSet()){\n            String query = \"Select * from employees limit 100\";\n            jrs.setCommand(query);\n            jrs.setUrl(url);\n            jrs.setUsername(user);\n            jrs.setPassword(pw);\n            \n            jrs.moveToInsertRow();\n            jrs.updateInt(\"emp_no\",12345);\n            jrs.updateString(\"firs_name\",\"Blue\");\n            jrs.updateString(\"last_name\",\"Bella\");\n            jrs.insertRow();\n            \n            //System.out.println(jrs.getString(\"first_name\") + \" \" + jrs.getString(\"last_name\"));\n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n}','JDBC',0,0,NULL,5),(873,'Blue Bella this prints the values just inserted in the insert row.','public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n        try(JdbcRowSet jrs = RowSetProvider.newFactory().createJdbcRowSet()){\n            String query = \"Select * from employees limit 100\";\n            jrs.setCommand(query);\n            jrs.setUrl(url);\n            jrs.setUsername(user);\n            jrs.setPassword(pw);\n            \n            jrs.execute();\n            \n            jrs.moveToInsertRow();\n            jrs.updateInt(\"emp_no\", 789);\n            jrs.updateString(\"first_name\",\"Blue\");\n            jrs.updateString(\"last_name\",\"Bella\");\n            jrs.insertRow();\n            \n            System.out.println(jrs.getString(\"first_name\") + \" \" + jrs.getString(\"last_name\"));\n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n}','JDBC',0,0,NULL,5),(874,'null null','public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n        try(JdbcRowSet jrs = RowSetProvider.newFactory().createJdbcRowSet()){\n            String query = \"Select * from employees limit 100\";\n            jrs.setCommand(query);\n            jrs.setUrl(url);\n            jrs.setUsername(user);\n            jrs.setPassword(pw);\n            jrs.execute();\n            jrs.moveToInsertRow();\n            System.out.println(jrs.getString(\"first_name\") + \" \" + jrs.getString(\"last_name\"));\n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n}','JDBC',0,0,NULL,5),(875,'NPE setURL was left out ','public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n        try(JdbcRowSet jrs = RowSetProvider.newFactory().createJdbcRowSet()){\n            String query = \"Select * from employees limit 100\";\n            jrs.setCommand(query);\n            jrs.setUsername(user);\n            jrs.setPassword(pw);\n            jrs.execute();\n            jrs.moveToInsertRow();\n            System.out.println(jrs.getString(\"first_name\") + \" \" + jrs.getString(\"last_name\"));\n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n}','JDBC',0,0,NULL,5),(876,'will not compile non static variable cannot be referenced from static context','public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n        try(JdbcRowSet jrs = RowSetProvider.newFactory().createJdbcRowSet()){\n            String query = \"Select * from employees limit 100\";\n            jrs.setCommand(query);\n            jrs.setUrl(url);\n            jrs.setUsername(user);\n            jrs.setPassword(pw);\n            jrs.execute();\n            \n            jrs.addRowSetListener(new MyRowSetListener());\n            \n            jrs.moveToInsertRow();\n            jrs.updateInt(\"emp_no\",3);\n            jrs.updateString(\"first_name\",\"Micheal\");\n            jrs.updateString(\"last_name\",\"Boyd\");\n            jrs.insertRow();\n            \n            jrs.moveToCurrentRow();\n            \n            while(jrs.next()){\n                System.out.println(jrs.getString(\"first_name\") + \" \" + jrs.getString(\"last_name\"));\n            }\n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n    \n    class MyRowSetListener implements RowSetListener {\n        \n        public void rowChanged(RowSetEvent event) {\n            if(event.getSource() instanceof RowSet) {\n                try{\n                    ((RowSet) event.getSource()).execute();\n                    //re excute the query every time the rowset is updchanged to update it\n                } catch(SQLException e){\n                    \n                }\n                \n            }\n        }\n        \n        public void cursorMoved(RowSetEvent e) { }\n        public void rowSetChanged(RowSetEvent e){ }\n    }\n}','JDBC',0,0,NULL,5),(877,'create a rowsetlistener','\npublic class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n        try(JdbcRowSet jrs = RowSetProvider.newFactory().createJdbcRowSet()){\n            String query = \"Select * from employees limit 100\";\n            jrs.setCommand(query);\n            jrs.setUrl(url);\n            jrs.setUsername(user);\n            jrs.setPassword(pw);\n            jrs.execute();\n            \n            jrs.addRowSetListener(new MyRowSetListener());\n            \n            jrs.moveToInsertRow();\n            jrs.updateInt(\"emp_no\",3);\n            jrs.updateString(\"first_name\",\"Micheal\");\n            jrs.updateString(\"last_name\",\"Boyd\");\n            jrs.insertRow();\n            \n            jrs.moveToCurrentRow();\n            \n            while(jrs.next()){\n                System.out.println(jrs.getString(\"first_name\") + \" \" + jrs.getString(\"last_name\"));\n            }\n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n    \n    static class MyRowSetListener implements RowSetListener {\n        \n        public void rowChanged(RowSetEvent event) {\n            if(event.getSource() instanceof RowSet) {\n                try{\n                    ((RowSet) event.getSource()).execute();\n                    //re excute the query every time the rowset is updchanged to update it\n                } catch(SQLException e){\n                    \n                }\n                \n            }\n        }\n        \n        public void cursorMoved(RowSetEvent e) { }\n        public void rowSetChanged(RowSetEvent e){ }\n    }\n}','JDBC',0,0,NULL,5),(878,'got it','a JdbcRowSet is connected which means its update are actively written to\nthe db, a CachedRowSet and all the rest are disconnected which means they\ncan connect to get the data disconnect change the data then re connect to \nupdate their changes, thats what a cache is.','JDBC',0,0,NULL,5),(879,'CachedRowSet cs = RowSetProvider.newFactory().createCachedRowSet();','how do you create a CachedRowSet','JDBC',0,0,NULL,5),(880,'will not compile thats not how you create a RowSet. you should add \n\n	createJdbcRowSet();','\npublic class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n        try(JdbcRowSet jrs = RowSetProvider.newFactory().createJdbcRowSet()){\n            String query = \"Select * from employees limit 100\";\n            jrs.setCommand(query);\n            jrs.setUrl(url);\n            jrs.setUsername(user);\n            jrs.setPassword(pw);\n            jrs.execute();\n            \n            jrs.addRowSetListener(new MyRowSetListener());\n            \n            jrs.moveToInsertRow();\n            jrs.updateInt(\"emp_no\",3);\n            jrs.updateString(\"first_name\",\"Micheal\");\n            jrs.updateString(\"last_name\",\"Boyd\");\n            jrs.insertRow();\n            \n            jrs.moveToCurrentRow();\n            \n            while(jrs.next()){\n                System.out.println(jrs.getString(\"first_name\") + \" \" + jrs.getString(\"last_name\"));\n            }\n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n    \n    static class MyRowSetListener implements RowSetListener {\n        \n        public void rowChanged(RowSetEvent event) {\n            if(event.getSource() instanceof RowSet) {\n                try{\n                    ((RowSet) event.getSource()).execute();\n                    //re excute the query every time the rowset is updchanged to update it\n                } catch(SQLException e){\n                    \n                }\n                \n            }\n        }\n        \n        public void cursorMoved(RowSetEvent e) { }\n        public void rowSetChanged(RowSetEvent e){ }\n    }\n}','JDBC',0,0,NULL,5),(881,'acceptChanges();','When your done changing CachedRowSet what do you call?','JDBC',0,0,NULL,5),(882,'Connection conn = DriverManager..\nconn.setAutoCommit(false); // begin transaction','how do you begin a transaction in jdbc ?','JDBC',0,0,NULL,5),(883,'you exlicityly commmit the current transaction\n\nyou excplicityl roll back the current transaction\n\nthere is a failure that forces automatic rollback.','A jdbc transaction includes all of the sQL queries you execute until either ...?','JDBC',0,0,NULL,5),(884,'start a transacation by setting autoCommit(false), then make sure you commit()\nit otherwise everything you just did will be automatically rolledback. \n\nAs soon you commit() another transaction is started.\n\nThere can only be one transaction at a time. ','public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n       try(Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\")){\n           conn.setAutoCommit(false);\n           Statement stmt = conn.createStatement();\n           stmt.execute(\"Insert into employees values (601,\'Dixon\',\'Ramey\')\");\n           stmt.execute(\"Insert into employees values (602,\'Alex\',\'Ramey\')\");\n           stmt.execute(\"Insert into employees values (603,\'Kevin\',\'Ramey\')\");\n           \n           conn.commit();\n           \n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n    \n}','JDBC',0,0,NULL,5),(885,'will not compile, Connection is scoped only within that try block because it is\nin a try with resources, conn in the catch is out of scope. ','public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n       try(Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\")){\n           conn.setAutoCommit(false);\n           Statement stmt = conn.createStatement();\n           stmt.execute(\"Insert into employees values (601,\'Dixon\',\'Ramey\')\");\n           stmt.execute(\"Insert into employees values (602,\'Alex\',\'Ramey\')\");\n           stmt.execute(\"Insert into employees values (603,\'Kevin\',\'Ramey\')\");\n           \n           conn.commit();\n           \n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n            \n            conn.rollback();\n        }\n    }\n    \n}','JDBC',0,0,NULL,5),(886,'WNC DriverManager.getConnection throws a sqlexception ','public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\");\n  \n        try{   \n        \n            conn.setAutoCommit(false);\n           Statement stmt = conn.createStatement();\n           stmt.execute(\"Insert into employees values (601,\'Dixon\',\'Ramey\')\");\n           stmt.execute(\"Insert into employees values (602,\'Alex\',\'Ramey\')\");\n           stmt.execute(\"Insert into employees values (603,\'Kevin\',\'Ramey\')\");\n           \n           conn.commit();\n           \n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n            \n            conn.rollback();\n        }\n    }\n    \n}','JDBC',0,0,NULL,5),(887,'if the insertions go as planned then commit the transaction otherwise try again\n','public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n       try(Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\")){\n           conn.setAutoCommit(false);\n           Statement stmt = conn.createStatement();\n           int updatecount = 0;\n           \n           updatecount += stmt.executeUpdate(\"Insert into employees values (701,\'Dixon\',\'Ramey\')\");\n           updatecount += stmt.executeUpdate(\"Insert into employees values (702,\'Alex\',\'Ramey\')\");\n           updatecount += stmt.executeUpdate(\"Insert into employees values (703,\'Kevin\',\'Ramey\')\");\n           \n           if(updatecount == 3){\n               System.out.println(\"Transaction complete\");\n                conn.commit();\n           } else {\n               System.out.println(\"Something didn\'t go through\");\n               conn.rollback();\n           }\n\n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n    \n}','JDBC',0,0,NULL,5),(888,'sqlexception transaction has not been started. setAutoCommit(false) to start one','public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n       try(Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\")){\n           Statement stmt = conn.createStatement();\n           int updatecount = 0;\n           \n           updatecount += stmt.executeUpdate(\"Insert into employees values (701,\'Dixon\',\'Ramey\')\");\n           updatecount += stmt.executeUpdate(\"Insert into employees values (702,\'Alex\',\'Ramey\')\");\n           updatecount += stmt.executeUpdate(\"Insert into employees values (703,\'Kevin\',\'Ramey\')\");\n           \n           if(updatecount == 3){\n               System.out.println(\"Transaction complete\");\n                conn.commit();\n           } else {\n               System.out.println(\"Something didn\'t go through\");\n               conn.rollback();\n           }\n\n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n    \n}','JDBC',0,0,NULL,5),(889,'setting autocommit to true will committ any current transaction and turn auto commit back on','public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n       try(Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\")){\n           conn.setAutoCommit(false);\n           Statement stmt = conn.createStatement();\n           int updatecount = 0;\n           \n           updatecount += stmt.executeUpdate(\"Insert into employees values (706,\'Dixon\',\'Ramey\')\");\n           updatecount += stmt.executeUpdate(\"Insert into employees values (707,\'Alex\',\'Ramey\')\");\n           updatecount += stmt.executeUpdate(\"Insert into employees values (708,\'Kevin\',\'Ramey\')\");\n           \n           if(updatecount == 3){\n               System.out.println(\"Transaction complete\");\n                conn.setAutoCommit(true);\n           } else {\n               System.out.println(\"Something didn\'t go through\");\n               conn.rollback();\n           }\n\n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n    \n}','JDBC',0,0,NULL,5),(890,'FALSE ! Connection objects','JDBC:\n\nYou call setAutoCommit(false) on Statement ojbects ','JDBC',0,0,NULL,5),(891,'','a savepoint represents a point in the transaction that you can rollback to.\nit is created from a connection object.','JDBC',0,0,NULL,5),(892,'how to use a savepoint','public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n       try(Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\")){\n           conn.setAutoCommit(false);//start a transaction\n           Statement stmt = conn.createStatement();\n           int updatecount = 0;\n           \n           updatecount += stmt.executeUpdate(\"Insert into employees values (710,\'steve\',\'davidson\')\");\n           updatecount += stmt.executeUpdate(\"Insert into employees values (711,\'Alex\',\'The great\')\");\n           updatecount += stmt.executeUpdate(\"Insert into employees values (713,\'baily\',\'Ramey\')\");\n           Savepoint sp1 = conn.setSavepoint();\n           \n           stmt.executeUpdate(\"Insert into employees values(801,\'Whitey\',\'Ford\')\");\n           \n           conn.rollback();\n\n           ResultSet rs = stmt.executeQuery(\"select * from employees where first_name = \\\'Whitey\\\'\");\n           \n           while(rs.next()){\n               System.out.println(rs.getInt(\"emp_no\"));\n           }\n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n    \n}','JDBC',0,0,NULL,5),(893,'Prepared and Callable statement setXXX() methods number parameters from \n1 not 0. ','public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n       try(Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\")){\n          String call = \"{CALL REMOVEBOOKS(?,?)}\";\n          String titleToRemove = null;\n          int maxBooks = 0;\n          CallableStatement cstmt = conn.prepareCall(call);\n          String titles = \"%Hero%\";\n          int numBooksRemoved;\n          cstmt.setInt(0,maxBooks);\n          cstmt.setString(1,titleToRemove);\n          cstmt.registerOutParameter(0,java.sql.Types.INTEGER);\n          cstmt.execute();\n          numBooksRemoved = cstmt.getInt(0); \n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n    \n}','JDBC',0,0,NULL,5),(894,'executeQuery() for callable and preparedstatements must not have the query passed\nin as a parameter. \n\nAlso the indexes are numbered incorectly','public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n       try(Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\")){\n          String call = \"{CALL REMOVEBOOKS(?,?)}\";\n          String titleToRemove = null;\n          int maxBooks = 0;\n          CallableStatement cstmt = conn.prepareCall(call);\n          String titles = \"%Hero%\";\n          int numBooksRemoved;\n          cstmt.setInt(0,maxBooks);\n          cstmt.setString(1,titleToRemove);\n          cstmt.registerOutParameter(0,java.sql.Types.INTEGER);\n          cstmt.executeQuery(query);\n          numBooksRemoved = cstmt.getInt(0); \n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n    \n}','JDBC',0,0,NULL,5),(895,'sqlexception executeQuery() for callable and prepared statements must not have\nthe query passed in as a parameter ','public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n       try(Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\")){\n          String call = \"{CALL REMOVEBOOKS(?,?)}\";\n          String titleToRemove = null;\n          String query = \"select * from Books\";\n          int maxBooks = 0;\n          CallableStatement cstmt = conn.prepareCall(call);\n          String titles = \"%Hero%\";\n          int numBooksRemoved;\n          cstmt.setInt(1,maxBooks);\n          cstmt.setString(2,titleToRemove);\n          cstmt.registerOutParameter(1,java.sql.Types.INTEGER);\n          cstmt.executeQuery(query);\n          numBooksRemoved = cstmt.getInt(1);\n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n    \n}','JDBC',0,0,NULL,5),(896,'sqlexception for registering the out parameter after the execute call.','public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n       try(Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\")){\n          String call = \"{CALL REMOVEBOOKS(?,?)}\";\n          String titleToRemove = null;\n          String query = \"select * from Books\";\n          int maxBooks = 0;\n          CallableStatement cstmt = conn.prepareCall(call);\n          String titles = \"%Hero%\";\n          int numBooksRemoved;\n          cstmt.setInt(1,maxBooks);\n          cstmt.setString(2,titleToRemove);\n          cstmt.execute();\n          cstmt.registerOutParameter(1,java.sql.Types.INTEGER);\n          numBooksRemoved = cstmt.getInt(1);\n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n    \n}','JDBC',0,0,NULL,5),(897,'this stored proceudre does not return a resultset, so while it will compile\nbcasue executeQuery() will return a ResultSet to rs. cstmt.getInt(1); will throw\na sql exception.','public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n       try(Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\")){\n          String call = \"{CALL REMOVEBOOKS(?,?)}\";\n          String titleToRemove = null;\n          String query = \"select * from Books\";\n          int maxBooks = 0;\n          CallableStatement cstmt = conn.prepareCall(call);\n          String titles = \"%Hero%\";\n          int numBooksRemoved;\n          cstmt.setInt(1,maxBooks);\n          cstmt.setString(2,titleToRemove);\n          cstmt.registerOutParameter(1,java.sql.Types.INTEGER);\n          ResultSet rs = cstmt.executeQuery();\n          rs.next();\n          numBooksRemoved = cstmt.getInt(1);\n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n    \n}','JDBC',0,0,NULL,5),(898,'this is the way to use a CallableStatement.','public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n       try(Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\")){\n          String call = \"{CALL REMOVEBOOKS(?,?)}\";\n          String titleToRemove = null;\n          String query = \"select * from Books\";\n          int maxBooks = 0;\n          CallableStatement cstmt = conn.prepareCall(call);\n          String titles = \"%Hero%\";\n          int numBooksRemoved;\n          cstmt.setInt(1,maxBooks);\n          cstmt.setString(2,titleToRemove);\n          cstmt.registerOutParameter(1,java.sql.Types.INTEGER);\n          cstmt.execute();\n          numBooksRemoved = cstmt.getInt(1);\n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }  \n}','JDBC',0,0,NULL,5),(899,'Will not compile RowSetFactory does not implement autocloseable','try(RowSetFactory rsf = RowSetProvider.newFactory()) {\nRowSet rws = rsf.createRowSet();','JDBC',0,0,NULL,5),(900,'this database will be unchanged. the error here is that acceptChanges() was\nnever called to reconcile the changes made with the in memory version and the\nactual db.\n\nthe database being offline anytime after the execute() is invoked in irrelevent\n','String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n       //try(Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\")){\n        \n        try(CachedRowSet crs = RowSetProvider.newFactory().createCachedRowSet()) {\n            String query = \"Select * From employee\";\n            crs.setCommand(query);\n            crs.setUrl(url);\n            crs.setUsername(user);\n            crs.setPassword(pw);\n            crs.execute();\n            crs.last();\n            crs.updateString(\"last_name\", \"Sullivan\");\n            //database goes offline\n            crs.moveToInsertRow();\n            crs.updateInt(\"ID\",101);\n            crs.updateString(\"first_name\",\"Billy\");\n            crs.updateString(\"last_name\",\"Blue\");\n            crs.insertRow();\n            crs.moveToCurrentRow();\n            crs.absolute(10);\n            crs.deleteRow();\n            //db backonline\n        } catch(SQLException e){\n            System.out.println(e);\n        }','JDBC',0,0,NULL,5),(901,'crs.insertRow();\n\nalso crs.acceptChanges()','public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n       //try(Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\")){\n        \n        try(CachedRowSet crs = RowSetProvider.newFactory().createCachedRowSet()) {\n            String query = \"Select * From employee\";\n            crs.setCommand(query);\n            crs.setUrl(url);\n            crs.setUsername(user);\n            crs.setPassword(pw);\n            crs.execute();\n            crs.last();\n            crs.updateString(\"last_name\", \"Sullivan\");\n            //database goes offline\n            crs.moveToInsertRow();\n            crs.updateInt(\"ID\",101);\n            crs.updateString(\"first_name\",\"Billy\");\n            crs.updateString(\"last_name\",\"Blue\");\n            crs.moveToCurrentRow();\n            crs.absolute(10);\n            crs.deleteRow();\n            //db backonline\n        } catch(SQLException e){\n            System.out.println(e);\n        }\n    }  \n}\nwhats missing here ?','JDBC',0,0,NULL,5),(902,'crs.execute() is missing','public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n       //try(Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\")){\n        \n        try(CachedRowSet crs = RowSetProvider.newFactory().createCachedRowSet()) {\n            String query = \"Select * From employee\";\n            crs.setCommand(query);\n            crs.setUrl(url);\n            crs.setUsername(user);\n            crs.setPassword(pw);\n            crs.last();\n            crs.updateString(\"last_name\", \"Sullivan\");\n            //database goes offline\n            crs.moveToInsertRow();\n            crs.updateInt(\"ID\",101);\n            crs.updateString(\"first_name\",\"Billy\");\n            crs.updateString(\"last_name\",\"Blue\");\n            crs.insertRow();\n            crs.moveToCurrentRow();\n            crs.absolute(10);\n            crs.deleteRow();\n            //db backonline\n        } catch(SQLException e){\n            System.out.println(e);\n        }\n    }  \n}','JDBC',0,0,NULL,5),(903,'the first two updates are executed, but then a sqlexception is thrown because \na transaction was never started to rollback.\n\nyou would have had to setAutoCommit(false) to start a transaction.\n\nThe first two were automatically commited. ','public class Hello {\n    public static void main(String[] args){\n        \n        boolean businessrule = true;\n       try(Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\")){\n            String query = \"Inser into ...\";\n            String query2 = \"Updat table...\";\n            \n            Statement st = conn.createStatement();\n            \n            st.executeUpdate(query);\n            st.executeUpdate(query2);\n            \n            if(businessrule){\n                conn.rollback();\n            }\n        } catch(SQLException e){\n            System.out.println(e);\n        }\n    }  \n}','JDBC',0,0,NULL,5),(904,'if the business rule remains false then both updates will be comitted.\nsince autocommit is false.','public class Hello {\n    public static void main(String[] args){\n        \n        boolean businessrule = false;\n       try(Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\")){\n            conn.setAutoCommit(false);\n            String query = \"Inser into ...\";\n            String query2 = \"Updat table...\";\n            \n            Statement st = conn.createStatement();\n            \n            st.executeUpdate(query);\n            st.executeUpdate(query2);\n            \n            if(businessrule){\n                conn.rollback();\n            } else {\n                conn.commit();\n            }\n        } catch(SQLException e){\n            System.out.println(e);\n        }\n    }  \n}','JDBC',0,0,NULL,5),(905,'no rows are added at all, the rollback() rolls back to the savepoint but erasing the\nsecond update, but because there is no commit() at all the first update will also be \nrolledback when the try block closes for good becaus autocommitmode was set\nto false. ','public class Hello {\n    public static void main(String[] args){\n\n       try(Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\")){\n            conn.setAutoCommit(false);\n            String query = \"Inser into ...\";\n            String query2 = \"Updat table...\";\n            Statement st = conn.createStatement();\n            \n            st.executeUpdate(query);\n            \n            Savepoint sp1 = conn.setSavepoint();\n            \n            st.executeUpdate(query2);\n            \n            conn.rollback();\n           \n        } catch(SQLException e){\n            System.out.println(e);\n        }\n    }  \n}','JDBC',0,0,NULL,5),(906,'First entry:\nMicheal Boyd\nLast entry:\nKenroku Malabarba\nrow: 20\nKyoichi Maliniak\nrow: 30\nGuoxiang Nooteboom\nupdate executed\njava.sql.SQLException: Operation not allowed after ResultSet closed\n\nAfter re executing a statement, all ResultSets tied to that statemnt are \nautomatically closed','public class Hello {\n    public static void main(String[] args){\n        try {\n            Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\");\n            Statement st = conn.createStatement();\n            String q = \"Select * From employees limit 100\";\n            ResultSet rs = st.executeQuery(q);\n            \n            rs.first();\n            System.out.println(\"First entry:\");\n            System.out.println(rs.getString(\"first_name\") + \" \" +rs.getString(\"last_name\"));\n            \n            rs.last();\n            System.out.println(\"Last entry:\");\n            System.out.println(rs.getString(\"first_name\") + \" \" +rs.getString(\"last_name\"));\n            \n            rs.absolute(20);\n            System.out.println(\"row: \"+ rs.getRow());\n            System.out.println(rs.getString(\"first_name\") + \" \" +rs.getString(\"last_name\"));\n            \n            rs.relative(10);\n            System.out.println(\"row: \"+ rs.getRow());\n            System.out.println(rs.getString(\"first_name\") + \" \" +rs.getString(\"last_name\")); \n            \n            String update = \"insert into employees values(09,\'Broden\',\'Chapman\')\";\n            boolean results = st.execute(update);\n            \n            if(!results){\n                System.out.println(\"update executed\");\n            }\n            \n            rs.last();\n            System.out.println(\"new entry row: \"+ rs.getRow());\n            System.out.println(rs.getString(\"first_name\") + \" \" +rs.getString(\"last_name\")); \n\n        } catch(SQLException e){System.out.println(e); }\n        \n    }\n}','JDBC',0,0,NULL,5),(907,'Will not compile, this is not the right syntax for multi - catch\nshould be \n\n	} catch(SQLException | IOException e){  ... }','public class Hello {\n    public static void main(String[] args){\n        try {\n            Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\");\n            Statement st = conn.createStatement();\n            String q = \"Select * From employees limit 100\";\n            getDBfile();\n            ResultSet rs = st.executeQuery(q);\n            \n            rs.first();\n            System.out.println(\"First entry:\");\n            System.out.println(rs.getString(\"first_name\") + \" \" +rs.getString(\"last_name\"));\n            \n            rs.last();\n            System.out.println(\"Last entry:\");\n            System.out.println(rs.getString(\"first_name\") + \" \" +rs.getString(\"last_name\"));\n            \n            rs.absolute(20);\n            System.out.println(\"row: \"+ rs.getRow());\n            System.out.println(rs.getString(\"first_name\") + \" \" +rs.getString(\"last_name\"));\n            \n            rs.relative(10);\n            System.out.println(\"row: \"+ rs.getRow());\n            System.out.println(rs.getString(\"first_name\") + \" \" +rs.getString(\"last_name\")); \n            \n            String update = \"insert into employees values(09,\'Broden\',\'Chapman\')\";\n            boolean results = st.execute(update);\n            \n            if(!results){\n                System.out.println(\"update executed\");\n            }\n            \n            rs.last();\n            System.out.println(\"new entry row: \"+ rs.getRow());\n            System.out.println(rs.getString(\"first_name\") + \" \" +rs.getString(\"last_name\")); \n\n        } catch(SQLException e | IOException e){System.out.println(e); }\n        \n    }\n    \n    public static void getDBfile() throws IOException { }  \n}','General',0,0,NULL,5),(908,'First entry:\nHired today: Fri Jul 28 11:29:33 EDT 2017\nMicheal Boyd\nLast entry:\nTuval Kalloufi\nrow: 20\nChirstian Koblick\nrow: 30\nBerni Genin\nupdate executed\njava.sql.SQLException: Operation not allowed after ResultSet closed','public class Hello {\n    public static void main(String[] args){\n        try {\n            Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\");\n            PreparedStatement pst = conn.prepareStatement(\"Select * From employees limit 100\");\n            ResultSet rs = pst.executeQuery();\n            \n            java.util.Date d = new java.util.Date();\n\n            rs.first();\n            System.out.println(\"First entry:\");\n            System.out.println(\"Hired today: \"+d);\n            System.out.println(rs.getString(\"first_name\") + \" \" +rs.getString(\"last_name\"));\n            \n            rs.last();\n            System.out.println(\"Last entry:\");\n            System.out.println(rs.getString(\"first_name\") + \" \" +rs.getString(\"last_name\"));\n            \n            rs.absolute(20);\n            System.out.println(\"row: \"+ rs.getRow());\n            System.out.println(rs.getString(\"first_name\") + \" \" +rs.getString(\"last_name\"));\n            \n            rs.relative(10);\n            System.out.println(\"row: \"+ rs.getRow());\n            System.out.println(rs.getString(\"first_name\") + \" \" +rs.getString(\"last_name\")); \n            \n            String update = \"insert into employees values(11,\'Broden\',\'Chapman\')\";\n            boolean results = pst.execute(update);\n            \n            if(!results){\n                System.out.println(\"update executed\");\n            }\n            \n            rs.last();\n            System.out.println(\"new entry row: \"+ rs.getRow());\n            System.out.println(rs.getString(\"first_name\") + \" \" +rs.getString(\"last_name\")); \n\n        } catch(SQLException e){System.out.println(e); }\n        \n    }\n}','JDBC',0,0,NULL,5),(909,'public long getTime()\n\nReturns the number of milliseconds \nsince January 1, 1970, 00:00:00 GMT represented by this Date object.','public static void main(sa) {\n	//most useless method\n	Date d = new Date();\n	sout( d.getTime() + \" \" );\n}\n\nwhat does this show ?','Strings',0,0,NULL,5),(910,'WNC, the correct way to create a Calendar is \n\n	Calendar c = Calendar.getInstance();','public class Hello {\n    public static void main(String[] args){\n        try {\n            Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\");\n            PreparedStatement pst = conn.prepareStatement(\"Select * From employees limit 100\");\n            ResultSet rs = pst.executeQuery();\n            \n            Date d = new Date();\n            //Calendar c = Calendar.getInstance();\n            Calendar c = new Calendar();\n            c.setTime(d);\n\n            rs.first();\n            System.out.println(\"First entry:\");\n            System.out.println(\"Hired today: \"+d);\n            System.out.println(\"Start first upcoming monday: \"+firstNextMonday(d));\n            System.out.println(rs.getString(\"first_name\") + \" \" +rs.getString(\"last_name\"));\n            \n            c.add(Calendar.MONTH,-1);\n            Date monthago = c.getTime();\n            rs.last();\n            System.out.println(\"Last entry:\");\n            System.out.println(\"Hired a month ago: \"+monthago);\n            System.out.println(rs.getString(\"first_name\") + \" \" +rs.getString(\"last_name\"));\n            ','Strings',0,0,NULL,5),(911,'WNC, the corrct ways to create a Calendar is \n\n	Calendar c = Calendar.getInstance();\n\nif that was corrected then this program would print:\n\n	First entry:\n	Hired today: Mon Aug 07 16:39:34 EDT 2017\n\nand keep running forever...\n\n	you were using accesing a static field at c.DAY_OF_WEEK\n	\n	it should be:\n\n	while(c.get(Calendar.DAY_OF_WEEK) != c.MONDAY){\n            //c.add(1,DAY_OF_WEEK);\n            c.add(c.DAY_OF_WEEK,1);\n        }\n\nif today was monday it would print the excact time and day of right now','public class Hello {\n    public static void main(String[] args){\n        try {\n            Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\");\n            PreparedStatement pst = conn.prepareStatement(\"Select * From employees limit 100\");\n            ResultSet rs = pst.executeQuery();\n            \n            Date d = new Date();\n            Calendar c = new Calendar();\n            c.setTime(d);\n\n            rs.first();\n            System.out.println(\"First entry:\");\n            System.out.println(\"Hired today: \"+d);\n            System.out.println(\"Start first upcoming monday: \"+firstNextMonday(d));\n            System.out.println(rs.getString(\"first_name\") + \" \" +rs.getString(\"last_name\"));\n            \n            c.add(Calendar.MONTH,-1);\n            Date monthago = c.getTime();\n            rs.last();\n            System.out.println(\"Last entry:\");\n            System.out.println(\"Hired a month ago: \"+monthago);\n            System.out.println(rs.getString(\"first_name\") + \" \" +rs.getString(\"last_name\"));\n        } catch(SQLException e){ }\n        \n    }\n    \n    public static Date firstNextMonday(Date d){\n        Calendar c = Calendar.getInstance();\n        c.setTime(d);\n        \n        while(c.DAY_OF_WEEK != c.MONDAY){\n            //c.add(1,DAY_OF_WEEK);\n            c.add(c.DAY_OF_WEEK,1);\n        }\n        \n        return c.getTime();\n        \n    }\n}','Strings',0,0,NULL,5),(912,'java.sql.SQLException: No value specified for parameter 1','public class Hello {\n    public static void main(String[] args){\n        try {\n            Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\");\n            PreparedStatement pst = conn.prepareStatement(\"Select * From employees where first_name = ?\");\n            ResultSet rs = pst.executeQuery();\n            \n            Date d = new Date();\n            Calendar c = Calendar.getInstance();\n            c.setTime(d);\n            \n            DateFormat dateformat = DateFormat.getInstance();\n\n            rs.first();\n            System.out.println(\"First entry:\");\n            System.out.println(\"Hired today: \"+d);\n            System.out.println(\"Start first upcoming monday: \"+firstNextMonday(d));\n            System.out.println(rs.getString(\"first_name\") + \" \" +rs.getString(\"last_name\"));\n            \n            c.add(Calendar.MONTH,-1);\n            Date monthago = c.getTime();\n            rs.last();\n            System.out.println(\"Last entry:\");\n            System.out.println(\"Hired a month ago: \"+monthago);\n            System.out.println(rs.getString(\"first_name\") + \" \" +rs.getString(\"last_name\"));\n            \n            c.setTime(d);\n            c.add(Calendar.YEAR,-1);\n            c.add(Calendar.MONTH, -6);\n            Date yearandahalf = c.getTime();\n            rs.absolute(20);\n            System.out.println(\"row: \"+ rs.getRow());\n            System.out.println(\"Hired a year and a half ago\"+yearandahalf);\n            System.out.println(rs.getString(\"first_name\") + \" \" +rs.getString(\"last_name\"));\n	} catch(SQLException e) { }\n   }\n}','Strings',0,0,NULL,5),(913,'7/28/17 12:39 PM','public static void main(String[] args){\n        Date d = new Date();\n        DateFormat df = DateFormat.getInstance();\n        \n        System.out.println(df.format(d));\n        \n    }','Strings',0,0,NULL,5),(914,'Jul 28, 2017','public static void main(String[] args){\n\n        Date d = new Date();\n        DateFormat df = DateFormat.getDateInstance();\n        \n        System.out.println(df.format(d));\n        \n    }','Strings',0,0,NULL,5),(915,' public static void main(String[] args){\n        Date d = new Date();\n        DateFormat df = DateFormat.getDateInstance(DateFormat.SHORT);\n        \n        System.out.println(df.format(d));\n        \n    }','What dateformat is this\n\n7/28/17','Strings',0,0,NULL,5),(916,'will not compile, ParseException must be caught or thrown','public static void main(String[] args){\n        Date d = new Date();\n        DateFormat df = DateFormat.getDateInstance(DateFormat.SHORT);\n        \n        String s = df.format(d);\n        \n        Date d2 = df.parse(s);\n    }','Strings',0,0,NULL,5),(917,'parsedFri Jul 28 00:00:00 EDT 2017','public static void main(String[] args){\n        Date d = new Date();\n        DateFormat df = DateFormat.getDateInstance(DateFormat.SHORT);\n        \n        String s = df.format(d);\n        \n        try{\n            Date d2 = df.parse(s);\n            System.out.println(\"parsed \"+d2);\n        } catch( ParseException e){\n            \n        }\n    }','Strings',0,0,NULL,5),(918,'WNC dateformat is abstract cannot be instantiated ','public static void main(String[] args){\n        Date d = new Date();\n        DateFormat df = new DateFormat(DateFormat.SHORT);\n        \n        String s = df.format(d);\n        \n        try{\n            Date d2 = df.parse(s);\n            System.out.println(\"parsed \"+d2);\n        } catch( ParseException e){\n            \n        }\n    }','Strings',0,0,NULL,5),(919,'The regular DF constructor doesn\'t take a style or Locale.\n\nGet a default date/time \nformatter that uses the SHORT style for both the date and the time.\n\nwith statements preparedstatements callablestatements:\n\n	executeQuery() returns a ResultSet\n	executeUpdate() returns an int\n	execute()  returns a boolean','try {\n            Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\");\n            PreparedStatement pst = conn.prepareStatement(\"Select * From employees limit 100\");\n            ResultSet rs = pst.executeQuery();\n            \n            Date d = new Date();\n            Calendar c = Calendar.getInstance();\n            c.setTime(d);\n            \n            DateFormat dateformat = DateFormat.getInstance();\n            Locale italian = new Locale(\"it\");\n            DateFormat italianformat = DateFormat.getInstance(DateFormat.FULL,italian);\n} catch(SQLException e){ }','Strings',0,0,NULL,5),(920,'WNC you can only set a DateFormat and NumberFormat can only set\n local at the time of instantiation. There is not method to change locale\nafterward.','public class Hello {\n    public static void main(String[] args){\n        DateFormat df = DateFormat.getDateInstance(DateFormat.FULL,Locale.KOREA);\n        Date now = new Date();\n        \n        System.out.println(df.format(now));\n        \n        df.setLocale(Locale.US);\n        \n        System.out.println(df.format(now));\n    }\n}','Strings',0,0,NULL,5),(921,'Brazil\nDenmark\nItaly\nBrasil\nDanmark\nItalia','public class Hello {\n    public static void main(String[] args){\n        Locale loc1 = new Locale(\"pt\",\"BR\");\n        Locale loc2 = new Locale(\"da\",\"DK\");\n        Locale loc3 = new Locale(\"it\", \"IT\");\n        \n        System.out.println(loc1.getDisplayCountry());\n        System.out.println(loc2.getDisplayCountry());\n        System.out.println(loc3.getDisplayCountry());\n        \n        //display the countrys name in that language\n        \n        System.out.println(loc1.getDisplayCountry(loc1));\n        System.out.println(loc2.getDisplayCountry(loc2));\n        System.out.println(loc3.getDisplayCountry(loc3));\n    }\n}','Strings',0,0,NULL,5),(922,'3\n123.435','public class Hello {\n    public static void main(String[] args){\n        float f1 = 123.43535353f;\n        NumberFormat nf = NumberFormat.getInstance();\n        System.out.println(nf.getMaximumFractionDigits());\n        \n        System.out.println(nf.format(f1));\n        \n    }\n}','Strings',0,0,NULL,5),(923,'3\n123.435\n123.43536','public class Hello {\n    public static void main(String[] args){\n        float f1 = 123.43535353f;\n        NumberFormat nf = NumberFormat.getInstance();\n        System.out.println(nf.getMaximumFractionDigits());\n        \n        System.out.println(nf.format(f1));\n        \n        nf.setMaximumFractionDigits(5);\n        \n        System.out.println(nf.format(f1));\n        \n    }\n}','Strings',0,0,NULL,5),(924,'345.3435\n345','public class Hello {\n    public static void main(String[] args){\n        float f1 = 123.43535353f;\n        NumberFormat nf = NumberFormat.getInstance();\n        \n        try{\n            System.out.println(nf.parse(\"345.3435\"));\n            nf.setParseIntegerOnly(true);\n            System.out.println(nf.parse(\"345.3435\"));\n        } catch(ParseException e){\n            \n        }\n    }\n}','Strings',0,0,NULL,5),(925,'123.435\n123.435\n$123.44\n?123\n\ncould vary from maching to machine','public class Hello {\n    public static void main(String[] args){\n        float f1 = 123.43535353f;\n        NumberFormat nf = NumberFormat.getInstance();\n        NumberFormat nf2 = NumberFormat.getInstance(Locale.KOREA);\n        NumberFormat nf3 = NumberFormat.getCurrencyInstance();\n        NumberFormat nf4 = NumberFormat.getCurrencyInstance(Locale.KOREA);\n        \n        System.out.println(nf.format(f1));\n        System.out.println(nf2.format(f1));\n        System.out.println(nf3.format(f1));\n        System.out.println(nf4.format(f1));\n\n    }\n}','Strings',0,0,NULL,5),(926,'0\n7\n17','public class Hello {\n    public static void main(String[] args){\n        Pattern p = Pattern.compile(\"ab\");\n        Matcher m = p.matcher(\"abakdnfab kekrls ab\");\n        \n        while(m.find()){\n            System.out.println(m.start());\n        }\n        \n    }\n}','Strings',0,0,NULL,5),(927,'13\n14\n30\n31\n58\n59\n\n\\\\d looks for digits','public class Hello {\n    public static void main(String[] args){\n        Pattern p = Pattern.compile(\"\\\\d\");\n        Matcher m = p.matcher(\"The silly Dog89 ran for miles.56 Like a silly little puppy45\");\n        \n        while(m.find()){\n            System.out.println(m.start());\n        }\n        \n    }\n}','Strings',0,0,NULL,5),(928,'\\\\d looks for digits, \\\\D looks for nondigitis\nfirst:\n22\n23\n\nsecond:\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n24\n25\n26\n27\n28\n29\n30','first:\n    public static void main(String[] args){\n        Pattern p = Pattern.compile(\"\\\\d\");\n        Matcher m = p.matcher(\"The silly Dog ran for 89 miles.\");\n        \n        while(m.find()){\n            System.out.println(m.start());\n        }\n        \n    }\nsecond:\n	public static void main(String[] args){\n        Pattern p = Pattern.compile(\"\\\\D\");\n        Matcher m = p.matcher(\"The silly Dog ran for 89 miles.\");\n        \n        while(m.find()){\n            System.out.println(m.start());\n        }\n        \n    }\n','Strings',0,0,NULL,5),(929,'a whitespace character \\t \\n \\f \\r','regex metacharacter:\n\n\\s','Strings',0,0,NULL,5),(930,'non white space','regex metacharacter:\n\n\\S','Strings',0,0,NULL,5),(931,'a-z A-Z digits or _','regex metacharacter:\n\n\\w word character\n\nmeaning what ?','Strings',0,0,NULL,5),(932,'everything besides a-z A-Z _ or digits','regex metacharacter:\n\n\\W non word character\n\nmeaning what ?','Strings',0,0,NULL,5),(933,'3\n9\n13\n17\n21\n24\n\nwhitespace characters','public static void main(String[] args){\n        Pattern p = Pattern.compile(\"\\\\s\");\n        Matcher m = p.matcher(\"The silly Dog ran for 89 miles.\");\n        \n        while(m.find()){\n            System.out.println(m.start());\n        }\n        \n    }','Strings',0,0,NULL,5),(934,'all the non white spaces:\n0\n1\n2\n4\n5\n6\n7\n8\n10\n11\n12\n14\n15\n16\n18\n19\n20\n22\n23\n25\n26\n27\n28\n29\n30','public static void main(String[] args){\n        Pattern p = Pattern.compile(\"\\\\S\");\n        Matcher m = p.matcher(\"The silly Dog ran for 89 miles.\");\n        \n        while(m.find()){\n            System.out.println(m.start());\n        }\n        \n    }','Strings',0,0,NULL,5),(935,'0   all the word characters similiar to \\\\S\n1\n2\n4\n5\n6\n7\n8\n10\n11\n12\n14\n15\n16\n18\n19\n20\n22\n23\n25\n26\n27\n28\n29','public static void main(String[] args){\n        Pattern p = Pattern.compile(\"\\\\w\");\n        Matcher m = p.matcher(\"The silly Dog ran for 89 miles.\");\n        \n        while(m.find()){\n            System.out.println(m.start());\n        }\n        \n    }','Strings',0,0,NULL,5),(936,'3  //non word character similar to \\\\S numbers are word characters\n9\n13\n17\n21\n24\n30','public static void main(String[] args){\n        Pattern p = Pattern.compile(\"\\\\W\");\n        Matcher m = p.matcher(\"The silly Dog ran for 89 miles.\");\n        \n        while(m.find()){\n            System.out.println(m.start());\n        }\n        \n    }','Strings',0,0,NULL,5),(937,'a word boundary, anytime there is a word character and a non word right next to\neach other.\nThere are invisible non word characters at the end and beginning of a string.\n\n0\n3\n4\n9\n10\n13\n14\n17\n18\n21\n22\n24\n25\n30','public class Hello {\n    public static void main(String[] args){\n        Pattern p = Pattern.compile(\"\\\\b\");\n        Matcher m = p.matcher(\"The silly Dog ran for 89 miles.\");\n        \n        while(m.find()){\n            System.out.println(m.start());\n        }\n        \n    }\n}','Strings',0,0,NULL,5),(938,'//non word boundary each of these is a case where there IS NO word boundary\nor two word characters are beside each other or two non words are beside each other\nreturns the position of the second character.\n\n1 \n2\n5\n6\n7\n8\n11\n12\n15\n16\n19\n20\n23\n26\n27\n28\n29\n31','public class Hello {\n    public static void main(String[] args){\n        Pattern p = Pattern.compile(\"\\\\B\");\n        Matcher m = p.matcher(\"The silly Dog ran for 89 miles.\");\n        \n        while(m.find()){\n            System.out.println(m.start());\n        }\n        \n    }\n}','Strings',0,0,NULL,5),(939,'4\n5\n11\n19\n26\n29','public static void main(String[] args){\n        Pattern p = Pattern.compile(\"[soi]\");\n        Matcher m = p.matcher(\"The silly Dog ran for 89 miles.\");\n        \n        while(m.find()){\n            System.out.println(m.start());\n        }\n        \n    }','Strings',0,0,NULL,5),(940,'1\n2\n4\n5\n6\n7\n8\n11\n12\n14\n15\n16\n18\n19\n20\n25\n26\n27\n28\n29','public class Hello {\n    public static void main(String[] args){\n        Pattern p = Pattern.compile(\"[a-z]\");\n        Matcher m = p.matcher(\"The silly Dog ran for 89 miles.\");\n        \n        while(m.find()){\n            System.out.println(m.start());\n        }\n        \n    }\n}\n','Strings',0,0,NULL,5),(941,'15','public class Hello {\n    public static void main(String[] args){\n        Pattern p = Pattern.compile(\"[a-cA-C]\");\n        Matcher m = p.matcher(\"The silly Dog ran for 89 miles.\");\n        \n        while(m.find()){\n            System.out.println(m.start());\n        }\n        \n    }\n}','Strings',0,0,NULL,5),(942,'// the mistake here is that ? gives you \"ZERO OR ONE\" so if there is no a \nthere that still mathces!\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58','public class Hello {\n    public static void main(String[] args){\n        Pattern p = Pattern.compile(\"a?\");\n        Matcher m = p.matcher(\"The silly Dog ran for at least 89 miles.I am tired he said\");\n        \n        while(m.find()){\n            System.out.println(m.group());\n        }\n        \n    }\n}','Strings',0,0,NULL,5),(943,'public class Hello {\n    public static void main(String[] args){\n        Pattern p = Pattern.compile(\" a.\");\n        Matcher m = p.matcher(\"The silly Dog ran for at least 89 miles.I am tired he said\");\n        \n        while(m.find()){\n            System.out.println(m.start());\n            System.out.println(m.group());\n        }\n        \n    }\n}\n\n21\n at\n41\n am','creaet a regex that finds a word composed of an \'a\' with any character next to it','Strings',0,0,NULL,5),(944,'Without the space at the beginning of the pattern you allow a then any character\nto but up against any other character if you wanted it to just be individual\nwords then you could add a space at the beginning or a whitespce character.\n15\nan\n22\nat\n27\nas\n42\nam\n55\nai','public class Hello {\n    public static void main(String[] args){\n        Pattern p = Pattern.compile(\"a.\");\n        Matcher m = p.matcher(\"The silly Dog ran for at least 89 miles.I am tired he said\");\n        \n        while(m.find()){\n            System.out.println(m.start());\n            System.out.println(m.group());\n        }\n        \n    }\n}\n\n','Strings',0,0,NULL,5),(945,'21\n at\n41\n am','public class Hello {\n    public static void main(String[] args){\n        Pattern p = Pattern.compile(\"\\\\sa.\");\n        Matcher m = p.matcher(\"The silly Dog ran for at least 89 miles.I am tired he said\");\n        \n        while(m.find()){\n            System.out.println(m.start());\n            System.out.println(m.group());\n        }\n        \n    }\n}','Strings',0,0,NULL,5),(946,'49\n first ','public class Hello {\n    public static void main(String[] args){\n        //five letter words\n        Pattern p = Pattern.compile(\"\\\\s.....\\\\s\");\n        Matcher m = p.matcher(\"A regular expression, specified as a string, must first be compiled into an instance of this class\");\n        \n        while(m.find()){\n            System.out.println(m.start());\n            System.out.println(m.group());\n        }\n        \n    }\n}','Strings',0,0,NULL,5),(947,'/home/maxbisesi/Documents/allfiles\n\nNone of these methods throw an IOE','public class Hello {\n    public static void main(String[] dicks){\n      Path src = Paths.get(\"/home/maxbisesi/Documents/allfiles/copy.txt\");\n      Path srcParent = src.getParent();\n      System.out.println(srcParent);\n      \n    }\n\n}','IO',0,0,NULL,5),(948,'0\nyyxxxyxx\n8\n\n* is greedy so it reads then entire source then works backward, until it finds\nthe rightmost match. ',' public static void main(String[] args){\n        //five letter words\n        Pattern p = Pattern.compile(\".*xx\");\n        Matcher m = p.matcher(\"yyxxxyxx\");\n        \n        while(m.find()){\n            System.out.println(m.start());\n            System.out.println(m.group());\n		  System.out.println(m.end());\n        }\n        \n      \n    }','Strings',0,0,NULL,5),(949,'0\nyyxxxy\n6\n\ngreedy reads the whole source data first','public static void main(String[] args){\n        //five letter words\n        Pattern p = Pattern.compile(\".*y\");\n        Matcher m = p.matcher(\"yyxxxyxx\");\n        \n        while(m.find()){\n            System.out.println(m.start());\n            System.out.println(m.group());\n            System.out.println(m.end());\n        }\n        \n      \n    }','Strings',0,0,NULL,5),(950,'This pattern says its looking for zero or more digits, \nso at the positions other than 2 5 and 11 it does find 0 digits\n\n0:__\n1:__\n2:_4_\n3:__\n4:__\n5:_89_\n7:__\n8:__\n9:__\n10:__\n11:_90_\n13:__\n14:__\n\n',' public static void main(String[] args){\n        //five letter words\n        Pattern p = Pattern.compile(\"\\\\d*\");\n        Matcher m = p.matcher(\"yy4xx89xxye90g\");\n        \n        while(m.find()){\n            System.out.println(m.start()+\":_\"+m.group()+\"_\");\n        }\n        \n      \n    }','Strings',0,0,NULL,5),(951,'Greedy will allow zero length matches, proven by the start and end indexs being \nthe same.\n\n0:_a_:1\n1:__:1\n2:_a_:3\n3:_a_:4\n4:__:4\n5:__:5\n6:__:6\n7:_a_:8\n8:_a_:9\n9:_a_:10\n10:__:10\n11:__:11\n12:_a_:13\n13:_a_:14\n14:_a_:15\n15:__:15','public static void main(String[] args){\n        //five letter words\n        Pattern p = Pattern.compile(\"a?\");\n        Matcher m = p.matcher(\"abaabbbaaabbaaa\");\n        \n        while(m.find()){\n            System.out.println(m.start()+\":_\"+m.group()+\"_:\"+m.end());\n        }\n        \n      \n    }','Strings',0,0,NULL,5),(952,'hello\nmy\ndarling','public class Hello {\n    public static void main(String[] args){\n        String[] tokens = \"hello my darling\".split(\" \");\n        \n        for(String s : tokens){\n            System.out.println(s);\n        }\n    }\n\n}','Strings',0,0,NULL,5),(953,'hello\nmy\ndarling','public static void main(String[] args){\n        String[] tokens = \"hello5my5darling\".split(\"\\\\d\");\n        \n        for(String s : tokens){\n            System.out.println(s);\n        }\n    }','Strings',0,0,NULL,5),(954,'b\ni\ng\ni\nb\nh\nj\nv\nu\n \nl\no\nu\nf\n \nk\nv\nc\ni\ny','public static void main(String[] args){\n        String[] tokens = \"bigibhjvu louf kvciy\".split(\"\");\n        \n        for(String s : tokens){\n            System.out.println(s);\n        }\n    }','Strings',0,0,NULL,5),(955,'whitespace','what is scanners default delemiter','Strings',0,0,NULL,5),(956,'01234456','public static void main(String[] args){\n        Pattern p = Pattern.compile(\"\\\\d*\");\n        Matcher m = p.matcher(\"ab34ef\");\n        while(m.find()){\n            System.out.print(m.start() + m.group());\n        }\n    }','Strings',0,0,NULL,5),(957,'0123445687891234514','public static void main(String[] args){\n        Pattern p = Pattern.compile(\"\\\\d*\");\n        Matcher m = p.matcher(\"ab34ef8hk12345\");\n        while(m.find()){\n            System.out.print(m.start() + m.group());\n        }\n    }','Strings',0,0,NULL,5),(958,'\n\n\n\n\n\n\n\n\n\n\nException in thread \"main\" java.util.MissingResourceException: \nCan\'t find bundle for base name NickNames, locale en_US\n\n\n\n\n\n\n\n\n\n\n\n','public class Hello {\n    public static void main(String[] args){\n        ResourceBundle rb = ResourceBundle.getBundle(\"NickNames\");\n        System.out.println(rb.getString(\"Max Bisesi\"));\n        \n    }\n}\n\nclass NickNames extends ListResourceBundle {\n    protected Object[][] getContents(){\n        return new Object[][]{{\"hello\",\"from java\"},{\"Max Bisesi\",\"Big Bad Max\"},{\"Garret Gieske\", \"gieske\"}};\n    }\n}','Locale',0,0,NULL,5),(959,'en_US\nde_DE','public static void main(String[] args){\n       Locale initial = Locale.getDefault();\n        System.out.println(initial);\n        \n        Locale.setDefault(Locale.GERMANY);\n        System.out.println(Locale.getDefault());\n        \n    }','Locale',0,0,NULL,5),(960,'ResourceBundle.getBundle(basename);\nResourceBundle.getBundle(basename, locale);\n\nfirst uses default locale','two ways to get a ResourceBundle: ?','Locale',0,0,NULL,5),(961,'got it !','Java chooses the most specific resource bundle it can while while giving\npreference to java ListResourceBundle','Locale',0,0,NULL,5),(962,'RB_fr_CA.java // a java class mathcing excactly\nRB_fr_CA.properties // then it looks for exectaly matching property files\n\nRB_fr.java\nRB_fr.properites // if it cant find both it will look for the Language\n\n\nRB_en_US.java\nRB_en_US.poperties   // use the default locale instead\n\nRB_en.java\nRB_en.properties   //just llook for the default language\n\nRB.java\nRB.properties    //try default Bundle name','request french canadian resource bundle\n\nLocale loc = new Locale(\"fr\",\"CA\");\nResourceBundle rb = ResourceBundle.getBundle(\"RB\",loc);\n\nhow will java search for that bundle ?','Locale',0,0,NULL,5),(963,'missingresourceexception','What happens if java cant find a resourceBundle','Locale',0,0,NULL,5),(964,'Take a ride in the lift','ResourceBundles can inherit properties from parents\n\nRB_en.properties\n	ride.in=Take a ride in\n\nRB_en_US.properties\n	elevator=elevator\n\nRB_en_UK.properties\n	elevator=lift\n\nLocale locale = new Locale(\"en\",\"UK\");\nResourceBundle rb = ResourceBundle.getBundle(\"RB\",locale);\nsout(rb.getString(\"ride.in\") + rb.getString(\"elevator\"));','Locale',0,0,NULL,5),(965,'MissingResourceException','public static void main(String[] args){\n      ResourceBundle rb = ResourceBundle.getBundle(\"Flag\",new Locale(\"en_CA\"));\n        System.out.println(rb.getString(\"key\"));\n        \n    }\n\nthere are no resourcebundles loaded','Locale',0,0,NULL,5),(966,'Flag_en_CA.properties\nFlag_en.java\nFlag_en.properties\nFlag.properties','public static void main(String[] args){\n      ResourceBundle rb = ResourceBundle.getBundle(\"Flag\",new Locale(\"en_CA\"));\n        System.out.println(rb.getString(\"key\"));\n        \n    }\n\ndefault locale is Italian if there is only one resource bundle on the classpath\nhow will java search for that bundle based on the above ?','Locale',0,0,NULL,5),(967,'Flag_en.properties\n\nFlag_fr_CA.properties the language does not match\n\nFlag_CA.properties, CA is not a valid lang code','public static void main(String[] args){\n      ResourceBundle rb = ResourceBundle.getBundle(\"Flag\",new Locale(\"en_CA\"));\n        System.out.println(rb.getString(\"key\"));\n        \n    }\n\nwhich will be chosen ?\n\nFlag_fr_CA.properties\nFlag_en.properties\nFlag_CA.properties ','Locale',0,0,NULL,5),(968,'1 \n3 \n6 \n8 \n9 \n11 \n\n\\\\b says that the number reported is the end of a boundary between a wordcharacter\nand a non word character,\n\nbetween 0 and 1 is a boundary between a word and a non word.\n\nimagine the end and beginning of a string is an invisible non word.\nposition 0 was not returned here because ^ is non word and that against the \ninvisble non word is not a boundary','public static void main(String[] args){\n      Pattern p = Pattern.compile(\"\\\\b\");\n      Matcher m = p.matcher(\"^23 *$76 bc\");\n      while(m.find()){\n          System.out.println(m.start()+\" \");\n      }\n        \n    }','Locale',0,0,NULL,5),(969,'1\n3\n4\n6','  public static void main(String[] args){\n      Pattern p = Pattern.compile(\"\\\\b\");\n      Matcher m = p.matcher(\"#ab de#\");\n      while(m.find()){\n          System.out.println(m.start()+\" \");\n      }\n        \n    }','Locale',0,0,NULL,5),(970,'0 \n2 \n5 \n7\n\nif there is a non word boundary between the last character and \nthe invible end of string non word boundary then start will give \nthe very last character index, where normally it would give the second \nindex of the two characters creating the non word boudary. ',' public static void main(String[] args){\n      Pattern p = Pattern.compile(\"\\\\B\");\n      Matcher m = p.matcher(\"#ab de#\");\n      while(m.find()){\n          System.out.println(m.start()+\" \");\n      }\n        \n    }','Strings',0,0,NULL,5),(971,'0 \n4 \n8 \n9','public static void main(String[] args){\n      Pattern p = Pattern.compile(\"\\\\b\");\n      Matcher m = p.matcher(\"abci####r\");\n      while(m.find()){\n          System.out.println(m.start()+\" \");\n      }\n        \n    }','Locale',0,0,NULL,5),(972,'something like this ^^rt##r\n\nthe output is determined by the difference between a boundary adn a word boundary\n\n','when searched using \\\\b what string would give the result: 2467 ?','Strings',0,0,NULL,5),(973,'^^^^^^^\n\nimagine Strings contain non word characters at the beginning and end of\neach string. Here, \\\\B is saying that there is NOT a word boundary between\nthe imaginary non word character that represents the beginning of the string\nand the first ^ symbol because they are both non words.\n\nThen there is NOT a word boundary between the first and subsequent ^ symbols\nbecause they are all non words. ','when searched with \\\\B what string could give 1234567 ? ','Locale',0,0,NULL,5),(974,'..\n. a.\n. b .\n. c.\n.d .\n.e.\n\nif the first character in the String is a delimter the first array\nelement will be an empty token','public static void main(String[] args){\n        String[] chunks = \"1 a2 b 3 c4d 5e\".split(\"\\\\d\");\n        \n        for(String s : chunks){\n            System.out.println(\".\"+s+\".\");\n        }\n        \n    }','Locale',0,0,NULL,5),(975,'got it ','if the first character in the String is a delimter the first array\nelement will be an empty token','Locale',0,0,NULL,5),(976,'Changed line5 to new Locale(\"en\",\"UK\")','Train_en_US.properties: train=subway\nTrain_en_UK.properties: train=undergroudn\nTrain_en_.properties: ride = ride;\n\npublic class Choochoo {\n	public static void main(String[] args) {\n		Locale.setDefault(new Locale(\"en\",\"US\"));\n		ResourceBundle rb = \n	ResourceBundle.getBundle(\"Train\",new Locale(\"en\",\"US\"));\n		sout( rb.getString(\"ride\")+\" \"+rb.getString(\"train\"));\n	}\n}\n\nwhich change can you make independently to change the output to \"ride underground\"\n\nchange line 1 to Locale.setDefault(new Locale(\"en\",\"UK));\nAdd train=underground to Train_en.porperties\nchange line5 to new Locale(\"en\",\"UK\"));\nDelete Train_en_US.properties','Locale',0,0,NULL,5),(977,'go it ','when using StringBuilder if you append past the current capacity it\ncan be automatically increased.\n\nif you insert past it you will receive an exception','Locale',0,0,NULL,5),(978,'0  \n9 abcdef789','public static void main(String[] args){\n        StringBuilder sb = new StringBuilder(8);\n        System.out.println(sb.length() + \" \" + sb + \" \");\n        sb.insert(0,\"abcdef\");\n        sb.append(\"789\");\n        System.out.println(sb.length() + \" \" + sb);   \n    }','Locale',0,0,NULL,5),(979,'0  \n10 abcdefghij\n\nthe string builders capacity has been increased automatically','public static void main(String[] args){\n        StringBuilder sb = new StringBuilder(8);\n        System.out.println(sb.length() + \" \" + sb + \" \");\n        sb.insert(0,\"abcdefghij\");\n        System.out.println(sb.length() + \" \" + sb);   \n    }','General',0,0,NULL,5),(980,'will not compile, there is no method getInteger();','public class Hello {\n    public static void main(String[] args){\n        ResourceBundle rb = ResourceBundle.getBundle(\"NickNames\",Locale.getDefault());\n        Object ob = rb.getInteger(\"123\");\n        \n    }\n}\n\nclass NickNames extends ListResourceBundle {\n    protected Object[][] getContents(){\n        return new Object[][]{{\"hello\",\"from java\"},{\"Max Bisesi\",\"Big Bad Max\"},{\"Garret Gieske\", \"gieske\"},{\"123\",678}};\n    }\n}','General',0,0,NULL,5),(981,'ClassCastException\n\nyoou can either use getString to get a string or getObject to get anything else\nbut you cannot use getString to get an object','public class Hello {\n    public static void main(String[] args){\n        ResourceBundle rb = ResourceBundle.getBundle(\"Hello.NickNames\",Locale.getDefault());\n        Object ob = rb.getString(\"123\");\n        \n    }\n}\n\nclass NickNames extends ListResourceBundle {\n    protected Object[][] getContents(){\n        return new Object[][]{{\"hello\",\"from java\"},{\"Max Bisesi\",\"Big Bad Max\"},{\"Garret Gieske\", \"gieske\"},{\"123\",678}};\n    }\n}','General',0,0,NULL,5),(982,'abcd abc false\nabcd abcd true\n\nstring objects are immutable references are mutable\n\nSo here, when the s1+=\"d\" executes. The String \"abc\" was once referenced\nby s1 but it not longer is. Now it is referenced by s2. a New String object\nis created abcd and s1 is reassinged to reference that.','public static void main(Sa) {\n	String s1 = \"abc\";\n	String s2 = s1;\n	s1 += \"d\";\n	sout(s1+\" \"+s2+\" \"+ (s1==s2));\n	\n	StringBuffer sb1 = new StringBuffer(\"abc\");\n	StringBuffer sb2 = sb1;\n	sb1.append(\"d\");\n	sout(sb1+ \" \" + sb2 + \" \" + (sb1==sb2));\n}','General',0,0,NULL,5),(983,' maxy  denny \n\nstrings are immutable, when s.trim() is executed a new String is created\nand a reference to it is returned then immediately lost. s and x remain\npointing to the strings \" maxy \" and \" denny \".\n','public class Hello {\n    public static void main(String[] args){\n       String s = \" maxy \";\n       String x = \" denny \";\n       s.trim();\n       x.trim();\n       String y = s+x;\n       \n        System.out.println(y);\n    }\n}','General',0,0,NULL,5),(984,'987.12346 // rounds doesn\'t truncate\n987.123456 // setMaxFracDigs applies to formating but not parsing','String s = \"987.123456\";\ndouble d = 987.123456d;\nNumberFormat nf = NumberFormat.getInstance();\nnf.setMaximumFractionDigits(5);\nsout(nf.format(d) + \" \");\ntry {\n	sout(nf.parse(s));\n} catch(ParseException e){ }','General',0,0,NULL,5),(985,'3\n\n\\\\d looks for digits\n\n+ says one or more ','public static void main(String[] args){\n        Pattern p = Pattern.compile(\"\\\\d+\");\n        Matcher m = p.matcher(\"ab2c4d67\");\n        int count = 0;\n        while(m.find()){\n            count++;\n        }\n        System.out.println(count);\n    }','Strings',0,0,NULL,5),(986,'this one is confusing but remember + is greedy\n\nits not a series of word characters in this case the whole damn thing is \none word character',' public static void main(String[] args){\n        Pattern p = Pattern.compile(\"\\\\w+\");\n        Matcher m = p.matcher(\"ab2c4d67\");\n        int count = 0;\n        while(m.find()){\n            count++;\n        }\n        System.out.println(count);\n    }','Strings',0,0,NULL,5),(987,'1\n\nthe whole string is one long non whitespace character and + is greedy\nso it took the whole thing','public static void main(String[] args){\n        Pattern p = Pattern.compile(\"\\\\S+\");\n        Matcher m = p.matcher(\"ab2c4d67\");\n        int count = 0;\n        while(m.find()){\n            count++;\n        }\n        System.out.println(count);\n    }','Strings',0,0,NULL,5),(988,'1\n\n+ is greedy so this whole number is one big digit, greedy took the whole \nthing',' public static void main(String[] args){\n        Pattern p = Pattern.compile(\"\\\\d+\");\n        Matcher m = p.matcher(\"78254467\");\n        int count = 0;\n        while(m.find()){\n            count++;\n        }\n        System.out.println(count);\n    }','Strings',0,0,NULL,5),(989,'1\n\nthe whole string is one big non word character so the greedy + took the whole\nthing','public static void main(String[] args){\n        Pattern p = Pattern.compile(\"\\\\W+\");\n        Matcher m = p.matcher(\"$%^&*\");\n        int count = 0;\n        while(m.find()){\n            count++;\n        }\n        System.out.println(count);\n    }','Strings',0,0,NULL,5),(990,'1 2 followed by an exception','psvm(Sa){\n	String input = \"1 2 a 3 45 6\";	\n	Scanner sc = new Scanner(input);\n	int x = 0;\n	do {\n		x = sc.nextInt();\n		sout(x);	\n	} while(x!=0);\n}','General',0,0,NULL,5),(991,' When the syntax is \"glob\" then the String representation of the path is matched using a limited pattern language that resembles regular expressions but with a simpler syntax. For example:\n\n    *.java 	Matches a path that represents a file name ending in .java\n    *.* 	Matches file names containing a dot\n    *.{java,class} 	Matches file names ending with .java or .class\n    foo.? 	Matches file names starting with foo. and a single character extension\n    /home/*/* 	Matches /home/gus/data on UNIX platforms\n    /home/** 	Matches /home/gus and /home/gus/data on UNIX platforms\n    C:\\\\* 	Matches C:\\foo and C:\\bar on the Windows platform (note that the backslash is escaped; as a string literal in the Java Language the pattern would be \"C:\\\\\\\\*\")\n\nThe following rules are used to interpret glob patterns:\n\n    The * character matches zero or more characters of a name component without crossing directory boundaries.\n\n    The ** characters matches zero or more characters crossing directory boundaries.\n\n    The ? character matches exactly one character of a name component.\n\n    The backslash character (\\) is used to escape characters that would otherwise be interpreted as special characters. The expression \\\\ matches a single backslash and \"\\{\" matches a left brace for example.\n\n    The [ ] characters are a bracket expression that match a single character of a name component out of a set of characters. For example, [abc] matches \"a\", \"b\", or \"c\". The hyphen (-) may be used to specify a range so [a-z] specifies a range that matches from \"a\" to \"z\" (inclusive). These forms can be mixed so [abce-g] matches \"a\", \"b\", \"c\", \"e\", \"f\" or \"g\". If the character after the [ is a ! then it is used for negation so [!a-c] matches any character except \"a\", \"b\", or \"c\".\n\n    Within a bracket expression the *, ? and \\ characters match themselves. The (-) character matches itself if it is the first character within the brackets, or the first character after the ! if negating.\n\n    The { } characters are a group of subpatterns, where the group matches if any subpattern in the group matches. The \",\" character is used to separate the subpatterns. Groups cannot be nested.\n\n    Leading period/dot characters in file name are treated as regular characters in match operations. For example, the \"*\" glob pattern matches file name \".login\". The Files.isHidden(java.nio.file.Path) method may be used to test whether a file is considered hidden.\n\n    All other characters match themselves in an implementation dependent manner. This includes characters representing any name-separators.\n\n    The matching of root components is highly implementation-dependent and is not specified.\n\nWhen the syntax is \"regex\" then the pattern component is a regular expression as defined by the Pattern class.\n\nFor both the glob and regex syntaxes, the matching details, such as whether the matching is case sensitive, are implementation-dependent and therefore not specified.','Glob rules','Strings',0,0,NULL,5),(992,'Exception in thread \"main\" java.lang.IllegalArgumentException\n\ngetPathMatcher() argument must take the form:\n\n	syntax:pattern\n\nspecify glob or regex ','public class Hello {\n    public static void main(String[] args) {\n        PathMatcher matcher = FileSystems.getDefault().getPathMatcher(\"*\");\n        Path p1 = Paths.get(\"One.java\");\n        \n        System.out.println(matcher.matches(p1));\n\n    }\n\n}','Strings',0,0,NULL,5),(993,'false, \nthe space after \'glob:\' matters. \n\nto give expected behavior take that space away.','public class Hello {\n    public static void main(String[] args) {\n        PathMatcher matcher = FileSystems.getDefault().getPathMatcher(\"glob: *\");\n        Path p1 = Paths.get(\"One.java\");\n        \n        System.out.println(matcher.matches(p1));\n\n    }\n\n}','Strings',0,0,NULL,5),(994,'true,\n\nin glob * means any string inside directory bounds','public class Hello {\n    public static void main(String[] args) {\n        PathMatcher matcher = FileSystems.getDefault().getPathMatcher(\"glob:*\");\n        Path p1 = Paths.get(\"One.java\");\n        \n        System.out.println(matcher.matches(p1));\n\n    }\n\n}','Strings',0,0,NULL,5),(995,'p1 could be:\n\"glob:*\" \"glob:**\" \"glob:*.{java,class}\" \"glob:One.????\"\n\n ','public class Hello {\n    public static void main(String[] args) {\n        PathMatcher matcher = FileSystems.getDefault().getPathMatcher(\"glob:\");\n        Path p1 = Paths.get(\"One.java\");\n        Path p2 = Paths.get(\"/home/Files/two.txt\");\n        Path p3 = Paths.get(\"/home/Pictures/amy1.pic\");\n        \n        System.out.println(matcher.matches(p1));\n        System.out.println(matcher.matches(p2));\n        System.out.println(matcher.matches(p3));\n\n    }\n\n}\ncreate a glob to match each of these paths','Strings',0,0,NULL,5),(996,'true\ntrue\ntrue\n\nin a bracketed expression * ? and / match themselves\n\n* matches anything within a directory boundary','public class Hello {\n    public static void main(String[] args) {\n        PathMatcher matcher = FileSystems.getDefault().getPathMatcher(\"glob:*{*txt,*pic,/dir}\");\n        Path p1 = Paths.get(\"files.*txt\");\n        Path p2 = Paths.get(\"pictures.*pic\");\n        Path p3 = Paths.get(\"home/dir\");\n        \n        System.out.println(matcher.matches(p1));\n        System.out.println(matcher.matches(p2));\n        System.out.println(matcher.matches(p3));\n    }\n\n}','Strings',0,0,NULL,5),(997,'false \nfalse\ntrue\n\n* doesn\'t work accross directory bounds ','public class Hello {\n    public static void main(String[] args) {\n        PathMatcher matcher = FileSystems.getDefault().getPathMatcher(\"glob:*{*txt,*pic,/dir}\");\n        Path p1 = Paths.get(\"home/files.*txt\");\n        Path p2 = Paths.get(\"documents/pictures.*pic\");\n        Path p3 = Paths.get(\"home/dir\");\n        \n        System.out.println(matcher.matches(p1));\n        System.out.println(matcher.matches(p2));\n        System.out.println(matcher.matches(p3));\n    }\n\n}','Strings',0,0,NULL,5),(998,'will not compile the proper syntax is:\n\n	FileSystems.getDefault().getPathMatcher()','public class Hello {\n    public static void main(String[] args) {\n        PathMatcher matcher = FileSystems.getPathMatcher(\"glob:*{*txt,*pic,/dir}\");\n        Path p1 = Paths.get(\"home/files.*txt\");\n        Path p2 = Paths.get(\"documents/pictures.*pic\");\n        Path p3 = Paths.get(\"home/dir\");\n        \n        System.out.println(matcher.matches(p1));\n        System.out.println(matcher.matches(p2));\n        System.out.println(matcher.matches(p3));\n    }\n\n}','Strings',0,0,NULL,5),(999,'you can also do this to use regex instead of glob.\n\nhere they would all say \'true\'','public class Hello {\n    public static void main(String[] args) {\n        PathMatcher matcher = FileSystems.getDefault().getPathMatcher(\"regex:.*\");\n        Path p1 = Paths.get(\"home/files.*txt\");\n        Path p2 = Paths.get(\"documents/pictures.*pic\");\n        Path p3 = Paths.get(\"home/dir\");\n        \n        System.out.println(matcher.matches(p1));\n        System.out.println(matcher.matches(p2));\n        System.out.println(matcher.matches(p3));\n    }\n\n}','Strings',0,0,NULL,5),(1000,'will not compile, \n\nGazer is declared after it is used in a method,thats not allowed move it to before','public class Hello {\n	private int size = 7;\n	private static int length = 3;\n	public static void main(String[] args) {\n		new Hello().go();\n	}\n	void go(){\n		int size = 5;\n                 System.out.println(new Gazer().adder());\n                 \n                 class Gazer {\n                     private int size = 6;\n                      int adder() { return size * length; }\n                }\n	}\n	\n}','Strings',0,0,NULL,5),(1001,'WNC,  \n\nlocal variable size is accessed from within inner class needs to be final,\n\n\n	','public class Hello {\n	private int size = 7;\n	private static int length = 3;\n	public static void main(String[] args) {\n		new Hello().go();\n	}\n	void go(){\n		int size = 5;\n                class Gazer {\n                      int adder() { return size * length; }\n                }\n                 System.out.println(new Gazer().adder());\n	}\n}','Strings',0,0,NULL,5),(1002,'21\n\nnothing wrong here, instances can access statics just not the other way around!','public class Hello {\n	private int size = 7;\n	private static int length = 3;\n	public static void main(String[] args) {\n		new Hello().go();\n	}\n	void go(){\n                class Gazer {\n                      int adder() { return size * length; }\n                }\n                 System.out.println(new Gazer().adder());\n	}\n}','Inner Classes',0,0,NULL,5),(1003,'WNC\n\nsuper to bound a named type parameter (e.g. <S super T>) as opposed to a wildcard (e.g. <? super T>) is ILLEGAL simply because even if it\'s allowed, it wouldn\'t do what you\'d hoped it would do, because since Object is the ultimate super of all reference types, and everything is an Object, in effect there is no bound.\n\nIn your specific example, since any array of reference type is an Object[] (by Java array covariance), it can therefore be used as an argument to <S super T> S[] toArray(S[] a) (if such bound is legal) at compile-time, and it wouldn\'t prevent ArrayStoreException at run-time.\n\nWhat you\'re trying to propose is that given:\n\nList<Integer> integerList;\n\nand given this hypothetical super bound on toArray:\n\n<S super T> S[] toArray(S[] a) // hypothetical! currently illegal in Java\n\nthe compiler should only allow the following to compile:\n\nintegerList.toArray(new Integer[0]) // works fine!\nintegerList.toArray(new Number[0])  // works fine!\nintegerList.toArray(new Object[0])  // works fine!\n\nand no other array type arguments (since Integer only has those 3 types as super). That is, you\'re trying to prevent this from compiling:\n\nintegerList.toArray(new String[0])  // trying to prevent this from compiling\n\nbecause, by your argument, String is not a super of Integer. However, Object is a super of Integer, and a String[] is an Object[], so the compiler still would let the above compile, even if hypothetically you can do <S super T>!\n\nSo the following would still compile (just as the way they are right now), and ArrayStoreException at run-time could not be prevented by any compile-time checking using generic type bounds:\n\nintegerList.toArray(new String[0])  // compiles fine!\n// throws ArrayStoreException at run-time\n\nGenerics and arrays don\'t mix, and this is one of the many places where it shows.\nA non-array example\n\nAgain, let\'s say that you have this generic method declaration:\n\n<T super Integer> void add(T number) // hypothetical! currently illegal in Java\n\nAnd you have these variable declarations:\n\nInteger anInteger\nNumber aNumber\nObject anObject\nString aString\n\nYour intention with <T super Integer> (if it\'s legal) is that it should allow add(anInteger), and add(aNumber), and of course add(anObject), but NOT add(aString). Well, String is an Object, so add(aString) would still compile anyway.','public class Hello<T> {\n    \n    public static void main(String[] args){\n        \n        Dog d = new Dog();\n        \n        ArrayList<?> c = makeArrayList(new Animal());\n        \n\n    } \n    public static <G super Dog> ArrayList<G> makeArrayList(G g){\n        ArrayList<G> genlist = new ArrayList<>();\n        genlist.add(g);\n        return genlist;\n        \n    }\n}\n\nclass Animal{}\nclass Dog extends Animal{}','Generics',0,0,NULL,5),(1004,'will not compile to import a static member an import sattemten must say \nimport static wiht either a wildcard or excplicity the member to be imported','package xcom;\npublic class Stuff{\n	public static int MY_COSTANT = 5;\n	public static int dosStuff(int x) { return (x++)*x; }\n}\n\nimport static xcom.Stuff;\nimport static java.lang.System;\nclass User {\n	public static void mian(SA){\n		new User().go()\n	}\n	void go(){\n			out.println(doStuff(MY_CONSTANT);\n	}\n}','General',0,0,NULL,5),(1005,'WNC,\n\nsubmitting a Callable to an ExecutorService gets you a Future of the type \nreturned by the call(), then you get that result from the future with \nget() wich can block.','public class Hello {\n    \n    public static void main(String[] args){\n        Path file = Paths.get(\"~/Public/Data\");\n        FileSearcher fs = new FileSearcher(file,\"\\\\b\\\\W\\\\w+\");\n        ExecutorService es = Executors.newCachedThreadPool();\n        HashMap<Integer,String> searchresults = es.submit(fs);\n        System.out.println(\"We\'re wating on your search results\");\n        Future<HashMap<Integer,String>> futuresearch;\n        \n        try{\n            //HashMap<Integer,String> searchresults = futuresearch.get();\n            searchresults = futuresearch.get();\n            if(searchresults == null){\n                System.out.println(\"There were no results bro\");\n                System.exit(0);\n            }\n            \n        }catch(ExecutionException | InterruptedException e){\n            \n        }\n    }\n}\n\nclass FileSearcher implements Callable<HashMap<Integer,String>> {\n    private Path fileToLoad;\n    private String regex;\n    public FileSearcher(Path file,String reg){\n        fileToLoad = file;\n        regex = reg;\n    }\n    \n    public HashMap<Integer,String> call() throws IOException{\n        int linenum = 0;\n        HashMap<Integer,String> map = new HashMap<>();\n        BufferedReader br = new BufferedReader(new FileReader(fileToLoad.toFile()));\n        Pattern p = Pattern.compile(regex);\n        Matcher m;\n        String line;\n        while((line = br.readLine()) != null){\n            map.put(++linenum,line);\n        }\n        return map;\n    }\n}','Executors',0,0,NULL,5),(1006,'-12\n\nNearly does not properly override equals(Object o).\n\nSo by nearly\'s wrongly implemented equals() they are equal so you get -1\n\nbut Set knows the true equals to use and here it cant find it so it uses\nthe default equal which states that all objects are different and allows in\ntwo identicle objects. ','class Nearly {\n	String value;\n	public Nearly(String v) { value = v; }\n	public int hashCode() { return 1; }\n	public boolean equals(Nearly n){\n		if(value.charAt(0) == n.value.charAt(0)) return true;\n		return false;\n	}\n	psvm(sa){	\n		Nearly n1 = new Nearly(\"aaa\");\n		Nearly n2 = new Nearly(\"aaa\");\n		String s = \"-\";\n		if(n1.equals(n2)) s += \"1\";\n		if(n1 == n2) s += \"2\";\n		Set<Nearly> set = new HashSet<Nearly>();\n		set.add(n1);	\n		set.add(n2);\n		sout( s + set.size() );\n	}\n}','OOP',0,0,NULL,5),(1007,'x5.hashCode() == x6.hashCode()\n\nif the hashcode values are not equal the two objects must not be equal\n\nif equals() is not true there is not guarentee of results from hashcode\n\nhashcode will often return equals values even if the two objects are not equal','x = 0;\nif(x1.hashCode() != x2.hashCode() ) x = x +1;\nif(x3.equals(x4) == false) x = x + 10;\nif(x5.equals(x6) == true) x = x + 100;\nif(x7.hashCode() == x8.hashCode() ) x = x + 1000;\nsout( \"x = \" + x);\n\nif the output is x = 1111 what has to always be true ?\n\nx2.equals(x1) == true\nx3.hashCode() != x4.hashCode()\nx5.hashCode() == x6.hashCode()\nx8.equals(x7) == true','OOP',0,0,NULL,5),(1008,'got it','if the hashcode values are not equal the two objects must not be equal','OOP',0,0,NULL,5),(1009,'','import static statements must import explicitly the members ','OOP',0,0,NULL,5),(1010,'return ((Sortof)o).code.length * ((Sortof)o).bal == this.code.length * this.bal;\n\nreturn ((Sortof)o).code.length * ((Sortof)o).bal * ((Sortof)o).rate == this.code.length * this.bal * this.rate;\n\n\nthe equals algorithm must be at least as precise as hashcode at determining\nwhat is \"meaningfully equivalent\" ','class Sortof {\n	String name;\n	int bal;\n	String code;\n	short rate;\n	public int hashCode() {\n		return (code.length() * bal);\n	}\n	public boolean equals(Object o){\n		//insert here\n	}\n}\n\nhow can you fullfill the equals and hashcode contracts for this class ?\n','OOP',0,0,NULL,5),(1011,'b4 and b8','public class Hello{\n    public static void main(String[] args){\n        Bango b1 = new Bango();\n        Bango b2 = new Bongo();\n        Bango b3 = new Bingo();\n        \n        Bongo b4 = b2;\n        Bongo b5 = (Bongo)b2;\n        Bango b6 = b3;\n        Bango b7 = (Bango) b3;\n        Bingo b8 = b3;\n        Bingo b9 = (Bingo) b3;\n        Bango b10 = (Bongo) b3;\n    \n    }\n}\n\nclass Bango { }\nclass Bongo extends Bango { }\nclass Bingo extends Bongo { }\n\nwhich wont compile ? ','OOP',0,0,NULL,5),(1012,'WILL NOT COMPILE','class Clojure extends FP {\n	boolean typed;\n	public static void main(String[] args){\n		Clojure c = new Clojure();\n		c.monad();\n	}\n	void mondad() {\n		sout(\"foo\");\n	}\n}\n\nclass FP {\n	String name = \"basic\";\n	protected FP(String s){ name = s; }\n}','OOP',0,0,NULL,5),(1013,'Will not compile only instance methods can be overriden and calls to super \nare only for obverridne methods. ','class AlternateFuel {\n	int getRating() { return 42; }\n	static int getRating2() { return 43; }\n}\nclass Bio extends AlternateFuel {\n	psvm(){\n		new Bio().go();\n		sout( super.getRating2() );\n	}\n	void go() {\n		sout( super.getRating() );\n	}\n}','OOP',0,0,NULL,5),(1014,'2 2 1\n\ninstance variables are not overriden, the variable used is related to \nthe reference type. \n\nsuper can be used to access super class instance variables','class Alpha { int over = 1; }\nclass Beta extends Alpha { int over = 2; }\nclass Gamma extends Beta {\n	int over = 3;\n	public static void main(SA){\n		new Gamma().go();\n	}\n\n	void go() {	\n		Beta b = new Gamma();\n		Alpha a = new Gamma();\n		sout( super.over+\" \"+b.over+\" \"+a.over );\n	}\n}','OOP',0,0,NULL,5),(1015,'two legal overrides, one a covariant return\n\ntwo legal overloads ','class Programmer {\n	Programmer debug(){ return this; }\n}\n\nclass SCJP extends Programmer {\n	//insert here\n}\n\nProgrammer debug() { return this; }\nSCJP debug() { return this; }\n\nint debug(int x) { return 1; }\nObject debug(String s){ return this; }','OOP',0,1,NULL,5),(1016,'legal overload\n\nif it were just:\n\nObject debug() that would be an overload and that would not compile because overloads cannot change the return type, unless it is a subclass. \n\noverloads can return a different return type,\n\n','class Programmer {\n	Programmer debug(){ return this; }\n}\n\nclass SCJP extends Programmer {\n	Object debug(String s){ return this; }\n}\n\n','OOP',0,0,NULL,5),(1017,'WNC, they have to be in the same inheritance tree','public class Hello{\n    public static void main(String[] args){\n        Short s = null;\n        \n        boolean b = (s instanceof String);\n    \n    }\n}','OOP',0,0,NULL,5),(1018,'false\n\nif two objects are equal, their hashCodes must be equal\n\nif two objects are not equal, their hashCodes must not be equal. ','Class Dog follows the equals and hashcode contract, x and y are reference variable\nto two Dog objects which are true?\n\nif x.equals(y) is true then x.hashCode() == y.hashCode() may be false\n','OOP',0,0,NULL,5),(1019,'got it','join() throws InterruptedException','Threads',0,0,NULL,5),(1020,'6','public class Hello{\n    public static void main(String[] args){\n        Pattern p = Pattern.compile(\"\\\\W\");\n        Matcher m = p.matcher(\"565757 43353535\");\n        \n        while(m.find()){\n            System.out.println(m.start());\n        }\n        \n    }\n}','Strings',0,0,NULL,5),(1021,'got it','YOU CANT USE SUPER WHEN DEFINING A GENERIC CLASS','Generics',0,0,NULL,5),(1022,'WNC close() throws IOEXception, cannot throw new or broader checked exceptions','class E implements Closeable { public void close() throws Exception {}}','Collections',0,0,NULL,5),(1023,'start() and run()','What methods are defined in the thread class ?','Threads',0,0,NULL,5),(1024,'got it','Both wait() and notify() must be called from a synchronized context\n\nthe wait() method is overloaded to accept a duration','Threads',0,0,NULL,5),(1025,'got it','if a class has synchronized code multiple threads can still access the unsynchronized\ncode\n\nwhen a thread invokes wait() it releases its locks','Threads',0,0,NULL,5),(1026,'notifyAll() would be a mistake since only one waiting thread can have \na widget. \n\nnotify() is better \n\nif they are all notified only one would get the new widget but the others \nwould probably throw an exception since they try to get a widgeth without\ndouble checking if one is available','class Widget { }\nclass WidgetMaker extends Thread {\n    List<Widget> finishedWidget = new ArrayList<Widget>();\n    public void run(){\n        try{\n            while(true){\n                Thread.sleep(2000);\n                Widget w = new Widget();\n                \n                //insert something\n                \n            }\n        } catch(InterruptedException e){ }\n    }\n    \n    public Widget waitForWidget() {\n        synchronized(finishedWidget) {\n            if(finishedWidget.size() == 0){\n                try{\n                    finishedWidget.wait();\n                } catch(InterruptedException e){ }\n            }\n            return finishedWidget.remove(0);\n        }\n    }\n}\n\npublic class Hello extends Thread{\n    private WidgetMaker maker;\n    public Hello(String name, WidgetMaker me){\n        super(name);\n        this.maker = me;\n    }\n    \n    public void run(){\n        Widget w = maker.waitForWidget();\n        System.out.println(getName() + \"got a widget\");\n    }\n   \n    public static void main(String[] args) {\n       WidgetMaker maker = new WidgetMaker();\n       maker.start();\n       new Hello(\"lenny\",maker).start();\n       new Hello(\"Moe\",maker).start();\n       new Hello(\"Ben\",maker).start();\n    }\n}\n\nif each user should get its own widget which no other user is using what should\nyuou put in //insert here ? \n\nsynchronized(finishedWidget){\n	finshedWidget.add(w);\n	finishedWidget.notify();\n}\n\nor \n\nsynchronized(finishedWidget){\n	finshedWidget.add(w);\n	finishedWidget.notifyAll();\n}','Threads',0,0,NULL,5),(1027,'NO, \nThese two run() method lock onto an instance of Hello but there are two \ndifferent instances so that wont prevent thme from running at the same time.\n\nyou can do...\n\n	public void run(){ synchronized(Letters.class){write();} }\n	\n	or\n	\n	public void run(){ synchronized(System.out){ write(); } }\n\nnow they wont run at the same time as they go for the same locks','public class Hello extends Thread{\n    private String name;\n    public Hello(String name){ this.name = name; }\n    public void write() {\n        System.out.println(name);\n        System.out.println(name);\n    }\n    public static void main(String[] args) {\n        new Hello(\"X\").start();\n        new Hello(\"Y\").start(); \n    }\n}\n\nyou want to guarentee that output is XXYY or YYXX how can you do this ?\n\n\npublic synchronized void run() { write(); }\npublic void run(){ synchronized(this){ write(); } }','Threads',0,0,NULL,5),(1028,'This class is thread safe \n\nline a would always print true if a lock were used befor int old','class Calculator {\n    private AtomicInteger i = new AtomicInteger();\n    public void add(int val){\n        int old = i.get();\n        int newval = old + val;\n        System.out.println(i.compareAndSet(old,newval));   //LINE A\n    }\n    public int getValue() {\n        return i.get();\n    }\n}','Concurrency',0,0,NULL,5),(1029,'class Asynchronous implements Runnable\nclass Asynchronous implements Callable<String>\n\nif the object sent to submit is a Runnable, the submit method will return\nan instance of Future whos get method will return null\n\notherwise Futures get method will return a type of the Type of class of Callable','public class Hello {\n    ExecutorService service = Executors.newFixedThreadPool(8);\n    \n        public void runAsynchronously(Asynchronous object){\n            Future<?> result = service.submit(object);\n        }\n        \n }\n\nwhat is a valid declaration of Asynchronous ?\n','Concurrency',0,0,NULL,5),(1030,'got it','ExecutorService method:\n\nsubmit\n\nFuture<?> submit(Runnable task)\n\nSubmits a Runnable task for execution and returns a Future representing that task. \nThe Future\'s get method will return null upon successful completion.','Concurrency',0,0,NULL,5),(1031,'executing a runnable\nnull','public class Hello {\n\n    private static ExecutorService service = Executors.newFixedThreadPool(8);\n\n    public static void runAsynchronously(Asynchronous object) {\n        Future<?> result = service.submit(object);\n        try{\n            System.out.println(result.get());\n        } catch(InterruptedException | ExecutionException e){ }\n    }\n\n    public static void main(String[] args) {\n        runAsynchronously(new Asynchronous());\n    }\n\n}\n\nclass Asynchronous implements Runnable {\n\n    public void run() {\n        System.out.println(\"executing a runnable\");\n    }\n}','Concurrency',0,0,NULL,5),(1032,'yes,\n\nyou could also use Atomic integer with getAndIncrement and getAndDecrement\ninstead of value and the lock ','public class Hello {\n    private Lock lock = new ReentrantLock();\n    private int value = 0;\n    public void increment(){\n        lock.lock();\n        value++;\n        lock.unlock();\n    }\n    public void decrement(){\n        lock.lock();\n        value--;\n        lock.unlock();\n    }\n    public int getValue(){\n        return value;\n    }\n    public static void main(String[] args){\n        \n    }    \n}\n\nis this class thread safe ?','Concurrency',0,0,NULL,5),(1033,'WNC fj should be a ForkJoinPool and use ivoke instead of submit','public static void main(SA) { \n	int[] myData = new int[10000000];\n	ForkJoin fj = new ForkJoin();\n\n	MyRecursiveInitClass action = new MyRecursiveInitClass(x,y,mydata);\n\n	fj.submit(action);\n\n	doStuff(myData);\n}\n\n','Concurrency',0,0,NULL,5),(1034,'true got it','A ForkJoinPool implements Executor and ExecutorService\n\nextends AbstractExecutorService','Concurrency',0,0,NULL,5),(1035,'got it','ForkJoinPool is a ExecutorService\n\nthe implementation of the compute() in ForkJoinTask the fork method should \nalways be be called before the join() or the invokeAll()\n\ninvoke() from class ForkJoinPool only accpts as parameters istances of \nForkJoinTask \n\nif the algorithim does not have to return a value you should extends RecursiveAction\nnot RecursiveTask\n\nForkJoinPool is a ExecutorService so it can be usd to process a Callable\nvia the submit method.','Concurrency',0,0,NULL,5),(1036,'200 is printed this does not throw a ConcurrentModificationException because\na CopyOnWriteArrayList allows modifications while being iterated.\n\n\n\n','public class ConcurrentModification {\nList<Integer> list = new CopyOnWriteArrayList<>();\n\npublic void work(){\n	Iterator<Integer> iter = list.iterator();\n	while(it.hasNext()){\n		it.next();\n		list.add(100);\n	}\n	sout( list.size() );\n	}\n}','Concurrency',0,0,NULL,5),(1037,'Thread-1removed element: null\nThread-1removed element: null\nThread-1removed element: null\nThread-1removed element: null\nThread-1removed element: null\nThread-0removed element: null\nThread-0removed element: null\nThread-0removed element: null\nThread-0removed element: null\nThread-0removed element: null\nThread-2removed element: null\nThread-3removed element: null\nThread-2removed element: null\nThread-3removed element: null\nThread-2removed element: null\nThread-3removed element: null\nThread-2removed element: null\nThread-3removed element: null\nThread-2removed element: null\nThread-3removed element: null\n\npeek() returns null if empty','public class Hello implements Runnable {\n    private static ArrayBlockingQueue<Integer> abq = new ArrayBlockingQueue<>(10);\n    public static void main(String[] args){\n       Hello h = new Hello();\n       Thread t1 = new Thread(h);\n       Thread t2 = new Thread(h);\n       Thread t3 = new Thread(h);\n       Thread t4 = new Thread(h);\n       \n       t1.start();\n       t2.start();\n       t3.start();\n       t4.start();\n       \n    }\n    public void run(){\n        for(int i = 0; i<5; i++){\n            System.out.println(Thread.currentThread().getName()+\"removed element: \"+abq.peek());\n        }\n        \n    }\n}','Concurrency',0,0,NULL,5),(1038,'got it ','ArrayBlockingQueue\n\n\npeek() returns null if empty','Concurrency',0,0,NULL,5),(1039,'got it ','peek() and poll() in interface Queue return null if empty','General',0,0,NULL,5),(1040,'WNC enum types must not be local','public class Hello {\n    enum A { A };\n    public static void main(String[] args) {\n        enum B{ B };\n    }\n}\nenum C{ C }','General',0,0,NULL,5),(1041,'\n\nEnums are static nested classes because they define static member variables \n(the enum values), and this is disallowed for inner classes: \nhttp://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.1.3\n\nUpdate: I was looking through the JLS (java language specification) for\n more detail on the restrictions of static nested classes, and didn\'t find \nit (although it\'s probably there, hidden under a different topic). From a \npure implementation perspective, there\'s no reason that this couldn\'t be \ndone. \n\nAs a comment: if your methods are large enough that they require their own \nenums, then it\'s a strong sign that you need refactoring.\n','enums cant be local to a method ','General',0,0,NULL,5),(1042,'WNC cannot override final methods','public class Hello extends Flipper {\n    public static void main(String[] args) {\n        \n    }\n    public void flip(){System.out.println(\"hello\");}\n}\nclass Flipper {\n    public final void flip() { System.out.println(\"flip\"); }\n}','General',0,0,NULL,5),(1043,'-ss\n\n{ go() } is an instance block, so it is not called until instantiation, which never happens here. ','public class Hello{\n    static String s = \"-\";\n    \n    public static void main(String[] args) {\n        go();\n        System.out.println(s);\n    }\n    { go(); }\n    static { go(); }\n    static void go(){ s+=\"s\"; }\n}','OOP',0,0,NULL,5),(1044,'compiles fine how to use an enum','public class Hello{\n    \n    public static void main(String[] args) {\n       Bigger.Faster bf = Bigger.Faster.HIGHER;\n    }\n   \n}\nclass Bigger {\n    enum Faster { HIGHER,  LONGER };\n}','General',0,0,NULL,5),(1045,'WNC,\n\nthe constants are declared with String constructors so the default constructor\nwont do. ','public class Hello{\n    \n    public static void main(String[] args) {\n        System.out.println(Bulbs.ON);\n    }\n   \n}\nenum Bulbs{ ON(\"Bright\"), OFF(\"Dim\") };','General',0,0,NULL,5),(1046,'how to contruct a string argumnet enum constant','public class Hello{\n    \n    public static void main(String[] args) {\n        System.out.println(Bulbs.ON);\n    }\n   \n}\nenum Bulbs{ \n    ON(\"Bright\"), OFF(\"Dim\");\n    \n    String name;\n\n    Bulbs(String x){ name = x; }\n};','General',0,0,NULL,5),(1047,'WNC enum constructos cannot be public or protected.\n\nThe constructor for an enum type must be package-private or private access.\'\n It automatically creates the constants that are defined at the beginning \nof the enum body. You cannot invoke an enum constructor yourself. \n\nThink of Enums as a class with a finite number of instances. \nThere can never be any different instances beside the ones you initially\n declare.\n\nThus, you cannot have a public or protected constructor, because that would\n allow more instances to be created.','public class Hello{\n    \n    public static void main(String[] args) {\n        System.out.println(Bulbs.ON);\n    }\n   \n}\nenum Bulbs{ \n    ON(\"Bright\"), OFF(\"Dim\");\n    \n    String name;\n\n    public Bulbs(String x){ name = x; }\n};','General',0,0,NULL,5),(1048,'B \nC \nb-m1\nB \nC \nc-m1\nB \nC \n\nabstract classes can have constructors, when a subclass constructor is called\nit calls its super first.\n\n','public class Hello extends B{\n    void m1() { System.out.println(\"c-m1\"); }\n    void m2() { }\n    \n    public static void main(String[] args) {\n        new Hello().go();\n        new Hello().m1();\n        new Hello().m2();\n    }\n    \n    void go(){ super.m1(); }\n    Hello(){ System.out.println(\"C \"); }\n}\nabstract class B {\n    void m1() { System.out.println(\"b-m1\");}\n    abstract void m2();\n    B() { System.out.println(\"B \");}\n    \n}','General',0,0,NULL,5),(1049,'A\nB\nD\nE\nG\nH','class Top {\n    { System.out.println(\"A\"); }\n    public Top(){ System.out.println(\"B\"); }\n    public Top(String s){ System.out.println(\"C\"); }\n}\n\nclass Middle extends Top {\n    {System.out.println(\"D\");}\n    public Middle(){ System.out.println(\"E\"); }\n    public Middle(String z){System.out.println(\"F\"); }\n}\npublic class Hello extends Middle{\n   {System.out.println(\"G\");}\n   public Hello(){ System.out.println(\"H\");}\n   public Hello(String x){ System.out.println(\"Z\");}\n    public static void main(String[] args) {\n      new Hello();\n    }\n}','OOP',0,0,NULL,5),(1050,'You can tell that DateFormat is not a singleton because it takes a parameter\n','DateFormat f3 = DateFormat.getDateInstance(DateFormat.SHORT);\nDateFormat f4 = DateFormat.getDateInstance(DateFormat.SHORT);\n\nif f3 == f4 always returns true, DateFormat is a factory\nif f3 == f4 always returns false, DateFormat is a factory','OOP',0,0,NULL,5),(1051,'','A factory can have a public constructor\n\na factory can reate a new object each time you call it ','OOP',0,0,NULL,5),(1052,'','overriding requires the use of IS A relationship','OOP',0,0,NULL,5),(1053,'','IS A relationships always rely on inheritance\n\nIS A relationships always require at least two class types\n\nPolymorphism always relies on IS A relationships','OOP',0,0,NULL,5),(1054,'tight coupling','BioDiesel b4 = new BioDiesel(new Viscosity());','OOP',0,0,NULL,5),(1055,'Got it','DAO implementation must implements an interface,\n\nincreases cohesion by seperating data access code from the object representing\nthe data','OOP',0,0,NULL,5),(1056,'object composition, method delegation','what is this an example of:\n\ninterface B { void c(); }\n\nclass A implements B {\n	private B;\n\n	public A(B b){ this.b = b; }\n\n	public void c(){ b.c(); }\n\n	public void d(){ }\n}','OOP',0,0,NULL,5),(1057,'singleton\nthough not good with the nameing convention, should be getInstance()','public class Stadium { \n	private static final Stadium i = new Stadium();\n	public static Stadium newStadium() {\n		return i;\n	}\n	private Stadium() { }\n}','OOP',0,0,NULL,5),(1058,'object composition','interface Box{\n    void pack();\n    void seal();\n}\n\ninterface Mailer {\n    void addPostage();\n    void ship();\n}\n\nclass GiftBox implements Box{\n    public void pack(){ }\n    public void seal() { }\n}\n\nclass MailerBox implements Box,Mailer {\n    private Box box;\n    public MailerBox(Box box){\n        this.box = box;\n    }\n    public void pack(){ box.pack(); }\n    public void seal(){ box.seal(); }\n    public void addPostage(){\n        System.out.println(\"post\");\n    }\n    public void ship(){\n        System.out.println(\"Put in a box\");\n    }\n}','OOP',0,0,NULL,5),(1059,'Daos should immplement an interface so that is is easy to swap out database\nimplementations','public interface BookDao {\n	Collection<Book> findAllBooks();\n	Book findBookByIsbn(Book book);\n	void create(Book book);	\n	void delet(Book book);\n	void update(Book book);\n}\n\npublic class inMemoryDao implements BookDao { }\n\n','OOP',0,0,NULL,5),(1060,'got it ','loose coupling is desirable, classes are well encapulated minimize reference\nto each other and limit the breadth of API use','OOP',0,0,NULL,5),(1061,'got it','Object compositoin takes advantage of ISA HASA and polymorphism','OOP',0,1,NULL,5),(1062,'got it ','a Factory creates any subclass of an interface or abstract class\nFactoy is an abstract class\nThe Factory method return type is an interface or abstract class\nreturns subclasses of the target subect','OOP',0,0,NULL,5),(1063,'','You want the factory class to be an abstract class so that\nyou can implement some concrete code if necesarry. ','OOP',0,0,NULL,5),(1064,'Factory, A is the object we are creating and G is the abstract super class\nfor the factory what is not shown is the subclass that impleents the factory. ','class A() { }\n\nabstract class G {\n	A m() { return n(); }\n	abstract A n();\n}\n\nwhich design pattern ?','OOP',0,0,NULL,5),(1065,'one, \n\nQueue\n\nQueue is a ordered collection of items.\n\nItems are deleted at one end called ‘front’ end of the queue.\n\nItems are inserted at other end called ‘rear’ of the queue.\n\nThe first item inserted is the first to be removed (FIFO).\n\nStack\n\nStack is a collection of items.\n\nIt allows access to only one data item: the last item inserted.\n\nItems are inserted & deleted at one end called ‘Top of the stack’.\n\nIt is a dynamic & constantly changing object.\n\nAll the data items are put on top of the stack and taken off the top\n\nThis structure of accessing is known as Last in First out structure (LIFO)','class Hello{\n    public static void main(String[] args) {\n        Queue<String> x = new PriorityQueue<>();\n        x.add(\"one\");\n        x.add(\"two\");\n        x.add(\"thread\");\n        System.out.println(x.poll());\n    }\n}','Generics',0,0,NULL,5),(1066,'WNC, TreeSet does not implement Queue so it does not have poll()','class Hello{\n    public static void main(String[] args) {\n        TreeSet<String> x = new TreeSet<>();\n        x.add(\"one\");\n        x.add(\"two\");\n        x.add(\"thread\");\n        System.out.println(x.poll());\n    }\n}','Collections',0,0,NULL,5),(1067,'A private member can be access via a reference variable from within the object\nthat private was declared.  \n\nMethods, Variables and Constructors that are declared private can only be \naccessed within the declared class itself.\n\n','class A {   \n      private void methodA() {System.out.println(\"Hello, I am A!\");}   \n      public static void main(String[] args) {   \n        A a = new A();   \n        a.methodA(); }   \n} ','General',0,0,NULL,5),(1068,'-3 -1 5\n\nit doesnt matter what order the numbers are added to the set, it is a treeset\n\nthe negate() creates a new set withc negated values they are then put into \nincreasing order','class Hello{\n    private Set<Integer> numbers = new TreeSet<Integer>();\n    public Hello(int...nums){\n        for(int n: nums){\n            numbers.add(n);\n        }\n    }\n    public Hello negate(){\n        Hello negatives = new Hello();\n        for(int n : numbers){\n            negatives.numbers.add(-n);\n        }\n        return negatives;\n    }\n    public void show(){\n        for(int n : numbers){\n            System.out.println(n+\" \");\n        }\n    }\n    public static void main(String[] args) {\n        new Hello(1,3,-5).negate().show();\n    }\n}','General',0,0,NULL,5),(1069,'42,\n\n100 is the initial capacity.\n\nThis sorts in reverse order. ','public static void main(String[] args) {\n        \n        Comparator<Integer> cmp = new Comparator<Integer>() {\n            public int compare(Integer n1, Integer n2){\n                return n2.compareTo(n1);\n            }\n        };\n        \n        PriorityQueue pq = new PriorityQueue<Integer>(100,cmp);\n        pq.addAll(Arrays.asList(16,8,42,15,4,23));\n        System.out.println(pq.poll());\n}','Collections',0,0,NULL,5),(1070,'Sea\n4 \nfalse\n\nput returns the value previously associated with the key, or null if there\nwas nothing with it previously. ','public static void main(String[] args) {\n        Map<Integer,String> lat = new HashMap<>();\n        lat.put(60,\"Sea\");\n        lat.put(66,\"circle\");\n        System.out.println(lat.put(62,\"island\"));\n        System.out.println(lat.put(60,\"ocean\"));\n        lat.put(65,\"island\");\n        System.out.println(lat.size() + \" \");\n        System.out.println(lat.containsValue(\"sea\") + \" \");\n}','Collections',0,0,NULL,5),(1071,'only return s and return null, \n\nalthough String and StringBuilder are both subtypes of charsequence they are\nnot necesarrily subtypes of whatever is passed in ','public <S extends CharSequence> S foo(S s){\n	//return s;\n	//return (Object) s;\n	//return s.toString();\n	//return new StringBuilder(s);\n	//return (S) new StringBUilder(s);\n	//return null\n}\n\nwhich compile?','Collections',0,0,NULL,5),(1072,'four one three two\n\nTreeSet assures no duplicate entries, it will return elements in natrual\norder for strings thats alphebetical. ','TreeSet map = new TreeSet();\nmap.add(\"one\");\nmap.add(\"two\");\nmap.add(\"three\");\nmap.add(\"four\")\nmap.add(\"one\");\nIterator it = map.iterator();\nwhile(it.hasNext()){\n	sout(	it.next() + \" \" );\n}','Collections',0,0,NULL,5),(1073,'V \nWallace \nDuncan \n42 \n\nqueue is a FIFO \n\na compiler warning will be produced but it will still compile and run without\nexception ','class Hello{\n   public static void main(String[] args){\n       Queue<String> q = new LinkedList<String>();\n       q.add(\"V\");\n       q.add(\"Wallace\");\n       q.add(\"Duncan\");\n       showAll(q);\n   }\n   \n   public static void showAll(Queue q) {\n       q.add(new Integer(42));\n       while(!q.isEmpty()){\n           System.out.println(q.remove()+ \" \");\n       }\n   }\n}','Collections',0,0,NULL,5),(1074,'only Integer.valueOf(\"-1\") and 0xCAFE\n\nThis TreeSet will allow only numbers but the numbers must be mutually comparable\nthe 108 is an integer so anything added afterward must be an integer.\n\n0xCAFE is a valid hex literal for an int. \n\n3.14 is a double. ','public static void main(String[] args){\n       TreeSet<Number> tree = new TreeSet<Number>();\n       tree.add(108);\n       //tree.add(3.14);\n       //tree.add(\"42\");\n       //tree.add(Integer.valueOf(\"-1\");\n       //tree.add(null);\n       //tree.add(new Long(123));\n       //tree.add(0XCAFE);\n       \n   }\n\nwhich will compile and run ?','Collections',0,0,NULL,5),(1075,'ClassCastExcepiton','public static void main(String[] args){\n       TreeSet<Number> tree = new TreeSet<Number>();\n       tree.add(108);\n       tree.add(3.14);\n       //tree.add(\"42\");\n       tree.add(Integer.valueOf(\"-1\"));\n       tree.add(null);\n       tree.add(new Long(123));\n       tree.add(0XCAFE);\n       \n   }','Collections',0,0,NULL,5),(1076,'Internally, a Java compiler operates over a richer set of types than those \nthat can be written down explicitly in a Java program. The compiler-internal\n types which cannot be written in a Java program are called non-denotable\n types. Non-denotable types can occur as the result of the inference used\n by diamond. Therefore, using diamond with anonymous inner classes is not \nsupported since doing so in general would require extensions to the class \nfile signature attribute to represent non-denotable types, a de facto JVM \nchange. It is feasible that future platform versions could allow use of \ndiamond when creating an anonymous inner class as long as the inferred type \nwas denotable.','diamond operator cannot be used with anonymous classes','General',0,0,NULL,5),(1077,'LinkedList\n\nallows duplicates and has methods apporopriate for pushing and popping from the\nstack addFirst() getFirst()','What collection would be best to implement a stack that does not have \nthe overhead of synchronized methods ?','Collections',0,0,NULL,5),(1078,'chain meter','public static void main(String[] args){\n       String[] s = { \"inch\", \"foot\", \"yard\", \"rod\", \"meter\" };\n       List list = Arrays.asList(s);\n       list.set(4,\"chain\");\n       System.out.println(s[4]);\n       s[2] = \"meter\";\n       System.out.println(\" \" + list.get(2));\n   }','Collections',0,0,NULL,5),(1079,'ArrayIndexOutofBoundsException you are refereing to place 4 when there is \nonly 3 indexs 0-3','public static void main(String[] args){\n       String[] s = { \"inch\", \"foot\", \"yard\", \"rod\" };\n       List list = Arrays.asList(s);\n       list.set(4,\"chain\");\n       System.out.println(s[4]);\n       s[2] = \"meter\";\n       System.out.println(\" \" + list.get(2));\n   }','Collections',0,0,NULL,5),(1080,'UnsupportedOerationException,\n\nwhen you use asList the list and array becomes bound at the hip. so changes\nin one refect in the other,\n\nyou can only reset indexes though you cannot make any new addition or removals\nto the list, and you cant add or remove from an array anyway.',' public static void main(String[] args){\n       String[] s = { \"inch\", \"foot\", \"yard\", \"rod\", \"meter\" };\n       List list = Arrays.asList(s);\n       list.set(4,\"chain\");\n       System.out.println(s[4]);\n       s[2] = \"meter\";\n       System.out.println(\" \" + list.get(2));\n       list.add(9);\n   }','Collections',0,0,NULL,5),(1081,'compiles fine. ','class BackLister {\n    public static <T> List<T> backwards(List<T> input)\n    {\n        List<T> output = new LinkedList<T>();\n        for(T t : input)\n            output.add(0,t);\n        return output;\n    }\n}','Collections',0,0,NULL,5),(1082,'public static <T> List<T> backwards(List<T> iput)\n	- a standard way to create a generic method\n\npublic static <T> List<T> backwards(List<? extends T> input)\n	-this says to the compile \" I want to be allowed to pass\n		in lsits of subtypes of the declared type but only\n		to invoke methods on the elements.\n\npublic static <T> List<? super T> backwards(List<T> input)\npublic static <T> List<? extends T> backwards(List<T> input)\n\n\npublic static <T> List<T> backwards(List<? super T> input)\n\n	this will nto compile because if the input can containt any super type\nof T then those elements couldn\'t be added to a collection of type T','class BackLister {\n    //insert here \n    {\n        List<T> output = new LinkedList<T>();\n        for(T t : input)\n            output.add(0,t);\n        return output;\n    }\n}\n\npublic static <T> List<T> backwards(List<T> iput)\npublic static <T> List<T> backwards(List<? extends T> input)\npublic static <? super T> List<T> backwards(List<T> input)\npublic static <? extends T> List<T> backwards(List<T> input)\npublic static <T> List<? extends T> backwards(List<T> input)\npublic static <T> List<T> backwards(List<? super T> input)\npublic static <T> List<? super T> backwards(List<T> input)\n\nwhich compile and run without error ?\n','Collections',0,0,NULL,5),(1083,'WNC,\n\nif the input can contain any super type of T then those elements couldn\'t be\nadded to a collection of type T.','class Hello{\n   public static void main(String[] args){\n       ArrayList<Integer> ints = new ArrayList<>();\n       ints.add(9);\n       ints.add(8);\n       ints.add(7);\n   }\n\n    public static <T> List<T> backwards(List<? super T> input)\n    {\n        List<T> output = new LinkedList<T>();\n        for(T t : input)\n            output.add(0,t);\n        return output;\n    }\n}','Collections',0,0,NULL,5),(1084,'WILL NEVER COPMPILE\n\ncannot use wildcards in the type declaration','public static <? extends T> List<T> backwards(List<T> input)','Collections',0,0,NULL,5),(1085,'WILL NEVER COMPILE\n\ncannot use wildcards in the type variable delcaraiotn','public static <? super T> List<T> backwards(List<T> input)','Collections',0,0,NULL,5),(1086,'got it ','CANNOT USE ? WILDCARDS IN THE TYPE VARIABLE DECLARATION OF THE GENERIC METHOD','Collections',0,0,NULL,5),(1087,'WNC,\n\nnon static type variable G cannot be used in static context','class Hello<G>{\n   public static void main(String[] args){\n       ArrayList<G> ints = new ArrayList<>();\n   }\n\n    public static <T> List<T> backwards(List<? super T> input)\n    {\n        ArrayList<G> ints = new ArrayList<>();\n        List<T> output = new LinkedList<T>();\n        for(T t : input)\n            output.add(0,t);\n        return output;\n    }\n}\n','Collections',0,0,NULL,5),(1088,'WNC non static type variable G cannot be referenced from a static context','class Hello<G>{\n   public static void main(String[] args){\n       \n   }\n\n    public static <T extends G> List<T> backwards(List<T> input)\n    {\n        List<T> output = new LinkedList<T>();\n        for(T t : input)\n            output.add(0,t);\n        return output;\n    }\n}','Collections',0,0,NULL,5),(1089,'','This is the first part of PECS i.e. PE (Producer extends). To more relate it to real life terms, let’s use an analogy of a basket of fruits (i.e. collection of fruits). When we pick a fruit from basket, then we want to be sure that we are taking out only fruit only and nothing else; so that we can write generic code like this:\n\nFruit get = fruits.get(0);\n\nIn above case, we need to declare the collection of fruits as List<? extends Fruit>. e.g.\nclass Fruit {\n   @Override\n   public String toString() {\n      return \"I am a Fruit !!\";\n   }\n}\n \nclass Apple extends Fruit {\n   @Override\n   public String toString() {\n      return \"I am an Apple !!\";\n   }\n}\n \npublic class GenericsExamples\n{\n   public static void main(String[] args)\n   {\n      //List of apples\n      List<Apple> apples = new ArrayList<Apple>();\n      apples.add(new Apple());\n       \n      //We can assign a list of apples to a basket of fruits;\n      //because apple is subtype of fruit \n      List<? extends Fruit> basket = apples;\n       \n      //Here we know that in basket there is nothing but fruit only\n      for (Fruit fruit : basket)\n      {\n         System.out.println(fruit);\n      }\n       \n      //basket.add(new Apple()); //Compile time error\n      //basket.add(new Fruit()); //Compile time error\n   }\n}','Collections',0,0,NULL,5),(1090,'','a producer will extend the type being used because it will possibly contain\nsubtypes, it is a producer therefore you shouldn\'t have to nor want to\nadd anything else to it. so <? extends G> is for producers nothing will be\nadded to this collection','Collections',0,0,NULL,5),(1091,'','class Fruit {\n   @Override\n   public String toString() {\n      return \"I am a Fruit !!\";\n   }\n}\n \nclass Apple extends Fruit {\n   @Override\n   public String toString() {\n      return \"I am an Apple !!\";\n   }\n}\n \nclass AsianApple extends Apple {\n   @Override\n   public String toString() {\n      return \"I am an AsianApple !!\";\n   }\n}\n \npublic class GenericsExamples\n{\n   public static void main(String[] args)\n   {\n      //List of apples\n      List<Apple> apples = new ArrayList<Apple>();\n      apples.add(new Apple());\n       \n      //We can assign a list of apples to a basket of apples\n      List<? super Apple> basket = apples;\n       \n      basket.add(new Apple());      //Successful\n      basket.add(new AsianApple()); //Successful\n      basket.add(new Fruit());      //Compile time error\n   }\n}\n\nWe are able to add apple and even Asian apple inside basket, but we are not\n able to add Fruit (super type of apple) to basket. Why?\n\nReason is that basket is a reference to a List of something that is a \nsupertype of Apple. Again, we cannot know which supertype it is, but we\n know that Apple and any of its subtypes (which are subtype of Fruit) can \nbe added to be without problem (you can always add a subtype in collection \nof supertype). So, now we can add any type of Apple inside basket.\n\nproducers use super','Collections',0,0,NULL,5),(1092,'WNC though it is not thrown go() declares that it throws an excpetion so it \nshould be handled by main','class Hello{\n   public static void main(String[] args){\n       new Hello().go();\n   }\n   void go() throws IOException {\n       String row;\n       try {\n          FileReader fr = new FileReader(\"TestFile.txt\");\n          BufferedReader br = new BufferedReader(fr);\n          while((row = br.readLine()) != null)\n               System.out.println(row);\n       } catch(IOException e){\n           System.out.println(\"IOERROR\");\n       } finally {\n           System.out.println(\"done\");    \n       }\n   }\n}','Exceptions',0,0,NULL,5),(1093,'multi catch may not contain exception types that are in the same heirarchy','class Party {\n    static class Rain extends Exception { }\n    static class Thunderstorm extends Rain{ }\n    public void eat() {\n        try {\n            bbq();\n        } catch(Rain | Thunderstorm e){\n            \n        }\n    }\n    private void bbq() throws Rain, Thunderstorm{ }\n}','Exceptions',0,0,NULL,5),(1094,'done\n\nboth assert statements are true so the methods are never called','class Hello{\n   public static int y;\n   public static void main(String[] args){\n       int t = 2;\n       assert t < 4 : bar(7);\n       assert t > 1 : foo(8);\n       System.out.println(\"done\");\n   }\n    public static int foo(int x) {\n        System.out.println(\"foo \");\n        return y = x;\n    }\n    public static int bar(int z) {\n        System.out.println(\"bar \");\n        return y = z;\n    }\n}','Exceptions',0,0,NULL,5),(1095,'finally\nException in thread \"main\" java.lang.ArrayIndexOutOfBoundsException: 0\n	at hello.Hello.main(Hello.java:53)\n/home/maxbisesi/.cache/netbeans/8.1/executor-snippets/run.xml:53: Java returned: 1\n\n\nTHe other two excpeitons weren\'t suppressed they were forgotten when \nfinally threw a new exception. \n\nso getSuppressed() cant find anything and throws the indexOB exception.','class Hello{\n    static class A implements AutoCloseable {\n        public void close() throws Exception {\n            throw new Exception(\"catch\");\n        }\n    }\n    \n    private static void method() throws Exception {\n        try(A a = new A()) {\n            throw new Exception(\"try\");\n        } finally {\n            throw new Exception(\"finally\");\n        }\n    }\n\n   public static void main(String[] args){\n       try {\n           method();\n       } catch(Exception e) {\n           System.out.println(e.getMessage());\n           System.out.println(e.getSuppressed()[0]);\n       }\n   }\n\n}','Exceptions',0,0,NULL,5),(1096,'got it','%[arg_index][flags][width][.precision]conversion char\n\nflags\n-=-=-=-=-=-\n- left justify\n+ include a sign\n0 pad argument with zeros\n, use locale specific grouping serperators\n( Enclose negative numbers in parentheses\n\nconversion chars\n-=-=-=-=-=-=-=-=-=-\nb boolean\nc char\nd integer\nf floating point\ns string','Strings',0,0,NULL,5),(1097,'got it','Barring booleans, if your conversion character doesn\'t match your argument type,\nan exception will be thrown','Strings',0,0,NULL,5),(1098,'>    317< \n>0000831< \n>+7566  < \n\n','private static void method() throws Exception {\n        int a = 831;\n        int b = 7566;\n        int c = 317;\n        System.out.printf(\">%1$(7d< \\n\",c);\n        System.out.printf(\">%0,7d< \\n\",a);\n        System.out.printf(\">%+-7d< \\n\",b);\n    }','Strings',0,0,NULL,5),(1099,'use locale specific seperators','format flags:\n\n,','Strings',0,0,NULL,5),(1100,'Encolose negative numbers in paranethes','format flags:\n\n(','Strings',0,0,NULL,5),(1101,'Pad this argument with zeroes','format flags:\n\n0','Strings',0,0,NULL,5),(1102,'Include a sign with this argument','format flags:\n\n+','Strings',0,0,NULL,5),(1103,'left justify this argument','format flags:\n\n-','Strings',0,0,NULL,5),(1104,'boolean\ncharacter\ninteger\nfloating point\nstring','format conversion chararcters:\n\nb\nc\nd\nf\ns','Strings',0,0,NULL,5),(1105,'The world is not enough, and there is no tomorrow\n\neverything after the conversion character is printed as is','private static void method() throws Exception {\n        int a = 831;\n        String s = \"The world is not enough\";\n        boolean yea = true;\n        \n        System.out.printf(\"%1$s, and there is no tomorrow\",s);\n    }','Strings',0,0,NULL,5),(1106,'831, and there is no tomorrow','private static void method() throws Exception {\n        int a = 831;\n        String s = \"The world is not enough\";\n        boolean yea = true;\n        \n        System.out.printf(\"%1$s, and there is no tomorrow\",a);\n    }','Strings',0,0,NULL,5),(1107,'831, and there is no tomorrow','private static void method() throws Exception {\n        int a = 831;\n        String s = \"The world is not enough\";\n        boolean yea = true;\n        \n        System.out.printf(\"%1$s, and there is no tomorrow\",a);\n    }','Strings',0,0,NULL,5),(1108,'831, and there is no tomorrow','private static void method() throws Exception {\n        int a = 831;\n        String s = \"The world is not enough\";\n        boolean yea = true;\n        \n        System.out.printf(\"%1$s, and there is no tomorrow\",a);\n    }','Strings',0,0,NULL,5),(1109,'831, and there is no tomorrow','private static void method() throws Exception {\n        int a = 831;\n        String s = \"The world is not enough\";\n        boolean yea = true;\n        \n        System.out.printf(\"%1$s, and there is no tomorrow\",a);\n    }','Strings',0,0,NULL,5),(1110,'831, and there is no tomorrow','private static void method() throws Exception {\n        int a = 831;\n        String s = \"The world is not enough\";\n        boolean yea = true;\n        \n        System.out.printf(\"%1$s, and there is no tomorrow\",a);\n    }','Strings',0,0,NULL,5),(1111,'831, and there is no tomorrow','private static void method() throws Exception {\n        int a = 831;\n        String s = \"The world is not enough\";\n        boolean yea = true;\n        \n        System.out.printf(\"%1$s, and there is no tomorrow\",a);\n    }','Strings',0,0,NULL,5),(1112,'831, and there is no tomorrow','private static void method() throws Exception {\n        int a = 831;\n        String s = \"The world is not enough\";\n        boolean yea = true;\n        \n        System.out.printf(\"%1$s, and there is no tomorrow\",a);\n    }','Strings',0,0,NULL,5),(1113,'831, and there is no tomorrow','private static void method() throws Exception {\n        int a = 831;\n        String s = \"The world is not enough\";\n        boolean yea = true;\n        \n        System.out.printf(\"%1$s, and there is no tomorrow\",a);\n    }','Strings',0,0,NULL,5),(1114,'831, and there is no tomorrow','private static void method() throws Exception {\n        int a = 831;\n        String s = \"The world is not enough\";\n        boolean yea = true;\n        \n        System.out.printf(\"%1$s, and there is no tomorrow\",a);\n    }','Strings',0,0,NULL,5),(1115,'831, and there is no tomorrowa','private static void method() throws Exception {\n        int a = 831;\n        String s = \"The world is not enough\";\n        boolean yea = true;\n        \n        System.out.printf(\"%1$s, and there is no tomorrow\",a);\n    }','Strings',0,0,NULL,5),(1116,'831, and there is no tomorrowa','private static void method() throws Exception {\n        int a = 831;\n        String s = \"The world is not enough\";\n        boolean yea = true;\n        \n        System.out.printf(\"%1$s, and there is no tomorrow\",a);\n    }','Strings',0,0,NULL,5),(1117,'831, and there is no tomorrowa','private static void method() throws Exception {\n        int a = 831;\n        String s = \"The world is not enough\";\n        boolean yea = true;\n        \n        System.out.printf(\"%1$s, and there is no tomorrow\",a);\n    }','Strings',0,0,NULL,5),(1118,'831, and there is no tomorrowa','private static void method() throws Exception {\n        int a = 831;\n        String s = \"The world is not enough\";\n        boolean yea = true;\n        \n        System.out.printf(\"%1$s, and there is no tomorrow\",a);\n    }','Strings',0,0,NULL,5),(1119,'831, and there is no tomorrowa','private static void method() throws Exception {\n        int a = 831;\n        String s = \"The world is not enough\";\n        boolean yea = true;\n        \n        System.out.printf(\"%1$s, and there is no tomorrow\",a);\n    }','Strings',0,0,NULL,5),(1120,'831, and there is no tomorrowa','private static void method() throws Exception {\n        int a = 831;\n        String s = \"The world is not enough\";\n        boolean yea = true;\n        \n        System.out.printf(\"%1$s, and there is no tomorrow\",a);\n    }','Strings',0,0,NULL,5),(1121,'831, and there is no tomorrowa','private static void method() throws Exception {\n        int a = 831;\n        String s = \"The world is not enough\";\n        boolean yea = true;\n        \n        System.out.printf(\"%1$s, and there is no tomorrow\",a);\n    }','Strings',0,0,NULL,5),(1122,'831, and there is no tomorrowa','private static void method() throws Exception {\n        int a = 831;\n        String s = \"The world is not enough\";\n        boolean yea = true;\n        \n        System.out.printf(\"%1$s, and there is no tomorrow\",a);\n    }','Strings',0,0,NULL,5),(1123,'         a  61         a  61         b  62         b  62         c  63         c  63         d  64         d  64         e  65         e  65         f  66\n         f  66         g  67         g  67         h  68         h  68         i  69         i  69         j  6a         j  6a         k  6b         k  6b         l  6c\n         l  6c         m  6d         m  6d         n  6e         n  6e         o  6f         o  6f         p  70         p  70         q  71         q  71         r  72\n         r  72         s  73         s  73         t  74         t  74         u  75         u  75         v  76         v  76         w  77         w  77         x  78\n         x  78         y  79         y  79         z  7a         z  7','public static void main(String[] args){\n        int count = 0;\n            for (int ch = \'a\'; ch <= \'z\'; ch++) {\n            System.out.printf(\"      %1$4c%1$4x\", ch);\n            if (++count % 6 == 0) {\n                 System.out.printf(\"%n\");\n             }\n        System.out.printf(\"      %1$4c%<4x\", ch);\n        }\n\n   }','Strings',0,0,NULL,5),(1124,'A\nThis is a string\nThis is also a string\nTHIS IS ALSO A STRING\n1234','public static void main( String args[] )\n   { \n      char character = \'A\';\n      String string = \"This is also a string\";\n      Integer integer = 1234;  // initialize integer (autoboxing)\n\n      System.out.printf( \"%c\\n\", character );\n      System.out.printf( \"%s\\n\", \"This is a string\" );\n      System.out.printf( \"%s\\n\", string );\n      System.out.printf( \"%S\\n\", string );\n      System.out.printf( \"%s\\n\", integer ); // implicit call to toString\n   }','Strings',0,0,NULL,5),(1125,'false\ntrue\ntrue\nFALSE\nHashcode of \"hello\" is 5e918d2\nHashcode of \"Hello\" is 42628b2\nHashcode of null is NULL\nPrinting a % in a format string\nPrinting a new line \nnext line starts here','public static void main( String args[] ) \n   {\n      Object test = null;\n      System.out.printf( \"%b\\n\", false );\n      System.out.printf( \"%b\\n\", true );\n      System.out.printf( \"%b\\n\", \"Test\" );\n      System.out.printf( \"%B\\n\", test );\n      System.out.printf( \"Hashcode of \\\"hello\\\" is %h\\n\", \"hello\" );\n      System.out.printf( \"Hashcode of \\\"Hello\\\" is %h\\n\", \"Hello\" );\n      System.out.printf( \"Hashcode of null is %H\\n\", test );\n      System.out.printf( \"Printing a %% in a format string\\n\" );\n      System.out.printf( \"Printing a new line %nnext line starts here\" );\n   }','Strings',0,0,NULL,5),(1126,'a boolean conversion character will convert anything non boolean to \"true\"\nand a false to boolean to \"false\"','public static void main(String[] args){\n        int count = 0;\n        String s = \" true\";\n        boolean yea = true;\n        boolean nah = false;\n        System.out.printf(\"use boolean to convert non-boolean\\n count:%b \\n s:%b \\n yea:%b \\n nah:%b \",count,s,yea,nah);\n   }','Strings',0,0,NULL,5),(1127,'use string to convert non-boolean\n count:0 \n s: true \n yea:true \n nah:false','public static void main(String[] args){\n        int count = 0;\n        String s = \" true\";\n        boolean yea = true;\n        boolean nah = false;\n        System.out.printf(\"use string to convert non-boolean\\n count:%s \\n s:%s \\n yea:%s \\n nah:%s \",count,s,yea,nah);\n   }','Strings',0,0,NULL,5),(1128,'got it ','At least five wide 	\n\nprintf(\"\'%5d\'\", 10); 	\'   10\'\n\nAt least five-wide, left-justified 	\n\nprintf(\"\'%-5d\'\", 10); 	\'10   \'\n\nAt least five-wide, zero-filled 	\n\nprintf(\"\'%05d\'\", 10); 	\'00010\'\n\nAt least five-wide, with a plus sign 	\n\nprintf(\"\'%+5d\'\", 10); 	\'  +10\'\n\nFive-wide, plus sign, left-justified 	\n\nprintf(\"\'%-+5d\'\", 10); 	\'+10  \'','Strings',0,0,NULL,5),(1129,'got it','The %3d specifier is used with integers, and means a minimum width of three\n spaces, which, by default, will be right-justified:\n\nprintf(\"%3d\", 0); 	0\nprintf(\"%3d\", 123456789); 	123456789\nprintf(\"%3d\", -10); 	-10\nprintf(\"%3d\", -123456789); 	-123456789','Strings',0,0,NULL,5),(1130,'got it','To left-justify integer output with printf, just add a minus sign (-) after\n the % symbol, like this:\n\nprintf(\"%-3d\", 0); 	0\nprintf(\"%-3d\", 123456789); 	123456789\nprintf(\"%-3d\", -10); 	-10\nprintf(\"%-3d\", -123456789); 	-123456789','Strings',0,0,NULL,5),(1131,'got it','As a summary of printf integer formatting, here’s a little collection of \ninteger formatting examples. Several different options are shown, including\n a minimum width specification, left-justified, zero-filled, and also a \nplus sign for positive numbers.\n\nAt least five wide 	printf(\"\'%5d\'\", 10); 	\'   10\'\nAt least five-wide, left-justified 	printf(\"\'%-5d\'\", 10); 	\'10   \'\nAt least five-wide, zero-filled 	printf(\"\'%05d\'\", 10); 	\'00010\'\nAt least five-wide, with a plus sign 	printf(\"\'%+5d\'\", 10); 	\'  +10\'\nFive-wide, plus sign, left-justified 	printf(\"\'%-+5d\'\", 10); 	\'+10  \'','Strings',0,0,NULL,5),(1132,'got it','A simple string 	printf(\"\'%s\'\", \"Hello\"); 	\'Hello\'\nA string with a minimum length 	printf(\"\'%10s\'\", \"Hello\"); 	\'     Hello\'\nMinimum length, left-justified 	printf(\"\'%-10s\'\", \"Hello\"); 	\'Hello     \'','Strings',0,0,NULL,5),(1133,'got it if the argument is larger than the width, it will be extended','Print one position after the decimal 	\n\nprintf(\"\'%.1f\'\", 10.3456); 	\'10.3\'\n\nTwo positions after the decimal 	\n\nprintf(\"\'%.2f\'\", 10.3456); 	\'10.35\'\n\nEight-wide, two positions after the decimal 	\n\nprintf(\"\'%8.2f\'\", 10.3456); 	\'   10.35\'\n\nEight-wide, four positions after the decimal 	\n\nprintf(\"\'%8.4f\'\", 10.3456); 	\' 10.3456\'\n\nEight-wide, two positions after the decimal, zero-filled 	\n\nprintf(\"\'%08.2f\'\", 10.3456); 	\'00010.35\'\n\nEight-wide, two positions after the decimal, left-justified 	\n\nprintf(\"\'%-8.2f\'\", 10.3456); 	\'10.35   \'\n\nPrinting a much larger number with that same format 	\n\nprintf(\"\'%-8.2f\'\", 101234567.3456); 	\'101234567.35\'','Strings',0,0,NULL,5),(1134,'Exception in thread \"main\" java.util.FormatFlagsConversionMismatchException: Conversion = s, Flags = (\n\nfor using flags that dont apply to strings','public static void main(String[] args){\n        int count = 0;\n        String s = \" true\";\n        boolean yea = true;\n        boolean nah = false;\n        System.out.printf(\"%1$(4s\",s);\n   }','Strings',0,0,NULL,5),(1135,'Exception in thread \"main\" java.util.FormatFlagsConversionMismatchException:\n Conversion = s, Flags = 0','public static void main(String[] args){\n        int count = 0;\n        String s = \" true\";\n        boolean yea = true;\n        boolean nah = false;\n        System.out.printf(\"%1$0s\",s);\n   }','Strings',0,0,NULL,5),(1136,'(34)\n\nit goes like this:\n\narg_index flags width precision conversion character\n\nso here the fomat string means index 1, pad with zeroes, \nwidth of three, enclose negatives in zero, convert from an int','public static void main(String[] args){\n        int count = -34;\n        String s = \" true\";\n        boolean yea = true;\n        boolean nah = false;\n        System.out.printf(\"%1$0(3d\",count);\n   }','Strings',0,0,NULL,5),(1137,'Exception in thread \"main\" java.util.IllegalFormatConversionException:\n d != java.lang.Double','public static void main(String[] args){\n        double count = -34.45;\n        String s = \" true\";\n        boolean yea = true;\n        boolean nah = false;\n        System.out.printf(\"%1$0(3d\",count);\n   }','Strings',0,0,NULL,5),(1138,'(34.450000)','public static void main(String[] args){\n        double count = -34.45;\n        String s = \" true\";\n        boolean yea = true;\n        boolean nah = false;\n        System.out.printf(\"%1$0(3f\",count);\n   }','Strings',0,0,NULL,5),(1139,'\nWNC\ncant return <? super Cards> when return type is <Card>','public static ArrayList<Card> findCardsWithNoCategory(ArrayList<? extends Card> list){\n        ArrayList<? super Card> cards = new ArrayList<Card>();\n        \n        for(Card c : list){\n            if(c.getCategory().equals(\"\") || c.getCategory().equals(\" \")){\n                cards.add(c);\n            }\n        }\n        \n        return cards;\n        \n    }','Generics',0,0,NULL,5),(1140,'Files.newDirectoryStream(Path p, String glob)\n\nDirectoryStream only uses glob\n\nso you dont have to say \"glob: *\"\n\nif you do it wont match anything','DirectoryStream dm = ...\n\nFileSystem.getDefault().getDirectoryStream(Path p, String glob);\n\nFiles.getDefault().newDirectoryStream(File f, String regex);\n\nFiles.getDefault().newDirectoryStream(Path p, String glob);\n\nFiles.newDirectoryStream(Path p, String glob);\n\nFiles.getDirectoryStream(Files f, String regex);\n\n','IO',0,0,NULL,5),(1141,'Files.newDirectoryStream(Path p, String glob)\n\nDirectoryStream only uses glob\n\nso you dont have to say \"glob: *\"\n\nif you do it wont match anything','DirectoryStream dm = ...\n\nFileSystem.getDefault().getDirectoryStream(Path p, String glob);\n\nFiles.getDefault().newDirectoryStream(File f, String regex);\n\nFiles.getDefault().newDirectoryStream(Path p, String glob);\n\nFiles.newDirectoryStream(Path p, String glob);\n\nFiles.getDirectoryStream(Files f, String regex);\n\n','IO',0,0,NULL,5),(1142,'Files.newDirectoryStream(Path p, String glob)\n\nDirectoryStream only uses glob\n\nso you dont have to say \"glob: *\"\n\nif you do it wont match anything','DirectoryStream dm = ...\n\nFileSystem.getDefault().getDirectoryStream(Path p, String glob);\n\nFiles.getDefault().newDirectoryStream(File f, String regex);\n\nFiles.getDefault().newDirectoryStream(Path p, String glob);\n\nFiles.newDirectoryStream(Path p, String glob);\n\nFiles.getDirectoryStream(Files f, String regex);\n\n','IO',0,0,NULL,5),(1143,'Files.newDirectoryStream(Path p, String glob)\n\nDirectoryStream only uses glob\n\nso you dont have to say \"glob: *\"\n\nif you do it wont match anything','DirectoryStream dm = ...\n\nFileSystem.getDefault().getDirectoryStream(Path p, String glob);\n\nFiles.getDefault().newDirectoryStream(File f, String regex);\n\nFiles.getDefault().newDirectoryStream(Path p, String glob);\n\nFiles.newDirectoryStream(Path p, String glob);\n\nFiles.getDirectoryStream(Files f, String regex);','IO',0,0,NULL,5),(1144,'comiles but will not match anything,\nDirectoryStream only takes globs so when you say glob: it trys to match a file\nlike that. ','try(DirectoryStream<Path> dm = Files.newDirectoryStream(home,\"glob:*\")){\n           for(Path path:dm){\n               System.out.println(path);\n           }\n           \n       } catch(IOException e){ System.out.println(e); }','IO',0,0,NULL,5),(1145,'FileSystems.getDefault().getPathMatcher(\"glob:TextFile?.*\");\n\nthe argument to getPathMatcher is (String syntaxandpatter)\n\nso that means it supports glob or regex.\n\nsyntax:pattern\n\nglob:*.txt\nregex:.*{.txt}\n\n*Dont put a space after the : that wll be included in the pattern','PathMatcher pm = ...\n\nFiles.getDefault().getPathMatcher(\"glob:file?.*\");\nFileSystems.getDefault().getPathMatcher(Path dir,\"TextFile?.*\");\nFileSystems.getPathMatcher(\"regex:TextFile?.*\");\nFiles.newPathMatcher(File file, String glob);\n\n','IO',0,0,NULL,5),(1146,'DirectoryNotEmptyException\n\nFiles.delete cannot delete a directory thats not empty','public static void main(String[] args){\n       \n       Path file = Paths.get(\"/home/maxbisesi/Public/Data/InnerDir/emptyFile.txt\");\n       try{\n           Files.createFile(file);\n           System.out.println(\"File created\");\n           Path dir = Paths.get(\"/home/maxbisesi/Public/Data/InnerDir\");\n           Files.delete(dir);\n       } catch(IOException e){\n           System.out.println(e);\n       }\n       \n            \n   }','IO',0,0,NULL,5),(1147,'File created\n/home/maxbisesi/Public/Data/InnerDir\n\nyou can rename a File dir even if it is not empty',' public static void main(String[] args){\n       	// imagine InnerDir contains one text file\n           File file = new File(\"/home/maxbisesi/Public/Data/InnerDir\");\n           file.mkdir();\n           System.out.println(\"File created\");\n           file.renameTo(new File(\"/home/maxbisesi/Public/Data/MaxsDir\"));\n           System.out.println(file);\n\n            \n   }','IO',0,0,NULL,5),(1148,'it will print its two messages then continue to run,\n\nwithout shutdown() the executor doesn\'t know when to stop. ','public class Hello {\n    public static void main(String[] args){\n        ExecutorService ex = Executors.newSingleThreadExecutor(); \n        Future<Integer> futint = ex.submit(new FileCounter());\n        \n        System.out.println(\"Do other things while the files are getting counted\");\n        \n        try{\n            int count = futint.get();\n            System.out.println(count);\n            //ex.shutdown();\n        }catch(ExecutionException | InterruptedException e){\n            \n        }\n        \n    }\n    \n    \n}\n\nclass FileCounter implements Callable<Integer>{\n    private int fileCount = 0;\n    public Integer call() throws IOException{\n        fileCount = count(Paths.get(\"/home/maxbisesi/Documents\"));\n        return fileCount; \n    }\n    \n    public Integer count(Path d) throws IOException {\n        int count = 0;\n	try(DirectoryStream<Path> stream = Files.newDirectoryStream(d)){\n		for(Path path: stream){\n			count++;\n		}\n	}\n        return count;\n    }\n}\nwhat will happen ? ','Executors',0,0,NULL,5),(1149,'got it \n\nshutdownNow() will call Thread.interrupt() in an attemtpt to terminate any \nunfinished tasks.','ExecutorService ex = \n//..\nex.shutdown(); // no more new task but finish the currently executing ones\n\ntry {\n	boolean term = ex.awaitTermination(2,TimeUnit.SECONDS);\n} catch(InterruptedException e){\n	//did not wait the full 2 seconds\n} finally {\n	if(!ex.isTerminated()) // are all tasks done ?\n	{\n		List<Runnable> unfinished = ex.shutdownNow();\n		//a collection of unfinished tasks\n	}\n}','Executors',0,0,NULL,5),(1150,'First entry:\nHired today: Mon Aug 07 16:43:51 EDT 2017\nStart first upcoming monday: Mon Aug 07 16:43:51 EDT 2017\nMicheal Boyd\nLast entry:\nHired a month ago: Fri Jul 07 16:43:51 EDT 2017\nVishv Zockler\n','public class Hello {\n    public static void main(String[] args){\n        try {\n            Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\");\n            PreparedStatement pst = conn.prepareStatement(\"Select * From employees limit 100\");\n            ResultSet rs = pst.executeQuery();\n            \n            Date d = new Date();\n            Calendar c = Calendar.getInstance();\n            c.setTime(d);\n\n            rs.first();\n            System.out.println(\"First entry:\");\n            System.out.println(\"Hired today: \"+d);\n            System.out.println(\"Start first upcoming monday: \"+firstNextMonday(d));\n            System.out.println(rs.getString(\"first_name\") + \" \" +rs.getString(\"last_name\"));\n            \n            c.add(Calendar.MONTH,-1);\n            Date monthago = c.getTime();\n            rs.last();\n            System.out.println(\"Last entry:\");\n            System.out.println(\"Hired a month ago: \"+monthago);\n            System.out.println(rs.getString(\"first_name\") + \" \" +rs.getString(\"last_name\"));\n        } catch(SQLException e){ }\n        \n    }\n    \n    public static Date firstNextMonday(Date d){\n        Calendar c = Calendar.getInstance();\n        c.setTime(d);\n        \n        while(c.get(Calendar.DAY_OF_WEEK) != c.MONDAY){\n            //c.add(1,DAY_OF_WEEK);\n            c.add(c.DAY_OF_WEEK,1);\n        }\n        \n        return c.getTime();\n        \n    }\n}','Executors',0,0,NULL,5),(1151,'ExecutorService ex = Executors.newFixedThreadPool(4);\n\nits none of those','create a fixed thread pool...\n\nExecutor ex = ExecutorService.newFixedThreadPool(4);\nExecutor ex = Executor.newFixedThreadPool(4);\nExecutorService = ExecutorService.newFixedThreadPool(4);\nExecutorService = Executors.newFixedThreadExecutor(4);','Executors',0,0,NULL,5),(1152,'added: true\nadded: true\nadded: true\nadded: true\nadded: true\nadded: true\nadded: true\nadded: true\nadded: true\nadded: true\nadded: true\nadded: true\nadded: true\nadded: true\nadded: true\nadded: true\nadded: true\nadded: true\nadded: true\nadded: true\nadded: false\nqueue is full offer will not add anymore\nadded: false\nqueue is full offer will not add anymore\nadded: false\nqueue is full offer will not add anymore\nadded: false\nqueue is full offer will not add anymore\nadded: false\nqueue is full offer will not add anymore\nadded: false\nqueue is full offer will not add anymore\nadded: false\nqueue is full offer will not add anymore\nadded: false\nqueue is full offer will not add anymore\nadded: false\nqueue is full offer will not add anymore\nadded: false\nqueue is full offer will not add anymore\nadded: false\nqueue is full offer will not add anymore\nadded: false\nqueue is full offer will not add anymore\nadded: false\nqueue is full offer will not add anymore\nadded: false\nqueue is full offer will not add anymore\nnull\n/home/maxbisesi/.config \n/home/maxbisesi/.nano \n/home/maxbisesi/Desktop \n/home/maxbisesi/.bash_history \n/home/maxbisesi/Templates \n/home/maxbisesi/examples.desktop \n/home/maxbisesi/.bashrc \n/home/maxbisesi/.gnupg \n/home/maxbisesi/.java \n/home/maxbisesi/.xsession-errors \n/home/maxbisesi/.local \n/home/maxbisesi/.dmrc \n/home/maxbisesi/.Xauthority \n/home/maxbisesi/.ICEauthority \n/home/maxbisesi/Music \n/home/maxbisesi/qb_aug6.sql \n/home/maxbisesi/Documents \n/home/maxbisesi/NetBeansProjects \n/home/maxbisesi/.netbeans \n/home/maxbisesi/Downloads ','public class Hello {\n\n    private static ArrayBlockingQueue<String> abq = new ArrayBlockingQueue<>(20);\n\n    public static void main(String[] args) {\n        //ExecutorService ex = ExecutorService.newFixedThreadPool(4);\n        ExecutorService ex = Executors.newFixedThreadPool(4);\n        Future<?> fut = ex.submit(new FileLister());\n        try{\n            System.out.println(fut.get()); // will print null\n        } catch(ExecutionException | InterruptedException e){ }\n        \n        for(String file : abq){\n            System.out.println(file+\" \");\n        }\n\n    }\n\n    static class FileLister implements Runnable {\n        public void run() {\n            Path home = Paths.get(\"/home/maxbisesi\");\n            try (DirectoryStream<Path> stream = Files.newDirectoryStream(home)) {\n                for (Path path : stream) {\n                    boolean added = false;\n                    added = abq.offer(path.toString());\n                    System.out.println(\"added: \"+added);\n\n                    if (!added) {\n                        System.out.println(\"queue is full offer will not add anymore\");\n                    }\n                }\n            } catch (IOException e) { }\n        }\n    }\n}','Concurrency',0,0,NULL,5),(1153,'Cat\ntrue\nSheep\nGoat\nCow\nBull\n\nqueues remove from the head, here remove() returns the object removed,\nthe remove(E e) return true or false, the eleemnts are sorted according to\ntheir compareTo which orders in ascending order by size. ','public class Hello {\n    public static void main(String[] dicks){\n        PriorityQueue<Animal> q = new PriorityQueue<>();\n        \n        q.add(new Animal(5,\"Sheep\"));\n        q.offer(new Animal(6,\"Goat\"));\n        q.offer(new Animal(10,\"Cow\"));\n        q.offer(new Animal(12,\"Bull\"));\n        q.offer(new Animal(3,\"Cat\"));\n        q.offer(new Animal(7,\"Sloth\"));\n        \n        System.out.println(q.remove());\n        System.out.println(q.remove(new Animal(7,\"Sloth\")));\n        \n        while(!q.isEmpty()){\n            System.out.println(q.poll());\n        }\n    }\n}\n\nclass Animal implements Comparable<Animal> {\n    private Integer size;\n    private String name;\n    \n    public Animal(int x, String y){\n        size = x;\n        name = y;\n    }\n    public Animal(){\n        size = 0;\n        name = \"\";\n    }\n\n    public int getSize() {\n        return size;\n    }\n\n    public String getName() {\n        return name;\n    }\n    \n    public String toString(){\n        return name;\n    }\n    \n    public int compareTo(Animal o){\n        return size.compareTo(o.getSize());\n        \n    }\n    \n        \n    public boolean equals(Object o){\n        if((o instanceof Animal)){\n            if((((Animal)o).getSize() == this.size) && (((Animal)o).getName().equals(name) ))\n                return true;\n            return false;           \n        } \n        return false;\n    }\n\n}','Collections',0,0,NULL,5),(1154,'java.nio.file.NoSuchFileException: /home/maxbisesi/Public/GenDir/genFile.txt\n\nthe directory must exist before a file is created in it. ','public static void main(String[] args){\n        try{\n            Path p = Paths.get(\"/home/maxbisesi/Public/GenDir/genFile.txt\");\n            Files.createFile(p);\n        } catch(IOException e){System.out.println(e);}\n        \n        \n    }\n\nGenDir directory does not exist. ','IO',0,0,NULL,5),(1155,'It should be jrs.insertRow(), the docs say that updateRow cannot be called\nwhile on the insert row. \n\nThis will not work, will throw a SQLException',' public void addFlashCard(Card c) {\n        try{\n            jrs.moveToInsertRow();\n            jrs.updateString(\"answer\",c.getAnswer());\n            jrs.updateString(\"card\",c.getCard());\n            jrs.updateString(\"category\",c.getCategory());\n            jrs.updateRow();\n            \n            System.out.printf(\"Flash Card added: today: %1$03d \\n last added:\\n %2$s \\n category:%3$s\",todaysCount,c.getCard(),c.getCategory());\n            todaysCount++;\n        } catch(SQLException e){\n            System.out.println(\"something went wrong adding flashcards to rowset\");\n            System.out.println(e);\n        }\n    }','JDBC',0,0,NULL,5),(1156,'true\nlast modified: August 8, 2017 at: 12:14 PM\nlast accessed: August 8, 2017 at: 3:58 PM\ncreated: August 8, 2017 at: 12:14 PM','public class Hello {\n\n    public static void main(String[] args) {\n        new Hello().printDateTime(Paths.get(\"/home/maxbisesi\"));\n    }\n\n    public void printDateTime(Path d) {\n        DateFormat df = DateFormat.getDateInstance(DateFormat.LONG);\n        DateFormat dftime = DateFormat.getTimeInstance(DateFormat.SHORT);\n        try {\n            BasicFileAttributes ba = Files.readAttributes(d, BasicFileAttributes.class);\n            String creationDate = df.format(ba.creationTime().toMillis());\n            String lastAccessedDate = df.format(ba.lastAccessTime().toMillis());\n            String lastModifiedDate = df.format(ba.lastModifiedTime().toMillis());\n\n            String creationTime = dftime.format(ba.creationTime().toMillis());\n            String lastAccessedTime = dftime.format(ba.lastAccessTime().toMillis());\n            String lastModifiedTime = dftime.format(ba.lastModifiedTime().toMillis());\n\n            System.out.println(ba.isDirectory());\n\n            System.out.println(\"last modified: \" + lastModifiedDate + \" at: \" + lastModifiedTime);\n            System.out.println(\"last accessed: \" + lastAccessedDate + \" at: \" + lastAccessedTime);\n            System.out.println(\"created: \" + creationDate + \" at: \" + creationTime);\n\n        } catch (IOException e) { System.out.println(e);}\n\n    }\n}','Strings',0,0,NULL,5),(1157,'WNC unreported IOException at Files.walkFileTree()\n\nnon static inner class FileInfoPrinter cant be access from static context','public class Hello {\n\n    public static void main(String[] args) {\n        Path home = Paths.get(\"/home/maxbisesi\");\n        Files.walkFileTree(home,new FileInfoPrinter());\n    }\n\n    public void printDateTime(Path d) {\n        DateFormat df = DateFormat.getDateInstance(DateFormat.LONG);\n        DateFormat dftime = DateFormat.getTimeInstance(DateFormat.SHORT);\n        try {\n            BasicFileAttributes ba = Files.readAttributes(d, BasicFileAttributes.class);\n            String creationDate = df.format(ba.creationTime().toMillis());\n            String lastAccessedDate = df.format(ba.lastAccessTime().toMillis());\n            String lastModifiedDate = df.format(ba.lastModifiedTime().toMillis());\n\n            String creationTime = dftime.format(ba.creationTime().toMillis());\n            String lastAccessedTime = dftime.format(ba.lastAccessTime().toMillis());\n            String lastModifiedTime = dftime.format(ba.lastModifiedTime().toMillis());\n\n            System.out.println(\"directory: \" + ba.isDirectory());\n\n            System.out.println(\"last modified: \" + lastModifiedDate + \" at: \" + lastModifiedTime);\n            System.out.println(\"last accessed: \" + lastAccessedDate + \" at: \" + lastAccessedTime);\n            System.out.println(\"created: \" + creationDate + \" at: \" + creationTime);\n\n        } catch (IOException e) {\n            System.out.println(e);\n        }\n\n    }\n\n    class FileInfoPrinter extends SimpleFileVisitor<Path> {\n\n        public FileVisitResult preVisitDirectory(Path file, BasicFileAttributes attrs) {\n            System.out.print(file);\n            printDateTime(file);\n            return FileVisitResult.CONTINUE;\n        }\n\n    }\n}','Strings',0,0,NULL,5),(1158,'maxbisesi\n\ngetFileName() is different from getName(int index)\n\nkeep in mind that getFileName() and getName return a Path','public static void main(String[] args) {\n        Path home = Paths.get(\"/home/maxbisesi\");\n        System.out.println(home.getFileName());\n    }\n}','IO',0,0,NULL,5),(1159,'This will print out the contents of the home directory but skipping hidden files\nthat begin with a . like .config.\n\nremember that FileVisitor goes down as deep as it can before returning back up the\ntree.\n\nand files and directories at the same level can get visited in any order. \n\n\n/home/maxbisesi\ndirectory: true\n\nlast modified: August 8, 2017 at: 12:14 PM\nlast accessed: August 8, 2017 at: 3:58 PM\ncreated: August 8, 2017 at: 12:14 PM\n\n/home/maxbisesi/Desktop\ndirectory: true\n\nlast modified: July 21, 2017 at: 9:15 AM\nlast accessed: August 9, 2017 at: 11:33 AM\ncreated: July 21, 2017 at: 9:15 AM\n\n/home/maxbisesi/Templates\ndirectory: true\n\nlast modified: July 21, 2017 at: 9:15 AM\nlast accessed: August 9, 2017 at: 11:33 AM\ncreated: July 21, 2017 at: 9:15 AM\n\n/home/maxbisesi/Music\ndirectory: true\n\nlast modified: July 21, 2017 at: 9:15 AM\nlast accessed: August 9, 2017 at: 11:33 AM\ncreated: July 21, 2017 at: 9:15 AM\n\n/home/maxbisesi/Documents\ndirectory: true\n\nlast modified: July 24, 2017 at: 9:51 AM\nlast accessed: August 9, 2017 at: 11:33 AM\ncreated: July 24, 2017 at: 9:51 AM\n\n/home/maxbisesi/Documents/Code\ndirectory: true\n\nlast modified: August 8, 2017 at: 11:59 AM\nlast accessed: August 8, 2017 at: 11:59 AM\ncreated: August 8, 2017 at: 11:59 AM\n\n/home/maxbisesi/Documents/resumes\ndirectory: true\n\nlast modified: July 24, 2017 at: 9:51 AM\nlast accessed: August 9, 2017 at: 11:33 AM\ncreated: July 24, 2017 at: 9:51 AM\n\n/home/maxbisesi/NetBeansProjects\ndirectory: true\n\nlast modified: July 29, 2017 at: 12:03 PM\nlast accessed: August 9, 2017 at: 11:33 AM\ncreated: July 29, 2017 at: 12:03 PM\n\n/home/maxbisesi/NetBeansProjects/SourceManager\ndirectory: true\n\nlast modified: July 22, 2017 at: 2:52 PM\nlast accessed: August 8, 2017 at: 3:09 PM\ncreated: July 22, 2017 at: 2:52 PM\n\n/home/maxbisesi/NetBeansProjects/SourceManager/dist\ndirectory: true\n\nlast modified: July 22, 2017 at: 2:52 PM\nlast accessed: August 9, 2017 at: 11:33 AM\ncreated: July 22, 2017 at: 2:52 PM\n\n/home/maxbisesi/NetBeansProjects/SourceManager/nbproject\ndirectory: true\n\nlast modified: July 22, 2017 at: 12:35 PM\nlast accessed: August 8, 2017 at: 3:09 PM\ncreated: July 22, 2017 at: 12:35 PM\n','public class Hello {\n\n    public static void main(String[] args) {\n        Path home = Paths.get(\"/home/maxbisesi\");\n        Hello h = new Hello();\n        Hello.FileInfoPrinter fip = h.new FileInfoPrinter();\n        try{\n            Files.walkFileTree(home,fip);\n        }catch(IOException e){ }\n    }\n\n    public static void printDateTime(Path d) {\n        DateFormat df = DateFormat.getDateInstance(DateFormat.LONG);\n        DateFormat dftime = DateFormat.getTimeInstance(DateFormat.SHORT);\n        try {\n            BasicFileAttributes ba = Files.readAttributes(d, BasicFileAttributes.class);\n            String creationDate = df.format(ba.creationTime().toMillis());\n            String lastAccessedDate = df.format(ba.lastAccessTime().toMillis());\n            String lastModifiedDate = df.format(ba.lastModifiedTime().toMillis());\n\n            String creationTime = dftime.format(ba.creationTime().toMillis());\n            String lastAccessedTime = dftime.format(ba.lastAccessTime().toMillis());\n            String lastModifiedTime = dftime.format(ba.lastModifiedTime().toMillis());\n\n            System.out.println(\"directory: \" + ba.isDirectory());\n            System.out.println(\"\");\n            System.out.println(\"last modified: \" + lastModifiedDate + \" at: \" + lastModifiedTime);\n            System.out.println(\"last accessed: \" + lastAccessedDate + \" at: \" + lastAccessedTime);\n            System.out.println(\"created: \" + creationDate + \" at: \" + creationTime);\n            System.out.println(\"\");\n\n        } catch (IOException e) {\n            System.out.println(e);\n        }\n\n    }\n\n    class FileInfoPrinter extends SimpleFileVisitor<Path> {\n        private Pattern p = Pattern.compile(\"\\\\..*\");\n        private Matcher hidden;\n        \n\n        public FileVisitResult preVisitDirectory(Path file, BasicFileAttributes attrs) {\n            hidden = p.matcher(file.getFileName().toString());\n            if(hidden.find()){\n                return FileVisitResult.SKIP_SUBTREE;\n            }\n            System.out.print(file);\n            System.out.println(\"\");\n            printDateTime(file);\n            return FileVisitResult.CONTINUE;\n        }\n\n    }\n}','IO',0,0,NULL,5),(1160,'BasicFileAttributes is absract cannot be instantiated.\n\nshould be:\n\n	BasicFileAttributes ba = Files.readAttributes(path,BasicFileAttributes.class);','public class Hello {\n\n    public static void main(String[] args) {\n        Path home = Paths.get(\"/home/maxbisesi\");\n        Hello h = new Hello();\n        Hello.FileInfoPrinter fip = h.new FileInfoPrinter();\n        try{\n            Files.walkFileTree(home,fip);\n        }catch(IOException e){ }\n    }\n\n    public static void printDateTime(Path d) {\n        DateFormat df = DateFormat.getDateInstance(DateFormat.LONG);\n        DateFormat dftime = DateFormat.getTimeInstance(DateFormat.SHORT);\n        try {\n            //BasicFileAttributes ba = Files.readAttributes(d, BasicFileAttributes.class);\n            BasicFileAttributes ba = new BasicFileAttributes(d, BasicFileAttributes.class);\n            String creationDate = df.format(ba.creationTime().toMillis());\n            String lastAccessedDate = df.format(ba.lastAccessTime().toMillis());\n            String lastModifiedDate = df.format(ba.lastModifiedTime().toMillis());\n\n            String creationTime = dftime.format(ba.creationTime().toMillis());\n            String lastAccessedTime = dftime.format(ba.lastAccessTime().toMillis());\n            String lastModifiedTime = dftime.format(ba.lastModifiedTime().toMillis());\n\n            System.out.println(\"directory: \" + ba.isDirectory());\n            System.out.println(\"\");\n            System.out.println(\"last modified: \" + lastModifiedDate + \" at: \" + lastModifiedTime);\n            System.out.println(\"last accessed: \" + lastAccessedDate + \" at: \" + lastAccessedTime);\n            System.out.println(\"created: \" + creationDate + \" at: \" + creationTime);\n            System.out.println(\"\");\n\n        } catch (IOException e) {\n            System.out.println(e);\n        }\n\n    }\n\n    class FileInfoPrinter extends SimpleFileVisitor<Path> {\n        private Pattern p = Pattern.compile(\"\\\\..*\");\n        private Matcher hidden;\n        \n\n        public FileVisitResult preVisitDirectory(Path file, BasicFileAttributes attrs) {\n            hidden = p.matcher(file.getFileName().toString());\n            if(hidden.find()){\n                return FileVisitResult.SKIP_SUBTREE;\n            }\n            System.out.print(file);\n            System.out.println(\"\");\n            printDateTime(file);\n            return FileVisitResult.CONTINUE;\n        }\n\n    }\n}','IO',0,0,NULL,5),(1161,'FileVisitor method throw IOExceptions,\n\nbut in overrides if you choose not to declare an exception that is ok, demonstrated\nhere. ','class FileInfoPrinter extends SimpleFileVisitor<Path> {\n        private Pattern p = Pattern.compile(\"\\\\..*\");\n        private Matcher hidden;\n        \n\n        public FileVisitResult preVisitDirectory(Path file, BasicFileAttributes attrs){\n            hidden = p.matcher(file.getFileName().toString());\n            if(hidden.find()){\n                return FileVisitResult.SKIP_SUBTREE;\n            }\n            //makeFileCreatedOnMonday(file);\n            System.out.print(file);\n            System.out.println(\"\");\n            printDateTime(file);\n            return FileVisitResult.CONTINUE;\n        }\n        \n        public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\n            makeFileCreatedOnMonday(file);\n            return FileVisitResult.CONTINUE;\n        }\n\n    }','IO',0,0,NULL,5),(1162,'got it','class DateAsker implements Runnable {\n    private final int priority;\n    \n    public DateAsker(){\n        priority = ThreadLocalRandom.current().nextInt(0,5);\n    }\n    \n    \n    public void run(){\n        DateGiver dg = DateGiver.heyyou();\n        BlockingQueue<Date> bq = dg.availability();\n        Calendar c = Calendar.getInstance();\n        \n        try{\n            if(priority >= 4){\n                \n                Date next = bq.take();// blocks until available\n                c.setTime(next);\n                c.add(Calendar.DAY_OF_WEEK,2);\n                bq.put(c.getTime()); // returns void blocks until spac is available\n                \n            } else if(priority < 4 && priority >= 3){\n                \n                Date next = bq.poll(2000,TimeUnit.SECONDS);\n                c.setTime(next);\n                //c.add(Calendar.WEEK_IN_MONTH,2);\n                c.add(Calendar.WEEK_OF_MONTH,2);\n                bq.offer(c.getTime()); // returns true if object was added. false if the queeu is bouned and full  \n\n            } else {\n                Date next = bq.element();// gets the head of the queue without removing it. Throws NoSuchElementException if queue is empty\n                c.roll(Calendar.DAY_OF_MONTH,6);\n                c.roll(Calendar.HOUR_OF_DAY,20);\n                c.set(Calendar.MONTH,Calendar.JANUARY);\n                \n                bq.add(c.getTime()); // throws IllegalStateException if queue is bounded and full.\n                        \n            }\n        } catch(InterruptedException e){\n            \n        }\n\n        \n        \n    }\n}','Concurrency',0,0,NULL,5),(1163,'Singelton','class DateGiver implements Runnable {\n    private BlockingQueue<Date> dates = new ArrayBlockingQueue<>(25);\n    private static final DateGiver INSTANCE = new DateGiver();\n    \n    private DateGiver(){\n        \n    }\n    \n    public static DateGiver heyyou(){\n        return INSTANCE;\n    }\n\n    public void run(){\n        try{\n            Date d = new Date();\n            Calendar c = Calendar.getInstance();\n            c.setTime(d);\n            while(dates.peek() != null){\n                c.add(Calendar.DAY_OF_MONTH, 1);\n                dates.put(c.getTime());\n            }\n        }catch(InterruptedException e){\n            System.out.println(\"Sorry I got interrupted\");\n        }\n        \n    }\n    \n    public BlockingQueue<Date> availability(){\n        return dates;\n    }\n}\n\nwhat design pattern is this ?','OOP',0,0,NULL,5),(1164,'The instance getting method needs to be static. ','class DateGiver implements Runnable {\n    private BlockingQueue<Date> dates = new ArrayBlockingQueue<>(25);\n    private static final DateGiver INSTANCE = new DateGiver();\n    \n    private DateGiver(){\n        \n    }\n    \n    public DateGiver heyyou(){\n        return INSTANCE;\n    }\n\n    public void run(){\n        try{\n            Date d = new Date();\n            Calendar c = Calendar.getInstance();\n            c.setTime(d);\n            while(dates.peek() != null){\n                c.add(Calendar.DAY_OF_MONTH, 1);\n                dates.put(c.getTime());\n            }\n        }catch(InterruptedException e){\n            System.out.println(\"Sorry I got interrupted\");\n        }\n        \n    }\n    \n    public BlockingQueue<Date> availability(){\n        return dates;\n    }\n}\n\nWhat is missing from making this pattern singelton ? ','OOP',1,0,NULL,5),(1165,'WNC, an ArrayBlockingQueue is bounded and needs to be created \nwith an initial capacity.\n\n','class DateGiver implements Runnable {\n    private BlockingQueue<Date> dates = new ArrayBlockingQueue<>();\n    private static final DateGiver INSTANCE = new DateGiver();\n    \n    private DateGiver(){\n        \n    }\n    \n    public static DateGiver heyyou(){\n        return INSTANCE;\n    }\n\n    public void run(){\n        try{\n            Date d = new Date();\n            Calendar c = Calendar.getInstance();\n            c.setTime(d);\n            while(dates.peek() != null){\n                c.add(Calendar.DAY_OF_MONTH, 1);\n                dates.put(c.getTime());\n            }\n        }catch(InterruptedException e){\n            System.out.println(\"Sorry I got interrupted\");\n        }\n        \n    }\n    \n    public BlockingQueue<Date> availability(){\n        return dates;\n    }\n}','OOP',0,0,NULL,5),(1166,'LinkedBlockingQueue','Which concurrent collection is Optionally bounded ?','Concurrency',0,0,NULL,5),(1167,'WNC cannot assign a value to final variable people. \n\ninterface variables are implicity constants. ','public class Hello {\n\n    public static void main(String[] args) {\n        \n        Burnable stick = new Burnable(){\n            public void burn(){\n                System.out.println(\"Theres \"+people+\" people here so get the fire going\");\n            }\n            \n            public int unburn(){\n                System.out.println(\"That\'s impossible\");\n                return 0;\n            }\n            \n            public void shakeoff(){\n                System.out.println(\"That was my shoe!\");\n            }\n            \n            public void lookwhosHere(){\n                people++;\n                System.out.println(\"hey now theres \"+people+\" here.\");\n            }\n            \n        };\n    }\n\n}\n\ninterface Burnable{\n    int people = 10;\n    void burn();\n    void shakeoff();\n    int unburn();\n}','Concurrency',0,0,NULL,5),(1168,'WNC you cannot guarentee that c wont be pointing to a list<Dog> so \nyou cannot assign what is coming out to a Beagle reference. It could be \nAnimal or Dog.','public class Hello<T> {\n    \n    public static void main(String[] args){\n        \n        Dog d = new Dog();\n        \n        ArrayList<? extends Dog> c = new ArrayList<Beagle>();\n        \n        Beagle a = c.get(0);\n    } \n}\n\nclass Animal{}\nclass Dog extends Animal { }\nclass Beagle extends Dog { }\nclass Marly extends Beagle{ }','Concurrency',0,0,NULL,5),(1169,'T does not bind to a specific class here. \n\n\nThis call does not bind T to a specific class. Java does not need to know the exact T because of type erasure implementation of the generics. As long as the types that you pass are consistent with the declaration, the code should compile; in your case, lists of Object and String are consistent with the declaration.\n\nLet\'s expand your code a little so that we could force binding of T to a specific type. Perhaps the easiest way to do it is to pass Class<T>, like this:\n\nstatic <T> void doSomething(List<? super T> list1, List<? extends T> list2, Class<T> cl) {\n    System.out.println(cl);\n}\n\nNow let us try calling doSomething with String.class and with Object.class:\n\ndoSomething(new ArrayList<Object>(), new ArrayList<String>(), Object.class);\ndoSomething(new ArrayList<Object>(), new ArrayList<String>(), String.class);\n\nBoth calls successfully compile, producing the output\n\nclass java.lang.Object\nclass java.lang.String','static <T> void doSomething(List<? super T> list1, List<? extends T> list2) { }\n\ndoSomething(new ArrayList<Object>(), new ArrayList<String>());\n\nWould T type evaluate as Object or String?\n','Generics',0,0,NULL,5),(1170,'helper methods can be used to capture the wildcard','public class WildcardFixed {\n\n    void foo(List<?> i) {\n        fooHelper(i);\n    }\n\n\n    // Helper method created so that the wildcard can be captured\n    // through type inference.\n    private <T> void fooHelper(List<T> l) {\n        l.set(0, l.get(0));\n    }\n\n}','Generics',0,0,NULL,5),(1171,'Compiles fine, any thing coming out of src should be able to be added to dest. \n','public class Hello {\n    \n    public static void main(String[] args){\n        ArrayList<Object> dogs = new ArrayList<>();\n        ArrayList<Object> marlies = new ArrayList<>();\n        \n        copy(dogs,marlies);\n    } \n    \n     public static <T> void copy(List<? super T> dest, List<? extends T> src) {\n         for(T t : src){\n             dest.add(t);\n         }\n    }  \n}\n\nclass Animal{}\nclass Dog extends Animal { }\nclass Beagle extends Dog { }\nclass Marly extends Beagle{ }','Generics',0,0,NULL,5),(1172,'compiles, anything coming the source has to be of type that is safe to be added\nto the dest. ','public class Hello {\n    \n    public static void main(String[] args){\n        ArrayList<Marly> dogs = new ArrayList<>();\n        ArrayList<Animal> marlies = new ArrayList<>();\n        \n        copy(marlies, dogs);\n    } \n    \n     public static <T> void copy(List<? super T> dest, List<? extends T> src) {\n         for(T t : src){\n             dest.add(t);\n         }\n    }  \n}\n\nclass Animal{}\nclass Dog extends Animal { }\nclass Beagle extends Dog { }\nclass Marly extends Beagle{ }','Generics',1,0,NULL,5),(1173,'12\nTurtle 1\nTurtle 2\nTurtle 1\nTurtle 1\nTurtle 2\nTurtle 1\nTurtle 1\nTurtle 1\nTurtle 1\nTurtle 1\nTurtle 1\nTurtle 1\n\nwhile it\'s true that Set don\'t allow duplicates it disallows them by using the \nequals method it can only use equals to among elements in the same bucket. So Because\nturtle didn\'t implement hashCode() all the elements went into seperate buckets\nand there was nothing to compare against.','public class Hello {\n  public static void main(String[] args){\n      LinkedHashSet<Turtle> t = new LinkedHashSet<>();\n      t.add(new Turtle(1)); t.add( new Turtle(2)); t.add(new Turtle(1));\n      t.add(new Turtle(1)); t.add( new Turtle(2)); t.add(new Turtle(1));\n      t.add(new Turtle(1)); t.add(new Turtle(1)); t.add(new Turtle(1));\n      t.add(new Turtle(1)); t.add(new Turtle(1)); t.add(new Turtle(1));\n      \n      System.out.println(t.size());\n      for(Turtle x : t){\n          System.out.println(x);\n      }\n\n  }\n   \n}\n\ninterface Hungry<E> { void munch(E x); }\nabstract class Animal { }\nabstract class Plant { }\nclass Grass extends Plant { }\n\nclass Turtle {\n    int size;\n    String name;\n    public Turtle(int z){\n        size = z;\n        name = \"Turtle \"+size;\n    }\n    \n    public boolean equals(Object o){\n        return (this.size == ((Turtle)o).size);\n    }\n    \n    public String toString(){\n        return name;\n    }\n    \n    //public int hashCode() { return size/5; }\n}','Collections',0,0,NULL,5),(1174,'all animals eat\nall animals eat\nall animals eat\nEat salmon','public class Hello<T> {\n    public static void main(String[] args){\n        Animal cat = new Animal(5);\n        Animal bear = new Bear();\n        \n        cat.eat();\n        Animal.eat();\n        bear.eat();\n        Bear.eat();\n\n    } \n }\n\nclass Animal{\n    private int size;\n    public Animal(int s){\n        size = s;\n    }\n    public static void eat(){\n        System.out.println(\"all animals eat\");\n    }\n    public void makeSound(){\n            System.out.println(\"Sound!\");\n            \n    }\n    \n    public int getSize(){\n        return size;\n    }\n\n    public boolean equals(Object o){\n        // equals without instanceof \n        if(((Animal)o).getSize() == this.size){\n            return true;\n        } else {\n            return false;\n        }\n        \n    }\n}\n\nclass Bear extends Animal{\n    private static int ALLBEARSAREBIG = 100;\n    \n    public Bear(){\n        super(ALLBEARSAREBIG);\n        \n    }\n    \n    public static void eat(){\n        System.out.println(\"Eat salmon\");\n    }\n    \n}','OOP',0,0,NULL,5),(1175,'/tmp/google/file.txt\n../../../tmp/google/file.txt\n/home/max/tmp/tmp/google/file.txt\nException in thread \"main\" java.lang.IllegalArgumentException: \'other\' is different type of Path\n\nif other is an abolute path resolve returns the other, p2 is  an absolute \npath.\n\na relative path cannot be contructed if only one of the paths have a root \ncomponent. ','class Hello {\n    public static void main(String[] args) {     \n        Path p1 = Paths.get(\"/home/max/tmp/\");\n        Path p2 = Paths.get(\"/tmp/google/file.txt\");\n        Path p3 = Paths.get(\"tmp/google/file.txt\");\n        System.out.println(p1.resolve(p2));\n        System.out.println(p1.relativize(p2));\n        System.out.println(p1.resolve(p3));\n        System.out.println(p1.relativize(p3));\n        \n    }\n\n}','IO',0,0,NULL,5),(1176,'got it\n\nrelativize: IllegalArgumentException\nresolve: /home/maxbisesi/Documents/Code','If one path is absolute and the other is relative relativize will throw \nan Illegal argument Exception.\n\nBoth have to be either relative or absolute. \n\n	Path p1 = Paths.get(\"/home/maxbisesi\");\n        Path p2 = Paths.get(\"Documents/Code\");\n        \n        System.out.println(p1.relativize(p2));\n        System.out.println(p1.resolve(p2));','IO',0,0,NULL,5),(1177,'got it','If the other path is absolute relativize will return the other \n\n    \n        Path p1 = Paths.get(\"/home/max/tmp/\");\n        Path p2 = Paths.get(\"/tmp/google/file.txt\");\n\n        System.out.println(p1.resolve(p2));\n\n	/tmp/google/file.txt','IO',0,0,NULL,5),(1178,'/tmp/google/file.txt\n../../../tmp/google/file.txt\n/home/max/tmp/tmp/google/file.txt\n/tmp/google/file.txt/tmp/google/file.txt\n../../../src/dist/all','class Hello {\n    public static void main(String[] args) {     \n        Path p1 = Paths.get(\"/home/max/tmp/\");\n        Path p2 = Paths.get(\"/tmp/google/file.txt\");\n        Path p3 = Paths.get(\"tmp/google/file.txt\");\n        Path p4 = Paths.get(\"src/dist/all\");\n        System.out.println(p1.resolve(p2));\n        System.out.println(p1.relativize(p2));\n        System.out.println(p1.resolve(p3));\n        System.out.println(p2.resolve(p3));\n        System.out.println(p3.relativize(p4));\n        \n    }\n\n}','IO',0,0,NULL,5),(1179,'got it ','Matcher.end() gives the position after the last character. \n\n	Pattern p = Pattern.compile(\".*y\");\n        Matcher m = p.matcher(\"yyxxxyxx\");\n						 012345678\n        \n        while(m.find()){\n            System.out.println(m.start());\n            System.out.println(m.group());\n            System.out.println(m.end());\n        }\n\nm.end() is 6','Strings',0,0,NULL,5),(1180,'b5 and b8\n\nA class Cast will result from trying to downcast. ','public class Hello{\n    public static void main(String[] args){\n        Bango b1 = new Bango();\n        Bango b2 = new Bongo();\n        Bango b3 = new Bingo();\n        \n        Bongo b4 = b2;\n        Bongo b5 = (Bongo)b1;\n        Bango b6 = b3;\n        Bango b7 = (Bango) b3;\n        Bingo b8 = (Bingo)b1;\n        Bingo b9 = (Bingo) b3;\n        Bango b10 = (Bongo) b3;\n    \n    }\n}\n\nclass Bango { }\nclass Bongo extends Bango { }\nclass Bingo extends Bongo { }\n\nwhich throw a ClassCastException ?','Strings',0,0,NULL,5),(1181,'Gemini\nGemini\nEunech','public class Hello {\n    private String name = \"marco\";\n    private final static String gem = \"Gemini\";\n    private static String west = \"Eunech\";\n   \n    public static void main(String[] args) {\n        Hello h = new Hello();\n        h.methodlocal();\n    }\n    \n    public static void methodlocal(){\n        final int y = 56;\n        //System.out.println(name); //wouldnt compile\n        System.out.println(gem);\n        \n        \n        class Zombie {\n            public int size;\n            public static final int num = 5;\n        \n            public Zombie(int x){ size = x; System.out.println(gem); System.out.println(west);} //System.out.println(name); }\n            public void mone(){\n                System.out.println(\"ughhhg: \"+ size);\n            }\n            \n            public void accessTheLiving(){\n                System.out.println(\"local var: \"+y);\n            }\n            \n        }\n        \n        Zombie zom = new Zombie(7);\n        \n    }\n\n}','Inner Classes',0,0,NULL,5),(1182,'Will not compile, at compile time the compiler does not know what type G is\ngoing to be even though its runtime type will be right, this can still not be\nallowed to compile. ','public class Hello<T> {\n    public static void main(String[] args){\n\n        ArrayList<? extends Animal> c = makeArrayList(new Animal(5));\n        \n        \n    } \n    public static <G extends Animal> ArrayList<G> makeArrayList(G g){\n        ArrayList<G> genlist = new ArrayList();\n        \n        Animal max = new Animal(100);\n        Animal bear = new Animal(45);\n        Animal Hippo = new Animal(45);\n        \n        genlist.add(max); \n        genlist.add(bear);\n        genlist.add(Hippo);\n        return genlist;\n        \n    }\n}','Generics',0,0,NULL,5),(1183,'Compiles','public class Hello {\n    public static void main(String[] args){\n\n        ArrayList<? extends Animal> c = makeArrayList(new Animal());\n        ArrayList<? extends Animal> b = makeArrayList(new Dog());\n        \n        \n    } \n    public static <G extends Animal> ArrayList<G> makeArrayList(G g){\n        ArrayList<G> genlist = new ArrayList();\n        genlist.add(g);\n        \n        return genlist;\n        \n    }\n}\n\nclass Dog extends Animal{}\nclass Beagle extends Dog { }\nclass Animal{}','Generics',0,0,NULL,5),(1184,'Will not compile, \n\nhere makeArrayList is only bounded by the INPUT the output is pretty straightforward\nit is excactly type G. Which is Below Dog in the Heirarchy so a Beagle \nList could not be applied to a ? super Dog list. ','public class Hello {\n    public static void main(String[] args){\n\n        ArrayList<? extends Animal> c = makeArrayList(new Animal());\n        ArrayList<? extends Animal> b = makeArrayList(new Dog());\n        ArrayList<? super Dog> a = makeArrayList(new Beagle());\n        \n        \n    } \n    public static <G extends Animal> ArrayList<G> makeArrayList(G g){\n        ArrayList<G> genlist = new ArrayList();\n        genlist.add(g);\n        \n        return genlist;\n        \n    }\n}\n\nclass Dog extends Animal{}\nclass Beagle extends Dog { }\nclass Animal{}','Generics',0,0,NULL,5),(1185,'This will compile.','public class Hello {\n    public static void main(String[] args){\n\n        ArrayList<? extends Animal> c = makeArrayList(new Animal());\n        ArrayList<? extends Animal> b = makeArrayList(new Dog());\n        ArrayList<? super Beagle> a = makeArrayList(new Beagle());\n        \n        \n    } \n    public static <G extends Animal> ArrayList<G> makeArrayList(G g){\n        ArrayList<G> genlist = new ArrayList();\n        genlist.add(g);\n        \n        return genlist;\n        \n    }\n}\n\nclass Dog extends Animal{}\nclass Beagle extends Dog { }\nclass Animal{}','Generics',0,0,NULL,5),(1186,'Will not compile, cannot add Dog to ArrayList typed for T ','public class Hello {\n    public static void main(String[] args){\n        Printer<String> x = Printer.getInstance();\n\n    }\n    public static <T> void addAnimal(List<T> animals) {\n	animals.add(new Dog());\n    }\n    \n    public <G> ArrayList<G> makeArrayList(G g){\n        ArrayList<G> genlist = new ArrayList();\n        genlist.add(g);\n        return genlist;\n        \n    }\n}\n\nclass Dog{ }','Generics',0,0,NULL,5),(1187,'First if you dont shutdown an executorService it will keep running and the \nprogram will never end.\n\nSecond the regex patter created is never applied to the lines coming in.','public class Hello {\n    \n    public static void main(String[] args){\n        Path file = Paths.get(\"/home/maxbisesi/Public/Data/sumOftwointsinarray.txt\");\n        FileSearcher fs = new FileSearcher(file,\"\\\\b\\\\w\\\\w\\\\w\\\\b\");\n        ExecutorService es = Executors.newCachedThreadPool();\n        System.out.println(\"We\'re wating on your search results\");\n        Future<HashMap<Integer,String>> futuresearch = es.submit(fs);\n        \n        try{\n            HashMap<Integer,String> searchresults;\n            searchresults = futuresearch.get();\n            HashMap<Integer,String> moreresults = futuresearch.get();\n            \n            if(searchresults == null){\n                System.out.println(\"There were no results bro\");\n                System.exit(0);\n            }\n            for(Map.Entry<Integer,String> entry : searchresults.entrySet()){\n                System.out.println(entry.getKey()+\" \"+entry.getValue()+\"\\n\");\n            }\n            \n        }catch(ExecutionException | InterruptedException e){\n            System.out.println(e);\n        }\n    }\n}\n\nclass FileSearcher implements Callable<HashMap<Integer,String>> {\n    private Path fileToLoad;\n    private String regex;\n    public FileSearcher(Path file,String reg){\n        fileToLoad = file;\n        regex = reg;\n    }\n    \n    public HashMap<Integer,String> call() throws IOException{\n        int linenum = 0;\n        HashMap<Integer,String> map = new HashMap<>();\n        BufferedReader br = new BufferedReader(new FileReader(fileToLoad.toFile()));\n        Pattern p = Pattern.compile(regex);\n        Matcher m;\n        String line;\n        while((line = br.readLine()) != null){\n            map.put(++linenum,line);\n        }\n        return map;\n    }\n}\n\nWhat are the flaws here ? ','General',0,0,NULL,5),(1188,'Exception in thread \"main\" java.util.InputMismatchException\n\nfor trying to read a string in as an int thats an exception','public class Hello {\n    \n    public static void main(String[] args){\n        String in = \"1 a 10 . 100 1000\";\n        Scanner s = new Scanner(in);\n        int accum\n        = 0;\n        for (int x = 0; x < 4; x++) {\n        accum += s.nextInt();\n        }\n        System.out.println(accum);\n    }\n}','Strings',0,0,NULL,5),(1189,'Will not compile, String cannot be converted to boolean.\n\nthe additional info in an assert statement must be a string. ','public static void main(String[] args) {\n            int x = 7;\n            assert (x == 6) ? \"x == 6\" : \"x != 6\";\n        }\n    }','Exceptions',0,0,NULL,5),(1190,'IllegalMonitorStateException\n\nthe method go() is synchronized, that means it will lock onto to the currently\nexecuting object. which Here is this, or the \'new Hello()\'\n\na new Thread is started and then waited on but thats not allowed because go\nis synchronized onto the current object.\n\nit should be:\n\n	Thread t1 = new Thread();\n        t1.start();\n        synchronized(t1){\n            System.out.print(\"1 \");\n            t1.wait(5000);\n            System.out.print(\"2 \");\n        }\n        \n        System.out.println(\"All done, main thread\");','public class Hello {\n\n    public static void main(String[] args) {\n        try {\n            new Hello().go();\n        } catch (Exception e) {\n            System.out.println(e);\n        }\n    }\n\n    synchronized void go() throws InterruptedException {\n        Thread t1 = new Thread();\n        t1.start();\n        System.out.print(\"1 \");\n        t1.wait(5000);\n        System.out.print(\"2 \");\n    }\n}','Threads',0,0,NULL,5),(1191,'1 2 All done, main thread','public class Hello {\n\n    public static void main(String[] args) {\n        try {\n            new Hello().go();\n        } catch (Exception e) {\n            System.out.println(e);\n        }\n    }\n\n    synchronized void go() throws InterruptedException {\n        Thread t1 = new Thread();\n        t1.start();\n        synchronized(t1){\n            System.out.print(\"1 \");\n            t1.wait(5000);\n            System.out.print(\"2 \");\n        }\n        \n        System.out.println(\"All done, main thread\");\n    }\n}','Threads',0,0,NULL,5),(1192,'WNC, \n\nyou cannot use a wildcard when creating a Generic class. ','class Printer<? extends Animal> {\n    private ArrayList<T> joblist = new ArrayList<>();\n    private T instance;\n    \n    public Printer(){\n        \n    }\n    \n    public Printer(T b){\n       instance = b;\n    }\n    \n    public void addJob(T t){\n        joblist.add(t);\n    }\n    \n    public void makeSound() {\n        instance.makeSound();\n    }\n    \n    public T getAnewT(){\n        return instance;\n    }\n}\n\nclass Animal{public void makeSound(){\n            System.out.println(\"Sound!\");\n}\n}\nclass Dog extends Animal{}\nclass Beagle extends Dog{}','Generics',0,0,NULL,5),(1193,'If a reference is null it is not an instance of anything. ',' public static void main(String[] args) {\n        String s = null;\n        if(s instanceof String){ System.out.println(\"It Worked\"); } \n        else { System.out.println(\"No\"); }\n \n    }','General',0,0,NULL,5),(1194,'true arrays are always objects any array of any type or primitive.','int[] nums = new int[4];\nif(nums instanceof Obejct){\n	sout( \"true\");\n}','General',1,0,NULL,5),(1195,'WNC you do not use instanceof to compare two references ',' public static void main(String[] args) {\n        List<Object> strlist = new ArrayList<>();\n        ArrayList<String> arraylst = new ArrayList<>();\n        ArrayList<Object> oblist = new ArrayList<>();\n        \n        if(arraylst instanceof strlist){\n            System.out.println(\"it worked!\");\n        } else{\n            System.out.println(\"no\");\n        }\n\n \n    }','General',1,0,NULL,5),(1196,'WNC, instanceof cannot test generic types. Generics are a compile time feature',' public static void main(String[] args) {\n        List<Object> strlist = new ArrayList<>();\n        ArrayList<String> arraylst = new ArrayList<>();\n        ArrayList<Object> oblist = new ArrayList<>();\n        \n        if(arraylst instanceof List<String>){\n            System.out.println(\"it worked!\");\n        } else{\n            System.out.println(\"no\");\n        }\n\n \n    }','General',0,0,NULL,5),(1197,'home\nmaxbisesi\nPublic\nData\nTextFile1.txt','public static void main(String[] args) {\n        Path p1 = Paths.get(\"/home/maxbisesi/Public/Data/TextFile1.txt\");\n        \n        System.out.println(p1.getName(0));\n        System.out.println(p1.getName(1));\n        System.out.println(p1.getName(2));\n        System.out.println(p1.getName(3));\n        System.out.println(p1.getName(4));\n    }','IO',0,0,NULL,5),(1198,'5\nIllegalArgumentException\n\nwith getName() the element that is the closest to the root directory, has an\nindex of 0. \n\nthrows an IllegalArgumentException if the index is greater than the number \nof elements. ','public static void main(String[] args) {\n        Path p1 = Paths.get(\"/home/maxbisesi/Public/Data/TextFile1.txt\");\n        System.out.println(p1.getNameCount());\n        System.out.println(p1.getName(5));\n    }','IO',0,0,NULL,5),(1199,'/\nnull\n\nReturns the root component of this path as a Path object, or null if this \npath does not have a root component.','public static void main(String[] args) {\n        Path p1 = Paths.get(\"/home/maxbisesi/Public/Data/TextFile1.txt\");\n        Path p2 = Paths.get(\"maxbisesi/Public/Data\");\n        System.out.println(p1.getRoot());\n        System.out.println(p2.getRoot());\n        \n    }','IO',0,0,NULL,5),(1200,'WNC,\n\ngetRoot() getName() subPath() resolve() relativize() toAbsolute() \n\nall return Path objects','public static void main(String[] args) {\n        Path p1 = Paths.get(\"/home/maxbisesi/Public/Data/TextFile1.txt\");\n        Path p2 = Paths.get(\"maxbisesi/Public/Data\");\n        String root = p1.getRoot();        \n    }','IO',0,0,NULL,5),(1201,'true\nfalse','public static void main(String[] args) {\n\n        Path p1 = Paths.get(\"/home/maxbisesi/Public/Data/TextFile1.txt\");\n        Path p2 = Paths.get(\"maxbisesi/Public/Data\");\n        \n        boolean ab = p1.isAbsolute();\n        boolean ab2 = p2.isAbsolute();\n        \n        System.out.println(ab);\n        System.out.println(ab2);\n        \n    }','IO',0,0,NULL,5),(1202,'/home/maxbisesi/Public/Data',' public static void main(String[] args) {\n\n        Path p1 = Paths.get(\"/home/maxbisesi/Public/Data/TextFile1.txt\");\n        \n        Path parent = p1.getParent();\n        \n        System.out.println(parent);\n        \n    }','IO',0,0,NULL,5),(1203,'/home/maxbisesi/Public/Data\nnull\n\ngetParent() \n	returns the paths parent or null if the path does not have a parent',' public static void main(String[] args) {\n\n        Path p1 = Paths.get(\"/home/maxbisesi/Public/Data/TextFile1.txt\");\n        Path p2 = Paths.get(\"maxbisesi/Public/Data\");\n        Path p3 = Paths.get(\"maxbisesi\");\n        \n        Path parent = p1.getParent();\n        Path parent2 = p3.getParent();\n        \n        System.out.println(parent);\n        System.out.println(parent2);\n        \n    }','IO',0,0,NULL,5),(1204,'true\n\nthe element that is closest to the root directory in the heirarchy has an\nindex of zero. ','Path methods getName() and subPath() all use zero based indexs ','IO',0,0,NULL,5),(1205,'maxbisesi/Public','public static void main(String[] args) {\n\n        Path p1 = Paths.get(\"/home/maxbisesi/Public/Data/TextFile1.txt\");\n        Path p2 = Paths.get(\"maxbisesi/Public/Data\");\n        \n        Path sub = p1.subpath(1,3); \n        \n        System.out.println(sub);\n        \n    }','IO',0,0,NULL,5),(1206,'home/maxbisesi/Public','public static void main(String[] args) {\n\n        Path p1 = Paths.get(\"/home/maxbisesi/Public/Data/TextFile1.txt\");\n        Path p2 = Paths.get(\"maxbisesi/Public/Data\");\n        \n        Path sub = p1.subpath(0,3); \n        \n        System.out.println(sub);\n        \n    }','IO',0,0,NULL,5),(1207,'Public/Data/TextFile1.txt\n\n    beginIndex - the index of the first element, inclusive\n    endIndex - the index of the last element, exclusive','public static void main(String[] args) {\n\n        Path p1 = Paths.get(\"/home/maxbisesi/Public/Data/TextFile1.txt\");\n        Path p2 = Paths.get(\"maxbisesi/Public/Data\");\n        \n        Path sub = p1.subpath(2,5); \n        \n        System.out.println(sub);\n        \n    }','IO',0,0,NULL,5),(1208,'learn it','Path subpath(int beginIndex,int endIndex)\n\n    beginIndex - the index of the first element, inclusive\n    endIndex - the index of the last element, exclusive','IO',0,0,NULL,5),(1209,'IllegalArgumentException\n\nonly 5 elemetns\n\n    beginIndex - the index of the first element, inclusive\n    endIndex - the index of the last element, exclusive','public static void main(String[] args) {\n\n        Path p1 = Paths.get(\"/home/maxbisesi/Public/Data/TextFile1.txt\");\n        Path p2 = Paths.get(\"maxbisesi/Public/Data\");\n        \n        Path sub = p1.subpath(2,6); \n        \n        System.out.println(sub);\n        \n    }','IO',0,0,NULL,5),(1210,'will read characters from the first file encode them and put them in the\nnext. ','public void scrambleFile(Path file) {\n        \n        FileReader inputStream = null;\n        FileWriter outputStream = null;\n\n        try {\n            inputStream = new FileReader(file.toFile());\n            Path fileToWrite = Paths.get(file.getParent().toString(),\"ScrambledFile\"+filecount+\".txt\");\n            outputStream = new FileWriter(fileToWrite.toString());\n\n            int c;\n            while((c = inputStream.read()) != -1){\n                Character a = key.get((char)c);\n                if(a == null){\n                    continue;\n                } else {\n                    outputStream.write((int)a);\n                }\n                \n            }\n            \n            inputStream.close();\n            outputStream.close();\n\n        } catch(IOException e){\n            System.out.println(e);\n        } \n        \n        filecount++;\n    }','IO',0,0,NULL,5),(1211,'MissingFormatWidthException\n\nwith - and 0 the width is required.','public static void main(String[] args) {\n        double count = -34.45;\n        String s = \" true\";\n        boolean yea = true;\n        boolean nah = false;\n        System.out.printf(\"%1$0(f\",count);\n        \n    }','IO',0,0,NULL,5),(1212,'got it ','java.util.formatter\n\nthe flags - and 0 require you to specify the width','Strings',0,0,NULL,5),(1213,'- and 0 ','what flags in java.util.formatter require you to specify the width ?','Strings',0,0,NULL,5),(1214,'IllegalMonitorStateException,\n\nthe running thread was not synchronized onto t1, \nyou must be synchronized onto an object to wait on it.','public class Hello extends Thread {\n    public static void main(String[] args){\n        new CodeMaker().start();\n    }\n}\n\nclass CodeMaker  extends Thread {\n    private String code;\n    private int counter;\n    private ArrayList<String> al;\n    private char[] letters = {\'A\',\'B\',\'C\',\'D\',\'E\',\'F\',\'G\',\'H\',\'I\'};\n    \n    public CodeMaker(){\n        counter = 0;\n        al = new ArrayList<>();\n    }\n\n    class SectionGenerator implements Runnable{\n        private String sec = \"\";\n        private Random ran = new Random();\n\n        public void run() {\n            //tried to use notify outside of synchronized context\n            synchronized(this){\n                int x = ran.nextInt(3);\n                int y = ran.nextInt(3);\n                int z = ran.nextInt(3);\n            \n            \n                sec += letters[x];\n                sec += letters[y];\n                sec += letters[z];\n                notifyAll();\n            }\n        }\n        \n        public synchronized String section(){\n            return sec;\n        }\n\n    }\n    \n    class NumberGenerator implements Runnable{\n        private String number = \"\";\n        private Random ran = new Random();\n        \n        public void run(){\n            //tried to use notify outside of synchronized context\n            synchronized(this){\n                int x1 = ran.nextInt(100);\n                int x2 = ran.nextInt(100);\n                int x3 = ran.nextInt(100);\n            \n                number += x1+\".\"+x2+\".\"+x3;\n                notifyAll();\n            }\n        }\n        \n        public synchronized String Number(){\n            return number;\n        }\n    }\n    \n   public synchronized void run(){\n       \n       SectionGenerator sg1 = new SectionGenerator();\n       NumberGenerator ng1 = new NumberGenerator();\n       Thread t1 = new Thread(sg1);\n       Thread t2 = new Thread(ng1);\n       \n       t1.start();\n       t2.start();\n       \n       try{\n        t1.wait();\n        code += sg1.section();\n        t2.wait();\n        code += ng1.Number();\n       } catch(InterruptedException e){\n           \n       }\n       System.out.println(code);\n\n       \n   }\n    \n    \n}\n','Threads',0,0,NULL,5),(1215,'its CONCUR_READ_ONLY not TYPE_READ_ONLY','public class Hello extends Thread {\n    public static void main(String[] args){\n        try(Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees\", \"root\", \"Basketball12\")){\n            String getAllEmployeeNames = \"select first_name,last_name from employees\";\n            Statement st1 = conn.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.TYPE_READ_ONLY);\n            \n            ResultSet empnames = st1.executeQuery(getAllEmployeeNames);\n            \n            empnames.last();\n            \n            System.out.println(empnames.getString(\"first_name\")+\" \"+empnames.getString(\"last_name\"));\n            \n        }catch(SQLException e){\n            System.out.println(e);\n        }\n    }\n}','JDBC',0,0,NULL,5),(1216,'Cristinel Bouloucos\nKazuhito Cappelletti\n\ncom.mysql.jdbc.NotUpdatable: Result Set not updatable.This result set must \ncome from a statement that was created with a result set type of \nResultSet.CONCUR_UPDATABLE, the query must select only one table, can not \nuse functions and must select all primary keys from that table. See the \nJDBC 2.1 API Specification, section 5.6 for more details.This result set \nmust come from a statement that was created with a result set type of \nResultSet.CONCUR_UPDATABLE, the query must select only one table, can not \nuse functions and must select all primary keys from that table. See the\n JDBC 2.1 API Specification, section 5.6 for more details.','public static void main(String[] args){\n        try(Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees\", \"root\", \"Basketball12\")){\n            String getAllEmployeeNames = \"select first_name,last_name from employees\";\n            Statement st1 = conn.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);\n            \n            ResultSet empnames = st1.executeQuery(getAllEmployeeNames);\n            \n            empnames.absolute(34);\n            System.out.println(empnames.getString(\"first_name\")+\" \"+empnames.getString(\"last_name\"));\n            empnames.previous();\n            System.out.println(empnames.getString(\"first_name\")+\" \"+empnames.getString(\"last_name\"));\n            empnames.deleteRow();\n            System.out.println(empnames.getString(\"first_name\")+\" \"+empnames.getString(\"last_name\"));\n            \n        }catch(SQLException e){\n            System.out.println(e);\n        }\n    }','JDBC',0,0,NULL,5),(1217,'CONCUR_UPDATABLE lets you delete rows. It will save those changes to the underlying db','public class Hello {\n    public static void main(String[] args){\n        try(Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees\", \"root\", \"Basketball12\")){\n            String getAllEmployeeNames = \"select emp_no,first_name,last_name from employees\";\n            Statement st1 = conn.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_UPDATABLE);\n            \n            ResultSet empnames = st1.executeQuery(getAllEmployeeNames);\n            \n            empnames.absolute(34);\n            System.out.println(empnames.getString(\"first_name\")+\" \"+empnames.getString(\"last_name\"));\n            empnames.previous();\n            System.out.println(empnames.getString(\"first_name\")+\" \"+empnames.getString(\"last_name\"));\n            empnames.deleteRow();\n            System.out.println(empnames.getString(\"first_name\")+\" \"+empnames.getString(\"last_name\"));\n            \n        }catch(SQLException e){\n            System.out.println(e);\n        }\n    }\n}','JDBC',0,0,NULL,5),(1218,'SCROLL SENSITIVE will show what chagnes you have made. ','public class Hello {\n    public static void main(String[] args){\n        try(Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees\", \"root\", \"Basketball12\")){\n            String getAllEmployeeNames = \"select emp_no,first_name,last_name from employees\";\n            Statement st1 = conn.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE,ResultSet.CONCUR_UPDATABLE);\n            \n            ResultSet empnames = st1.executeQuery(getAllEmployeeNames);\n            \n            empnames.absolute(40);\n            System.out.println(empnames.getString(\"first_name\")+\" \"+empnames.getString(\"last_name\"));\n            empnames.next();\n            System.out.println(empnames.getString(\"first_name\")+\" \"+empnames.getString(\"last_name\"));\n            empnames.next();\n            System.out.println(empnames.getString(\"first_name\")+\" \"+empnames.getString(\"last_name\"));\n\n            empnames.next();\n            System.out.println(empnames.getString(\"first_name\")+\" \"+empnames.getString(\"last_name\"));\n            empnames.updateString(\"first_name\",\"BIG MAX\");\n            empnames.updateRow();\n            System.out.println(empnames.getString(\"first_name\")+\" \"+empnames.getString(\"last_name\"));\n            \n            \n        }catch(SQLException e){\n            System.out.println(e);\n        }\n    }\n}','JDBC',0,0,NULL,5),(1219,'','Arrays/Collections must be sorted before being searched. Otherwise results\nwill be unpredictable','Collections',0,0,NULL,5),(1220,'abcd\nabc abc true\nabcd abcd true\n\nstrings are immutable','public static void main(String[] args) {\n	String s1 = \"abc\";\n	String s2 = s1;\n	System.out.println(s1+\"d\");\n	System.out.println(s1+\" \"+s2+\" \"+ (s1==s2));\n	\n	StringBuffer sb1 = new StringBuffer(\"abc\");\n	StringBuffer sb2 = sb1;\n	sb1.append(\"d\");\n	System.out.println(sb1+ \" \" + sb2 + \" \" + (sb1==sb2));\n    }','Strings',0,0,NULL,5),(1221,'builds the directory structure, throwing IOE if necessary','public static void main(String[] args) throws IOException {\n       File file1 = new File(\"/home/maxbisesi/Public/TestDir/file1\");\n       File file2 = new File(\"/home/maxbisesi/Public/TestDir/file2\");\n       File dir = new File(\"/home/maxbisesi/Public/TestDir\");\n       \n       if(dir.exists() && dir.isDirectory()){\n           file1.createNewFile();\n           file2.createNewFile();\n       } else {\n           dir.mkdir();\n           file1.createNewFile();\n           file2.createNewFile();\n       }\n    } ','IO',0,0,NULL,5),(1222,'all inner interfaces are implicitly static','public class Hello {\n    public static void main(String[] args){\n        \n    }\n    \n    interface Handeler{\n        void handle();\n    }\n}\n\nclass Adder implements Hello.Handeler {\n        public void handle(){\n            System.out.println(\"I got this.\");\n        }\n}','OOP',0,0,NULL,5),(1223,'got it','All variables in an interface are implicitly static','OOP',0,0,NULL,5),(1224,'got it ','interface varialbes are implicitly static and final','OOP',0,0,NULL,5),(1225,'does not compile in java 7','interface hungry{\n    static void milk();\n}','OOP',0,0,NULL,5),(1226,'B\nC\n\nthe jvm keeps a constant string pool. With strings == checks the similarity\nof the objects themselves.','public static void main(String[] args) {\n        String s1 = \"hi\";\n        String s2 = new String(\"hi\");\n        String s3 = \"hi\";\n        \n        if(s1 == s2){\n            System.out.println(\"A\");\n        } else{\n            System.out.println(\"B\");\n        }\n        \n        if(s1 == s3){\n            System.out.println(\"C\");\n        } else {\n            System.out.println(\"D\");\n        }\n        \n        \n    }','Strings',0,0,NULL,5),(1227,'true\nThe jvm keeps a pool of Strings and == compares the actuall strings ','public static void main(String[] args) {\n        String s1 = \"hi\";\n        String s3 = \"hi\";\n        \n        System.out.println((s1 == s3));\n        \n        \n    }','Strings',0,0,NULL,5),(1228,'0,0\n\nx=x only reassigns the passed parameter not the member. \n\nyou must use this.x = x;','public class Hello {\n    \n\n    public static void main(String[] args) {\n        Point2D p = new Point2D(10,20);\n        System.out.println(p);\n    }\n    \n}\n\nclass Point2D {\n    private int x,y;\n    \n    public Point2D(int x, int y){\n        x=x;\n    }\n    \n    public String toString(){\n        return x+\",\"+y;\n    }\n}','OOP',0,0,NULL,5),(1229,'k==j: true\nk.equals(j): true\n\nInteger objects are immutable just like strings are. \n\nIf there is an Integer object for a value already exists java will not \ncreate a new object. \n\ntwo integer objects are equal no matter if you use == or equals. Because object \nvalues are all imutable. ','public class Hello {\n    \n\n    public static void main(String[] args) {\n        Integer i = 10;\n        Integer j = 11;\n        Integer k = ++i;\n        System.out.println(\"k==j: \"+(k==j));\n        System.out.println(\"k.equals(j): \"+(k.equals(j)));\n    }\n    \n}','OOP',0,0,NULL,5),(1230,'false\nfalse \ntrue\n\narray objects dont have an equals method. There\'s is inherited from the \nObject class. \n\nThe two objects are not equal themselves they are both seperate.\n\nArrays class has various methods for testing equality of arrays. ','public static void main(String []args) {\n            int []arr1 = {1, 2, 3, 4, 5};\n            int []arr2 = {1, 2, 3, 4, 5};\n            System.out.println(\"arr1 == arr2 is \" + (arr1 == arr2));\n            System.out.println(\"arr1.equals(arr2) is \" + arr1.equals(arr2));\n\n            System.out.println(\"Arrays.equals(arr1, arr2) is \" +java.util.Arrays.equals(arr1, arr2));\n}','OOP',0,0,NULL,5),(1231,'Animal\nBear\nObject\nAnimal\n\noverloading is based on the static types of the objects\noverridig and runtime resolution resolves to the dynamic type. ','public class Hello {\n\n        public static void main(String []args) {\n            Animal a = new Animal();\n            Animal b = new Bear();\n            \n            overload(a);\n            overload((Bear)b);\n            overload((Object)b);\n            overload(b);\n            \n        }\n        \n        public static void overload(Animal a){\n            System.out.println(\"Animal\");\n        }\n        public static void overload(Bear b){\n            System.out.println(\"Bear\");\n        }\n        public static void overload(Grizzly g){\n            System.out.println(\"Grizzly\");\n        }\n        public static void overload(Object o){\n            System.out.println(\"Object\");\n        }\n}\n\nclass Animal{}\nclass Bear extends Animal{}\nclass Grizzly extends Bear{}','OOP',0,0,NULL,5),(1232,'foo(long)\n\nfor an integer literal the jvm matches in the following order:\n\n	int, long,Integer, int...\n\n','public class Hello {\n\n        public static void main(String []args) {\n                foo(10);\n        }\n        public static void foo(Integer i) { System.out.println(\"foo(Integer)\"); }\n        public static void foo(short i) { System.out.println(\"foo(short)\"); }\n        public static void foo(long i) { System.out.println(\"foo(long)\"); }\n        public static void foo(int ... i) { System.out.println(\"foo(int ...)\"); }\n}','OOP',0,0,NULL,5),(1233,'WNC reference to foo is ambiguous','public class Hello {\n\n        public static void main(String []args) {\n                foo(null);\n        }\n        public static void foo(Integer i) { System.out.println(\"foo(Integer)\"); }\n        public static void foo(short i) { System.out.println(\"foo(short)\"); }\n        public static void foo(long i) { System.out.println(\"foo(long)\"); }\n        public static void foo(int ... i) { System.out.println(\"foo(int ...)\"); }\n}','OOP',0,0,NULL,5),(1234,'A\nB\nC\nD\n\nhow to iterate through an enum. \n\nuse values()','enum Cards{ A,B,C,D };\npublic class Hello {\n\n        public static void main(String []args) {\n                for(Cards card: Cards.values()){\n                    System.out.println(card +\" \");\n                }\n        }\n\n}','General',0,0,NULL,5),(1235,'WNC,\n\nreference to name is ambiguous','abstract class AbstractBook {\n    public String name;\n}\n\ninterface sleepy{\n    public String name = \"undefined\";\n}\n\nclass Book extends AbstractBook implements sleepy{\n    public Book(String name){\n        this.name = name;\n    }\n            \n}\npublic class Hello {\n\n        public static void main(String []args) {\n           AbstractBook ab = new Book(\"Diamonds\");\n            System.out.println(ab.name);\n        }\n\n}','General',0,0,NULL,5),(1236,'the removed element is 1\n\nDeque is a double ended queue. \n\ncan be added and removed from the head or tail. ','public class Hello {\n\n    public static void main(String []args) {\n        Deque<Integer> deque = new ArrayDeque<>();\n        deque.addAll(Arrays.asList(1, 2, 3, 4, 5));\n        System.out.println(\"The removed element is: \" + deque.remove());\n    }\n}','General',0,0,NULL,5),(1237,'got it ','Dequeue methods:\n\n           First Element (Head) 	             Last Element (Tail)\n\n	Throws exception 	Special value 	Throws exception 	Special value\nInsert: 	addFirst(e) 	offerFirst(e) 	addLast(e) 	offerLast(e)\nRemove:	removeFirst() 	pollFirst() 	removeLast() 	pollLast()\nExamine: 	getFirst() 	peekFirst() 	getLast() 	peekLast()','Collections',0,0,NULL,5),(1238,'true','a LinkedList is a Dequeue','Collections',0,0,NULL,5),(1239,'5\n9\n5\n9\n1\n3\n\n',' public static void main(String []args) {\n        Deque<Integer> d = new ArrayDeque<>(5);\n        d.add(5);\n        d.add(1);\n        d.add(7);\n        d.add(1);\n        d.add(3); \n        d.add(9);\n        \n        System.out.println(d.getFirst());\n        System.out.println(d.getLast());\n        System.out.println(d.pollFirst());\n        System.out.println(d.pollLast());\n        System.out.println(d.removeFirst());\n        System.out.println(d.removeLast());\n    }','Collections',0,0,NULL,5),(1240,'remove throws an exception if the queue is empty','Dequeu whats the difference between pollFirst and removeFirst','Collections',0,0,NULL,5),(1241,'6\n5\n4\n3\n2\n1\nException in thread \"main\" java.util.NoSuchElementException\n\nremove throws an exception if queue is empty','public class Hello {\n\n    public static void main(String []args) {\n        Deque<Integer> d = new ArrayDeque<>(5);\n        d.add(1);\n        d.add(2);\n        d.add(3);\n        d.add(4);\n        d.add(5); \n        d.add(6);\n        \n        for(int i = 0; i < 10; i++){\n            System.out.println(d.removeLast());\n        }\n    }\n}','Collections',0,0,NULL,5),(1242,'6\n5\n4\n3\n2\n1\nnull\nnull\nnull\nnull\n\npoll returns null if empty','public class Hello {\n\n    public static void main(String []args) {\n        Deque<Integer> d = new ArrayDeque<>(5);\n        d.add(1);\n        d.add(2);\n        d.add(3);\n        d.add(4);\n        d.add(5); \n        d.add(6);\n        \n        for(int i = 0; i < 10; i++){\n            System.out.println(d.pollLast());\n        }\n    }\n}','Collections',0,0,NULL,5),(1243,'1\n1\n1\n1\n1\n1\n1\n element retrrieves but does not remove the head, similar to peek() only \nelement throws an exception if dequeu is empty','public static void main(String []args) {\n        Deque<Integer> d = new ArrayDeque<>(5);\n        d.add(1);\n        d.add(2);\n        d.add(3);\n        d.add(4);\n        d.add(5); \n        d.add(6);\n        \n        for(int i = 0; i < 10; i++){\n            System.out.println(d.element());\n        }\n    }','Collections',0,0,NULL,5),(1244,'getFirst getLast element removeFirst removeLast remove\n\nremove and removeFirst are equivalent','which dequeue methods throw exceptions if the queue is empty ? \n','Collections',0,0,NULL,5),(1245,'cool','A dequeue is FIFO therefore the methods that add and addLast are\nequivalent\n\nwhere the ones that remove and removeFirst are equivalent. ','Collections',0,0,NULL,5),(1246,'false true false true','public static void main(String []args) {\n\n            String pattern = \"a*b+c{3}\";\n            String []strings = { \"abc\", \"abbccc\", \"aabbcc\", \"aaabbbccc\" };\n            for(String str : strings) {\n                System.out.print(Pattern.matches(pattern, str) + \" \");\n            }\n    }','Strings',0,0,NULL,5),(1247,'true true  true true\n\n+ one or more \n* zero or more',' public static void main(String []args) {\n\n            String pattern = \"a*b+c+\";\n            String []strings = { \"abc\", \"abbccc\", \"aabbcc\", \"aaabbbccc\" };\n            for(String str : strings) {\n                System.out.print(Pattern.matches(pattern, str) + \" \");\n            }\n    }','Strings',0,0,NULL,5),(1248,'will compile and throw InvalidKeyException,\n\nfirst an overriden method does not have to throw an excpeiton if its super does\n\nsecond IllegalArgumentException is a runtime exception anyway so it does \nnot have to be declared thrown. ','class InvalidKeyException extends IllegalArgumentException{ }\n\nclass New {\n    public void foo() throws InvalidKeyException{ }\n}\npublic class Hello extends New {\n\n    public static void main(String []args) {\n        new Hello().foo();\n    }\n    \n    public void foo(){\n        throw new InvalidKeyException();\n    }\n        \n}','Exceptions',0,0,NULL,5),(1249,'in catch -> in finally->\n\nreturn means the function will return but finally will still be executed first.\n\n','public static void main(String []args) {\n        \n        try {\n            int i = 10/0; // LINE A\n            System.out.print(\"after throw -> \");\n        } catch(ArithmeticException ae) {\n            System.out.print(\"in catch -> \");\n            return;\n        } finally {\n            System.out.print(\"in finally -> \");\n        }\n            System.out.print(\"after everything\");\n    }','Exceptions',0,0,NULL,5),(1250,'Error + e \n\nyou should never catch an assertion error but if you were to It would be\ncaught by \'Error\'','public static void main(String []args) {\n	try {\n		assert false;\n	} catch(RuntimeException re) {\n		System.out.println(\"RuntimeException\");\n	} catch(Exception e) {\n		System.out.println(\"Exception\");\n	} catch(Error e) {\n		// LINE A\n		System.out.println(\"Error\" + e);\n	} catch(Throwable t) {\n		System.out.println(\"Throwable\");\n	}\n}\n\njava -ea Hello','Exceptions',0,0,NULL,5),(1251,'creates all the files and directories','public class Hello {\n\n    public static void main(String[] args) {\n        String[] fileList = {\"/file1.txt\", \"/subdir/file2.txt\", \"/file3.txt\"};\n        for (String file : fileList) {\n            try {\n                new File(file).mkdirs();\n            } catch (Exception e) {\n                System.out.println(\"file creation failed\");\n                System.exit(-1);\n            }\n        }\n   }\n}','IO',0,0,NULL,5),(1252,'Allen\nClark\nbob\nromeo\n\nthis shows that TreeSets sort there elements. And Capitols sort before lowers','public class Hello {\n\n    public static void main(String[] args) {\n      String names = \"<bob> romeo. Allen> ^ Clark\";\n      Set<String> words = new TreeSet<>();\n      try(Scanner tokenizer = new Scanner(names)){\n          tokenizer.useDelimiter(\"\\\\W\");\n          while(tokenizer.hasNext()){\n              String word = tokenizer.next();\n              if(!word.trim().equals(\"\")){\n                  words.add(word);\n              }\n          }\n          for(String word : words){\n              System.out.println(word);\n          }\n      }\n   }\n}','Strings',0,0,NULL,5),(1253,'0 1 \n\nwith subpath the element closest to the root is 0, the ending index is exclusive','Path wordpadPath = Paths.get(\"C:\\\\Program Files\\\\Windows NT\\\\Accessories\\\\wordpad.exe\");\nSystem.out.println(wordpadPath.subpath(beginIndex, endIndex));\n \nWhat are the values of the integer values beginIndex and endIndex in this program that will result in this code\nsegment printing the string “Program Files” as output?\n\na) beginIndex = 1 and endIndex = 2\nb) beginIndex = 0 and endIndex = 1\nc) beginIndex = 1 and endIndex = 1\nd) beginIndex = 4 and endIndex = 16','IO',0,0,NULL,5),(1254,'cool','Which one of the following options is a correct way to create a watch service for watching a directory for\nchanges?\n\nWatchService watch = FileSystems.getDefault().newWatchable();\nWatchService watcher = FileSystems.getDefault().newWatchService();\nWatchService dirWatcher = FileSystems.getDefault().newDirectoryWatchService();\nWatchService fileWatcher = FileSystems.getNewFileWatchService();\nWatchService fileDirWatcher = WatchService.getNewFileDirectoryWatchService();','IO',0,0,NULL,5),(1255,'c e \n\nd is wrong because CallabeStatement PreparedStatement, and Statement \nare not classes they are interfaces.\n','a) Objects of type Statement can handle IN, OUT, and INOUT parameters.\nb) PreparedStatement is used for executing stored procedures.\nc) You can get an instance of PreparedStatement by calling prepareStatement() method in the Connection\ninterface.\nd) CallableStatement extends the PreparedStatement class; PreparedStatement in turn extends the Statement\nclass.\ne) The interface Statement and its derived interfaces implement the AutoCloseable interface, hence it can be used\nwith try-with-resources statement.','JDBC',0,0,NULL,5),(1256,'sqlexception autocommit is true. \n\nyou cannot set a savepoint, rollback, or commit with autocommit on','// assume that connection is successfully established to the database\nconnection.setAutoCommit(true);\nStatement statement = connection.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE,\nResultSet.CONCUR_UPDATABLE);\nresultSet = statement.executeQuery(\"SELECT * FROM TempSensor\");\n \n// assume that the initial value of temp is \"0\" in the table\n \nresultSet.moveToInsertRow();\nresultSet.updateString(\"temp\", \"100\");\nresultSet.insertRow();\nSavepoint firstSavepoint = connection.setSavepoint();\n \nresultSet.moveToInsertRow();\nresultSet.updateString(\"temp\", \"200\");\nresultSet.insertRow();\nSavepoint secondSavepoint = connection.setSavepoint();\n \nresultSet.moveToInsertRow();\nresultSet.updateString(\"temp\", \"300\");\nresultSet.insertRow();\nSavepoint thirdSavepoint = connection.setSavepoint();\n \nconnection.rollback(secondSavepoint);\nconnection.commit();','JDBC',0,0,NULL,5),(1257,'worker\n\nthen hangs...\n\nwhen the current thread joins onto itself to terminate it never does because\nit is waiting for itslef.','class Worker extends Thread {\n    public void run() {\n        System.out.println(Thread.currentThread().getName());\n    }\n}\n \nclass Hello {\n    public static void main(String []args) throws InterruptedException {\n        Thread.currentThread().setName(\"Master \");\n        Thread worker = new Worker();\n        worker.setName(\"Worker \");\n        worker.start();\n        Thread.currentThread().join();\n        System.out.println(Thread.currentThread().getName());\n    }\n}','Threads',0,0,NULL,5),(1258,'[10, 5, 10, 20]\n[20, 5, 10]\n[5, 10, 20]\n[5, 10, 20]\n\nconcurrentSkipListSet is sorted.','class Hello {\n    public static void main(String []args) throws InterruptedException {\n        List list = Arrays.asList(10,5,10,20);\n        System.out.println(list);\n        System.out.println(new HashSet(list));\n        System.out.println(new TreeSet(list));\n        System.out.println(new ConcurrentSkipListSet(list));\n    }\n}','Collections',0,0,NULL,5),(1259,'c\n\nsince java cant find \n	ResourceBundle_fr_CA.properties\n	ResourceBundle_fr.properties\n\njava will search for canidate locales for teh base bundle named ResourceBundle and \na default locale\n\n	ResourceBundle_en_US.properties\n	ResourceBundle_en.properties','Assume that you’ve the following resource bundles in your classpath:\nResourceBundle.properties\nResourceBundle_ar.properties\nResourceBundle_en.properties\nResourceBundle_it.properties\nResourceBundle_it_IT_Rome.properties\n \nAlso assume that the default locale is English (US), where the language code is en and country code is US. Which\none of these five bundles will be loaded for the call\nloadResourceBundle(\"ResourceBundle\", new Locale(\"fr\", \"CA\", \"\"));?\n \na) ResourceBundle.properties\nb) ResourceBundle_ar.properties\nc) ResourceBundle_en.properties\nd) ResourceBundle_it.properties\ne) ResourceBundle_it_IT_Rome.properties','Locale',0,0,NULL,5),(1260,'only i will compile.\n\nputting a 0 in front of the numbers indicates that it is an octal which can \nbe applied to ints. ','public static void main(String []args) throws InterruptedException {\n        int i = 012;\n        int a = 10.0l;\n        int b = 10.0f;\n        int c = 10.0;\n    }','General',0,0,NULL,5),(1261,'ok',' public static void main(String []args) throws InterruptedException {\n        byte b = 100;\n        int i = 3456;\n        short s = 400;\n        long l = 6000;\n        float f = 356.0f;\n        double d = 45000.0;\n        \n        //commented assingments do not compile\n        i = b;\n        // b = i;\n        i = s;\n        //s = i;\n        l = i;\n        //i = l;\n        f = i;\n        //i = f;\n        f = l;\n        //l = f;\n        d = f;\n        //f = d;\n        d = s;\n        l = s;\n        l = b;\n        d = i;\n        f = s;\n        l = b;  \n    }','General',0,0,NULL,5),(1262,'NPE','public static void main(String []args){\n        Boolean b = null;\n        System.out.println(b ? true: false);\n                \n    }','General',0,0,NULL,5),(1263,' private Point() {\n	this(0, 0);\n}\n\nyou cannot call super and this. super or this should be the first calls \nin a constructor. ','class Point {\n        private int x = 0, y;\n        public Point(int x, int y) {\n        this.x = x;\n        this.y = y;\n    }\n        // DEFAULT_CTOR\n}\n\na) public Point() {\n	this(0, 0);\n	super();\n}\n \nb) public Point() {\n	super();\n	this(0, 0);\n}\n \nc) private Point() {\n	this(0, 0);\n}\n \nd) public Point() {\n	this();\n}\n \ne) public Point() {\n	this(x, 0);\n}\n\n\nWhich one of the following definitions of the Point constructor can be replaced without compiler\nerrors in place of the comment DEFAULT_CTOR?','General',0,0,NULL,5),(1264,'yes, instance of AnEnum\nyes, instance of EnumBase\nyes, instance of Enum\n\n\nyes, instance of AnEnum\nyes, instance of EnumBase\nyes, instance of Enum\n\nAn enumeration can implement an interface (but cannot extend a class, or cannot be\na base class).\nEach enumeration constant is an object of its enumeration type. An enumeration\nautomatically extends the abstract class java.util.Enum. Hence, all the three instanceof\nchecks succeed.','interface EnumBase { }\n \nenum AnEnum implements EnumBase {ONLY_MEM;}\n \nclass Hello {\n    public static void main(String []args) {\n        if(AnEnum.ONLY_MEM instanceof AnEnum) {\n            System.out.println(\"yes, instance of AnEnum\");\n        }\n        if(AnEnum.ONLY_MEM instanceof EnumBase) {\n            System.out.println(\"yes, instance of EnumBase\");\n        }\n        if(AnEnum.ONLY_MEM instanceof Enum) {\n            System.out.println(\"yes, instance of Enum\");\n        }\n    }\n}','General',0,0,NULL,5),(1265,'ok','enums can implement an interface,\n\ncannot extend a class, they already implicitly extend Enum class\n\nno class can extend an enum\n\nenum constants are objects of its class','General',0,0,NULL,5),(1266,'a) Enum can have private constructor.\nc) Enum can have public methods and fields.\nd) Enum can implement an interface.','Which of the following statements are true with respect to enums? \n\na) An enum can have private constructor.\nb) An enum can have public constructor.\nc) An enum can have public methods and fields.\nd) An enum can implement an interface.\ne) An enum can extend a class.','General',0,0,NULL,5),(1267,'Think of Enums as a class with a finite number of instances. \nThere can never be any different instances beside the ones you initially \ndeclare.\n\nThus, you cannot have a public or protected constructor, because that\n would allow more instances to be created.','enums cannot have public or protected constructors \n\nwhy ?','General',0,0,NULL,5),(1268,'compiles','interface EnumBase { }\n \nenum AnEnum implements EnumBase {\n    ONLY_MEM;\n    private AnEnum(){\n        \n    }\n}','General',0,0,NULL,5),(1269,'WNC','interface EnumBase { }\n \nenum AnEnum implements EnumBase {\n    ONLY_MEM;\n    public AnEnum(){\n        \n    }\n}','General',0,0,NULL,5),(1270,'compiles','interface EnumBase { }\n \nenum AnEnum implements EnumBase {\n    ONLY_MEM;\n     AnEnum(){\n        \n    }\n}','General',0,0,NULL,5),(1271,'WNC','interface EnumBase { }\n \nenum AnEnum implements EnumBase {\n    ONLY_MEM;\n    protected AnEnum(){\n        \n    }\n}','General',0,0,NULL,5),(1272,'b)\nClass Test is related with ClassC with a composition relationship.\nWhen a class inherits from another class, they share an is-a relationship. On the other\nhand, if a class uses another class (by declaring an instance of another class), then the first\nclass has a has-a relationship with the used class.','	class ClassA {}\n	interface InterfaceB {}\n	class ClassC {}\n\n	class Test extends ClassA implements InterfaceB {\n		String msg;\n		ClassC classC;\n	}\n\na) Class Test is related with ClassA with a has-a relationship.\nb) Class Test is related to ClassC with a composition relationship.\nc) Class Test is related with String with an is-a relationship.\nd) Class ClassA is related with InterfaceB with an is-a relationship.','General',0,0,NULL,5),(1273,'a) java.text.Format is the abstract base class that supports formatting of locale sensitive\ninformation such as date, time, and currency\nc) java.text.NumberFormat derives from java.text.Format class; it is the base class for\nprocessing numbers, currency, etc. in a locale sensitive way.\nd) java.text.DateFormat derives from java.text.Format class; it is the base class for\nprocessing date and time information based on locale.\nClass java.text.SimpleDateForma','a) j  ava.text.Format is the abstract base class that supports formatting of locale sensitive\ninformation such as date, time, and currency\n\nb) j  ava.text.CustomTimeFormat allows you to define custom patterns for processing\ntime for specific locales.\n\nc) j  ava.text.NumberFormat derives from the java.text.Format class; it is the base\nclass for processing numbers, currency, etc. in a locale sensitive way.\n\nd) j  ava.text.DateFormat derives from the java.text.Format class; it is the base class\nfor processing date and time information based on locale.','General',0,0,NULL,5),(1274,'b) AtomicInteger\nc) AtomicLong\n\nClasses AtomicInteger and AtomicLong extend Number class.\nAtomicBoolean does not extend java.lang.Number. Classes named as AtomicFloat or\nAtomicDouble do not exist in the java.util.concurrent.atomic package.','Which of the following classes in the java.util.concurrent.atomic package inherit from\njava.lang.Number? (Select all that apply).\na) AtomicBoolean\nb) AtomicInteger\nc) AtomicLong\nd) AtomicFloat\ne) AtomicDouble','General',0,0,NULL,5),(1275,'false \ntrue\n\nthe newly created object is not part of the student set so it will show false.\n\ns10 however is the excact object added. Since equals is not overriden, this \ncollection can only identify equal objects using the unoverriden equals()\nfrom object which says that two objects are equal only if they are the excact\nsame reference variable which in this case is true..','class Student{\n    public Student(int r) {\n    rollNo = r;\n    }\n\n    int rollNo;\n    public int hashCode(){\n        return rollNo;\n    }\n}\n\nclass Hello {\n        public static void main(String[] args){\n            HashSet<Student> students = new HashSet<>();\n            students.add(new Student(5));\n            Student s10 = new Student(10);\n            students.add(s10);\n            System.out.println(students.contains(new Student(10)));\n            System.out.println(students.contains(s10));\n        }\n}','Collections',0,0,NULL,5),(1276,'all four\n\nExecutor is an interface with a single method execute(Runnable r).\n\nWith Executor you create your own implementation to determine how you want threads\nto execute tasks. \n\nExecutor implementations in .concurrent package implement ExecutorService\nwhich is more complete\n\nExecutorService interface extends Executor. \n\nExecutors provides basic concrete implementations of these interfaces. ','a) The Executor interface declares a single method execute(Runnable command) that\nexecutes the given command at sometime in the future.\nb) The Callable interface declares a single method call() that computes a result.\nc) The Exchanger class provides a “synchronization point at which threads can pair and\nswap elements within pairs”.\nd) The TimeUnit enumeration represents time duration and is useful for specifying\ntiming parameters in concurrent programs.','Collections',0,0,NULL,5),(1277,'ok','Executor is an interface with a single method execute(Runnable r).\n\nWith Executor you create your own implementation to determine how you want threads\nto execute tasks. \n\nExecutor implementations in .concurrent package implement ExecutorService\nwhich is more complete\n\nExecutorService interface extends Executor. \n\nExecutors provides basic concrete implementations of these interfaces. ','Executors',0,0,NULL,5),(1278,'executor and singleton','public class JabRefExecutorService implements Executor {\n\n    public static final JabRefExecutorService INSTANCE = new JabRefExecutorService();\n    private static final Log LOGGER = LogFactory.getLog(JabRefExecutorService.class);\n    private final ExecutorService executorService = Executors.newCachedThreadPool(r -> {\n        Thread thread = new Thread(r);\n        thread.setName(\"JabRef CachedThreadPool\");\n        thread.setUncaughtExceptionHandler(new FallbackExceptionHandler());\n        return thread;\n\n    });\n    private final ExecutorService lowPriorityExecutorService = Executors.newCachedThreadPool(r -> {\n        Thread thread = new Thread(r);\n        thread.setName(\"JabRef LowPriorityCachedThreadPool\");\n        thread.setUncaughtExceptionHandler(new FallbackExceptionHandler());\n        return thread;\n    });\n    private final Timer timer = new Timer(\"timer\", true);\n    private Thread remoteThread;\n\n    private JabRefExecutorService() { }\n\n    @Override\n    public void execute(Runnable command) {\n        if (command == null) {\n            LOGGER.debug(\"Received null as command for execution\");\n            return;\n        }\n\n        executorService.execute(command);\n    }','Executors',0,0,NULL,5),(1279,'Arrays.asList returns an unmodifiable list. you cannot add or remove from it','class Hello {\n        public static void main(String[] args){\n            List<String> coaches = Arrays.asList(\"Joe\",\"Dean\",\"Will\",\"Aaron\");\n            System.out.println(coaches.remove(\"Joe\"));\n        }\n}','Collections',0,0,NULL,5),(1280,'Arrays.asList returns an unmodifiable list. you cannot add to it or remove from\nit. \n\n','class Hello {\n        public static void main(String[] args){\n            List<String> coaches = Arrays.asList(\"Joe\",\"Dean\",\"Will\",\"Aaron\");\n            //System.out.println(coaches.remove(\"Joe\"));\n            coaches.add(\"Reese\");\n        }\n}','Collections',0,0,NULL,5),(1281,'ok','Arrays.asList returns an umodifiable list you cannot add to it or remove\nfrom it or you will get an unsupportedoperationexception. ','Collections',0,0,NULL,5),(1282,'compiles fine. ','class Hello {\n        public static void main(String[] args){\n            List<String> coaches = Arrays.asList(\"Joe\",\"Dean\",\"Will\",\"Aaron\");\n            //System.out.println(coaches.remove(\"Joe\"));\n            coaches.set(0,\"Dan\");\n        }\n}','Collections',0,0,NULL,5),(1283,'115110\nThe string concatenation operator works as follows: if both the operands are numbers,\nit performs the addition; otherwise it concats the arguments by calling the toString()\nmethod if needed. It evaluates from left to right. Hence, the expression in the program\nresults in the string 115110.','class Test {\n	public static void main(String []args) {\n		String s = new String(\"5\");\n		System.out.println(1+10+s+1+10);\n	}\n}\n \na) 11511\nb) 1105110\nc) 115110\nd) 27','Strings',0,0,NULL,5),(1284,'wow ','The string concatenation operator works as follows: if both the operands are numbers,\nit performs the addition; otherwise it concats the arguments by calling the toString()\nmethod if needed. It evaluates from left to right. ','Strings',0,0,NULL,5),(1285,'a\n\nwith + if the expression is in () it evaluates first. + if the left arg\nis a string both will become strings.\n\nif the two are numbers then addition will be performed. ','class Test {\n	public static void main(String []args) {\n		String s = new String(\"5\");\n		System.out.println(1.0+10.5+s+(1.0+10.5));\n	}\n}\n \na) 11.5511.5\nb) 11.551.010.5\nc) 1.010.551.010.5\nd) 11.55(1.010.5)\ne) 11.55(11.5)','Strings',0,0,NULL,5),(1286,'hell\n00123\n\nIn first printf() method, %3.4s indicates that you want to print the first four characters\nof a string. In the second printf() method call, %05d indicates that you wanted to print\na minimum five digits of an integer. If the number does not have enough digits, then the\nnumber will be preceded by leading zeroes.\n\n\nYou can also use String.format(\"%3.3s\", \"abcdefgh\"). \nThe first digit is the minimum length (the string will be left \npadded if it\'s shorter), the second digit is the maxiumum length \nand the string will be truncated if it\'s longer. So\n\nSystem.out.printf(\"%3.3s%3.3s\", \"abcdefgh\", \"a\");\n\nwill produce\n\n\'abc  a\'','class Printf {\n	public static void main(String []args) {\n		System.out.printf(\"%3.4s %n\", \"hello world\");\n		System.out.printf(\"%05d\", 123);\n	}\n}','Strings',0,0,NULL,5),(1287,'ok','NumberFormatException is a runtime exception','General',0,0,NULL,5),(1288,'no:10 and 7\nno:2$s and 1$s\n\nThe format specifier string %$s indicates that you want to re-order the input values.\nA number (integer) sandwiched between a % and a $ symbol is used to re-order the\ninput values; the number indicates which input variable you want to put here. In %2$s\nit indicates that you want to put the second argument. Similarly, %1$s indicates that you\nwant to put the first argument.','class Test {\npublic static void main(String []args) {\nint a = 7, b = 10;\nSystem.out.printf(\"no:%2$s and %1$s\", a, b);\nSystem.out.printf(\"\\nno:2$s and 1$s\", a, b);\n}\n}','General',0,0,NULL,5),(1289,'\nb\nb\nb','class Test {\npublic static void main(String[] s) {\nString quote = \"aba*abaa**aabaa***\";\nString [] words = quote.split(\"a\\\\**\", 10);\nfor (String word : words) {\nSystem.out.println(word);\n}\n}\n}','Strings',0,0,NULL,5),(1290,'in regex ? indicates 0 or 1','class Test {\n	public static void main(String[] args) {\n		String str1 = \"xxzz\";\n		String str2 = \"xyz\";\n		String str3 = \"yzz\";\n		Pattern pattern = Pattern.compile(\"(xx)*y?z{1,}\");\n		Matcher matcher = pattern.matcher(str1);\n		System.out.println(matcher.matches());\n		System.out.println(pattern.matcher(str2).matches());\n		System.out.println(\n		Pattern.compile(\"(xx)*y?z{1,}\").\n		matcher(str3).matches());\n	}\n}','Strings',0,0,NULL,5),(1291,'Suneetha N.=9876543210, 9898989898: Patil,Pratish\n\n\n\npublic String replaceAll(String replacement)\n\nReplaces every subsequence of the input sequence that matches the pattern \nwith the given replacement string.\n\nThis method first resets this matcher. It then scans the input sequence \nlooking for matches of the pattern. Characters that are not part of any\n match are appended directly to the result string; each match is replaced \nin the result by the replacement string. The replacement string may contain references to captured subsequences as in the appendReplacement method.\n\nNote that backslashes (\\) and dollar signs ($) in the replacement string \nmay cause the results to be different than if it were being treated as a \nliteral replacement string. Dollar signs may be treated as references to\n captured subsequences as described above, and backslashes are used to \nescape literal characters in the replacement string.\n\nGiven the regular expression a*b, the input \"aabfooaabfooabfoob\", and \nthe replacement string \"-\", an invocation of this method on a matcher \nfor that expression would yield the string \"-foo-foo-foo-\".\n\nInvoking this method changes this matcher\'s state. If the matcher is\n to be used in further matching operations then it should first be\n reset. ','class Test {\n	public static void main(String[] args) {\n\n	String str =\"Suneetha N.=9876543210, Pratish Patil=9898989898\";\n\n	Pattern pattern =Pattern.compile(\"(\\\\w+)(\\\\s\\\\w+)(=)(\\\\d{10})\");\n\n	Matcher matcher = pattern.matcher(str);\n\n	String newStr = matcher.replaceAll(\"$4:$2,$1\");\n	System.out.println(newStr);\n}\n}\n ','Strings',0,0,NULL,5),(1292,'ok ','if a final variable is static it has be intitialized right away.','OOP',0,0,NULL,5),(1293,'concurrent modification exception\n\nTreeSets iterator: \n\n	The iterators returned by this class\'s iterator method are fail-fast: \nif the set is modified at any time after the iterator is created, in any \nway except through the iterator\'s own remove method, the iterator will\n throw a ConcurrentModificationException.','public static void main(String[] args) {\n\n            Set<String> set = new TreeSet<String>();\n            set.add(\"S\");\n            set.add(\"R\");\n            Iterator<String> iter = set.iterator();\n            set.add(\"P\");\n            set.add(\"Q\");\n            while(iter.hasNext()) {\n                System.out.print(iter.next() + \" \");\n            }\n    }','Collections',0,0,NULL,5),(1294,'how to correctly load an rb','public class Hello extends Thread {\n\n    public static void main(String[] args) {\n\n         ResourceBundle resBundle = ResourceBundle.getBundle(\"ResourceBundle\", new Locale(\"it\", \"IT\", \"\"));\n         System.out.println(resBundle.getObject(new Integer(1).toString()));\n    }\n        \n     \n}\n\nclass ResourceBundle_it_IT extends ListResourceBundle {\n\n    public Object[][] getContents() {\n        return contents;\n    }\n    static final Object[][] contents = {\n        {\"1\", \"Uno\"},\n        {\"2\", \"Duo\"},\n        {\"3\", \"Trie\"},};\n}','Locale',0,0,NULL,5),(1295,'CopyOnWrite Collections will allow concurrent modification','public static void main(String[] args) {\n\n            Set<String> set = new CopyOnWriteArraySet<String>();\n            set.add(\"2\");\n            set.add(\"1\");\n            Iterator<String> iter = set.iterator();\n            set.add(\"3\");\n            set.add(\"-1\");\n            while(iter.hasNext()) {\n                System.out.print(iter.next() + \" \");\n            }\n    }','Collections',0,0,NULL,5),(1296,'the proper name of a resource bundle has its package in front. ','ResourceBundle resBundle = ResourceBundle.getBundle(\"hello.ResourceBundle\", new Locale(\"it\", \"IT\", \"\"));\n            System.out.println(resBundle.getObject(new Integer(1).toString()));','Locale',0,0,NULL,5),(1297,'One Thread continously interates throgh the set while the other continusly adds\nnew things to it. \n\nThis is allowed with a COWSet. \n\nThough if the Iterator is obtained then an element is added that iterator\nwill not change it will print the elements that were in the set at the time\nof Instantiation of the iterator. ','public class Hello extends Thread {\n    Set<String> set = new CopyOnWriteArraySet<String>();\n    \n    public Hello(){\n        set.add(\"2\");\n        set.add(\"1\");\n        set.add(\"3\");\n        set.add(\"-1\");\n    }\n\n    public static void main(String[] args) {\n        //Thread t1 = new ConcAdder();\n        Hello h = new Hello();\n        Hello.ConcAdder ca = h.new ConcAdder();\n        ca.start();\n        \n        Hello.ConcIter ci = h.new ConcIter();\n        ci.start();\n\n    }\n    \n    class ConcAdder extends Thread{\n        private String[] letters = {\"A\",\"B\",\"C\",\"D\"};\n        public void run(){\n            while(true){\n                try{\n                    sleep(1000);\n                    int a = ThreadLocalRandom.current().nextInt(0,3);\n                    set.add(letters[a]);\n                } catch(InterruptedException e){\n                    \n                }\n            }\n            \n        }\n    }\n    \n    class ConcIter extends Thread {\n        public void run(){\n            while(true){\n                Iterator<String> it = set.iterator();\n\n                while(it.hasNext()){\n                    System.out.println(it.next());\n                }\n                \n                try{\n                    sleep(1000);\n                } catch(InterruptedException e){ }\n            }\n        }\n        \n    }    \n}\n','Concurrency',0,0,NULL,5),(1298,'ok','\npublic interface Iterable<T>\n\nImplementing this interface allows an object to be the target of the\n \"foreach\" statement.\n\n\nIterator<E> is an interface too	','General',0,0,NULL,5),(1299,'2\nException in thread \"Thread-2\" java.lang.UnsupportedOperationException\n1\n3\n-1\n\nYou cannot mutate the collection with Iterator methods when using \na COW colleciton. \n\nThe collection is only thread safe because it copies its entire internal array\nevery time something is added or removed. \n\nSo when an iterator is obtained it gives one copy of the immutable internal\narray. You cannot mutate an array which gives the unsupportedOperation excepiton.','public class Hello extends Thread {\n    Set<String> set = new CopyOnWriteArraySet<String>();\n    \n    public Hello(){\n        set.add(\"2\");\n        set.add(\"1\");\n        set.add(\"3\");\n        set.add(\"-1\");\n    }\n\n    public static void main(String[] args) {\n        //Thread t1 = new ConcAdder();\n        Hello h = new Hello();\n        Hello.ConcAdder ca = h.new ConcAdder();\n        ca.start();\n        \n        Hello.ConcIter ci = h.new ConcIter();\n        ci.start();\n\n    }\n    \n    class ConcAdder extends Thread{\n        private String[] letters = {\"A\",\"B\",\"C\",\"D\"};\n        public void run(){\n            while(true){\n                    int a = ThreadLocalRandom.current().nextInt(0,3);\n                    set.add(letters[a]);\n            }\n            \n        }\n    }\n    \n    class ConcIter extends Thread {\n        public void run(){\n            while(true){\n                Iterator<String> it = set.iterator();\n\n                while(it.hasNext()){\n                    System.out.println(it.next());\n                }\n                \n                it.remove();\n            }\n        }\n        \n    }    \n}','Concurrency',0,0,NULL,5),(1300,'-1\nException in thread \"Thread-2\" java.util.ConcurrentModificationException\n\nTreeSet iterator is fail fast','public class Hello extends Thread {\n    Set<String> set = new TreeSet<String>();\n    \n    public Hello(){\n        set.add(\"2\");\n        set.add(\"1\");\n        set.add(\"3\");\n        set.add(\"-1\");\n    }\n\n    public static void main(String[] args) {\n        //Thread t1 = new ConcAdder();\n        Hello h = new Hello();\n        Hello.ConcAdder ca = h.new ConcAdder();\n        ca.start();\n        \n        Hello.ConcIter ci = h.new ConcIter();\n        ci.start();\n\n    }\n    \n    class ConcAdder extends Thread{\n        private String[] letters = {\"A\",\"B\",\"C\",\"D\"};\n        public void run(){\n            while(true){\n                    int a = ThreadLocalRandom.current().nextInt(0,3);\n                    set.add(letters[a]);\n            }\n            \n        }\n    }\n    \n    class ConcIter extends Thread {\n        public void run(){\n            while(true){\n                Iterator<String> it = set.iterator();\n\n                while(it.hasNext()){\n                    System.out.println(it.next());\n                }\n                \n                //it.remove();\n            }\n        }\n        \n    }    \n}','Concurrency',0,0,NULL,5),(1301,'Base print\nan abstract class can extend a concrete class. ','public abstract class Hello extends Base  {\n    public static void main(String[] yea){\n        Base b = new Base();\n        b.print();\n    }\n}\n\nclass Base{\n    public void print(){\n        System.out.println(\"Base print\");\n    }\n}','OOP',0,0,NULL,5),(1302,'i1 = 10, i2 = 10, i3 = 10, i4 = 10\nunchecked cast warning too.\n\nE becomes whatever you are assigning the variable to','class Hello {\n\n    static <E> E cast(Object item) {\n        return (E) item;\n    }\n\n    public static void main(String[] args) {\n        Object o1 = 10;\n        int i = 10;\n        Integer anInteger = 10;\n\n        Integer i1 = cast(i);\n        Integer i2 = cast(10);\n        Integer i3 = cast(anInteger);\n        Integer i4 = cast(o1);\n\n        System.out.printf(\"i1 = %d, i2 = %d, i3 = %d, i4 = %d\", i1, i2, i3, i4);\n    }\n}','OOP',0,0,NULL,5),(1303,'Exception in thread \"main\" java.lang.ClassCastException: \njava.lang.Integer cannot be cast to java.lang.String','class Hello {\n\n    static <E> E cast(Object item) {\n        return (E) item;\n    }\n\n    public static void main(String[] args) {\n        Object o1 = 10;\n        int i = 10;\n        Integer anInteger = 10;\n\n        String i4 = cast(o1);\n\n        System.out.printf(i4);\n    }\n}','Generics',0,0,NULL,5),(1304,'compiles fine','class Hello {\n\n    static <E> E cast(Sculptable item) {\n        return (E) item;\n    }\n\n    public static void main(String[] args) {\n       Clay c = new Clay();\n       Rock r = cast(c);\n    }\n}\n\ninterface Sculptable{ }\nclass Rock{}\nclass Clay extends Rock implements Sculptable{}','Generics',0,0,NULL,5),(1305,'ArrayStoreException.\n\nThe compiler sees a Vehicle[] and car vehicle object being assigned to it.\n\nhowever the JVM sees a Car[] because the JVM deals with polymorphism. \nand a Vehicle object cannot be added to a Car[]','class Hello {\n\n\n    public static void main(String[] args) {\n        Vehicle[] v = new Car[4];\n        v[0] = new Vehicle();\n        v[1] = new Car();\n        v[2] = new Toyota();\n        \n        System.out.println(v.length);\n    }\n    \n}\n\nclass Vehicle{}\nclass Car extends Vehicle{}\nclass Toyota extends Car{}','Generics',0,0,NULL,5),(1306,'4','class Hello {\n\n\n    public static void main(String[] args) {\n        Vehicle[] v = new Car[4];\n        //v[0] = new Vehicle();\n        v[1] = new Car();\n        v[2] = new Toyota();\n        \n        System.out.println(v.length);\n    }\n    \n}\n\nclass Vehicle{}\nclass Car extends Vehicle{}\nclass Toyota extends Car{}','Generics',0,0,NULL,5),(1307,'true\njava.lang.ArrayStoreException: Point\n\nThe variable pa has type Point[] and the variable cpa has as its value a \nreference to an object of type ColoredPoint[]. A ColoredPoint can be \nassigned to a Point; therefore, the value of cpa can be assigned to pa.\n\nA reference to this array pa, for example, testing whether pa[1] is null, \nwill not result in a run-time type error. This is because the element of\n the array of type ColoredPoint[] is a ColoredPoint, and every ColoredPoint\n can stand in for a Point, since Point is the superclass of ColoredPoint.\n\nOn the other hand, an assignment to the array pa can result in a run-time \nerror. At compile time, an assignment to an element of pa is checked to \nmake sure that the value assigned is a Point. But since pa holds a \nreference to an array of ColoredPoint, the assignment is valid only if \nthe type of the value assigned at run time is, more specifically, a \nColoredPoint.\n\nThe Java Virtual Machine checks for such a situation at run time to \nensure that the assignment is valid; if not, an ArrayStoreException is\nthrown. ','class Point { int x, y; }\nclass ColoredPoint extends Point { int color; }\nclass Test {\n    public static void main(String[] args) {\n        ColoredPoint[] cpa = new ColoredPoint[10];\n        Point[] pa = cpa;\n        System.out.println(pa[1] == null);\n        try {\n            pa[0] = new Point();\n        } catch (ArrayStoreException e) {\n            System.out.println(e);\n        }\n    }\n}','Generics',0,0,NULL,5),(1308,'5\n[2, 1, 9, 6]\ntrue\n[2, 1, 6]','public static void main(String[] args) {\n\n        List<Integer> list = new ArrayList<Integer>();\n        list.add(new Integer(2));\n        list.add(1);\n        list.add(5);\n        list.add(9);\n        list.add(6);\n\n        System.out.println(list.remove(2));\n        System.out.println(list);\n        System.out.println(list.remove(new Integer(9)));\n        System.out.println(list);\n\n\n    }','Collections',0,0,NULL,5),(1309,'Pick a little, eat a little, pick a little, eat a little, burp burp burp, eat a lot, pick a little more.\n\nBoth replaceAll() and replace() methods replace all occurrences of the substring from\nthe given string. The difference between them is that replaceAll() takes regex as the\nfirst argument and replacement string as the second argument. The replace() method\ntakes CharSequence as both the arguments (note that String implements CharSequence\ninterface).','public static void main(String[] args) {\n        String talk = \"Pick a little, talk a little, pick a little, talk a little, cheep cheep cheep, talk a lot, pick a little more\";\n        String eat = talk.replaceAll(\"talk\", \"eat\").replace(\"cheep\", \"burp\");\n        System.out.println(eat);\n    }','Strings',0,0,NULL,5),(1310,'ok','replace(char oldChar, char newChar)\nReturns a new string resulting from replacing all occurrences of oldChar in this string with newChar.\n\nString 	replace(CharSequence target, CharSequence replacement)\nReplaces each substring of this string that matches the literal target sequence with the specified literal replacement sequence.\n\nString 	replaceAll(String regex, String replacement)\nReplaces each substring of this string that matches the given regular expression with the given replacement.\n\nString 	replaceFirst(String regex, String replacement)\nReplaces the first substring of this string that matches the given regular expression with the given replacement.','Strings',0,0,NULL,5),(1311,'For 4 days and 4 nights, we battled the wind, the cold, the despair.','public static void main(String[] args) {\n        String talk = \"For 30 days and 30 nights, we battled the wind, the cold, the despair.\";\n        String rep = talk.replaceAll(\"\\\\d+\", \"4\");\n        System.out.println(rep);\n    }','Strings',0,0,NULL,5),(1312,'For 30 days and 30 nights, we battled the wind, the cold, the despair.\n\nreplace takes a charsequence as a first arg not regex','public static void main(String[] args) {\n        String talk = \"For 30 days and 30 nights, we battled the wind, the cold, the despair.\";\n        String rep = talk.replace(\"\\\\d+\", \"4\");\n        System.out.println(rep);\n    }','Strings',0,0,NULL,5),(1313,'true\n\ntype erasure will make ArrayList raw and ArrayList<String> the same type of class\n','public static void main(String []args) {\n        Class c1 = new ArrayList<String>().getClass();\n        // LINE A\n        Class c2 = ArrayList.class;\n        // LINE B\n        System.out.println(c1 == c2);\n    }','General',0,0,NULL,5),(1314,'When executed, the program prints the following: B\n\nThe overload resolution matches to the most specific overload. When the argument null is\npassed, there are two candidates, Overload(Object) and Overload(double[]), and of these\ntwo, Overload(double[]) is the most specific overload, so the compiler resolves to calling\nthat method.\n\nOne method or constructor is less specific than another if it can accept \nany parameters passed to the other \n\nn our program, both constructors are accessible and applicable. \nThe constructor Confusing(Object) accepts any parameter passed to\n Confusing(double[]), so Confusing(Object) is less specific. \n(Every double array is an Object, but not every Object is a double array.)\n The most specific constructor is therefore Confusing(double[]), \nwhich explains the program\'s output.','class Hello {\n\n    private static void overload(Object o){ System.out.println(\"A\"); }\n    private static  void overload(double[] d){ System.out.println(\"B\"); }\n    private static void overload(){ System.out.println(\"C\"); }\n    \n    public static void main(String []args) {\n        overload(null);\n    }\n}','General',0,0,NULL,5),(1315,'NPE\n\n When the superclass constructor is called it calls the subclass foo()\nnot its own, resulting in an NPE.','class Hello extends Super {\n    public Hello(){\n        member = \"HI\";\n    }\n    public void foo(){\n        System.out.println(\"in Hello foo \"+ member.toLowerCase());\n    }\n    private String member;\n    \n    public static void main(String []args) {\n        Super s = new Hello();\n        s.foo();\n        \n    }\n}\n\nclass Super{\n    public Super(){\n        foo();\n    }\n    \n    public void foo(){\n        System.out.println(\"Super foo\");\n    }\n}','General',0,0,NULL,5),(1316,'pqr.foo();\n\n  In this program, the member pqr is imported statically. So, the foo() method can be accessed by\nqualifying it as pqr.foo(). Note that foo() itself is not imported statically, so it cannot be invoked directly\nin this program.','// class PQR in mock package\npackage mock;\n \npublic class PQR {\n	public static void foo() {\n		System.out.println(\"foo\");\n	}\n}\n \n// class XYZ in mock package\npackage mock;\nimport static mock.*;\n \npublic class XYZ {\n	public static PQR pqr;\n}\n \n// class StatImport\nimport static mock.XYZ.*;\n \nclass StatImport {\n	public static void main(String []args) {\n		// STMT\n	}\n}','General',0,0,NULL,5),(1317,'This program will print 10 in the console.\nThe valueOf(int) method is a static method in String that returns the String\nrepresentation of the integer value that is passed as its argument. Since calling a static\nmethod does not require dereferencing the reference variable on which it is called, this\nprogram does not throw a NullPointerException.\n\nshows the danger of using references to access static methods. ','psvm(String[] args){\n	String st = null;\n	sout( st.valueOf(10) );\n}','Strings',0,0,NULL,5),(1318,'try{\n\n}catch(Exception1 | Exception2 e) {\n\n	e = new Exception1();\n}\n\nTHIS WOULD FAIL COMPILATION\n\n','When using multi-catch, the catch block parameter is final and cannot \nhave a new value assigned to it in the catch block.\n\ntry{\n\n} catch(SQLException | IOException e){\n	\n	e = new IOException();\n}\n\n// this shows why thats illegal, your not sure which exception type \nwill come through.\n//updated 2','Exceptions',0,0,NULL,5),(1319,'javac -source 1.3 OldCode.java\n\njavac -source 1.4 NewCode.java','To compile old code that may use \'assert\' as an identifier, \nadd 1.3. This will tell the compiler to treat the word \'assert\' as an identifier.\n\n1.4 will use \'assert\' as a keyword	','Exceptions',0,0,NULL,5),(1320,'java -da com.maxbisesi.Test\n\njava -disableassertions com.maxbisesi.Test','Disable assertions at runtime		','Exceptions',0,0,NULL,5),(1321,'This is a bad idea...\n\npublic void doStuff(){\n	assert (modifyThings());\n	//continue\n}\n\npublic boolean modifyThings() {\n	y = x++;\n	return true;\n}','Dont use assert expressions that can cause side effects...','Exceptions',0,0,NULL,5),(1322,'Fails compilation','You cant use the variable name multiple times in a multi-catch. \nThe following wont compile...\n\ncatch(Exception1 e1 | Exception2 e2){\n\n}','Exceptions',0,0,NULL,5),(1323,'the following are equivalent:\n\ncatch(SQLException | IOException e)\n\ncatch(IOException | SQLException e)','With Multi catch order does NOT matter...		','Exceptions',0,0,NULL,5),(1324,'The following will not compile...\n\ncatch(FileNotFoundException | IOException e)\n\nsince FILNOTFOUND is a subclass of IOException we could have just\nwrtten that in the first place..\n\ncatch(IOException)','With Multi-Catch you have to make sure a given excpetion can only\nmatch one type...\n\ncatch(IOException | SQLException e)\n\nthese two are different types.','Exceptions',0,0,NULL,5),(1325,'This is legal but it is not good practice. It is illegal to reasign the value\nof a multi-catch parameter. \n\ntry {\n	\n} catch(SQLException | IOException e){\n\n	e = new IOException();\n}\n\n^^WILL NOT COMPILE\n','Legal or illegal...\n\ntry {\n	//do something\n} catch(IOException e){\n	\n	e = new IOException();\n}','Exceptions',0,0,NULL,5),(1326,'Will not compile, it is legal to reassign the parameter here. But it is illegal\nto throw e. The method declares that it throws SQL and IO so throwing a \ngeneral exception is unreported. \n\nif the signature was throws Exception then everything would be fine\n\nException as a genreal','public void couldthrow() throws SQLException, IOException { }\n\npublic void rethrow() throws SQLException, IOException {\n	try{\n		couldthrow();\n	} catch(Exception e){ \n		e = new IOException();\n		throw e;\n	}\n}	','Exceptions',0,0,NULL,5),(1327,'Illegal, regular trys have to have a catch or a finally\n\ntry-with can be used by themselves','legal or illegal\n\ntry {\n\n}','Exceptions',0,0,NULL,5),(1328,'does not compile. \nto be declared in a try with the method has to implement auto closeable or\ncloseable','try(String s = \"hi\") {}','Exceptions',0,0,NULL,5),(1329,'will not compile,\nThe declared resources use a commma , not a semi colon ;\n\nshould be:\n\ntry(Resource r = new Resource(); ...','Path p = Paths.get(\"/home/maxbisesi\");\n      try(BufferedReader br = new BufferedReader(new FileReader(p.toFile())), BufferedWriter bw = new BufferedWriter(new FileWriter(p.toFile()))){\n          \n      } catch(IOException e){\n          \n      }','Exceptions',0,0,NULL,5),(1330,'ok, AutoCloseable interface allows throwing any Exception','Class A implements AutoCloseable { \n	public void close() throws Exception {}\n}	','Exceptions',0,0,NULL,5),(1331,'ok sublcasses or implenting methods can throw a subclass of excpetion\nor none at all.\n\nAutoCloseable\'s  close throws an Exception','class B implements AutoCloseable { public void close() {}}\nclass C implements AutoCloseable { public void close() throws IOException {}}','Exceptions',0,0,NULL,5),(1332,'ILLEGAL- Closeable only allows IOExceptions or subclasses','class D implements Closeable { public void close() throws Exception{}}','Exceptions',0,0,NULL,5),(1333,'ok Closeable allows throwing IOExceptions\n\nvoid close() throws IOException','class E implements Closeable { public void close() throws IOException {}}','Collections',0,0,NULL,5),(1334,'you can call close() multiple times all day and nothing will happen the second time and beyond. \nwill not blow up. ','idempotent','Exceptions',0,0,NULL,5),(1335,'nothing bad will happen if you call close() more than one time. ','AutoCloseable\'s close() is idempotent	','Exceptions',0,0,NULL,5),(1336,'might blow up if called more than once','Closeable\'s close() is not idempotent','Exceptions',0,0,NULL,5),(1337,'B\nA\ncatch\n\nResources are closed in reverse order from what they are declared.','class A implements AutoCloseable {\n	public void close() {\n		sout(\"A\");\n	}\n}\n\nclass B implements AutoCloseable {\n	public void close() {\n		sout(\"B\");\n	}\n}\n\nclass C {\n	psvm(sa){\n		try(A a = new A(); B b = new B()){\n			throw new RuntimeException();\n		} catch(EXception e) {\n			sout(\"catch\");\n		}\n	}\n}\n\nwhat does it print?','Exceptions',0,0,NULL,5),(1338,'Try\nsuppressed: java.io.IOException: Closing\n\nafter the exception in the try block gets thrown on line 4, the try with \nresources still calls close() and the catch block catches one \nof the exceptions.\n\nJava adds any excpeittions thrown by close() methods to a suppressed array in the main excpetion. \n\nif no other exception happens in the try block the exceptioon thrown in\nclose() gets treated as the main excpetion  for the catch block. ','public class Suppressed {\n	psvm(sa) {\n		try(One one = new One()) {\n			throw new exception(\"try\");\n		} catch (Exception e) {\n			sout(e.getMessage());\n			\n			for(Throwable t : e.getSuppressed()){\n				sout(\"suppressed:\" + t);\n		}	}\n	}\n}\n\nclass One implements AutoCloseable {\n	public void close() throws IOException {\n		throw new IOException(\"Closing\");\n	}\n}','Exceptions',0,0,NULL,5),(1339,'got it ','If the catch or Finally block throws an exception NO SUPPRESSION HAPPENS\nthe last exception thrown gets sent to the caller rather than the one from the \ntry- just like before try with resources','Exceptions',0,0,NULL,5),(1340,'Closing - 2\nsuppressed: java.io.IOException: Closing - 1\n\nresources close in the opposite order they are declared','class Bad implements AutoCloseable {\n	String name;\n	Bad(String n) { name = n; }\n	public void close() throws IOException {\n		throw new IOException(\"Closing -\" +name);\n	}\n}\n\npublic class Suppressed {\n	public static void main(SA) {\n		try(Bad b1 = new Bad(\"1\"); Bad b2 = new Bad(\"2\")) {\n			\n		} catch(Exception e) {\n			sout(e.getMessage());\n			for(Throwable t : e.getSuppressed()) {\n				sout(\"suppressed:\" + t);\n			}\n		}\n	}\n}','Exceptions',0,0,NULL,5),(1341,'Since all file IO on the exam is related to characters, if you see a Stream\nlike DataOutputStream the the question is probably about serialization\nor something unrelated to the actual IO objective','Stream classes are used to read and write bytes, and Readers and Writers\nare used to read write Characters....','IO',0,0,NULL,5),(1342,'// first time\nfalse\ntrue \ntrue\n\n//second time\ntrue\nfalse\ntrue\n\nexists returns false the first time becasue the file was created as an object\nbut not yet as a physical file. ','psvm(SA) {\n	try {\n		boolean newFile = false;\n		File file = new File(\"fiileWrite1.txt\");\n		sout(file.exists());\n		newFile = file.createNewFile());\n		sout(newFile);\n		sout(file.exists());\n	} catch (IOException e) {}\n}	','IO',0,0,NULL,5),(1343,'This method returns true if it can find the actual file\n\nfalse\ntrue\n\n	the first time it is run','public static void main(String[] args){\n        File newFile = new File(\"/home/maxbisesi/Public/textFile5.txt\");\n        try{\n            System.out.println(newFile.exists());\n            newFile.createNewFile();\n            System.out.println(newFile.exists());\n        } catch(IOException e){\n            \n        }   \n    }','IO',0,0,NULL,5),(1344,'true if the named file does not exist and was successfully created; false if the named file already exists\n','File method: \ntry {\n	createNewFile();\n} catch(IOException e) { } ','IO',0,0,NULL,5),(1345,'File(File parent, String child)\nCreates a new File instance from a parent abstract pathname and a child pathname string.\n\nFile(String pathname)\nCreates a new File instance by converting the given pathname string into an abstract pathname.\n\nFile(String parent, String child)\nCreates a new File instance from a parent pathname string and a child pathname string.','File class Constructors	','IO',0,0,NULL,5),(1346,'createNewFile()\ndelete()\nexists()\nisDirectory()\nisfile()\nlist()\nmkdir()\nrenameTo()','File class key methods ','IO',0,0,NULL,5),(1347,'FileWriter(File file)\n\nFileWriter(String filename)','FileWriter class Constructors	','IO',0,0,NULL,5),(1348,'close()\nflush()\nwrite()','FileWriter class key methods 	','IO',0,0,NULL,5),(1349,'BufferedWriter(Writer out)','BufferedWriter class constructors	','IO',0,0,NULL,5),(1350,'close() \nflush()\nnewLine()\nwrite()','BufferedWriter key methods	','IO',0,0,NULL,5),(1351,'PrintWriter(File file)\nCreates a new PrintWriter, without automatic line flushing, with the specified file.\n\nPrintWriter(File file, String csn)\nCreates a new PrintWriter, without automatic line flushing, with the specified file and charset.\n\nPrintWriter(OutputStream out)\nCreates a new PrintWriter, without automatic line flushing, from an existing OutputStream.\n\nPrintWriter(OutputStream out, boolean autoFlush)\nCreates a new PrintWriter from an existing OutputStream.\n\nPrintWriter(String fileName)\nCreates a new PrintWriter, without automatic line flushing, with the specified file name.\n\nPrintWriter(String fileName, String csn)\nCreates a new PrintWriter, without automatic line flushing, with the specified file name and charset.\n\nPrintWriter(Writer out)\nCreates a new PrintWriter, without automatic line flushing.\n\nPrintWriter(Writer out, boolean autoFlush)\nCreates a new PrintWriter.','PrintWriter constructors','IO',0,0,NULL,5),(1352,'read()','FileReader key methods 	','IO',0,0,NULL,5),(1353,'Reader','BufferedReader constructors	','IO',0,0,NULL,5),(1354,'read()\nreadLine()','BufferedReader key methods','IO',0,0,NULL,5),(1355,'filewrite2.txt would contain the text:\n\nhello\nworld','File file = new file(\"filewriter2.txt\");\nFileWriter fw = new fileWriter(file);\n\nPrintWriter pw = new PrintWriter (fw);\n\npw.println(\"hello\");\npw.println(\"world\"));','IO',0,0,NULL,5),(1356,'','File file = new File(\"filewrite2.txt\");\nFileReader fr = new FileReader(file);\nBufferedReader br = new BufferedReader(fr);\n\nString data = br.readLine();','IO',0,0,NULL,5),(1357,'got it ','File file = new File(\"foo\");\n\nif \"foo\" does not exist no actual file is created.\n\nif \"foo\" does exists, the new File object refers to the existing file. ','IO',0,0,NULL,5),(1358,'io','readers dont have flush methods','IO',0,0,NULL,5),(1359,'a char[]','Console.readPassword() returns...','IO',0,0,NULL,5),(1360,'Returns the path element corresponding to the specified index.\n\nthe 0th element is the one closest to the root.','Path Method:\n\nPath getName(int index)','IO',0,0,NULL,5),(1361,'returns the filename or the last element of the sequence of name elements\n\nor..\n\nReturns the name of the file or directory denoted by this path as a Path object. The file name is the farthest element from the root in the directory hierarchy.','Path Method:\n\nString getFileName()','IO',0,0,NULL,5),(1362,'4','public class Hello {\n    public static void main(String[] dicks) throws IOException{\n      Path src = Paths.get(\"/home/maxbisesi/Documents/copy.txt\");\n\n      System.out.println(src.getNameCount());\n      \n    }\n\n}','IO',0,0,NULL,5),(1363,'\n/home/maxbisesi/Documents','\npublic class Hello {\n    public static void main(String[] dicks) throws IOException{\n      Path src = Paths.get(\"/home/maxbisesi/Documents/copy.txt\");\n      Path srcParent = src.getParent();\n      System.out.println(srcParent);\n      \n    }\n\n}','IO',0,0,NULL,5),(1364,'retunrs the root of thsi path, or null if this path does not have a root.','Path Method:\n\nPath getRoot()		','IO',0,0,NULL,5),(1365,'returns a ssubsequence of this path NOT INCLUDING ROOT. \n\nbeginning INCLUSIVE\n\nending EXCLUSIVE','Path Method:\n\nPath subpath(int beginindex, int endIndex)','IO',0,0,NULL,5),(1366,'that means it can be iterated through in a for loop!','Path extends from Iterable<Path>	','IO',0,0,NULL,5),(1367,'tmp/dir1/dir2/dir3/file.txt','int spaces = 1;\nPath myPath = Paths.get(\"tmp\", \"dir1\", \"dir2\", \"dir3\", \"file.txt\");\n\nfor(Path subpath : myPath){\n	sout( subpath + \"//\" );\n}','IO',0,0,NULL,5),(1368,'returns a path that is this path with redundant name elements eliminated\n\n. can be ignored\n\n.. followed by a directory can be removed as redundant','Path method:\n\nPath normalize()	','IO',0,0,NULL,5),(1369,'/a/b/c','Paths.get(\"/a/./b/./c\").normalize();\n','IO',0,0,NULL,5),(1370,'.classpath','Paths.get(\".classpath\").normalize();','IO',0,0,NULL,5),(1371,'/a/b','Paths.get(\"/a/b/c/..\").normalize()','IO',0,0,NULL,5),(1372,'../a/b/c\n\nThe two dots do say go up one directory, but since there is\'nt a directory\nbefore it Path cant simplify it.','Paths.get(\"../a/b/c\").normalize()','IO',0,0,NULL,5),(1373,'/home/java/models/Model.pdf\n\npath1.resolve(path2) should be read as \"resolve path2 within path1s directory\n','Path dir = Paths.get(\"/home/java\");\nPath file = Paths.get(\"models/Model.pdf\");\nPath result = dir.resolve(file);\n\nsout( result );\n	','IO',0,0,NULL,5),(1374,'/google\n\nResolve the given path against this path.\n\nIf the other parameter is an absolute path then this method trivially returns other.\n If other is an empty path then this method trivially returns this path.\n Otherwise this method considers this path to be a directory and resolves\n the given path against this path. In the simplest case, the given path does not have a root component, \nin which case this method joins the given path to this path \nand returns a resulting path that ends with the given path.','class Hello {\n    public static void main(String[] args) {     \n        Path p1 = Paths.get(\"/home/max/tmp\");\n        Path p2 = Paths.get(\"/google\");\n        System.out.println(p1.resolve(p2));\n        \n    }\n\n}','IO',0,0,NULL,5),(1375,'/home/java/dir\n/home/java/Model.pdf\n/dir/Model.pdf\n/home/java\n/home/java\nModel.pdf/dir\n\nThe first three do what you would exprect. They add the paramenter\nto resolve to the provided path object. The fourth and fifth try to resolve\nan absolute path within the context of something else. The problem is \nthat an aboluste path doesnt\'t depend on other directories it is absolute.\n','Path absolute = Paths.get(\"/home/java\");\nPath relative = Paths.get(\"dir\");\nPath file = Paths.get(\"Model.pdf\");\n\nsout( absolute.resolve(relative) );\nsout( asolute.resolve(file) );\nsout( relative.resolve(file) );\nsout( relative.resolve(absolute) ); // BAD\nsout( file.resolve(absolute) ); //BAD\nsout( file.resolve(relative) ); //BAD','IO',0,0,NULL,5),(1376,'Thhe compilere cannot decide here so it will not compile','Be carefule with questions that come in two flavors. one with a Path parameter\nand the other with a String parameter such as resolve()...\n\nPath path = Paths.get(\"/usr/bin/zip\");\npath.resolve(null);','IO',0,0,NULL,5),(1377,'resolve()','Which Path method is used to combine two paths and set one in another?','IO',0,0,NULL,5),(1378,'relativize()','Which Path method is used to describe how to gret from one path to \nthe other	','IO',0,0,NULL,5),(1379,'country/Swift.mp3\n\n\njava recognized that the /home/java part is the same and returned a path of\njust the remainder.\n\npath1.relativize(path2) should be read as \"give me a path shows how to get from\npath1 to path2\"','Path dir = Paths.get(\"/home/java\");\nPath music = Paths.get(\"/home/java/country/Swift.mp3\");\nPath mp3 = dir.reltivize(music);\n\nsout( mp3 );','IO',0,0,NULL,5),(1380,'.relativize()','\"give me a path shows how to get from\npath1 to path2\"','IO',0,0,NULL,5),(1381,'temp/music.mp3\n\n../..\n\n../../usr/local\n\nmusic.pdf\n\nExcpetion in main thread IllegalArgumentExcpetion\n\n	','Path absolute1 = Paths.get(\"/home/java\");\nPath absolute2 = Paths.get(\"/usr/local\");\nPath absolute3 = Paths.get(\"/home/java/temp/music.mp3\");\nPath relative1 = Paths.get(\"temp\");\nPath relative2 = Paths.get(\"temp/music.pdf\");\n\nsout( absolute1.relativize(absolute3) );\nsout( absolute3.relativize(absolute1) );\nsout( absolute1.relativize(absolute2) );\nsout( relative1.relativize(relative2) );\nsout( absolute1.relativize(relative1) ); //BAD','IO',0,0,NULL,5),(1382,'Path relativize(Path other)\n\nConstructs a relative path between this path and a given path.\n\nRelativization is the inverse of resolution. This method attempts to construct a relative path that when resolved against this path, yields a path that locates the same file as the given path. For example, on UNIX, if this path is \"/a/b\" and the given path is \"/a/b/c/d\" then the resulting relative path would be \"c/d\". Where this path and the given path do not have a root component, then a relative path can be constructed. A relative path cannot be constructed if only one of the paths have a root component. Where both paths have a root component then it is implementation dependent if a relative path can be constructed. If this path and the given path are equal then an empty path is returned.\n\nFor any two normalized paths p and q, where q does not have a root component,\n\n    p.relativize(p.resolve(q)).equals(q) \n\nWhen symbolic links are supported, then whether the resulting path, when resolved against this path, yields a path that can be used to locate the same file as other is implementation dependent. For example, if this path is \"/a/b\" and the given path is \"/a/x\" then the resulting relative path may be \"../x\". If \"b\" is a symbolic link then is implementation dependent if \"a/b/../x\" would locate the same file as \"/a/x\".\n\nParameters:\n    other - the path to relativize against this path\nReturns:\n    the resulting relative path, or an empty path if both paths are equal\nThrows:\n    IllegalArgumentException - if other is not a Path that can be relativized against this path','relativeize()','IO',0,0,NULL,5),(1383,'If this program is run from the root, it is the one in /tmp/file1.txt\n\nif it is run from /tmp it is the one in /tmp/tmp/file1.txt\n\nif the program is run from anywhere else the path refers to a file that doesn\nnot exist. ','When creating a Path you can seperate out folder and filename as much\nor as little as you want. When you don\'t begin with a root the Path\nis considered a relative path, which means Java looks from the current\ndirectory.\n\nPath p6 = Paths.get(\"tmp\", \"file1.txt\"); // relative path\n\n/ (root)\n	| - - tmp\n		| - file1.txt\n		| - tmp\n			| - file1.txt\n','IO',0,0,NULL,5),(1384,'got it ','With IO a file doesn\'t exists just because you create a File object.\nIt is the same with Path objects\n\nPath path = Paths.get(\"fileWrite1.txt\");\nsout(Files.exists(path)); // false\nFiles.createFile(path); \nsout(Files.exists(path)); // true','IO',0,0,NULL,5),(1385,'Path path1 = Paths.get(\"/java/source\");\nPath path2 = Paths.get(\"/java/source/directory\");\nPath file = Paths.get(\"/java/source/directory/Program.java\");\nFiles.createDirectory(path1);\nFiles.createDirectory(path2);\nFiles.createFile(file);\n\n// all at once\n\nFiles.createDirectories(path2);\nFile.createFile(file);','create directories one at a time or all at once	......\n\nTHE directory must exist by the time the file is created','IO',0,0,NULL,5),(1386,'13570164000000','Date januaryFirst = new GregorianCalendar(20q3, Calendar.January, 1).getTime();\n\nFile file = new File(\"c:/temp/file\");\nfile.createNewFile();\nfile.setLastModified(januaryFirst.getTime());\nfile.setLastModified(januaryFirst.getTime());\nsout(file.lastModified());\nfile.delete();','IO',0,0,NULL,5),(1387,'2013-01-01T05','Path path = Paths.get(\"c:/temp/file2\");\nDate januaryFirst = new GregorianCalendar(2013,Calendar.JANUARY, 1).getTime();\nFiles.createFile(path);\nFileTime fileTime = FileTime.fromMillis(januaryFirst.getTime());\nFiles.setLastModifiedTime(path,fileTime);\nsout(Files.getLastModifiedTime(path));\nFiles.delete((path);','IO',0,0,NULL,5),(1388,'\nfile.lastModified();\n\nFiles.getLastModifiedTime(path);','How would you get the last modified date/time of a Path and a File?\n\nFile file = new file(\"test\");\nPath path = Paths.get(\"test\");','IO',0,0,NULL,5),(1389,'A C D E F \n\nin an undeterminable order, although thread angela uses the max reference\n.Sleep is static and therefore she puts herself to sleep. This is why\nreferences shouldn\'t be used for static methods. \n\nmax trys to synchronize on angela but he does not own the lock so he therefore\ncannot and throws an IllegalMonitorStateException. \n\n... ','public class Hello {\n    static Thread max ,angela;\n    public static void main(String[] args){\n        angela = new Thread() {\n            public void run(){\n                System.out.println(\"A\");\n                try {\n                    max.sleep(1000);\n                } catch(Exception e){\n                    System.out.println(\"B\");\n                }\n                System.out.println(\"C\");\n                \n            }\n        };\n        \n        max = new Thread() {\n            public void run(){\n                System.out.println(\"D\");\n                try {\n                    angela.wait(); \n                } catch(Exception e){\n                    System.out.println(\"E\");\n                }\n                \n                System.out.println(\"F\");\n            }\n        };\n        \n        max.start();\n        angela.start();   \n    }\n} ','IO',0,0,NULL,5),(1390,'file.canRead();\n\nFiles.isReadable(path);','How would you get theread permision set of a Path and a File?\n\nFile file = new file(\"test\");\nPath path = Paths.get(\"test\");','IO',0,0,NULL,5),(1391,'file.canWrite();\nfile.canExecute();\n\nFiles.isWritable(path);\nFiles.isExecutable(path);','How would you get write and or execute permision set of a Path and a File?\n\nFile file = new file(\"test\");\nPath path = Paths.get(\"test\");','IO',0,0,NULL,5),(1392,'file.setLastModifed(timeinMillis);\n\nFileTime ft = FileTime.fromMillis(timeInMillis);\nFiles.setLastModifiedTime(path,ft);','How do you set the last modified time of a path and file?\n\nFile file = new file(\"test\");\nPath path = Paths.get(\"test\");','IO',0,0,NULL,5),(1393,'basic.creationTime();\nbasic.lastAccessTime();\nbasick.lastModifiedTime();\n\nbasic.isDirectory();\n\n','BasicFileAttributes basic = Files.readAttributes(path, BasicFileAttributes.class);\n\nhow would you list the creation time, last access time, and last Modified time?	\n','IO',0,0,NULL,5),(1394,'1. BasicFileAttributes is PLURAL, BasicFileAttributeVIew is SINGULAR\n\n2. BasicFIleAttributeView basView = Files.getFileAttributeView(   );   \n\n	BasicFileAtttributes bas = FIles.readAttributes(   );\n\n3. You can ONLY update attributes in BasicFileAttributeView, \n	\n	VIEW IS FOR UPDATING','Three big things about BasicFileAttributes and BasicFileAttributeView...','IO',0,0,NULL,5),(1395,'PosixFileAttributes pox = Files.readAttributes(path, PosixFileAttributes.class);\n','How would you construct a PosixFileAttribute object?	','IO',0,0,NULL,5),(1396,'Path path = Paths.get(\"/tmp/file2\");\nFiles.createFile(path);\nPosixFileAttributes ps = Files.readAttributes(path, PosixFileAttributes.class);\n\nSet<PosixFilePermission> perms = PosixFilePermission.fromString(\"rw-r--r--\");\n\nFiles.setPosixFilePermissions(path,perms);\n\nsout( ps.permissions() );\n\nTHe output would be:\n\n[OWNER_WRITE, GROUP_READ, OTHERS_READ, OWNER_READ ]','How would you set a Unix File\'s permissions in Java?	','IO',0,0,NULL,5),(1397,'BasicFileAttributes basic = Files.readAttributes(path1, BasicFileAttribute.class );\n\nFileTime at = basic.lastAccessTime();\nFileTime update = basic.lastModifiedTime();\nFileTime now = FileTime.fromMillis(System.currentTimeMiilis() );\n\nPath file = Paths.get(\"/temp/file.txt\");\nFiles.createFile(file);\n\nBasicFileAttributeView view = Files.getBasicFileAttributeView(file, BasicFileAttributeView.class);\n\nview.setTimes(update, at, now);','How to take modified times from one file\nand write new BasicFileAttributes\' last modified times\nlast access time and creation time to another file ... ?','IO',0,0,NULL,5),(1398,'... interface\n\nmethods:\n\nString 	name()\nReturns the name of the attribute view.\n\nBasicFileAttributes 	readAttributes()\nReads the basic file attributes as a bulk operation.\n\nvoid 	setTimes(FileTime lastModifiedTime, FileTime lastAccessTime, FileTime createTime)\n\nUpdates any or all of the file\'s last modified time, last access time, and create time attributes.','BasicFileAttributeView is a...\n\nClass\n\nInterface\n\nAbstract class     ?','IO',0,0,NULL,5),(1399,'FileTime 	creationTime()\nReturns the creation time.\n\nObject 	fileKey()\nReturns an object that uniquely identifies the given file, or null if a file key is not available.\n\nboolean 	isDirectory()\nTells whether the file is a directory.\n\nboolean 	isOther()\nTells whether the file is something other than a regular file, directory, or symbolic link.\n\nboolean 	isRegularFile()\nTells whether the file is a regular file with opaque content.\n\nboolean 	isSymbolicLink()\nTells whether the file is a symbolic link.\n\nFileTime 	lastAccessTime()\nReturns the time of last access.\n\nFileTime 	lastModifiedTime()\nReturns the time of last modification.\n\nlong 	size()\nReturns the size of the file (in bytes).','interface BasicFileAttributes methods.... ','IO',0,0,NULL,5),(1400,'GroupPrincipal 	group()\nReturns the group owner of the file.\n\nUserPrincipal 	owner()\nReturns the owner of the file.\n\nSet<PosixFilePermission> 	permissions()\nReturns the permissions of the file.','interface PosixFileAttributes methods','IO',0,0,NULL,5),(1401,'String 	name()\nReturns the name of the attribute view.\n\nPosixFileAttributes 	readAttributes()\nReads the basic file attributes as a bulk operation.\n\nvoid 	setGroup(GroupPrincipal group)\nUpdates the file group-owner.\n\nvoid 	setPermissions(Set<PosixFilePermission> perms)\nUpdates the file permissions.','interface PosixFileAttributeView methods ...','IO',0,0,NULL,5),(1402,'DosFileAttributeView has methods...\n\nsetArchive()\nsetHidden()\nsetReadOnly()\nsetSystem()\n\nfor Windows specific files ','With DosFileAttributeView you can set what new and different file types ?','IO',0,0,NULL,5),(1403,'String 	name()\nReturns the name of the attribute view.\n\nDosFileAttributes 	readAttributes()\nReads the basic file attributes as a bulk operation.\n\nvoid 	setArchive(boolean value)\nUpdates the value of the archive attribute.\n\nvoid 	setHidden(boolean value)\nUpdates the value of the hidden attribute.\n\nvoid 	setReadOnly(boolean value)\nUpdates the value of the read-only attribute.\n\nvoid 	setSystem(boolean value)\nUpdates the value of the system attribute.','interface DosFileAttributeView methods...','IO',0,0,NULL,5),(1404,'DosFileAttributes dos = Files.readAttributes(path, DosFileAttributes.class);\n\nsout( dos.isHidden() );\nsout( dos.isReadOnly() );\n\nFiles.setAttribute(path, \"dos:hidden\", true);\nFiles.setAttribute(path, \"dos:readonly\", true);\n\n','read a DosFileAttributes then declare if it is hidden and readonly \nthen set them so without using a DosFileAttributeView...','IO',0,0,NULL,5),(1405,'\n    setAttribute\n\n    public static Path setAttribute(Path path,\n                    String attribute,\n                    Object value,\n                    LinkOption... options)\n                             throws IOException\n\n    Sets the value of a file attribute.\n\n    The attribute parameter identifies the attribute to be set and takes the form:\n\n        [view-name:]attribute-name \n\n    where square brackets [...] delineate an optional component and the character \':\' stands for itself.\n\n    view-name is the name of a FileAttributeView that identifies a set of file attributes. If not specified then it defaults to \"basic\", the name of the file attribute view that identifies the basic set of file attributes common to many file systems. attribute-name is the name of the attribute within the set.\n\n    The options array may be used to indicate how symbolic links are handled for the case that the file is a symbolic link. By default, symbolic links are followed and the file attribute of the final target of the link is set. If the option NOFOLLOW_LINKS is present then symbolic links are not followed.\n\n    Usage Example: Suppose we want to set the DOS \"hidden\" attribute:\n\n        Path path = ...\n        Files.setAttribute(path, \"dos:hidden\", true);\n     \n\n    Parameters:\n        path - the path to the file\n        attribute - the attribute to set\n        value - the attribute value\n        options - options indicating how symbolic links are handled\n    Returns:\n        the path parameter\n    Throws:\n        UnsupportedOperationException - if the attribute view is not available\n        IllegalArgumentException - if the attribute name is not specified, or is not recognized, or the attribute value is of the correct type but has an inappropriate value\n        ClassCastException - if the attribute value is not of the expected type or is a collection containing elements that are not of the expected type\n        IOException - if an I/O error occurs\n        SecurityException - In the case of the default provider, and a security manager is installed, its checkWrite method denies write access to the file. If this method is invoked to set security sensitive attributes then the security manager may be invoked to check for additional permissions.\n\n','You dont always need a XXXFileAttributeView object in order to change\na files attributes, you can just as easily do so with \"Files\" ...\n	','IO',0,0,NULL,5),(1406,'Files.setPosixFilePermissions\n\npublic static Path setPosixFilePermissions(Path path,\n                           Set<PosixFilePermission> perms)\n                                    throws IOException\n\nSets a file\'s POSIX permissions.\n\nThe path parameter is associated with a FileSystem that supports the PosixFileAttributeView. This attribute view provides access to file attributes commonly associated \nwith files on file systems used by operating systems that implement the Portable \nOperating System Interface (POSIX) family of standards.\n\nParameters:\n    path - A file reference that locates the file\n    perms - The new set of permissions\nThrows:\n    UnsupportedOperationException - if the associated file system does not support the PosixFileAttributeView\n    ClassCastException - if the sets contains elements that are not of type PosixFilePermission\n    IOException - if an I/O error occurs\n    SecurityException - In the case of the default provider, and a security manager is installed, it denies RuntimePermission(\"accessUserInformation\") or its checkWrite method denies write access to the file.','You dont need PosixFileAttributeView to set a file permissions either...','IO',0,0,NULL,5),(1407,'PosixFileAttributes pos = Files.readAttributes(path, PosixFileAttributes.class);\nSet<PosixFilePermissions> perms = PosixFilePermissions.fromString(\"rw-r--r--:);\n\nFiles.setPosixFilePermissions(path,perms);\n\nsout(pos.group());\nsout(pos.permissions());','How to set a linux files permisions from a string ?\n	','IO',0,0,NULL,5),(1408,'DirectoryStream<T> \n\nT is the element returned by the iterator. \n\nTHis allows for the convieninet use of a for - each loop to go through a dir.\n\nThe elements returned by the iterator are in no specific order.\n\n List<Path> listSourceFiles(Path dir) throws IOException {\n       List<Path> result = new ArrayList<>();\n       try (DirectoryStream<Path> stream = Files.newDirectoryStream(dir, \"*.{c,h,cpp,hpp,java}\")) {\n           for (Path entry: stream) {\n               result.add(entry);\n           }\n       } catch (DirectoryIteratorException ex) {\n           // I/O error encounted during the iteration, the cause is an IOException\n           throw ex.getCause();\n       }\n       return result;\n   }\n ','What interface is used to recursively loop through a directory ?	','IO',0,0,NULL,5),(1409,'\n    Files.newDirectoryStream\n\n    public static DirectoryStream<Path> newDirectoryStream(Path dir)\n                                                    throws IOException\n\n    Opens a directory, returning a DirectoryStream to iterate over all entries in the directory. The elements returned by the directory stream\'s iterator are of type Path, each one representing an entry in the directory. The Path objects are obtained as if by resolving the name of the directory entry against dir.\n\n    When not using the try-with-resources construct, then directory stream\'s close method should be invoked after iteration is completed so as to free any resources held for the open directory.\n\n    When an implementation supports operations on entries in the directory that execute in a race-free manner then the returned directory stream is a SecureDirectoryStream.\n\n    Parameters:\n        dir - the path to the directory\n    Returns:\n        a new and open DirectoryStream object\n    Throws:\n        NotDirectoryException - if the file could not otherwise be opened because it is not a directory (optional specific exception)\n        IOException - if an I/O error occurs\n        SecurityException - In the case of the default provider, and a security manager is installed, the checkRead method is invoked to check read access to the directory.\n\n','how do you create a new DirectoryStream<T>','IO',0,0,NULL,5),(1410,'Path\n\nThe directory Stream interface is generic, but thats misleading since the \nonly way create a new DirectoryStream is by using File.newDirectoryStream\nwhich returns a Path.','What type of object are returned by directorystreams iterator ? ','IO',0,0,NULL,5),(1411,'use \nFiles.newDirectoryStream(Path dir, String glob);\n\nthis lets you add a glob in that will compare the string representations \nof their file names agains the given glob.\n\nthis lets you filter your results...\n\n Path dir = ...\n     try (DirectoryStream<Path> stream = Files.newDirectoryStream(dir, \"*.java\")) {\n         :\n     }','How would you filter the object returned by a directory Stream ?	','IO',1,0,NULL,5),(1412,'Nothing will not compile, must catch IOException for DirectoryStream','What will be returned by this code...\n\n	Path dir = Paths.get(\"/home/maxbisesi/Documents\");\n        \n	try(DirectoryStream<Path> ds = Files.newDirectoryStream(dir,\"[vx]*\")){\n            sout( );\n        } ','IO',0,0,NULL,5),(1413,'only 1','How many directories at a time can DirectoryStream look at ?','IO',0,0,NULL,5),(1414,'or ...\nDirectoryStream streams one directory','Think, DirectorySteam acts like ls in bash.','IO',0,0,NULL,5),(1415,'public static Path walkFileTree(Path start,\n                FileVisitor<? super Path> visitor)\n                         throws IOException\n\nWalks a file tree.\n\nThis method works as if invoking it were equivalent to evaluating the expression:\n\n     walkFileTree(start, EnumSet.noneOf(FileVisitOption.class), Integer.MAX_VALUE, visitor)\n     \n\nIn other words, it does not follow symbolic links, and visits all levels of the file tree.\n\nParameters:\n    start - the starting file\n    visitor - the file visitor to invoke for each file\nReturns:\n    the starting file\nThrows:\n    SecurityException - If the security manager denies access to the starting file. In the case of the default provider, the checkRead method is invoked to check read access to the directory.\n    IOException - if an I/O error is thrown by a visitor method','What \"Files\" method do you use along with FileVisitor?','IO',0,0,NULL,5),(1416,'FileVisitResult','FileVisitor methods return what ?','IO',0,0,NULL,5),(1417,'CONTINUE\nSKIP_SIBLINGS = continue without visiting the siblings of this file or directory\n\nSKIP_SUBTREE = continue without visiting the entries in this directory\n\nTERMINATE','Enum FileVisitResult elements','IO',0,0,NULL,5),(1418,'SimpleFileVisitor sf = new SimpleFileVisitor() will not compile','SimpleFileVisitor has a protected constructor so It can only be extended','IO',0,0,NULL,5),(1419,'DirectoryStream throws an IOException. Therefore anytime you use \nDirectoryStream you must catch an IOException\n\ntry(DirectoryStream stream = Files.newDirectoryStream(dir)){\n	sout(\"throw excpetion\");\n	//do stuff\n} catch(IOException e) { \n	log(e);\n}','try(DirectoryStream stream = Files.newDirectoryStream(dir)){\n	sout(\"throw excpetion\");\n	//do stuff\n}\n\nWhats wrong here ?','IO',0,0,NULL,5),(1420,'If DirectroyStream is not typed it will give Object elements. Therefore\nto use an untyped DirectoryStream you would have to use...\n	\n	for(Object file : stream) {\n	\n	}\n\n... but thats usually not what you want so always do this>>>\n\n	try(DirectoryStream<Path> Stream = Files.newDirectoryStream(dir)){\n\n	} catch(IOExcetpion e) {\n\n	}','try(DirectoryStream stream = Files.newDirectoryStream(dir)){\n\n	for(Path file : stream){\n		sout(file.getFileName());\n	}\n} catch(IOException e ){\n\n}\n\nWhats wrong here ??','IO',0,0,NULL,5),(1421,'All character stream classes are descended from Reader and Writer. \nAs with byte streams, there are character stream classes that specialize in file I/O: FileReader and FileWriter. \nThe CopyCharacters example illustrates these classes.\n\nclose() throws IOException here too','\npublic class CopyCharacters {\n    public static void main(String[] args) throws IOException {\n\n        FileReader inputStream = null;\n        FileWriter outputStream = null;\n\n        try {\n            inputStream = new FileReader(\"xanadu.txt\");\n            outputStream = new FileWriter(\"characteroutput.txt\");\n\n            int c;\n            while ((c = inputStream.read()) != -1) {\n                outputStream.write(c);\n            }\n        } finally {\n            if (inputStream != null) {\n                inputStream.close();\n            }\n            if (outputStream != null) {\n                outputStream.close();\n            }\n        }\n    }\n}\n','IO',0,0,NULL,5),(1422,'wrap them in Try Block, they all throw IOExceptions ','What has to be done with pretty much ALL IO classes ?','IO',0,0,NULL,5),(1423,'public String readLine()\n                throws IOException\n\nReads a line of text. A line is considered to be terminated by any one of a line feed (\'\\n\'), a carriage return (\'\\r\'), or a carriage return followed immediately by a linefeed.\n\nReturns:\n    A String containing the contents of the line, not including any line-termination characters, or null if the end of the stream has been reached\nThrows:\n    IOException - If an I/O error occurs\n\n\nOther IO classes have read methods that only read in a single character\nBufferedReader has this too. But this method really helps!','What method does BufferedReader have that makes it valuable	','IO',0,0,NULL,5),(1424,'PrintWriter','Which IO class swallows exceptions and does not throw them but \nsaid exceptions can be checked using checkerror()','IO',0,0,NULL,5),(1425,'wont compile you cant construct a FileWriter from a Path not to mention there is an unreported IOException','Path file = Paths.get(\"/home/dick/bigorsmall.txt\");\nBufferedWriter bw = new BufferedWriter(new FileWriter(file));\n\nbw.write(\"this ones pretty big \");','IO',0,0,NULL,5),(1426,'Copy the file from the source to target and return the target.\n\nthrows FileAlreadyExistsException if target fiile already exists, and no\nREPLACE_EXSISTING copy Option is specified. ','Files method:\n\nPath copy(Path src, Path targ, CopyOption...options)','IO',0,0,NULL,5),(1427,'Moves the file from src to target return target. \n\nthrows:\n\n FileAlreadyExistsException - if the target file exists but cannot be replaced because the REPLACE_EXISTING option is not specified (optional specific exception)\n   \n DirectoryNotEmptyException - the REPLACE_EXISTING option is specified but the file cannot be replaced because it is a non-empty directory (optional specific exception)','Files method:\n\nPath move(Path src, Path target, CopyOption options)','IO',0,0,NULL,5),(1428,'false \ntrue\n\nin glob * means match any character excpet a directory boundary\n\n** mathces any character across directory boundaries. \n\nnotice that PathMatcher(\"syntax:pattern\") can take a glob or a regex but you\nmust specify\n\nedit:\nwas previously:\nDefault().getPathMatcher(\"glob: *.txt\");\n\nthere cant be a space after the : or that will mathch...\n\n	Path path = Paths.get(\"one.txt\");\n        PathMatcher matcher = FileSystems.getDefault().getPathMatcher(\"glob: *.txt\");\n        System.out.println(matcher.matches(path));\n\nwould give false unless the space was removed. | Path p1 = Paths.get(\"/home/One.txt\");\nPath p2 = Paths.get(\"One.txt\");\nPathMatcher matcher = FileSystems.getDefault().getPathMatcher(\"glob: *.txt\");\n\nsout( matcher.matches(p1) );\nsout( matcher.matches(p2) );','Path p1 = Paths.get(\"/home/One.txt\");\nPath p2 = Paths.get(\"One.txt\");\nPathMatcher matcher = FileSystems.getDefault().getPathMatcher(\"glob:*.txt\");\n\nsout( matcher.matches(p1) );\nsout( matcher.matches(p2) );','IO',0,0,NULL,5),(1429,'* matches any character inside a directory boundary\n** matches any character inside a directory boundary\n\n','in Glob what does * mean ? what about ** ?','IO',0,0,NULL,5),(1430,'? matches any single character. ','GLOB\n\nwhat does \"?\" mean ?','IO',0,0,NULL,5),(1431,'true\ntrue\nfalse','public class Hello {\n    public static void main(String[] args) {\n        PathMatcher matcher = FileSystems.getDefault().getPathMatcher(\"glob:**{.pic,.txt}\");\n        Path p1 = Paths.get(\"home/files.txt\");\n        Path p2 = Paths.get(\"documents/pictures/smile.pic\");\n        Path p3 = Paths.get(\"home/dir\");\n        \n        System.out.println(matcher.matches(p1));\n        System.out.println(matcher.matches(p2));\n        System.out.println(matcher.matches(p3));\n    }\n\n}','IO',0,0,NULL,5),(1432,'true\ntrue\nfalse','public void matches(Path path, String glob){\n	PathMatcher matcher = FileSystems.getDefault().getPathMatcher(glob);\n	sout( matcher.matches(path) );\n}\n\nPath p1 = Paths.get(\"Bert-book\");\nPath p2 = Paths.get(\"Kathy-horse\");\nmatches(p1, \"glob:{Bert*,Kathy*}\");\nmatches(p2, \"glob: {Bert, Kathy}*\");\nmatches(p1, \"glob:{Bert,Kathy}\");','IO',0,0,NULL,5),(1433,'wrong, visitFileFailed takes an IOExcpeption as a parameter\nas well as postVisitDirectory','FileVisitor\n\npublic FileVisitResult visitFileFailed(path file, BasicFileAttributes attrs) {\n\n	// do something\n	return FileVisitResult.CONTINUE;\n	\n}\n','IO',0,0,NULL,5),(1434,'right, ','FileVisitor: \n\npublic FileVisitResult preVisitDirectory(path file, BasicFileAttributes attrs) {\n\n	// do something\n	return FileVisitResult.CONTINUE;\n	\n}','IO',0,0,NULL,5),(1435,'right','FileVisitor:\n\npublic FileVisitResult visitFileFailed(path file, IOException e) {\n\n	// do something\n	return FileVisitResult.CONTINUE;\n	\n}','IO',0,0,NULL,5),(1436,'right','FileVisitor:\n\npublic FileVisitResult postVisitDirectory(path file, IOException e) {\n\n	// do something\n	return FileVisitResult.CONTINUE;\n	\n}','IO',0,0,NULL,5),(1437,'9/8/01 7:46 PM \n\nremember that strings are imutable, so even though you called \nreplaceAll on that string you didn\'t assing it to a new sString therefore it\nwas lost.\n\nshould be:\n	String newDate = todayFile.replaceAll(\" \",\"-\");','Date today = new Date();\n\nDateFormat df = DateFormat.getInstance();\n\nString todayFile = df.format(today);\n\nsout(todayFile);	// this gives 9/8/01 7:46 PM\n\ntodayFile.replaceAll(\" \",\"-\");\n\nsout( todayFile );\n\nwhat prints now ?','Strings',0,0,NULL,5),(1438,'wont compile, FileWriter doesn\'t have a Path constructor,\n\nchange p1 to p1.toFile();\n\nFileWriter(File file)\nConstructs a FileWriter object given a File object.\n\nFileWriter(File file, boolean append)\nConstructs a FileWriter object given a File object.\n\nFileWriter(FileDescriptor fd)\nConstructs a FileWriter object associated with a file descriptor.\n\nFileWriter(String fileName)\nConstructs a FileWriter object given a file name.\n\nFileWriter(String fileName, boolean append)\nConstructs a FileWriter object given a file name with a boolean indicating whether or not to append the data written.','Path p1 = Paths.get(todayFile+\".txt\");\nSystem.out.println(p1);\n        \nBufferedWriter bw = new BufferedWriter(new FileWriter(p1));','IO',0,0,NULL,5),(1439,'4 3 \n\ntwo rules apply to the first doX, you cannot widen and then box in\none step, and var-args are always chosen last. So you cannot widen shorts\nto ints or longs then box them to Integer or Long but you can box short\nto Short then widen that to Number, that takes priority over var args.\n\nthe second doX simmply boxs int to Integer.\n\n\n\n    Assignment contexts allow the use of one of the following:\n\n        an identity conversion (§5.1.1)\n\n        a widening primitive conversion (§5.1.2)\n\n        a widening reference conversion (§5.1.5)\n\n        a boxing conversion (§5.1.7) optionally followed by a widening reference conversion\n\n        an unboxing conversion (§5.1.8) optionally followed by a widening primitive conversion.\n\n\n','class Eggs {\n	int doX(Long x, Long y){ return 1; }\n	int doX(long...){ return 2; }\n	int doX(Integer x, Integery){ return 3; }\n	int doX(Number n, Number m){ return 4; }\n	public static void main(SA){\n		new Eggs().go();\n	}\n	void go(){\n		short s = 7;\n		sout(doX(s,s) + \" \");\n		sout(doX(7,7));\n	}\n}','General',0,0,NULL,5),(1440,'the first is the directory to start walking at in the form of a Path\n\nthe second is an object of the class that extends SimpleFileVisitor<Path>','What is the first and second argument to Files.walkFileTree()','IO',0,0,NULL,5),(1441,'visitFileFailed and postVisitDirectory','Which Two FileVisitor methods take IOExceptions as parameters	?','IO',0,0,NULL,5),(1442,'preVisitDirectory and visitFile','Which two FileVisitor methods take BasicFileAttributes as parameters ?','IO',0,0,NULL,5),(1443,'now the output is:\n	pre: /home\n	file: /home/a.txt\n	pre: /home/child\n	pre: /home/emptyChild\n	post: /home/emptyChild\n	post: /home\n\npostVisitDirectory is never called if the subtree of the directory is skipped','/home\n	- a.txt\n	- emptyChild	\n	- child\n		- b.txt\n		- grandchild\n			- c.txt\n\npublic class PrintDirs extends SimpleFileVisitor<Path> {\n	public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) {\n		sout( \"pre\" + dir);\n		String name = dir.getFileName().toString();\n		\n		if (name.equals(\"child\"))\n			return FileVisitResult.SKIP_SUBTREE;\n		return FileVisitResult.CONTINUE;\n\n	}\n}\n			\n			\n		\n	','IO',0,0,NULL,5),(1444,'','postVisitDirectory is never called if the subtree of the directory is skipped','IO',0,0,NULL,5),(1445,'assuming child is encountered beffore emptyChild, the output is: \n\npre: /home\nfile: /home/a.txt\npre: /home/child\nfile: /home/child/b.txt\npre: /home/child/grandchild\npost: /home/child\npre: /home/emptyChild\npost: /home\n\nyou skip the grandchld subtree so you dont see the postVisitDirectory call\n\nchild is a sibling but it was encountered before emptychild so it was not skipped','/home\n	- a.txt\n	- emptyChild	\n	- child\n		b.txt\n		grandchild\n		c.txt\n\n\" assume you have FileVisitor method from previous flashcards where the\npre post and file are printed before printing the path of that dir or file \"\n\npublic FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) {\n	sout( \"pre: \" + dir);\n	String name = dir.getFileName().toString();\n	\n	if (name.equals(\"grandchild\"))\n		return FileVisitResult.SKIP_SUBTREE;\n	if ( name.equals(\"emptychild\")\n		return FileVisitResult.SKIP_SIBLINGS;\n	return FileVisitResult.CONTINUE;','IO',0,0,NULL,5),(1446,'true \nfalse\nfalse\nfalse\n\n{A*,b} means A followed by anything or the single character b\n\n/**/ means one or more directories with any name\n\n\\\\* the actuall asterix character \\ escapes the * the second \\ espaces the first \\ ','public void matches(Path path, String glob){\n	PathMatcher matcher = FileSystems.getDefault().getPathMatcher(glob);\n	sout( matcher.matches(path) );\n}\n\nPath p1 = Paths.get(\"0*b/test/1\");\nPath p2 = Paths.get(\"9\\\\*b/test/1\");\nPath p3 = Paths.get(\"01b/test/1\");\nPath p4 = Paths.get(\"0*b/1\");\n\nString glob = \"[0-9]\\\\*{A*,b}/**/1\");\n\nmatches(p1,glob);\nmatches(p2,glob);\nmatches(p3,glob);\nmatches(p4,glob);\n','IO',0,0,NULL,5),(1447,'IOException','What exception if any do FileVisitor methods throw ?','IO',0,0,NULL,5),(1448,'glob: **\n\nregex: .*','glob vs regex: \n\nZero or more of any character, including directory bounndary','IO',0,0,NULL,5),(1449,'zero or or more of any character including directory boundary','regex:\n\n.*','IO',0,0,NULL,5),(1450,'glob: *\n\nregex: no syntax required','glob vs regex:\n\nZero or more of any character, not a directory boundary','IO',0,0,NULL,5),(1451,'glob: ?\n\nregex: .','Glob vs regex:\n\nexcactly one character','IO',0,0,NULL,5),(1452,'glob:\n	{cat, dog}*\n\nregex:\n\n	(cat|dog).*','glob vs regex:\n\nBegins with cat or dog','IO',0,0,NULL,5),(1453,'regex','(cat|dog).*\n\nglob or regex ?','IO',0,0,NULL,5),(1454,'FileSystems.getDefault().getPathMatcher();','You are creating a PathMatcher\n\nPathMatcher matcher = ________._________().__________();','IO',0,0,NULL,5),(1455,'FileSystems.getDefault().newWatchService();','You are creating a WatchService:\n\nWatchService watcher = _____________.__________()._________()','IO',0,0,NULL,5),(1456,'WatchKey\ntry {\n	WatchKey key;\n	try {\n	key = watcher.take();\n              } catch(interuptedException x) {\n		return;\n	}\n	for(WatchEvent<?> event : key.pollEvents()){\n	//do stuff\n	}','What do you get from a WatchService to indicate a deletion creation or modification','IO',0,0,NULL,5),(1457,'take() will wait and block forever until an event takes place. Will throw\nInteruptedException if interuped without taking an event. \n\npoll() returns null if an event is not imediately available. ','What are two ways to get a WatchKey ? \nand whats the difference between them ? ','IO',0,0,NULL,5),(1458,'does not compile countGold() cannot be called from a static context','public class Frodo etends Hobbit {\n	public static void main(SA) { \n		int mygold = 7;\n		sout(countGold(mygold,6));\n	}\n}\nclass Hobbit {\n	int countGold(int x, int y) { return x + y; }\n}','IO',0,0,NULL,5),(1459,'1) If two objects are equal, then they must have the same hash code.\n2) If two objects have the same hash code, they may or may not be equal. \n3) If two objects are not equal, they must NOT have the same hashcode\n','The contract between equals() and hashCode() is:','OOP',0,0,NULL,5),(1460,'shows all files and directories in /home/maxbisesi\n\nsqlexception if the path is not a valid path',' public static void main(String[] args){\n       Path dir = Paths.get(\"/home/maxbisesi\");\n       try(DirectoryStream<Path> stream = Files.newDirectoryStream(dir,\"*\");){\n            for(Path path : stream){\n               System.out.println(path);\n            }\n        } catch(IOException e){\n            System.out.println(\"SQLException\");\n            System.out.println(e);\n        }\n   }','IO',0,0,NULL,5),(1461,'x.a() thread1 x.a() in thread2\nx.b() thread1 x.b() in thread2\nx.b() thread1 y.b() in thread2\n\nthe same instance method of the same instance is blocked while a static\nmethod accross all methods is blocked. ','public class Hello {\n    synchronized void a() { actBusy(); }\n    static synchronized void b() { actBusy(); }\n    static void actBusy() {\n        try {\n            Thread.sleep(1000);\n            \n        } catch( InterruptedException e){}\n            \n        \n    }\n    public static void main(String[] args) {\n        final Hello x = new Hello();\n        final Hello y = new Hello();\n        \n        Runnable runnable = new Runnable() {\n            public void run() {\n                int option = (int) (Math.random() * 4);\n                switch(option) {\n                    case 0: x.a(); break;\n                    case 1: x.b(); break;\n                    case 2: y.a(); break;\n                    case 3: y.b(); break;\n                }\n            }\n        };\n        \n        Thread t1 = new Thread(runnable);\n        Thread t2 = new Thread(runnable);\n        \n        t1.start();\n        t2.start();\n    \n    }\n\n}  \n\nwhich methods could never be running at the same time ?','Threads',0,0,NULL,5),(1462,'got it ','Method forwarding relies on Has-a relationships','OOP',0,0,NULL,5),(1463,'method forwarding\n\nan object composition principle that calles methods on an instance variable of an object','class Animal implements Burriable {\n    private Integer size;\n    private String name;\n    \n    public Animal(int x, String y){\n        size = x;\n        name = y;\n    }\n    public Animal(){\n        size = 0;\n        name = \"\";\n    }\n\n    public int getSize() {\n        return size;\n    }\n\n    public String getName() {\n        return name;\n    }\n    \n    public void bury(){\n        System.out.println(\"just toss him in there...\");\n    }\n    public void digUp(){\n        System.out.println(\"Hang on this ones still kickin !\");\n    }\n    public void pray(){\n        System.out.println(\"...Lord forgive us for what we have done, hes only been gone for \"+YEARSDEAD+\" years.\");\n    }\n}\n\nclass Dog implements Burriable{\n    private Animal animal;\n    public Dog(Animal a){\n        animal = a;\n    }\n    \n    public void bury(){\n        animal.bury();\n    }\n    public void digUp(){\n        animal.digUp();\n    }\n    public void pray(){\n        animal.pray();\n    }\n    \n    public String yelpForHelp(){\n        return \"ar ar arrr....\";\n    }\n}\n\ninterface Burriable {\n    int YEARSDEAD = 1;\n    void bury();\n    void digUp();\n    void pray();\n}\n\nwhat OOP principle is this ?','OOP',0,0,NULL,5),(1464,'The singleton pattern is identifiable bby the static variable for the single instance and the accessor returning it. ','public class F {\n	private static final F f = new F();\n	public static F c(){\n		return f;\n	}\n\n	public void update(F a) { }\n	\n	public void delete(F a) { }\n\n}\nwhat design pattern is this ? ','OOP',0,0,NULL,5),(1465,'object composition, you can tell because of the method forwarding. \nSingleton is tempting but the getInstance method here returns a NEW instance\ninstead a single private static one like it should to be singleton. ','public class E {\n	private D d;\n	public void m() {\n		d.m();\n	}\n\n		public static E getInstance() {\n			return new E();\n		}\n}\n\nclass D {\n	public void m() { }\n}\n\nwhat design pattern principle is this ?\n','OOP',0,0,NULL,5),(1466,'Factory,\n\nClass A is the object we are creating using the factory method. class G\nis the abstract superclass for the factory. Not shown is a class implementing \nclass G that actually creates the object. ','class A {}\n\nabstract class G {\n	A m() { return n(); }\n	abstract A n();\n}\n\nwhat principle is demostrated','OOP',0,0,NULL,5),(1467,'Reuse The DAO pattern centralize logic for the data access code making reuse\neasier and allowing you to switch out implementations. ','which is a benefit of the DAO pattern ?	','OOP',0,0,NULL,5),(1468,'regular files, hidden files, and subdirectories','public void print(Path d) throws IOException {\n	try(DirectoryStream<Path> stream = Files.newDirectoryStream(d)){\n		for(Path path: stream){\n			sout( path.getFileName() );\n		}\n	}\n}\n\nwhat files will this display ? ','IO',0,0,NULL,5),(1469,'The first time the file will be created and copied normally the second time you\nwill get a file already exists excpeiotn','public class Hello {\n    public static void main(String[] dicks) throws IOException{\n      Path src = Paths.get(\"/home/maxbisesi/Documents/copy.txt\");\n      Files.createFile(src);\n      \n      Files.copy(src, Paths.get(\"/home/maxbisesi/Documents/newcopy.txt\"));\n      \n    }\n\n}\n\nwhat happens if this is ran twice and all preivous files dont exist before','IO',0,0,NULL,5),(1470,'Compilation fails, to compile would have to be \n\n	Object item = list.get(0);','public class Hello {\n    public static void main(String[] dicks){\n        ArrayList list = new ArrayList();\n        \n        list.add(\"java\");\n        list.add(\"sucks\");\n        \n        String item = list.get(0);\n\n    }\n\n}','Collections',0,0,NULL,5),(1471,'Will not compile, there is no scope there \n\nif(true){\n	int b = 1;\n} \n	this would though !','if(true)\n       int b = 1;\n        ','General',0,0,NULL,5),(1472,'CooLooLCuuL\n\n* is the greedy quantifier, it takes as much as it can. ','public class Hello {\n    public static void main(String[] dicks){\n        Pattern p = Pattern.compile(\"C.*L\");\n        Matcher m = p.matcher(\"CooLooLCuuLooC\");\n        \n        while(m.find())\n            System.out.println(m.group());\n\n    }\n\n}','Strings',0,0,NULL,5),(1473,'False it gets the same priority as the thread that created it ','If a thread\'s priority is not specified explicitly then it gets\nNORM_PRIORITY\n\nT or F ','Threads',0,0,NULL,5),(1474,'Will not compile, method eat in class animal cannot be applied to given types','public class Hello {\n    public static void main(String[] dicks){\n        Animal ah2 = new Horse();\n        ah2.eat(\"carrots\");\n    }\n\n}\n\nclass Animal{\n    public void eat(){ }\n}\n\nclass Horse extends Animal {\n    public void eat() { }\n    public void eat(String s ){ } \n}\n    ','General',0,0,NULL,5),(1475,'Horse','public class Hello {\n    public static void main(String[] dicks){\n        Animal ah2 = new Horse();\n        ah2.eat();\n    }\n\n}\n\nclass Animal{\n    public void eat(){ System.out.println(\"Animal\"); }\n}\n\nclass Horse extends Animal {\n    public void eat(){ System.out.println(\"Horse\");} \n}\n\n','General',0,0,NULL,5),(1476,'will not compile overriden method \ncannot throw new or broader checked exceptions','public class Hello {\n    public static void main(String[] dicks){\n        Animal ah2 = new Horse();\n        ah2.eat();\n    }\n\n}\n\nclass Animal{\n    public void eat(){ System.out.println(\"Animal\"); }\n}\n\nclass Horse extends Animal {\n    public void eat() throws IOException{ System.out.println(\"Horse\");} \n}','General',0,0,NULL,5),(1477,'Animal\n\neat in horse is an overload, it still inherits Animals eat()','public class Hello {\n    public static void main(String[] dicks){\n        Animal ah2 = new Horse();\n        ah2.eat();\n    }\n\n}\n\nclass Animal{\n    public void eat(){ System.out.println(\"Animal\"); }\n}\n\nclass Horse extends Animal {\n    public void eat(int x) throws IOException{ System.out.println(\"Horse\");} \n}','General',0,0,NULL,5),(1478,'SQLException\n	Statement objects do not support multiple open ResultSets.\n	\n	Only a single ResultSet can be opened from the same statement object\n\n	*if the same statement object is executed more than once the previous\n	ResultSet is closed automatically\n		\n		... and attempting to access a closed RS is a SQLException','//assume valid Connection cn, and good database connection\n\nString query = \"Select * from Answer\";\ntry(Statement stmt = cn.createStatement()){\n	ResultSet rs1 = stmt.executeQuery(query);\n	stmt.executeQuery(\"select * from Question\");\n	while(rs1.next(){\n		sout(rs1.getInt(\"fk_question_num\");\n	}\n} catch(SQLException e){\n	\n}','JDBC',0,0,NULL,5),(1479,'','','blank',0,0,NULL,5),(1480,'SQLException , attempting to execute a query without setting a parameter\nresults in an SQLException\n\n	should be>>>\n		\n		pstmt.setString(1,\"dick\");\n\nIndexing starts at 1','try(Connection conn = DriverManager.getConnection(url,user,pw)){\n	String pQuery = \"Select unitPrice From Book Where Title Like ?\";\n\n	PreparedStatement pstmt = conn.prepareStatement(pQuery);\n\n	ResultSet rs = pstmt.executeQuery();\n} catch(SQLException sq) {\n}\n','JDBC',0,0,NULL,5),(1481,'compiles and runs just fine ','public class Hello {\n    public static void main(String[] dicks){\n        try{\n            couldthrow();\n        } catch(IOException | SQLException e){\n            \n        }\n        \n    }\n    \n    public static void couldthrow() throws IOException, SQLException{\n        \n    }\n\n}','Exceptions',0,0,NULL,5),(1482,'instanceof test','public boolean equals(Object o) { \n	if(((Moof)o).getMoofValue() == this.moofValue {\n		return true;\n	} else {\n		return false;\n	}\n}\n\nwhats missing here','Collections',0,0,NULL,5),(1483,'got it','equals() hashCode() and toString() are all PUBLIC','Collections',0,0,NULL,5),(1484,'for any reference value x, x.equals(x) should be true. ','equals() Contract\n\nreflexive	','Collections',0,0,NULL,5),(1485,'for any reference values x and y, \n\nx.equals(y) shoud be true if and only if \ny.equals(x) returns true. ','equals() contract,\n\nsymmetric','Collections',0,0,NULL,5),(1486,'reflxive, x.equals(x) is always true\n\nsymetric, x.equals(y) and y.equals(x)\n\ntransitive, if x.equals(y) and y.equals(z) then x.equals(z)\n\nconsistent, x.equals(y) is true no matter how many times you call it\n\nif x is non null, x.equals(null) is always false','what are the four tenants of the equals contract ?','Collections',0,0,NULL,5),(1487,'MUST also be equal.','if two objects are considered equal, their hashcodes...','Collections',0,0,NULL,5),(1488,'Yes just inefficient, all objects will go in the same bucket. The Collection\nwill search through a single big bucket using equal() to find the instance\nits looking for. In that case you defeat the purpose of using a hashed collection. ','Is it still legal to have a hashcode that always returns the same number ?','Collections',0,0,NULL,5),(1489,'When it is invoked on the same object more than once during an execution\nof a java application the hashcode() method must consistently return the \nsame integer \n\nIf two objects are equal according to the equals method, then calling hashchode)( \non each of the objects must produce the same integer\n\nunequal objects can still produce the same hashcodes \n\n*That means that equals and hashCode must work with same attributes somehow','HashCode contract:\n\n1\n\n2\n\n\n3','Collections',0,0,NULL,5),(1490,'x.hashcode() == y.hashcode()','x.equals(y) == true\n\nmeans what for hashcode()...','Collections',0,0,NULL,5),(1491,'x.equals(y) == false\n\nequals() and hashcode are like directions to get to a specific \nelement\n\nhashCode places all the elements in seperate but similiar buckets \nequals() gets the correct ones out.\n\nso if two elemets have different hashCodes they will be in different buckets\nanyway so hashCode is one level of precision and equals() is the next.','x.hashCode() != y.hashCode()	\n\nmeans what for equals()','Collections',0,0,NULL,5),(1492,'../..\nGenDir/genFile.txt\n','public static void main(String[] args){\n        Path p = Paths.get(\"/home/maxbisesi/Public/GenDir/genFile.txt\");\n        Path p2 = Paths.get(\"/home/maxbisesi/Public\");\n        \n        System.out.println(p.relativize(p2));\n        System.out.println(p2.relativize(p));  \n}','IO',0,0,NULL,5),(1493,'a Vector is the same as an ArrayList but Vector methods are synchronized\nfor thread safety. \n\nVector and Hashtable are the two original collections\n\nunless you really need thread safety choose ArrayList over Vector, \nthe synchronized methods give an unecssary performance hit. \n\n','Collections:\n\n	Vector\n','Collections',0,0,NULL,5),(1494,'is ordered by index position except that the elements are doubly linked to \none another. This linkage gives you new methods for adding and removing\nfrom the beginning or end.\n\nEasy choice for implementing a stack or queue. \n\nmay iterate more slowly than ArrayList but still a good choice when you need\nfast insertion and deletion.\n\nLinkedList supports peek(), poll(), offer(), Queue methods!!','Collections:\n\n	LinkedList','Collections',0,0,NULL,5),(1495,'Set','Which Interface disallows duplicates','Collections',0,0,NULL,5),(1496,'unsorted and unordered. Uses the hashcode of the object being inserted\n\nso the more effeicinet your hashcode the more effecient access youll get\n\nUse for a collection with no duplicates where you dont care about the\norder when you iterate through it.','Collections:\n	\n	HashSet','Collections',0,0,NULL,5),(1497,'\nMaintains a doubly linked list across elelemnts so the insertion order \nis maintained\n\nduplicates are still disallowed. ','Collections:\n\n	LinkedHashSet','Collections',0,0,NULL,5),(1498,'Sorted\n\nguarentees elements will be in ascending order according to natural order\n\n','Collections:\n\n	TreeSet','Collections',0,0,NULL,5),(1499,'compilation fails at the last three lines,\n\n1. multi catch syntax is | not ||\n\n2. objects declared in a try block are only available within the \ntry block so closing r is out of scope','public class Reader {\n	public void read(Path p, Charset s) {\n		try(BufferedReader r = Files.newBufferedReader(p,s)) {\n			try { r.read(); }\n			catch(IOException f) {\n				r.readLine();\n			}\n		} catch(IOException || NullPointerException e) {\n			r.close();\n		} finally {\n			r.close();\n		}\n	}\n}','IO',0,0,NULL,5),(1500,'unsorted and unordered Map. \n\nUse When you need a map and you don\'t care\nabout the order when you iterate through. \n\nThe basic map, other maps add a little more overhead. \n\nWhere keys land in the map is based on hashCode() \n\nHashMap allows one null key and multiple null values ','Collections:\n\n	HashMap','blank',0,0,NULL,5),(1501,'Hashtable is the synchronized counterpart to HashMap. \n\nWhile HashMap lets you have a null key and null values\n\nHashtable doesn\'t allow anything thats null!','Collections:\n	\n	Hashtable\n	','Collections',0,0,NULL,5),(1502,'True!\n\nHashtable doesn\'t allow anything null it will throw a npe','HashMap allows multiple null values','Collections',0,0,NULL,5),(1503,'FALSE\n\nThat would defeat the purpose of a \"key\"','HashMap allows multiple null keys','Collections',0,0,NULL,5),(1504,'FALSE\n\nunordered and unsorted','HashMap is sorted','Collections',0,0,NULL,5),(1505,'FALSE','HashMap is synchronized','Collections',0,0,NULL,5),(1506,'True!','Hashtable is synchronized ','Collections',0,0,NULL,5),(1507,'FALSE, nothing can be null in Hashtable','Hashtable allows multiple null values and one null key','blank',0,0,NULL,5),(1508,'since list is declared as anything that extends Animal you cant be sure that it\nwill be the right type to pass into the next method that taks <Animal>\n\nWill not compile','public static ArrayList<Animal> staggerSort(ArrayList<? extends Animal> list){\n        Map<String,List<Number>> byCategory = seperateToCategories(list);\n        return null;\n    }\n    \n    static Map<String,List<Number>> seperateToCategories(ArrayList<Animal> list){\n        return null;\n    }','Generics',0,0,NULL,5),(1509,'big Bucks\nsweet Cheeks\n\nbig Bucks replaced big Country in the map, LinkedHashMaps maintain insertion\norder. \n\nso that mapping was simply replaced but it kept its position','public static void main(String[] args){\n        LinkedHashMap<String,String> lhm = new LinkedHashMap<>();\n        lhm.put(\"big\",\"Country\");\n        lhm.put(\"sweet\",\"Cheeks\");\n        lhm.put(\"big\",\"Bucks\");\n        \n        for(Map.Entry<String,String> entry: lhm.entrySet()){\n            System.out.println(entry.getKey()+\" \"+entry.getValue());\n        }\n        \n    }','Collections',0,0,NULL,5),(1510,'WNC,\n\ngo() declares that it throws a checked exceptions so it has to be handled\nor thrown in main.\n\nif that would have compiled an IOException would be thrown so it would\nprint got io error done. ','class Gutsy {\n	public static void main(String[] args){\n		new Gutsy().go();\n	}\n	void go() throws IOException {\n	String row;\n	try {\n		FileReader fr = new FileReader(\"TestFile.txt\");\n		BufferedReader br = new BufferedReader(fr);\n		while((row = br.readLine() ) != null)\n			sout( row );\n	} catch(IOException e) {\n		sout(\"got io error\");\n	} finally {\n		sout( \"done\" );\n	}\n   }\n}','Exceptions',0,0,NULL,5),(1511,'-6 through 4','Given a properly prepared string[] with five elements what is the range \nof possible results that could be returned by Arrays.binarySearch() ? ','Collections',0,0,NULL,5),(1512,'sorted Map\n\nsorted by natural order or custom comparison rules.','TreeMap','blank',0,0,NULL,5),(1513,'3\nfalse\ntrue\n2','List<String> test = new ArrrayList<String>();\nString s = \"hi\";\ntest.add(\"string\");\ntest.add(s);\ntest.add(s+s);\nsout( test.size() );\nsout( test.contains(42) );\nsout( test.contains(\"hihi\") );\ntest.remove(\"hi\");\nsout( test.size() );','Collections',0,0,NULL,5),(1514,'These two are the same, the first demonstrates autoboxing. ','List myInts = new ArrayList();\n        myInts.add(4);\n        \n        myInts.add(new Integer(4));','blank',0,0,NULL,5),(1515,'NullPointerException','class Boxing2 {\n	static Integer x;\n	psvm(sa) {\n		doStuff(x);\n	}\n\n	static void doStuff(int z) {\n		int z2 = 5;\n		sout( z2 + z );\n	}\n}','General',0,0,NULL,5),(1516,'unsorted: [CZ, a, AB, CE, CZ, cz, BA, BF, ABC, CE,  CE, A, ce, A B, AA,  Z]\nsorted: [ CE,  Z, A, A B, AA, AB, ABC, BA, BF, CE, CE, CZ, CZ, a, ce, cz]\n\nspaces come first, as shown by A B and AA. Also capitals come before lowercase','public static void main(String[] dicks){\n        ArrayList<String> list = new ArrayList<>();\n        \n        list.add(\"CZ\");\n        list.add(\"a\");\n        list.add(\"AB\");\n        list.add(\"CE\");\n        list.add(\"CZ\");\n        list.add(\"cz\");\n        list.add(\"BA\");\n        list.add(\"BF\");\n        list.add(\"ABC\");\n        list.add(\"CE\");\n        list.add(\" CE\");\n        list.add(\"A\");\n        list.add(\"ce\");\n        list.add(\"A B\");\n        list.add(\"AA\");\n        list.add(\" Z\");\n        \n        System.out.println(\"unsorted: \"+list);\n        Collections.sort(list);\n        System.out.println(\"sorted: \"+list);','Collections',0,0,NULL,5),(1517,'Will not compile, Horse does not implement Comparable','public class Hello {\n    public static void main(String[] dicks){\n        List<Horse> stable = new ArrayList<>();\n        \n        for(int x =0; x < 10; x++){\n            stable.add(new Horse());\n        }\n        \n        Collections.sort(stable);\n        \n    }\n\n}\n\nclass Horse {\n    public boolean equals(Horse s){\n        return false;\n    }\n}','Collections',0,0,NULL,5),(1518,'will not compile, compareTo is public ','class Horse implements Comparable<Horse> {\n    public boolean equals(Horse s){\n        return false;\n    }\n    \n    int compareTo(Horse h){\n        \n    }\n    \n    \n}','Collections',0,0,NULL,5),(1519,'compiles fine!','public class Hello {\n    public static void main(String[] dicks){\n        List<Horse> stable = new ArrayList<>();\n        \n        for(int x =0; x < 10; x++){\n            stable.add(new Horse(\"lucky\"+x));\n        }\n        \n        Collections.sort(stable);\n        \n    }\n\n}\n\nclass Horse implements Comparable<Horse> {\n    String name;\n    \n    public Horse(String x){\n        name = x;\n    }\n    \n    public String getName(){\n        return name;\n    }\n    \n    public boolean equals(Horse s){\n        return false;\n    }\n    \n    public int compareTo(Horse h){\n        return name.compareTo(h.getName());\n        \n    }\n    \n    \n}','Collections',0,0,NULL,5),(1520,'Object','When you override equals() you must take an argument of what type ?','Collections',0,0,NULL,5),(1521,'The type your sorting.\n\n\npublic interface Comparable<T>\n\n...type T','When you override compareTo() you must take an argument of type?','Collections',0,0,NULL,5),(1522,'This is still legal but painful, genereics make this easier but it will still \ncompile','class DVDInfo implements Comparable {\n	public int comparteTo(Object o) {\n		DVDInfo d = (DVDInfo) o;\n		return title.compareTo(d.getTitle() );\n	}\n}','Collections',0,0,NULL,5),(1523,'compare()\n\ncompareTo()','Comparator has _________________\n\nComparable has _________________','Collections',0,0,NULL,5),(1524,'Comparator','Which soritng interface do you implement to create individual sorting classes\n	','Collections',0,0,NULL,5),(1525,'will not compile the method is:\n\n	int compare(T o1, T o2)','class Dicksorter implements Comparator<Dicks> {\n	public int compareTo(Dick one) {\n	}\n}','Collections',0,0,NULL,5),(1526,'compiles fine, this takes advvantage of integer comparison','class DickSorter implements Comparator<Dick> {\n	public int compare(Dick one, Dick two){\n		return one.getSize().compareTo(two.getSize());\n	}\n}','Collections',0,0,NULL,5),(1527,'Will not compile\n\ntoArray() in List interface returns an Object[]','public class Hello {\n    public static void main(String[] dicks){\n        List<Horse> stable = new ArrayList<>();\n        \n        stable.add(new Horse(\"Honey\"));\n        stable.add(new Horse(\"Mighty Mikey\"));\n        stable.add( new Horse(\"The Fastest Stud in the Mud\"));\n        stable.add( new Horse(\"Churchill\"));\n        \n        Horse[] ranch = stable.toArray();\n\n    }\n\n}','Collections',0,0,NULL,5),(1528,'ClassCastException, \"johny\" cant be turned into a horse\n\nshould be Arrays.binarySearch(stable,new Horse(\"Johny\"));','public class Hello {\n    public static void main(String[] dicks){\n        Horse[] stable = {new Horse(\"Johny\"), new Horse(\"wilfred\"), new Horse(\"Marco\"), new Horse(\"MAx\"), new Horse(\"Billy\") };\n        \n        int x = Arrays.binarySearch(stable,\"Johny\");\n        System.out.println(x);  \n\n    }\n\n}','Collections',0,0,NULL,5),(1529,'The results are undefined, the array is not sorted. ','public class Hello {\n    public static void main(String[] dicks){\n        Horse[] stable = {new Horse(\"Johny\"), new Horse(\"wilfred\"), new Horse(\"Marco\"), new Horse(\"MAx\"), new Horse(\"Billy\") };\n        \n        int x = Arrays.binarySearch(stable,new Horse(\"Johny\"));\n        System.out.println(x);  \n\n    }\n\n}    \n\nclass Horse implements Comparable<Horse> {\n    String name;\n    \n    public Horse(String x){\n        name = x;\n    }\n    \n    public String getName(){\n        return name;\n    }\n    \n    public boolean equals(Horse s){\n        return false;\n    }\n    \n    public int compareTo(Horse h){\n        return name.compareTo(h.getName());\n        \n    }\n    \n    \n    ','Collections',0,0,NULL,5),(1530,'ClassCastException Horse cannot be converted to Comparable\n\nbinarySearch uses comparable to search the Array.\n\nThis search would give inconsistant results anyways because \nthe array was not sorted first. \n\nto fix add this:\n\nclass Horse implements Comparable<Horse> {\n    String name;\n    \n    public Horse(String x){\n        name = x;\n    }\n    \n    public String getName(){\n        return name;\n    }\n    \n    public boolean equals(Horse s){\n        return false;\n    }\n    \n    public int compareTo(Horse s){\n        return name.compareTo(s.getName());\n    }\n    \n}\n\n-if an array is sorted in natrual order it must searched in natural order \n-if it is sorted using a comparator it must be searched using the same comparator.\n','public class Hello {\n    public static void main(String[] dicks){\n        Horse[] stable = {new Horse(\"Johny\"), new Horse(\"wilfred\"), new Horse(\"Marco\"), new Horse(\"MAx\"), new Horse(\"Billy\") };\n        \n        \n        int x = Arrays.binarySearch(stable,new Horse(\"Marco\"));\n        System.out.println(x);  \n\n    }\n\n}\n\nclass Horse {\n    String name;\n    \n    public Horse(String x){\n        name = x;\n    }\n    \n    public String getName(){\n        return name;\n    }\n    \n    public boolean equals(Horse s){\n        return false;\n    }\n    \n}','Collections',0,0,NULL,5),(1531,'Will not compile, if the untyped version of Comparable is used then\nthe parameter to compareTo would be Object\n\neither change to Comparable<Horse>\n\nor \n\ncomparTo(Object o) and cast.\n\notherwise, the answer would be 2 remember arrays aren\'t sorted even though\nyour using comparable the elements of an array dont get sorted so the positions are \nwhat index they were defined as !\n\nThis would give undefined results','public class Hello {\n    public static void main(String[] dicks){\n        Horse[] stable = {new Horse(\"Johny\"), new Horse(\"wilfred\"), new Horse(\"Marco\"), new Horse(\"MAx\"), new Horse(\"Billy\") };\n        int x = Arrays.binarySearch(stable,new Horse(\"Marco\"));\n        System.out.println(x);  \n    }\n}\n\nclass Horse implements Comparable{\n    String name;\n    public Horse(String x){\n        name = x;\n    }\n    public String getName(){\n        return name;\n    }\n    public boolean equals(Horse s){\n        return false;\n    }\n    public int compareTo(Horse h){\n        return name.compareTo(h.getName());  \n    }\n}\n','Collections',0,0,NULL,5),(1532,'binarySearch()\n\nreturns the int index of the element being searched.\n\nUnsuccesful searches return an int index that represents the\n insertion point. \n\nThe collection or array must be sorted before you can search it.\n\nif you attempt to search an unsorted array or collection the results of the\nsearch will be unpredictable.\n\nIf it was sorted in natural order it must searched in natural order.\n	do this by NOT sending a Comparator as an argument to the binarySearch() \n\nIf it was sorted with a comparator it must be searched using the same comparator\n\n	\n	','What method is used to search through Arrays and Collections','Collections',0,0,NULL,5),(1533,'will not compile, need to cast\n\nreturn name.compareTo(((Horse)h).getName());\n\ndoes not compile because h is an Object and Objects dont have a method\ncalled getName. \n\nyou would cast h to a horse. \n\nObject is the right argument type here though because Comparable is a raw type\nif it were Comparable<Horse> the argument would need to be Horse.','class Horse implements Comparable{\n    String name;\n    \n    public Horse(String x){\n        name = x;\n    }\n    \n    public String getName(){\n        return name;\n    }\n    \n    public boolean equals(Horse s){\n        return false;\n    }\n    \n    public int compareTo(Object h){\n        return name.compareTo(h.getName());\n  \n    }','Collections',0,0,NULL,5),(1534,'these all compile fine, \n\nPolymorphism works with Arrays. ','public class Hello {\n    public static void main(String[] dicks){\n       Animal[] beavers = new Beaver[5];\n       \n       Animal[] animals = {new Beaver(), new Beaver(), new Beaver() };\n       \n       Animal[] ans2 = new Animal[5];\n       ans2[0] = new Beaver();\n\n    }\n}\n\nclass Animal{\n    public Animal(){\n        \n    }\n    \n    public String getName(){\n        return \"d\";\n    }\n}\n\nclass Beaver extends Animal{\n    \n}','Collections',0,0,NULL,5),(1535,'2\n0','public class Hello {\n    public static void main(String[] dicks){\n       \n        String[] strings = {\"One\",\"Dice\",\"Angela\",\"Bisesi\",\"Franko\"};\n        \n        Arrays.sort(strings);\n        int x = Arrays.binarySearch(strings,\"Dice\");\n        System.out.println(x);  \n        \n        Arrays.sort(strings);\n        \n        System.out.println(Arrays.binarySearch(strings,\"Angela\"));\n    }\n\n}','Collections',0,0,NULL,5),(1536,'compare must be public, will not compile','class sortBySecondLetter implements Comparator<String> {\n    int compare(String one, String two){\n        \n    }\n}','Collections',0,0,NULL,5),(1537,'will not compile, char is a primitive so charone cannot be dereferenced here\nchange to Character.','class sortBySecondLetter implements Comparator<String> {\n    public int compare(String one, String two){\n        char charone = one.charAt(1);\n        char chartwo = two.charAt(1);\n        \n        return charone.compareTo(chartwo);\n    }\n}','Collections',0,0,NULL,5),(1538,'[Ljava.lang.String;@15db9742\n\narrays are not classes','public class Hello {\n    public static void main(String[] dicks){\n        sortBySecondLetter sbsl = new sortBySecondLetter();\n        String[] strings = {\"One\",\"Dice\",\"Angela\",\"Bisesi\",\"Franko\"};\n        \n        Arrays.sort(strings,sbsl);\n        \n        System.out.println(strings);\n    }\n\n}','Collections',0,0,NULL,5),(1539,'size 4\nidx2 three\none \nfive \nthree \nsix \ns1[1] five','String[] sa = {\"one\", \"two\", \"three\", \"four\" };\nList sList = Arrays.asList(sa);\n\nSout( \"size \" + sList.size() );\nsout( \"idx2 \" + sList.get(2) );\n\nsList.set(3,\"six\" );\nsa[1] = \"five\";\n\nfor(String s : sa ){\n	sout( s + \" \");\n}\nsout(\"\\n s1[1] \" + sList.get(1) );','Collections',0,0,NULL,5),(1540,'UnsupportedOperationException\n\nThis UnsupportedOperationException comes when you try to perform some operation on collection where its not \nallowed and in your case, When you call Arrays.asList it \ndoes not return a java.util.ArrayList. It returns a java.util.Arrays$ArrayList which is an immutable list. \nYou cannot add to it and you cannot remove from it.\n\nReturns a {@code List} of the objects in the specified array. The size of the {@code List} cannot be modified, i.e. adding and removing are unsupported, but the elements can be set. Setting an element modifies the underlying array.\n\nEDIT\n\nThe type of the resulting list is Arrays.ArrayList, which is a private class inside Arrays.class. Practically speaking,\nit is nothing but a List-view on the array that you\'ve passed with Arrays.asList. With a consequence: if you change the array, the list is changed too. And because an array is not resizeable, \nremove and add operation must be unsupported.\n','public class Hello {\n    public static void main(String[] args){\n        String[] sa = {\"one\", \"two\", \"three\", \"four\" };\n        List sList = Arrays.asList(sa);\n\n        System.out.println( \"size \" + sList.size() );\n        System.out.println( \"idx2 \" + sList.get(2) );\n\n        sList.set(3,\"six\" );\n        sa[1] = \"five\";\n\n        for(String s : sa ){\n            System.out.println( s + \" \");\n        }\n        System.out.println(\"s1[1] \" + sList.get(1) );\n        \n        sList.remove(\"five\");\n        for(String s : sa)\n            System.out.println(s+\" \");\n    }\n\n}','Collections',0,0,NULL,5),(1541,'size 4\nidx2 three\none \nfive \nthree \nsix \ns1[1] five\none \nFIVE \nthree \nSIX\n\nThis shows that Arrays and Lists coming from\nArrays.asList() are \"joined at the hip\" changes in one affect \nthe other. This is different from a \"Backed Collection\". Because \nBacked Collections dont go both ways and are only backed for a certain range.','String[] sa = {\"one\", \"two\", \"three\", \"four\" };\n        List sList = Arrays.asList(sa);\n\n        System.out.println( \"size \" + sList.size() );\n        System.out.println( \"idx2 \" + sList.get(2) );\n\n        sList.set(3,\"six\" );\n        sa[1] = \"five\";\n\n        for(String s : sa ){\n            System.out.println( s + \" \");\n        }\n        System.out.println(\"s1[1] \" + sList.get(1) );\n        \n        sList.set(1, \"FIVE\");\n	sList.set(3,\"SIX);\n        for(String s : sa)\n            System.out.println(s+\" \");','Collections',0,0,NULL,5),(1542,'unsupported operation exception, \n\nList returned by asList is fixed size can only be updated not added to or removed from','public static void main(String[] dicks){\n        String[] sa = {\"one\", \"two\", \"three\", \"four\" };\n        List sList = Arrays.asList(sa);\n\n        System.out.println( \"size \" + sList.size() );\n        System.out.println( \"idx2 \" + sList.get(2) );\n\n        sList.set(3,\"six\" );\n        sa[1] = \"five\";\n\n        for(String s : sa ){\n            System.out.println( s + \" \");\n        }\n        System.out.println(\"s1[1] \" + sList.get(1) );\n        \n        sList.set(1, \"FIVE\");\n        sList.set(3,\"SIX\");\n        sList.add(\"SEVEN\");\n        for(String s : sa)\n            System.out.println(s+\" \");','Collections',0,0,NULL,5),(1543,'will not compile, toArray( T[] a) will return an array of the type you send\nto it. so here an Object[] cannot be assigned to an Integer[].\n\nto fix:\n	change oa to ia2 which will cause toArray to return an Integer[]',' public static void main(String[] dicks){\n        List<Integer> iL = new ArrayList<Integer>();\n        for(int x=0; x<3; x++){\n                iL.add(x);\n        }\n        Object[] oa = iL.toArray();\n        Integer[] ia2 = new Integer[3];\n        ia2 = iL.toArray(oa);\n    }','Collections',0,0,NULL,5),(1544,'0\n1\n2\n3\n4\n','public static void main(String[] dicks){\n        List<Integer> iL = new ArrayList<Integer>();\n        for(int x=0; x<5; x++){\n                iL.add(x);\n        }\n        Object[] oa = iL.toArray();\n        Integer[] ia2 = new Integer[3];\n        ia2 = iL.toArray(ia2);\n        \n        for(Integer i : ia2){\n            System.out.println(i);\n        }     \n    }','Collections',0,0,NULL,5),(1545,'0\n1\n2\n3\n4\n0\n1\n2\n3\n4','public static void main(String[] dicks){\n        List<Integer> iL = new ArrayList<Integer>();\n        for(int x=0; x<5; x++){\n                iL.add(x);\n        }\n        Object[] oa = iL.toArray();\n        Integer[] ia2 = new Integer[3];\n        ia2 = iL.toArray(ia2);\n        \n        for(Integer i : ia2){\n            System.out.println(i);\n        }\n        \n        iL.add(100);\n        \n        for(Integer i : ia2)\n            System.out.println(i);\n       \n    }','Collections',0,0,NULL,5),(1546,'will not compile, \n\n.toArray() returns an Object[]',' public static void main(String[] dicks){\n        List<Integer> iL = new ArrayList<Integer>();\n        for(int x=0; x<5; x++){\n                iL.add(x);\n        }\n        Integer[] oa = iL.toArray();     \n    }','Collections',0,0,NULL,5),(1547,'unpredictable result, the array is not sorted before being searched. ','class HDTV implements Comparable<HDTV> {\n	private int size;\n	private String brand;\n        private int resolution;\n \n	public HDTV(int size, String brand, int res) {\n		this.size = size;\n		this.brand = brand;\n                this.resolution = res;\n	}\n \n	public int getSize() {\n		return size;\n	}\n        \n        public int getRes() {\n            return resolution;\n        }\n \n	public void setSize(int size) {\n		this.size = size;\n	}\n \n	public String getBrand() {\n		return brand;\n	}\n \n	public void setBrand(String brand) {\n		this.brand = brand;\n	}\n \n	@Override\n	public int compareTo(HDTV tv) {\n \n		if (this.getSize() > tv.getSize())\n			return 1;\n		else if (this.getSize() < tv.getSize())\n			return -1;\n		else\n			return 0;\n	}\n        \n        public String toString(){\n            return brand;\n        }\n}\n\npublic class Hello {\n    public static void main(String[] dicks){\n        compareTVs();\n    }\n    \n     \n    public static void compareTVs() {\n		HDTV tv1 = new HDTV(55, \"Samsung\", 6000);\n		HDTV tv2 = new HDTV(60, \"Sony\", 4500);\n                HDTV tv3 = new HDTV(70, \"MEGATV\", 10000);\n                HDTV tv4 = new HDTV(15,\"kitchenette\", 600);\n\n                HDTV[] array = {tv2, tv1, tv3, tv4 };\n                \n                System.out.println(Arrays.binarySearch(array,new HDTV(700,\"Samsung\",400)));\n                \n	}\n\n}','Collections',0,0,NULL,5),(1548,'will not compile \n\nArrayList.addAll doesn\'t work like that, it takes another collection\nthen adds all the elements from one to another. ','public static void main(String[] dicks){\n        List<HDTV> tvs = new ArrayList<>();\n        HDTV tv1 = new HDTV(55, \"Samsung\", 6000);\n        HDTV tv2 = new HDTV(60, \"Sony\", 4500);\n        HDTV tv3 = new HDTV(70, \"MEGATV\", 10000);\n        HDTV tv4 = new HDTV(15,\"kitchenette\", 600);\n        tvs.addAll(tv1,tv2,tv3,tv4);\n    }','Collections',0,0,NULL,5),(1549,'Samsung\nSony\nMEGATV\nkitchenette\n\nthis shows proper use of an iterator','public static void main(String[] dicks){\n        List<HDTV> tvs = new ArrayList<>();\n        \n        HDTV tv1 = new HDTV(55, \"Samsung\", 6000);\n        HDTV tv2 = new HDTV(60, \"Sony\", 4500);\n        HDTV tv3 = new HDTV(70, \"MEGATV\", 10000);\n        HDTV tv4 = new HDTV(15,\"kitchenette\", 600);\n        \n        tvs.add(tv1);\n        tvs.add(tv2);\n        tvs.add(tv3);\n        tvs.add(tv4);\n        \n        Iterator<HDTV> i3 = tvs.iterator();\n        \n        while(i3.hasNext()){\n            HDTV t3 = i3.next();\n            System.out.println(t3.getBrand());\n        }\n        \n        \n    }','Collections',0,0,NULL,5),(1550,'If the iterator isn\'t typed then the elements returned by Iterator will be \nObjects so to make this compile, \n\nyou would have to cast\n\n	(HDTV) i3.next();','public static void main(String[] dicks){\n        List<HDTV> tvs = new ArrayList<>();\n        \n        HDTV tv1 = new HDTV(55, \"Samsung\", 6000);\n        HDTV tv2 = new HDTV(60, \"Sony\", 4500);\n        HDTV tv3 = new HDTV(70, \"MEGATV\", 10000);\n        HDTV tv4 = new HDTV(15,\"kitchenette\", 600);\n        \n        tvs.add(tv1);\n        tvs.add(tv2);\n        tvs.add(tv3);\n        tvs.add(tv4);\n        \n        Iterator i3 = tvs.iterator();\n        \n        while(i3.hasNext()){\n            HDTV t3 = i3.next();\n            System.out.println(t3.getBrand());\n        }\n        \n        \n    }','Collections',0,0,NULL,5),(1551,'none fail both of those are fine. ','  public static void main(String[] dicks){\n        List<HDTV> tvs = new ArrayList<>();\n        \n        HDTV tv1 = new HDTV(55, \"Samsung\", 6000);\n        HDTV tv2 = new HDTV(60, \"Sony\", 4500);\n        HDTV tv3 = new HDTV(70, \"MEGATV\", 10000);\n        HDTV tv4 = new HDTV(15,\"kitchenette\", 600);\n        \n        tvs.add(tv1);\n        tvs.add(tv2);\n        tvs.add(tv3);\n        tvs.add(tv4);\n        \n        HDTV[] tv = new HDTV[5];\n        HDTV[] hv = tvs.toArray(tv); //line 1\n        Object[] tvobjs = tvs.toArray(); //line 2\n        \n   \n    }\n\nwhich line would fail if any ?','Collections',0,0,NULL,5),(1552,'true\ntrue\ntrue\ntrue\nfalse\n4\n5\n7\n9\n\nSets dont allow duplicates and the iteration order is not predictable','public static void main(String[] dicks){\n      Set s = new HashSet();\n      \n        System.out.println(s.add(4));\n        System.out.println(s.add(9));\n        System.out.println(s.add(5));\n        System.out.println(s.add(\"7\"));\n        System.out.println(s.add(4));\n        \n        for(Object o : s)\n            System.out.println(o);\n\n    }','Collections',0,0,NULL,5),(1553,'ClassCastException\n \nTreeSets are sorted and all these elements aren\'t mutually comparabble','public static void main(String[] dicks){\n      Set s = new TreeSet();\n      \n        System.out.println(s.add(4));\n        System.out.println(s.add(9));\n        System.out.println(s.add(5));\n        System.out.println(s.add(\"7\"));\n        System.out.println(s.add(4));\n        \n        for(Object o : s)\n            System.out.println(o);\n\n    }','Collections',0,0,NULL,5),(1554,'Charly,\n\nhere strings are used as keys and they override hashcode() and equals()\nso it can be used ','class Dog {\n    public String name;\n    public Dog(String n) { name = n; }\n    \n    public String toString(){\n        return name;\n    }\n}\n\npublic class Hello {\n\n    public static void main(String[] dicks){\n      Map<Object,Object> map = new HashMap<>();\n      \n      map.put(\"d1\",new Dog(\"Charly\"));\n      map.put(\"d2\", new Dog(\"dumbfuck\"));\n      \n        System.out.println(map.get(\"d1\"));\n    }\n}','Collections',0,0,NULL,5),(1555,'null \n\nthe map cannot find the values bcause the keys dont have equals or hashcode methods.','class Dog {\n    public String name;\n    public Dog(String n) { name = n; }\n    \n    public String toString(){\n        return name;\n    }\n\n    public static void main(String[] dicks){\n      Map<Object,Object> map = new HashMap<>();\n      \n      map.put(new Dog(\"Bell\"),\"Big brown lab\");\n      map.put(new Dog(\"Sable\"), \"small schiperkee\");\n      \n        System.out.println(map.get(new Dog(\"Bell\")));\n    }\n\n}\n\n','Collections',0,0,NULL,5),(1556,'null\ncatdog\nDOG','class Dog {\n    enum Pets{DOG, CAT, SNAKE};\n    public String name;\n    public Dog(String n) { name = n; }\n    \n    public String toString(){\n        return name;\n    }\n\npublic static void main(String[] dicks){\n      \n      Map<Object,Object> map = new HashMap<>();\n      \n      map.put(new Dog(\"Bell\"),\"Big brown lab\");\n      map.put(new Dog(\"Sable\"), \"small schiperkee\");\n      map.put(Pets.CAT, new Dog(\"catdog\"));\n      map.put(\"Dog\", Pets.DOG);\n      \n        System.out.println(map.get(new Dog(\"Bell\")));\n        System.out.println(map.get(Pets.CAT));\n        System.out.println(map.get(\"Dog\"));\n    }\n}','Collections',0,0,NULL,5),(1557,'both are legal, the first will be slightly better\n\nthe more unique a hashcode the faste retrieval will be. ','public int hashCode() { return name.length(); }\npublic int hashCode() { return 4; }\n \nwhich will be faster ?\n','Collections',0,0,NULL,5),(1558,'12\n34\n45\n63','TreeSet<Integer> tree = new TreeSet<Integer>();\ntree.add(12);\ntree.add(63);\ntree.add(34);\ntree.add(45);\n \nIterator<Integer> iterator = tree.iterator();\nSystem.out.print(\"Tree set data: \");\nwhile (iterator.hasNext()) {\n    System.out.print(iterator.next() + \" \");\n}','Collections',0,0,NULL,5),(1559,'[1.8, 2.3, 2.2, 4.6, 8.9]\n-5\n\nthis comparator sorts in ascending order uless they have the same integer\nvalue','public class Hello {\n    \n    \n    public static void main(String[] dicks){\n      \n      List<Double> grades = new ArrayList<>();\n      grades.addAll(Arrays.asList( new Double[]{ 1.8, 4.6, 2.3, 8.9, 2.2 } ));\n      \n      Collections.sort(grades,new CusSort());\n      \n      System.out.println(grades);\n      \n        System.out.println(Collections.binarySearch(grades,4.2,new CusSort()));\n\n    }\n}\n    \n   class CusSort implements Comparator<Double> {\n       public int compare(Double d1, Double d2){\n           return d1.intValue() == d2.intValue() ? d2.compareTo(d1) : d1.compareTo(d2);\n           \n       }\n   }','Collections',0,0,NULL,5),(1560,'{a=ant, b=buffalo, h=horse} {b=buffalo}\n{R=raccoon, a=ant, b=bat, f=fish, h=horse} {b=bat, f=fish}','public class Hello {\n    \n    \n    public static void main(String[] dicks){\n      \n     TreeMap<String, String> map = new TreeMap<>();\n     map.put(\"a\",\"ant\"); map.put(\"b\",\"buffalo\"); map.put(\"h\",\"horse\");\n     \n     SortedMap<String, String> submap;\n     submap = map.subMap(\"b\",\"g\");\n     \n        System.out.println(map+\" \"+submap);\n        \n        map.put(\"b\",\"bat\");\n        \n        submap.put(\"f\",\"fish\");\n        \n        map.put(\"R\", \"raccoon\");\n        // submap.put(\"p\",\"pig\");\n        \n        System.out.println(map+\" \"+submap);\n    }\n}','Collections',0,0,NULL,5),(1561,'IllegalArgumnetException\n\np is out of range of the submap as first established with subMap(b g);\n\n','public class Hello {\n    \n    \n    public static void main(String[] dicks){\n      \n     TreeMap<String, String> map = new TreeMap<>();\n     map.put(\"a\",\"ant\"); map.put(\"b\",\"buffalo\"); map.put(\"h\",\"horse\");\n     \n     SortedMap<String, String> submap;\n     submap = map.subMap(\"b\",\"g\");\n     \n        System.out.println(map+\" \"+submap);\n        \n        map.put(\"b\",\"bat\");\n        \n        submap.put(\"f\",\"fish\");\n        \n        map.put(\"R\", \"raccoon\");\n        submap.put(\"p\",\"pig\");\n        \n        System.out.println(map+\" \"+submap);\n    }\n}','Collections',0,0,NULL,5),(1562,'will not compile, submap returns a SortedMap.','public class Hello {\n    \n    \n    public static void main(String[] dicks){\n      \n     TreeMap<String, String> map = new TreeMap<>();\n     map.put(\"a\",\"ant\"); map.put(\"b\",\"buffalo\"); map.put(\"h\",\"horse\"); map.put(\"j\",\"jackle\");\n     \n     TreeMap<String, String> submap;\n     submap = map.subMap(\"b\",\"g\");\n     \n     System.out.println(map+\" \"+submap);\n\n    }\n}','Collections',0,0,NULL,5),(1563,'AbstractMap<k,V>\nNavigableMap<K,V>','class TreeMap<k,v> extends  _____________\n implements  ____________','Collections',0,0,NULL,5),(1564,'{Beee=9, Ant=6, muskrat=20, Dog=7}\n\nwithout a provided comparator TreeMap sorts using Animals comparable\n\nwhich is to rank by size','public class Hello {\n    \n    \n    public static void main(String[] dicks){\n      \n     TreeMap<Animal, Integer> map = new TreeMap<>();\n     \n     map.put(new Animal(5,\"Ant\"), 6); map.put(new Animal(3,\"Beee\"),9); map.put(new Animal(25,\"Dog\"),7); map.put(new Animal(20,\"muskrat\"),20);\n     \n     System.out.println(map);\n     \n \n\n    }\n}\n\nclass sortAnimalsAlphabetically implements Comparator<Animal> {\n\n    @Override\n    public int compare(Animal o1, Animal o2) {\n        return o1.getName().compareTo(o2.getName());\n    }\n    \n}\n\nclass Animal implements Comparable<Animal> {\n    private Integer size;\n    private String name;\n    \n    public Animal(int x, String y){\n        size = x;\n        name = y;\n    }\n\n    public int getSize() {\n        return size;\n    }\n\n    public String getName() {\n        return name;\n    }\n    public int compareTo(Animal o){\n        return size.compareTo(o.getSize());\n        \n    }\n    \n    public String toString(){\n        return name;\n    }\n}','Collections',0,0,NULL,5),(1565,'{Ant=6, Beee=9, Dog=7, muskrat=20}\n\nsort using comparator','public class Hello {\n    \n    \n    public static void main(String[] dicks){\n      \n     TreeMap<Animal, Integer> map = new TreeMap<>(new sortAnimalsAlphabetically());\n     \n     map.put(new Animal(5,\"Ant\"), 6); map.put(new Animal(3,\"Beee\"),9); map.put(new Animal(25,\"Dog\"),7); map.put(new Animal(20,\"muskrat\"),20);\n     \n     System.out.println(map);\n     \n \n\n    }\n}\n\nclass sortAnimalsAlphabetically implements Comparator<Animal> {\n\n    @Override\n    public int compare(Animal o1, Animal o2) {\n        return o1.getName().compareTo(o2.getName());\n    }\n    \n}\n\nclass Animal implements Comparable<Animal> {\n    private Integer size;\n    private String name;\n    \n    public Animal(int x, String y){\n        size = x;\n        name = y;\n    }\n\n    public int getSize() {\n        return size;\n    }\n\n    public String getName() {\n        return name;\n    }\n    public int compareTo(Animal o){\n        return size.compareTo(o.getSize());\n        \n    }\n    \n    public String toString(){\n        return name;\n    }\n}','Collections',0,0,NULL,5),(1566,'IllegalArgumentException key out of range\n\nyour trying to add a rhino - 50 - to the copied map when the biggest element\nin the orgiinal was a Dog at 15 !','public class Hello {\n    \n    \n    public static void main(String[] dicks){\n      \n     TreeMap<Animal, Integer> map = new TreeMap<>();\n     \n     map.put(new Animal(2,\"Ant\"), 6); map.put(new Animal(3,\"Beee\"),9); map.put(new Animal(15,\"Dog\"),7); map.put(new Animal(12,\"muskrat\"),20);\n     \n     SortedMap<Animal,Integer> copymap = map.subMap(map.firstKey(), map.lastKey());\n     \n     copymap.put(new Animal(50,\"Rhino\"), 1);\n     map.put(new Animal(30,\"Wolf\"), 4);\n     System.out.println(map);\n     \n     SortedMap<Animal,Integer> copy1map = copymap.subMap(new Animal(4,\"Worm\"), new Animal(25,\"Dolphin\"));\n     \n     System.out.println(copy1map);\n\n    }\n}\n\nclass sortAnimalsAlphabetically implements Comparator<Animal> {\n\n    @Override\n    public int compare(Animal o1, Animal o2) {\n        return o1.getName().compareTo(o2.getName());\n    }\n    \n}\n\nclass Animal implements Comparable<Animal> {\n    private Integer size;\n    private String name;\n    \n    public Animal(int x, String y){\n        size = x;\n        name = y;\n    }\n\n    public int getSize() {\n        return size;\n    }\n\n    public String getName() {\n        return name;\n    }\n    public int compareTo(Animal o){\n        return size.compareTo(o.getSize());\n        \n    }\n    \n    public String toString(){\n        return name;\n    }\n}','Collections',0,0,NULL,5),(1567,'IllegalArgumentException, fromKey out of range\n\nthe tic your trying to add is too small previously the smallest elemtn was\nan Ant at 2','public class Hello {\n    \n    \n    public static void main(String[] dicks){\n      \n     TreeMap<Animal, Integer> map = new TreeMap<>();\n     \n     map.put(new Animal(2,\"Ant\"), 6); map.put(new Animal(3,\"Beee\"),9); map.put(new Animal(15,\"Dog\"),7); map.put(new Animal(12,\"muskrat\"),20);\n     \n     SortedMap<Animal,Integer> copymap = map.subMap(map.firstKey(), map.lastKey());\n     \n     map.put(new Animal(50,\"Rhino\"), 1);\n     map.put(new Animal(30,\"Wolf\"), 4);\n     System.out.println(map);\n     \n     SortedMap<Animal,Integer> copy1map = copymap.subMap(new Animal(1,\"Tic\"), new Animal(25,\"Dolphin\"));\n     \n     //System.out.println(copy1map);\n\n    }\n}\n\nclass sortAnimalsAlphabetically implements Comparator<Animal> {\n\n    @Override\n    public int compare(Animal o1, Animal o2) {\n        return o1.getName().compareTo(o2.getName());\n    }\n    \n}\n\nclass Animal implements Comparable<Animal> {\n    private Integer size;\n    private String name;\n    \n    public Animal(int x, String y){\n        size = x;\n        name = y;\n    }\n\n    public int getSize() {\n        return size;\n    }\n\n    public String getName() {\n        return name;\n    }\n    public int compareTo(Animal o){\n        return size.compareTo(o.getSize());\n        \n    }\n    \n    public String toString(){\n        return name;\n    }\n}\n','Collections',0,0,NULL,5),(1568,'{Ant=6, Beee=9, muskrat=20, Dog=7}\n{Ant=6, Beee=9, muskrat=20}\n{Ant=6, Beee=9, muskrat=20, Dog=7, Wolf=4, Rhino=1}\n{Ant=6, Beee=9, muskrat=20, Dog=7, Wolf=4}\n\npublic SortedMap<K,V> subMap(K fromKey,\n                    K toKey)\n\nkeys range from fromKey, inclusive, to toKey, exclusive. (If fromKey and toKey are equal, the returned map is empty.)\n The returned map is backed by this map, so changes \nin the returned map are reflected in this map, and vice-versa.\n\nTHE TO KEY IS EXCLUSIVE ','public class Hello {\n    \n    \n    public static void main(String[] dicks){\n      \n     TreeMap<Animal, Integer> map = new TreeMap<>();\n     \n     map.put(new Animal(2,\"Ant\"), 6); map.put(new Animal(3,\"Beee\"),9); map.put(new Animal(15,\"Dog\"),7); map.put(new Animal(12,\"muskrat\"),20);\n     \n     SortedMap<Animal,Integer> copymap = map.subMap(map.firstKey(), map.lastKey());\n        System.out.println(map);\n        System.out.println(copymap);\n     \n     map.put(new Animal(50,\"Rhino\"), 1);\n     map.put(new Animal(30,\"Wolf\"), 4);\n     System.out.println(map);\n     \n     copymap = map.subMap(map.firstKey(), map.lastKey());\n     \n        System.out.println(copymap);\n     \n     //SortedMap<Animal,Integer> copy1map = copymap.subMap(new Animal(7,\"Snake\"), new Animal(40,\"Bear\"));\n     //System.out.println(copy1map);\n\n    }\n}','Collections',0,1,NULL,5),(1569,'{Ant=6, Beee=9, muskrat=20, Dog=7}\n{Ant=6, Beee=9, muskrat=20, Dog=7}\n\noverloaded version of submap indicates if that arg is inclusive \n\nThe map is sorted according to the natural ordering of its keys, or by a Comparator provided at map creation time\nNote that the ordering maintained by a tree map, like any sorted map, and whether or not an explicit comparator is provided, \nmust be consistent with equals if this sorted map is to correctly implement the Map interface. (See Comparable or Comparator for a precise definition of consistent with equals.) \nThis is so because the Map interface is defined in terms of the equals operation, but a sorted map performs all key comparisons using its compareTo (or compare) method, so two keys that are deemed equal by this method are, \nfrom the standpoint of the sorted map, equal.  ','public class Hello {\n  public static void main(String[] dicks){\n      \n     TreeMap<Animal, Integer> map = new TreeMap<>();\n     \n     map.put(new Animal(2,\"Ant\"), 6); map.put(new Animal(3,\"Beee\"),9); map.put(new Animal(15,\"Dog\"),7); map.put(new Animal(12,\"muskrat\"),20);\n     \n     SortedMap<Animal,Integer> copymap = map.subMap(map.firstKey(),true, map.lastKey(),true);\n        System.out.println(map);\n        System.out.println(copymap);\n    }\n}\n\nclass Animal implements Comparable<Animal>{\n    private int size;\n    private String name;\n    public Animal(int s, String n){\n        size = s;\n        name = n;\n        \n    }\n    public int getSize(){\n        return size;\n    }\n    public int compareTo(Animal a){\n        int asize = a.getSize();\n        int bsize = this.size;\n        \n        if(asize < bsize)\n            return 1;\n        else if(asize == bsize)\n            return 0;\n        else\n            return -1;\n  \n    }\n    \n    public String toString(){\n        return name;\n    }\n}','Collections',0,0,NULL,5),(1570,'{Ant=6, Beee=9, muskrat=20, Dog=7}\n{Beee=9, muskrat=20, Dog=7}','public class Hello {\n    \n    \n    public static void main(String[] dicks){\n      \n     TreeMap<Animal, Integer> map = new TreeMap<>();\n     \n     map.put(new Animal(2,\"Ant\"), 6); map.put(new Animal(3,\"Beee\"),9); map.put(new Animal(15,\"Dog\"),7); map.put(new Animal(12,\"muskrat\"),20);\n     \n     SortedMap<Animal,Integer> copymap = map.subMap(map.firstKey(),false, map.lastKey(),true);\n        System.out.println(map);\n        System.out.println(copymap);\n    }\n}','Collections',0,0,NULL,5),(1571,'{Ant=6, Beee=9, muskrat=20, Dog=7}\n{Beee=9, muskrat=20}','public class Hello {\n    \n    \n    public static void main(String[] dicks){\n      \n     TreeMap<Animal, Integer> map = new TreeMap<>();\n     \n     map.put(new Animal(2,\"Ant\"), 6); map.put(new Animal(3,\"Beee\"),9); map.put(new Animal(15,\"Dog\"),7); map.put(new Animal(12,\"muskrat\"),20);\n     \n     SortedMap<Animal,Integer> copymap = map.subMap(map.firstKey(),false, map.lastKey(),false);\n        System.out.println(map);\n        System.out.println(copymap);\n    }\n}','Collections',0,0,NULL,5),(1572,'{Ant=6, Beee=9, muskrat=20, Dog=7}\n{Ant=6, Beee=9, muskrat=20, Dog=7}\n{Ant=6, Beee=9, muskrat=20, Dog=7, Wolf=1, Giant sloth=6}\n{Ant=6, Beee=9, muskrat=20, Dog=7}\n\nIf new elements are added to the orginal map that are out of the range\nof the submap then they are not copied over to the sub.\n\nThat submap only exist within the range it was defined. ','public class Hello {\n    \n    \n    public static void main(String[] dicks){\n      \n     TreeMap<Animal, Integer> map = new TreeMap<>();\n     \n     map.put(new Animal(2,\"Ant\"), 6); map.put(new Animal(3,\"Beee\"),9); map.put(new Animal(15,\"Dog\"),7); map.put(new Animal(12,\"muskrat\"),20);\n     \n     SortedMap<Animal,Integer> copymap = map.subMap(map.firstKey(),true, map.lastKey(),true);\n     \n        System.out.println(map);\n        System.out.println(copymap);\n     map.put(new Animal(25,\"Wolf\"), 1);\n     //copymap.put(new Animal(22,\"Lynx\"), 0);\n     map.put(new Animal(33,\"Giant sloth\"), 6);\n     //copymap.put(new Animal(30,\"Comodo\"),5);\n     \n        System.out.println(map);\n        System.out.println(copymap);        \n    }\n}','Collections',0,0,NULL,5),(1573,'{Ant=6, Beee=9, muskrat=20, Dog=7}\n{Ant=6, Beee=9, muskrat=20, Dog=7}\n{Ant=6, Beee=9, Fat Cat=0, muskrat=20, Dog=7, Wolf=1, Giant sloth=6}\n{Ant=6, Beee=9, Fat Cat=0, muskrat=20, Dog=7}','public class Hello {\n    \n    \n    public static void main(String[] dicks){\n      \n     TreeMap<Animal, Integer> map = new TreeMap<>();\n     \n     map.put(new Animal(2,\"Ant\"), 6); map.put(new Animal(3,\"Beee\"),9); map.put(new Animal(15,\"Dog\"),7); map.put(new Animal(12,\"muskrat\"),20);\n     \n     SortedMap<Animal,Integer> copymap = map.subMap(map.firstKey(),true, map.lastKey(),true);\n     \n        System.out.println(map);\n        System.out.println(copymap);\n     map.put(new Animal(25,\"Wolf\"), 1);\n     copymap.put(new Animal(10,\"Fat Cat\"), 0);\n     map.put(new Animal(33,\"Giant sloth\"), 6);\n     \n        System.out.println(map);\n        System.out.println(copymap);\n    }\n}','Collections',0,0,NULL,5),(1574,'{Ant=6, Beee=9, chipmunk=4, muskrat=20, Dog=7, Wolf=1, Giant sloth=6, Leapord=2, Cave Dweller=1}\n{Ant=6, Beee=9, chipmunk=4, muskrat=20, Dog=7, Wolf=1, Giant sloth=6}','public class Hello {\n    \n    \n    public static void main(String[] dicks){\n      \n     TreeMap<Animal, Integer> map = new TreeMap<>();\n     \n     map.put(new Animal(2,\"Ant\"), 6); map.put(new Animal(3,\"Beee\"),9); map.put(new Animal(15,\"Dog\"),7); map.put(new Animal(12,\"muskrat\"),20);\n     map.put(new Animal(25,\"Wolf\"), 1); map.put(new Animal(33,\"Giant sloth\"), 6);\n     map.put(new Animal(35,\"Leapord\"),2); map.put(new Animal(9,\"chipmunk\"),4); map.put(new Animal(46,\"Cave Dweller\"),1);\n     \n        System.out.println(map);\n        \n     SortedMap<Animal,Integer> headmap = map.headMap(new Animal(35,\"Leapord\"));\n     \n        System.out.println(headmap);\n   \n    }\n}','Collections',0,0,NULL,5),(1575,'{Ant=6, Beee=9, chipmunk=4, muskrat=20, Dog=7, Wolf=1, Giant sloth=6, Leapord=2, Cave Dweller=1}\n{Ant=6, Beee=9, chipmunk=4, muskrat=20, Dog=7, Wolf=1, Giant sloth=6, Leapord=2}','public class Hello {\n    \n    \n    public static void main(String[] dicks){\n      \n     TreeMap<Animal, Integer> map = new TreeMap<>();\n     \n     map.put(new Animal(2,\"Ant\"), 6); map.put(new Animal(3,\"Beee\"),9); map.put(new Animal(15,\"Dog\"),7); map.put(new Animal(12,\"muskrat\"),20);\n     map.put(new Animal(25,\"Wolf\"), 1); map.put(new Animal(33,\"Giant sloth\"), 6);\n     map.put(new Animal(35,\"Leapord\"),2); map.put(new Animal(9,\"chipmunk\"),4); map.put(new Animal(46,\"Cave Dweller\"),1);\n     \n        System.out.println(map);\n        \n     SortedMap<Animal,Integer> headmap = map.headMap(new Animal(35,\"Leapord\"),true);\n     \n        System.out.println(headmap);\n   \n    }\n}','Collections',0,0,NULL,5),(1576,'{Ant=6, Beee=9, chipmunk=4, muskrat=20, Dog=7, Wolf=1, Giant sloth=6, Leapord=2, Cave Dweller=1}\n{Ant=6, Beee=9, chipmunk=4, muskrat=20, Dog=7, Wolf=1, Giant sloth=6, Leapord=2}','public class Hello {\n    \n    \n    public static void main(String[] dicks){\n      \n     TreeMap<Animal, Integer> map = new TreeMap<>();\n     \n     map.put(new Animal(2,\"Ant\"), 6); map.put(new Animal(3,\"Beee\"),9); map.put(new Animal(15,\"Dog\"),7); map.put(new Animal(12,\"muskrat\"),20);\n     map.put(new Animal(25,\"Wolf\"), 1); map.put(new Animal(33,\"Giant sloth\"), 6);\n     map.put(new Animal(35,\"Leapord\"),2); map.put(new Animal(9,\"chipmunk\"),4); map.put(new Animal(46,\"Cave Dweller\"),1);\n     \n        System.out.println(map);\n        \n     SortedMap<Animal,Integer> headmap = map.headMap(new Animal(40,\"Python\"),true);\n     \n        System.out.println(headmap);\n   \n    }\n}','Collections',0,0,NULL,5),(1577,'{Ant=6, Beee=9, chipmunk=4, muskrat=20, Dog=7, Wolf=1, Giant sloth=6, Leapord=2, Cave Dweller=1}\n{Ant=6, Beee=9, chipmunk=4, muskrat=20, Dog=7, Wolf=1, Giant sloth=6, Leapord=2}','public class Hello {\n    \n    \n    public static void main(String[] dicks){\n      \n     TreeMap<Animal, Integer> map = new TreeMap<>();\n     \n     map.put(new Animal(2,\"Ant\"), 6); map.put(new Animal(3,\"Beee\"),9); map.put(new Animal(15,\"Dog\"),7); map.put(new Animal(12,\"muskrat\"),20);\n     map.put(new Animal(25,\"Wolf\"), 1); map.put(new Animal(33,\"Giant sloth\"), 6);\n     map.put(new Animal(35,\"Leapord\"),2); map.put(new Animal(9,\"chipmunk\"),4); map.put(new Animal(46,\"Cave Dweller\"),1);\n     \n        System.out.println(map);\n        \n     SortedMap<Animal,Integer> headmap = map.headMap(new Animal(40,\"Python\"));\n     \n        System.out.println(headmap);\n   \n    }\n}','Collections',0,0,NULL,5),(1578,'IOException caused by flushing a closed Bufferedwriter','try{\n            bw.write(df.format(today));\n            bw.newLine();\n            bw.write(\"Flash Cards \\n\");\n            bw.newLine();\n            \n            for(Card c : cards){\n                bw.write(\"================================================\\n\");\n                bw.write(\"-\"+counter+\"-\\n\");\n                bw.write(\"================================================\\n\");\n                bw.write(c.getCard());\n                bw.newLine();\n                bw.write(\"================================================\\n\");\n                bw.write(c.getAnswer());\n                bw.newLine();\n                bw.write(\"================================================\\n\");\n                counter++;\n            }\n            \n            bw.close();\n	    bw.flush();\n            \n        } catch(IOException e){\n            System.out.println(\"Problem saving cards\");\n            e.printStackTrace(); \n        } ','Collections',0,0,NULL,5),(1579,'{Ant=6, Beee=9, chipmunk=4, muskrat=20, Dog=7, Wolf=1, Giant sloth=6, Leapord=2, Cave Dweller=1}\n{Ant=6, Beee=9, chipmunk=4, muskrat=20, Dog=7, Wolf=1, Giant sloth=6, Leapord=2}\n{Ant=6, Beee=9, chipmunk=4, muskrat=20, Dog=7, Wolf=1, Giant sloth=6}','public class Hello {\n    \n    \n    public static void main(String[] dicks){\n      \n     TreeMap<Animal, Integer> map = new TreeMap<>();\n     \n     map.put(new Animal(2,\"Ant\"), 6); map.put(new Animal(3,\"Beee\"),9); map.put(new Animal(15,\"Dog\"),7); map.put(new Animal(12,\"muskrat\"),20);\n     map.put(new Animal(25,\"Wolf\"), 1); map.put(new Animal(33,\"Giant sloth\"), 6);\n     map.put(new Animal(35,\"Leapord\"),2); map.put(new Animal(9,\"chipmunk\"),4); map.put(new Animal(46,\"Cave Dweller\"),1);\n     \n        System.out.println(map);\n        \n     SortedMap<Animal,Integer> headmap = map.headMap(new Animal(40,\"Python\"));\n     \n     System.out.println(headmap);\n        \n     NavigableMap<Animal,Integer> headmapincl = map.headMap(new Animal(34,\"Lynx\"), true);\n     SortedMap<Animal,Integer> headmap_2 = map.headMap(new Animal(30,\"Fox\"), true);\n     \n        System.out.println(headmapincl);\n        \n   \n    }\n}','Collections',0,0,NULL,5),(1580,'{Ant=6, Beee=9, chipmunk=4, muskrat=20, Dog=7, Wolf=1, Giant sloth=6, Leapord=2, Cave Dweller=1}\n{Giant sloth=6, Leapord=2, Cave Dweller=1}','public class Hello {\n    \n    \n    public static void main(String[] dicks){\n      \n     TreeMap<Animal, Integer> map = new TreeMap<>();\n     \n     map.put(new Animal(2,\"Ant\"), 6); map.put(new Animal(3,\"Beee\"),9); map.put(new Animal(15,\"Dog\"),7); map.put(new Animal(12,\"muskrat\"),20);\n     map.put(new Animal(25,\"Wolf\"), 1); map.put(new Animal(33,\"Giant sloth\"), 6);\n     map.put(new Animal(35,\"Leapord\"),2); map.put(new Animal(9,\"chipmunk\"),4); map.put(new Animal(46,\"Cave Dweller\"),1);\n     \n        System.out.println(map);\n        \n    SortedMap<Animal,Integer> tailmap = map.tailMap(new Animal(33,\"Giant Sloth\"));\n    \n        System.out.println(tailmap);\n        \n   \n    }\n}','Collections',0,0,NULL,5),(1581,'{Ant=6, Beee=9, chipmunk=4, muskrat=20, Dog=7, Wolf=1, Giant sloth=6, Leapord=2, Cave Dweller=1}\n{Leapord=2, Cave Dweller=1}','public class Hello {\n    \n    \n    public static void main(String[] dicks){\n      \n     TreeMap<Animal, Integer> map = new TreeMap<>();\n     \n     map.put(new Animal(2,\"Ant\"), 6); map.put(new Animal(3,\"Beee\"),9); map.put(new Animal(15,\"Dog\"),7); map.put(new Animal(12,\"muskrat\"),20);\n     map.put(new Animal(25,\"Wolf\"), 1); map.put(new Animal(33,\"Giant sloth\"), 6);\n     map.put(new Animal(35,\"Leapord\"),2); map.put(new Animal(9,\"chipmunk\"),4); map.put(new Animal(46,\"Cave Dweller\"),1);\n     \n        System.out.println(map);\n        \n    SortedMap<Animal,Integer> tailmap = map.tailMap(new Animal(33,\"Giant Sloth\"),false);\n    \n        System.out.println(tailmap);\n        \n   \n    }\n}','Collections',0,0,NULL,5),(1582,'will not compile,\n\npollFirstEntry(),cielingKey,higherKey(), floorKey(), pollLastEntry(),\ndescendingMap()\n\n	are all in TreeMap not interface SortedMap.',' public static void main(String[] dicks){\n      \n     TreeMap<Animal, Integer> map = new TreeMap<>();\n     \n     map.put(new Animal(2,\"Ant\"), 6); map.put(new Animal(3,\"Beee\"),9); map.put(new Animal(15,\"Dog\"),7); map.put(new Animal(12,\"muskrat\"),20);\n     map.put(new Animal(25,\"Wolf\"), 1); map.put(new Animal(33,\"Giant sloth\"), 6);\n     map.put(new Animal(35,\"Leapord\"),2); map.put(new Animal(9,\"chipmunk\"),4); map.put(new Animal(46,\"Cave Dweller\"),1);\n     \n        System.out.println(map);\n        \n     SortedMap<Animal,Integer> tailmap = map.tailMap(new Animal(33,\"Giant Sloth\"),false);\n     \n        System.out.println(tailmap.pollFirtEntry());\n    \n    }\n}','Collections',0,0,NULL,5),(1583,'{Ant=6, Beee=9, chipmunk=4, muskrat=20, Dog=7, Wolf=1, Giant sloth=6, Leapord=2, Cave Dweller=1}\nAnt=6\nCave Dweller=1\nBeee\nchipmunk\nLeapord\nGiant sloth','public class Hello {\n    \n    \n    public static void main(String[] dicks){\n      \n     TreeMap<Animal, Integer> map = new TreeMap<>();\n     \n     map.put(new Animal(2,\"Ant\"), 6); map.put(new Animal(3,\"Beee\"),9); map.put(new Animal(15,\"Dog\"),7); map.put(new Animal(12,\"muskrat\"),20);\n     map.put(new Animal(25,\"Wolf\"), 1); map.put(new Animal(33,\"Giant sloth\"), 6);\n     map.put(new Animal(35,\"Leapord\"),2); map.put(new Animal(9,\"chipmunk\"),4); map.put(new Animal(46,\"Cave Dweller\"),1);\n     \n        System.out.println(map);\n        \n     \n        System.out.println(map.pollFirstEntry());\n        System.out.println(map.pollLastEntry());\n        System.out.println(map.ceilingKey(new Animal(2,\"Ant\")));\n        System.out.println(map.higherKey(new Animal(3,\"Beee\")));\n        System.out.println(map.floorKey(new Animal(46,\"Cave Dweller\")));\n        System.out.println(map.lowerKey(new Animal(35,\"Leapord\")));\n        \n    \n    }\n}','Collections',0,0,NULL,5),(1584,'nullpointerexception, PQ does not allow null elements','\npublic class Hello {\n    public static void main(String[] dicks){\n      \n        PriorityQueue<Animal> q = new PriorityQueue<>();\n        \n        q.add(new Animal(5,\"Sheep\"));\n        q.offer(new Animal(6,\"Goat\"));\n        q.offer(new Animal(10,\"Cow\"));\n        q.offer(new Animal(12,\"Bull\"));\n        q.offer(null);\n        \n        System.out.println(q);\n        \n    \n    }\n}','Collections',0,0,NULL,5),(1585,'ConcurrentModificationExcpeiton for removing elements from the pq\nwhile iterating over it. ','public class Hello {\n    public static void main(String[] dicks){\n        \n        PriorityQueue<Animal> q = new PriorityQueue<>(5);\n        \n        q.add(new Animal(5,\"Sheep\"));\n        q.offer(new Animal(6,\"Goat\"));\n        q.offer(new Animal(10,\"Cow\"));\n        q.offer(new Animal(12,\"Bull\"));\n        q.offer(new Animal(3,\"Cat\"));\n        q.offer(new Animal(7,\"Sloth\"));\n        \n        for(Animal x : q)\n            System.out.println(x);\n        \n        System.out.println(\"__________________\");\n        \n        for(Animal x : q)\n            System.out.println(q.poll());\n        \n    \n    }\n}','Collections',0,0,NULL,5),(1586,'Cat\nSheep\nSloth\nBull\nGoat\nCow\n__________________\nCat\nSheep\nGoat\nSloth\nCow\nBull\n\nYou need to poll the items from the PriorityQueue one by one. toString doesn\'t do that.\n\nSo instead of your System.out.println(queue); do this:\n\nwhile(!queue.isEmpty()) {\n   System.out.println(queue.poll());\n}\n\nThe reason is that the PriorityQueue is never completely sorted internally, lookup how a heap works for more detail. Polling items from it fixes the heap during the calls, thus it should output the elements in sorted order.','public class Hello {\n    public static void main(String[] dicks){\n        \n        PriorityQueue<Animal> q = new PriorityQueue<>(5);\n        \n        q.add(new Animal(5,\"Sheep\"));\n        q.offer(new Animal(6,\"Goat\"));\n        q.offer(new Animal(10,\"Cow\"));\n        q.offer(new Animal(12,\"Bull\"));\n        q.offer(new Animal(3,\"Cat\"));\n        q.offer(new Animal(7,\"Sloth\"));\n        \n        for(Animal x : q)\n            System.out.println(x);\n        \n        System.out.println(\"__________________\");\n        \n        while(!q.isEmpty())\n            System.out.println(q.poll());\n        \n    \n    }\n}','Collections',0,0,NULL,5),(1587,'will not compile string cannot be converted to Animal','public class Hello {\n    public static void main(String[] dicks){\n        \n        PriorityQueue<Animal> q = new PriorityQueue<>(5);\n        \n        q.add(new Animal(5,\"Sheep\"));\n        q.offer(new Animal(6,\"Goat\"));\n        q.offer(new Animal(10,\"Cow\"));\n        q.offer(new Animal(12,\"Bull\"));\n        q.offer(new Animal(3,\"Cat\"));\n        q.offer(new Animal(7,\"Sloth\"));\n        \n        q.offer(\"Sloths\");\n        q.add(\"fake bull\");\n        \n        while(!q.isEmpty())\n            System.out.println(q.poll());\n        \n\n        \n    \n    }\n}','Collections',0,0,NULL,5),(1588,'will not compile, Collections.sort will only sort Lists','public class Hello {\n    public static void main(String[] dicks){\n        Comparator revSort = Collections.reverseOrder();\n        PriorityQueue<Animal> q = new PriorityQueue<>();\n        \n        q.add(new Animal(5,\"Sheep\"));\n        q.offer(new Animal(6,\"Goat\"));\n        q.offer(new Animal(10,\"Cow\"));\n        q.offer(new Animal(12,\"Bull\"));\n        q.offer(new Animal(3,\"Cat\"));\n        q.offer(new Animal(7,\"Sloth\"));\n        \n        PriorityQueue<Animal> q2 = new PriorityQueue<>(q);\n        \n        Collections.sort(q2,revSort);\n        \n        while(!q.isEmpty())\n            System.out.println(q.poll());\n        \n        while(!q2.isEmpty())\n            System.out.println(q2.poll());\n\n    }\n}','Collections',0,0,NULL,5),(1589,'Bull\nCow\nSloth\nGoat\nSheep\nCat','public class Hello {\n    public static void main(String[] dicks){\n        Comparator revSort = Collections.reverseOrder();\n        PriorityQueue<Animal> q = new PriorityQueue<>(revSort);\n        \n        q.add(new Animal(5,\"Sheep\"));\n        q.offer(new Animal(6,\"Goat\"));\n        q.offer(new Animal(10,\"Cow\"));\n        q.offer(new Animal(12,\"Bull\"));\n        q.offer(new Animal(3,\"Cat\"));\n        q.offer(new Animal(7,\"Sloth\"));\n        \n        while(!q.isEmpty()){\n            System.out.println(q.poll());\n        }\n        \n        \n\n    }\n}','Collections',0,0,NULL,5),(1590,'Here animal doesn\'t impleemnt equals and remove uses equals to determine the \nelement to remove','public class Hello {\n    public static void main(String[] dicks){\n        Comparator revSort = Collections.reverseOrder();\n        PriorityQueue<Animal> q = new PriorityQueue<>(revSort);\n        \n        q.add(new Animal(5,\"Sheep\"));\n        q.offer(new Animal(6,\"Goat\"));\n        q.offer(new Animal(10,\"Cow\"));\n        q.offer(new Animal(12,\"Bull\"));\n        q.offer(new Animal(3,\"Cat\"));\n        q.offer(new Animal(7,\"Sloth\"));\n        \n        System.out.println(q.remove());\n        System.out.println(q.remove(new Animal(7,\"Sloth\")));\n        \n        while(!q.isEmpty()){\n            System.out.println(q.poll());\n        }\n\n    }\n}\n\nclass Animal implements Comparable<Animal> {\n    private Integer size;\n    private String name;\n    \n    public Animal(int x, String y){\n        size = x;\n        name = y;\n    }\n\n    public int getSize() {\n        return size;\n    }\n\n    public String getName() {\n        return name;\n    }\n    public int compareTo(Animal o){\n        return size.compareTo(o.getSize());\n        \n    }\n    \n    public String toString(){\n        return name;\n    }\n}\n','Collections',0,0,NULL,5),(1591,'now with equals remove() works just fine. \n\nBull\ntrue\n\nCow\nGoat\nSheep\nCat\n\nnotice the pq is sorted with a Reverse sort comparator, so the animal class\nimplements Comparable. If it didn\'t implement Comparable it could not be used \nin the PriorityQueue. If it wasn\'t for the equals method the remove(sloth)\ncall would return false and sloth would not be removed. Thus making the \noutput:\n\n	Bull\n	false\n\n	Cow\n	Sloth\n	Goat\n	Sheep\n	Cat\n\nalso notice that it is a queue and therefore removes from the head','public class Hello {\n    public static void main(String[] dicks){\n        Comparator revSort = Collections.reverseOrder();\n        PriorityQueue<Animal> q = new PriorityQueue<>(revSort);\n        \n        q.add(new Animal(5,\"Sheep\"));\n        q.offer(new Animal(6,\"Goat\"));\n        q.offer(new Animal(10,\"Cow\"));\n        q.offer(new Animal(12,\"Bull\"));\n        q.offer(new Animal(3,\"Cat\"));\n        q.offer(new Animal(7,\"Sloth\"));\n        \n        System.out.println(q.remove());\n        System.out.println(q.remove(new Animal(7,\"Sloth\")));\n        System.out.println(\"\");\n        \n        while(!q.isEmpty()){\n            System.out.println(q.poll());\n        }\n    }\n}\n\nclass Animal implements Comparable<Animal> {\n    private Integer size;\n    private String name;\n    \n    public Animal(int x, String y){\n        size = x;\n        name = y;\n    }\n\n    public int getSize() {\n        return size;\n    }\n\n    public String getName() {\n        return name;\n    }\n    public int compareTo(Animal o){\n        return size.compareTo(o.getSize());\n        \n    }\n    \n    public String toString(){\n        return name;\n    }\n    \n    public boolean equals(Object o){\n        if((o instanceof Animal)){\n            if((((Animal)o).getSize() == this.size) && (((Animal)o).getName().equals(name) ))\n                return true;\n            return false;           \n        } \n        return false;\n    }\n}','Collections',0,0,NULL,5),(1592,'Biffy\ntwo tone\nbig slick\nfunny farm\ntwice tickled\nnull\nnull','public class Hello {\n    public static void main(String[] dicks){\n        Map<Integer,String> map = new HashMap<>();\n        \n        map.put(7,\"Biffy\");\n        map.put(5,\"two tone\");\n        map.put(9,\"big slick\");\n        map.put(1,\"funny farm\");\n        map.put(10, \"twice tickled\");\n        \n        List<Integer> list = new ArrayList<>();\n        \n        list.add(7);\n        list.add(5);\n        list.add(9);\n        list.add(1);\n        list.add(10);\n        list.add(16);\n        list.add(14);\n        \n        for(int x : list){\n            System.out.println(map.remove(x));\n        }    \n\n    }\n}','Collections',0,0,NULL,5),(1593,'sizes: 5, 7, 5\nBiffy\nset contains?: true\nsizes: 4, 7, 5\ntwo tone\nset contains?: true\nsizes: 3, 7, 5\nbig slick\nset contains?: true\nsizes: 2, 7, 5\nfunny farm\nset contains?: true\nsizes: 1, 7, 5\ntwice tickled\nset contains?: true\nsizes: 0, 7, 5\nnull\nset contains?: false\nsizes: 0, 7, 5\nnull\nset contains?: false','public class Hello {\n    public static void main(String[] dicks){\n        Map<Integer,String> map = new HashMap<>();\n        \n        map.put(7,\"Biffy\");\n        map.put(5,\"two tone\");\n        map.put(9,\"big slick\");\n        map.put(1,\"funny farm\");\n        map.put(10, \"twice tickled\");\n        \n        List<Integer> list = new ArrayList<>();\n        \n        list.add(7);\n        list.add(5);\n        list.add(9);\n        list.add(1);\n        list.add(10);\n        list.add(16);\n        list.add(14);\n        \n        Set<Integer> set = new HashSet<>();\n        \n        set.add(7);\n        set.add(5);\n        set.add(9);\n        set.add(1);\n        set.add(10);\n        \n        for(int x : list){\n            System.out.println(\"sizes: \"+map.size() +\", \"+ list.size()+\", \"+set.size());\n            System.out.println(map.remove(x));\n            System.out.println(\"set contains?: \"+set.contains(x));\n        }    \n\n    }\n}','Collections',0,0,NULL,5),(1594,'','Spaces sort before characters,\nuppercases sort before the lower,\nyour good to go','Collections',0,0,NULL,5),(1595,'true\ntrue\nfalse\ntrue\ntrue\ntrue\nfalse\n4\ntrue\nfalse\n3','public class Hello {\n    public static void main(String[] dicks){\n       HashSet<Animal> set = new HashSet<>();\n       \n       Animal cat = new Animal(3,\"Cat\");\n       Animal dog = new Animal(4,\"Dog\");\n       Animal wolf = new Animal(6,\"Wolf\");\n       Animal coyote = new Animal(5,\"Coyote\");\n       Animal cat2 = new Animal(3,\"Cat\");\n       \n        System.out.println(cat.equals(cat2));\n       \n        System.out.println(set.add(cat));\n        System.out.println(set.add(cat));\n        System.out.println(set.add(dog));\n        System.out.println(set.add(wolf));\n        System.out.println(set.add(coyote));\n        System.out.println(set.add(cat2));\n        \n       \n        System.out.println(set.size());\n        System.out.println(set.remove(cat));\n        System.out.println(set.contains(cat));\n        System.out.println(set.size());\n        \n        \n    \n    }\n}\n\n\nclass Animal {\n    private Integer size;\n    private String name;\n    \n    public Animal(int x, String y){\n        size = x;\n        name = y;\n    }\n\n    public int getSize() {\n        return size;\n    }\n\n    public String getName() {\n        return name;\n    }\n    \n    public String toString(){\n        return name;\n    }\n    \n    public boolean equals(Object o){\n        if((o instanceof Animal)){\n            if((((Animal)o).getSize() == this.size) && (((Animal)o).getName().equals(name) ))\n                return true;\n            return false;           \n        } \n        return false;\n    }\n    \n    //public int hashCode(){ return name.length() + size; }\n        \n}','Collections',0,0,NULL,5),(1596,'true\ntrue\nfalse\ntrue\ntrue\ntrue\nfalse\n4\ntrue\nfalse\n3\n\nif hashCode() is not overriden then every object will go in its own bucket\ntherefore equals will not be able to differentiate between equal objects because it will have no\nother objects to compare that object to!','public class Hello {\n    public static void main(String[] dicks){\n       HashSet<Animal> set = new HashSet<>();\n       \n       Animal cat = new Animal(3,\"Cat\");\n       Animal dog = new Animal(4,\"Dog\");\n       Animal wolf = new Animal(6,\"Wolf\");\n       Animal coyote = new Animal(5,\"Coyote\");\n       Animal cat2 = new Animal(3,\"Cat\");\n       \n        System.out.println(cat.equals(cat2));\n       \n        System.out.println(set.add(cat));\n        System.out.println(set.add(cat));\n        System.out.println(set.add(dog));\n        System.out.println(set.add(wolf));\n        System.out.println(set.add(coyote));\n        System.out.println(set.add(cat2));\n        \n       \n        System.out.println(set.size());\n        System.out.println(set.remove(cat));\n        System.out.println(set.contains(cat));\n        System.out.println(set.size());\n        \n        \n    \n    }\n}\n\n\nclass Animal {\n    private Integer size;\n    private String name;\n    \n    public Animal(int x, String y){\n        size = x;\n        name = y;\n    }\n\n    public int getSize() {\n        return size;\n    }\n\n    public String getName() {\n        return name;\n    }\n    \n    public String toString(){\n        return name;\n    }\n    \n    public boolean equals(Object o){\n        if((o instanceof Animal)){\n            if((((Animal)o).getSize() == this.size) && (((Animal)o).getName().equals(name) ))\n                return true;\n            return false;           \n        } \n        return false;\n    }\n    \n    public int hashCode(){ return name.length() + size; }\n        \n}\n','Collections',0,0,NULL,5),(1597,'false\ntrue\nfalse\ntrue\ntrue\ntrue\ntrue\n5\ntrue\nfalse\n4\n\nif equals is not overriden then only references with the same actual\nobject are considered equal','public class Hello {\n    public static void main(String[] dicks){\n       HashSet<Animal> set = new HashSet<>();\n       \n       Animal cat = new Animal(3,\"Cat\");\n       Animal dog = new Animal(4,\"Dog\");\n       Animal wolf = new Animal(6,\"Wolf\");\n       Animal coyote = new Animal(5,\"Coyote\");\n       Animal cat2 = new Animal(3,\"Cat\");\n       \n        System.out.println(cat.equals(cat2));\n       \n        System.out.println(set.add(cat));\n        System.out.println(set.add(cat));\n        System.out.println(set.add(dog));\n        System.out.println(set.add(wolf));\n        System.out.println(set.add(coyote));\n        System.out.println(set.add(cat2));\n        \n       \n        System.out.println(set.size());\n        System.out.println(set.remove(cat));\n        System.out.println(set.contains(cat));\n        System.out.println(set.size());\n        \n        \n    \n    }\n}\n\n\nclass Animal {\n    private Integer size;\n    private String name;\n    \n    public Animal(int x, String y){\n        size = x;\n        name = y;\n    }\n\n    public int getSize() {\n        return size;\n    }\n\n    public String getName() {\n        return name;\n    }\n    \n    public String toString(){\n        return name;\n    }\n    \n    /**\n    public boolean equals(Object o){\n        if((o instanceof Animal)){\n            if((((Animal)o).getSize() == this.size) && (((Animal)o).getName().equals(name) ))\n                return true;\n            return false;           \n        } \n        return false;\n    } **/\n    \n    public int hashCode(){ return name.length() + size; }\n        \n}\n','Collections',0,0,NULL,5),(1598,'nullpointerexception\n\nLinkedHashSet and HashSet allow null elements but when you call a method on a null\nyou get an exception','public class Hello {\n    public static void main(String[] dicks){\n       Animal cat = new Animal(3,\"Cat\");\n       Animal dog = new Animal(4,\"Dog\");\n       Animal wolf = new Animal(6,\"Wolf\");\n       Animal coyote = new Animal(5,\"Coyote\");\n       Animal cat2 = new Animal(3,\"Cat\");\n       \n       LinkedHashSet<Animal> lhs = new LinkedHashSet<>();\n       HashSet<Animal> hs = new HashSet<>();\n       \n       lhs.add(cat); lhs.add(dog); lhs.add(wolf); lhs.add(coyote); lhs.add(null);\n       hs.add(cat); hs.add(dog); hs.add(wolf); hs.add(coyote); hs.add(null);\n       \n       for(Animal x : lhs){\n           System.out.print(x.getName()+\" \");\n       }\n \n    }\n}','Collections',0,0,NULL,5),(1599,'true\ntrue\nfalse\nfalse\n\nSets allow null elements but they also dont allow duplicates so here \nis will not let you add ANother null','public class Hello {\n    public static void main(String[] dicks){\n       Animal cat = new Animal(3,\"Cat\");\n       Animal dog = new Animal(4,\"Dog\");\n       Animal wolf = new Animal(6,\"Wolf\");\n       Animal coyote = new Animal(5,\"Coyote\");\n       Animal cat2 = new Animal(3,\"Cat\");\n       \n       LinkedHashSet<Animal> lhs = new LinkedHashSet<>();\n       HashSet<Animal> hs = new HashSet<>();\n       \n       lhs.add(cat); lhs.add(dog); lhs.add(wolf); lhs.add(coyote);\n       hs.add(cat); hs.add(dog); hs.add(wolf); hs.add(coyote); \n       \n       System.out.println( lhs.add(null) ); \n       System.out.println( hs.add(null) );\n       \n       System.out.println( lhs.add(null) );\n       System.out.println( hs.add(null) );\n        \n\n    }\n}','Collections',0,0,NULL,5),(1600,'will not compile,\n\nHashtable is a Map !\n\nrequires two type arguments','public class Hello {\n    public static void main(String[] dicks){\n       Animal cat = new Animal(3,\"Cat\");\n       Animal dog = new Animal(4,\"Dog\");\n       Animal wolf = new Animal(6,\"Wolf\");\n       Animal coyote = new Animal(5,\"Coyote\");\n       Animal cat2 = new Animal(3,\"Cat\");\n       \n       LinkedHashSet<Animal> lhs = new LinkedHashSet<>();\n       HashSet<Animal> hs = new HashSet<>();\n       Hashtable<Animal> ht = new Hashtable<>();\n       \n       lhs.add(cat); lhs.add(dog); lhs.add(wolf); lhs.add(coyote);\n       hs.add(cat); hs.add(dog); hs.add(wolf); hs.add(coyote); \n       \n       System.out.println(lhs.add(null)); \n       System.out.println(hs.add(null));\n       \n       System.out.println(lhs.add(null));\n       System.out.println(hs.add(null));\n        \n\n    }\n}','Collections',0,0,NULL,5),(1601,'null\nnull\nnull\nnull\nnull\nCat\nCat\nDog\nDog\n\nput\n\npublic V put(K key,\n    V value)\n\nMaps the specified key to the specified value in this hashtable. \nNeither the key nor the value can be null.\n\nThe value can be retrieved by calling the get\n method with a key that is equal to the original key.\n\nTo successfully store and retrieve objects from a hashtable, \nthe objects used as keys \nmust implement the hashCode method and the equals method. \n\nto know anything about how this code works you need to know if it implements\nequals and hashCode','public class Hello {\n    public static void main(String[] dicks){\n       Animal cat = new Animal(3,\"Cat\");\n       Animal dog = new Animal(4,\"Dog\");\n       Animal wolf = new Animal(6,\"Wolf\");\n       Animal coyote = new Animal(5,\"Coyote\");\n       Animal cat2 = new Animal(3,\"Cat\");\n\n       Hashtable<Integer,Animal> ht = new Hashtable<>();\n\n        System.out.println(ht.put(1,cat));\n        System.out.println(ht.put(2,dog));\n        System.out.println(ht.put(3,wolf));\n        System.out.println(ht.put(4,coyote));\n        System.out.println(ht.put(5, cat2));\n        \n        System.out.println(ht.put(1,cat));\n        System.out.println(ht.put(1,new Animal(3,\"Barn Cat\")));\n        \n        System.out.println(ht.put(2,dog));\n        System.out.println(ht.put(2, new Animal(4,\"Fox\")));\n    }\n}','Collections',0,0,NULL,5),(1602,'null\nnull\nnull\nnull\nnull\nCat\nCat\n5\nDog\nDog','public class Hello {\n    public static void main(String[] dicks){\n       Animal cat = new Animal(3,\"Cat\");\n       Animal dog = new Animal(4,\"Dog\");\n       Animal wolf = new Animal(6,\"Wolf\");\n       Animal coyote = new Animal(5,\"Coyote\");\n       Animal cat2 = new Animal(3,\"Cat\");\n\n       Hashtable<Integer,Animal> ht = new Hashtable<>();\n\n        System.out.println(ht.put(1,cat));\n        System.out.println(ht.put(2,dog));\n        System.out.println(ht.put(3,wolf));\n        System.out.println(ht.put(4,coyote));\n        System.out.println(ht.put(5, cat2));\n        \n        System.out.println(ht.put(1,cat));\n        System.out.println(ht.put(1,new Animal(3,\"Barn Cat\")));\n        \n        System.out.println(ht.size());\n        \n        System.out.println(ht.put(2,dog));\n        System.out.println(ht.put(2, new Animal(4,\"Fox\")));\n    }\n}\n\n\nclass Animal {\n    private Integer size;\n    private String name;\n    \n    public Animal(int x, String y){\n        size = x;\n        name = y;\n    }\n\n    public int getSize() {\n        return size;\n    }\n\n    public String getName() {\n        return name;\n    }\n    \n    public String toString(){\n        return name;\n    }\n    \n    /**\n    public boolean equals(Object o){\n        if((o instanceof Animal)){\n            if((((Animal)o).getSize() == this.size) && (((Animal)o).getName().equals(name) ))\n                return true;\n            return false;           \n        } \n        return false;\n    } **/\n    \n    //public int hashCode(){ return name.length() + size; }\n        \n}\n','Collections',0,0,NULL,5),(1603,'will not compile int cannot auotbox to null\n\na primitive cannot be null','public class Hello {\n    public static void main(String[] dicks){\n        Map<String, Integer> map = new HashMap<>();\n        \n        String name = \"Max\";\n        map.put(name,10000000);\n        \n        int total = map.get(\"Max\");\n        \n        (if total == null){\n            System.out.println(\"no money in maxs account\");\n        }\n    }\n}','Collections',0,0,NULL,5),(1604,'class Foo<t> { }	// a class\nT anInstance;		//an instance variable\nFoo(T aRef) { }	// a constructor argument\nvoid bar(T aRef) { }	// a method argument\nT baz() { }		// a return type\n\nThe compiler will substitute the actual type','The generics type identifier can be used in class, method, and variable declarations....\n\n','Generics',0,0,NULL,5),(1605,'List and Set, With Maps you remove by the key which removes the element','Which Collection interfaces have a method for removing an element by the object ?','Collections',0,0,NULL,5),(1606,'Will Not compile\n\nuntyped collections store Objects so you would have to cast to a String. ','public class Hello {\n    public static void main(String[] args){\n        List myList = new ArrayList();\n        myList.add(\"Hoyt\");\n        myList.add(\"JOJO\");\n        myList.add(\"Adam\");\n        \n        String athletename = myList.get(1);\n        System.out.println(athletename+ \" \" + athletename.length());\n    }\n}','Collections',0,0,NULL,5),(1607,'Will Not compile','void takeListOfStrings(List<String> strings) {\n	strings.add(new Integer(42) ); \n}','Generics',0,0,NULL,5),(1608,'Compiles fine, you know what is coming out of a typed list returned from a method declared with that type','public List<Dog> getDogList() {\n	List<Dog> dogs = new ArrayList<>();\n	//add dogs to list\n	return dogs;\n}\n\nDog d = getDogList().get(0);','Generics',0,0,NULL,5),(1609,'Will not compile','public List getDogList() {\n	List dogs = new ArrayList();\n	dogs.add(\"Dicks\");\n	dogs.add(\"Spot\");\n	dogs.add(\"FIdo\");\n	return dogs;\n}\n\npsvm(sa){	\n	List dognames = getDogList();\n	Dog fido = dognames.get(2);\n}\n	','Generics',0,0,NULL,5),(1610,'The cast is unecessary but it wont cause any error','psvm(sa){\n	List<Integer> list = new ArrayList<>();\n	list.add(5);\n	list.add(9);\n	list.add(7);\n\n	Integer i = (Integer) list.get(0);\n}','Generics',0,0,NULL,5),(1611,'Works fine. ','public class Hello {\n    public static void main(String[] args){\n        List<Integer> myList = new ArrayList<>();\n        \n        myList.add(4);\n        myList.add(6);\n        Adder adder = new Adder();\n        int total = adder.addAll(myList);\n        \n        System.out.println(total);\n        \n    }\n}\n\nclass Adder {\n        int addAll(List list){\n            Iterator it = list.iterator();\n            int total = 0;\n            \n            while(it.hasNext()){\n                int i = ((Integer)it.next()).intValue();\n                total += i;\n            }\n            \n            return total;\n        }\n}','Generics',0,0,NULL,5),(1612,'ClassCastException','public class Hello {\n    public static void main(String[] args){\n        List myList = new ArrayList();\n        \n        myList.add(4);\n        myList.add(6);\n        myList.add(\"whoops\");\n        Adder adder = new Adder();\n        int total = adder.addAll(myList);\n        \n        System.out.println(total);\n        \n    }\n}\n\nclass Adder {\n        int addAll(List list){\n            Iterator it = list.iterator();\n            int total = 0;\n            \n            while(it.hasNext()){\n                int i = ((Integer)it.next()).intValue();\n                total += i;\n            }\n            \n            return total;\n        }\n}','Generics',0,0,NULL,5),(1613,'compiles and runs no problem','public class Hello {\n    public static void main(String[] args){\n        List<Integer> myList = new ArrayList<>();\n        \n        myList.add(4);\n        myList.add(6);\n        Inserter is = new Inserter();\n        is.insert(myList);\n        \n    }\n}\n\nclass Inserter {\n        void insert(List list){\n            list.add(new Integer(42));\n            Iterator it = list.iterator();\n            int total = 0;\n            \n            while(it.hasNext()){\n                int i = ((Integer)it.next()).intValue();\n                total += i;\n            }\n\n        }\n}','Generics',0,0,NULL,5),(1614,'ClassCastException\n\nand compiler warning for going into unsafe method','public class Hello {\n    public static void main(String[] args){\n        List<Integer> myList = new ArrayList<>();\n        \n        myList.add(4);\n        myList.add(6);\n        Inserter is = new Inserter();\n        is.insert(myList);\n        \n    }\n}\n\nclass Inserter {\n        void insert(List list){\n            list.add(\"42\");\n            Iterator it = list.iterator();\n            int total = 0;\n            \n            while(it.hasNext()){\n                int i = ((Integer)it.next()).intValue();\n                total += i;\n            }\n\n        }\n}','Generics',0,0,NULL,5),(1615,'Will not compile because of .intValue() the list declared in inserter is of type Object','public class Hello {\n    public static void main(String[] args){\n        List<Integer> myList = new ArrayList<>();\n        \n        myList.add(4);\n        myList.add(6);\n        Inserter is = new Inserter();\n        is.insert(myList);\n        \n    }\n}\n\nclass Inserter {\n        void insert(List list){\n            list.add(\"42\");\n            Iterator it = list.iterator();\n            int total = 0;\n            \n            while(it.hasNext()){\n                int i = (it.next()).intValue();\n                total += i;\n            }\n\n        }\n}','Generics',0,0,NULL,5),(1616,'comiler warning but compiles and runs just fine, in order to support legacy code this must be allowed. ','public class Hello {\n    public static void main(String[] args){\n        List<Integer> myList = new ArrayList<>();\n        \n        myList.add(4);\n        myList.add(6);\n        Inserter is = new Inserter();\n        is.insert(myList);\n        \n    }\n}\n\nclass Inserter {\n        void insert(List list){\n            list.add(\"42\");           \n        }\n}','Generics',0,0,NULL,5),(1617,'','The compiiler only issues warnings when a typed collection is going into an untyped method and that method\nADDS somethiing. ','Generics',0,0,NULL,5),(1618,'The generic types are removed by the compiler before runtime. The types are just for the compiler the JVM\nhas no idea about types. To the JVM generic code looks the same as pre generic. ','\"Type Erasure\"\n','Generics',0,0,NULL,5),(1619,'cast is required here','List myList = new ArrayList();\n        \nmyList.add(45);\n        \nint x = (Integer) myList.get(0);','Generics',0,0,NULL,5),(1620,'cast not necessary here',' List<Integer> myList = new ArrayList<>();\n        \n        myList.add(45);\n        \n        int x = myList.get(0);\n        \n        ','Generics',0,0,NULL,5),(1621,'no\nno\nyes\nyes','List<Object> myList = new ArrayList<JButton>();\nList<Number> myList = new ArrayList<Integer>();\nList<JButton> myList = new ArrayList<JButton>();\nList<String> myList = new ArrayList<String>();','Generics',0,0,NULL,5),(1622,'This is ok!\n\nunlike collection types array types can use polymorphism.\n','class Parent { }\nclass Child extends Parent { }\n\npublic class Test {\n	psvm(SA){\n		Parent[] myArray = new Child[4];\n	}\n}','Generics',0,0,NULL,5),(1623,'This not ok ','List<Object> myList = new ArrayList<JButton>();	','Generics',0,0,NULL,5),(1624,'Will not compile\n\nif the method parameter says ArrayList<Animal> then you\ncan only pass in an ArrayList of type <Animal>, \npolymorphism doesn\'t work for generic types','public class AnimalDoctor {\n	public void checkAnimals(ArrayLIst<Animal> list){\n		for(Animal a : animals){\n			a.checkup();\n		}\n	}\n}\n\npsvm(Sa){\n        List<Dog> dogs = new ArrayList<Dog>();\n        dogs.add(new Dog()); dogs.add(new Dog());\n\n        List<Cat> cats = new ArrrayLiist<Cat>();\n        cats.add(new Cat()); cats.add(new Cat());\n\n        AnimalDoctor ad = new AnimalDoctor();\n        ad.checkAnimals(dogs);\n        ad.checkAnimals(cats);\n}\n}','Generics',0,0,NULL,5),(1625,'fine','Animal[] animals = new Animal[3];\nanimals[0] = new Cat();\nanimals[1] = new Dog();','Generics',0,0,NULL,5),(1626,'fine you can add and instance of a subtype into an array or collection declared with a supertype.\n\nyou can addDogs and Cats to an Animal array or an Animal Collection. ','List<Animal> animals = new ArrayList<Animal>();\nanimals.add(new Cat());\nanimals.add(new Dog());\n','Generics',0,0,NULL,5),(1627,'ok!','public class Hello {\n    public static void main(String[] args){\n       \n      \n        \n    }\n    \n    public void foo() {\n	Dog[] dogs = { new Dog(), new Dog() };\n	addAnimal(dogs);\n    }\n    \n    public void addAnimal(Animal[] animals) {\n	animals[0] = new Dog();\n        animals[1] = new Cat();\n    }\n}','Generics',0,0,NULL,5),(1628,'ok !\n\nThe compiler thinks its ok to add a Dog to an Animal[] since a Dog can be assigned to an animal reference. B\n\nBut the compiler does not know if you passed in an array of an animal subtype. \n\nThe reason: at runtime the JVM knows the type of the array but not the type of the collection ','public class Hello {\n    public static void main(String[] args){\n \n    }\n    \n    public void foo() {\n	Cat[] cats = { new Cat(), new Cat() };\n	addAnimal(cats);\n    }\n    \n    public void addAnimal(Animal[] animals) {\n	animals[0] = new Dog();\n        animals[1] = new Cat();\n    }\n}','Generics',0,0,NULL,5),(1629,'comiles and runs just fine','public class Hello {\n    public static void main(String[] args){\n        List<Animal> animals = new ArrayList<Animal>();\n        animals.add(new Dog());\n        animals.add(new Cat());\n        \n        addAnimal(animals);\n    \n    }\n    public static void addAnimal(List<Animal> animals) {\n	animals.add(new Dog());\n    }\n}','Generics',0,0,NULL,5),(1630,'comiles fine','public class Hello {\n    public static void main(String[] args){\n        ArrayList<Animal> animals = new ArrayList<>();\n        animals.add(new Dog());\n        animals.add(new Cat());\n        \n        addAnimal(animals);\n    \n    }\n    public static void addAnimal(List<Animal> animals) {\n	animals.add(new Dog());\n    }\n}','Generics',0,0,NULL,5),(1631,'will not compile, ','public class Hello {\n    public static void main(String[] args){\n        List<Dog> animals = new ArrayList<>();\n        animals.add(new Dog());\n        \n        \n        addAnimal(animals);\n    \n    }\n    public static void addAnimal(List<Animal> animals) {\n	animals.add(new Dog());\n    }\n}','Generics',0,0,NULL,5),(1632,'will not compile because of ArrayList<Dog> cant be applied to List<Animal>','public class Hello {\n    public static void main(String[] args){\n        ArrayList<Dog> animals = new ArrayList<>();\n        animals.add(new Dog());\n        \n        \n        addAnimal(animals);\n    \n    }\n    public static void addAnimal(List<Animal> animals) {\n	animals.add(new Dog());\n    }\n}','Generics',0,0,NULL,5),(1633,'<?> wildcard\n\ntells the compiler you can take any generic subtype of the declared argument type because you won\'t\nbe putting anything in the collection. ','What mechanism is used to tell the compiler \" Hey, I\'m using the collection passed in just to invoke methods \non the elements  and I promise not to ADD anything into the collection\"','Generics',0,0,NULL,5),(1634,'wont compile \n\nadding to a collection is not compatible with ? notation','public class Hello {\n    public static void main(String[] args){\n        ArrayList<Dog> animals = new ArrayList<>();\n        animals.add(new Dog());\n        \n        \n        addAnimal(animals);\n    \n    }\n    public static void addAnimal(List<? extends Animal> animals) {\n	animals.add(new Dog());\n    }\n}','Generics',0,0,NULL,5),(1635,'compiles fine!','public class Hello {\n    public static void main(String[] args){\n        ArrayList<Dog> animals = new ArrayList<>();\n        animals.add(new Dog());\n        \n        \n        addAnimal(animals);\n    \n    }\n    public static void addAnimal(List<? extends Animal> animals) {\n	for(Animal a : animals){\n            a.makesound();\n        }\n    }\n}','Generics',0,0,NULL,5),(1636,'will not compile because of for(Animal a : animals)\n\n	needs to be... \n		for(Serializable a : animals)','public class Hello {\n    public static void main(String[] args){\n        ArrayList<Dog> animals = new ArrayList<>();\n        animals.add(new Dog());\n        \n        \n        addAnimal(animals);\n    \n    }\n    public static void addAnimal(List<? extends Serializable> animals) {\n	for(Animal a : animals){\n            a.makesound();\n        }\n    }\n}\n\nclass Dog extends Animal{}\nclass Cat extends Animal{}\nclass Animal implements Serializable{\n    public void makesound(){ System.out.println(\"SOUND\"); }\n        \n}','Generics',0,0,NULL,5),(1637,'compiles fine!','public class Hello {\n    public static void main(String[] args){\n        ArrayList<Dog> animals = new ArrayList<>();\n        animals.add(new Dog());\n        \n        \n        addAnimal(animals);\n    \n    }\n    public static void addAnimal(List<? extends Serializable> animals) {\n	for(Serializable a : animals){\n            //call method form interface\n        }\n    }\n}\n\nclass Dog extends Animal{}\nclass Cat extends Animal{}\nclass Animal implements Serializable{\n    public void makesound(){ System.out.println(\"SOUND\"); }\n        \n}','Generics',0,0,NULL,5),(1638,'<? super Dog>\n\npublic class Hello {\n    public static void main(String[] args) {     \n\n        List<Animal> animals = new ArrayList<Animal>();\n        animals.add(new Dog());\n        animals.add(new Cat());\n        \n        addAnimal(animals);\n    \n    }\n    \n    public static void addAnimal(List<? super Dog> animals) {\n	animals.add(new Dog());\n    }\n}\n\nWhile you can now accept in List types of <? super Dog> you can still only\nadd type Dog to that list. This is created because its ok to add a Dog to List<Object>\n\n\n','What can you use to type a method parameter and still add to the collection','Generics',0,0,NULL,5),(1639,'this is fine\n\n\"Hey compiler, please accept any List with a generic type that is of type Dog or a supertype of Dog. \nNothing lower in the inheritance tree can come in, but anything higher than Dog is okay\"\n\nif you pass in a List of type Animal then it\'s perfectly fine to add a Dog to it. If you pass in a list of type Dog\nits still ok to add a Dog to it. if you pass in a list of type Object its still ok. \n\nHowever that doesn\'t give you the freedom to just add anything  you can still\nonly add the type after the super','public class Hello {\n    public static void main(String[] args){\n        List<Animal> animals = new ArrayList<Animal>();\n        animals.add(new Dog());\n        animals.add(new Animal());\n        \n        addAnimal(animals);\n        \n    \n    }\n    public static void addAnimal(List<? super Dog> animals) {\n	animals.add(new Dog());\n    }\n}','Generics',0,0,NULL,5),(1640,'will not compile incompatible types ','public class Hello {\n    public static void main(String[] args){\n        List<Animal> animals = new ArrayList<Animal>();\n        animals.add(new Dog());\n        animals.add(new Animal());\n        \n        addAnimal(animals);\n        \n    \n    }\n    public static void addAnimal(List<Object> animals) {\n	animals.add(new Dog());\n    }\n}','Generics',0,0,NULL,5),(1641,'','','Generics',0,0,NULL,5),(1642,'? will mean that any type of list can be passed to this method however nothing will be allowed to be added to it\n\n<Object> will mean that only lists of type Object can be passed to this method and \nyou will be able to add pretty much anything to that list. ','whats the difference between\n\npublic void foo(List<?> list){ }\npublic void foo(List<Object> list) { }','Generics',0,0,NULL,5),(1643,'class Bar compiles fine\n\nTest is the class that fails. ','public class TestWildcards {\n	psvm(sa) {\n		List<Integer> myList = new ArrayList<Integer>();\n		Bar bar = new Bar();\n		bar.doInsert(MyList);\n	}\n}\n\nclass Bar {\n	void doInsert(List<Object> list) {\n		list.add(new Dog();	\n	}\n}\n\nwhich class fails compilation here ?','Generics',0,0,NULL,5),(1644,'Bar','public class TestWildcards {\n	psvm(sa) {\n		List<Integer> myList = new ArrayList<Integer>();\n		Bar bar = new Bar();\n		bar.doInsert(MyList);\n	}\n}\n\nclass Bar {\n	void doInsert(List<?> list) {\n		list.add(new Dog();	\n	}\n}\n\nwhich class fails compilation here ?','Generics',0,0,NULL,5),(1645,'nothing they are identicle \n\nthey both say I can refer to any type of object. but you wont be able to addd to me. \n\nthis is very differenct from List<Object> ','whats the difference between \n\nList<?>\nList<? extends Object>','Generics',0,0,NULL,5),(1646,'1 2  and 5 compile ','1 List<?> list = new ArrayList<Dog>();\n2 List<? extends Animal> alist = new ArrayList<Dog>();\n3  List<?> foo = new ArrayList<? extends Animal>();\n4 List<? extends Dog> cList = new ArrayList<Integer>();\n5 List<? super Dog> dList = new ArrayList<Animal>();\n6 List<? super Animal elist = new ArrayList<Dog>();\n\n','Generics',0,0,NULL,5),(1647,'AutoCloseable()\nyou can call close() mulitple times and nothing will happen the second time and beyond. \n\nCloseable() is not, something could go wrong the second time','Which interface close() is idempotent ?','Generics',0,0,NULL,5),(1648,'public <T> void makeArrayList(T t){ }\n\nYou have to define the type variable BEFORE the return type of the method\n\n','declare a generic method:\n\npublic <T> void makeArrayList(T t){ }\n\npublic void makeArrayList(T t) { }\n\npublic void <T> makeArrayList(T t){\n}','Generics',0,0,NULL,5),(1649,'Will not compile \n\nNon static type variable cannot be referenced from static context. \n\nWhen T is defined for a new class it is appropriate for that instance there forfore static methods of that \nclass wont really know about the individualy typed instances. \n\nSingleton with generics doesn\'t make a whole lot of sense anyway....\n\npublic class SimpleSingleton {\nprivate Map<String, Object> counter = new HashMap<String, Object>();\n\npublic <T> T getInstance(Class<T> clazz) throws IllegalAccessException, InstantiationException {\n    T singleton = (T) counter.get(clazz.getName());\n    if (singleton == null) {\n        singleton = clazz.newInstance();\n        counter.put(clazz.getName(), singleton);\n    }\n    return singleton;\n}\n\n\nalso adding a Dog to an ArrayList typed for T will not compile \n','public class Hello<T> {\n    public static void main(String[] args){\n        Printer<String> x = Printer.getInstance();\n\n    }\n    public static void addAnimal(List<T> animals) {\n	animals.add(new Dog());\n    }\n    \n    public <G> ArrayList<G> makeArrayList(G g){\n        ArrayList<G> genlist = new ArrayList();\n        genlist.add(g);\n        return genlist;\n        \n    }\n}\n\nclass Printer<T> {\n    private ArrayList<T> joblist = new ArrayList<>();\n    private static Printer instance = null;\n    \n    protected Printer(){\n        \n    }\n    \n    public static Printer getInstance(){\n        if(instance == null){\n            instance = new Printer();\n            return instance;\n        }\n        \n        return instance;\n        \n    }\n    \n    public void addJob(T t){\n        joblist.add(t);\n    }\n}','Generics',1,0,NULL,5),(1650,'NullPointerException\n\ninstance in class Printer is never intitialized','public class Hello<T> {\n    public static void main(String[] args){\n        Printer<String> x = new Printer<>();\n        String y = x.instance;\n        System.out.println(y.length());\n\n    } \n    public <G> ArrayList<G> makeArrayList(G g){\n        ArrayList<G> genlist = new ArrayList();\n        genlist.add(g);\n        return genlist;\n        \n    }\n}\n\nclass Printer<T> {\n    private ArrayList<T> joblist = new ArrayList<>();\n    T instance;\n    \n    public Printer(){\n        \n    }\n    \n    public void addJob(T t){\n        joblist.add(t);\n    }\n    \n    public T getAnewT(){\n        return instance;\n    }\n}','Generics',0,0,NULL,5),(1651,'in the overloaded constructor T should be instance, remember a Type is an Object not an reference varialb.e','class Printer<T> {\n    private ArrayList<T> joblist = new ArrayList<>();\n    private T instance;\n    \n    public Printer(){\n        \n    }\n    \n    public Printer(T b){\n        T = b;\n    }\n    \n    public void addJob(T t){\n        joblist.add(t);\n    }\n    \n    public T getAnewT(){\n        return instance;\n    }\n}','Generics',0,0,NULL,5),(1652,'a Class will be created with a type that extends number','class Printer<T extends Number> {\n    private ArrayList<T> joblist = new ArrayList<>();\n    private T instance;\n    \n    public Printer(){\n        \n    }\n    \n    public Printer(T b){\n       instance = b;\n    }\n    \n    public void addJob(T t){\n        joblist.add(t);\n    }\n    \n    public T getAnewT(){\n        return instance;\n    }\n}','Generics',0,0,NULL,5),(1653,'will not compile, a type variable is needed here not a wildcard.\n\nWildcards are never used in generic class definitions','class Printer<? extends Number> {\n    private ArrayList<T> joblist = new ArrayList<>();\n    private T instance;\n    \n    public Printer(){\n        \n    }\n    \n    public Printer(T b){\n       instance = b;\n    }\n    \n    public void addJob(T t){\n        joblist.add(t);\n    }\n    \n    public T getAnewT(){\n        return instance;\n    }\n}','Generics',0,0,NULL,5),(1654,'Does not compile,\n\nyou cant use super when defining a generic class','class Printer<T super Beagle> {\n    private ArrayList<T> joblist = new ArrayList<>();\n    private T instance;\n    \n    public Printer(){\n        \n    }\n    \n    public Printer(T b){\n       instance = b;\n    }\n    \n    public void addJob(T t){\n        joblist.add(t);\n    }\n    \n    public T getAnewT(){\n        return instance;\n    }\n}\n\nclass Animal{}\nclass Dog extends Animal{}\nclass Beagle extends Dog{}','Generics',0,0,NULL,5),(1655,'fine,\n\nyou use extends when creating a generic class to specify bounds','class Printer<T extends Animal> {\n    private ArrayList<T> joblist = new ArrayList<>();\n    private T instance;\n    \n    public Printer(){\n        \n    }\n    \n    public Printer(T b){\n       instance = b;\n    }\n    \n    public void addJob(T t){\n        joblist.add(t);\n    }\n    \n    public void makeSound() {\n        instance.makeSound();\n    }\n    \n    public T getAnewT(){\n        return instance;\n    }\n}\n\nclass Animal{public void makeSound(){\n            System.out.println(\"Sound!\");\n}\n}\nclass Dog extends Animal{}\nclass Beagle extends Dog{}','Generics',0,0,NULL,5),(1656,'will not compile type argument string is not within bound of class Printer','public class Hello<T> {\n    public static void main(String[] args){\n        \n        Printer<String> x = new Printer<>();\n\n\n    } \n    public <G> ArrayList<G> makeArrayList(G g){\n        ArrayList<G> genlist = new ArrayList();\n        genlist.add(g);\n        return genlist;\n        \n    }\n}\n\nclass Printer<T extends Animal> {\n    private ArrayList<T> joblist = new ArrayList<>();\n    private T instance;\n    \n    public Printer(){\n        \n    }\n    \n    public Printer(T b){\n       instance = b;\n    }\n    \n    public void addJob(T t){\n        joblist.add(t);\n    }\n    \n    public void makeSound() {\n        instance.makeSound();\n    }\n    \n    public T getAnewT(){\n        return instance;\n    }\n}\n\nclass Animal{public void makeSound(){\n            System.out.println(\"Sound!\");\n}\n}\nclass Dog extends Animal{}\nclass Beagle extends Dog{}','Generics',0,0,NULL,5),(1657,'will not compile because of (Dog d)','public class Hello<T> {\n    public static void main(String[] args){\n\n        ArrayList x = makeArrayList(Dog d);\n        \n        ArrayList c = new ArrayList<String>();\n\n    } \n    public <G> ArrayList<G> makeArrayList(G g){\n        ArrayList<G> genlist = new ArrayList();\n        genlist.add(g);\n        return genlist;\n        \n    }\n}','Generics',0,0,NULL,5),(1658,'compiles fine.','public class Hello<T> {\n    public static void main(String[] args){\n        \n        Dog d = new Dog();\n        \n        ArrayList x = makeArrayList(d);\n        \n        ArrayList c = new ArrayList<String>();\n\n    } \n    public static <G> ArrayList<G> makeArrayList(G g){\n        ArrayList<G> genlist = new ArrayList();\n        genlist.add(g);\n        return genlist;\n        \n    }\n}','Generics',0,0,NULL,5),(1659,'neither Dog a nor stringa will compile. The Declared type of the arraylists is non generic so they return objects\n','public class Hello<T> {\n    public static void main(String[] args){\n        \n        Dog d = new Dog();\n        \n        ArrayList x = makeArrayList(d);\n        \n        ArrayList c = new ArrayList<String>();\n        c.add(\"quick string\");\n        \n        x.add(new Dog());\n        \n        Dog a = x.get(0);\n        String stringa = c.get(0);\n \n    } \n    public static <G> ArrayList<G> makeArrayList(G g){\n        ArrayList<G> genlist = new ArrayList();\n        genlist.add(g);\n        return genlist;\n        \n    }\n}','Generics',0,0,NULL,5),(1660,'compiles fine','public class Hello<T> {\n    public static void main(String[] args){\n        \n        Dog d = new Dog();\n        \n        ArrayList<Dog> c = makeArrayList(d);\n \n    } \n    public static <G> ArrayList<G> makeArrayList(G g){\n        ArrayList<G> genlist = new ArrayList();\n        genlist.add(g);\n        return genlist;\n        \n    }\n}','Generics',0,0,NULL,5),(1661,'compiles fine','public class Hello<T> {\n    public static void main(String[] args){\n        \n        Dog d = new Dog();\n        \n        ArrayList<Dog> c = makeArrayList(d);\n        \n        c.add(new Beagle());\n \n    } \n    public static <G extends Animal> ArrayList<G> makeArrayList(G g){\n        ArrayList<G> genlist = new ArrayList();\n        genlist.add(g);\n        return genlist;\n        \n    }\n}\n\n\nclass Animal{public void makeSound(){\n            System.out.println(\"Sound!\");\n}\n}\nclass Dog extends Animal{}\nclass Beagle extends Dog{}','Generics',0,0,NULL,5),(1662,'Compilation fails ? wildcard is not valid here you need a type varialbe istead','public class Hello<T> {\n    public static void main(String[] args){\n        \n        Dog d = new Dog();\n        \n        ArrayList<Dog> c = makeArrayList(d);\n \n    } \n    public static <? extends Animal> ArrayList<?> makeArrayList(? g){\n        ArrayList<?> genlist = new ArrayList();\n        genlist.add(g);\n        return genlist;\n        \n    }\n}','Generics',0,0,NULL,5),(1663,'compiles fine, \n\nyou can define ArrayLIsts this way, you wont be able to add anything to it though','public class Hello<T> {\n    public static void main(String[] args){\n        \n        Dog d = new Dog();\n        \n        ArrayList<?> c = makeArrayList(d);\n \n    } \n    public static <G extends Animal> ArrayList<G> makeArrayList(G g){\n        ArrayList<G> genlist = new ArrayList();\n        genlist.add(g);\n        return genlist;\n        \n    }\n}','Generics',0,0,NULL,5),(1664,'compilation fails','public class Hello<T> {\n    public static void main(String[] args){\n        \n        Dog d = new Dog();\n        \n        ArrayList<?> c = makeArrayList(d);\n        c.add(new Animal());\n    } \n    public static <G extends Animal> ArrayList<G> makeArrayList(G g){\n        ArrayList<G> genlist = new ArrayList();\n        genlist.add(g);\n        return genlist;\n        \n    }\n}','Generics',0,0,NULL,5),(1665,'does not compile because of H extends Beagle\n\nshould be ? extends Beagle','public class Hello<T> {\n    public static void main(String[] args){\n        \n        Dog d = new Dog();\n        \n        ArrayList<H extends Beagle> c = makeArrayList(d);\n        \n    } \n    public static <G extends Animal> ArrayList<G> makeArrayList(G g){\n        ArrayList<G> genlist = new ArrayList();\n        genlist.add(g);\n        return genlist;\n        \n    }\n}','Generics',0,0,NULL,5),(1666,'does not compile Beagle is the lowest type and nothing extends it,\n\nthe only type that would be acceptable here is a Beagle','public class Hello<T> {\n    public static void main(String[] args){\n        \n        Dog d = new Dog();\n        \n        ArrayList<? extends Beagle> c = makeArrayList(d);\n        \n    } \n    public static <G extends Animal> ArrayList<G> makeArrayList(G g){\n        ArrayList<G> genlist = new ArrayList();\n        genlist.add(g);\n        return genlist;\n        \n    }\n}\n\n\nclass Animal{public void makeSound(){\n            System.out.println(\"Sound!\");\n}\n}\nclass Dog extends Animal{}\nclass Beagle extends Dog{}','Generics',0,0,NULL,5),(1667,'compiles fine','public class Hello<T> {\n    public static void main(String[] args){\n        \n        Dog d = new Dog();\n        \n        ArrayList<? extends Animal> c = makeArrayList(d);\n        \n    } \n    public static <G extends Animal> ArrayList<G> makeArrayList(G g){\n        ArrayList<G> genlist = new ArrayList();\n        genlist.add(g);\n        return genlist;\n        \n    }\n}\n\n\nclass Animal{public void makeSound(){\n            System.out.println(\"Sound!\");\n}\n}\nclass Dog extends Animal{}\nclass Beagle extends Dog{}','Generics',0,0,NULL,5),(1668,'\n\nPECS (short for \"Producer extends and Consumer super\") can be explained by : Get and Put Principle\nGet And Put Principle (From Java Generics and Collections)\n\nIt states,\n\n    use an extends wildcard when you only get values out of a structure\n    use a super wildcard when you only put values into a structure\n    and don’t use a wildcard when you both get and put.\n\nLet\'s understand it by example:\n\n1. For Extends Wildcard(get values i.e Producer extends)\n\nHere is a method, that takes a collection of numbers, converts each to a double, and sums them up\n\npublic static double sum(Collection<? extends Number> nums) {\n   double s = 0.0;\n   for (Number num : nums) \n      s += num.doubleValue();\n   return s;\n}\n\nLet\'s call the method :\n\nList<Integer>ints = Arrays.asList(1,2,3);\nassert sum(ints) == 6.0;\nList<Double>doubles = Arrays.asList(2.78,3.14);\nassert sum(doubles) == 5.92;\nList<Number>nums = Arrays.<Number>asList(1,2,2.78,3.14);\nassert sum(nums) == 8.92;\n\nSince, sum() method uses extends, all of the following calls are legal. The first two calls would not be legal if extends was not used.\n\nEXCEPTION : You cannot put anything into a type declared with an extends wildcard—except for the value null, which belongs to every reference type:\n\nList<Integer> ints = new ArrayList<Integer>();\nints.add(1);\nints.add(2);\nList<? extends Number> nums = ints;\nnums.add(null);  // ok\nassert nums.toString().equals(\"[1, 2, null]\");\n\n2. For Super Wildcard(put values i.e Consumer super)\n\nHere is a method, that takes a collection of numbers and an int n, and puts the first n integers, starting from zero, into the collection:\n\npublic static void count(Collection<? super Integer> ints, int n) {\n    for (int i = 0; i < n; i++) ints.add(i);\n}\n\nLet\'s call the method :\n\nList<Integer>ints = new ArrayList<Integer>();\ncount(ints, 5);\nassert ints.toString().equals(\"[0, 1, 2, 3, 4]\");\nList<Number>nums = new ArrayList<Number>();\ncount(nums, 5); nums.add(5.0);\nassert nums.toString().equals(\"[0, 1, 2, 3, 4, 5.0]\");\nList<Object>objs = new ArrayList<Object>();\ncount(objs, 5); objs.add(\"five\");\nassert objs.toString().equals(\"[0, 1, 2, 3, 4, five]\");\n\nSince, count() method uses super, all of the following calls are legal: The last two calls would not be legal if super was not used.\n\nEXCEPTION : you cannot get anything out from a type declared with a super wildcard—except for a value of type Object, which is a supertype of every reference type:\n\nList<Object> objs = Arrays.<Object>asList(1,\"two\");\nList<? super Integer> ints = objs;\nString str = \"\";\nfor (Object obj : ints) str += obj.toString();\nassert str.equals(\"1two\");\n\n3. When both Get and Put, don\'t Use wildcard\n\nWhenever you both put values into and get values out of the same structure, you should not use a wildcard.\n\npublic static double sumCount(Collection<Number> nums, int n) {\n   count(nums, n);\n   return sum(nums);\n}\n\n','PECS','Generics',0,0,NULL,5),(1669,'PECS\n\nproducers extends consumers super','public class Hello<T> {\n    \n    public static void main(String[] args){\n        \n        Dog d = new Dog();\n        \n        ArrayList<? extends Animal> c = new ArrayList<Beagle>();\n        \n        c.add(new Beagle()); // does not compile\n        c.add(new Beagle()); // does not compile\n        \n        Animal a = c.get(0);\n    } ','Generics',0,0,NULL,5),(1670,'does not compile because of Beagle a = c.get(0);','public class Hello<T> {\n    \n    public static void main(String[] args){\n        \n        Dog d = new Dog();\n        \n        ArrayList<? super Beagle> c = new ArrayList<Beagle>();\n        \n        c.add(new Beagle());\n        c.add(new Beagle()); \n        \n        Beagle a = c.get(0);\n    } ','Generics',0,0,NULL,5),(1671,'compiles fine','public class Hello<T> {\n    \n    public static void main(String[] args){\n        \n        Dog d = new Dog();\n        \n        ArrayList<Dog> c = makeArrayList(d);\n        \n        c.add(new Beagle());\n        c.add(new Beagle()); \n\n    } \n    public static <G extends Animal> ArrayList<G> makeArrayList(G g){\n        ArrayList<G> genlist = new ArrayList<>();\n        genlist.add(g);\n        return genlist;\n        \n    }\n}','Generics',0,0,NULL,5),(1672,'compiles fine','public class Hello<T> {\n    \n    public static void main(String[] args){\n        \n        Dog d = new Dog();\n        \n        ArrayList<Dog> c = makeArrayList(new Beagle());\n        \n        c.add(new Beagle());\n        c.add(new Beagle()); \n\n    } \n    public static <G extends Animal> ArrayList<G> makeArrayList(G g){\n        ArrayList<G> genlist = new ArrayList<>();\n        genlist.add(g);\n        return genlist;\n        \n    }\n}','Generics',0,0,NULL,5),(1673,'comilation fails\n\nArrayLIst<Animal> cannot be applied to ArrayList<Dog>','public class Hello<T> {\n    \n    public static void main(String[] args){\n        \n        Dog d = new Dog();\n        \n        ArrayList<Dog> c = makeArrayList(new Animal());\n        \n        c.add(new Beagle());\n        c.add(new Beagle()); \n\n    } \n    public static <G extends Animal> ArrayList<G> makeArrayList(G g){\n        ArrayList<G> genlist = new ArrayList<>();\n        genlist.add(g);\n        return genlist;\n        \n    }\n}','Generics',0,0,NULL,5),(1674,'comiles fine','\npublic class Hello<T> {\n    \n    public static void main(String[] args){\n        \n        Dog d = new Dog();\n        \n        ArrayList<?> c = makeArrayList(new Animal());\n        \n\n    } \n    public static <G extends Animal> ArrayList<G> makeArrayList(G g){\n        ArrayList<G> genlist = new ArrayList<>();\n        genlist.add(g);\n        return genlist;\n        \n    }\n}','Generics',0,0,NULL,5),(1675,'','public class Test {\n\n    public class A {}\n\n    public class B extends A {}\n\n    public class C extends B {}\n\n    public void testCoVariance(List<? extends B> myBlist) {\n        B b = new B();\n        C c = new C();\n        myBlist.add(b); // does not compile\n        myBlist.add(c); // does not compile\n        A a = myBlist.get(0); \n    }\n\n    public void testContraVariance(List<? super B> myBlist) {\n        B b = new B();\n        C c = new C();\n        myBlist.add(b);\n        myBlist.add(c);\n        A a = myBlist.get(0); // does not compile\n    }\n}','Generics',0,0,NULL,5),(1676,'\n\nJosh Bloch\'s mnemonic PECS is useful here. It stands for:\n\nProducer extends, Consumer super\n\nThis means that when a parameterized type being passed to a method will produce instances of T (they will be retrieved from it in some way), ? extends T should be used, since any instance of a subclass of T is also a T.\n\nWhen a parameterized type being passed to a method will consume instances of T (they will be passed to it to do something), ? super T should be used because an instance of T can legally be passed to any method that accepts some supertype of T. A Comparator<Number> could be used on a Collection<Integer>, for example. ? extends T would not work, because a Comparator<Integer> could not operate on a Collection<Number>.\n\nEdit: To clarify a little more on get/put (produce/consume):\n\npublic T something();\n       ^\n\nThe above is a method that produces T.\n\npublic void something(T t);\n                      ^\n\nThe above is a method that consumes T.\n\n\"Producer extends, Consumer super\" applies to how the method a parameterized object is being passed to is going to be using that object. In the case of Collections.max(), items will be retrieved from the Collection, so it is a producer. Those items will be passed as arguments to the method on Comparator, so it is a consumer.\n','PECS','Generics',0,0,NULL,5),(1677,'','/ Source \n       List<Integer> intList = Arrays.asList(1,2,3);\n       List<Double> doubleList = Arrays.asList(2.78,3.14);\n       List<Number> numList = Arrays.asList(1,2,2.78,3.14,5);\n\n       // Destination\n       List<Integer> intList2 = new ArrayList<>();\n       List<Double> doublesList2 = new ArrayList<>();\n       List<Number> numList2 = new ArrayList<>();\n\n        // Works\n        copyElements1(intList,intList2);         // from int to int\n        copyElements1(doubleList,doublesList2);  // from double to double\n\n\n     static <T> void copyElements1(Collection<T> src, Collection<T> dest) {\n        for(T n : src){\n            dest.add(n);\n         }\n      }\n\n\n     // Let\'s try to copy intList to its supertype\n     copyElements1(intList,numList2); // error, method signature just says \"T\"\n                                      // and here the compiler is given \n                                      // two types: Integer and Number, \n                                      // so which one shall it be?\n\n     // PECS to the rescue!\n     copyElements2(intList,numList2);  // possible\n\n\n\n    // copy Integer (? extends T) to its supertype (Number is super of Integer)\n    private static <T> void copyElements2(Collection<? extends T> src, \n                                          Collection<? super T> dest) {\n        for(T n : src){\n            dest.add(n);\n        }\n    }','Generics',0,0,NULL,5),(1678,'does not compile Collection<G> is given two different types here\n\nalso a and b were not initialized, that is ok to do with instance variables\nbut not locals \n\nyou could say \n\nArrayList<Animal> a = null;\nand same for b;','public class Hello<T> {\n    \n    public static void main(String[] args){\n        ArrayList<Animal> a;\n        ArrayList<Beagle> b;\n        \n        Hello<String> x = new Hello<>();\n        \n        x.copyColl(a,b);\n        \n\n    } \n    public <G> void copyColl(Collection<G> src, Collection<G> dest){\n        \n        for(G n : src)\n            dest.add(n);\n        \n    }\n}','Generics',0,0,NULL,5),(1679,'compiles fine','public class Hello<T> {\n    \n    public static void main(String[] args){\n        ArrayList<Dog> a = new ArrayList<>();\n        ArrayList<Dog> b = new ArrayList<>();\n        \n        Hello<String> x = new Hello<>();\n        \n        x.copyColl(a,b);\n        \n\n    } \n    public <G extends Animal> void copyColl(Collection<G> src, Collection<G> dest){\n        \n        for(G n : src)\n            dest.add(n);\n        \n    }\n}','Generics',0,0,NULL,5),(1680,'does not compile \n\nyou cant add to a collection declared with wildcard extends','public class Hello<T> {\n    \n    public static void main(String[] args){\n        ArrayList<Dog> a = new ArrayList<>();\n        ArrayList<Dog> b = new ArrayList<>();\n        \n        Hello<String> x = new Hello<>();\n        \n        \n        \n        x.copyColl(a,b);\n        \n\n    } \n    public <G extends Animal> void copyColl(Collection<G> src, Collection<? extends G> dest){\n        \n        for(G n : src)\n            dest.add(n);\n        \n    }\n}','Generics',0,0,NULL,5),(1681,'compiles fine','public class Hello<T> {\n    \n    public static void main(String[] args){\n        ArrayList<Dog> a = new ArrayList<>();\n        ArrayList<Dog> b = new ArrayList<>();\n        \n        Hello<String> x = new Hello<>();\n        \n        \n        \n        x.copyColl(a,b);\n        \n\n    } \n    public <G extends Animal> void copyColl(Collection<G> src, Collection<? super G> dest){\n        \n        for(G n : src)\n            dest.add(n);\n        \n    }\n}','Generics',0,0,NULL,5),(1682,'will not compiile at x.copyColl','public class Hello<T> {\n    \n    public static void main(String[] args){\n        ArrayList<Animal> a = new ArrayList<>();\n        ArrayList<Dog> b = new ArrayList<>();\n        \n        Hello<String> x = new Hello<>();\n        \n        \n        \n        x.copyColl(a,b);\n        \n\n    } \n    public <G extends Animal> void copyColl(Collection<? extends G> src, Collection<? super G> dest){\n        \n        for(G n : src)\n            dest.add(n);\n        \n    }\n}','Generics',0,0,NULL,5),(1683,'compiles fine\n\nyou can easily take a beagle and add it to an Animal array','public class Hello<T> {\n    \n    public static void main(String[] args){\n        ArrayList<Beagle> a = new ArrayList<>();\n        ArrayList<Animal> b = new ArrayList<>();\n        \n        Hello<String> x = new Hello<>();\n        \n        \n        \n        x.copyColl(a,b);\n        \n\n    } \n    public <G extends Animal> void copyColl(Collection<? extends G> src, Collection<? super G> dest){\n        \n        for(G n : src)\n            dest.add(n);\n        \n    }\n}','Generics',0,0,NULL,5),(1684,'','','blank',0,0,NULL,5),(1685,'','','blank',0,0,NULL,5),(1686,'','','blank',0,0,NULL,5),(1687,'','','blank',0,0,NULL,5),(1688,'','','blank',0,0,NULL,5),(1689,'public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs)\nthrows IOException {\n	sout( dir );\n	return FileVisitResult.CONTINUE;\n}\n\npublic FileVisitResult postVisitDirectory(Path dir, IOException e)\nthrows IOException {\n	sout( dir );\n	return FileVisitResult.CONTINUE;\n}\n\n**VisitFile is called only for Files and not directories','public class Visit extends SimpleFileVisitor<Path> {\n\n	//insert here\n\n   public static void main(String[] args) throws Exception {\n	Visit v = new Visit();\n	Files.walkFileTree(Paths.get(\"/mydir\"),v);\n   }\n}\n\nwhat inserted here will print out the provided directory and all \nsubdirectories ?\n\n\n','IO',0,0,NULL,5),(1690,'','','blank',0,0,NULL,5),(1691,'','','blank',0,0,NULL,5),(1692,'r1\nr4\npre \nb1\nb2\nr3\nr2\nhawk\n\nstatic init blocks run at class loading time. Instance init blocks run after\nthe constructors call to super()','class Bird {	\n	{ System.out.println(\"b1\"); }	\n	public Bird() { System.out.println(\"b2\"); }\n}\n\nclass Raptor extends Bird {\n	static {System.out.println(\"r1\"); }\n	public Raptor() { System.out.println(\"r2\"); }\n	{ System.out.println(\"r3\"); }\n	static { System.out.println(\"r4\"); }\n}\npublic class Hello extends Raptor {\n\n    public static void main(String[] args) {\n        System.out.println(\"pre \");\n        new Hello();\n        System.out.println(\"hawk\");\n    }\n}\n		','OOP',0,0,NULL,5),(1693,'BasicFileAttributeView baView = Files.getFileAttributeView(d,BasicFileAttributeView.class);','public static void makeFileCreatedOnMonday(Path d) throws IOException{\n        BasicFileAttributes ba = Files.readAttributes(d, BasicFileAttributes.class);\n        Calendar c = Calendar.getInstance();\n        //BasicFileAttributeView baView = Files.readAttributeView(d,BasicFileAttributes.class)\n        //BasicFileAttributeView baView = Files.getBasicAttributeView(d,BasicFileAttributes.class);\n        //BasicFileAttributeView baView = Files.getFileAttributeView(d,BasicFileAttributes.class);\n        //BasicFileAttributeView baView = Files.getFileAttributeView(d,BasicFileAttributeView.class);\n        \n	//void setTimes(FileTime lastModifiedTime,FileTime lastAccessTime,FileTime createTime)\n        \n        Date creationDate = new Date(ba.creationTime().toMillis());\n        c.setTime(creationDate);\n        \n        if(c.get(Calendar.DAY_OF_WEEK) == Calendar.MONDAY){\n            baView.setTimes(null,null,null);\n        } else {\n            //other fields are retained\n            c.set(Calendar.DAY_OF_WEEK,Calendar.MONDAY);\n            FileTime newDay = FileTime.fromMillis(c.getTimeInMillis());\n            \n            baView.setTimes(null,null,newDay);\n        }\n        \n    }\n\nHow do you create a FileAttributeView ?','Strings',0,0,NULL,5),(1694,'','','blank',0,0,NULL,5),(1695,'compiles with warnings \n\nthe problems will arrise down the road when you get that dog out of a supposedly Integer array. ','psvm(SA){\n	List<Integer> list = new ArrayLIst<>();\n	list.add(5); //autoboxing\n	foo( list );\n}\n\nstatic void foo(List alist) {\n	alist.add(new Dog(\"Charly\"));\n}','Generics',0,0,NULL,5),(1696,'','Generic type information does not exist at runtime - it is for compile-time safetly only.\nMixing generics with legacy code can create compiled code that may throw an excecption at runtime. ','Generics',0,0,NULL,5),(1697,'','polymorphic assingment rules apply everywhere an assignment can be made for generics,\n\nthe following are not allowed:\n	\n	void foo(List<Animal> alist {  }  //cannot take a List<Dog>\n\n	List<Animal> bar() {  }  // cannot return a List<Dog>','Generics',0,0,NULL,5),(1698,'compiles fine','class Animal{\n    public void makeSound() throws InterruptedException {\n            System.out.println(\"Sound!\");\n    }\n}\nclass Dog extends Animal{\n    public void makeSound() throws InterruptedException {\n        System.out.println(\"Bark!\");\n        \n    }\n}\nclass BullDog extends Dog{\n    public void makeSound() throws InterruptedException {\n        System.out.println(\"Grumble!\");\n    }\n}','Generics',0,0,NULL,5),(1699,'BullDog does not compile, Dog\'s makeSound chose not to throw the exception but then when BullDog chose \nto override it didn\'t know that Animal used to throw that exception. ','class Animal{\n    public void makeSound() throws InterruptedException {\n            System.out.println(\"Sound!\");\n    }\n}\nclass Dog extends Animal{\n    public void makeSound(){\n        System.out.println(\"Bark!\");\n        \n    }\n}\nclass BullDog extends Dog{\n    public void makeSound() throws InterruptedException {\n        System.out.println(\"Grumble!\");\n    }\n}','General',0,0,NULL,5),(1700,'does not compile because you cannot return an Animal list from a method declaring a return statemnt\nof Dog list','public class Hello<T> {\n    \n    public static void main(String[] args){\n      Hello<?> x = new Hello<>();\n      \n      List<?> readonlylist = x.dogs();\n      List<?> readonlyanimallist = x.animals();\n        \n\n    } \n    public ArrayList<Animal> animals(){\n        ArrayList<Animal> vetlist = new ArrayList<>();\n        vetlist.add(new Animal());\n        vetlist.add(new BullDog());\n        vetlist.add(new BullDog());\n        vetlist.add(new Dog());\n        vetlist.add(new Animal());\n        \n        return vetlist;\n  \n    }\n    \n    public ArrayList<Dog> dogs(){\n        ArrayList<Animal> vetlist = new ArrayList<>();\n        vetlist.add(new Dog());\n        vetlist.add(new BullDog());\n        vetlist.add(new BullDog());\n        vetlist.add(new Dog());\n        vetlist.add(new Dog());\n\n        return vetlist;\n    }','Generics',0,0,NULL,5),(1701,'','Wildcard syntax allows a generic method to accept subtypes or supertypes of the declared type\nof the method argument.\n\n	void addD(List<Dog> d) {  } //can take only <Dog>\n	\n	void addD(List<? extends Dog>) { } //take a <Dog> or <Beagle>','Generics',0,0,NULL,5),(1702,'','The wildcard keyword \'extends\' is used to mean either \" extends \" or \"implements\" \n\nso in <? extends Dog> Dog can be a class or interface. ','Generics',0,0,NULL,5),(1703,'','When using a wildcard List<? extends Dog>, the collection can be accessed but not modified','Generics',0,0,NULL,5),(1704,'','When using a wildcard List<?> any generic type can be assigned to the reference, but for access only\nno modifications.','Generics',0,0,NULL,5),(1705,'','List<Object> refers only to a List<Object>, while List<?> or List<? extends Object> can hold \nany type of object, but for access only. \n\n','Generics',0,0,NULL,5),(1706,'got it ','The generic type identifier can be used in class, method, and variable declarations:\n\n	class Foo<t> { }\n	T anInstance;\n	Foo(T aRef) { } // a constructor argument\n	void bar(T aRef) {  }	//method argument\n	T baz() { }	//return type','Generics',0,0,NULL,5),(1707,'','You can declare a generic method using a type not defined in the class:\n	\n	public <T> void makeList(T t) { }\n\n\n    This is not using T as a return type. This method has a void return type, but to use T within the argument you must declare the <T>\n	which happens before the return type. ','Generics',0,0,NULL,5),(1708,'List<List<Integer>> table = new ArrayList<>();\n\nList<List<Integer>> table = new ArrayList<List<Integer>>();\n\n	not this:\n		List<List<Integer>> superlist1 = new ArrayList<ArrayList<Integer>>();\n\n	.... incompatible types','psvm(SA){\n	for(int i = 0; i<= 10; i++) {\n		List<Integer> row = new ArrayList<>();\n		for (int j = 0; j<= 10; j++)\n		         row.add(i*j);\n		table.add(row);\n	}\n	for(List<Integer> row : table)\n		sout(row);\n}\n\ndefine table','Generics',0,0,NULL,5),(1709,'2 is true because often two dissiimilar objects can return the same hashcode value.\n\n4 is true because if the hashCode() comparison == returns true, might or might not be equal. \n\n3 is incorrect because often two dissimilar objects can return the same hashcode value. \n\n1 and 5 are a negation of the equals and hashCode() contract','Which statements are true about comparing two instances of the same class \ngiven that equals() and hashCode() have been properly overriden\n\n1 if the equals() returns true, the hashCode() comparison == might return false\n\n2 if the equals() returns false, the hashCode() comparison == might return true\n\n3 if the hashCode() comparison == returns true, the equals() method must return true\n\n4 if the hashCode() comparison == returns true, the equals() method might return true\n\n5 if the hashCode() comparison != returns true, the equals() method might return true','Generics',0,0,NULL,5),(1710,'got it\n','IF TWO OBJECTS ARE EQUAL ACCORDING TO THE EQUALS(OBJECT) METHOD, THE CALLING THE HASHCODE()\nMETHOD ON EACH OF THE TWO OBJECT MUST PRODUCE THE SAME INTEGER RESULT. ','Generics',0,0,NULL,5),(1711,'','It is not required that if two object are unequal according to the dquals method, the calling the hashCode()\non each of the two objects must produce distinct integer results. ','Generics',0,0,NULL,5),(1712,'ClassCastException','public static void before() {\n	Set set = new TreeSet();\n	set.add(\"2\");\n	set.add(3);\n	set.add(\"1);\n	Iterator it = set.iterator();\n		while(it.hasNext() )\n	sout( it.next() );\n}\n','Generics',0,0,NULL,5),(1713,'Change Herbivore interface to\n	\n	 interface Herbivore<E extends Animal> extends Hungry<E> { }','interface Hungry<E> { void munch(E x); }\ninterface Carnivore<E extends Animal> extends Hungry<E> { }\ninterface Herbivore<E extends Plant> extends Hungry<E> { }\nabstract class Plant { }\nabstract class Animal { }\nclass Grass extends Plant { }\nclass Sheep extends Animal implements Herbivore<Sheep> {\n    public void munch (Sheep x){ }\n}\nclass Wolf extends Animal implements Carnivore<Sheep> {\n    public void munch(Sheep x) { }\n}\n\nwhat can you change to make this compile','Generics',0,0,NULL,5),(1714,'Sheep does not compile,\n\n	Sheep is not abstract and does not override abstract method munch(Plant) in Hungry','interface Hungry<E> { void munch(E x); }\ninterface Carnivore<E extends Animal> extends Hungry<E> { }\ninterface Herbivore<E extends Plant> extends Hungry<E> { }\nabstract class Plant { }\nabstract class Animal { }\nclass Grass extends Plant { }\nclass Sheep extends Animal implements Herbivore<Plant> {\n    public void munch (Sheep x){ }\n}\nclass Wolf extends Animal implements Carnivore<Sheep> {\n    public void munch(Sheep x) { }\n}','Generics',0,0,NULL,5),(1715,'compiles and runs no problem','public class Hello<T> {\n  public static void main(String[] args){\n      Sheep bella = new Sheep();\n      \n      bella.munch(new Grass());\n      \n  }\n      \n}\n\ninterface Hungry<E> { void munch(E x); }\ninterface Carnivore<E extends Animal> extends Hungry<E> { }\ninterface Herbivore<E extends Plant> extends Hungry<E> { }\nabstract class Plant { }\nabstract class Animal { }\nclass Grass extends Plant { }\nclass Sheep extends Animal implements Herbivore<Plant> {\n    public void munch (Plant x){ }\n}\nclass Wolf extends Animal implements Carnivore<Sheep> {\n    public void munch(Sheep x) { }\n}','Generics',0,0,NULL,5),(1716,'The variable c of type ArrayList<? super Beagle> could possibly hold an instance of \nArrayList<Beagle>, ArrayList<Dog>, ArrayList<Animal>, or ArrayList<Object>.\n If it happened to be set to an ArrayList<Beagle>, it would violate the generic type to add a Dog to it.\n The compiler can\'t track what you actually assign to the ArrayList<? super Beagle> variable over the course of the program, \nso it assumes the worst and prevents the possible type safety violation. ','public class Hello<T> {\n\n   public static void main(String[] args){\n\n    Dog d = new Dog();\n\n    ArrayList<? super Beagle> c = makeArrayList(d);\n\n    c.add(new Beagle());\n    c.add(new Beagle());\n    c.add(new Dog());    \n  } \n\n  public static <G extends Animal> ArrayList<G> makeArrayList(G g){\n    ArrayList<G> genlist = new ArrayList<>();\n    genlist.add(g);\n    return genlist;\n\n }\n}\n\n\nclass Animal{public void makeSound(){\n        System.out.println(\"Sound!\");\n }\n}   \n class Dog extends Animal{}\nclass Beagle extends Dog{}','Generics',0,0,NULL,5),(1717,'For example, if the department of motor vehicles supplies a list of drivers to the census bureau, this seems reasonable. We think that a List<Driver> is a List<Person>, assuming that Driver is a subtype of Person. In fact, what is being passed is a copy of the registry of drivers. Otherwise, the census bureau could add new people who are not drivers into the list, corrupting the DMV\'s records.','Let\'s test your understanding of generics. Is the following code snippet legal?\n\nList<String> ls = new ArrayList<String>(); // 1\nList<Object> lo = ls; // 2 \n\nLine 1 is certainly legal. The trickier part of the question is line 2. This boils down to the question: is a List of String a List of Object. Most people instinctively answer, \"Sure!\"\n\nWell, take a look at the next few lines:\n\nlo.add(new Object()); // 3\nString s = ls.get(0); // 4: Attempts to assign an Object to a String!\n\nHere we\'ve aliased ls and lo. Accessing ls, a list of String, through the alias lo, we can insert arbitrary objects into it. As a result ls does not hold just Strings anymore, and when we try and get something out of it, we get a rude surprise.\n\nThe Java compiler will prevent this from happening of course. Line 2 will cause a compile time error.\n\nIn general, if Foo is a subtype (subclass or subinterface) of Bar, and G is some generic type declaration, it is not the case that G<Foo> is a subtype of G<Bar>. This is probably the hardest thing you need to learn about generics, because it goes against our deeply held intuitions.\n\nWe should not assume that collections don\'t change. Our instinct may lead us to think of these things as immutable.','Generics',0,0,NULL,5),(1718,'static <T> void fromArrayToCollection(T[] a, Collection<T> c) {\n    for (T o : a) {\n        c.add(o); // Correct\n    }\n}','static void fromArrayToCollection(Object[] a, Collection<?> c) {\n    for (Object o : a) { \n        c.add(o); // compile-time error\n    }\n}\n\nfix this with a generic method....','Generics',0,0,NULL,5),(1719,'','\n\nNo, a List<Dog> is not a List<Animal>. Consider what you can do with a List<Animal> - you can add any animal to it... including a cat. Now, can you logically add a cat to a litter of puppies? Absolutely not.\n\n// Illegal code - because otherwise life would be Bad\nList<Dog> dogs = new ArrayList<Dog>(); // ArrayList implements List\nList<Animal> animals = dogs; // Awooga awooga\nanimals.add(new Cat());\nDog dog = dogs.get(0); // This should be safe, right?\n\nSuddenly you have a very confused cat.\n\nNow, you can\'t add a Cat to a List<? extends Animal> because you don\'t know it\'s a List<Cat>. \nYou can retrieve a value and know that it will be an Animal, but you can\'t add arbitrary animals. \nThe reverse is true for List<? super Animal> - in that case you can add an Animal to it safely, but you don\'t know anything about what might be retrieved from it, because it could be a List<Object>.\n','Generics',0,0,NULL,5),(1720,'compiles fine...\n\nHerbivore<Plant> extends Hungry<Plant> works because the type is a parameter just like the formal \nparameters. So it is not necessary that a subinterface has the same parameters as long as its indicated that\nit does in fact take a type parameter. \n\nIn a nutshell, generics enable types (classes and interfaces) to be parameters when defining classes, interfaces and methods. Much like the more familiar formal parameters used in method declarations, type parameters provide a way for you to re-use the same code with different inputs. The difference is that the inputs to formal parameters are values, while the inputs to type parameters are types.\n\nits the same reason why List<E>, an interface, has to be the same as = new ArrayList<E> but not the \nsame as all other Lists\n\nList<String> list = new ArrayList<String>();\n	\n	ArrayList implements List just like Herbivore extends Hungry.','public class Hello<T> {\n  public static void main(String[] args){\n      Sheep bella = new Sheep();\n      \n  }\n      \n}\n\ninterface Hungry<E> { void munch(E x); }\ninterface Carnivore<E extends Animal> extends Hungry<E> { }\ninterface Herbivore<Plant> extends Hungry<Plant> { }\nabstract class Plant { }\nabstract class Animal { }\nclass Grass extends Plant { }\nclass Sheep extends Animal implements Herbivore<Grass> {\n    public void munch (Grass x){ }\n}\nclass Wolf extends Animal implements Carnivore<Sheep> {\n    public void munch(Sheep x) { }\n}','Generics',0,0,NULL,5),(1721,'','Raw Types\n\nA raw type is the name of a generic class or interface without any type arguments. For example, given the generic Box class:\n\npublic class Box<T> {\n    public void set(T t) { /* ... */ }\n    // ...\n}\n\nTo create a parameterized type of Box<T>, you supply an actual type argument for the formal type parameter T:\n\nBox<Integer> intBox = new Box<>();\n\nIf the actual type argument is omitted, you create a raw type of Box<T>:\n\nBox rawBox = new Box();\n\nTherefore, Box is the raw type of the generic type Box<T>. However, a non-generic class or interface type is not a raw type.\n\nRaw types show up in legacy code because lots of API classes (such as the Collections classes) were not generic prior to JDK 5.0. When using raw types, you essentially get pre-generics behavior — a Box gives you Objects. For backward compatibility, assigning a parameterized type to its raw type is allowed:\n\nBox<String> stringBox = new Box<>();\nBox rawBox = stringBox;               // OK\n\nBut if you assign a raw type to a parameterized type, you get a warning:\n\nBox rawBox = new Box();           // rawBox is a raw type of Box<T>\nBox<Integer> intBox = rawBox;     // warning: unchecked conversion\n\nYou also get a warning if you use a raw type to invoke generic methods defined in the corresponding generic type:\n\nBox<String> stringBox = new Box<>();\nBox rawBox = stringBox;\nrawBox.set(8);  // warning: unchecked invocation to set(T)\n\nThe warning shows that raw types bypass generic type checks, deferring the catch of unsafe code to runtime. Therefore, you should avoid using raw types.','Generics',0,0,NULL,5),(1722,'compiles fine \n\ngeneric typed objects can be assigned to raw types.','class Driver<E>{\n    \n}\nabstract class Auto{}\nclass Truck extends Auto{}\nclass Car extends Auto{}\n\npublic class Hello<T> {\n  public static void main(String[] args){\n      Driver<Truck> truckdriver = new Driver<>();\n      Driver untypeddriver = truckdriver;\n      \n      List biglist = new ArrayList<String>();\n      \n  }\n      \n}','Generics',0,0,NULL,5),(1723,'compiles fine, raw type reerences that are assinged to typed objects still take objects.','public class Hello<T> {\n  public static void main(String[] args){\n      \n      List biglist = new ArrayList<String>();\n      \n      biglist.add(8);\n      biglist.add(\"bigdick\");\n      \n  }\n      \n}','Generics',0,0,NULL,5),(1724,'compiles fine,  but you can still add anything to biglist','public class Hello<T> {\n  public static void main(String[] args){\n      Driver<Truck> truckdriver = new Driver<>();\n      Driver untypeddriver = truckdriver;\n      \n      List biglist = new ArrayList<Driver<Truck>>();\n      \n      biglist.add(8);\n      biglist.add(\"bigdick\");\n      \n  }\n      \n}','Generics',0,0,NULL,5),(1725,'fine','public class Hello {\n  public static void main(String[] args){\n      Driver<Truck> truckdriver = new Driver();\n      \n      testmethod(new Driver<Truck>());   \n  }\n  \n  public static void testmethod(Object x){\n      // do something\n  }\n      \n}','Generics',0,0,NULL,5),(1726,' You can subtype a generic class or interface by extending or implementing it. The relationship between the type parameters of one class or interface and the type parameters of another are determined by the extends and implements clauses.\n\nUsing the Collections classes as an example, ArrayList<E> implements List<E>, and List<E> extends Collection<E>. So ArrayList<String> is a subtype of List<String>, which is a subtype of Collection<String>. So long as you do not vary the type argument, the subtyping relationship is preserved between the types.\ndiagram showing a sample collections hierarchy: ArrayList<String> is a subtype of List<String>, which is a subtype of Collection<String>.\nA sample Collections hierarchy\n\nNow imagine we want to define our own list interface, PayloadList, that associates an optional value of generic type P with each element. Its declaration might look like:\n\ninterface PayloadList<E,P> extends List<E> {\n  void setPayload(int index, P val);\n  ...\n}\n\nThe following parameterizations of PayloadList are subtypes of List<String>:\n\n    PayloadList<String,String>\n    PayloadList<String,Integer>\n    PayloadList<String,Exception>\n','Generic Classes and Subtyping','Generics',0,0,NULL,5),(1727,' As you already know, it is possible to assign an object of one type to an object of another type provided that the types are compatible. For example, you can assign an Integer to an Object, since Object is one of Integer\'s supertypes:\n\nObject someObject = new Object();\nInteger someInteger = new Integer(10);\nsomeObject = someInteger;   // OK\n\nIn object-oriented terminology, this is called an \"is a\" relationship. Since an Integer is a kind of Object, the assignment is allowed. But Integer is also a kind of Number, so the following code is valid as well:\n\npublic void someMethod(Number n) { /* ... */ }\n\nsomeMethod(new Integer(10));   // OK\nsomeMethod(new Double(10.1));   // OK\n\nThe same is also true with generics. You can perform a generic type invocation, passing Number as its type argument, and any subsequent invocation of add will be allowed if the argument is compatible with Number:\n\nBox<Number> box = new Box<Number>();\nbox.add(new Integer(10));   // OK\nbox.add(new Double(10.1));  // OK\n\nNow consider the following method:\n\npublic void boxTest(Box<Number> n) { /* ... */ }\n\nWhat type of argument does it accept? By looking at its signature, you can see that it accepts a single argument whose type is Box<Number>. But what does that mean? Are you allowed to pass in Box<Integer> or Box<Double>, as you might expect? The answer is \"no\", because Box<Integer> and Box<Double> are not subtypes of Box<Number>.\n\nThis is a common misunderstanding when it comes to programming with generics, but it is an important concept to learn.\ndiagram showing that Box<Integer> is not a subtype of Box<Number>\nBox<Integer> is not a subtype of Box<Number> even though Integer is a subtype of Number.\nNote: Given two concrete types A and B (for example, Number and Integer), MyClass<A> has no relationship to MyClass<B>, regardless of whether or not A and B are related. The common parent of MyClass<A> and MyClass<B> is Object.','Generics, Inheritance, and Subtypes','Generics',0,0,NULL,5),(1728,'','List<? extends Integer> intList = new ArrayList<>();\nList<? extends Number>  numList = intList;  // OK. List<? extends Integer> is a subtype of List<? extends Number>','Generics',0,0,NULL,5),(1729,'compilation fails,\n\ninterface methods are implicityl public abstract so when you overid them like munch in Panda you have to say\npublic . ','interface Hungry<E> { void munch(E x); }\ninterface Carnivore<E extends Animal> extends Hungry<E> { }\n\ninterface Herbivore<Plant> extends Hungry<Plant> { }\n\n\ninterface Pineavore<Pine> extends Herbivore<Plant> { }\n\n\n\nclass Panda implements Herbivore<Pine>{  \n    void munch(Pine x){\n            System.out.println(\"eat pines\");\n    };\n} \nclass Chamelion implements Herbivore<Flowers>{ \n    public void munch(Flowers x){ } \n}','Generics',0,0,NULL,5),(1730,'will not compile, when you implement a generic interface, you must provide a type similarly you cannot say\nnew Thing<E>();','interface Hungry<E> { void munch(E x); }\n\nclass Driver<E> implements Hungry<T>{\n    public void munch(T food){\n        \n    }\n    \n}','Generics',0,0,NULL,5),(1731,'Panda does not compile \n\ndoes not override abstract method munch(Plant) in class Hungry.\n\n	','interface Hungry<E> { void munch(E x); }\n\ninterface Herbivore<Grass> extends Hungry<Plant> { }\n\nclass Panda implements Herbivore<Grass>{  \n        public void munch(Grass x){\n            System.out.println(\"eat pines\");\n    };\n} \n\nabstract class Animal { }\nabstract class Plant { }\nclass Grass extends Plant { }','Generics',0,0,NULL,5),(1732,'ArrayList','Which collection class allows you to grow or shrink its size and provide indexed access to its elements,\nbut whose methods are not synhcronized ?','Generics',0,0,NULL,5),(1733,'1 ArrayList<Integer> input = null;\n   List<Integer> output = null;\n\n2 List<Number> input = null;\n    List<Number> output = null\n\n3  List<Integer> input = null\n   List<Integer> output = null;\n\n\nThe return type is List so the output has to be a list it cant be arraylist. \nwhatever the input is thats what the output will be so input and output have to be the same type\nand the type has to be something that extends Number','public static <E extends Number> List<E> process(List<E> nums)\n\n// declare input and output\n\noutput = process(input);\n\n','Generics',0,0,NULL,5),(1734,'2\n2\n3 4\n\nfor the sake of the exam add and offer both add to naturally sorted collections \nso here the order becomes the natural order. \n\neven strings get sorted numerically.\n\n','public class Hello {\n  public static void main(String[] args){\n      PriorityQueue<String> pq = new PriorityQueue<String>();\n      pq.add(\"2\");\n      pq.add(\"4\");\n      System.out.println(pq.peek());\n      pq.offer(\"1\");\n      pq.add(\"3\");\n      pq.remove(\"1\");\n      System.out.println(pq.poll());\n      if(pq.remove(\"2\")) System.out.println(pq.poll());\n      System.out.println(pq.poll() + \" \" + pq.peek());\n  }\n   \n}','Generics',0,0,NULL,5),(1735,'1 2 2 4 3 5 67 7 \n1 2 2 3 4 5 67 7\n\nString only looks at the first charater so 67 is the same as 6','public class Hello {\n  public static void main(String[] args){\n      PriorityQueue<String> pq = new PriorityQueue<String>();\n      pq.add(\"2\");\n      pq.add(\"4\");\n\n      pq.offer(\"1\");\n      pq.add(\"3\");\n      \n      pq.add(\"2\");\n      pq.offer(\"5\");\n      \n      pq.add(\"67\");\n      pq.add(\"7\");\n      \n      for(String x : pq)\n          System.out.print(x+\" \");\n      \n      System.out.println(\"\");\n      \n      for(int x = 0; x <8; x++)\n          System.out.print(pq.poll()+\" \");\n\n  }\n   \n}','Generics',0,0,NULL,5);
INSERT INTO `flashcard` VALUES (1736,'2\n\nthe size is two when hashCode is implementd this imp. will place all turtles with size 1 in the same bucket\n\nsize() counts the buckets.\n\nif hashCode was not implemented then every entry would go into its own bucket and the size would be\n12\n\n','public class Hello {\n  public static void main(String[] args){\n      LinkedHashSet<Turtle> t = new LinkedHashSet<>();\n      t.add(new Turtle(1)); t.add( new Turtle(2)); t.add(new Turtle(1));\n      t.add(new Turtle(1)); t.add( new Turtle(2)); t.add(new Turtle(1));\n      t.add(new Turtle(1)); t.add(new Turtle(1)); t.add(new Turtle(1));\n      t.add(new Turtle(1)); t.add(new Turtle(1)); t.add(new Turtle(1));\n      \n      System.out.println(t.size());\n\n  }\n   \n}\n\ninterface Hungry<E> { void munch(E x); }\nabstract class Animal { }\nabstract class Plant { }\nclass Grass extends Plant { }\n\nclass Turtle {\n    int size;\n    public Turtle(int z){\n        size = z;\n    }\n    \n    public boolean equals(Object o){\n        return (this.size == ((Turtle)o).size);\n    }\n    \n    public int hashCode() { return size/5; }\n}','Generics',0,0,NULL,5),(1737,'classcastexception','class Grass extends Plant { }\n\npublic class Hello {\n  public static void main(String[] args){\n     TreeSet<Grass> grassset = new TreeSet<>();\n     grassset.add(new Grass());\n\n  }\n   \n}','Generics',0,0,NULL,5),(1738,'The output will contain a -1\n\n\"pen marble map key\" \n\n.binarySearch has to be invoked with the same Comparator that created it. \n	here it doesn\'t know how the array is sorted so it gives insertion point','public class GeoCache {\n	public static void main(String[ ]args) {\n		String[] s = {\"map\",\"pen\",\"marble\",\"key\"};\n		Othello o = new Othello();\n		Arrays.sort(s,o);\n		for(String s2: s) sout(s2+\" \");\n		sout( Arrays.binarySearch(s,\"map\");\n	}\n\n	static class Othello implements Comparator<String> {\n		public int compare(String a, String b) { return b.compareTo(a);l }\n	}\n}\n		','Collections',0,0,NULL,5),(1739,'One good usage of inner classes that comes into my mind is in java.util.ArrayList that hides its iterators implementations into private inner classes. You can\'t create them except by invoking iterator() or listIterator() on the list object.\n\nThis way the Iterator and ListIterator implementations for ArrayList are grouped with their related class and methods for enhanced readability (the implementations are pretty short), but hidden from others.\n\nThey can\'t be declared static as they need access to their enclosing instance object.','public class ArrayList<E> extends AbstractList<E>\n         implements List<E>, RandomAccess, Cloneable, java.io.Serializable {\n    ...\n    public Iterator<E> iterator() {\n         return new Itr();\n    }\n\n    private class Itr implements Iterator<E> {\n    ...\n    }\n\n    public ListIterator<E> listIterator() {\n         return new ListItr(0);\n    }\n\n    private class ListItr extends Itr implements ListIterator<E> {\n    ...\n    }\n}','General',0,0,NULL,5),(1740,'foo 7\n\ncompiles fine, you need the outer classes reference for a regular inner class\n\nthe inner class can be created as such from within the enclosing class. \n\ncould also be Inner a = new Inner();','public class Hello {\n    private int secretnum = 7;\n    \n  public static void main(String[] args){\n     Hello h = new Hello();\n     h.createInner();\n\n  }\n  \n  public void createInner(){\n      Hello.Inner a = new Hello.Inner();\n      a.foo(); a.seeOuter();\n  }\n  \n  \n  class Inner {\n      public void seeOuter(){\n          System.out.println(secretnum);\n      }\n      \n      void foo(){\n          System.out.println(\"Foo\");\n      }\n  }\n   \n}','Inner Classes',0,0,NULL,5),(1741,'WNC,\n\nNo static declarations are allowed in regular inner classes unless they \nare final.\n\nThe creation of a is legal though redundant, it could have been:\n\n	Inner a = new Inner();\n','public class Hello {\n    private int secretnum = 7;\n    \n  public static void main(String[] args){\n     Hello h = new Hello();\n     h.createInner();\n\n  }\n  \n  public void createInner(){\n      Hello.Inner a = new Hello.Inner();\n      a.foo(); a.seeOuter();\n  }\n  \n  \n  class Inner {\n      private static int verysecret = 8;\n      \n      public void seeOuter(){\n          System.out.println(secretnum);\n      }\n      \n      void foo(){\n          System.out.println(\"Foo\");\n      }\n  }','Inner Classes',0,0,NULL,5),(1742,'compiles fine, if an inner class is going to have static member it has to be final','public class Hello {\n    private int secretnum = 7;\n    \n  public static void main(String[] args){\n     Hello h = new Hello();\n     h.createInner();\n\n  }\n  \n  public void createInner(){\n      Hello.Inner a = new Hello.Inner();\n      a.foo(); a.seeOuter();\n  }\n  \n  \n  class Inner {\n      private static final int verysecret = 8;\n      \n      public void seeOuter(){\n          System.out.println(secretnum);\n      }\n      \n      void foo(){\n          System.out.println(\"Foo\");\n      }\n  }\n   \n}','Inner Classes',0,0,NULL,5),(1743,'apple carrot orange plum\n\nwith arraylist you can add(int index, object elemetn) to a specific index','public class sequence {\n	psvm(sa){\n		ArrayList<String> list = new ArrayList<>();\n		list.add(\"apple\");\n		list.add(\"organe\");\n		list.add(\"plum\");\n		list.add(1,\"carrot\");\n		sout( list );\n	}\n}','Collections',0,0,NULL,5),(1744,'will not compile,\n\ninner classes are the same as class instance variables so naturally you cannot access \nthem from a static context. ','public class Hello {\n    private int secretnum = 7;\n    \n    public static void main(String[] args){\n        Inner in = new Inner();\n\n    }\n  \n     class Inner {\n        private static final int verysecret = 8;\n        void foo(){\n          System.out.println(\"Foo\");\n        } \n  }\n   \n}','Inner Classes',0,0,NULL,5),(1745,'compiles fine','public class Hello {\n    private int secretnum = 7;\n    \n    public static void main(String[] args){\n        Hello h = new Hello();\n        Hello.Inner in = h.new Inner();\n\n    }\n  \n     class Inner {\n        private static final int verysecret = 8;\n        void foo(){\n          System.out.println(\"Foo\");\n        } \n  }\n   \n}','Inner Classes',0,0,NULL,5),(1746,'When instantiating from a static method You have to provide the Outer class name\n\nthe inner class is just a like an instance member. \n\nbut in the instance method its easy to create the inner class normally. \n\nits the same to create a new inner class in the static method as it is from another class.\n\n\nThis was one is also confusing because it has a mistakenly named method \nthat looks like a constructor. But its not. ','public class Hello {\n    private int secretnum = 7;\n    private static Inner inner;\n    \n    public static void main(String[] args){\n        Hello h = new Hello();\n        Hello.Inner in = h.new Inner();\n        \n        Hello.Inner in2 = h.new Inner();\n        \n        Hello.Inner in3 = new Hello().new Inner();\n        \n        inner = h.new Inner();\n        \n        //Inner a = new Inner(); this would not work\n        \n\n    }\n    \n    public void instancemaker(){\n        Inner a = new Inner();\n        System.out.println(a.verysecret);\n    }\n  \n     class Inner {\n        private static final int verysecret = 8;\n        \n        public void Inner(int x){\n            \n        }\n        void foo(){\n          System.out.println(\"Foo\");\n        } \n  }\n   \n}','Inner Classes',0,0,NULL,5),(1747,'public class Hello {\n    private int secretnum = 7;\n    public static void main(String[] args) {}\n    class Inner {  private static final int verysecret = 8; }\n}\n\nclass Dog extends Hello { class Innerdog extends Inner{ } }','public class Hello {\n    private int secretnum = 7;\n    public static void main(String[] args) {}\n    class Inner {  private static final int verysecret = 8; }\n}\n\nclass Dog extends Hello.Inner {}\n\nchange this code so it compiles, and creates a class that extends Hello.Inner','Inner Classes',0,0,NULL,5),(1748,'class Dog extends Hello{ class Inner extends Hello.Inner { } }','public class Hello {\n    private int secretnum = 7;\n    public static void main(String[] args) {}\n    class Inner {  private static final int verysecret = 8; }\n}\n\nclass Dog extends Hello{ class Inner extends Inner { } }\n\nthis is illegal what could make it legal ?','Inner Classes',0,0,NULL,5),(1749,'good example of an anonymous inner class from opennlp','public Iterator<String> iterator() {\n    return new Iterator<String>() {\n\n      private int index;\n\n      public boolean hasNext() {\n        return index < size();\n      }\n\n      public String next() {\n\n        if (hasNext()) {\n          return getToken(index++);\n        }\n        else {\n          throw new NoSuchElementException();\n        }\n      }\n\n      public void remove() {\n        throw new UnsupportedOperationException();\n      }\n\n    };\n  }','Inner Classes',0,0,NULL,5),(1750,'good example of anonymous inner class','public Iterator<String> iterator() {\n    return new Iterator<String>() {\n\n      private int index;\n\n      public boolean hasNext() {\n        return index < size();\n      }\n\n      public String next() {\n\n        if (hasNext()) {\n          return getToken(index++);\n        }\n        else {\n          throw new NoSuchElementException();\n        }\n      }\n\n      public void remove() {\n        throw new UnsupportedOperationException();\n      }\n\n    };\n  }','Inner Classes',0,0,NULL,5),(1751,'fine\ngood example of;\nStringTokenizer\nBufferedReader\n\n','public static Dictionary parseOneEntryPerLine(Reader in) throws IOException {\n    BufferedReader lineReader = new BufferedReader(in);\n\n    Dictionary dictionary = new Dictionary();\n\n    String line;\n\n    while ((line = lineReader.readLine()) != null) {\n      StringTokenizer whiteSpaceTokenizer = new StringTokenizer(line, \" \");\n\n      String[] tokens = new String[whiteSpaceTokenizer.countTokens()];\n\n      if (tokens.length > 0) {\n        int tokenIndex = 0;\n        while (whiteSpaceTokenizer.hasMoreTokens()) {\n          tokens[tokenIndex++] = whiteSpaceTokenizer.nextToken();\n        }\n\n        dictionary.put(new StringList(tokens));\n      }\n    }\n\n    return dictionary;\n  }','General',0,0,NULL,5),(1752,'will not compile \nreadLine() method throws IOException\n\nmust be caught or thrown!','public static Dictionary parseOneEntryPerLine(Reader in)  {\n    BufferedReader lineReader = new BufferedReader(in);\n\n    Dictionary dictionary = new Dictionary();\n\n    String line;\n\n    while ((line = lineReader.readLine()) != null) {\n      StringTokenizer whiteSpaceTokenizer = new StringTokenizer(line, \" \");\n\n      String[] tokens = new String[whiteSpaceTokenizer.countTokens()];\n\n      if (tokens.length > 0) {\n        int tokenIndex = 0;\n        while (whiteSpaceTokenizer.hasMoreTokens()) {\n          tokens[tokenIndex++] = whiteSpaceTokenizer.nextToken();\n        }\n\n        dictionary.put(new StringList(tokens));\n      }\n    }\n\n    return dictionary;\n  }','IO',0,0,NULL,5),(1753,'1=Bell\n3=Whistle\n5=Nic\n\ninner classes can have static members only if they are final','public class Hello {\n    private int secretnum = 7;\n    public static void main(String[] args) {\n        Map<Integer,String> hellomap = new HashMap();\n        hellomap.put(1,\"Bell\");\n        hellomap.put(3,\"Whistle\");\n        hellomap.put(5,\"Nic\");\n        \n        for(Entry<Integer,String> x : hellomap.entrySet()){\n            System.out.println(x);\n        }\n    \n    }\n    public class Inner {  private static final int verysecret = 8; }\n}','Inner Classes',0,0,NULL,5),(1754,'EvenIterator will not compile is not abstract and does not impelemnt next() in Iterator()\n\nThis shows that since DSIterator extends Iterator the first concrete class has to be the one to \nimplement the interfaces methods. ','public class Hello {\n    private final static int SIZE = 25;\n    private int[] array = new int[SIZE];\n    \n    public Hello(){\n        for(int i = 0; i<SIZE; i++){\n            array[i] = i;\n        }\n    }\n    \n    public void printEven(){\n        \n    }\n    \n    interface DSIterator extends java.util.Iterator<Integer> { }\n    \n    private class EvenIterator implements DSIterator{\n        \n    }\n    \n\n    public static void main(String[] args) {\n\n    \n    }\n\n}','General',0,0,NULL,5),(1755,'will not compile print() cannot be called from a static context.','public class Hello {\n    private final static int SIZE = 100;\n    private int[] array = new int[SIZE];\n    \n    public Hello(){\n        for(int i = 0; i<SIZE; i++){\n            array[i] = i;\n        }\n    }\n    \n    public void print(){\n        ThirdIterator it = new ThirdIterator();\n        while(it.hasNext()){\n            System.out.print(it.next() +\" \");\n        }\n        \n    }\n    \n    interface DSIterator extends java.util.Iterator<Integer> { }\n    \n    private class ThirdIterator implements DSIterator{\n        private int nextIndex = 0;\n        \n        public boolean hasNext(){\n            return (nextIndex <= SIZE - 1);\n        }\n        \n        public Integer next(){\n            Integer retValue = Integer.valueOf(array[nextIndex]);\n            \n            nextIndex += 3;\n            return retValue;\n            \n        }\n        \n    }\n    \n\n    public static void main(String[] args) {\n        print();\n    \n    }\n\n}','General',0,0,NULL,5),(1756,'0 3 6 9 12 15 18 21 24 27 30 33 36 39 42 45 48 51 54 57 60 63 66 69 72 75 78 81 84 87 90 93 96 99','public class Hello {\n    private final static int SIZE = 100;\n    private int[] array = new int[SIZE];\n    \n    public Hello(){\n        for(int i = 0; i<SIZE; i++){\n            array[i] = i;\n        }\n    }\n    \n    public void print(){\n        ThirdIterator it = new ThirdIterator();\n        while(it.hasNext()){\n            Object i = it.next();\n            //System.out.print(it.next() +\" \");\n        }\n        \n    }\n    \n    interface DSIterator extends java.util.Iterator { }\n    \n    private class ThirdIterator implements DSIterator{\n        private int nextIndex = 0;\n        \n        public boolean hasNext(){\n            return (nextIndex <= SIZE - 1);\n        }\n        \n        public Integer next(){\n            Integer retValue = Integer.valueOf(array[nextIndex]);\n            \n            nextIndex += 3;\n            return retValue;\n            \n        }\n        \n    }\n    \n\n    public static void main(String[] args) {\n        Hello h = new Hello();\n        h.print();\n    \n    }\n\n}','General',0,0,NULL,5),(1757,'if a final variable is static it has be intitialized right away.\n\nWhere a final instance varialbe must be intitialized at some point either in the constructor or upon creation.\n\n','public class Hello {\n    private final static int SIZE;\n    private int[] array;\n    \n    public Hello(int size){\n        this.SIZE = size;\n        \n        array = new int[SIZE];\n        \n        for(int i = 0; i<SIZE; i++){\n            array[i] = i;\n        }\n    }\n}','General',0,0,NULL,5),(1758,'Will not compile \n\nfinal variable SIZE is never initialized in default constructor or otherwise and this is a compilererror','public class Hello {\n    private final int SIZE;\n    private int[] array;\n    \n    public void print(){\n        ThirdIterator it = new ThirdIterator();\n        while(it.hasNext()){\n            Integer i = it.next();\n            //System.out.print(it.next() +\" \");\n        }\n        \n    }\n\n}','General',0,0,NULL,5),(1759,'final Variable SIZE in Hello is not intitialized in constructor \n\ncannot assign a value to final variable SIZE in innerclass ThirdIterator\n\nnon static third iterator class cannot be referenced from static main.\n\n','public class Hello {\n    private final int SIZE;\n    private int[] array;\n    \n    interface DSIterator extends java.util.Iterator<Integer> { }\n    \n    private class ThirdIterator implements DSIterator{\n        private int nextIndex = 0;\n        public ThirdIterator(){\n            SIZE = 100;\n            for(int ix=0; ix<SIZE; ix++){\n                array[ix] = ix;\n            }\n        }\n        \n        public boolean hasNext(){\n            return (nextIndex <= SIZE - 1);\n        }\n        \n        public Integer next(){\n            Integer retValue = Integer.valueOf(array[nextIndex]);\n            \n            nextIndex += 3;\n            return retValue;\n            \n        }\n        \n    }\n    \n    private static class EveryFourth implements DSIterator{\n        private int nextIndex = 0;\n        private static final int SIZE = 1000;\n        private int[] array = new int[SIZE];\n        \n        public EveryFourth(){\n           for(int i =0; i<100; i++){\n               array[i] = i;\n           }\n        }\n        \n        public boolean hasNext(){\n            return (nextIndex <= SIZE-1);\n        }\n        \n        public Integer next() {\n            Integer retValue = Integer.valueOf(array[nextIndex]);\n            \n            nextIndex += 4;\n            return retValue;\n        }\n    }\n    \n\n    public static void main(String[] args) {\n        EveryFourth a = new EveryFourth();\n        ThirdIterator b = new ThirdIterator();\n        \n    \n    }\n\n}\n\nThere multiple problems here','Inner Classes',0,0,NULL,5),(1760,'you cant do this either\nfinal variable SIZE is not instantiated on creation or in the \nconstructor. Even though it is in the ThirdIterator class\nconstructor. that does not work. ','public class Hello {\n    private final int SIZE;\n    private int[] array;\n    \n    public Hello(){\n        ThirdIterator x = new ThirdIterator();\n    }\n    \n    interface DSIterator extends java.util.Iterator<Integer> { }\n    \n    private class ThirdIterator implements DSIterator{\n        private int nextIndex = 0;\n        public ThirdIterator(){\n            SIZE = 100;\n            for(int ix=0; ix<SIZE; ix++){\n                array[ix] = ix;\n            }\n        }\n......\n.........','Inner Classes',0,0,NULL,5),(1761,'compiles fine','public class Hello {\n    private final int SIZE = 100;\n    private int[] array;\n\n    interface DSIterator extends java.util.Iterator<Integer> { }\n    \n    private class ThirdIterator implements DSIterator{\n        private int nextIndex = 0;\n        public ThirdIterator(){\n            for(int ix=0; ix<SIZE; ix++){\n                array[ix] = ix;\n            }\n        }  \n        public boolean hasNext(){\n            return (nextIndex <= SIZE - 1);\n        }\n        public Integer next(){\n            Integer retValue = Integer.valueOf(array[nextIndex]); \n            nextIndex += 3;\n            return retValue;    \n        }\n    }\n    private static class EveryFourth implements DSIterator{\n        private int nextIndex = 0;\n        private static final int SIZE = 1000;\n        private int[] array = new int[SIZE];\n        public EveryFourth(){\n           for(int i =0; i<100; i++){\n               array[i] = i;\n           }\n        }\n        public boolean hasNext(){\n            return (nextIndex <= SIZE-1);\n        }\n        \n        public Integer next() {\n            Integer retValue = Integer.valueOf(array[nextIndex]);\n            \n            nextIndex += 4;\n            return retValue;\n        }\n    }\n    public static void main(String[] args) {\n        EveryFourth a = new EveryFourth();\n        Hello.ThirdIterator b = new Hello().new ThirdIterator();\n    }\n\n}','Inner Classes',0,0,NULL,5),(1762,'A nested interface declared static is redundant. A nested interface is automatically static. \nstatic can be removed without and affect on semantics. Similar to public on interface methods \nor public final on interface fields. \n\nIt doen\'t change the fact that code without access to Foo wont have access to Foo.Bar interface.\n\nIt is acceptable to use if you excpect it only to be used from the enclosing class\n\npublic class Foo {\n	public interface Bar {\n		void callback();\n	}\n	public static void registerCallback(Bar bar){...}\n}\n//elsewhere\nFoo.registerCallback(new Foo.Bar() {\n	public void callback() {...}\n});','public class Hello {\n    private final int SIZE = 100;\n    private int[] array;\n\n    \n    static interface DSIterator extends java.util.Iterator<Integer> { }\n    \n    private class ThirdIterator implements DSIterator{\n        private int nextIndex = 0;\n        public ThirdIterator(){\n            for(int ix=0; ix<SIZE; ix++){\n                array[ix] = ix;\n            }\n        }\n        \n        public boolean hasNext(){\n            return (nextIndex <= SIZE - 1);\n        }\n        \n     ......','Inner Classes',0,0,NULL,5),(1763,'does not compile without outer reference for inner interface.\n\nshould be:\n\n	class Dog implements Hello.Petable {\n    \n ','public class Hello {\n    private final int SIZE = 100;\n    private int[] array;\n\n    \n    interface DSIterator extends java.util.Iterator<Integer> { }\n    \n    interface Petable {\n        void speak();\n        void wag();\n    }\n    \n    private class ThirdIterator implements DSIterator{\n        private int nextIndex = 0;\n        public ThirdIterator(){\n            for(int ix=0; ix<SIZE; ix++){\n                array[ix] = ix;\n            }\n        }\n        \n        public boolean hasNext(){\n            return (nextIndex <= SIZE - 1);\n        }\n        \n        public Integer next(){\n            Integer retValue = Integer.valueOf(array[nextIndex]);\n            \n            nextIndex += 3;\n            return retValue;\n            \n        }\n        \n    }\n    \n    private static class EveryFourth implements DSIterator{\n        private int nextIndex = 0;\n        private static final int SIZE = 1000;\n        private int[] array = new int[SIZE];\n        \n        public EveryFourth(){\n           for(int i =0; i<100; i++){\n               array[i] = i;\n           }\n        }\n        \n        public boolean hasNext(){\n            return (nextIndex <= SIZE-1);\n        }\n        \n        public Integer next() {\n            Integer retValue = Integer.valueOf(array[nextIndex]);\n            \n            nextIndex += 4;\n            return retValue;\n        }\n    }\n    \n\n    public static void main(String[] args) {\n        \n        EveryFourth a = new EveryFourth();\n        Hello.ThirdIterator b = new Hello().new ThirdIterator();\n        \n    \n    }\n\n}\n\nclass Dog implements Petable {\n    \n    public void bark(){\n        \n    }\n\n    @Override\n    public void speak() {\n        throw new UnsupportedOperationException(\"Not supported yet.\"); //To change body of generated methods, choose Tools | Templates.\n    }\n\n    @Override\n    public void wag() {\n        throw new UnsupportedOperationException(\"Not supported yet.\"); //To change body of generated methods, choose Tools | Templates.\n    }\n    \n}','Inner Classes',0,0,NULL,5),(1764,'how to instantiate an inner class object from outside the outter class instance code.','class MyOuter{\n	private int x = 7;\n\n	class MyInner{\n	public void seeOuter(){\n		sout( x );\n	}\n\n}\n\nclass OCP{\n	public static void main(SA){\n		MyOuter mo = new MyOuter();\n		MYOuter.MyInner inner = mo.new MyInner();\n		inner.seeOuter();\n	}\n}','Inner Classes',0,0,NULL,5),(1765,'one liner','psvm(SA){\n	MyOuter.MyInner inner = new MyOuter().new MyInner();\n	inner.seeOuter();\n}','Inner Classes',0,0,NULL,5),(1766,'\n	The rules for an inner class to reference itself or the outer class instance are as follows:\n\n	To reference the inner class instance itself from within the inner class code,\n		use this\n\n	toreference the \"outer this\" from within the inner class code,\n		use MyOuter.this.','class MyOuter{\n    private int x = 7;\n    public void makeInner() {\n        MyInner in = new MyInner();\n       in.seeOuter();\n   }\n\n    class MyInner {	\n           public void seeOuter {\n	sout( \"Outer x is \" + x );\n	sout(\"Inner class ref is \" + this);\n	sout( \"Outer class ref is \" + MyOuter.this );\n            }\n}\n\n      psvm(sa) {\n	MyOuter.MyInner inner = new MyOuter().new MyInner();\n	inner.seeOuter();\n     }\n}\n		','Inner Classes',0,0,NULL,5),(1767,'final\nabstract\npublic \nprivate\nprotected\nstatic\nstrictfp','what member modifiers can be applied to an inner class	','Inner Classes',0,0,NULL,5),(1768,'How to properly use a method local inner class','class MyOuter2 {\n	private String x = \"Outer2\";\n	void doStuff() {\n	        class MyInner {\n		public void seeOuter() {\n	                               sout(\" outer x is \" + x );\n		}\n	        }\n	\n	MyInner mi = new MyInner(); // THIS LINE MUST COME AFTER THE CLASS\n\n	mi.seeOuter();\n	}\n}\n\n	','Inner Classes',0,0,NULL,5),(1769,'WayInner: 7\n\nthe proper way to use a method local inner ','public class Hello {\n   \n    public static void main(String[] args) {\n        Hello h = new Hello();\n        h.methodlocal();\n    }\n    \n    public void methodlocal(){\n        \n        class WayInner {\n            private int size;\n        \n            public WayInner(int x){ size = x;}\n            public void printDetail(){\n                System.out.println(\"WayInner: \"+ size);\n            }\n        }\n        \n        WayInner a = new WayInner(7);\n        a.printDetail();\n    }\n\n}','Inner Classes',0,0,NULL,5),(1770,'will not compile in java 7. \n\nlocal varialbe cannot be accesed from within inner class. \n\nLocal varialbe exist on the stack and only exist for the lifetime of the method. \n\nwhen the method ends the local varialbes are destroyed, however the inner class object might still live on\n ','public class Hello {\n   \n    public static void main(String[] args) {\n        Hello h = new Hello();\n        h.methodlocal();\n    }\n    \n    public void methodlocal(){\n        int y = 56;\n        \n        class WayInner {\n            public int size;\n        \n            public WayInner(int x){ size = x;}\n            public void printDetail(){\n                System.out.println(\"WayInner: \"+ size);\n            }\n            \n            public void showall(){\n                System.out.println(size+\" \"+y);\n            }\n        }\n        \n        WayInner a = new WayInner(7);\n        a.printDetail();\n        a.showall();\n        \n    }\n\n}','Inner Classes',0,0,NULL,5),(1771,'will compile method local inner class can only access local variables if they are marked final.','public class Hello {\n   \n    public static void main(String[] args) {\n        Hello h = new Hello();\n        h.methodlocal();\n    }\n    \n    public void methodlocal(){\n        final int y = 56;\n        \n        class Zombie {\n            public int size;\n        \n            public Zombie(int x){ size = x;}\n            public void mone(){\n                System.out.println(\"ughhhg: \"+ size);\n            }\n            \n            public void accessTheLiving(){\n                System.out.println(\"local var: \"+y);\n            }\n            \n        }\n        \n        Zombie zom = new Zombie(7);\n        \n    }\n\n}','Inner Classes',0,0,NULL,5),(1772,'will not compile method local inner classes cannot be marked public private protected static or transient.','public class Hello {\n   \n    public static void main(String[] args) {\n        Hello h = new Hello();\n        h.methodlocal();\n    }\n    \n    public void methodlocal(){\n        final int y = 56;\n        \n        protected class Zombie {\n            public int size;\n        \n            public Zombie(int x){ size = x;}\n            public void mone(){\n                System.out.println(\"ughhhg: \"+ size);\n            }\n            \n            public void accessTheLiving(){\n                System.out.println(\"local var: \"+y);\n            }\n            \n        }\n        \n        Zombie zom = new Zombie(7);\n        \n    }\n\n}','Inner Classes',0,0,NULL,5),(1773,'will not compile ML inner class cannot be marked static. ','public class Hello {\n   \n    public static void main(String[] args) {\n        Hello h = new Hello();\n        h.methodlocal();\n    }\n    \n    public void methodlocal(){\n        final int y = 56;\n        \n        static class Zombie {\n            public int size;\n        \n            public Zombie(int x){ size = x;}\n            public void mone(){\n                System.out.println(\"ughhhg: \"+ size);\n            }\n            \n            public void accessTheLiving(){\n                System.out.println(\"local var: \"+y);\n            }\n            \n        }\n        \n        Zombie zom = new Zombie(7);\n        \n    }\n\n}','Inner Classes',0,0,NULL,5),(1774,'will not compile \n\nillegal static declaration in method local inner class. ','public class Hello {\n   \n    public static void main(String[] args) {\n        Hello h = new Hello();\n        h.methodlocal();\n    }\n    \n    public void methodlocal(){\n        final int y = 56;\n        \n        class Zombie {\n            public int size;\n        \n            public Zombie(int x){ size = x;}\n            public static void mone(){\n                System.out.println(\"ughhhg: \"+ size);\n            }\n            \n            public void accessTheLiving(){\n                System.out.println(\"local var: \"+y);\n            }\n            \n        }\n        \n        Zombie zom = new Zombie(7);\n        \n    }\n\n}','Inner Classes',0,0,NULL,5),(1775,'will not compile\n\nillegal modifier static is only allowed in constant decalartations. \n\nto compile make num final','public class Hello {\n   \n    public static void main(String[] args) {\n        Hello h = new Hello();\n        h.methodlocal();\n    }\n    \n    public void methodlocal(){\n        final int y = 56;\n        \n        \n        class Zombie {\n            public int size;\n            public static int num = 5;\n        \n            public Zombie(int x){ size = x;}\n            public void mone(){\n                System.out.println(\"ughhhg: \"+ size);\n            }\n            \n            public void accessTheLiving(){\n                System.out.println(\"local var: \"+y);\n            }\n            \n        }\n        \n        Zombie zom = new Zombie(7);\n        \n    }\n\n}','Inner Classes',0,0,NULL,5),(1776,'compiles fine.\n\nto use static in an inner class it must be marked final','public class Hello {\n   \n    public static void main(String[] args) {\n        Hello h = new Hello();\n        h.methodlocal();\n    }\n    \n    public void methodlocal(){\n        final int y = 56;\n        \n        \n        class Zombie {\n            public int size;\n            public static final int num = 5;\n        \n            public Zombie(int x){ size = x;}\n            public void mone(){\n                System.out.println(\"ughhhg: \"+ size);\n            }\n            \n            public void accessTheLiving(){\n                System.out.println(\"local var: \"+y);\n            }\n            \n        }\n        \n        Zombie zom = new Zombie(7);\n        \n    }\n\n}','Inner Classes',0,0,NULL,5),(1777,'','For inner classes \'static\' is only allowed for constant variable declarations. ','Inner Classes',0,0,NULL,5),(1778,'does not compile, \n\neven if the method is static ML innner class cannot decalre staic unless it is a static final constant. ','public class Hello {\n   \n    public static void main(String[] args) {\n        Hello h = new Hello();\n        h.methodlocal();\n    }\n    \n    public static void methodlocal(){\n        final int y = 56;\n        \n        \n        class Zombie {\n            public int size;\n            public static final int num = 5;\n        \n            public Zombie(int x){ size = x;}\n            public static final void mone(){\n                System.out.println(\"ughhhg: \"+ size);\n            }\n            \n            public void accessTheLiving(){\n                System.out.println(\"local var: \"+y);\n            }\n            \n        }\n        \n        Zombie zom = new Zombie(7);\n        \n    }\n\n}','Inner Classes',0,0,NULL,5),(1779,'does not compile\n\na MLIC declared in a static method cannot access instance varialbes of the outerclass. \n\nso\n sout(name) does not compile here. \n\nit can however access those static variables, if it was just the statics \nit would print:\n\n	Gemini\n	Gemini\n	Eunech','public class Hello {\n    private String name = \"marco\";\n    private final static String gem = \"Gemini\";\n    private static String west = \"Eunech\";\n   \n    public static void main(String[] args) {\n        Hello h = new Hello();\n        h.methodlocal();\n    }\n    \n    public static void methodlocal(){\n        final int y = 56;\n        //System.out.println(name); //wouldnt compile\n        System.out.println(gem);\n        \n        \n        class Zombie {\n            public int size;\n            public static final int num = 5;\n        \n            public Zombie(int x){ size = x; System.out.println(gem); System.out.println(west); System.out.println(name); }\n            public void mone(){\n                System.out.println(\"ughhhg: \"+ size);\n            }\n            \n            public void accessTheLiving(){\n                System.out.println(\"local var: \"+y);\n            }\n            \n        }\n        \n        Zombie zom = new Zombie(7);\n        \n    }\n\n}','Inner Classes',0,0,NULL,5),(1780,'this compiles fine \nMLIC in a instance method can access both static and instance variables','public class Hello {\n    private String name = \"marco\";\n    private final static String gem = \"Gemini\";\n    private static String west = \"Eunech\";\n   \n    public static void main(String[] args) {\n        Hello h = new Hello();\n        h.methodlocal();\n    }\n    \n    public void methodlocal(){\n        final int y = 56;\n        //System.out.println(name); //wouldnt compile\n        System.out.println(gem);\n        \n        \n        class Zombie {\n            public int size;\n            public static final int num = 5;\n        \n            public Zombie(int x){ size = x; System.out.println(gem); System.out.println(west); System.out.println(name); }\n            public void mone(){\n                System.out.println(\"ughhhg: \"+ size);\n            }\n            \n            public void accessTheLiving(){\n                System.out.println(\"local var: \"+y);\n            }\n            \n        }\n        \n        Zombie zom = new Zombie(7);\n        \n    }\n\n}','Inner Classes',0,0,NULL,5),(1781,'h.buck() will not compile because you can only call the superclasses methods on a polymorphic reference','class Horse extends Animal {\n        void buck() { }\n}\n\nclass Animal {\n        void eat() { }\n}\nclass Test {\n        public static void main(String[] atrgs) {\n	Animal h = new Horse();\n	h.eat();\n	h.buck();\n       }\n}	','Inner Classes',0,0,NULL,5),(1782,'here smalls.actFly() compiles \n\nhowever, getLoot() is defined in the anonyous subclass so polynorphically it cannot compile.\n\nThe only way to use methods declared in the anonymous subclass is to override methods of \nthe super class where overriding rules still apply. ','public class Hello {\n   \n    public static void main(String[] args) {\n        Biggie smalls = new Biggie(){\n            public void getLoot(){\n                System.out.println(\"Gimmie the loot!\");\n            }\n            \n        };\n        \n        smalls.actFly();\n        smalls.getLoot();\n        \n      \n    }\n\n}\n\nclass Biggie {\n    public void actFly(){\n        System.out.println(\"Shit so fly\");\n    }\n    public static void getPaid(){\n        System.out.println(\"Its so easy!\");\n    }\n    public int getFemaleDigits(){\n        return 5556784;\n    }\n}','Inner Classes',0,0,NULL,5),(1783,'proper override','public class Hello {\n   \n    public static void main(String[] args) {\n        Biggie smalls = new Biggie(){\n            private void getLoot(){\n                System.out.println(\"Gimmie the loot!\");\n            }\n            \n            public void actFly(){\n                System.out.println(\"Still acting fly\");\n            }\n            \n        };\n        \n        smalls.actFly();\n        smalls.actFly();\n    }\n\n}\n\nclass Biggie {\n    public void actFly(){\n        System.out.println(\"Shit so fly\");\n    }\n    public static void getPaid(){\n        System.out.println(\"Its so easy!\");\n    }\n    public int getFemaleDigits(){\n        return 5556784;\n    }\n}','Inner Classes',0,0,NULL,5),(1784,'will not compile override methods cannot return a different type unless its a subtype','public class Hello {\n   \n    public static void main(String[] args) {\n        Biggie smalls = new Biggie(){\n            private void getLoot(){\n                System.out.println(\"Gimmie the loot!\");\n            }\n            \n            public int actFly(){\n                int x = 66;\n                System.out.println(\"Still acting fly\");\n                return x;\n            }\n            \n        };\n        \n        smalls.actFly();\n        smalls.actFly();\n    }\n\n}\n\nclass Biggie {\n    public void actFly(){\n        System.out.println(\"Shit so fly\");\n    }\n    public static void getPaid(){\n        System.out.println(\"Its so easy!\");\n    }\n    public int getFemaleDigits(){\n        return 5556784;\n    }\n}','Inner Classes',0,0,NULL,5),(1785,'this will compile just fine. \n\nan override method is allowed to have less reestricted access but not more,\n\nan override method must have the same return type or it can return a subclass. ','public class Hello {\n   \n    public static void main(String[] args) {\n        Biggie smalls = new Biggie(){\n            private void getLoot(){\n                System.out.println(\"Gimmie the loot!\");\n            }\n            \n            public void actFly(){\n                System.out.println(\"Still acting fly\");\n            }\n            \n            public Integer getFemalDigits(){\n                return 5671123;\n            }  \n        };\n        \n        smalls.actFly();\n        smalls.actFly();\n    }\n\n}\n\nclass Biggie {\n    protected void actFly(){\n        System.out.println(\"Shit so fly\");\n    }\n    public static void getPaid(){\n        System.out.println(\"Its so easy!\");\n    }\n    public Number getFemaleDigits(){\n        return 5556784;\n    }\n}','Inner Classes',0,0,NULL,5),(1786,'will not compile, \n\nyou cannot override a method marked static. \n\nThe only way you could make this work is by making getPaid in the anonymous\nclass static which would \'hide\' the superclass static method not override it.\n\nunfortuanlytel you cannot put a static method in an anonymous class. \n\n\n\nOver-riding basically supports late binding . Therefore, which method will be called is decided at run time.It is for non-static methods. Hiding is for all other members (static methods , instance members, static members). It is based on the early binding . More clearly , the method or member to be called or used is decided during compile time.\n\nIn your example, the first call , Animal.testClassMethod() is a call to a static method,hence, it is pretty sure as to which method is going to be called.\n\nIn the second call,myAnimal.testInstanceMethod(), it calls a non-static method. It is what you call run-time polymorphism. It is not decided until run time which method is to be called.\n\nFor further clarification, read this.\n','public class Hello {\n   \n    public static void main(String[] args) {\n        Biggie smalls = new Biggie(){\n            private void getLoot(){\n                System.out.println(\"Gimmie the loot!\");\n            }\n            \n            public void actFly(){\n                System.out.println(\"Still acting fly\");\n            }\n            \n            public Integer getFemalDigits(){\n                return 5671123;\n            }  \n            \n            public void getPaid(){\n                System.out.println(\"Boy I get money!\");\n            }\n        };\n        \n        smalls.actFly();\n        smalls.actFly();\n    }\n\n}\n\nclass Biggie {\n    protected void actFly(){\n        System.out.println(\"Shit so fly\");\n    }\n    public static void getPaid(){\n        System.out.println(\"Its so easy!\");\n    }\n    public Number getFemaleDigits(){\n        return 5556784;\n    }\n}','Inner Classes',0,0,NULL,5),(1787,'Will not compile\n\nstatic definitions not allowed in inner classes except for constant varaible definintions. ','public class Hello {\n   \n    public static void main(String[] args) {\n        Biggie smalls = new Biggie(){\n            private void getLoot(){\n                System.out.println(\"Gimmie the loot!\");\n            }\n            \n            public void actFly(){\n                System.out.println(\"Still acting fly\");\n            }\n            \n            public Integer getFemalDigits(){\n                return 5671123;\n            }  \n            \n            public static void getPaid(){\n                System.out.println(\"Boy I get money!\");\n            }\n        };\n        \n        smalls.actFly();\n        smalls.actFly();\n    }\n\n}\n\nclass Biggie {\n    protected void actFly(){\n        System.out.println(\"Shit so fly\");\n    }\n    public static void getPaid(){\n        System.out.println(\"Its so easy!\");\n    }\n    public Number getFemaleDigits(){\n        return 5556784;\n    }\n}','Inner Classes',0,0,NULL,5),(1788,'this compiles fine,\n\n','class Biggie {\n    public static int thashitt = 568;\n    protected void actFly(){\n        System.out.println(\"Shit so fly\");\n    }\n    public static void getPaid(){\n        System.out.println(\"Its so easy!\");\n    }\n    public Number getFemaleDigits(){\n        return 5556784;\n    }\n}\n\nclass Benzino extends Biggie{\n    \n    public void printThaShitt(){\n        System.out.println(thashitt);\n    }\n    \n    public static void getPaid(){\n        System.out.println(\"It\'s somewhat difficult\");\n    }\n    \n    public Integer getFemaleDigits(){\n        return null;\n    }\n    \n}','Inner Classes',0,0,NULL,5),(1789,'Still acting fly\n5671123\nIts so easy!\n\nthe reference smalls is of type anonymous class so its methods are theoverriden methods in the anonymous \nclass\n\nwhen getPaid() is called on benz you are accessing a static method from a reference variable, so \nthe Biggie version is used because thats the type of the reference variable, \n\nstatic methods cannot be overridden but they can be hidden. ','public class Hello {\n   \n    public static void main(String[] args) {\n        Biggie smalls = new Biggie(){\n            private void getLoot(){\n                System.out.println(\"Gimmie the loot!\");\n            }\n            \n            public void actFly(){\n                System.out.println(\"Still acting fly\");\n            }\n            \n            public Integer getFemaleDigits(){\n                return 5671123;\n            }  \n\n        };\n        \n        smalls.actFly();\n        System.out.println(smalls.getFemaleDigits());\n        \n        Biggie benz = new Benzino();\n        benz.getPaid();\n    }\n\n}\n\nclass Biggie {\n    public static int thashitt = 568;\n    protected void actFly(){\n        System.out.println(\"Shit so fly\");\n    }\n    public static void getPaid(){\n        System.out.println(\"Its so easy!\");\n    }\n    public Number getFemaleDigits(){\n        return 5556784;\n    }\n}\n\nclass Benzino extends Biggie{\n    \n    public void printThaShitt(){\n        System.out.println(thashitt);\n    }\n    \n    public static void getPaid(){\n        System.out.println(\"It\'s somewhat difficult\");\n    }\n    \n    public Integer getFemaleDigits(){\n        return null;\n    }\n    \n}','Inner Classes',0,0,NULL,5),(1790,'Still acting fly\n5671123\nIt\'s somewhat difficult','public class Hello {\n   \n    public static void main(String[] args) {\n        Biggie smalls = new Biggie(){\n            private void getLoot(){\n                System.out.println(\"Gimmie the loot!\");\n            }\n            \n            public void actFly(){\n                System.out.println(\"Still acting fly\");\n            }\n            \n            public Integer getFemaleDigits(){\n                return 5671123;\n            }  \n\n        };\n        \n        smalls.actFly();\n        System.out.println(smalls.getFemaleDigits());\n        \n        Benzino benz = new Benzino();\n        benz.getPaid();\n    }\n\n}\n\nclass Biggie {\n    public static int thashitt = 568;\n    protected void actFly(){\n        System.out.println(\"Shit so fly\");\n    }\n    public static void getPaid(){\n        System.out.println(\"Its so easy!\");\n    }\n    public Number getFemaleDigits(){\n        return 5556784;\n    }\n}\n\nclass Benzino extends Biggie{\n    \n    public void printThaShitt(){\n        System.out.println(thashitt);\n    }\n    \n    public static void getPaid(){\n        System.out.println(\"It\'s somewhat difficult\");\n    }\n    \n    public Integer getFemaleDigits(){\n        return null;\n    }\n    \n}','Inner Classes',0,0,NULL,5),(1791,'p.pop(); is ok because popcorn has a pop method\n\np.sizzle();  is illegal because popcorn does not have sizzle().\n\n','class Popcorn {\n	public void pop(){\n		sout(\"popcorn\");\n	}\n}\n\nclass Food {\n	Popcorn p = new Popcorn() {\n		public void sizzle(){\n			sout(\"anonymouse sizzling popcorn\");\n		}\n\n		public void pop(){\n			sout(\"anonumous popcorn\");\n		}\n	};\n\n	public void popIt(){\n		p.pop();\n		p.sizzle();\n	}\n}','Inner Classes',0,0,NULL,5),(1792,'will not compile class Benzino does not have that method. ','public class Hello {\n   \n    public static void main(String[] args) {\n        Biggie benz = new Benzino();\n        benz.printThaShitt();\n    }\n\n}\n\nclass Biggie {\n    public static int thashitt = 568;\n    protected void actFly(){\n        System.out.println(\"Shit so fly\");\n    }\n    public static void getPaid(){\n        System.out.println(\"Its so easy!\");\n    }\n    public Number getFemaleDigits(){\n        return 5556784;\n    }\n}\n\nclass Benzino extends Biggie{\n    \n    public void printThaShitt(){\n        System.out.println(thashitt);\n        getPaid();\n        super.getPaid();\n        Biggie.getPaid();\n    }\n    \n    public static void getPaid(){\n        System.out.println(\"It\'s somewhat difficult\");\n    }\n    \n    public Integer getFemaleDigits(){\n        return null;\n    }\n    \n}','Inner Classes',0,0,NULL,5),(1793,'568\nIt\'s somewhat difficult\nIts so easy!\nIts so easy!\n\n\ngetPaid() is used plainly as is it calls Benzinos static method, \n\nall the others access the super class. \n\nStatic variables in Java are not inherited, they exist only in the class which declares them; \nhowever, they can be accessed implicitly by referring to an instance or subclass (or subclass instance) of the class which defines the \nstatic variable. \n(Static variable handling is one of the few confusing parts of the Java language, IMHO.)','public class Hello {\n   \n    public static void main(String[] args) {\n        Benzino benz = new Benzino();\n        benz.printThaShitt();\n    }\n\n}\n\nclass Biggie {\n    public static int thashitt = 568;\n    protected void actFly(){\n        System.out.println(\"Shit so fly\");\n    }\n    public static void getPaid(){\n        System.out.println(\"Its so easy!\");\n    }\n    public Number getFemaleDigits(){\n        return 5556784;\n    }\n}\n\nclass Benzino extends Biggie{\n    \n    public void printThaShitt(){\n        System.out.println(thashitt);\n        getPaid();\n        super.getPaid();\n        Biggie.getPaid();\n    }\n    \n    public static void getPaid(){\n        System.out.println(\"It\'s somewhat difficult\");\n    }\n    \n    public Integer getFemaleDigits(){\n        return null;\n    }\n    \n}\n','Inner Classes',0,0,NULL,5),(1794,'this shows that static methods can be overloaded','public class Test {\n    public static void foo() {\n        System.out.println(\"Test.foo() called \");\n    }\n    public static void foo(int a) { \n        System.out.println(\"Test.foo(int) called \");\n    }\n    public static void main(String args[])\n    { \n        Test.foo();\n        Test.foo(10);\n    }\n}','Inner Classes',0,0,NULL,5),(1795,'will not compile, you cannot overload based on static keyword alone','public class Test {\n    public static void foo() {\n        System.out.println(\"Test.foo() called \");\n    }\n    public void foo() { \n        System.out.println(\"Test.foo(int) called \");\n    }\n    public static void main(String args[]) { \n        Test.foo();\n    }\n}','Inner Classes',0,0,NULL,5),(1796,'will not compile, \n\nanonymous class of stick is not abstract and does not overrride interface\nmethods\n\n','public class Hello {\n\n   \n    public static void main(String[] args) {\n        Burnable stick = new Burnable(){\n            \n        };\n    }\n\n}\n\ninterface Burnable{\n    int people = 10;\n    void burn();\n    void shakeoff();\n    int unburn();\n    \n}','Inner Classes',0,0,NULL,5),(1797,'does not compile, \n\nanonymous subclass does not impelement all abstract methods ','public class Hello {\n\n   \n    public static void main(String[] args) {\n        Burnable stick = new Burnable(){\n            public void burn(){\n                System.out.println(\"Theres \"+people+\" people here so get the fire going\");\n            }\n            \n        };\n    }\n\n}\n\ninterface Burnable{\n    int people = 10;\n    void burn();\n    void shakeoff();\n    int unburn();\n    \n}','Inner Classes',0,0,NULL,5),(1798,'This type of anonomuous inner class implemtents an interface\n\nThis is the only time you can use new with an interface.\n\nIt compiles because all of the abstract methods are implemented\n\n','public class Hello {\n\n    public static void main(String[] args) {\n        \n        Burnable stick = new Burnable(){\n            public void burn(){\n                System.out.println(\"Theres \"+people+\" people here so get the fire going\");\n            }\n            \n            public int unburn(){\n                System.out.println(\"That\'s impossible\");\n                return 0;\n            }\n            \n            public void shakeoff(){\n                System.out.println(\"That was my shoe!\");\n            }\n            \n        };\n    }\n\n}\n\ninterface Burnable{\n    int people = 10;\n    void burn();\n    void shakeoff();\n    int unburn();\n}\n','Inner Classes',0,0,NULL,5),(1799,'will not compile interfaces are 100% abstract, they can have nothing\nconcrete','interface Burnable{\n    int people = 10;\n    void burn();\n    void shakeoff();\n    int unburn();\n    void people(){\n        System.out.println(people+\" \");\n    }\n}','Inner Classes',0,0,NULL,5),(1800,'Theres 8 people here so get the fire going','public class Hello {\n\n    public static void main(String[] args) {\n        \n        Burnable stick = new Burnable(){\n            int people = 8;\n            public void burn(){\n                System.out.println(\"Theres \"+people+\" people here so get the fire going\");\n            }\n            \n            public int unburn(){\n                System.out.println(\"That\'s impossible\");\n                return 0;\n            }\n            \n            public void shakeoff(){\n                System.out.println(\"That was my shoe!\");\n            }\n            \n        };\n        \n        stick.burn();\n    }\n\n}\n\ninterface Burnable{\n    int people = 10;\n    void burn();\n    void shakeoff();\n    int unburn();\n}\n','Inner Classes',0,0,NULL,5),(1801,'Will not compile, shakeoff() is overloaded in anonymous subclass. \n\nThe overload is legal using it outside the inner class is not\n\nthat method is an overload it is created in the anonnymous subclass and\ncant be used on the Burnable refernence','public class Hello {\n\n    public static void main(String[] args) {\n        \n        Burnable stick = new Burnable(){\n            int people = 8;\n            public void burn(){\n                System.out.println(\"Theres \"+people+\" people here so get the fire going\");\n            }\n            \n            public int unburn(){\n                System.out.println(\"That\'s impossible\");\n                return 0;\n            }\n            \n            public void shakeoff(int x){\n                System.out.println(\"That was my shoe!\"+x);\n            }\n            \n            public void shakeoff(){\n                System.out.println(\"its off\");\n            }\n            \n            \n            \n        };\n        \n        stick.burn();\n        stick.shakeoff();\n    }\n\n}\n\ninterface Burnable{\n    int people = 10;\n    void burn();\n    void shakeoff(int z);\n    int unburn();\n}','Inner Classes',0,0,NULL,5),(1802,'gimmie all the balls!','public class Hello {\n\n    public static void main(String[] args) {\n        Gym.BasketBallCourt bc = new Gym.BasketBallCourt();\n        bc.collectBalls();\n    }\n\n}\n\nclass Gym{\n    public int weights = 8000;\n    public String name = \"Max\'s gym\";\n    public int price = 50;\n    \n    public void pitch(){\n        System.out.println(\"Were the best gym\");\n    }\n    \n    static class BasketBallCourt {\n        private int courts = 2;\n        \n        public void collectBalls(){\n            System.out.println(\"gimmmie all the balls!\");\n        }\n        \n        public int Scoreboard(){\n            return 114;\n        }\n    }\n}','Inner Classes',0,0,NULL,5),(1803,'will not compile, static classes are like static members of the enclosing\nclass they cannot access instance varialbes','class Gym{\n    public int weights = 8000;\n    public String name = \"Max\'s gym\";\n    public int price = 50;\n    \n    public void pitch(){\n        System.out.println(\"Were the best gym\");\n    }\n    \n    static class BasketBallCourt {\n        private int courts = 2;\n        \n        public void collectBalls(){\n            System.out.println(\"gimmmie all the balls!\");\n        }\n        \n        public void gymPrice(){\n            System.out.println(name+\" \"+price);\n        }\n        \n        public int Scoreboard(){\n            return 114;\n        }\n    }','Inner Classes',0,0,NULL,5),(1804,'This compiles fine static inner classes can have static fields and methods\n','class Gym{\n    public int weights = 8000;\n    public String name = \"Max\'s gym\";\n    public int price = 50;\n    \n    public void pitch(){\n        System.out.println(\"Were the best gym\");\n    }\n    \n    static class BasketBallCourt {\n        private static int courts = 2;\n        \n        public void collectBalls(){\n            System.out.println(\"gimmmie all the balls!\");\n        }\n        \n        public void gymPrice(){\n            Gym g = new Gym();\n            System.out.println(g.price);\n        }\n        \n        public int Scoreboard(){\n            return 114;\n        }\n    }\n}','Inner Classes',0,0,NULL,5),(1805,'this compiles fine, shows how to properly instantiate static nested clases','public class Hello {\n\n    public static void main(String[] args) {\n        Gym.BasketBallCourt bc = new Gym.BasketBallCourt();\n        bc.collectBalls();\n    }\n\n}\n\nclass Gym{\n    public int weights = 8000;\n    public String name = \"Max\'s gym\";\n    public int price = 50;\n    \n    public void pitch(){\n        BasketBallCourt bc = new BasketBallCourt();\n        System.out.println(\"Were the best gym\");\n        System.out.println(\"Our court is huge too! \"+bc.courts());\n    }\n    \n    static class BasketBallCourt {\n        private static int courts = 2;\n        \n        public static void collectBalls(){\n            System.out.println(\"gimmmie all the balls!\");\n        }\n        public int courts(){\n            return courts;\n        }\n        \n        public void gymPrice(){\n            Gym g = new Gym();\n            System.out.println(g.price);\n        }\n        \n        public int Scoreboard(){\n            return 114;\n        }\n    }\n}','Inner Classes',0,0,NULL,5),(1806,'will not compile, that is not the right instantiation of a static nested class','public class Hello {\n\n    public static void main(String[] args) {\n        Gym.BasketBallCourt bc = new Gym.BasketBallCourt();\n        Gym g = new Gym();\n        \n        Gym.BasketBallCourt bc3 = g.new BasketBallCourt();\n        \n        g.pitch();\n        \n    }\n\n}\n\nclass Gym{\n    public int weights = 8000;\n    public String name = \"Max\'s gym\";\n    public int price = 50;\n    \n    public void pitch(){\n        BasketBallCourt bc = new BasketBallCourt();\n        System.out.println(\"Were the best gym\");\n        System.out.println(\"Our court is huge too! \"+bc.courts());\n    }\n    \n    static class BasketBallCourt {\n        private static int courts = 2;\n        \n        public static void collectBalls(){\n            System.out.println(\"gimmmie all the balls!\");\n        }\n        public int courts(){\n            return courts;\n        }\n        \n        public void gymPrice(){\n            Gym g = new Gym();\n            System.out.println(g.price);\n        }\n        \n        public int Scoreboard(){\n            return 114;\n        }\n    }\n}','Inner Classes',0,0,NULL,5),(1807,'114\ngimmie all the balls','public class Hello {\n\n    public static void main(String[] args) {\n        Gym.BasketBallCourt bc = new Gym.BasketBallCourt();\n        Gym g = new Gym();\n        \n        Gym.BasketBallCourt bc3 = new Gym.BasketBallCourt();\n        \n        bc3.Scoreboard();\n        \n        Gym.BasketBallCourt.collectBalls();\n        \n    }\n\n}\n\nclass Gym{\n    public int weights = 8000;\n    public String name = \"Max\'s gym\";\n    public int price = 50;\n    \n    public void pitch(){\n        BasketBallCourt bc = new BasketBallCourt();\n        System.out.println(\"Were the best gym\");\n        System.out.println(\"Our court is huge too! \"+bc.courts());\n    }\n    \n    static class BasketBallCourt {\n        private static int courts = 2;\n        \n        public static void collectBalls(){\n            System.out.println(\"gimmmie all the balls!\");\n        }\n        public int courts(){\n            return courts;\n        }\n        \n        public void gymPrice(){\n            Gym g = new Gym();\n            System.out.println(g.price);\n        }\n        \n        public int Scoreboard(){\n            return 114;\n        }\n    }\n}','Inner Classes',0,0,NULL,5),(1808,'114','public class Hello {\n\n    public static void main(String[] args) {\n        Gym.BasketBallCourt gbg = new Gym().new BasketBallCourt();\n        System.out.println(gbg.Scoreboard());\n        \n    }\n\n}\n\nclass Gym{\n    public int weights = 8000;\n    public String name = \"Max\'s gym\";\n    public int price = 50;\n    \n    public void pitch(){\n        BasketBallCourt bc = new BasketBallCourt();\n        System.out.println(\"Were the best gym\");\n    }\n    \n    class BasketBallCourt {\n        \n        public void collectBalls(){\n            System.out.println(\"gimmmie all the balls!\");\n        }\n        \n        public void gymPrice(){\n            Gym g = new Gym();\n            System.out.println(g.price);\n        }\n        \n        public int Scoreboard(){\n            return 114;\n        }\n    }\n}','Inner Classes',0,0,NULL,5),(1809,'does not compile because of private modifier','public class Hello {\n\n    public static void main(String[] args) {\n        Gym.BasketBallCourt gbg = new Gym().new BasketBallCourt();\n        \n    }\n\n}\n\nclass Gym{\n    public int weights = 8000;\n    public String name = \"Max\'s gym\";\n    public int price = 50;\n    \n    public void pitch(){\n        BasketBallCourt bc = new BasketBallCourt();\n        System.out.println(\"Were the best gym\");\n    }\n    \n    private class BasketBallCourt {\n        \n        public void collectBalls(){\n            System.out.println(\"gimmmie all the balls!\");\n        }\n        \n        public void gymPrice(){\n            Gym g = new Gym();\n            System.out.println(g.price);\n        }\n        \n        public int Scoreboard(){\n            return 114;\n        }\n    }\n}','Inner Classes',0,0,NULL,5),(1810,'this compiles fine','public class Hello {\n\n    public static void main(String[] args) {\n        Gym.BasketBallCourt gbg = new Gym().new BasketBallCourt();\n        \n    }\n\n}\n\nclass Gym{\n    public int weights = 8000;\n    public String name = \"Max\'s gym\";\n    public int price = 50;\n    \n    public void pitch(){\n        BasketBallCourt bc = new BasketBallCourt();\n        System.out.println(\"Were the best gym\");\n    }\n    \n    protected class BasketBallCourt {\n        \n        public void collectBalls(){\n            System.out.println(\"gimmmie all the balls!\");\n        }\n        \n        public void gymPrice(){\n            Gym g = new Gym();\n            System.out.println(g.price);\n        }\n        \n        public int Scoreboard(){\n            return 114;\n        }\n    }\n}','Inner Classes',0,0,NULL,5),(1811,'oooh ahhh\n\nsince inner classes are members of the enclsoing class just like anything else\nthey are inherited too.','public class Hello {\n\n    public static void main(String[] args) {\n        LifeTime lt = new LifeTime();\n        lt.showLifeTimesCourt();    \n    }\n\n}\n\nclass Gym{\n    public int weights = 8000;\n    public String name = \"Max\'s gym\";\n    public int price = 50;\n    \n    public void pitch(){\n        BasketBallCourt bc = new BasketBallCourt();\n        System.out.println(\"Were the best gym\");\n    }\n    \n    protected class BasketBallCourt {\n        \n        public void collectBalls(){\n            System.out.println(\"gimmmie all the balls!\");\n        }\n        \n        public void showCourt(){\n            System.out.println(\"oooh ahhh\");\n        }\n        \n        public void gymPrice(){\n            Gym g = new Gym();\n            System.out.println(g.price);\n        }\n        \n        public int Scoreboard(){\n            return 114;\n        }\n    }\n}\n\nclass LifeTime extends Gym{\n    public void showLifeTimesCourt(){\n        BasketBallCourt b = new BasketBallCourt();\n        b.showCourt();\n    }\n}','Inner Classes',0,0,NULL,5),(1812,'this compiles and runs','public class Hello {\n\n    public static void main(String[] args) {\n       LifeTime lt = new LifeTime();\n       Gym.BasketBallCourt bc = lt.new BasketBallCourt();\n       \n    }\n\n}\n\nclass Gym{\n    public int weights = 8000;\n    public String name = \"Max\'s gym\";\n    public int price = 50;\n    \n    public void pitch(){\n        BasketBallCourt bc = new BasketBallCourt();\n        System.out.println(\"Were the best gym\");\n    }\n    \n    protected class BasketBallCourt {\n        \n        public void collectBalls(){\n            System.out.println(\"gimmmie all the balls!\");\n        }\n        \n        public void showCourt(){\n            System.out.println(\"oooh ahhh\");\n        }\n        \n        public void gymPrice(){\n            Gym g = new Gym();\n            System.out.println(g.price);\n        }\n        \n        public int Scoreboard(){\n            return 114;\n        }\n    }\n}\n\nclass LifeTime extends Gym{\n    public void showLifeTimesCourt(){\n        BasketBallCourt b = new BasketBallCourt();\n        b.showCourt();\n    }\n}','Inner Classes',0,0,NULL,5),(1813,'How to access this reference of outer class','public class Hello {\n\n    public static void main(String[] args) {\n       Gym lt = new Gym();\n       Gym.BasketBallCourt bc = lt.new BasketBallCourt();\n       \n    }\n\n}\n\nclass Gym{\n    public int weights = 8000;\n    public String name = \"Max\'s gym\";\n    public int price = 50;\n    \n    public void pitch(){\n        BasketBallCourt bc = new BasketBallCourt();\n        System.out.println(\"Were the best gym\");\n    }\n    \n    protected class BasketBallCourt {\n        public String name = \"Maxs court\";\n        \n        public void collectBalls(){\n            System.out.println(\"gimmmie all the balls!\");\n        }\n        \n        public void showCourt(){\n            System.out.println(\" \"+name);\n            System.out.println(\"oooh ahhh\");\n        }\n        \n        public void gymPrice(){\n            System.out.println(\" \"+Gym.this.name);\n            System.out.println(Gym.this.price);\n        }\n        \n        public int Scoreboard(){\n            return 114;\n        }\n    }\n}','Inner Classes',0,0,NULL,5),(1814,'compiles fine','public class Hello {\n\n    public static void main(String[] args) {\n       LifeTime lt = new LifeTime();\n       Gym.BasketBallCourt bc = lt.new BasketBallCourt();\n       \n    }\n\n}\n\nclass Gym{\n    public int weights = 8000;\n    public String name = \"Max\'s gym\";\n    public int price = 50;\n    \n    public void pitch(){\n        BasketBallCourt bc = new BasketBallCourt();\n        System.out.println(\"Were the best gym\");\n    }\n    \n    protected class BasketBallCourt {\n        public String name = \"Maxs court\";\n        \n        public void collectBalls(){\n            System.out.println(\"gimmmie all the balls!\");\n        }\n        \n        public void showCourt(){\n            System.out.println(\" \"+name);\n            System.out.println(\"oooh ahhh\");\n        }\n        \n        public void gymPrice(){\n            System.out.println(\" \"+Gym.this.name);\n            System.out.println(Gym.this.price);\n        }\n        \n        public int Scoreboard(){\n            return 114;\n        }\n    }\n}\n\nclass LifeTime extends Gym{\n    public void showLifeTimesCourt(){\n        final int time = 530;\n        class SalesRep{\n            public void appointment(){\n                System.out.println(\"The time of our appointment is: \"+time);\n            }\n            \n        }\n        SalesRep sr = new SalesRep();\n        sr.appointment();\n        BasketBallCourt b = new BasketBallCourt();\n        b.showCourt();\n    }\n}','Inner Classes',0,0,NULL,5),(1815,'compilation fails, non final local variable is access from Method local inner \nclass.','package hello;\n\nimport java.awt.Container;\nimport java.awt.EventQueue;\nimport java.awt.event.ActionEvent;\nimport java.awt.event.InputEvent;\nimport java.awt.event.KeyEvent;\nimport java.io.IOException;\nimport java.io.Serializable;\nimport java.nio.file.DirectoryStream;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Hashtable;\nimport java.util.Iterator;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.NavigableMap;\nimport java.util.PriorityQueue;\nimport java.util.Set;\nimport java.util.SortedMap;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport javax.swing.AbstractAction;\nimport javax.swing.GroupLayout;\nimport javax.swing.InputMap;\nimport javax.swing.JButton;\nimport javax.swing.JComponent;\nimport javax.swing.JFrame;\nimport javax.swing.JPanel;\nimport javax.swing.KeyStroke;\n\npublic class Hello {\n\n    public static void main(String[] args) {\n       LifeTime lt = new LifeTime();\n       Gym.BasketBallCourt bc = lt.new BasketBallCourt();\n       \n    }\n\n}\n\nclass Gym{\n    public int weights = 8000;\n    public String name = \"Max\'s gym\";\n    public int price = 50;\n    \n    public void pitch(){\n        BasketBallCourt bc = new BasketBallCourt();\n        System.out.println(\"Were the best gym\");\n    }\n    \n    protected class BasketBallCourt {\n        public String name = \"Maxs court\";\n        \n        public void collectBalls(){\n            System.out.println(\"gimmmie all the balls!\");\n        }\n        \n        public void showCourt(){\n            System.out.println(\" \"+name);\n            System.out.println(\"oooh ahhh\");\n        }\n        \n        public void gymPrice(){\n            System.out.println(\" \"+Gym.this.name);\n            System.out.println(Gym.this.price);\n        }\n        \n        public int Scoreboard(){\n            return 114;\n        }\n    }\n}\n\nclass LifeTime extends Gym{\n    public void showLifeTimesCourt(){\n        int time = 530;\n        class SalesRep{\n            public void appointment(){\n                System.out.println(\"The time of our appointment is: \"+time);\n            }\n            \n        }\n        SalesRep sr = new SalesRep();\n        sr.appointment();\n        BasketBallCourt b = new BasketBallCourt();\n        b.showCourt();\n    }\n}\n\n\n','Inner Classes',0,0,NULL,5),(1816,'Method inner classes cannot be declared protected public private or static','class Gym{\n    public int weights = 8000;\n    public String name = \"Max\'s gym\";\n    public int price = 50;\n    \n    public void pitch(){\n        BasketBallCourt bc = new BasketBallCourt();\n        System.out.println(\"Were the best gym\");\n    }\n    \n    protected class BasketBallCourt {\n        public String name = \"Maxs court\";\n        \n        public void collectBalls(){\n            System.out.println(\"gimmmie all the balls!\");\n        }\n        \n        public void showCourt(){\n            System.out.println(\" \"+name);\n            System.out.println(\"oooh ahhh\");\n        }\n        \n        public void gymPrice(){\n            System.out.println(\" \"+Gym.this.name);\n            System.out.println(Gym.this.price);\n        }\n        \n        public int Scoreboard(){\n            return 114;\n        }\n    }\n}\n\nclass LifeTime extends Gym{\n    public void showLifeTimesCourt(){\n        int time = 530;\n        protected class SalesRep{\n            public void appointment(){\n                System.out.println(\"The time of our appointment is: \"+time);\n            }\n            \n        }\n        SalesRep sr = new SalesRep();\n        sr.appointment();\n        BasketBallCourt b = new BasketBallCourt();\n        b.showCourt();\n    }\n}','Inner Classes',0,0,NULL,5),(1817,'This compiles fine, you can create an anonymous inner class with a subclass\nthen assign it to a superclass reference. ','public class Hello {\n    public static void main(String[] args) {\n       Gym g = new LifeTime() {\n           public void showLifeTimeCourt(){\n               System.out.println(\"LT on meridean\");\n           }\n       };\n    }\n}\n\nclass Gym{\n    public int weights = 8000;\n    public String name = \"Max\'s gym\";\n    public int price = 50;\n    \n    public void pitch(){\n        BasketBallCourt bc = new BasketBallCourt();\n        System.out.println(\"Were the best gym\");\n    }\n    \n    static class BasketBallCourt {\n        public String name = \"Maxs court\";\n        \n        public void collectBalls(){\n            System.out.println(\"gimmmie all the balls!\");\n        }\n        \n        public void showCourt(){\n            System.out.println(\" \"+name);\n            System.out.println(\"oooh ahhh\");\n        }\n        \n        public void gymPrice(){\n\n        }\n        \n        public int Scoreboard(){\n            return 114;\n        }\n    }\n}\n\nclass LifeTime extends Gym{\n    \n    public void showLifeTimesCourt(){\n        final int time = 530;\n        BasketBallCourt bc = new BasketBallCourt();\n        bc.collectBalls();\n    }\n}','Inner Classes',0,0,NULL,5),(1818,'shark.devourSeal() does not compile. \n\nthe anonymous class is declared with a reference type of AquaticLife\nso you can only use methods of that class','public class Hello {\n    public static void main(String[] args) {\n        \n        AquaticLife shark = new Shark(){\n            String unknown = \"unknown species\";\n            public void species(){\n                System.out.println(unknown);\n            }\n        };\n        \n        shark.swim();\n        shark.devourSeal();\n  \n    }\n}\n\nclass AquaticLife{ \n    public void swim(){ \n        System.out.println(\"Bubbles\");\n    }\n     \n    public void useGills(){\n        System.out.println(\"ahhh\");\n    }\n}\n\nclass Shark extends AquaticLife{\n    public void devourSeal(){\n        System.out.println(\"chomp\");\n    }\n    \n    public void swin(){\n        System.out.println(\"Swims up to 60mph\");\n    }\n    public void electricSense(){\n        System.out.println(\"I can feel you in the water\");\n    }\n}','Inner Classes',0,0,NULL,5),(1819,'an inner class can extend the outlying classs','class AquaticLife{ \n    public void swim(){ \n        System.out.println(\"Bubbles\");\n    }\n     \n    public void useGills(){\n        System.out.println(\"ahhh\");\n    }\n    \n    class BottomFeeder extends AquaticLife {\n        public void useGills(){\n            System.out.println(\"I dont have gills\");\n        }\n    }\n}','Inner Classes',0,0,NULL,5),(1820,'It can be abstract,\n	that would mean a concrete class would have to be created in the \n	method so that would probably not be very useful\n\nIt can access private members of the enclosing class\n--------------------------------------------------------\nIt can be marked final but it doesnt\' have to be\n\na method local inner class cannot be marked public, or static','which are true about a method local inner class ?\n\nIt must be marked final\nIt can be marked abstract\nIt can be marked public \nIt can be marked static \nIt can access private members of the enclosing class','Inner Classes',0,0,NULL,5),(1821,'Compilation fails with an error at the line where the semicolon should be \nafter the inner class','public class TestObj {\n	public static void main(SA){\n		Object ob = new Object() {\n			public boolean equals(Object ob){\n				return true;\n			}\n		}\n		sout(ob.equals(\"FRED\");\n	}\n}','Inner Classes',0,0,NULL,5),(1822,'compilation fails at sout(ob.name);\n\nif the reference variable is of type Object you can only access members \ndefined class Object','public class HorseTest {\n	public static void main(SA){\n		class Horse {\n			public String name;\n			public Horse(String s) {\n				name = s;\n			}\n		}\n		Object ob = new Horse(\"Zippo\");\n		sout(ob.name);\n	}\n}','Inner Classes',0,0,NULL,5),(1823,'57 22\n\nto create an instance of an inner class you have to create it with an \nouter class reference here AbstractTest is abstract so it had to be\ninstantiated with an anonymous inner class to have a concrete reference\nto tie the new anonymous class of type Bar to. ','public abstract class AbstractTest {\n	public int getNum(){\n		return 45;\n	}\n	public abstract class Bar {\n		public int getNum(){\n			return 38;\n		}\n	}\n	public staic void main(String[] args) {\n		AbstractTest t = new AbstractTest(){\n			public int getNum() {\n				return 22;\n			}\n		};\n		AbstractTest.Bar f = t.new Bar() {\n			public int getNum(){\n				return 57;\n			}\n		};\n		sout(f.getNum() + \" \" + t.getNum() );\n	}\n}','Inner Classes',0,0,NULL,5),(1824,'Cathedral.Sanctum s = c.new Sanctum();\n\nor\n\nCathedral.Sanctum s1 = new Cathedral().new Sanctum();','public class Tour {\n	public static void main(SA){\n		Cathedral c = new Cathedral();\n		// insert code\n		s.go();\n	}\n}\n\nclass Cathedral {\n	class Sanctum {\n		void go() { sout(\"spooky\"); }\n	}\n}\n\nproperly instantiate Sanctume','Inner Classes',0,0,NULL,5),(1825,'Will not compile Hello is abstract cannot be instantiated lol ','public abstract class Hello {\n    public static void main(String[] args) {\n        new Hello().test();\n        \n    }\n    \n    void test() {\n        class Breaker{ void foo(){ System.out.println(\"Inner\"); } }\n    }\n    \n    class Breaker {\n        void foo(){\n            System.out.println(\"middle\");\n        }\n    }\n}\n\nclass Breaker{\n    void foo(){\n        System.out.println(\"Outer\");\n    }\n    \n}','Inner Classes',0,0,NULL,5),(1826,'middle\n\nThe closest scoped class is middle. The inner class is declared after the\ncall to foo() and the Outer class comes after any inner classes','public class Hello {\n    public static void main(String[] args) {\n        new Hello().test();\n        \n    }\n    \n    void test() {\n        new Breaker().foo();\n        class Breaker{ void foo(){ System.out.println(\"Inner\"); } }\n    }\n    \n    class Breaker {\n        void foo(){\n            System.out.println(\"middle\");\n        }\n    }\n}\n\nclass Breaker{\n    void foo(){\n        System.out.println(\"Outer\");\n    }\n    \n}','Inner Classes',0,0,NULL,5),(1827,'the call to blue in main fails because it is called before the anon class\nis created. \n\nanonymous class bigBlue works fine, you can define anonymous classes as\nmembers \n\nalso anon class blue forgets to end with a ; \n\nabsract classes cannnot have private abstract members, how would they\nbe instantiated ?\n\nbecaue of that BlueGill cannot properly override method numberOfFins()\n\nan overriding method can choose not to throw the same exception or can \nthrow a narrower one. \n','public class Hello {\n    public static void main(String[] args) {\n        blue.biteHook();\n        \n        BlueGill blue = new BlueGill(){\n            public void biteHook(){\n                System.out.println(\"Not This Time\");\n            }\n        }\n        \n    }\n    \n    BlueGill bigBlue = new BlueGill(){\n        public int bubble() throws IOException {\n            System.out.println(\"Big Bubbles\");\n            return 5;\n        }\n        \n    };\n}\n\nabstract class Fish {\n    public abstract void swim();\n    private abstract int numberOfFins();\n    \n}\n\nclass BlueGill extends Fish {\n    public void swim(){\n        System.out.println(\"Swims in lakes\");\n    }\n    \n    public void biteHook() throws IOException {\n        System.out.println(\"What the hell\");\n    }\n    \n    public int bubble() throws Exception{\n        System.out.println(\"bubble bubble\");\n        return 2;\n    }\n}','Inner Classes',0,1,NULL,5),(1828,'numberOfFins() in abstract class Fish does not throw SQLException\n	so the override in BlueGill cannot throw a new Exception.\n\nbiteHook is declared in BlueGill then overriden in the annon class with\nthe same exception so its ok.\n\nthen the anon class does not override the method numberOfFins which was \nnot properly overriden in the abstract class so that makes the anon class\nnot compile. If it had overriden numberOfFins() then it could have compiled\n\nstill though the NOF in BlueGill threw that SQLException so it wont ever compile..','public class Hello {\n    public static void main(String[] args) {     \n        BlueGill blue = new BlueGill(){\n            public void biteHook() throws IOException{\n                System.out.println(\"Not This Time\");\n            }\n            public void biteHook(boolean yesno) throws NullPointerException{\n                System.out.println(\"That worm looks so tasty\");\n            }\n            \n        };\n        \n    }\n}\n\nabstract class Fish {\n    public abstract void swim() throws Exception;\n    public abstract int numberOfFins();\n    public static void breathe(){\n        System.out.println(\"ahhh\");\n    }\n    \n    \n}\n\nclass BlueGill extends Fish {\n    public void swim(){\n        breathe();\n        System.out.println(\"Swims in lakes\");\n    }\n    \n    public void biteHook() throws IOException {\n        System.out.println(\"What the hell\");\n    }\n    \n    public int numberOfFins() throws SQLException {\n        return 4;\n    }\n    \n    public int bubble() throws Exception{\n        System.out.println(\"bubble bubble\");\n        return 2;\n    }\n}','Inner Classes',0,0,NULL,5),(1829,'{ Car.this.drive(); }\n\nEngine() { Car.this.drive(); }','public class  Car {\n	class Engine {\n		// insert here\n	}\n	public static void main(SA){\n		new Car().go();\n	}\n	void go() {\n		new Engine();\n	}\n	void drive() { sout(\"hi\"); }\n}\n\n// what can be given at insert here to produce \"hi\" ?\n','Inner Classes',0,0,NULL,5),(1830,'no output is produced, the inner classes are valid and the exceptions are \nthrown properly','public class City {\n	class Manhattan {\n		void doStuff() throws Exception { sout(\"x \"); }\n	}\n	class Timesquare extends Manhattan {\n		void doStuff throws Exception {  }\n	}\n\n	public static void main(Stringp]] args) throws Exception{\n		new City().go();\n	}\n	void go() throws Exception { new Timesquare().doStuff(); }\n}','Inner Classes',0,0,NULL,5),(1831,'21','public class Navel {\n	private int size = 7;\n	private static int length = 3;\n	public static void main(String[] args) {\n		new Navel().go();\n	}\n	void go(){\n		int size = 5;\n		sout( new Gazer().adder() );\n	}\n	class Gazer {\n		int adder() { return size * length; }\n	}\n}	','Inner Classes',0,0,NULL,5),(1832,'ahhh\nahhh\nSwims in a lake','public class Hello {\n    public static void main(String[] args) {     \n        BlueGill blue = new BlueGill();\n        blue.breathe();\n        blue.swim();\n        \n    }\n}\n\nabstract class Fish {\n    public abstract void swim() throws Exception;\n    public abstract int numberOfFins();\n    public static void breathe(){\n        System.out.println(\"ahhh\");\n    }   \n}\n\nclass BlueGill extends Fish {\n    public void swim(){\n        breathe();     \n        System.out.println(\"Swims in a lake\");\n    }\n    \n    public int numberOfFins(){\n        return 5;    \n    }   \n}','Inner Classes',0,0,NULL,5),(1833,'ahhh','public class Hello {\n    public static void main(String[] args) {     \n        BlueGill blue = new BlueGill();\n        \n        Fish.breathe();\n        \n    }\n}\n\nabstract class Fish {\n    public abstract void swim() throws Exception;\n    public abstract int numberOfFins();\n    public static void breathe(){\n        System.out.println(\"ahhh\");\n    }   \n}\n\nclass BlueGill extends Fish {\n    public void swim(){\n        breathe();     \n        System.out.println(\"Swims in a lake\");\n    }\n    \n    public int numberOfFins(){\n        return 5;    \n    }   \n}','Inner Classes',0,0,NULL,5),(1834,'compiles','abstract class Fish {\n    public static int species = 100;\n    public abstract void swim() throws Exception;\n    public abstract int numberOfFins();\n    public static void breathe(){\n        System.out.println(\"ahhh\");\n    }   \n}\n\nclass BlueGill extends Fish {\n    public void swim(){\n        breathe();     \n        System.out.println(species);\n        System.out.println(\"Swims in a lake\");\n    }\n    \n    public int numberOfFins(){\n        return 5;    \n    }   \n}','Inner Classes',0,0,NULL,5),(1835,'compilation fails, \nClass sorter must be delcared static to be used in static methood main. ','public class Pockets {\n	public static void main(SA){\n		String[] sa = {\"nickle\",\"button\", \"key\", \"lint\" };\n		Sorter s = new Sorter();\n		for(String s2: sa) sout( s2+\" \" );\n		Arrays.sort(sa,s);\n		sout();\n		for(String s2 : sa) sout( s2+\" \" );\n		\n	}\n	class Sorter implements Comparator<String> {	\n		public int compare(String a, String b) {\n			return b.compareTo(a);\n		}\n	}\n}','Collections',0,0,NULL,5),(1836,'ahhh\n100\nSwims in a lake\n\noverriding methods cannot throw new or broader checked exceptions, they can throw none at all. ','public class Hello {\n    public static void main(String[] args) {     \n        BlueGill blue = new BlueGill();\n        blue.swim();\n        \n    }\n}\nclass BlueGill extends Fish {\n    public void swim(){\n        breathe();     \n        System.out.println(species);\n        System.out.println(\"Swims in a lake\");\n    }\n    \n    public int numberOfFins(){\n        return 5;    \n    }   \n}\n\nabstract class Fish {\n    public static int species = 100;\n    public abstract void swim() throws Exception;\n    public abstract int numberOfFins();\n    public static void breathe(){\n        System.out.println(\"ahhh\");\n    }   \n}\n   ','Inner Classes',0,0,NULL,5),(1837,'will not compile, BlueGill is an inner class therefor must be declared static\nto be used in static method main. ','public class Hello {\n    public static void main(String[] args) {     \n        BlueGill blue = new BlueGill();\n        blue.swim();\n        \n    }\n class BlueGill extends Fish {\n    public void swim(){\n        breathe();     \n        System.out.println(species);\n        System.out.println(\"Swims in a lake\");\n    }\n    \n    public int numberOfFins(){\n        return 5;    \n    }   \n}\n}\n\nabstract class Fish {\n    public static int species = 100;\n    public abstract void swim() throws Exception;\n    public abstract int numberOfFins();\n    public static void breathe(){\n        System.out.println(\"ahhh\");\n    }   \n}','Inner Classes',0,0,NULL,5),(1838,'ahhh\n100\nSwims in lake','public class Hello {\n    public static void main(String[] args) {     \n        BlueGill blue = new BlueGill();\n        blue.swim();\n        \n    }\n static class BlueGill extends Fish {\n    public void swim(){\n        breathe();     \n        System.out.println(species);\n        System.out.println(\"Swims in a lake\");\n    }\n    \n    public int numberOfFins(){\n        return 5;    \n    }   \n}\n}\n\nabstract class Fish {\n    public static int species = 100;\n    public abstract void swim() throws Exception;\n    public abstract int numberOfFins();\n    public static void breathe(){\n        System.out.println(\"ahhh\");\n    }   \n}','Inner Classes',0,0,NULL,5),(1839,'Arraylist doesn\'t have a method that returns the given object. \n\nalso you cannot return null when the return type is primitive.','public class Hello {\n    public static void main(String[] args) {     \n        Locker<SchoolSupplies> locker = new Locker<>();\n        locker.stuff.add(new Book(\"AAA\"));\n        locker.stuff.add(new Book(\"BBB\"));\n        \n        System.out.println(locker.getOut(new Book(\"AAA\")));\n        \n    }\n}\n\nclass Locker<T> {\n    ArrayList<T> stuff = new ArrayList<T>();\n    public T getOut(T that){\n        return stuff.get(that);\n    }\n}\n\nabstract class SchoolSupplies{\n    public abstract void use();\n    public abstract int lend();\n    public abstract boolean isCool();\n}\n\nclass Book extends SchoolSupplies{\n    private String name;\n    Book(String n){\n        name = n;\n    }\n    public void use(){\n        System.out.println(\"Read it\");\n    }\n    \n    public int lend(){\n        System.out.println(\"I need back by 4th\");\n        return 4;\n    }\n    \n    public boolean isCool(){\n        return false;\n    }\n}\n\nclass Pen extends SchoolSupplies {\n    public void use(){\n        System.out.println(\"doodle\");\n    }\n    \n    public int lend(){\n        System.out.println(\"just have it\");\n        return null;\n    }\n    \n    public boolean isCool(){\n        return true;\n    }\n}','Inner Classes',0,0,NULL,5),(1840,'compiles with a warning','public class Hello {\n    public static void main(String[] args) {     \n\n        List<Animal> animals = new ArrayList<Animal>();\n        animals.add(new Dog());\n        animals.add(new Cat());\n        \n        addAnimal(animals);\n    \n    }\n    \n    public static void addAnimal(List animals) {\n	animals.add(new Object());\n    }\n}','Generics',0,0,NULL,5),(1841,'will not compile,\n\ndefault constructors in Dog and Cat do not give proper calls to super()\nanimal non-defautl constructor','public class Hello {\n    public static void main(String[] args) {     \n\n        Animal a = new Animal(6,\"dog\");\n        System.out.println(a.getSize());\n    \n    }\n\n}\n        \nclass Animal implements Comparable<Animal>{\n    private int size;\n    private String name;\n    public Animal(int s, String n){\n        size = s;\n        name = n;\n        \n    }\n    public int getSize(){\n        return size;\n    }\n    public int compareTo(Animal a){\n        int asize = a.getSize();\n        int bsize = this.size;\n        \n        if(asize < bsize)\n            return 1;\n        else if(asize == bsize)\n            return 0;\n        else\n            return -1;\n        \n        \n    }\n    \n    public String toString(){\n        return name;\n    }\n}\n\nclass Dog extends Animal{}\nclass Cat extends Animal{} ','General',0,0,NULL,5),(1842,'will not compile,\n\n	should be...\n		for(Shaveable s : sList){\n			...','public class Hello {\n    public static void main(String[] args) {     \n        List<Spankable> spanklist = new ArrayList<>();\n        spanklist.add(new Doll());\n        spanklist.add(new Doll());\n        \n    }\n    \n    public static void runit(List<? extends Shaveable> sList){\n        for(Spankable s : sList){\n            s.shave();\n        }\n    }\n\n}\n\ninterface Shaveable{\n    public void shave();\n}\n\ninterface Spankable extends Shaveable{\n    public void spank();\n}\n\nclass Doll implements Spankable{\n    public void spank(){\n        System.out.println(\"OW!\");\n    }\n    \n    public void shave(){\n        System.out.println(\"HMMM : O\");\n    }\n}','General',0,0,NULL,5),(1843,'compiles\n\nhmmm : O\nhmmm : O','public class Hello {\n    public static void main(String[] args) {     \n        List<Spankable> spanklist = new ArrayList<>();\n        spanklist.add(new Doll());\n        spanklist.add(new Doll());\n        \n    }\n    \n    public static void runit(List<? extends Shaveable> sList){\n        for(Shaveable s : sList){\n            s.shave();\n        }\n    }\n\n}\n\ninterface Shaveable{\n    public void shave();\n}\n\ninterface Spankable extends Shaveable{\n    public void spank();\n}\n\nclass Doll implements Spankable{\n    public void spank(){\n        System.out.println(\"OW!\");\n    }\n    \n    public void shave(){\n        System.out.println(\"HMMM : O\");\n    }\n}','General',0,0,NULL,5),(1844,'HMMM : O\nHMMM : O\n\n','public class Hello {\n    public static void main(String[] args) {     \n        List<Spankable> spanklist = new ArrayList<>();\n        spanklist.add(new Doll());\n        spanklist.add(new Doll());\n        \n        runit(spanklist);\n        \n    }\n    \n    public static void runit(List<? extends Spankable> sList){\n        for(Shaveable s : sList){\n            s.shave();\n        }\n    }\n\n}\n\ninterface Shaveable{\n    public void shave();\n}\n\ninterface Spankable extends Shaveable{\n    public void spank();\n}\n\nclass Doll implements Spankable{\n    public void spank(){\n        System.out.println(\"OW!\");\n    }\n    \n    public void shave(){\n        System.out.println(\"HMMM : O\");\n    }\n}','General',0,0,NULL,5),(1845,'HMMM : O\nHMMM : O','class Hello {\n    public static void main(String[] args) {     \n        List<Spankable> spanklist = new ArrayList<>();\n        spanklist.add(new Doll());\n        spanklist.add(new Doll());\n        \n        runit(spanklist);\n        \n    }\n    \n    public static void runit(List<? extends Shaveable> sList){\n        for(Shaveable s : sList){\n            s.shave();\n        }\n    }\n\n}\n\ninterface Shaveable{\n    public void shave();\n}\n\ninterface Spankable extends Shaveable{\n    public void spank();\n}\n\nclass Doll implements Spankable{\n    public void spank(){\n        System.out.println(\"OW!\");\n    }\n    \n    public void shave(){\n        System.out.println(\"HMMM : O\");\n    }\n}                     ','General',0,0,NULL,5),(1846,'HMMM : O\nHMMM : O','class Hello {\n    public static void main(String[] args) {     \n        List<Doll> spanklist = new ArrayList<>();\n        spanklist.add(new Doll());\n        spanklist.add(new Doll());\n        \n        runit(spanklist);\n        \n    }\n    \n    public static void runit(List<? extends Shaveable> sList){\n        for(Shaveable s : sList){\n            s.shave();\n        }\n    }\n\n}\n\ninterface Shaveable{\n    public void shave();\n}\n\ninterface Spankable extends Shaveable{\n    public void spank();\n}\n\nclass Doll implements Spankable{\n    public void spank(){\n        System.out.println(\"OW!\");\n    }\n    \n    public void shave(){\n        System.out.println(\"HMMM : O\");\n    }\n}                  ','General',0,0,NULL,5),(1847,'/tmp/google/file.txt','class Hello {\n    public static void main(String[] args) {     \n        Path p1 = Paths.get(\"/home/max/tmp\");\n        Path p2 = Paths.get(\"/tmp/google/file.txt\");\n        System.out.println(p1.resolve(p2));\n        \n    }\n\n}','General',0,0,NULL,5),(1848,'/home/max/tmp/tmp/google/file.txt','class Hello {\n    public static void main(String[] args) {     \n        Path p1 = Paths.get(\"/home/max/tmp\");\n        Path p2 = Paths.get(\"tmp/google/file.txt\");\n        System.out.println(p1.resolve(p2));\n        \n    }\n\n}','IO',0,0,NULL,5),(1849,'/home/max/tmp/google/file.txt','class Hello {\n    public static void main(String[] args) {     \n        Path p1 = Paths.get(\"/home/max/tmp\");\n        Path p2 = Paths.get(\"google/file.txt\");\n        System.out.println(p1.resolve(p2));\n        \n    }\n\n}','IO',0,0,NULL,5),(1850,'/home/max/tmp/file.txt','class Hello {\n    public static void main(String[] args) {     \n        Path p1 = Paths.get(\"/home/max/tmp\");\n        Path p2 = Paths.get(\"file.txt\");\n        System.out.println(p1.resolve(p2));\n        \n    }\n\n}','General',0,0,NULL,5),(1851,'home/max/tmp/file.txt','class Hello {\n    public static void main(String[] args) {     \n        Path p1 = Paths.get(\"home/max/tmp\");\n        Path p2 = Paths.get(\"file.txt\");\n        System.out.println(p1.resolve(p2));\n        \n    }\n\n}','General',0,0,NULL,5),(1852,'home/max/tmp/file.txt/file.txt','class Hello {\n    public static void main(String[] args) {     \n        Path p1 = Paths.get(\"home/max/tmp/file.txt\");\n        Path p2 = Paths.get(\"file.txt\");\n        System.out.println(p1.resolve(p2));\n        \n    }\n\n}','General',0,0,NULL,5),(1853,'file.txt','class Hello {\n    public static void main(String[] args) {     \n        Path p1 = Paths.get(\"\");\n        Path p2 = Paths.get(\"file.txt\");\n        System.out.println(p1.resolve(p2));\n        \n    }\n\n}','General',0,0,NULL,5),(1854,'home/max/tmp/file.txt','class Hello {\n    public static void main(String[] args) {     \n        Path p1 = Paths.get(\"home/max/tmp/file.txt\");\n        Path p2 = Paths.get(\"\");\n        System.out.println(p1.resolve(p2));\n        \n    }\n\n}','General',0,0,NULL,5),(1855,'file.txt/home/max/tmp/file.txt','class Hello {\n    public static void main(String[] args) {     \n        Path p1 = Paths.get(\"home/max/tmp/file.txt\");\n        Path p2 = Paths.get(\"file.txt\");\n        System.out.println(p2.resolve(p1));\n        \n    }\n\n}','General',0,0,NULL,5),(1856,'true\n\nHowever Animal does not have an instanceof test in its boolean so be \ncareful you could get a classcastexception','public class Hello<T> {\n    public static void main(String[] args){\n\n        ArrayList<? extends Animal> c = makeArrayList(new Animal(5));\n        \n        Animal max = new Animal(100);\n        Animal bear = new Animal(45);\n        Animal Hippo = new Animal(45);\n        \n        System.out.println(bear.equals(Hippo));    \n    } \n    public static <G extends Animal> ArrayList<G> makeArrayList(G g){\n        ArrayList<G> genlist = new ArrayList();\n        genlist.add(g);\n        return genlist;\n        \n    }\n}\n\nclass Animal{\n    private int size;\n    public Animal(int s){\n        size = s;\n    }\n    public void makeSound(){\n            System.out.println(\"Sound!\");\n            \n    }\n    \n    public int getSize(){\n        return size;\n    }\n\n    public boolean equals(Object o){\n        // equals without instanceof \n        if(((Animal)o).getSize() == this.size){\n            return true;\n        } else {\n            return false;\n        }\n        \n    }\n}\n\nclass Flower {\n    public void pretty(){\n        System.out.println(\"i look so pretty\");\n    }\n}','General',0,0,NULL,5),(1857,'ClassCastException','public class Hello<T> {\n    public static void main(String[] args){\n\n        ArrayList<? extends Animal> c = makeArrayList(new Animal(5));\n        \n        Animal max = new Animal(100);\n        Animal bear = new Animal(45);\n        Animal Hippo = new Animal(45);\n        Flower flower = new Flower();\n        \n        System.out.println(bear.equals(Hippo));  \n        System.out.println(max.equals(flower));\n    } \n    public static <G extends Animal> ArrayList<G> makeArrayList(G g){\n        ArrayList<G> genlist = new ArrayList();\n        genlist.add(g);\n        return genlist;\n        \n    }\n}\n\nclass Animal{\n    private int size;\n    public Animal(int s){\n        size = s;\n    }\n    public void makeSound(){\n            System.out.println(\"Sound!\");\n            \n    }\n    \n    public int getSize(){\n        return size;\n    }\n\n    public boolean equals(Object o){\n        // equals without instanceof \n        if(((Animal)o).getSize() == this.size){\n            return true;\n        } else {\n            return false;\n        }\n        \n    }\n}\n\nclass Flower {\n    public void pretty(){\n        System.out.println(\"i look so pretty\");\n    }\n}','General',0,0,NULL,5),(1858,'instanceMethod() in Bar\nclassMethod() in Foo\n\nBriefly, when you override a method, you still get the benefits of run-time polymorphism, and when you hide, you don\'t\n\nWhy do we get instanceMethod from Bar, but classMethod() from Foo? Aren\'t we using the same instance f to access both of these? Yes we are - but since one is overriding and the other is hiding, we see different behavior.\n\nSince instanceMethod() is (drum roll please...) an instance method, in which Bar overrides the method from Foo, at run time the JVM uses the actual class of the instance f to determine which method to run. Although f was declared as a Foo, the actual instance we created was a new Bar(). So at runtime, the JVM finds that f is a Bar instance, and so it calls instanceMethod() in Bar rather than the one in Foo. That\'s how Java normally works for instance methods.\n\nWith classMethod() though. since (ahem) it\'s a class method, the compiler and JVM don\'t expect to need an actual instance to invoke the method. And even if you provide one (which we did: the instance referred to by f) the JVM will never look at it. The compiler will only look at the declared type of the reference, and use that declared type to determine, at compile time, which method to call. Since f is declared as type Foo, the compiler looks at f.classMethod() and decides it means Foo.classMethod. It doesn\'t matter that the instance reffered to by f is actually a Bar - for static methods, the compiler only uses the declared type of the reference. That\'s what we mean when we say a static method does not have run-time polymorphism.\n\nBecause instance methods and class methods have this important difference in behavior, we use different terms - \"overriding\" for instance methods and \"hiding\" for class methods - to distinguish between the two cases. And when we say you can\'t override a static method, what that means is that even if you write code that looks like it\'s overriding a static method (like the first Foo and Bar at the top of this page) - it won\'t behave like an overridden method. ','class Foo {\n    public static void classMethod() {\n        System.out.println(\"classMethod() in Foo\");\n    }\n \n    public void instanceMethod() {\n        System.out.println(\"instanceMethod() in Foo\");\n    }\n}\n \nclass Bar extends Foo {\n    public static void classMethod() {\n        System.out.println(\"classMethod() in Bar\");\n    }\n \n    public void instanceMethod() {\n        System.out.println(\"instanceMethod() in Bar\");\n    }\n}\n  \nclass Test {\n    public static void main(String[] args) {\n        Foo f = new Bar();\n        f.instanceMethod();\n        f.classMethod();\n    }\n}','General',0,0,NULL,5),(1859,'all animals eat\nall animals eat\nall animals eat\nEat salmon\n\nIt is allowed to call a static method of the class on an instance \nvariable, but it is confusing and not recomneded. \n\nstatic variables are not overriden by subclass methods they are hidden\n\nso, at runtime there will be no polymorphism for static methods','class Bear extends Animal{\n    private static int ALLBEARSAREBIG = 100;\n    \n    public Bear(){\n        super(ALLBEARSAREBIG);\n        \n    }\n    \n    public static void eat(){\n        System.out.println(\"Eat salmon\");\n    }\n    \n}\n\nclass Animal{\n    private int size;\n    public Animal(int s){\n        size = s;\n    }\n    public static void eat(){\n        System.out.println(\"all animals eat\");\n    }\n    public void makeSound(){\n            System.out.println(\"Sound!\");\n            \n    }\n    \n    public int getSize(){\n        return size;\n    }\n\n    public boolean equals(Object o){\n        // equals without instanceof \n        if(((Animal)o).getSize() == this.size){\n            return true;\n        } else {\n            return false;\n        }\n        \n    }\n}\n\npublic class Hello<T> {\n    public static void main(String[] args){\n        Animal cat = new Animal(5);\n        Animal bear = new Bear();\n        \n        cat.eat();\n        Animal.eat();\n        bear.eat();\n        Bear.eat();\n\n    } \n }','General',0,0,NULL,5),(1860,'will not compile you cannot override a static method\n\nto fix change eat in Bear to static or do something else with the other class\nand varialbes','public class Hello<T> {\n    public static void main(String[] args){\n        Animal cat = new Animal(5);\n        Animal bear = new Bear();\n        \n        cat.eat();\n        Animal.eat();\n        bear.eat();\n        Bear.eat();\n\n    } \n }\n\nclass Animal{\n    private int size;\n    public Animal(int s){\n        size = s;\n    }\n    public static void eat(){\n        System.out.println(\"all animals eat\");\n    }\n    public void makeSound(){\n            System.out.println(\"Sound!\");\n            \n    }\n    \n    public int getSize(){\n        return size;\n    }\n\n    public boolean equals(Object o){\n        // equals without instanceof \n        if(((Animal)o).getSize() == this.size){\n            return true;\n        } else {\n            return false;\n        }\n        \n    }\n}\n\nclass Bear extends Animal{\n    private static int ALLBEARSAREBIG = 100;\n    \n    public Bear(){\n        super(ALLBEARSAREBIG);\n        \n    }\n    \n    public void eat(){\n        System.out.println(\"Eat salmon\");\n    }\n    \n}','General',0,0,NULL,5),(1861,'will not compile,\n\ncall to super in Bear defautl constructor does not fit with ANimal int constructor\n\nremeber if you provide a parameterized constructor the implicit defautl one\ngoes away','public class Hello<T> {\n    public static void main(String[] args){\n        Animal cat = new Animal(5);\n        Animal bear = new Bear();\n        \n        cat.eat();\n        Animal.eat();\n        bear.eat();\n        Bear.eat();\n\n    } \n }\n\nclass Animal{\n    private int size;\n    public Animal(int s){\n        size = s;\n    }\n    public static void eat(){\n        System.out.println(\"all animals eat\");\n    }\n    public void makeSound(){\n            System.out.println(\"Sound!\");\n            \n    }\n    \n    public int getSize(){\n        return size;\n    }\n\n    public boolean equals(Object o){\n        // equals without instanceof \n        if(((Animal)o).getSize() == this.size){\n            return true;\n        } else {\n            return false;\n        }\n        \n    }\n}\n\nclass Bear extends Animal{\n\n    \n    public Bear(){\n        \n    }\n    \n    public static void eat(){\n        System.out.println(\"Eat salmon\");\n    }\n    \n}\n\nclass Flower {\n    public void pretty(){\n        System.out.println(\"i look so pretty\");\n    }\n}','General',0,0,NULL,5),(1862,'Will not compile, reference to resolve is ambiguous. \n\nboth resolve(String) and resolve(Path) match','Path p1 = Paths.get(\"/home/maxbisesi/file.txt\");\n        System.out.println(p1.resolve(null));','IO',0,0,NULL,5),(1863,'Compiles fine! you can use the overloaded method within the inner class\n\nTheres 8 people here so get the fire going','public class Hello {\n\n    public static void main(String[] args) {\n        \n        Burnable stick = new Burnable(){\n            int people = 8;\n            public void burn(){\n                System.out.println(\"Theres \"+people+\" people here so get the fire going\");\n            }\n            \n            public int unburn(){\n                System.out.println(\"That\'s impossible\");\n                return 0;\n            }\n            \n            public void shakeoff(int x){\n                System.out.println(\"That was my shoe!\"+x);\n            }\n            \n            public void shakeoff(){\n                \n                this.shakeoff(4);\n                System.out.println(\"its off\");\n            }\n            \n            \n            \n        };\n        \n        stick.burn();\n    }\n\n}\n\ninterface Burnable{\n    int people = 10;\n    void burn();\n    void shakeoff(int z);\n    int unburn();\n}','Inner Classes',0,0,NULL,5),(1864,'','The thread is the worker and the runnable is the job to be done','Threads',0,0,NULL,5),(1865,'Thread()\nThread(Runnable target)\nThread(Runnable target, String name)\nThread(String name)','Thread Constructors','Threads',0,0,NULL,5),(1866,'after the run() is complete','When is a thread considered dead?','Threads',0,0,NULL,5),(1867,'It is not guarenteed that the threads will be started in the order that\nthey are declared. Or that they will finish and start at the same time\n\nor that a loop will complete once it has begun.','Nothing is guarenteed in threading other than Each thread will start and each thread\nwill run to completion. ','Threads',0,0,NULL,5),(1868,'','The order in which runnable threads are chosen to run is not guarenteed.','Threads',0,0,NULL,5),(1869,'Will not compile, unreported Exception InteruptedException must be caught\nor thrown. ','public class Hello {\n    public static void main(String[] dicks){\n       Thread t = new Thread(new FooRunnable());\n       t.start();\n              \n\n    }\n}\n\nclass FooRunnable implements Runnable {\n    public void run(){\n        for(int x = 1; x <= 100; x++){\n            if((x % 10) == 0){\n                System.out.println(\"next 10\");\n            }\n            System.out.println(x+\" \");\n            Thread.sleep(1000); \n            }\n            \n        }\n    }\n}','Threads',0,0,NULL,5),(1870,'','A thread gets a default priority that is the default priority of the thread of\nexecution that creates it. ','Threads',0,0,NULL,5),(1871,'default thread priority is 5','FooRunnable r = new FooRunnable();\nThread t = new Thread(r);\nt.setPriority(8);\nt.start();\n','Threads',0,0,NULL,5),(1872,'Thread.MIN_PRIORITY (1)\nThread.NORM_PRIORITY (5)\nThread.MAX_PRIORITY (10)\n','Thread class constants ','Threads',0,0,NULL,5),(1873,'will cause a thread to go from running to runnable, but it might not do\nanything at all. ','Thread.yeild()','Threads',0,0,NULL,5),(1874,'FALSE','join() is static','Threads',0,0,NULL,5),(1875,'takes the currently running thread(if this were in the main method then that\nwould be the main thread) and joins it onto the end of the thread\nreferenced by t. \n\n','Thread t = new Thread();\nt.start();\nt.join();','Threads',0,0,NULL,5),(1876,'will not compile, only methods or blocks can be synchronized not variables\nor classes','public class Hello implements Runnable{\n    private synchronized Account acct = new Account(50);\n    \n    public static void main(String[] dicks){\n       Hello h = new Hello();\n       Thread one = new Thread(h);\n       Thread two = new Thread(h);\n       one.setName(\"Max\");\n       two.setName(\"Angela\");\n       \n       one.start();\n       two.start();\n\n    }\n    \n    public void run(){\n        for(int x = 0; x < 5; x++){\n            makeWithdrawl(10);\n            if(acct.getBalance() < 0){\n                System.out.println(\"account is overdrawn\");\n            }\n        }\n    }\n    \n    private synchronized void makeWithdrawl(int amt){\n        //this operation is not atomic\n        if(acct.getBalance() >= amt){\n            System.out.println(Thread.currentThread().getName()+\" is going to withdraw\");\n            \n            try{\n                Thread.sleep(500);\n            } catch(InterruptedException e){\n                \n            }\n            \n            acct.withdraw(amt);\n            System.out.println(Thread.currentThread().getName() + \" completes the withdraw\");\n        } else {\n            System.out.println(\"insufficinet funds for: \" + Thread.currentThread().getName() );\n        }\n    }\n}','Threads',0,0,NULL,5),(1877,'','If a thread goes to sleeep it holds any locks it has','Threads',0,0,NULL,5),(1878,'will not compile, method local inner classes must be declared before they \nare used. ','private JPanel createAddFlashCardPanel() {\n        JPanel jp = new JPanel(new FlowLayout());\n        \n        \n        JTextArea ja = new JTextArea(17,78);\n        ja.setWrapStyleWord(true);\n        JScrollPane question = new JScrollPane(ja);\n        ja.setTabSize(5);\n        ja.setFont(textfont);\n        \n        \n        AbstractDocument doc = (AbstractDocument) ja.getDocument();\n        doc.addDocumentListener(new TextChanger());\n        \n        class TextChanger implements DocumentListener {\n\n        @Override\n        public void insertUpdate(DocumentEvent e) {\n            try{\n                String addedtext = doc.getText(e.getOffset(), e.getLength());\n                System.out.println(addedtext);\n            } catch(BadLocationException blexc){\n                \n            }\n        }\n        @Override\n        public void removeUpdate(DocumentEvent e) {\n            \n        }\n        @Override\n        public void changedUpdate(DocumentEvent e) {\n            \n        }\n       \n    }\n  \n    ','Threads',0,0,NULL,5),(1879,'will not compile, foundcards is defined only in the scope of the try{}\n\nto fix \n\nput it above try{ } ',' private SwingWorker<String, String> worker = new SwingWorker<String, String>() {\n        public String doInBackground() {\n            while (!searchwords.isEmpty()) {\n                String word = searchwords.poll();\n                if(word == null){\n                    continue;\n                }\n                \n                try{\n                    ArrayList<Card> foundcards = Database.searchDatabase(word);\n                } catch (IOException e){\n                    System.out.println(\"problem serarch db\");\n                }\n\n                for (Card c : foundcards) {\n\n                }\n\n            }\n        }','Threads',0,0,NULL,5),(1880,'public static int getCount() {\n	synchronized(MyClass.class) {\n		return count;\n	}\n}\n\n- there is only one copyy of static data you\'re trying to protect so you\nonly need one lock per class to synchronize static methods- a lock for the whole class.\n\nevery class loaded in java has a corresponding instance of java.lang.Class\nrepresenting that Class. It\'s that Class instance used to lock on \nstatic methods. ','public static synchronized int getCount() {\n	return count;\n}\n\nhow to could this method be re made excactly using a synchronized block ?','Threads',0,0,NULL,5),(1881,'100x A\n\n100x AA\n\n100x AAA\n\nall these threads synchronize onto the same object','public class Hello extends Thread {\n   StringBuilder sb;\n    \n    public Hello(StringBuilder stb){\n        sb = stb;\n    }\n   \n    \n    public static void main(String[] dicks){\n        StringBuilder sbmain = new StringBuilder(\"A\");  \n        Hello a = new Hello(sbmain);\n        Hello b = new Hello(sbmain);\n        Hello c = new Hello(sbmain);\n        a.start();\n        b.start();\n        c.start();\n    }\n    \n    public void run(){\n        \n        synchronized(sb){\n            for(int i = 0; i < 100; i++){\n                System.out.println(sb);\n            }\n            sb.append(\"A\");  \n        }\n    }\n}','Threads',0,0,NULL,5),(1882,'un predicatable results - without synch. you cannot be sure what thread will\nwill be executing when. ','public class Hello extends Thread {\n   StringBuilder sb;\n    \n    public Hello(StringBuilder stb){\n        sb = stb;\n    }\n   \n    public static void main(String[] dicks){\n        StringBuilder sbmain = new StringBuilder(\"A\");  \n        Hello a = new Hello(sbmain);\n        Hello b = new Hello(sbmain);\n        Hello c = new Hello(sbmain);\n        a.start();\n        b.start();\n        c.start();\n    }  \n    public void run(){\n            for(int i = 0; i < 1000; i++){\n                System.out.println(i+\" \"+sb);\n            }\n            sb.append(\"A\");   \n    }\n}','Threads',0,0,NULL,5),(1883,'got it','Threads calling non-static synchronized methods in the same class will only\nblock each other if they\'re invoked using THE SAME INSTANCE. that\'s because theyeach\nlock on this instance, and if they\'re called using two differenct instances,\nthey get two locks, which do not interfere with each other. ','Threads',0,0,NULL,5),(1884,'got it ','Threads calling static synchronized methods in the same class will always \nblock each other- they all lock on the same class instance. ','Threads',0,0,NULL,5),(1885,'','a static synchronized method and a non-static synhcronized method will not block\neach other, ever. the static method locks on a Class instance, while the non\nstatic locks on this instance. These actions do not interfere with each other.','Threads',0,0,NULL,5),(1886,'','Generally use synchronization anytime more than one thread is accessing mutable\ndata. Dont worry about local varialbes each thread gets its own copy of those\nTwo threads executing the same method at the same time will use different\ncopiies of local variables.\n	However:\n		do worry about static and non sttaic fields if they contain data that \n		can be changed. ','Threads',0,0,NULL,5),(1887,'5\n5\n5','public class Hello {\n    \n   public static void main (String [] args){\n       Thing thing = new Thing();\n       \n       new Thread(new Accessor(thing),\"Max\").start();\n       new Thread(new Accessor(thing),\"Bart\").start();\n       new Thread(new Accessor(thing),\"Thread C\").start();\n \n   }\n}\n\nclass Accessor implements Runnable{\n    private Thing thisthing;\n    \n    public Accessor(Thing x){\n        thisthing = x;\n    }\n    \n    public void run(){\n        thisthing.setNonstaticField(5);\n        System.out.println(thisthing.getNonstaticField());\n    }\n}\n\nclass Thing {\n    private static int staticField;\n    private int nonstaticField;\n    \n    public static synchronized int getStaticField(){\n        return staticField;\n    }\n    \n    public static synchronized void setStaticField(int x){\n        //use class not this\n        Thing.staticField = x;\n    }\n    \n    public synchronized int getNonstaticField(){\n        return nonstaticField;\n    }\n    \n    public synchronized void setNonstaticField(int y){\n        this.nonstaticField = y;\n    }\n}','Threads',0,0,NULL,5),(1888,'un predictable results, to make predictable\n\nput loop code inside a synhcronized block that locks onto thisthing!','public class Hello {\n    \n   public static void main (String [] args){\n       Thing thing = new Thing();\n       \n       new Thread(new Accessor(thing),\"Max\").start();\n       new Thread(new Accessor(thing),\"Bart\").start();\n       new Thread(new Accessor(thing),\"Thread C\").start();\n \n   }\n}\n\nclass Accessor implements Runnable{\n    private Thing thisthing;\n    \n    public Accessor(Thing x){\n        thisthing = x;\n    }\n    \n    public void run(){\n        for(int i = 1; i <= 10; i++){\n            thisthing.setNonstaticField(i);\n            System.out.println(thisthing.getNonstaticField());\n        }\n    }\n}\n\nclass Thing {\n    private static int staticField;\n    private int nonstaticField;\n    \n    public static synchronized int getStaticField(){\n        return staticField;\n    }\n    \n    public static synchronized void setStaticField(int x){\n        //use class not this\n        Thing.staticField = x;\n    }\n    \n    public synchronized int getNonstaticField(){\n        return nonstaticField;\n    }\n    \n    public synchronized void setNonstaticField(int y){\n        this.nonstaticField = y;\n    }\n}','Threads',0,0,NULL,5),(1889,'run:\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n','public class Hello {\n    \n   public static void main (String [] args){\n       Thing thing = new Thing();\n       \n       new Thread(new Accessor(thing),\"Max\").start();\n       new Thread(new Accessor(thing),\"Bart\").start();\n       new Thread(new Accessor(thing),\"Thread C\").start();\n \n   }\n}\n\nclass Accessor implements Runnable{\n    private Thing thisthing;\n    \n    public Accessor(Thing x){\n        thisthing = x;\n    }\n    \n    public void run(){\n        synchronized(thisthing){\n            for(int i = 1; i <= 10; i++){\n              thisthing.setNonstaticField(i);\n             System.out.println(thisthing.getNonstaticField());\n         }\n        }\n    }\n}\n\nclass Thing {\n    private static int staticField;\n    private int nonstaticField;\n    \n    public static synchronized int getStaticField(){\n        return staticField;\n    }\n    \n    public static synchronized void setStaticField(int x){\n        //use class not this\n        Thing.staticField = x;\n    }\n    \n    public synchronized int getNonstaticField(){\n        return nonstaticField;\n    }\n    \n    public synchronized void setNonstaticField(int y){\n        this.nonstaticField = y;\n    }\n}','Threads',0,0,NULL,5),(1890,'SynchronizedRGB must be used carefully to avoid being seen in an inconsistent state. Suppose, for example, a thread executes the following code:\n\nSynchronizedRGB color =\n    new SynchronizedRGB(0, 0, 0, \"Pitch Black\");\n...\nint myColorInt = color.getRGB();      //Statement 1\nString myColorName = color.getName(); //Statement 2\n\nIf another thread invokes color.set after Statement 1 but before Statement 2, the value of myColorInt won\'t match the value of myColorName. To avoid this outcome, the two statements must be bound together:\n\nsynchronized (color) {\n    int myColorInt = color.getRGB();\n    String myColorName = color.getName();\n} \n\nThis kind of inconsistency is only possible for mutable objects — it will not be an issue for the immutable version of SynchronizedRGB.','class SynchronizedRGB {\n\n    // Values must be between 0 and 255.\n    private int red;\n    private int green;\n    private int blue;\n    private String name;\n\n    private void check(int red,\n                       int green,\n                       int blue) {\n        if (red < 0 || red > 255\n            || green < 0 || green > 255\n            || blue < 0 || blue > 255) {\n            throw new IllegalArgumentException();\n        }\n    }\n\n    public SynchronizedRGB(int red,\n                           int green,\n                           int blue,\n                           String name) {\n        check(red, green, blue);\n        this.red = red;\n        this.green = green;\n        this.blue = blue;\n        this.name = name;\n    }\n\n    public void set(int red,\n                    int green,\n                    int blue,\n                    String name) {\n        check(red, green, blue);\n        synchronized (this) {\n            this.red = red;\n            this.green = green;\n            this.blue = blue;\n            this.name = name;\n        }\n    }\n\n    public synchronized int getRGB() {\n        return ((red << 16) | (green << 8) | blue);\n    }\n\n    public synchronized String getName() {\n        return name;\n    }\n\n    public synchronized void invert() {\n        red = 255 - red;\n        green = 255 - green;\n        blue = 255 - blue;\n        name = \"Inverse of \" + name;\n    }\n}','Threads',0,0,NULL,5),(1891,'run:\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n30 \n29 \n28 \n27 \n26 \n25 \n24 \n23 \n22 \n21 \n20 \n19 \n18 \n17 \n16 \n15 \n14 \n13 \n12 \n11 \n30 \n29 \n28 \n27 \n26 \n25 \n24 \n23 \n22 \n21 \n20 \n19 \n18 \n17 \n16 \n15 \n14 \n13 \n12 \n11 \n30 \n29 \n28 \n27 \n26 \n25 \n24 \n23 \n22 \n21 \n20 \n19 \n18 \n17 \n16 \n15 \n14 \n13 \n12 \n11 \n\n','public class Hello {\n    \n   public static void main (String [] args){\n       Thing thing = new Thing();\n       \n       new Thread(new Accessor(thing),\"Max\").start();\n       new Thread(new Accessor(thing),\"Bart\").start();\n       new Thread(new Accessor(thing),\"Thread C\").start();\n       new Thread(new staticAccessor(),\"stat Max\").start();\n       new Thread(new staticAccessor(),\"stat bart\").start();\n       new Thread(new staticAccessor(),\"stat c\").start();\n \n   }\n}\n\nclass Accessor implements Runnable{\n    private Thing thisthing;\n    \n    public Accessor(Thing x){\n        thisthing = x;\n    }\n    \n    public void run(){\n        synchronized(thisthing){\n            for(int i = 1; i <= 10; i++){\n              thisthing.setNonstaticField(i);\n             System.out.println(thisthing.getNonstaticField());\n         }\n        }\n    }\n}\n\nclass staticAccessor implements Runnable {\n    \n    public void run(){\n        synchronized(Thing.class){\n            for(int i = 30; i > 10; i--){\n                Thing.setStaticField(i);\n                System.out.println(Thing.getStaticField()+\" \");\n            }\n        }\n    }\n    \n}','Threads',0,0,NULL,5),(1892,'this class may deadlock','class DeadlockRisk {\n    private static class Resource {\n        public int value;\n    }\n    \n    private Resource resA = new Resource();\n    private Resource resB = new Resource();\n    \n    public int read() {\n        synchronized(resA) { // may deadlock\n            synchronized(resB) {\n                return resB.value + resA.value;\n            }\n        }\n    }\n    \n    public void write(int a, int b){\n        synchronized(resB){//may deadlock\n            synchronized(resA){\n                resA.value = a;\n                resB.value = b;\n            }\n        }\n    }\n}','Threads',0,0,NULL,5),(1893,'','wait() notify() and notifyAll() must be called from within a synhcronized\ncontext! A thread can\'t invoke a wait or notify method on an object unless it owns \nthat object\'s lock','Threads',0,0,NULL,5),(1894,'run:\nwaiting for b to complete...\nTotal is 4950\n\n','public class Hello {\n    \n   public static void main (String [] args){\n       \n       ThreadB b = new ThreadB();\n       b.start();\n       \n       synchronized(b) {\n           try {\n               System.out.println(\"waiting for b to complete...\");\n               b.wait();\n           } catch(InterruptedException e) { }\n           \n           System.out.println(\"Total is \" + b.total);\n       }\n \n   }\n  \n}\n\nclass ThreadB extends Thread {\n       int total;\n       \n       public void run() {\n           synchronized(this) {\n               for(int i = 0; i<100; i++){\n                   total += i;\n               }\n               \n               notify();\n           }\n       }\n   }','Threads',0,0,NULL,5),(1895,'will not compile non static variable this cannot be referenced from\na static context. ','public class Hello {\n    \n   public static void main (String [] args){\n       \n       ThreadB b = new ThreadB();\n       b.start();\n       \n       synchronized(this) {\n           try {\n               System.out.println(\"waiting for b to complete...\");\n               b.wait();\n           } catch(InterruptedException e) { }\n           \n           System.out.println(\"Total is \" + b.total);\n       }\n \n   }\n  \n}','Threads',0,0,NULL,5),(1896,'','use notifyAll() to signal all waiting threads,\nnotify() will only signal one unspecified thread.','Threads',0,0,NULL,5),(1897,'this programm will wait indefinately, \nbecause the calculator was never started so the threads will continuously\nwait for it. ','public class Hello {\n    \n   public static void main (String [] args){\n      \n        Calculator cal = new Calculator();\n        new Reader(cal).start();\n        new Reader(cal).start();\n        new Reader(cal).start();\n\n   }\n  \n}\n\nclass Reader extends Thread {\n    Calculator c;\n    \n    public Reader(Calculator calc) {\n        c = calc;\n    }\n    \n    public void run(){\n        synchronized(c) {\n            try {\n                System.out.println(\"Waiting for calc\");\n                    c.wait();\n            } catch(InterruptedException e){ }\n                \n            System.out.println(\"Total is: \"+ c.total);\n            \n        }\n    }\n}\n\nclass Calculator implements Runnable {\n    int total;\n    \n    public void run() {\n        synchronized(this) {\n            for(int i = 0; i < 100; i++){\n                total += i;\n            }\n            notifyAll();\n        }\n    }\n}','Threads',0,0,NULL,5),(1898,'will not compile, run() in Calculator cannot override run() in Runnable\noverriding method is static','public class Hello {\n    \n   public static void main (String [] args){\n      \n        Calculator cal = new Calculator();\n        new Reader(cal).start();\n        new Reader(cal).start();\n        new Reader(cal).start();\n        new Thread(cal).start();\n\n   }\n  \n}\n\nclass Reader extends Thread {\n    Calculator c;\n    \n    public Reader(Calculator calc) {\n        c = calc;\n    }\n    \n    public void run(){\n        synchronized(c) {\n            try {\n                System.out.println(\"Waiting for calc\");\n                    c.wait();\n            } catch(InterruptedException e){ }\n                \n            System.out.println(\"Total is: \"+ c.total);\n            \n        }\n    }\n}\n\nclass Calculator implements Runnable {\n    int total;\n    \n    public static void run() {\n        synchronized(this) {\n            for(int i = 0; i < 100; i++){\n                total += i;\n            }\n            notifyAll();\n        }\n    }\n}','Threads',0,0,NULL,5),(1899,'Will not compile Collections.asList() does not exist \n\nyour thinking of Arrays.asList();','public String getSection(){\n	String[] sections = {\"ABD\",\"AfG\",\"HTL\",\"AtL\",\"MAX\",\"AKH\",\"TYU\"};	\n     List<String> sectionList = Collections.asList(sections);\n     Collections.shuffle(sectionList);\n     String ret = sectionList.get(counter);\n	counter++;\n	return ret;\n}','Threads',0,0,NULL,5),(1900,'will not compile, \n\nList<String> coming from Arrays.asList cannot be converted to ArrayList.\n\nTherefore secionList should be a List<String>\n',' public String getSection(){\n            String[] sections = {\"ABD\",\"AfG\",\"HTL\",\"AtL\",\"MAX\",\"AKH\",\"TYU\"};\n            ArrayList sectionList = Arrays.asList(sections); \n            Collections.shuffle(sectionList);\n            String ret = sectionList.get(counter);\n            counter++;\n            return ret;\n        }','Threads',0,0,NULL,5),(1901,'It will print an undeterminable series of codes though they will be in order,\n\nthe getSection() method has a block that is synchronized on the CodeMake.class\nobject but that only protects static methods.\n\nso when one thread is synched on CodeMaker.class no other thread can execute \nthat same block of code, here it is no applicable because all the threads \nhave the same block of code. That counter is the same for all threads,\nwhile the sections array is copied across all instances. The array is \nnot mutated in any way though. ','class CodeMaker{\n    private String code = \": \";\n    private static int counter = 0;\n    private String[] sections = {\"ABD\",\"AfG\",\"HTL\",\"AtL\",\"MAX\",\"AKH\",\"TYU\"};\n    \n    \n    class SectionGenerator implements Runnable{\n        //private static int counter = 0; cannot have static members in inner class\n           \n        public String getSection(){\n            \n            synchronized(CodeMaker.class){\n                //sections.size()\n                if(counter < sections.length){\n                    String sec = sections[counter];\n                    counter++;\n                    return sec;\n                }\n            }\n            return null;\n        }\n        \n        public void run() {\n            code += getSection() + \" : \";\n        }\n\n    }\n    \n    public void coder(){\n        for(int i = 0; i < 7; i++){\n            new Thread(new SectionGenerator()).start();\n        }\n        System.out.println(\"code: \"+code);\n    }\n    \n    \n}','Threads',0,0,NULL,5),(1902,'will not compile illegal modifier static in inner class, \n\nto fix you would have to make counter final but that would defeat the\npurpose of having a counter!','class CodeMaker{\n    private String code = \": \";\n    private String[] sections = {\"ABD\",\"AfG\",\"HTL\",\"AtL\",\"MAX\",\"AKH\",\"TYU\"};\n    \n    \n    class SectionGenerator implements Runnable{\n        private static int counter = 0;\n           \n        public String getSection(){\n            \n            synchronized(CodeMaker.class){\n                //sections.size()\n                if(counter < sections.length){\n                    String sec = sections[counter];\n                    counter++;\n                    return sec;\n                }\n            }\n            return null;\n        }\n        \n        public void run() {\n            code += getSection() + \" : \";\n        }\n\n    }\n    \n    public void coder(){\n        for(int i = 0; i <= 7; i++){\n            new Thread(new SectionGenerator()).start();\n        }\n        System.out.println(\"code: \"+code);\n    }\n    \n    \n}','Threads',0,0,NULL,5),(1903,'will not compile, an array does not have a size() method \nit has a length attribute','class CodeMaker{\n    private String code = \": \";\n    private static int counter = 0;\n    private String[] sections = {\"ABD\",\"AfG\",\"HTL\",\"AtL\",\"MAX\",\"AKH\",\"TYU\"};\n    \n    \n    class SectionGenerator implements Runnable{\n           \n        public String getSection(){\n            \n            synchronized(CodeMaker.class){\n                if(counter < sections.size()){\n                    String sec = sections[counter];\n                    counter++;\n                    return sec;\n                }\n            }\n            return null;\n        }\n        \n        public void run() {\n            code += getSection() + \" : \";\n        }\n\n    }\n    \n    public void coder(){\n        for(int i = 0; i <= 7; i++){\n            new Thread(new SectionGenerator()).start();\n        }\n        System.out.println(\"code: \"+code);\n    }\n    \n    \n}','Threads',0,0,NULL,5),(1904,'code: : AfG : HTL : AtL : MAX : \ncode: : ABD : AfG : HTL : AtL : MAX : AKH : TYU : \ncode: : ABD : AfG : HTL : AtL : MAX : AKH : TYU :\ncode: : ABD : HTL : AtL : MAX : AKH : TYU : \ncode: : ABD : AfG : HTL : AtL : MAX : AKH : TYU : \n\n...results from a few different runs. Without synchronization you cannot\nbe sure what will print because one thread could come in bewteen execution\nof getSection() and disrupt the results. This however will not change the\norder in which the code are retrieved because no matter \nhow choatic the threads execute there is no code that will\ncause static int counter to decrease or increase more than one. \n','class CodeMaker{\n    private String code = \": \";\n    private static int counter = 0;\n    private String[] sections = {\"ABD\",\"AfG\",\"HTL\",\"AtL\",\"MAX\",\"AKH\",\"TYU\"};\n    \n    \n    class SectionGenerator implements Runnable{\n           \n        public String getSection(){\n            \n                if(counter < sections.length){\n                    String sec = sections[counter];\n                    counter++;\n                    return sec;\n                }\n            \n            return null;\n        }\n        \n        public void run() {\n            code += getSection() + \" : \";\n        }\n\n    }\n    \n    public void coder(){\n        for(int i = 0; i <= 7; i++){\n            new Thread(new SectionGenerator()).start();\n        }\n        System.out.println(\"code: \"+code);\n    }\n    \n    \n}','Threads',0,0,NULL,5),(1905,'This code will not print accurate results as in it will not reliably\nprint all the sections. \n\nThis is becaue the reading of a code and tacking it into the complete \ncode is not an atomic operation. \n\nto uniformly print all the codes you would do this:\n\n	class SectionGenerator implements Runnable{\n\n        public void run() {\n            synchronized(CodeMaker.class){\n            \n                if(counter < sections.length){\n                    String sec = sections[counter];\n                    counter++;\n                    code += sec + \" : \";\n                }\n\n                \n            }\n        }\n\n    }','class CodeMaker{\n    private String code = \": \";\n    private int counter = 0;\n    private static String[] sections = {\"ABD\",\"AfG\",\"HTL\",\"AtL\",\"MAX\",\"AKH\",\"TYU\"};\n    \n    \n    class SectionGenerator implements Runnable{\n           \n        public String getSection(){\n            \n            synchronized(CodeMaker.class){\n            \n                if(counter < sections.length){\n                    String sec = sections[counter];\n                    counter++;\n                    return sec;\n                }\n                \n                return null;\n                \n            }\n            \n            \n        }\n        \n        public void run() {\n            code += getSection() + \" : \";\n        }\n\n    }\n    \n    public void coder(){\n        for(int i = 0; i <= 7; i++){\n            new Thread(new SectionGenerator()).start();\n        }\n        System.out.println(\"code: \"+code);\n    }\n    \n    \n}\n\npublic class Hello {\n    \n   public static void main (String [] args){\n      new CodeMaker().coder();\n\n   }\n  \n}','Threads',0,0,NULL,5),(1906,'will print:\n\ncode: : ABD : AfG : HTL : AtL : MAX : AKH : TYU :\n\nevery time. \n\nin previous questions counter was not static, if that were the case here\nresults would not be predictable. ','class CodeMaker{\n    private String code = \": \";\n    private int counter = 0;\n    private static String[] sections = {\"ABD\",\"AfG\",\"HTL\",\"AtL\",\"MAX\",\"AKH\",\"TYU\"};\n    \n    \n    class SectionGenerator implements Runnable{\n\n        public void run() {\n            synchronized(CodeMaker.class){\n            \n                if(counter < sections.length){\n                    String sec = sections[counter];\n                    counter++;\n                    code += sec + \" : \";\n                }\n\n                \n            }\n        }\n\n    }\n    \n    public void coder(){\n        for(int i = 0; i <= 7; i++){\n            new Thread(new SectionGenerator()).start();\n        }\n        System.out.println(\"code: \"+code);\n    }\n    \n    \n}\n\npublic class Hello {\n    \n   public static void main (String [] args){\n      new CodeMaker().coder();\n\n   }\n  \n}','Threads',0,0,NULL,5),(1907,'will produce unpredictable results because counter is not static, so\nits access is not locked by synchronization onto CodeMaker.class\n','public class Hello {\n    \n   public static void main (String [] args){\n      new CodeMaker().coder();\n\n   }\n  \n}\n\nclass CodeMaker{\n    private String code = \": \";\n    private int counter = 0;\n    private static String[] sections = {\"ABD\",\"AfG\",\"HTL\",\"AtL\",\"MAX\",\"AKH\",\"TYU\"};\n    \n    \n    class SectionGenerator implements Runnable{\n\n        public void run() {\n            synchronized(CodeMaker.class){\n            \n                if(counter < sections.length){\n                    String sec = sections[counter];\n                    counter++;\n                    code += sec + \" : \";\n                }\n                \n            }\n        }\n\n    }\n    \n    public void coder(){\n        for(int i = 0; i <= 7; i++){\n            new Thread(new SectionGenerator()).start();\n        }\n        System.out.println(\"code: \"+code);\n    }\n    \n    \n}','Threads',0,0,NULL,5),(1908,'without synchronization here the results will be wildly unpredictable.','class statPrinter {\n    private int counter = 0;\n    \n    class Adder implements Runnable {\n        \n        public void run(){\n                //Thread.sleep(1000); with no try\n                counter++;\n                System.out.println(counter + \", Adder +1 \");  \n        }\n    }\n    \n    class Minuser implements Runnable {\n        public void run() {\n                counter--;\n                System.out.println(counter+\", Minuser -1 \");    \n        }\n    }\n    \n    public void test(){\n        for(int i = 0; i < 100; i++){\n            new Thread(new Adder()).start();\n            new Thread(new Minuser()).start();\n            \n        }\n    }\n}','Threads',0,0,NULL,5),(1909,'will not compile, unreported interrupt exception coming from \nThread.sleep();\n\nmust wrap in try catch or declare it to be thrown','class statPrinter {\n    private int counter = 0;\n    \n    class Adder implements Runnable {\n        \n        public void run(){\n                Thread.sleep(1000); \n                counter++;\n                System.out.println(counter + \", Adder +1 \");  \n        }\n    }\n    \n    class Minuser implements Runnable {\n        public void run() {\n                Thread.sleep(500);\n                counter--;\n                System.out.println(counter+\", Minuser -1 \");    \n        }\n    }\n    \n    public void test(){\n        for(int i = 0; i < 100; i++){\n            new Thread(new Adder()).start();\n            new Thread(new Minuser()).start();\n            \n        }\n    }\n}','Threads',0,0,NULL,5),(1910,'These results are unpredicatable, \n\nyes run() can be synched, these two methods synchronize on the current\nobject, all that means is that theyre code \n\n	counter++;\n     System.out.println(counter+\", Minuser -1 \"); \n\n	counter--;\n      System.out.println(counter+\", Minuser -1 \"); 	\n\nwill run in order completely without being interrupted by another thread.\n\nhowever that does not stop another thread from jumping the gun and being\nrun twice though!\n\n','class statPrinter {\n    private int counter = 0;\n    \n    class Adder implements Runnable {\n        \n        public synchronized void run(){\n                counter++;\n                System.out.println(counter + \", Adder +1 \");  \n        }\n    }\n    \n    class Minuser implements Runnable {\n        public synchronized void run() {\n                counter--;\n                System.out.println(counter+\", Minuser -1 \");    \n        }\n    }\n    \n    public void test(){\n        for(int i = 0; i < 100; i++){\n            new Thread(new Adder()).start();\n            new Thread(new Minuser()).start();\n            \n        }\n    }\n}','Threads',0,0,NULL,5),(1911,'this will give unpredictable results, \n\npublic void run() {\n            synchronized(this){\n                counter--;\n                System.out.println(counter+\", Minuser -1 \");   \n            }\n        }\n\nis the same as\n\npublic synchronized void run(){\n	...\n}\n\n\nthey both lock onto the current obejct, meaning no other thread can\naccess that object. The variable of concern here though is counter which\nis a variable of the statPrinter object. ','class statPrinter {\n    private int counter = 0;\n    \n    class Adder implements Runnable {\n        \n        public void run(){\n            synchronized(this){\n                counter++;\n                System.out.println(counter + \", Adder +1 \");  \n            }\n        }\n    }\n    \n    class Minuser implements Runnable {\n        public void run() {\n            synchronized(this){\n                counter--;\n                System.out.println(counter+\", Minuser -1 \");   \n            }\n        }\n    }\n    \n    public void test(){\n        for(int i = 0; i < 100; i++){\n            new Thread(new Adder()).start();\n            new Thread(new Minuser()).start();\n            \n        }\n    }\n}','Threads',0,0,NULL,5),(1912,'Will not compile you cannot intitialize an array with shorthand like that.\nBecause, at the time of creation java wants to know excactly how \nmuch memory to allocate when you jsut create the reference you basically\ncreate nothing.\n\nin the constructor you whene you initialize you have to excplicitly\ncreate the memory with the new array using new. \n\nto compile do this:\n	\n	sections = new String[]{\"ABD\",\"AfG\",\"HTL\",\"AtL\",\"MAX\",\"AKH\",\"TYU\"};','class CodeMaker{\n    private String code;\n    private int counter;\n    private static String[] sections;\n    private ArrayList<String> al;\n    \n    public CodeMaker(){\n        code = \": \";\n        counter = 0;\n        sections = {\"ABD\",\"AfG\",\"HTL\",\"AtL\",\"MAX\",\"AKH\",\"TYU\"};\n        al = new ArrayList<>();\n    }\n    \n    \n    class SectionGenerator implements Runnable{\n\n        public void run() {\n            synchronized(CodeMaker.class){\n            \n                if(counter < sections.length){\n                    String sec = sections[counter];\n                    counter++;\n                    code += sec + \" : \";\n                }\n                \n            }\n        }\n\n    }\n    \n    public void coder(){\n        for(int i = 0; i <= 10; i++){\n            new Thread(new SectionGenerator()).start();\n        }\n        System.out.println(\"code: \"+code);\n    }\n    \n    \n}','Threads',0,0,NULL,5),(1913,'will not compile, Constructors cannot be synchronized. ','class CodeMaker{\n    private String code;\n    private int counter;\n    private static String[] sections;\n    private ArrayList<String> al;\n    \n    public synchronized CodeMaker(){\n        code = \": \";\n        counter = 0;\n        sections = new String[]{\"ABD\",\"AfG\",\"HTL\",\"AtL\",\"MAX\",\"AKH\",\"TYU\"};\n        al = new ArrayList<>();\n    }\n    \n    \n    class SectionGenerator implements Runnable{\n\n        public void run() {\n            synchronized(CodeMaker.class){\n            \n                if(counter < sections.length){\n                    String sec = sections[counter];\n                    counter++;\n                    code += sec + \" : \";\n                }\n                \n            }\n        }\n\n    }\n    \n    public void coder(){\n        for(int i = 0; i <= 10; i++){\n            new Thread(new SectionGenerator()).start();\n        }\n        System.out.println(\"code: \"+code);\n    }\n    \n    \n}','Threads',0,0,NULL,5),(1914,'will not compile becaue of wait(),\n\nureported exception, interruptedexception, must be caught or thrown\n\n','class CodeMaker  extends Thread {\n    private String code;\n    private int counter;\n    private ArrayList<String> al;\n    private char[] letters = {\'A\',\'B\',\'C\',\'D\',\'E\',\'F\',\'G\',\'H\',\'I\'};\n    \n    public CodeMaker(){\n        counter = 0;\n        al = new ArrayList<>();\n    }\n\n    class SectionGenerator implements Runnable{\n        private String sec = \"\";\n        private Random ran;\n\n        public void run() {\n            //tried to use notify outside of synchronized context\n            synchronized(this){\n                int x = ran.nextInt(3);\n                int y = ran.nextInt(3);\n                int z = ran.nextInt(3);\n            \n            \n                sec += letters[x];\n                sec += letters[y];\n                sec += letters[z];\n                notifyAll();\n            }\n        }\n        \n        public synchronized String section(){\n            return sec;\n        }\n\n    }\n    \n    class NumberGenerator implements Runnable{\n        private String number = \"\";\n        private Random ran;\n        \n        public void run(){\n            //tried to use notify outside of synchronized context\n            synchronized(this){\n                int x1 = ran.nextInt(100);\n                int x2 = ran.nextInt(100);\n                int x3 = ran.nextInt(100);\n            \n                number+= x1+\".\"+x2+\".\"+x3;\n                notifyAll();\n            }\n        }\n        \n        public synchronized String Number(){\n            return number;\n        }\n    }\n    \n   public void run(){\n       \n       SectionGenerator sg1 = new SectionGenerator();\n       NumberGenerator ng1 = new NumberGenerator();\n       Thread t1 = new Thread(sg1);\n       Thread t2 = new Thread(ng1);\n       \n       t1.start();\n       t2.start();\n       \n       t1.wait();\n       code += sg1.section();\n       t2.wait();\n       code += ng1.Number();\n       \n       System.out.println(code);\n\n       \n   }\n    \n    \n}\n','Threads',0,0,NULL,5),(1915,'will not compile, not a proper override of run(),\n\noverrides cannot throw new or broader checked exceptions','class CodeMaker  extends Thread {\n    private String code;\n    private int counter;\n    private ArrayList<String> al;\n    private char[] letters = {\'A\',\'B\',\'C\',\'D\',\'E\',\'F\',\'G\',\'H\',\'I\'};\n    \n    public CodeMaker(){\n        counter = 0;\n        al = new ArrayList<>();\n    }\n\n    class SectionGenerator implements Runnable{\n        private String sec = \"\";\n        private Random ran;\n\n        public void run() {\n            //tried to use notify outside of synchronized context\n            synchronized(this){\n                int x = ran.nextInt(3);\n                int y = ran.nextInt(3);\n                int z = ran.nextInt(3);\n            \n            \n                sec += letters[x];\n                sec += letters[y];\n                sec += letters[z];\n                notifyAll();\n            }\n        }\n        \n        public synchronized String section(){\n            return sec;\n        }\n\n    }\n    \n    class NumberGenerator implements Runnable{\n        private String number = \"\";\n        private Random ran;\n        \n        public void run(){\n            //tried to use notify outside of synchronized context\n            synchronized(this){\n                int x1 = ran.nextInt(100);\n                int x2 = ran.nextInt(100);\n                int x3 = ran.nextInt(100);\n            \n                number+= x1+\".\"+x2+\".\"+x3;\n                notifyAll();\n            }\n        }\n        \n        public synchronized String Number(){\n            return number;\n        }\n    }\n    \n   public void run() throws InterruptedException {\n       \n       SectionGenerator sg1 = new SectionGenerator();\n       NumberGenerator ng1 = new NumberGenerator();\n       Thread t1 = new Thread(sg1);\n       Thread t2 = new Thread(ng1);\n       \n       t1.start();\n       t2.start();\n       \n       t1.wait();\n       code += sg1.section();\n       t2.wait();\n       code += ng1.Number();\n       \n       System.out.println(code);\n\n       \n   }\n    \n    \n}','Threads',0,0,NULL,5),(1916,'NPE, ran is nevere intitialized. ','public class Hello extends Thread {\n    public static void main(String[] args){\n        new CodeMaker().start();\n    }\n}\n\nclass CodeMaker  extends Thread {\n    private String code;\n    private int counter;\n    private ArrayList<String> al;\n    private char[] letters = {\'A\',\'B\',\'C\',\'D\',\'E\',\'F\',\'G\',\'H\',\'I\'};\n    \n    public CodeMaker(){\n        counter = 0;\n        al = new ArrayList<>();\n    }\n\n    class SectionGenerator implements Runnable{\n        private String sec = \"\";\n        private Random ran;\n\n        public void run() {\n            //tried to use notify outside of synchronized context\n            synchronized(this){\n                int x = ran.nextInt(3);\n                int y = ran.nextInt(3);\n                int z = ran.nextInt(3);\n            \n            \n                sec += letters[x];\n                sec += letters[y];\n                sec += letters[z];\n                notifyAll();\n            }\n        }\n        \n        public synchronized String section(){\n            return sec;\n        }\n\n    }\n    \n    class NumberGenerator implements Runnable{\n        private String number = \"\";\n        private Random ran;\n        \n        public void run(){\n            //tried to use notify outside of synchronized context\n            synchronized(this){\n                int x1 = ran.nextInt(100);\n                int x2 = ran.nextInt(100);\n                int x3 = ran.nextInt(100);\n            \n                number += x1+\".\"+x2+\".\"+x3;\n                notifyAll();\n            }\n        }\n        \n        public synchronized String Number(){\n            return number;\n        }\n    }\n    \n   public synchronized void run(){\n       \n       SectionGenerator sg1 = new SectionGenerator();\n       NumberGenerator ng1 = new NumberGenerator();\n       Thread t1 = new Thread(sg1);\n       Thread t2 = new Thread(ng1);\n       \n       t1.start();\n       t2.start();\n       \n       try{\n        t1.wait();\n        code += sg1.section();\n        t2.wait();\n        code += ng1.Number();\n       } catch(InterruptedException e){\n           \n       }\n       System.out.println(code);\n\n       \n   }\n    \n    \n}','Threads',0,0,NULL,5),(1917,'IllegalMonitorStateException, ','public class Hello extends Thread {\n    public static void main(String[] args){\n        new CodeMaker().start();\n    }\n}\n\nclass CodeMaker  extends Thread {\n    private String code;\n    private int counter;\n    private ArrayList<String> al;\n    private char[] letters = {\'A\',\'B\',\'C\',\'D\',\'E\',\'F\',\'G\',\'H\',\'I\'};\n    \n    public CodeMaker(){\n        counter = 0;\n        al = new ArrayList<>();\n    }\n\n    class SectionGenerator implements Runnable{\n        private String sec = \"\";\n        private Random ran = new Random();\n\n        public void run() {\n            //tried to use notify outside of synchronized context\n            synchronized(this){\n                int x = ran.nextInt(3);\n                int y = ran.nextInt(3);\n                int z = ran.nextInt(3);\n            \n            \n                sec += letters[x];\n                sec += letters[y];\n                sec += letters[z];\n                notifyAll();\n            }\n        }\n        \n        public synchronized String section(){\n            return sec;\n        }\n\n    }\n    \n    class NumberGenerator implements Runnable{\n        private String number = \"\";\n        private Random ran = new Random();\n        \n        public void run(){\n            //tried to use notify outside of synchronized context\n            synchronized(this){\n                int x1 = ran.nextInt(100);\n                int x2 = ran.nextInt(100);\n                int x3 = ran.nextInt(100);\n            \n                number += x1+\".\"+x2+\".\"+x3;\n                notifyAll();\n            }\n        }\n        \n        public synchronized String Number(){\n            return number;\n        }\n    }\n    \n   public synchronized void run(){\n       \n       SectionGenerator sg1 = new SectionGenerator();\n       NumberGenerator ng1 = new NumberGenerator();\n       Thread t1 = new Thread(sg1);\n       Thread t2 = new Thread(ng1);\n       \n       t1.start();\n       t2.start();\n       \n       try{\n        t1.wait();\n        code += sg1.section();\n        t2.wait();\n        code += ng1.Number();\n       } catch(InterruptedException e){\n           \n       }\n       System.out.println(code);\n\n       \n   }\n    \n    \n}','Threads',0,0,NULL,5),(1918,'will not compile, static classes are not allowed in inner classes,\n\nonly static final varialbe definitions is allowed.','public class Hello extends Thread {\n    public static void main(String[] args){\n        \n    }\n    \n    class Operator extends Thread {\n        Machine machine = new Machine();\n        Machine.MachineInstructions job;\n        \n        public void run(){\n            while(true){\n                String shape = getShapeFromUser();\n                job = calculateNewInstructionsFor(shape);\n                \n                machine.addJob(job);\n            }\n        }\n        \n        public Machine.MachineInstructions calculateNewInstructionsFor(String x){\n            // dah duh duu da du\n            return machine.new MachineInstructions();\n        }\n        \n        public String getShapeFromUser(){\n            System.out.println(\"What shape? square ok thanks\");\n            return \"Square\";\n        }\n        \n    }\n    \n    class Machine extends Thread {\n        List<MachineInstructions> joblist = new ArrayList<>(0);\n        \n        public void addJob(MachineInstructions job){\n            synchronized(joblist){\n                joblist.add(job);\n                joblist.notify();\n            }\n        }\n        \n        public void run(){\n            while(true) {\n                synchronized(joblist) {\n                    //wait until at least one job is available\n                    while(joblist.isEmpty()) {\n                        try{\n                            joblist.wait();\n                        } catch(InterruptedException ei){\n                            \n                        }\n                        \n                        //if we get here you know the list is\'nt empty\n                        MachineInstructions inst = joblist.remove(0);\n                        \n                    }\n                }\n            }\n        }\n        \n        \n        static class MachineInstructions {\n            \n        }\n    }\n}','Threads',0,0,NULL,5),(1919,'will not compile, non static inner classes cannot be accessed from static\nmain','public class Hello extends Thread {\n    public static void main(String[] args){\n        new Operator().start();\n        new Machine().start();\n    }\n    \n    class Operator extends Thread {\n        Machine machine = new Machine();\n        Machine.MachineInstructions job;\n        \n        public void run(){\n            while(true){\n                String shape = getShapeFromUser();\n                job = calculateNewInstructionsFor(shape);\n                \n                machine.addJob(job);\n            }\n        }\n        \n        public Machine.MachineInstructions calculateNewInstructionsFor(String x){\n            // dah duh duu da du\n            return machine.new MachineInstructions(x);\n        }\n        \n        public String getShapeFromUser(){\n            System.out.println(\"What shape? square ok thanks\");\n            return \"Square\";\n        }\n        \n    }\n    \n    class Machine extends Thread {\n        List<MachineInstructions> joblist = new ArrayList<>();\n        \n        public void addJob(MachineInstructions job){\n            synchronized(joblist){\n                joblist.add(job);\n                joblist.notify();\n            }\n        }\n        \n        public void run(){\n            while(true) {\n                synchronized(joblist) {\n                    //wait until at least one job is available\n                    while(joblist.isEmpty()) {\n                        try{\n                            joblist.wait();\n                        } catch(InterruptedException ei){\n                            \n                        }\n                        \n                        //if we get here you know the list is\'nt empty\n                        MachineInstructions inst = joblist.remove(0);\n                        \n                        \n                    }\n                }\n            }\n        }\n        \n        \n        class MachineInstructions {\n            private String shape;\n            \n            public MachinInstructions(String shape){\n                this.shape = shape;\n            }\n            public void produceShape(){\n                System.out.println(\"Here\'s your :\"+shape);\n            }\n            \n        }\n    }\n}','Threads',0,0,NULL,5),(1920,'will not compile non static instance variable cannot be referenced \nfrom static main','public class Hello extends Thread {\n    Operator op = new Operator();\n    Machine m = new Machine();\n    public static void main(String[] args){\n        op.start();\n        m.start();\n    }\n    \n    class Operator extends Thread {\n        Machine machine = new Machine();\n        Machine.MachineInstructions job;\n        \n        public void run(){\n            while(true){\n                String shape = getShapeFromUser();\n                job = calculateNewInstructionsFor(shape);\n                \n                machine.addJob(job);\n            }\n        }\n        \n        public Machine.MachineInstructions calculateNewInstructionsFor(String x){\n            // dah duh duu da du\n            return machine.new MachineInstructions(x);\n        }\n        \n        public String getShapeFromUser(){\n            System.out.println(\"What shape? square ok thanks\");\n            return \"Square\";\n        }\n        \n    }\n    \n    class Machine extends Thread {\n        List<MachineInstructions> joblist = new ArrayList<>();\n        \n        public void addJob(MachineInstructions job){\n            synchronized(joblist){\n                joblist.add(job);\n                joblist.notify();\n            }\n        }\n        \n        public void run(){\n            while(true) {\n                synchronized(joblist) {\n                    //wait until at least one job is available\n                    while(joblist.isEmpty()) {\n                        try{\n                            joblist.wait();\n                        } catch(InterruptedException ei){\n                            \n                        }\n                        \n                        //if we get here you know the list is\'nt empty\n                        MachineInstructions inst = joblist.remove(0);\n                        \n                        \n                    }\n                }\n            }\n        }\n        \n        \n        class MachineInstructions {\n            private String shape;\n            \n            public MachinInstructions(String shape){\n                this.shape = shape;\n            }\n            public void produceShape(){\n                System.out.println(\"Here\'s your :\"+shape);\n            }\n            \n        }\n    }\n}','Threads',0,0,NULL,5),(1921,'will not compile non static variable this cannot be reference from a static\ncontext. \n\nthe inner classes are instance classes so, even though you define \nthe variables as static they have to use this to access the inner class\n\nso it will still not compile','public class Hello extends Thread {\n    private static Operator op = new Operator();\n    private static Machine m = new Machine();\n    public static void main(String[] args){\n        op.start();\n        m.start();\n    }\n    \n    class Operator extends Thread {\n        Machine machine = new Machine();\n        Machine.MachineInstructions job;\n        \n        public void run(){\n            while(true){\n                String shape = getShapeFromUser();\n                job = calculateNewInstructionsFor(shape);\n                \n                machine.addJob(job);\n            }\n        }\n        \n        public Machine.MachineInstructions calculateNewInstructionsFor(String x){\n            // dah duh duu da du\n            return machine.new MachineInstructions(x);\n        }\n        \n        public String getShapeFromUser(){\n            System.out.println(\"What shape? square ok thanks\");\n            return \"Square\";\n        }\n        \n    }\n    \n    class Machine extends Thread {\n        List<MachineInstructions> joblist = new ArrayList<>();\n        \n        public void addJob(MachineInstructions job){\n            synchronized(joblist){\n                joblist.add(job);\n                joblist.notify();\n            }\n        }\n        \n        public void run(){\n            while(true) {\n                synchronized(joblist) {\n                    //wait until at least one job is available\n                    while(joblist.isEmpty()) {\n                        try{\n                            joblist.wait();\n                        } catch(InterruptedException ei){\n                            \n                        }\n                        \n                        //if we get here you know the list is\'nt empty\n                        MachineInstructions inst = joblist.remove(0);\n                        \n                        \n                    }\n                }\n            }\n        }\n        \n        \n        class MachineInstructions {\n            private String shape;\n            \n            public MachinInstructions(String shape){\n                this.shape = shape;\n            }\n            public void produceShape(){\n                System.out.println(\"Here\'s your :\"+shape);\n            }\n            \n        }\n    }\n}','Threads',0,0,NULL,5),(1922,'will produce: \n	What shape? square ok thanks\n	What shape? square ok thanks\n	What shape? square ok thanks\n	What shape? square ok thanks\n...ad infinum\n\nThe conintinuos loops are meant to keep checking for new shapes. \n\nnotice that one of the threads is alwasy synched in with the jobslist\n\nthey then use wait and notify to bounce back and forth.','public class Hello extends Thread {\n \n    public static void main(String[] args){\n        Hello h = new Hello();\n        h.new Operator().start();\n        h.new Machine().start();\n    }\n    \n    class Operator extends Thread {\n        Machine machine = new Machine();\n        Machine.MachineInstructions job;\n        \n        public void run(){\n            while(true){\n                String shape = getShapeFromUser();\n                job = calculateNewInstructionsFor(shape);\n                \n                machine.addJob(job);\n            }\n        }\n        \n        public Machine.MachineInstructions calculateNewInstructionsFor(String x){\n            // dah duh duu da du\n            return machine.new MachineInstructions(x);\n        }\n        \n        public String getShapeFromUser(){\n            System.out.println(\"What shape? square ok thanks\");\n            return \"Square\";\n        }\n        \n    }\n    \n    class Machine extends Thread {\n        List<MachineInstructions> joblist = new ArrayList<>();\n        \n        public void addJob(MachineInstructions job){\n            synchronized(joblist){\n                joblist.add(job);\n                joblist.notify();\n            }\n        }\n        \n        public void run(){\n            while(true) {\n                synchronized(joblist) {\n                    //wait until at least one job is available\n                    while(joblist.isEmpty()) {\n                        try{\n                            joblist.wait();\n                        } catch(InterruptedException ei){\n                            \n                        }\n                        \n                        //if we get here you know the list is\'nt empty\n                        MachineInstructions inst = joblist.remove(0);\n                        \n                        \n                    }\n                }\n            }\n        }\n        \n        \n        class MachineInstructions {\n            private String shape;\n            \n            public MachineInstructions(String shape){\n                this.shape = shape;\n            }\n            public void produceShape(){\n                System.out.println(\"Here\'s your :\"+shape);\n            }\n            \n        }\n    }\n}','Threads',0,0,NULL,5),(1923,'IllegalMonitorStateException\n\nwait in thread machine is called from outside a synchronized context\n\nyou have to synchronized on an object to wait on it. ','public class Hello extends Thread {\n \n    public static void main(String[] args){\n        Hello h = new Hello();\n        h.new Operator().start();\n        h.new Machine().start();\n    }\n    \n    class Operator extends Thread {\n        Machine machine = new Machine();\n        Machine.MachineInstructions job;\n        \n        public void run(){\n            while(true){\n                String shape = getShapeFromUser();\n                job = calculateNewInstructionsFor(shape);\n                \n                machine.addJob(job);\n            }\n        }\n        \n        public Machine.MachineInstructions calculateNewInstructionsFor(String x){\n            // dah duh duu da du\n            return machine.new MachineInstructions(x);\n        }\n        \n        public String getShapeFromUser(){\n            System.out.println(\"What shape? square ok thanks\");\n            return \"Square\";\n        }\n        \n    }\n    \n    class Machine extends Thread {\n        List<MachineInstructions> joblist = new ArrayList<>();\n        \n        public void addJob(MachineInstructions job){\n            synchronized(joblist){\n                joblist.add(job);\n                joblist.notify();\n            }\n        }\n        \n        public void run(){\n            while(true) {\n                    //wait until at least one job is available\n                    while(joblist.isEmpty()) {\n                        try{\n                            joblist.wait();\n                        } catch(InterruptedException ei){\n                            \n                        }\n                        \n                        //if we get here you know the list is\'nt empty\n                        MachineInstructions inst = joblist.remove(0);\n                        \n                        \n                    }\n            }\n        }\n        \n        \n        class MachineInstructions {\n            private String shape;\n            \n            public MachineInstructions(String shape){\n                this.shape = shape;\n            }\n            public void produceShape(){\n                System.out.println(\"Here\'s your :\"+shape);\n            }\n            \n        }\n    }\n}','Threads',0,0,NULL,5),(1924,'IllegalMonitorStateException, \n\nnotify() in addJob is called without being synched with joblist.\n\nyou have to be synched on an object to wait on it or notify it.\n\nRemember you wait and notify objects not threads. ','public class Hello extends Thread {\n \n    public static void main(String[] args){\n        Hello h = new Hello();\n        h.new Operator().start();\n        h.new Machine().start();\n    }\n    \n    class Operator extends Thread {\n        Machine machine = new Machine();\n        Machine.MachineInstructions job;\n        \n        public void run(){\n            while(true){\n                String shape = getShapeFromUser();\n                job = calculateNewInstructionsFor(shape);\n                \n                machine.addJob(job);\n            }\n        }\n        \n        public Machine.MachineInstructions calculateNewInstructionsFor(String x){\n            // dah duh duu da du\n            return machine.new MachineInstructions(x);\n        }\n        \n        public String getShapeFromUser(){\n            System.out.println(\"What shape? square ok thanks\");\n            return \"Square\";\n        }\n        \n    }\n    \n    class Machine extends Thread {\n        List<MachineInstructions> joblist = new ArrayList<>();\n        \n        public void addJob(MachineInstructions job){\n                joblist.add(job);\n                joblist.notify();\n        }\n        \n        public void run(){\n            while(true) {\n                synchronized(joblist) {\n                    //wait until at least one job is available\n                    while(joblist.isEmpty()) {\n                        try{\n                            joblist.wait();\n                        } catch(InterruptedException ei){\n                            \n                        }\n                        \n                        //if we get here you know the list is\'nt empty\n                        MachineInstructions inst = joblist.remove(0);\n                        \n                        \n                    }\n                }\n            }\n        }\n        \n        \n        class MachineInstructions {\n            private String shape;\n            \n            public MachineInstructions(String shape){\n                this.shape = shape;\n            }\n            public void produceShape(){\n                System.out.println(\"Here\'s your :\"+shape);\n            }\n            \n        }\n    }\n}','Threads',0,0,NULL,5),(1925,'Here butterfingers is unable to get his meaty claws on the same machine \nthe operator is using becasue those two are instance classes created \nin static main, joblist is an instance variable so the one they are \nusing belongs to the instance created in main. \n\nButterFinger created his own seperated machine to fuck with here, good\nso the output will be \n\nWhat shape? square ok thanks\nWhat shape? square ok thanks\nWhat shape? square ok thanks\nWhat shape? square ok thanks     for ever and ever. ','//ignore the answer try to figure out what wrong with this thin\npublic class Hello extends Thread {\n \n    public static void main(String[] args){\n        Hello h = new Hello();\n        h.new Operator().start();\n        h.new Machine().start();\n        new ButterFinger().start();\n    }\n    \n    class Operator extends Thread {\n        Machine machine = new Machine();\n        Machine.MachineInstructions job;\n        \n        public void run(){\n            while(true){\n                String shape = getShapeFromUser();\n                job = calculateNewInstructionsFor(shape);\n                \n                machine.addJob(job);\n            }\n        }\n        \n        public Machine.MachineInstructions calculateNewInstructionsFor(String x){\n            // dah duh duu da du\n            return machine.new MachineInstructions(x);\n        }\n        \n        public String getShapeFromUser(){\n            System.out.println(\"What shape? square ok thanks\");\n            return \"Square\";\n        }\n        \n    }\n    \n    class Machine extends Thread {\n        private List<MachineInstructions> joblist = new ArrayList<>();\n        \n        public void addJob(MachineInstructions job){\n            synchronized(joblist){\n                joblist.add(job);\n                joblist.notifyAll();\n            }\n        }\n        \n        public void run(){\n            while(true) {\n                synchronized(joblist) {\n                    //wait until at least one job is available\n                    while(joblist.isEmpty()) {\n                        try{\n                            joblist.wait();\n                        } catch(InterruptedException ei){\n                            \n                        }\n                        \n                        //if we get here you know the list is\'nt empty\n                        MachineInstructions inst = joblist.remove(0);\n                        \n                        \n                    }\n                }\n            }\n        }\n        \n        \n        class MachineInstructions {\n            private String shape;\n            \n            public MachineInstructions(String shape){\n                this.shape = shape;\n            }\n            public void produceShape(){\n                System.out.println(\"Here\'s your :\"+shape);\n            }\n            \n        }\n    }\n     \n}\n\nclass ButterFinger extends Thread {\n    private Hello h = new Hello();\n    private Hello.Machine machine = h.new Machine();\n    \n        public void run(){\n            while(true){\n                machine.addJob(machine.new MachineInstructions(\"Whoops I fucked up\"));\n            }\n            \n        }\n}','Threads',0,0,NULL,5),(1926,'Butterfinger now has the right machine however the main method never\nstarts him so the output is still \n\nwhat shape? square ok thanks\nWhat shape? square ok thanks\nWhat shape? square ok thanks\nWhat shape? square ok thanks    forever...\n\nno,\n\n	Operator and Machine have no way to connect. Operator has its own\n	version of machine and therefore does not connect with the machine\n	thread that was started in main. ','public class Hello extends Thread {\n    Operator op = new Operator();\n    Machine m = new Machine();\n \n    public static void main(String[] args){\n       Hello h = new Hello();\n       h.op.start();\n       h.m.start();\n    }\n    \n    class Operator extends Thread {\n        Machine machine = new Machine();\n        Machine.MachineInstructions job;\n        \n        public void run(){\n            while(true){\n                String shape = getShapeFromUser();\n                job = calculateNewInstructionsFor(shape);\n                \n                machine.addJob(job);\n            }\n        }\n        \n        public Machine.MachineInstructions calculateNewInstructionsFor(String x){\n            // dah duh duu da du\n            return machine.new MachineInstructions(x);\n        }\n        \n        public String getShapeFromUser(){\n            System.out.println(\"What shape? square ok thanks\");\n            return \"Square\";\n        }\n        \n    }\n    \n    class Machine extends Thread {\n        private List<MachineInstructions> joblist = new ArrayList<>();\n        \n        public void addJob(MachineInstructions job){\n            synchronized(joblist){\n                joblist.add(job);\n                joblist.notifyAll();\n            }\n        }\n        \n        public void run(){\n            while(true) {\n                synchronized(joblist) {\n                    //wait until at least one job is available\n                    while(joblist.isEmpty()) {\n                        try{\n                            joblist.wait();\n                        } catch(InterruptedException ei){\n                            \n                        }\n                        \n                        //if we get here you know the list is\'nt empty\n                        MachineInstructions inst = joblist.remove(0);\n                        \n                        \n                    }\n                }\n            }\n        }\n        \n        \n        class MachineInstructions {\n            private String shape;\n            \n            public MachineInstructions(String shape){\n                this.shape = shape;\n            }\n            public void produceShape(){\n                System.out.println(\"Here\'s your :\"+shape);\n            }\n            \n        }\n    }\n     \n}\n\nclass ButterFinger extends Thread {\n    private Hello h = new Hello();\n    \n        public void run(){\n            while(true){\n                h.m.addJob(h.m.new MachineInstructions(\"Whoops I fucked up\"));\n            }\n            \n        }\n}','Threads',0,0,NULL,5),(1927,'IllegalMonitorStateException\n\nyou cannot call start() on a thread more than once. ','public class Hello {\n    public static void main(String[] args){\n        CodeMaker cm = new CodeMaker();\n        \n        for(int i = 0; i<10; i++){\n            cm.start();\n        }\n        \n    }\n}\n\nclass CodeMaker  extends Thread {\n    private String code;\n    private int counter;\n    private ArrayList<String> al;\n    private char[] letters = {\'A\',\'B\',\'C\',\'D\',\'E\',\'F\',\'G\',\'H\',\'I\'};\n    \n    public CodeMaker(){\n        counter = 0;\n        al = new ArrayList<>();\n    }\n\n    class SectionGenerator implements Runnable{\n        private String sec = \"\";\n        private Random ran = new Random();\n\n        public void run() {\n            //tried to use notify outside of synchronized context\n            synchronized(this){\n                int x = ran.nextInt(3);\n                int y = ran.nextInt(3);\n                int z = ran.nextInt(3);\n            \n            \n                sec += letters[x];\n                sec += letters[y];\n                sec += letters[z];\n                notifyAll();\n            }\n        }\n        \n        public synchronized String section(){\n            return sec;\n        }\n\n    }\n    \n    class NumberGenerator implements Runnable{\n        private String number = \"\";\n        private Random ran = new Random();\n        \n        public void run(){\n            //tried to use notify outside of synchronized context\n            synchronized(this){\n                int x1 = ran.nextInt(100);\n                int x2 = ran.nextInt(100);\n                int x3 = ran.nextInt(100);\n            \n                number += x1+\".\"+x2+\".\"+x3;\n                notifyAll();\n            }\n        }\n        \n        public synchronized String Number(){\n            return number;\n        }\n    }\n    \n    \n   public synchronized void run(){\n       \n       SectionGenerator sg1 = new SectionGenerator();\n       NumberGenerator ng1 = new NumberGenerator();\n       Thread t1 = new Thread(sg1);\n       Thread t2 = new Thread(ng1);\n       \n       t1.start();\n       t2.start();\n       \n       try{\n        t1.wait();\n        code += sg1.section();\n        t2.wait();\n        code += ng1.Number();\n       } catch(InterruptedException e){\n           \n       }\n       System.out.println(code);\n   }    ','Threads',0,0,NULL,5),(1928,'','You can call start() on a Thread object only once, otherwise you get an\nIllegalThreadStateException\n\nyou can however create many threads from the same runnable','Threads',0,0,NULL,5),(1929,'New State\n\nA thread that is created but not yet started is in the new state and not yet alive','public class Hello implements Runnable {\n\n    public static void main(String[] args) {\n        Thread t = new Thread(new Hello());\n    }\n    \n    public void run() {\n        System.out.println(\"run once\");\n    }\n}\n\n\nwhat state is this thread in ?\n\n','Threads',0,0,NULL,5),(1930,' got it ? ','Once a thread is started it goes into the runnable state,\n\nThe schedular can move a thread back and forth between the runnable state and \nthe running state. \n\nA running thread may enter a blocked / waiting state by a wait, sleep, or join \ncall\n\na running thread can enter the blocked/ waiting state because it cant acquire the lock \nfor a synchroized block\n\na dead thread cannot be started again.','Threads',0,0,NULL,5),(1931,'','sleeping is used to delay execution for a period of time and .. \n\nno locks are released when a thread goes to sleep','Threads',0,0,NULL,5),(1932,'','A sleeping thread is thread is guarenteed to sleep for at least the time specified\nin the argument to sleep() but there is not guarentee is actually return to running\n\nthe sleep mehtod is static so it only affects the currently running thread. ','Threads',0,0,NULL,5),(1933,'','unless explicitly set a thread\'s priority will have the same priority as the thread\nthat created it. ','Threads',0,0,NULL,5),(1934,'','when one thread call join() on another thread, the currently running thhread\nwill wait until the thread it joins with has completed. Think of join() as saying\n\n\"Hey thread I want to join on to the end of you. let me know when you\'re done, so \nI can enter the runnable state\"','Threads',0,0,NULL,5),(1935,'','While only one thread can be accessing synchronized code of a particular\ninstance, multiple threads can still access the same object\'s unsynchronized code.\n\nWhen a thread goes to sleep its locks will be unavailable to other threads.','Threads',0,0,NULL,5),(1936,'','Object.wait() = add me to your waiting list.','Threads',0,0,NULL,5),(1937,'','notify() is used to send a signal to onne and onnly one of the threads that \nare waiting, it cannot specify which thread will be notified.','Threads',0,0,NULL,5),(1938,'','wait() notify() and notifyAll() must called from within a synchronized context\nthe synchronization must be with the object that the thread is calling one of these\nmethhods on !','Threads',0,0,NULL,5),(1939,'the third one','Runnable target = new MyRunnable();\nThread myThread = new Thread(target);\n\n\npublic class MyRunnable extends Runnable{public void run(){}}\npublic class MyRunnable implements Runnable{public void start{}}\npublic class MyRunnable implements Runnable{public void run(){}}\n','Threads',0,0,NULL,5),(1940,'0..1..2..','public class Hello extends Thread {\n    public static void main(String[] args){\n       Hello h = new Hello();\n       Thread x = new Thread(h);\n       h.start();\n        \n    }\n    \n    public void run() {\n        for(int i=0; i<3; ++i)\n            System.out.print(i+\"...\");\n    }\n}','Threads',0,0,NULL,5),(1941,'will not compile .sleep() must be enclosed in a try block to catch its\nInterruptedException','public class Hello {\n    public static void main(String[] args){\n       printAll(args);\n        \n    }\n    \n    public static void printAll(String[] lines){\n        for(int i = 0; i<lines.length; i++){\n            System.out.println(lines[i]);\n            Thread.currentThread().sleep(1000);\n        }\n    }\n}\n\nwhat is the result','Threads',0,0,NULL,5),(1942,'public synchronized int read() { return a+b; }\npublic synchronized void set(int a, int b){this.a = a; this.b = b;}\n\npublic int read(){ synchronized(this){ return a+b; } }\npublic void set(int a, int b){synchronized(this){ this.a = a; this.b = b;} }\n\n\n','you have two private variables a and b. prevent concurrent access problems using\ntheir read() and set(int a, int b){} methods.','Threads',0,0,NULL,5),(1943,'1 2 \n\nIllegalMonitorStateException is unchecked and thrown by trying to wait\nsomething yyou do not own the lock to!','public class WaitTest {\n	public static void main(String[] args){\n		sout(\"1\");\n		synchronized(args){\n			sout(\"2\");\n			try{\n				args.wait();\n			} catch(InterruptedException e) {\n			}\n		}\n		sout(\"3\");\n	}\n}\n\n1. IllegalMonitorStateException\n2. will not compile\n3. 1 2 3\n4. 1 2\n5. fails to compile because of wait() illegalMonitorstatexception','Threads',0,0,NULL,5),(1944,'After object B is notified, or after two seconds. ','the following method is called from thread A on an object B and it is properly synchronized\n\nwait(2000);\n\nafter calling the method when will thread A becoma a canidate to get another \nturn at the CPU ?\n','Threads',0,0,NULL,5),(1945,'1 4','which are true ?\n\n1 the notifyAll() must be called from a synchronized context\n2 to call wati() an object must own the lock on the thread\n3 the notify() method is defined in class java.lang.thread\n4 when a thread is waiting as a result of wait() it releases its lock\n5 notify() method causes a thread to imeediately release its lock\n6 the difference between notify() and notifyAll() is that notifyAll() notifies\nall waiting threads regardless of the object theyre waiting on','Threads',0,0,NULL,5),(1946,'synchronize both log() and getContents()\n\neven though stringbuffer is synchronized internally, append is called \nmultiple times so anythread could get in there in between calls','public class Logger {\n	private StringBuilder contents = new StringBuilder();\n	public void log(String mess){\n		contents.append(System.currentTimeMillis());\n		contents.append(\": \");\n		contents.append(Thread.currentThread().getName());\n		contents.append(mess);\n	}\n\n	public String getContents() { return contents.toString(); }\n}\n\nhow can you enxure that instances of this class can be safely used by multiple \nthreads ?\n\nreplace StringBuilder with thread-safe StringBuffer ?','Threads',0,0,NULL,5),(1947,'IllegalMonitorStateException is thrown because the main thread does not \nhave a lock on t before it decides to wait on it. ','public static synchronized void main(Stirng[] args) throws InterruptedException {\n	Thread t = new Thread();\n	t.start();\n	sout(\"X\");\n	t.wait(10000);\n	sout(\"y\");\n}','Threads',0,0,NULL,5),(1948,'MyThread foo','class MyThread extends Thread {\n	MyThread() {\n		sout(\"MyThread\");\n	}\n	public void run(){\n		sout(\"bar\");\n	}\n\n	public void run(String s){\n		sout(\"baz\");\n	}\n}\n\npublic class Test {\n	psvm(sa){\n		Thread t = new MyThread(){\n			public void run(){\n				sout(\"foo\");\n			}\n		};\n		t.start();\n	}\n}\n		','Threads',0,0,NULL,5),(1949,'will not compile unreported IOException from newWatchService() and \npath.register()','public class Hello {\n    public static void main(String[] args){\n       WatchService watchService\n          = FileSystems.getDefault().newWatchService();\n \n        Path path = Paths.get(System.getProperty(\"user.home\"));\n \n        path.register(\n          watchService, \n            StandardWatchEventKinds.ENTRY_CREATE, \n              StandardWatchEventKinds.ENTRY_DELETE, \n                StandardWatchEventKinds.ENTRY_MODIFY);\n \n        WatchKey key;\n        while ((key = watchService.take()) != null) {\n            for (WatchEvent<?> event : key.pollEvents()) {\n                System.out.println(\n                  \"Event kind:\" + event.kind() \n                    + \". File affected: \" + event.context() + \".\");\n            }\n            key.reset();\n        }\n        \n    }\n    \n    \n}','IO',0,0,NULL,5),(1950,'will not compile take() throws an InterruptedException because \nit will wait if there are no events present','public class Hello {\n    public static void main(String[] args) throws IOException{\n       WatchService watchService\n          = FileSystems.getDefault().newWatchService();\n \n        Path path = Paths.get(System.getProperty(\"user.home\"));\n \n        path.register(\n          watchService, \n            StandardWatchEventKinds.ENTRY_CREATE, \n              StandardWatchEventKinds.ENTRY_DELETE, \n                StandardWatchEventKinds.ENTRY_MODIFY);\n \n        WatchKey key;\n        while ((key = watchService.take()) != null) {\n            for (WatchEvent<?> event : key.pollEvents()) {\n                System.out.println(\n                  \"Event kind:\" + event.kind() \n                    + \". File affected: \" + event.context() + \".\");\n            }\n            key.reset();\n        }\n        \n    }\n    \n    \n}','IO',0,0,NULL,5),(1951,'compiles fine if you were to delete a file from home directory \nyou would get a notice like this: \n	\n	Event kind:ENTRY_CREATE. File affected: Untitled Document.\n\n','public class Hello {\n    public static void main(String[] args) throws IOException, InterruptedException {\n       WatchService watchService\n          = FileSystems.getDefault().newWatchService();\n \n        Path path = Paths.get(System.getProperty(\"user.home\"));\n \n        path.register(\n          watchService, \n            StandardWatchEventKinds.ENTRY_CREATE, \n              StandardWatchEventKinds.ENTRY_DELETE, \n                StandardWatchEventKinds.ENTRY_MODIFY);\n \n        WatchKey key;\n        while ((key = watchService.take()) != null) {\n            for (WatchEvent<?> event : key.pollEvents()) {\n                System.out.println(\n                  \"Event kind:\" + event.kind() \n                    + \". File affected: \" + event.context() + \".\");\n            }\n            key.reset();\n        }\n        \n    }\n    \n    \n}','IO',0,0,NULL,5),(1952,'this would run one time, if there were no WatchEvents immediately available\nit would end.\nPoll() gets events and does not wait. \n\n','public class Hello {\n    public static void main(String[] args) throws IOException {\n       WatchService watchService\n          = FileSystems.getDefault().newWatchService();\n \n        Path path = Paths.get(System.getProperty(\"user.home\"));\n \n        path.register(\n          watchService, \n            StandardWatchEventKinds.ENTRY_CREATE, \n              StandardWatchEventKinds.ENTRY_DELETE, \n                StandardWatchEventKinds.ENTRY_MODIFY);\n \n        WatchKey key;\n        while ((key = watchService.poll()) != null) {\n            for (WatchEvent<?> event : key.pollEvents()) {\n                System.out.println(\n                  \"Event kind:\" + event.kind() \n                    + \". File affected: \" + event.context() + \".\");\n            }\n            key.reset();\n        }\n        \n    }\n    \n    \n}','IO',0,0,NULL,5),(1953,'...just a good example','Path path = Paths.get(\"/home\");\nWatchService watchService = FileSystems.getDefault().newWatchService();\nWatchKey watchKey = path.register(watchService,ENTRY_CREATE,ENTRY_DELETE,ENTRY_MODIFY);\n\nprivate boolean notDone = true;\nwhile(notDone){\n    try{\n         WatchKey watchKey = watchService.poll(60,TimeUnit.SECONDS);\n         List<WatchEvent.Kind<?>> events = watchKey.pollEvents();\n         for(WatchEvent event : events){\n            ...process the events\n         }\n         if(!watchKey.reset()){\n            ...handle situation no longer valid\n         }\n     }catch(InterruptedException e){\n            Thread.currentThread().interrupt();\n     }','IO',0,0,NULL,5),(1954,'will not compile, Subleaser does not implemnet runnable!\n\nAlso the two threads synchronize on their very own messageboards so \nthey have no problem getting access to them and printing their messages.\n\nSecondly Nothing is ever printed from the MessageBoard.','public class Hello {\n    public static void main(String[] dicks){\n        Thread t1 = new Thread(new Advertiser());\n        Thread t2 = new Thread(new Subleaser());\n    }\n\n}    \n\nclass MessageBoard {\n    private StringBuilder contents = new StringBuilder();\n    \n    public synchronized void postMessage(String s){\n        contents.append(s + \" \");\n    }\n    \n    public synchronized String readBoard(){\n        return contents.toString();\n    }\n    \n    public StringBuilder takeTurnAtBoard(){\n        return contents;\n    }\n}\n\nclass Advertiser implements Runnable{\n    protected MessageBoard mb = new MessageBoard();\n    public void run(){\n        synchronized(mb){\n            mb.postMessage(\"Attention!\");\n            mb.postMessage(\"Platonics\");\n            mb.postMessage(\"Lost Dog! 1000$ reward\");\n            mb.postMessage(\"Sex Change coupon\");\n            \n            System.out.println(mb.readBoard());\n        } \n    }\n}\n\nclass Subleaser{\n    private MessageBoard mb = new MessageBoard();\n    \n    public void run(){\n        synchronized(mb){\n            mb.postMessage(\"1000 a month!\");\n            mb.postMessage(\"two br\");\n            mb.postMessage(\"no dogs allowed!\");\n        }\n    }\n}','Threads',0,0,NULL,5),(1955,'subleaser  1000 a month! two br no dogs allowed! \nadvertiser  Attention! Platonics Lost Dog! 1000$ reward Sex Change coupon \n\nadvertiser  Attention! Platonics Lost Dog! 1000$ reward Sex Change coupon \nsubleaser  1000 a month! two br no dogs allowed!\n\nthese results can be unpredictable, though the methods are synched\nnothing is stopping another thread from coming in between append calls.\n\nto make the ressults truly predictable synchronized the postmessage calls in a block\non mb','public class Hello {\n    public static void main(String[] dicks){\n        Thread t1 = new Thread(new Advertiser(),\"advertiser\");\n        Thread t2 = new Thread(new Subleaser(),\"subleaser\");\n        \n        t1.start();\n        t2.start();\n    }\n\n}    \n\nclass MessageBoard {\n    private StringBuilder contents = new StringBuilder();\n    \n    public synchronized void postMessage(String s){\n        contents.append(s);\n        contents.append(\" \");\n    }\n    \n    public synchronized String readBoard(){\n        return contents.toString();\n    }\n    \n    public StringBuilder takeTurnAtBoard(){\n        return contents;\n    }\n}\n\nclass Advertiser implements Runnable{\n    protected MessageBoard mb = new MessageBoard();\n    public void run(){\n            //Thread.getName() static method cannot be called from non static\n            mb.postMessage(Thread.currentThread().getName()+\" \");\n            mb.postMessage(\"Attention!\");\n            mb.postMessage(\"Platonics\");\n            mb.postMessage(\"Lost Dog! 1000$ reward\");\n            mb.postMessage(\"Sex Change coupon\");\n            \n            System.out.println(mb.readBoard());\n        \n    }\n}\n\nclass Subleaser implements Runnable{\n    private MessageBoard mb = new MessageBoard();\n    \n    public void run(){\n            mb.postMessage(Thread.currentThread().getName()+\" \");\n            mb.postMessage(\"1000 a month!\");\n            mb.postMessage(\"two br\");\n            mb.postMessage(\"no dogs allowed!\");\n            \n            System.out.println(mb.readBoard());\n        }\n}','IO',0,0,NULL,5),(1956,'these can be quiet unpredictable:\n\n	subleaser  two br no dogs allowed! 1200$ a month advertiser  Attention! Lost Dog! 1000$ reward Sex Change coupon \nsubleaser  two br no dogs allowed! 1200$ a month advertiser  Attention! Lost Dog! 1000$ reward Sex Change coupon \n\nBoth threads are operating on the same instance, that instances objects\nmethods are synchronized but that doesn\'t stop the other thread from coming\ninbetween calls to postMessage()','public class Hello {\n    public static void main(String[] dicks){\n        MessageBoard mb = new MessageBoard();\n        Thread t1 = new Thread(new Advertiser(mb),\"advertiser\");\n        Thread t2 = new Thread(new Subleaser(mb),\"subleaser\");\n        \n        t1.start();\n        t2.start();\n    }\n\n}    \n\nclass MessageBoard {\n    private StringBuilder contents = new StringBuilder();\n    \n    public synchronized void postMessage(String s){\n        contents.append(s);\n        contents.append(\" \");\n    }\n    \n    public synchronized String readBoard(){\n        return contents.toString();\n    }\n    \n    public StringBuilder takeTurnAtBoard(){\n        return contents;\n    }\n}\n\nclass Advertiser implements Runnable{\n    protected MessageBoard mb;\n    \n    public Advertiser(MessageBoard mb){\n        this.mb = mb;\n    }\n    public void run(){\n            //Thread.getName() static method cannot be called from non static\n            mb.postMessage(Thread.currentThread().getName()+\" \");\n            mb.postMessage(\"Attention!\");\n            mb.postMessage(\"Lost Dog! 1000$ reward\");\n            mb.postMessage(\"Sex Change coupon\");\n            \n            System.out.println(mb.readBoard());\n        \n    }\n}\n\nclass Subleaser implements Runnable{\n    private MessageBoard mb;\n    \n    public Subleaser(MessageBoard mb){\n        this.mb = mb;\n    }\n    \n    public void run(){\n            mb.postMessage(Thread.currentThread().getName()+\" \");\n            mb.postMessage(\"two br\");\n            mb.postMessage(\"no dogs allowed!\");\n            mb.postMessage(\"1200$ a month\");\n            \n            System.out.println(mb.readBoard());\n        }\n}\n','IO',0,0,NULL,5),(1957,'You can be assured that these results will be predictable,\n\nThe synchronized blocks get a hold of the lock so it is just a compettion\nof which thread will lock first. ','public class Hello {\n    public static void main(String[] dicks){\n        MessageBoard mb = new MessageBoard();\n        Thread t1 = new Thread(new Advertiser(mb),\"advertiser\");\n        Thread t2 = new Thread(new Subleaser(mb),\"subleaser\");\n        \n        t1.start();\n        t2.start();\n    }\n\n}    \n\nclass MessageBoard {\n    private StringBuilder contents = new StringBuilder();\n    \n    public synchronized void postMessage(String s){\n        contents.append(s);\n        contents.append(\" \");\n    }\n    \n    public synchronized String readBoard(){\n        return contents.toString();\n    }\n    \n    public StringBuilder takeTurnAtBoard(){\n        return contents;\n    }\n}\n\nclass Advertiser implements Runnable{\n    protected MessageBoard mb;\n    \n    public Advertiser(MessageBoard mb){\n        this.mb = mb;\n    }\n    public void run(){\n        synchronized(mb){\n            //Thread.getName() static method cannot be called from non static\n            mb.postMessage(Thread.currentThread().getName()+\" \");\n            mb.postMessage(\"Attention!\");\n            mb.postMessage(\"Lost Dog! 1000$ reward\");\n            mb.postMessage(\"Sex Change coupon\");\n            \n            System.out.println(mb.readBoard());\n        }\n    }\n}\n\nclass Subleaser implements Runnable{\n    private MessageBoard mb;\n    \n    public Subleaser(MessageBoard mb){\n        this.mb = mb;\n    }\n    \n    public void run(){\n        synchronized(mb){\n            mb.postMessage(Thread.currentThread().getName()+\" \");\n            mb.postMessage(\"two br\");\n            mb.postMessage(\"no dogs allowed!\");\n            mb.postMessage(\"1200$ a month\");\n            \n            System.out.println(mb.readBoard());\n        }\n        }\n        \n}\n','IO',0,0,NULL,5),(1958,'foo.txt ENTRY_DELETE\n\n... Watcher only watches one directory at a time, not subdirectories','public class Hello {\n    public static void main(String[] dicks) throws InterruptedException {\n        try{\n            WatchService watcher = FileSystems.getDefault().newWatchService();\n            Path home = Paths.get(\"/home/maxbisesi\");\n            home.register(watcher, StandardWatchEventKinds.ENTRY_CREATE,StandardWatchEventKinds.ENTRY_DELETE);\n            \n            WatchKey key;\n            \n            //throws interruptedException \n            while((key = watcher.take()) != null) {\n                for(WatchEvent<?> event : key.pollEvents()){\n                    System.out.println(event.context() + \" \" + event.kind());\n              }\n           }\n        } catch(IOException ei){\n            \n        }    \n    }\n\n}    \n\nI delete foo.txt out of the home directory then go into Documents and delete\nindex.html. What is the result ?','IO',0,0,NULL,5),(1959,'1. 4 4 \n2. does not compile\n3. prints nothign , but starts a new thread\n4. creates a new thread and invokes run() directlyy\n5. creates and starts a new thread. ','public class Starter implements Runnable {\n	void go(long id) {\n		sout(id);\n	}\n\n	public static void main(String[] args){\n		sout(Thread.currentThread().getId() + \" \");\n		//insert code\n	}\n	public void run() { go(Thread.currentThread().getId()); }\n}\n\n1. new Starter().run();\n2. new Starter().start();\n3. new Thread(new Starter());\n4. new Thread(new Starter()).run();\n5. new Thread(new Starter()).start();','IO',0,0,NULL,5),(1960,'will not commpile, join throws interruptedexception ','public class Hello implements Runnable {\n    public void run(){\n        System.out.println(\"r1 \");\n        System.out.println(\"r2 \");\n    }\n    public static void main(String[] args){\n        Thread t = new Thread(new Hello());\n        t.start();\n        System.out.println(\"m1 \");\n        t.join();\n        System.out.println(\"m2 \");\n    }\n}','IO',0,0,NULL,5),(1961,'could be:\n\nm1 r1 r2 m2\nr1 m1 r2 m2\nr1 r2 m1 m2\n\njoin throws interruptedexception, it causes main to join onto the end\nof the thread t and wait till its done to continue. ','public class Hello implements Runnable {\n    public void run(){\n        System.out.println(\"r1 \");\n        System.out.println(\"r2 \");\n    }\n    public static void main(String[] args){\n        Thread t = new Thread(new Hello());\n        t.start();\n        System.out.println(\"m1 \");\n        try{\n            t.join();\n        } catch(InterruptedException e){\n            \n        }\n        System.out.println(\"m2 \");\n    }\n}','IO',0,0,NULL,5),(1962,'NullpointerException,\n\nthis one is hard to spot but c is initialized in the go method, an \ninstance method. The two threads start their own new instance and go\ndirectly to the run() method, without go() c never gets initialized. \n\nfor this to work c would have to be static. \n','public class Hello implements Runnable {\n    Chicks c;\n    public void run(){\n       c.yack(Thread.currentThread().getId());\n    }\n    public static void main(String[] args){\n        new Hello().go();\n       \n    }\n    \n    void go(){\n        c = new Chicks();\n        new Thread(new Hello()).start();\n        new Thread(new Hello()).start();\n    }\n}\n\nclass Chicks {\n    synchronized void yack(long id){\n        for(int x = 1; x <3; x++){\n            System.out.println(id + \" \");\n            Thread.yield();\n        }\n    }\n}','IO',0,0,NULL,5),(1963,'8\n8\n9\n9','public class Hello implements Runnable {\n    static Chicks c;\n    public void run(){\n       c.yack(Thread.currentThread().getId());\n    }\n    public static void main(String[] args){\n        new Hello().go();\n       \n    }\n    \n    void go(){\n        c = new Chicks();\n        new Thread(new Hello()).start();\n        new Thread(new Hello()).start();\n    }\n}\n\nclass Chicks {\n    synchronized void yack(long id){\n        for(int x = 1; x <3; x++){\n            System.out.println(id + \" \");\n            Thread.yield();\n        }\n    }\n}','IO',0,0,NULL,5),(1964,'','public class Hello implements Runnable {\n    static Chicks c;\n    public void run(){\n       c.yack(Thread.currentThread().getId());\n    }\n    public static void main(String[] args){\n        new Hello().go();\n       \n    }\n    \n    void go(){\n        c = new Chicks();\n        new Thread(new Hello()).start();\n        new Thread(new Hello()).start();\n    }\n}\n\nclass Chicks {\n    static long flag = 0;\n    synchronized void yack(long id){\n        if(flag == 0) flag = id;\n        for(int x = 1; x <3; x++){\n            if(flag == id) System.out.println(\"yada yada \");\n            else System.out.println(\"ehh \");\n        }\n    }\n}','IO',0,0,NULL,5),(1965,'the output could be 8 9 8 9\n\n..it could be anything really','public class Hello implements Runnable {\n    public void run(){\n       move(Thread.currentThread().getId());\n    }\n    \n    void move(long id){\n        System.out.println(id + \" \");\n        System.out.println(id + \" \");\n    }\n    public static void main(String[] args){\n        Hello h = new Hello();\n        new Thread(h).start();\n        new Thread(new Hello()).start();\n    }\n}','IO',0,0,NULL,5),(1966,'the output could be 4 2 4 2\n\nWhile the method is synhcronized it is being invoked by two different\nobjects so they could print in any order still \n\n','public class Hello implements Runnable {\n    public void run(){\n       move(Thread.currentThread().getId());\n    }\n    \n    synchronized void move(long id){\n        System.out.println(id + \" \");\n        System.out.println(id + \" \");\n    }\n    public static void main(String[] args){\n        Hello h = new Hello();\n        new Thread(h).start();\n        new Thread(new Hello()).start();\n    }\n}','IO',0,0,NULL,5),(1967,'test','test	','IO',0,0,NULL,5),(1968,'add  and  remove','Which method from a CopyOnWriteArrayList will caue a new copy of the internal\narray to be created ?','IO',0,0,NULL,5),(1969,'2018699554\n1311053135\nlocked thread Thread1\nunable to lock thread Thread2 will re try again\nunlocked locked thread Thread1\nlocked thread Thread2\nunlocked locked thread Thread2\n\nThe two threads use two different Runnables, but they are both vying for the same\nlock. ','public class Hello {\n    public static void main(String[] args){\n        new ReentrantLockingDemo().go();\n    }\n}\n\nclass ReentrantLockingDemo {\n\n    final Lock lock = new ReentrantLock();\n\n    public void go() {\n\n        Runnable run1 = newRunable();\n        Thread t1 = new Thread(run1, \"Thread1\");\n        System.out.println(run1.hashCode());\n        t1.start();\n\n        Runnable run2 = newRunable();\n        Thread t2 = new Thread(run2, \"Thread2\");\n        System.out.println(run2.hashCode());\n        t2.start();\n\n    }\n\n    private Runnable newRunable() {\n        return new Runnable() {\n            public int hashCode() {\n                return super.hashCode();\n            }\n            public void run() {\n                do {\n                    try {\n                        if (lock.tryLock(500, TimeUnit.MILLISECONDS)) {\n                            try {\n                                System.out.println(\"locked thread \"\n                                        + Thread.currentThread().getName());\n                                Thread.sleep(1000);\n                            } finally {\n                                lock.unlock();\n                                System.out.println(\"unlocked locked thread \"\n                                        + Thread.currentThread().getName());\n                            }\n                            break;\n                        } else {\n                            System.out.println(\"unable to lock thread \"\n                                    + Thread.currentThread().getName()\n                                    + \" will re try again\");\n                        }\n                    } catch (InterruptedException e) {\n                        e.printStackTrace();\n                    }\n                } while (true);\n            }     \n        };\n    }\n\n}','IO',0,0,NULL,5),(1970,'How a join should be used and implemented. \n\n100 Rens followed by 100 stimpys','public class ThreadTest {\n	class InnerRun implements Runnable {\n		public void run() {\n			for(int x = 0; x < 100; x++){\n				try{\n					Thread.sleep(5);\n				} catch(Exception e) {}\n				sout( \"Ren\" );\n			}\n		}\n	}\n\n	class InnerRunTwo implements Runnable {\n		Thread other;\n		public InnerRunTwo(Thread x){ other = x; }\n		public void run() {\n			try{\n				other.join();\n			} catch(Exception e) { }\n			for(int x = 0; x < 100; x++){\n			   try{\n				Thread.sleep(5);\n			   } catch( Exception e) { }\n			   sout( \"stimpy\" );\n			}\n		}	\n	}\nvoid start(){\n	InnerRun ir = new InnerRun();\n	Thread t = new Thread(ir);\n	InnerRunTwo irr = new InnerRunTwo(t);\n	Thread u = new Thread(irr);\n		t.start();	\n		u.start();\n}\npsvm(SA){ ThreadTest tt = new ThreadTest(); tt.start(); }\n}','IO',0,0,NULL,5),(1971,'run:\nInstance locked by: Thread-0\n0\nInstance locked by: Thread-0\n1\nInstance locked by: Thread-0\n2\nInstance locked by: Thread-0\n3\nInstance locked by: Thread-0\n4\nInstance locked by: Thread-0\n5\nInstance locked by: Thread-0\n6\nInstance locked by: Thread-0\n7\nInstance locked by: Thread-0\n8\nInstance locked by: Thread-0\n9\nInstance locked by: Thread-0\n10\nBUILD STOPPED (total time: 10 seconds)\n','public class Hello {\n    public static void main(String[] args){\n        Data data = new Data();\n        DataThread dt = new DataThread(data);\n        Thread t1 = new Thread(dt);\n        Thread t2 = new Thread(dt);\n        Thread t3 = new Thread(dt);\n        Thread t4 = new Thread(dt);\n        Thread t5 = new Thread(dt);\n        \n        t1.start();\n        t2.start();\n        t3.start();\n        t4.start();\n        t5.start();\n        \n    }\n}\n\nclass Data {\n    public Object lock = new Object();\n    public static Object staticLock = new Object();\n    \n    public synchronized void instanceLocked(){\n        System.out.println(\"Instance locked by: \"+Thread.currentThread().getName());\n    }\n    \n    public static synchronized void classLocked(){\n        System.out.println(\"class locked by: \"+Thread.currentThread().getName());\n        while(true){\n            \n        }\n    }\n}\n\nclass DataThread implements Runnable {\n    private Data data;\n    \n    public DataThread(Data data){\n        this.data = data;\n    }\n    public void run(){\n        synchronized(data.lock){\n            \n            for(int i = 0; i<100; i++){\n                data.instanceLocked();\n                System.out.println(i);\n                \n                try{\n                    Thread.sleep(1000);\n                } catch(InterruptedException e){\n                    \n                }\n            }\n            \n        }\n    }\n    \n}','IO',0,0,NULL,5),(1972,'Gaston: Alphonse has bowed to me!\nAlphonse: Gaston started to bow to me, but saw that I was already bowing to him.\nAlphonse: Gaston has bowed back to me!\nAlphonse: Gaston has bowed to me!\nGaston: Alphonse has bowed back to me!\nAlphonse: Gaston has bowed to me!\nGaston: Alphonse has bowed back to me!\nGaston: Alphonse has bowed to me!\nAlphonse: Gaston has bowed back to me!\nAlphonse: Gaston has bowed to me!\nGaston: Alphonse has bowed back to me!\nGaston: Alphonse has bowed to me!\nAlphonse: Gaston has bowed back to me!\nAlphonse: Gaston has bowed to me!\nGaston: Alphonse has bowed back to me!\nGaston: Alphonse has bowed to me!\nAlphonse: Gaston has bowed back to me!\nAlphonse: Gaston has bowed to me!\nGaston: Alphonse has bowed back to me!\nGaston: Alphonse has bowed to me!\nAlphonse: Gaston has bowed back to me!\nGaston: Alphonse has bowed to me!\nAlphonse: Gaston has bowed back to me!\nAlphonse: Gaston has bowed to me!\nGaston: Alphonse has bowed back to me!\nAlphonse: Gaston has bowed to me!\nGaston: Alphonse has bowed back to me!\nGaston: Alphonse has bowed to me!\nAlphonse: Gaston has bowed back to me!\nAlphonse: Gaston has bowed to me!\nGaston: Alphonse has bowed back to me!\nGaston: Alphonse started to bow to me, but saw that I was already bowing to him.\nAlphonse: Gaston has bowed to me!\nGaston: Alphonse has bowed back to me!\nAlphonse: Gaston has bowed to me!\nGaston: Alphonse has bowed back to me!','public class Hello {\n    public static void main(String[] args){\n         final Safelock.Friend alphonse =\n            new Safelock.Friend(\"Alphonse\");\n        final Safelock.Friend gaston =\n            new Safelock.Friend(\"Gaston\");\n        new Thread(new Safelock.BowLoop(alphonse, gaston)).start();\n        new Thread(new Safelock.BowLoop(gaston, alphonse)).start();\n    }\n}\n\nclass Safelock {\n    static class Friend {\n        private final String name;\n        private final Lock lock = new ReentrantLock();\n\n        public Friend(String name) {\n            this.name = name;\n        }\n\n        public String getName() {\n            return this.name;\n        }\n\n        public boolean impendingBow(Friend bower) {\n            Boolean myLock = false;\n            Boolean yourLock = false;\n            try {\n                myLock = lock.tryLock();\n                yourLock = bower.lock.tryLock();\n            } finally {\n                if (! (myLock && yourLock)) {\n                    if (myLock) {\n                        lock.unlock();\n                    }\n                    if (yourLock) {\n                        bower.lock.unlock();\n                    }\n                }\n            }\n            return myLock && yourLock;\n        }\n            \n        public void bow(Friend bower) {\n            if (impendingBow(bower)) {\n                try {\n                    System.out.format(\"%s: %s has\"\n                        + \" bowed to me!%n\", \n                        this.name, bower.getName());\n                    bower.bowBack(this);\n                } finally {\n                    lock.unlock();\n                    bower.lock.unlock();\n                }\n            } else {\n                System.out.format(\"%s: %s started\"\n                    + \" to bow to me, but saw that\"\n                    + \" I was already bowing to\"\n                    + \" him.%n\",\n                    this.name, bower.getName());\n            }\n        }\n\n        public void bowBack(Friend bower) {\n            System.out.format(\"%s: %s has\" +\n                \" bowed back to me!%n\",\n                this.name, bower.getName());\n        }\n    }\n\n    static class BowLoop implements Runnable {\n        private Friend bower;\n        private Friend bowee;\n\n        public BowLoop(Friend bower, Friend bowee) {\n            this.bower = bower;\n            this.bowee = bowee;\n        }\n    \n        public void run() {\n            Random random = new Random();\n            for (;;) {\n                try {\n                    Thread.sleep(random.nextInt(10));\n                } catch (InterruptedException e) {}\n                bowee.bow(bower);\n            }\n        }\n    }\n}','IO',0,0,NULL,5),(1973,'good example of Conditions','class BoundedBuffer {\n   final Lock lock = new ReentrantLock();\n   final Condition notFull  = lock.newCondition(); \n   final Condition notEmpty = lock.newCondition(); \n\n   final Object[] items = new Object[100];\n   int putptr, takeptr, count;\n\n   public void put(Object x) throws InterruptedException {\n     lock.lock();\n     try {\n       while (count == items.length)\n         notFull.await();\n       items[putptr] = x;\n       if (++putptr == items.length) putptr = 0;\n       ++count;\n       notEmpty.signal();\n     } finally {\n       lock.unlock();\n     }\n   }\n\n   public Object take() throws InterruptedException {\n     lock.lock();\n     try {\n       while (count == 0)\n         notEmpty.await();\n       Object x = items[takeptr];\n       if (++takeptr == items.length) takeptr = 0;\n       --count;\n       notFull.signal();\n       return x;\n     } finally {\n       lock.unlock();\n     }\n   }\n }','IO',0,0,NULL,5),(1974,'Will not compile, ArrayList listData is a raw type so in the foreach loop\nyou assign them to an Integer, you would have had to cast','class DataThread implements Runnable {\n    private Data data;\n    private ArrayList listData;\n    \n    public DataThread(Data data){\n        this.data = data;\n    }\n    public void run(){\n            data.lock.lock();\n            try{\n                listData = data.produceData();\n            try{\n               data.done.await();\n            } catch(InterruptedException e){\n                \n            }\n            \n            for(Integer i : listData){\n                System.out.println(i);\n            }\n            } finally {\n                data.lock.unlock();\n            }\n    }\n    \n}','IO',0,0,NULL,5),(1975,'With ReentrantReadWriteLock you can grant write access to only one thread, but\nit is possible to allow many threads to be reading at the same time. ','public class Hello {\n    private List<Integer> integers = new ArrayList<>();\n    private ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();\n    \n    public void add(Integer i){\n        rwl.writeLock().lock();\n        try {\n            integers.add(i);\n        } finally {\n            rwl.writeLock().unlock();\n        }\n    }\n    \n    public int findMax() {\n        rwl.readLock().lock();\n        try {\n            return Collections.max(integers);\n        } finally {\n            rwl.readLock().unlock();\n        }\n    }\n    public static void main(String[] args){\n      \n    }\n\n}','IO',0,0,NULL,5),(1976,'','read-only(immutabel) objects are always thread safe. ','IO',0,0,NULL,5),(1977,'your data sets remain small and the number of read operations and traversals greatly outnumber\nmodifications to the collection. \n\nCopy on write collections work by copying their internal array of data with\nany mutating operation. This copied array will replace the original read only\narrray. \n\nThis allows it to be safely shared between multiple threads. ','Use copy on write collections when...','IO',0,0,NULL,5),(1978,'','Just because a collection is thread safe does not make the elements stored within\nthread safe','IO',0,0,NULL,5),(1979,'','The Iterator for a concurrent collection is weakly consistent; it can return elements \nfrom the point in time the Iterator was created or LATER. This means that \nwhile looping through a concurrent collection, you might observel elements that\nare being inserted by other threads. also you might see only some of the elements\nthat another thread is inserting. ','IO',0,0,NULL,5),(1980,'ConcurrentSkipListMap and ConcurrentSkipListSet \n\n-They require the use of comparable and comparotr to enable ordering. ','Which concurrent Collections are sorted ?','IO',0,0,NULL,5),(1981,'','copy on write and concurrent collections are centered on the idea of multiple\nthreads sharing data. \n\nA BlockingQueue is used to exchnage data between two or more threads while causing\nsome of the threads to wait until the point in time when the data can be \ntransfered. ','IO',0,0,NULL,5),(1982,'4\n4\n3\n6\n8\n\nto indicate that you want a pattern to be surrounded by other similar characteres\nsurround it with non word boundaries. If you did want the character to \nbee alone surround it with word boudaries.','class Hello {\n    public static void main(String[] args) {     \n        Pattern p = Pattern.compile(\"\\\\B\\\\d\\\\B\");\n        Matcher m = p.matcher(\"Th4t\'ll b3 the d4y, on th3 v3ry l6ast d8y\");\n        \n        while(m.find()){\n            System.out.println(m.group());\n        }\n        \n    }\n\n}','Strings',0,0,NULL,5),(1983,'ArrayBlockingQueue\nLinkedBlockingQueue\nLinkedBlockingQueue\nPriorityBlockingQueue\nDelayQueue\nLinkedTransferQueue\nSynchronousQueue\n','BlockingQueue implementations','Concurrency',0,0,NULL,5),(1984,'','A blocking collection, depending on the method being called, may cause a thread to block\nuntil another threads calls a corresponding method on the collection. \n\nif you attempt to reemove an element() by calling take() on any BlockingQueue\nthat is empty, the operation will block until another thread inserts an element.\n','Concurrency',0,0,NULL,5),(1985,'Returns true if object added,\n\nfalse if duplicate objects are not allowed.\n\nThrows IllegalStateException if the queue is bounded and full','BlockingQueue method:\n\nadd(E e)','Concurrency',0,0,NULL,5),(1986,'returns true if object added, false if the queue is bounded and full','BlockingQueue method:\n\noffer(E e)','Concurrency',0,0,NULL,5),(1987,'returns void.\n\nwill block until space in the queue becomes available if needed ','BlockingQueue method:\n\nput(E e)','Concurrency',0,0,NULL,5),(1988,'returns false if the object was not able to be inserted before the time idicated,\n','offer(E e, long timeout, TimeUnit unit)','Concurrency',0,0,NULL,5),(1989,'returns true if an equal object was found in the queue and removed; \notherwise returns false.','BlockingQueue method:\n\nremove(Object o)','Concurrency',0,0,NULL,5),(1990,'removes the first object in the queue and returns it. \n\nif the timeout expires before an object can be removed becaue the queue is empty\nthen a null will be returned. ','BlockingQueue method:\n\npoll(long timeout, TimeUnit unit)','Concurrency',0,0,NULL,5),(1991,'Removes and returns the first object in the queue, blocking if needed until the \nobject becomes available. \n\nonly throws InterruptedException','BlockingQueue method:\n\ntake()','Concurrency',0,0,NULL,5),(1992,'removes and returns the first object in the queue and returns null if the queue is empty\n','BlockingQueue method:\n\npoll()','Concurrency',0,0,NULL,5),(1993,'Gets the head of the queue without removing it, Throws a NoSuchElementException\nif the queue is empty. ','BlockingQueue method:\n\nelement()','Concurrency',0,0,NULL,5),(1994,'gets the head of the queue without removing it, Returns a null if the queue is \nempty. ','BlockingQueue method:\n\npeek()','Concurrency',0,0,NULL,5),(1995,'The second put(35) will block until previous values is removed by another thread.','BlockingQueue<Integer> bq = new ArrayBlockingQueue<>(1);\n\ntry{\n	bq.put(34);\n	bq.put(35);\n} catch(InterruptedException e) {}','Concurrency',0,0,NULL,5),(1996,'...is a speciel type of bounded blocking queue; it has a capacity of \nzero. The first thread to attempt either an insert or remvoe operaion\non a synchronousQueue will block until another thread performs the opposite \noperation. USe this when you need threads to meet up and exchange an object.','SynchronousQueue','Concurrency',0,0,NULL,5),(1997,'5\n9\n\nThe iterator was obtained before the 3 was added. As long as the reference to \nthe iterator is maintained it will only provide access to 5 9.\n\nIt is ConcurrentCollections that will remain weakly consistant with the changes\nmade by other threads, This is a copyonwrite array list which is thread safe but\nnot concurrent.','public class Hello {\n    public static void main(String[] args){\n       CopyOnWriteArrayList<Integer> list = new CopyOnWriteArrayList<>();\n       \n       list.add(5);\n       list.add(9);\n       Iterator<Integer> it = list.iterator();\n       \n       list.add(3);\n       \n       while(it.hasNext()){\n           System.out.println(it.next());\n       }\n    }\n}','Concurrency',0,0,NULL,5),(1998,'5\n9\n4\n\nThe iterator is obtained before the element at index 2 is removed.','public class Hello {\n    public static void main(String[] args){\n       CopyOnWriteArrayList<Integer> cowlist = new CopyOnWriteArrayList<>();\n       \n       cowlist.add(5);\n       cowlist.add(9);\n       cowlist.add(4);\n       \n       Iterator<Integer> it = cowlist.iterator();\n       \n       cowlist.remove(2);\n       \n       while(it.hasNext()){\n           System.out.println(it.next());\n       }\n       \n    }\n}','Concurrency',0,0,NULL,5),(1999,'IndexOutofBoundsException \n\nthis can be confusing here the remove(int index) is being used. \n\nto fix do this\n\ncowlist.remove(new Integer(5));','public class Hello {\n    public static void main(String[] args){\n       CopyOnWriteArrayList<Integer> cowlist = new CopyOnWriteArrayList<>();\n       \n       cowlist.add(5);\n       cowlist.add(9);\n       cowlist.add(4);\n       \n       Iterator<Integer> it = cowlist.iterator();\n       \n       cowlist.remove(5);\n       \n       while(it.hasNext()){\n           System.out.println(it.next());\n       }\n       \n    }\n}','Concurrency',0,0,NULL,5),(2000,'add and remove. These are the only methods shown that modify the list','Which methods from copyonwritearraylist will cause a new copy of the internal\narray to be created\n\nadd\nget\niterator\nremove','Concurrency',0,0,NULL,5),(2001,'only put()','ArrayBlockingQueue<Integer> abq = new ArrayBlockingQueue<>(10);\n\nwhich operation can block indefinitely\n\nabq.add(1);\nabq.offer(1);\nabq.put(1);\nabq.offer(1,5,TimeUnit.SECONDS);','Concurrency',0,0,NULL,5),(2002,'IllegalStateEXception queue is full','public class Hello implements Runnable {\n    private static ArrayBlockingQueue<Integer> abq = new ArrayBlockingQueue<>(10);\n    public static void main(String[] args){\n       Hello h = new Hello();\n       Thread t1 = new Thread(h);\n       Thread t2 = new Thread(h);\n       Thread t3 = new Thread(h);\n       Thread t4 = new Thread(h);\n       \n       t1.start();\n       t2.start();\n       t3.start();\n       t4.start();\n       \n    }\n    public void run(){\n        for(int i = 0; i<5; i++){\n            abq.add(i);\n        }\n    }\n}','Concurrency',0,0,NULL,5),(2003,'true\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\nException in thread \"Thread-2\" java.lang.IllegalStateException: Queue full\n	at java.util.AbstractQueue.add(AbstractQueue.java:98)\n	at java.util.concurrent.ArrayBlockingQueue.add(ArrayBlockingQueue.java:312)\n	at hello.Hello.run(Hello.java:27)\n	at java.lang.Thread.run(Thread.java:745)\nException in thread \"Thread-3\" java.lang.IllegalStateException: Queue full\n	at java.util.AbstractQueue.add(AbstractQueue.java:98)\n	at java.util.concurrent.ArrayBlockingQueue.add(ArrayBlockingQueue.java:312)\n	at hello.Hello.run(Hello.java:27)\n	at java.lang.Thread.run(Thread.java:745)','public class Hello implements Runnable {\n    private static ArrayBlockingQueue<Integer> abq = new ArrayBlockingQueue<>(10);\n    public static void main(String[] args){\n       Hello h = new Hello();\n       Thread t1 = new Thread(h);\n       Thread t2 = new Thread(h);\n       Thread t3 = new Thread(h);\n       Thread t4 = new Thread(h);\n       \n       t1.start();\n       t2.start();\n       t3.start();\n       t4.start();\n       \n    }\n    public void run(){\n        for(int i = 0; i<5; i++){\n            System.out.println(abq.add(i));\n        }\n    }\n}','Concurrency',0,0,NULL,5),(2004,'offer() Inserts the specified element at the tail of this queue if \nit is possible to do so immediately \nwithout exceeding the queue\'s capacity, \nreturning true upon success and false if this queue is full. \nThis method is generally preferable to method add(E), which can fail to insert an element \nonly by throwing an exception.\n\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\nfalse\nfalse\nfalse\nfalse\nfalse\nfalse\nfalse\nfalse\nfalse\nfalse','public class Hello implements Runnable {\n    private static ArrayBlockingQueue<Integer> abq = new ArrayBlockingQueue<>(10);\n    public static void main(String[] args){\n       Hello h = new Hello();\n       Thread t1 = new Thread(h);\n       Thread t2 = new Thread(h);\n       Thread t3 = new Thread(h);\n       Thread t4 = new Thread(h);\n       \n       t1.start();\n       t2.start();\n       t3.start();\n       t4.start();\n       \n    }\n    public void run(){\n        for(int i = 0; i<5; i++){\n            System.out.println(abq.offer(i));\n        }\n    }\n}','Concurrency',0,0,NULL,5),(2005,'will not compile, .put() return void and blocks until space becomes available\n\n\'void\' is not allowed is sout();','public class Hello implements Runnable {\n    private static ArrayBlockingQueue<Integer> abq = new ArrayBlockingQueue<>(10);\n    public static void main(String[] args){\n       Hello h = new Hello();\n       Thread t1 = new Thread(h);\n       Thread t2 = new Thread(h);\n       Thread t3 = new Thread(h);\n       Thread t4 = new Thread(h);\n       \n       t1.start();\n       t2.start();\n       t3.start();\n       t4.start();\n       \n    }\n    public void run(){\n        for(int i = 0; i<5; i++){\n            System.out.println(abq.put(i));\n        }\n    }\n}','Concurrency',0,0,NULL,5),(2006,'Will not compile,\n\nput will block, therefore it may throw an interruptedException\n\nsurround with try catch','public class Hello implements Runnable {\n    private static ArrayBlockingQueue<Integer> abq = new ArrayBlockingQueue<>(10);\n    public static void main(String[] args){\n       Hello h = new Hello();\n       Thread t1 = new Thread(h);\n       Thread t2 = new Thread(h);\n       Thread t3 = new Thread(h);\n       Thread t4 = new Thread(h);\n       \n       t1.start();\n       t2.start();\n       t3.start();\n       t4.start();\n       \n    }\n    public void run(){\n        for(int i = 0; i<5; i++){\n            abq.put(i);\n        }\n    }\n}','Concurrency',0,0,NULL,5),(2007,'will run indefinitely, put will block until space becomes available, here \nit will never become available because there is no code removing objects','public class Hello implements Runnable {\n    private static ArrayBlockingQueue<Integer> abq = new ArrayBlockingQueue<>(10);\n    public static void main(String[] args){\n       Hello h = new Hello();\n       Thread t1 = new Thread(h);\n       Thread t2 = new Thread(h);\n       Thread t3 = new Thread(h);\n       Thread t4 = new Thread(h);\n       \n       t1.start();\n       t2.start();\n       t3.start();\n       t4.start();\n       \n    }\n    public void run(){\n        for(int i = 0; i<5; i++){\n            try{\n                abq.put(i);\n            } catch(InterruptedException e){}\n        }\n    }\n}','Concurrency',0,0,NULL,5),(2008,'peek() returns the head without removing it. returns null if empty\nThread-0removed element: 0\nThread-0removed element: 0\nThread-0removed element: 0\nThread-0removed element: 0\nThread-0removed element: 0\nThread-2removed element: 0\nThread-2removed element: 0\nThread-2removed element: 0\nThread-2removed element: 0\nThread-2removed element: 0\nThread-3removed element: 0\nThread-3removed element: 0\nThread-3removed element: 0\nThread-3removed element: 0\nThread-3removed element: 0\nThread-1removed element: 0\nThread-1removed element: 0\nThread-1removed element: 0\nThread-1removed element: 0\nThread-1removed element: 0\n','public class Hello implements Runnable {\n    private static ArrayBlockingQueue<Integer> abq = new ArrayBlockingQueue<>(10);\n    public static void main(String[] args){\n        for(int i = 0; i<10; i++)\n                abq.add(i);\n  \n       Hello h = new Hello();\n       Thread t1 = new Thread(h);\n       Thread t2 = new Thread(h);\n       Thread t3 = new Thread(h);\n       Thread t4 = new Thread(h);\n       \n       t1.start();\n       t2.start();\n       t3.start();\n       t4.start();\n       \n    }\n    public void run(){\n        for(int i = 0; i<5; i++){\n            System.out.println(Thread.currentThread().getName()+\"removed element: \"+abq.peek());\n        }\n        \n    }\n}','Concurrency',0,0,NULL,5),(2009,'','ArrayBlockingQueue<E>\n\nA bounded blocking queue backed by an array. \nThis queue orders elements FIFO (first-in-first-out). \nThe head of the queue is that element that has been on the queue the longest time. \nThe tail of the queue is that element that has been on the queue the shortest time. \nNew elements are inserted at the tail of the queue, and the queue retrieval operations obtain elements at the head of the queue.\n\nThis is a classic \"bounded buffer\", in which a fixed-sized array holds elements inserted by producers and extracted by consumers. \nOnce created, the capacity cannot be changed. Attempts to put an element into a full queue will result in the operation blocking; \nattempts to take an element from an empty queue will similarly block. ','Concurrency',0,0,NULL,5),(2010,'PutThread:Put One\nTakerThread:Retrieve using take\nTakerThread:take() returned One\nPutThread:Returned from put\n\nSyncQueue is used to make two threads meet up and hand off an object. \n\nBoth insertion and removal operations will block until the other thread\ndoes the inverse thus making the threads meet and exchange. ','public class Hello {\n    public static void main(String[] args){\n        SynchronousQueue<String> sq = new SynchronousQueue<String>();\n        Thread putThread = new Thread(new PutRunnable<String>(sq, \"One\"), \"PutThread\");\n        putThread.start();\n        Thread takerThread = new Thread(new TakerRunnable<String>(sq), \"TakerThread\");\n        takerThread.start();\n\n    }\n}\n\n class PutRunnable<T> implements Runnable {\n    private T value;\n    private SynchronousQueue<T> syncQ;\n    PutRunnable(SynchronousQueue<T> syncQ, T value) {\n        this.syncQ = syncQ;\n        this.value = value;\n    }\n    public void run() {\n        try {\n            PrintUtils.print(\"Put \" + value);\n            syncQ.put(value);\n            PrintUtils.print(\"Returned from put\");\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n \n}\nclass TakerRunnable<T> implements Runnable {\n    private T value;\n    private SynchronousQueue<T> syncQ;\n    TakerRunnable(SynchronousQueue<T> syncQ) {\n        this.syncQ = syncQ;\n    }\n    public void run() {\n        try {\n            PrintUtils.print(\"Retrieve using take\");\n            value = syncQ.take();\n            PrintUtils.print(\"take() returned \" + value);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n    public T getValue() {\n        return value;\n    }\n}\n\nclass PrintUtils {\n    public static void print(String s) {\n        System.out.println(Thread.currentThread().getName() + \":\" + s);\n    }\n}','Concurrency',0,0,NULL,5),(2011,'LinkedTranserQueue implements the BlockingQueue, TransferQueue, and Queue interfaces\n\nit is used here to demonstrate all the inserting and removing methods.','public class Hello {\n    \n    private static TransferQueue<Integer> tq = new LinkedTransferQueue<>();\n\n    public static void main(String[] args){\n        boolean b1 = tq.add(1); // true if added, IllegalStateException if full\n        \n        try{\n            //both of these throw interruptedExceptions because they block and wait\n            \n            tq.put(2);  //blocks if bounded or full\n        \n            tq.transfer(88); //blocks until element is consumed\n            \n        } catch(InterruptedException e){ }\n        \n        tq.tryTransfer(7); // returns true if consumed by the awaiting thread, or false without adding if there was no awaiting consumer.\n            // does not block therefore does not throw interruptedException\n        \n        try {\n            \n            //will wait the given time, blocking, then will return if not consumed\n            boolean b7 = tq.tryTransfer(99,10,TimeUnit.SECONDS);\n            \n        } catch(InterruptedException e){ }\n\n    }\n    \n    public static void methodsToRetrieve(){\n        Integer i1 = tq.element(); // gets without removing, throws NoSuchElementException if empty\n        \n        Integer i2 = tq.peek(); // gets without removing, null if empty\n        \n        Integer i3 = tq.poll(); //returns and removes the head, null if empty\n        \n        try{\n            Integer i4 = tq.poll(10,TimeUnit.MILLISECONDS); // removes the head, waits the specified time beffore returning null if empty\n        } catch(InterruptedException e) { }\n        \n        Integer i5 = tq.remove(); // removes the head of the queue throws NoSuchElementException if empty\n                \n        try{\n            Integer i6 = tq.take(); //removes the head blocks until an element is ready,\n        } catch(InterruptedException e) { }\n                \n    }','Concurrency',0,0,NULL,5),(2012,'will not compile, LinkedTransferQueue is not bounded and cannot be supplied with\na size argument','public class Hello {\n    \n    private static TransferQueue<Integer> tq = new LinkedTransferQueue<>(45);\n\n    public static void main(String[] args){\n        boolean b1 = tq.add(1); // true if added, IllegalStateException if full\n        \n        try{\n            //both of these throw interruptedExceptions because they block and wait\n            \n            tq.put(2);  //blocks if bounded or full\n        \n            tq.transfer(88); //blocks until element is consumed\n            \n        } catch(InterruptedException e){ }\n        \n        tq.tryTransfer(7); // returns true if consumed by the awaiting thread, or false without adding if there was no awaiting consumer.\n            // does not block therefore does not throw interruptedException\n        \n        try {\n            \n            //will wait the given time, blocking, then will return if not consumed\n            boolean b7 = tq.tryTransfer(99,10,TimeUnit.SECONDS);\n            \n        } catch(InterruptedException e){ }\n\n    }\n    \n    public static void methodsToRetrieve(){\n        Integer i1 = tq.element(); // gets without removing, throws NoSuchElementException if empty\n        \n        Integer i2 = tq.peek(); // gets without removing, null if empty\n        \n        Integer i3 = tq.poll(); //returns and removes the head, null if empty\n        \n        try{\n            Integer i4 = tq.poll(10,TimeUnit.MILLISECONDS); // removes the head, waits the specified time beffore returning null if empty\n        } catch(InterruptedException e) { }\n        \n        Integer i5 = tq.remove(); // removes the head of the queue throws NoSuchElementException if empty\n                \n        try{\n            Integer i6 = tq.take(); //removes the head blocks until an element is ready,\n        } catch(InterruptedException e) { }\n                \n    }','Concurrency',0,0,NULL,5),(2013,'will not compile, put and transfer block and wait, therefore they throw \nInterruptedExceptions','public class Hello {\n    \n    private static TransferQueue<Integer> tq = new LinkedTransferQueue<>();\n\n    public static void main(String[] args){\n        boolean b1 = tq.add(1); // true if added, IllegalStateException if full\n            \n        tq.put(2);  //blocks if bounded or full\n        \n        tq.transfer(88); //blocks until element is consumed\n        \n        tq.tryTransfer(7); // returns true if consumed by the awaiting thread, or false without adding if there was no awaiting consumer.\n            // does not block therefore does not throw interruptedException\n        \n        try {\n            \n            //will wait the given time, blocking, then will return if not consumed\n            boolean b7 = tq.tryTransfer(99,10,TimeUnit.SECONDS);\n            \n        } catch(InterruptedException e){ }\n\n    }\n    \n    public static void methodsToRetrieve(){\n        Integer i1 = tq.element(); // gets without removing, throws NoSuchElementException if empty\n        \n        Integer i2 = tq.peek(); // gets without removing, null if empty\n        \n        Integer i3 = tq.poll(); //returns and removes the head, null if empty\n        \n        try{\n            Integer i4 = tq.poll(10,TimeUnit.MILLISECONDS); // removes the head, waits the specified time beffore returning null if empty\n        } catch(InterruptedException e) { }\n        \n        Integer i5 = tq.remove(); // removes the head of the queue throws NoSuchElementException if empty\n                \n        try{\n            Integer i6 = tq.take(); //removes the head blocks until an element is ready,\n        } catch(InterruptedException e) { }\n                \n    }','Concurrency',0,0,NULL,5),(2014,'This shows the proper use of take() which will block until a book is available,\noffer is also properlyy used becaue it will only add if the queue is not full\nif it is it simply doesn\'t add it and doesn\'t throw an exception or anything.\n\nThis ones good try Topics of Destruction. Enjoy!\nMike chekced out Topics of Destruction\nThis ones good try War what is it good for. Enjoy!\nMax chekced out War what is it good for\nThis ones good try LOTR. Enjoy!\nPriebe chekced out LOTR\nThis ones good try Manson, the secret life. Enjoy!\nDom chekced out Manson, the secret life\nMike: Im done with Topics of Destruction here take it back!\nThis ones good try Topics of Destruction. Enjoy!\nMike chekced out Topics of Destruction\nPriebe: Im done with LOTR here take it back!\nThis ones good try LOTR. Enjoy!\nPriebe chekced out LOTR\nDom: Im done with Manson, the secret life here take it back!\nThis ones good try Manson, the secret life. Enjoy!\nDom chekced out Manson, the secret life\nMike: Im done with Topics of Destruction here take it back!\nThis ones good try Topics of Destruction. Enjoy!\nMike chekced out Topics of Destruction\nMax: Im done with War what is it good for here take it back!\nThis ones good try War what is it good for. Enjoy!\nMax chekced out War what is it good for\nPriebe: Im done with LOTR here take it back!\nThis ones good try LOTR. Enjoy!\nPriebe chekced out LOTR\nMike: Im done with Topics of Destruction here take it back!\nThis ones good try Topics of Destruction. Enjoy!\nMike chekced out Topics of Destruction\nPriebe: Im done with LOTR here take it back!\nThis ones good try LOTR. Enjoy!\nPriebe chekced out LOTR','public class Hello {\n    \n    public static void main(String[] args){\n        Library library = new Library();\n        \n        new Thread(library).start();\n        \n        new Thread(new Renter(library,\"Mike\")).start();\n        new Thread(new Renter(library,\"Max\")).start();\n        new Thread(new Renter(library,\"Priebe\")).start();\n        new Thread(new Renter(library,\"Dom\")).start();\n    }\n}\n\nclass Library implements Runnable{\n    private TransferQueue<Book> shelves = new LinkedTransferQueue<>();\n    \n    public Library() {\n        shelves.add(new Book(\"Topics of Destruction\"));\n        shelves.add(new Book(\"War what is it good for\"));\n        shelves.add(new Book(\"LOTR\"));\n        shelves.add(new Book(\"Manson, the secret life\"));\n    }\n    \n    public void run(){\n        while(true){ }\n    }\n    \n    public Book lend(){\n        \n        try {\n            Book book = shelves.take();\n            System.out.println(\"This ones good try \"+book.getName()+\". Enjoy!\");\n            return book;\n        } catch(InterruptedException e){ }\n        \n        return new Book(\"Free Library Pamphlet on plagarism\");\n    }\n    \n    public void accept(Book book){\n        shelves.offer(book);\n       \n    }\n}\n\nclass Renter implements Runnable {\n    private Library lib;\n    private String name;\n    public Renter(Library lib,String x){\n        name = x;\n        this.lib = lib;\n    }\n    public void run(){\n        while(true){\n            Book book = lib.lend();\n            System.out.println(name+\" chekced out \"+book.getName());\n            try{\n                Thread.sleep(ThreadLocalRandom.current().nextInt(1000,5000));\n            } catch(InterruptedException e) { }\n            \n            System.out.println(name+\": Im done with \"+book.getName()+\" here take it back!\");\n            lib.accept(book);\n        }\n    }\n}\n\n\nclass Book{\n    private String name;\n    public Book(String x ){\n        name = x;\n    }\n    \n    public String getName(){\n        return name;\n    }\n    \n}','Concurrency',0,0,NULL,5),(2015,'element() throws NoSuchElementException,\n\n','public class Hello {\n    \n    public static void main(String[] args){\n        Library library = new Library();\n        \n        new Thread(library).start();\n        \n        new Thread(new Renter(library,\"Mike\")).start();\n        new Thread(new Renter(library,\"Max\")).start();\n        new Thread(new Renter(library,\"Priebe\")).start();\n        new Thread(new Renter(library,\"Dom\")).start();\n    }\n}\n\nclass Library implements Runnable{\n    private TransferQueue<Book> shelves = new LinkedTransferQueue<>();\n    \n    public Library() {\n        shelves.add(new Book(\"Capulets and Montagues, the unknown link\"));\n        shelves.add(new Book(\"War What is it Good For\"));\n        shelves.add(new Book(\"Virtuous Villians\"));\n        shelves.add(new Book(\"Love in the Water\"));\n    }\n    \n    public void run(){\n        while(true){ }\n    }\n    \n    public Book lend(){\n        \n        try {\n            Book book = shelves.element();\n            System.out.println(\"This ones good try \"+book.getName()+\". Enjoy!\");\n            return book;\n        } catch(NoSuchElementException e){System.out.println(\"I\'m sorry sir we dont have that book right now\"); }\n        \n        return new Book(\"Free Library Pamphlet on plagarism\");\n    }\n    \n    public void accept(Book book){\n        shelves.offer(book);\n       \n    }\n}\n\nclass Renter implements Runnable {\n    private Library lib;\n    private String name;\n    public Renter(Library lib,String x){\n        name = x;\n        this.lib = lib;\n    }\n    public void run(){\n        while(true){\n            Book book = lib.lend();\n            System.out.println(name+\" chekced out \"+book.getName());\n            try{\n                Thread.sleep(ThreadLocalRandom.current().nextInt(1000,5000));\n            } catch(InterruptedException e) { }\n            \n            System.out.println(name+\": Im done with \"+book.getName()+\" here take it back!\");\n            lib.accept(book);\n        }\n    }\n}\n\nclass Book{\n    private String name;\n    public Book(String x ){\n        name = x;\n    }\n    \n    public String getName(){\n        return name;\n    }\n    \n}','Concurrency',0,0,NULL,5),(2016,'The same book keeps getting checked out because peek()\nreturns but does not remove the element\n\nThis ones good try Capulets and Montagues, the unknown link. Enjoy!\nMike chekced out Capulets and Montagues, the unknown link\nThis ones good try Capulets and Montagues, the unknown link. Enjoy!\nMax chekced out Capulets and Montagues, the unknown link\nThis ones good try Capulets and Montagues, the unknown link. Enjoy!\nPriebe chekced out Capulets and Montagues, the unknown link\nThis ones good try Capulets and Montagues, the unknown link. Enjoy!\nDom chekced out Capulets and Montagues, the unknown link\nDom: Im done with Capulets and Montagues, the unknown link here take it back!\nThis ones good try Capulets and Montagues, the unknown link. Enjoy!\nDom chekced out Capulets and Montagues, the unknown link\nMike: Im done with Capulets and Montagues, the unknown link here take it back!\nThis ones good try Capulets and Montagues, the unknown link. Enjoy!\nMike chekced out Capulets and Montagues, the unknown link\nPriebe: Im done with Capulets and Montagues, the unknown link here take it back!\nThis ones good try Capulets and Montagues, the unknown link. Enjoy!\nPriebe chekced out Capulets and Montagues, the unknown link\nMax: Im done with Capulets and Montagues, the unknown link here take it back!\nThis ones good try Capulets and Montagues, the unknown link. Enjoy!\nMax chekced out Capulets and Montagues, the unknown link\nDom: Im done with Capulets and Montagues, the unknown link here take it back!','public class Hello {\n    \n    public static void main(String[] args){\n        Library library = new Library();\n        \n        new Thread(library).start();\n        \n        new Thread(new Renter(library,\"Mike\")).start();\n        new Thread(new Renter(library,\"Max\")).start();\n        new Thread(new Renter(library,\"Priebe\")).start();\n        new Thread(new Renter(library,\"Dom\")).start();\n    }\n}\n\nclass Library implements Runnable{\n    private TransferQueue<Book> shelves = new LinkedTransferQueue<>();\n    \n    public Library() {\n        shelves.add(new Book(\"Capulets and Montagues, the unknown link\"));\n        shelves.add(new Book(\"War What is it Good For\"));\n        shelves.add(new Book(\"Virtuous Villians\"));\n        shelves.add(new Book(\"Love in the Water\"));\n    }\n    \n    public void run(){\n        while(true){ }\n    }\n    \n    public Book lend(){\n\n            Book book = shelves.peek();\n            System.out.println(\"This ones good try \"+book.getName()+\". Enjoy!\");\n        \n            if(book == null){\n                return new Book(\"Free Library Pamphlet on plagarism\");\n            } else {\n                return book;\n            }\n    }\n    \n    public void accept(Book book){\n        shelves.offer(book);\n       \n    }\n}\n\nclass Renter implements Runnable {\n    private Library lib;\n    private String name;\n    public Renter(Library lib,String x){\n        name = x;\n        this.lib = lib;\n    }\n    public void run(){\n        while(true){\n            Book book = lib.lend();\n            System.out.println(name+\" chekced out \"+book.getName());\n            try{\n                Thread.sleep(ThreadLocalRandom.current().nextInt(1000,5000));\n            } catch(InterruptedException e) { }\n            \n            System.out.println(name+\": Im done with \"+book.getName()+\" here take it back!\");\n            lib.accept(book);\n        }\n    }\n}\n\nclass Book{\n    private String name;\n    public Book(String x ){\n        name = x;\n    }\n    \n    public String getName(){\n        return name;\n    }\n    \n}','Concurrency',0,0,NULL,5),(2017,'does not compile, \n\nput() will block if there is no space available therefor it throws an\n\nInterruptedException','public class Hello {\n    \n    public static void main(String[] args){\n        Library library = new Library();\n        \n        new Thread(library).start();\n        \n        new Thread(new Renter(library,\"Mike\")).start();\n        new Thread(new Renter(library,\"Max\")).start();\n        new Thread(new Renter(library,\"Priebe\")).start();\n        new Thread(new Renter(library,\"Dom\")).start();\n    }\n}\n\nclass Library implements Runnable{\n    private TransferQueue<Book> shelves = new LinkedTransferQueue<>();\n    \n    public Library() {\n        shelves.add(new Book(\"Capulets and Montagues, the unknown link\"));\n        shelves.add(new Book(\"War What is it Good For\"));\n        shelves.add(new Book(\"Virtuous Villians\"));\n        shelves.add(new Book(\"Love in the Water\"));\n    }\n    \n    public void run(){\n        while(true){ }\n    }\n    \n    public Book lend(){\n\n            Book book = shelves.poll();\n            System.out.println(\"This ones good try \"+book.getName()+\". Enjoy!\");\n        \n            if(book == null){\n                return new Book(\"Free Library Pamphlet on plagarism\");\n            } else {\n                return book;\n            }\n    }\n    \n    public void accept(Book book){\n        shelves.put(book);\n       \n    }\n}\n\nclass Renter implements Runnable {\n    private Library lib;\n    private String name;\n    public Renter(Library lib,String x){\n        name = x;\n        this.lib = lib;\n    }\n    public void run(){\n        while(true){\n            Book book = lib.lend();\n            System.out.println(name+\" chekced out \"+book.getName());\n            try{\n                Thread.sleep(ThreadLocalRandom.current().nextInt(1000,5000));\n            } catch(InterruptedException e) { }\n            \n            System.out.println(name+\": Im done with \"+book.getName()+\" here take it back!\");\n            lib.accept(book);\n        }\n    }\n}\n\nclass Book{\n    private String name;\n    public Book(String x ){\n        name = x;\n    }\n    \n    public String getName(){\n        return name;\n    }\n    \n}','Concurrency',0,0,NULL,5),(2018,'take()','Which BlockingCollection method will block if needed until an object becomes\navailabel','Concurrency',0,0,NULL,5),(2019,'element()','Which BlockingCollection method throws nosuchelementexception','Concurrency',0,0,NULL,5),(2020,'add()','Which BlockingQueue method throws an illegalstateexception if the queueu is bounded and full ? ','Concurrency',0,0,NULL,5),(2021,'offer() and offer(e, long timeout, timeunit)','Whic BlockingQueue method returns true if it was added and false if \nthe queueu was full but also provides a timeout overloaded option','Concurrency',0,0,NULL,5),(2022,'','','blank',0,0,NULL,5),(2023,'String43\nString7\n43\n7\n53\n2','	String a = \"String\";\n        int b = 4;\n        int c = 3;\n        System.out.println(a+b+c);\n        System.out.println(a+(b+c));\n        System.out.println(\"\" + b + 3);\n        System.out.println(b+3);\n        System.out.println(++b + \"\" + c--);\n        System.out.println(c);','Strings',0,0,NULL,5),(2024,'','','blank',0,0,NULL,5),(2025,'Cached thread pools will create new threads as needed and reuse threads that \nhave become free. Thread that have been idle for 60 seconds are removed.\n\nCan create more threads than system can handle so watch out. ','ExecutorService ex = Executors.newCachedThreadPool();','Executors',0,0,NULL,5),(2026,'constructed with an int argument that specifies the number of threads to use\nto execute the tasks. Most common. Prevents system from being overloaded\nwith too many threads. \n\nBase number of threads on some kind of system resource. \n\nuse java.lang.Runtime\n\nRuntime rt = Runtime.getRuntime();\nint cpus = rt.availabeProcessors();','ExecutorService ex = Executors.newFixedThreadPool(4);\n','Executors',0,0,NULL,5),(2027,'ThreadPoolExecutor tpe = (ThreadPoolExecutor) Executors.newFixedThreadPool(4);\ntpe.setCorePoolSize(8);\ntpe.setMaximumPoolSize(8);','How to adust the thread count of a pool at runtime\n\n','Executors',0,0,NULL,5),(2028,'        ExecutorService ex = Executors.newSingleThreadExecutor(); \n\nwil not compile, it is singlethreadexecutor not singlethreadPool\n\n**Also you shutdown the ExecutorService not the Future!','public class Hello {\n    public static void main(String[] args){\n        ExecutorService ex = Executors.newSingleThreadPool();\n\n        Future<Integer> futint = ex.submit(new FileCounter());\n        \n        System.out.println(\"Do other things while the files are getting counted\");\n        \n        try{\n            int count = futint.get();\n            System.out.println(count);\n            futint.shutdown();\n        }catch(ExecutionException | InterruptedException e){\n            \n        }\n        \n    }\n    \n    \n}\n\nclass FileCounter implements Callable<Integer>{\n    private int fileCount = 0;\n    public Integer call() throws IOException{\n        fileCount = count(Paths.get(\"/home/maxbisesi/Documents\"));\n        return fileCount; \n    }\n    \n    public Integer count(Path d) throws IOException {\n        int count = 0;\n	try(DirectoryStream<Path> stream = Files.newDirectoryStream(d)){\n		for(Path path: stream){\n			count++;\n		}\n	}\n        return count;\n    }\n}','Executors',0,0,NULL,5),(2029,'','Scheduled Thread pool:\n	scheduled after a delay or at repeating intervals\n\npublic class Hello {\n    \n    public static void main(String[] args){\n     ScheduledExecutorService ftses = Executors.newScheduledThreadPool(4);\n     \n     ftses.schedule(r, 5, TimeUnit.SECONDS); //run once after a delay\n     \n     ftses.scheduleAtFixedRate(r, 2,5,TimeUnit.SECONDS); //begin after 2 sec delay and begin again every 5\n     \n     ftses.scheduleWithFixedDelay(r, 2, 5, TimeUnit.SECONDS); //begin after 2 sec delay and again 5 seconds after the last exection\n}','Executors',0,0,NULL,5),(2030,'Callable and Runnable','an ExecutorService can take what two kinds of objects ?','Executors',0,0,NULL,5),(2031,'being able to return a result','What is the primary benifit of using a Callable ?','Executors',0,0,NULL,5),(2032,'InterruptedException and ExecutionException','submitting a Callable to an ExecutorService returns a Future reference.\n\nwhat are two possible exceptions that could result ?','Executors',0,0,NULL,5),(2033,'raised when an exception was thrown during the execution of the callable\'s\ncall()','ExecutionException','Executors',0,0,NULL,5),(2034,'When a callable task is submitted to an executor the task will go run,\ncalling for its return value will block until it is done so otherwise go on \nwith your program until you are ready to use that result. In this code the rest\nof main is executed only after the future is returned.\nrunning...1\nrunning...2\nrunning...3\nrunning...4\nrunning...5\nrunning...6\nrunning...7\nrunning...8\nrunning...9\nrunning...10\nRan: 10\nmain: 0\nmain: 1\nmain: 2\nmain: 3\nmain: 4\nmain: 5\nmain: 6\nmain: 7\nmain: 8\nmain: 9\n','public class Hello {\n    \n    public static void main(String[] args){\n        Callable<Integer> c = new LoopCounter();\n        \n        ExecutorService ex = Executors.newCachedThreadPool();\n        \n        Future<Integer> f = ex.submit(c); //finishes in the future\n        \n        try{\n            Integer v = f.get(); // will block until done\n            System.out.println(\"Ran: \" + v);\n        } catch(InterruptedException | ExecutionException iex){\n            System.out.println(\"Failed\");\n        }\n        \n        for(int i = 0; i<10; i++){\n            System.out.println(\"main: \"+ i);\n        }\n    }\n}\n\nclass LoopCounter implements Callable<Integer> {\n    \n    public Integer call(){\n        int count = ThreadLocalRandom.current().nextInt(1,11);\n        for(int i = 1; i <= count; i++){\n                System.out.println(\"running...\" + i);\n        }\n        return count;\n    }\n}','Executors',0,0,NULL,5),(2035,'got it ','Using Executors takes away the need for synchronization, waiting, joining and \nnotifying','Executors',0,0,NULL,5),(2036,'The program will complete normally, without shutdown() it would continue to run,\nit is best to shutdown an executor service in order to free up threads.','public class Hello {\n    \n    public static void main(String[] args){\n        Callable<Integer> c = new LoopCounter();\n        \n        ExecutorService ex = Executors.newCachedThreadPool();\n        \n        Future<Integer> f = ex.submit(c); //finishes in the future\n        \n        try{\n            Integer v = f.get(); // will block until done\n            System.out.println(\"Ran: \" + v);\n        } catch(InterruptedException | ExecutionException iex){\n            System.out.println(\"Failed\");\n        }\n        \n        for(int i = 0; i<10; i++){\n            System.out.println(\"main: \"+ i);\n        }\n        \n        ex.shutdown();\n    }\n}\n\nclass LoopCounter implements Callable<Integer> {\n    \n    public Integer call(){\n        int count = ThreadLocalRandom.current().nextInt(1,11);\n        for(int i = 1; i <= count; i++){\n                System.out.println(\"running...\" + i);\n        }\n        return count;\n    }\n}','Executors',0,0,NULL,5),(2037,'','ExecutorService ex = ...\n//......\n\nex.shutdown(); // no more new tasks but finish existing tasks\n\ntry{\n	boolean term = ex.awaitTermination(2,TimeUnit.SECONDS);\n		//wait two seconds for running tasks to finsish\n} catch(InterruptedException ex) {\n	//did not wait full two seconds\n} finally {\n   if(!ex.isTerminated()) // are all tasks done ?\n   {\n	List<Runnable> unfinished = ex.shutdownNow();\n		// a collection of unfished tasks\n   }\n}','Executors',0,0,NULL,5),(2038,'breaks a big task down into smaller parts\n\n','class RandomInitRA extends RecursiveAction {\n    private static final int THRESHOLD = 10000;\n    private int[] data;\n    private int start;\n    private int end;\n    \n    public RandomInitRA(int[] data, int start, int end) {\n        this.data = data;\n        this.start = start;\n        this.end = end;\n    }\n    \n    protected void compute() {\n        if(end - start <= THRESHOLD) {\n            // if this is a manageable amount of work do the task\n            for(int i = start; i<end; i++){\n                data[i] = ThreadLocalRandom.current().nextInt();\n            }\n        } else { //task too big\n            int halfway = ((end - start) / 2) + start;\n            RandomInitRA a1 = new RandomInitRA(data,start,halfway);\n            a1.fork();\n            RandomInitRA a2 = new RandomInitRA(data,halfway,end);\n            a2.compute();\n            a1.join();\n        }\n    }\n}','Executors',0,0,NULL,5),(2039,'use invokeAll instead of the fork join compute, \nRecursiveAction does not reutrn a value so you should not excpect a value\nfrom invoke all. ','class RandomInitRA extends RecursiveAction {\n    private static final int THRESHOLD = 10000;\n    private int[] data;\n    private int start;\n    private int end;\n    \n    public RandomInitRA(int[] data, int start, int end) {\n        this.data = data;\n        this.start = start;\n        this.end = end;\n    }\n    \n    protected void compute() {\n        if(end - start <= THRESHOLD) {\n            // if this is a manageable amount of work do the task\n            for(int i = start; i<end; i++){\n                data[i] = ThreadLocalRandom.current().nextInt();\n            }\n        } else { //task too big\n            int halfway = ((end - start) / 2) + start;\n            RandomInitRA a1 = new RandomInitRA(data,start,halfway);\n            RandomInitRA a2 = new RandomInitRA(data,halfway,end);\n            invokeAll(a1,a2);\n        }\n    }\n}','Executors',0,0,NULL,5),(2040,'will not compile, return type of compute from RecursiveAction is void as\nRAs do not return values. ','class RandomInitRA extends RecursiveAction {\n    private static final int THRESHOLD = 10000;\n    private int[] data;\n    private int start;\n    private int end;\n    \n    public RandomInitRA(int[] data, int start, int end) {\n        this.data = data;\n        this.start = start;\n        this.end = end;\n    }\n    \n    protected int compute() {\n        if(end - start <= THRESHOLD) {\n            // if this is a manageable amount of work do the task\n            for(int i = start; i<end; i++){\n                data[i] = ThreadLocalRandom.current().nextInt();\n            }\n        } else { //task too big\n            int halfway = ((end - start) / 2) + start;\n            RandomInitRA a1 = new RandomInitRA(data,start,halfway);\n            RandomInitRA a2 = new RandomInitRA(data,halfway,end);\n            invokeAll(a1,a2);\n        }\n    }\n}','Executors',0,0,NULL,5),(2041,'int[] data = new int[10_000_000];\nForkJoinPool fjpool = new ForkJoinPool();\nRandomInitRA ra = new RandomInitRA(data,0,data.length);\n        \nfjpool.invoke(ra);','public class Hello{\n    public static void main(String[]  args){\n        \n        \n        \n    }\n}\n \nclass RandomInitRA extends RecursiveAction {\n    private static final int THRESHOLD = 10000;\n    private int[] data;\n    private int start;\n    private int end;\n    \n    public RandomInitRA(int[] data, int start, int end) {\n        this.data = data;\n        this.start = start;\n        this.end = end;\n    }\n    \n    protected void compute() {\n        if(end - start <= THRESHOLD) {\n            // if this is a manageable amount of work do the task\n            for(int i = start; i<end; i++){\n                data[i] = ThreadLocalRandom.current().nextInt();\n            }\n        } else { //task too big\n            int halfway = ((end - start) / 2) + start;\n            RandomInitRA a1 = new RandomInitRA(data,start,halfway);\n            RandomInitRA a2 = new RandomInitRA(data,halfway,end);\n            invokeAll(a1,a2);\n        }\n    }\n}\n\n//given that the task of this RA is to fill a big array with random numbers\n// how would you start it in main given int[] data = new int[10_000_000];','Executors',0,0,NULL,5),(2042,'the forkjoinpool method is invoke() not invokeAll()\n\nit should be:\n\n	fjpool.invoke(ra);\n\nThere is an invokeAll() but it takes a collection of callable and returns \na list of futures. \n\nnotice too that it doesn\'t return a value, technically it is of type Void, and\nnull is the only valid type for Void','public class Hello{\n    public static void main(String[]  args){\n        int[] data = new int[10_000_000];\n        ForkJoinPool fjpool = new ForkJoinPool();\n        RandomInitRA ra = new RandomInitRA(data,0,data.length);\n        \n        fjpool.invokeAll(ra);\n    }\n}\n \nclass RandomInitRA extends RecursiveAction {\n    private static final int THRESHOLD = 10000;\n    private int[] data;\n    private int start;\n    private int end;\n    \n    public RandomInitRA(int[] data, int start, int end) {\n        this.data = data;\n        this.start = start;\n        this.end = end;\n    }\n    \n    protected void compute() {\n        if(end - start <= THRESHOLD) {\n            // if this is a manageable amount of work do the task\n            for(int i = start; i<end; i++){\n                data[i] = ThreadLocalRandom.current().nextInt();\n            }\n        } else { //task too big\n            int halfway = ((end - start) / 2) + start;\n            RandomInitRA a1 = new RandomInitRA(data,start,halfway);\n            RandomInitRA a2 = new RandomInitRA(data,halfway,end);\n            invokeAll(a1,a2);\n        }\n    }\n}','Executors',0,0,NULL,5),(2043,'RecursiveAction RecursiveTask','Two subclasses of ForkJoinTask<V>','Executors',0,0,NULL,5),(2044,'this will compile \n\nan overriden method CAN have less restrive access, but not more restrictive.\n\ncompute() is protected in abstract class','class RandomInitRA extends RecursiveAction {\n    private static final int THRESHOLD = 10000;\n    private int[] data;\n    private int start;\n    private int end;\n    \n    public RandomInitRA(int[] data, int start, int end) {\n        this.data = data;\n        this.start = start;\n        this.end = end;\n    }\n    \n    public void compute() {\n        if(end - start <= THRESHOLD) {\n            // if this is a manageable amount of work do the task\n            for(int i = start; i<end; i++){\n                data[i] = ThreadLocalRandom.current().nextInt();\n            }\n        } else { //task too big\n            int halfway = ((end - start) / 2) + start;\n            RandomInitRA a1 = new RandomInitRA(data,start,halfway);\n            RandomInitRA a2 = new RandomInitRA(data,halfway,end);\n            invokeAll(a1,a2);\n        }\n    }\n}','Executors',0,0,NULL,5),(2045,'','','Executors',0,0,NULL,5),(2046,'will not compile an overriden method CAN have more restrictive access but not \nless. private is less than public.','class RandomInitRA extends RecursiveAction {\n    private static final int THRESHOLD = 10000;\n    private int[] data;\n    private int start;\n    private int end;\n    \n    public RandomInitRA(int[] data, int start, int end) {\n        this.data = data;\n        this.start = start;\n        this.end = end;\n    }\n    \n    private void compute() {\n        if(end - start <= THRESHOLD) {\n            // if this is a manageable amount of work do the task\n            for(int i = start; i<end; i++){\n                data[i] = ThreadLocalRandom.current().nextInt();\n            }\n        } else { //task too big\n            int halfway = ((end - start) / 2) + start;\n            RandomInitRA a1 = new RandomInitRA(data,start,halfway);\n            RandomInitRA a2 = new RandomInitRA(data,halfway,end);\n            invokeAll(a1,a2);\n        }\n    }\n}','Executors',0,0,NULL,5),(2047,'will not compile, an overriden method cannot have more restrictive access\ndefault is more restrictive than protected.','class RandomInitRA extends RecursiveAction {\n    private static final int THRESHOLD = 10000;\n    private int[] data;\n    private int start;\n    private int end;\n    \n    public RandomInitRA(int[] data, int start, int end) {\n        this.data = data;\n        this.start = start;\n        this.end = end;\n    }\n    \n    void compute() {\n        if(end - start <= THRESHOLD) {\n            // if this is a manageable amount of work do the task\n            for(int i = start; i<end; i++){\n                data[i] = ThreadLocalRandom.current().nextInt();\n            }\n        } else { //task too big\n            int halfway = ((end - start) / 2) + start;\n            RandomInitRA a1 = new RandomInitRA(data,start,halfway);\n            RandomInitRA a2 = new RandomInitRA(data,halfway,end);\n            invokeAll(a1,a2);\n        }\n    }\n}','Executors',0,0,NULL,5),(2048,'RecursiveTask<V> returns a value\n\nfor this particular example you should initialize the array with random \nnumber using RandomInitRecursiveAction that doesn\'t return a result. \n\npublic static void main(String[] args) {\n        int[] bigdata = new int[20000];\n        ForkJoinPool fj = new ForkJoinPool();\n        FindMaxPosition fmp = new FindMaxPosition(bigdata,0,bigdata.length);\n        Integer i = fj.invoke(fmp);\n        \n    }','class FindMaxPosition extends RecursiveTask<Integer> {\n     private static final int THRESHOLD = 10000;\n    private int[] data;\n    private int start;\n    private int end;\n    \n    public FindMaxPosition(int[] data, int start, int end) {\n        this.data = data;\n        this.start = start;\n        this.end = end;\n    }\n    \n    public Integer compute() {\n        if (end - start <= THRESHOLD){\n            int position = 0;\n            for(int i = start; i < end; i++){\n                 if(data[i] > data[position]) {\n                     position = i;\n                 }\n            }\n            \n            return position;\n        } else { //task is too big, split it\n            int halfway = ((end - start) / 2) + start;\n            FindMaxPosition p1 = new FindMaxPosition(data,start,halfway);\n            p1.fork();\n            FindMaxPosition p2 = new FindMaxPosition(data,start,halfway);\n            int pos2 = p2.compute();\n            int pos1 = p1.join();\n            \n            //these forked tasks found the greatest value in their subsections now compare the two results \n            \n            if(data[pos1] > data[pos2]) {\n                return pos1;\n            } else if(data[pos1] < data[pos2]){\n                return pos2;\n            } else {\n                return pos1 < pos2 ? pos1 : pos2;\n            }\n        }\n        \n    }\n}','Executors',0,0,NULL,5),(2049,'This will create an array of 10000000 elements then, find the biggest value in it\n','public class Hello{\n    public static void main(String[]  args){\n        int[] data = new int[10_000_000];\n        ForkJoinPool fjpool = new ForkJoinPool();\n        RandomInitRA ra = new RandomInitRA(data,0,data.length);\n        fjpool.invoke(ra);\n        \n        FindMaxPosition task = new FindMaxPosition(data,0,data.length);\n        Integer position = fjpool.invoke(task);\n        System.out.println(\"Bigggest value:;\"+ data[position]);\n    }\n}\n\nclass FindMaxPosition extends RecursiveTask<Integer> {\n     private static final int THRESHOLD = 10000;\n    private int[] data;\n    private int start;\n    private int end;\n    \n    public FindMaxPosition(int[] data, int start, int end) {\n        this.data = data;\n        this.start = start;\n        this.end = end;\n    }\n    \n    public Integer compute() {\n        if (end - start <= THRESHOLD){\n            int position = 0;\n            for(int i = start; i < end; i++){\n                 if(data[i] > data[position]) {\n                     position = i;\n                 }\n            }\n            \n            return position;\n        } else { //task is too big, split it\n            int halfway = ((end - start) / 2) + start;\n            FindMaxPosition p1 = new FindMaxPosition(data,start,halfway);\n            p1.fork();\n            FindMaxPosition p2 = new FindMaxPosition(data,start,halfway);\n            int pos2 = p2.compute();\n            int pos1 = p1.join();\n            \n            //these forked tasks found the greatest value in their subsections now compare the two results \n            \n            if(data[pos1] > data[pos2]) {\n                return pos1;\n            } else if(data[pos1] < data[pos2]){\n                return pos2;\n            } else {\n                return pos1 < pos2 ? pos1 : pos2;\n            }\n        }\n        \n    }\n}\n \nclass RandomInitRA extends RecursiveAction {\n    private static final int THRESHOLD = 10000;\n    private int[] data;\n    private int start;\n    private int end;\n    \n    public RandomInitRA(int[] data, int start, int end) {\n        this.data = data;\n        this.start = start;\n        this.end = end;\n    }\n    \n    protected void compute() {\n        if(end - start <= THRESHOLD) {\n            // if this is a manageable amount of work do the task\n            for(int i = start; i<end; i++){\n                data[i] = ThreadLocalRandom.current().nextInt();\n            }\n        } else { //task too big\n            int halfway = ((end - start) / 2) + start;\n            RandomInitRA a1 = new RandomInitRA(data,start,halfway);\n            RandomInitRA a2 = new RandomInitRA(data,halfway,end);\n            invokeAll(a1,a2);\n        }\n    }\n}','Executors',0,0,NULL,5),(2050,'ages.remove(\"John\",23);\n\npublic boolean remove(Object key,\n             Object value)\n\nRemoves the entry for a key only if currently mapped to a given value. This is equivalent to\n\n   if (map.containsKey(key) && map.get(key).equals(value)) {\n       map.remove(key);\n       return true;\n   } else return false;\n\nexcept that the action is performed ATOMICALLY.\n\nThere is another remove method that comes from the map Interface...\nthat is the standard remove function.\n\npublic V remove(Object key)\n\nRemoves the key (and its corresponding value) from this map. This method does nothing if the key is not in the map.\n\nSpecified by:\n    remove in interface Map<K,V>\nOverrides:\n    remove in class AbstractMap<K,V>\nParameters:\n    key - the key that needs to be removed\nReturns:\n    the previous value associated with key, or null if there was no mapping for key','ConcurrentMap<String,Integer> ages = new ConcurrentHashMap<>();\nages.put(\"John\",23);\n\nWhich method would delete Joh from the map only if his value was still equal \nto 23','Concurrency',0,0,NULL,5),(2051,'i.addAndGet(9);\ni.getAndAdd(9);','AtomicInteger i = new AtomicInteger();\ntwo methods to atomically increment by 9?','Concurrency',0,0,NULL,5),(2052,'only one thread at a time can access the write lock where multiple threads\ncan access the readLock','class LeaderBoard {\n    private ReadWriteLock rwl = new ReentrantReadWriteLock();\n    private List<Integer> highScores = new ArrayList<Integer>();\n    public void addScore(Integer score){\n        Lock lock = rwl.writeLock();\n        lock.lock();\n        \n        try{\n            if(highScores.size() < 10) {\n                highScores.add(score);\n            } else if(highScores.get(highScores.size() - 1) < score) {\n                highScores.set(highScores.size() - 1, score);\n            } else {\n                return;\n            }\n            \n            Collections.sort(highScores,Collections.reverseOrder());\n        } finally{\n            lock.unlock();\n        }\n    }\n    \n    public List getHighScores(){\n        Lock lock = rwl.readLock();\n        lock.lock();\n        try{\n            return Collections.unmodifiableList(highScores);\n        } finally {\n            lock.unlock();\n        }\n    }\n}','Concurrency',0,0,NULL,5),(2053,'IllegalMonitorStateExcetion rwl.writeLock() was not locked before it was unloked\n','public class Hello {\n\n    public static void main(String[] args) {\n       LeaderBoard lb = new LeaderBoard();\n       lb.addScore(56);\n    }\n    \n}\n\nclass LeaderBoard {\n    private ReadWriteLock rwl = new ReentrantReadWriteLock();\n    private List<Integer> highScores = new ArrayList<Integer>();\n    public void addScore(Integer score){\n        Lock lock = rwl.writeLock();\n        \n        try{\n            if(highScores.size() < 10) {\n                highScores.add(score);\n            } else if(highScores.get(highScores.size() - 1) < score) {\n                highScores.set(highScores.size() - 1, score);\n            } else {\n                return;\n            }\n            \n            Collections.sort(highScores,Collections.reverseOrder());\n        } finally{\n            lock.unlock();\n        }\n    }\n    \n    public List getHighScores(){\n        Lock lock = rwl.readLock();\n        lock.lock();\n        try{\n            return Collections.unmodifiableList(highScores);\n        } finally {\n            lock.unlock();\n        }\n    }\n}','Concurrency',0,0,NULL,5),(2054,'compiles fine, The writeLock is locked but never unlocked,that will not throw\nan exception.','public class Hello {\n\n    public static void main(String[] args) {\n       LeaderBoard lb = new LeaderBoard();\n       lb.addScore(5);\n    }\n    \n}\n\nclass LeaderBoard {\n    private ReadWriteLock rwl = new ReentrantReadWriteLock();\n    private List<Integer> highScores = new ArrayList<Integer>();\n    public void addScore(Integer score){\n        Lock lock = rwl.writeLock();\n        lock.lock();\n        try{\n            if(highScores.size() < 10) {\n                highScores.add(score);\n            } else if(highScores.get(highScores.size() - 1) < score) {\n                highScores.set(highScores.size() - 1, score);\n            } else {\n                return;\n            }\n            \n            Collections.sort(highScores,Collections.reverseOrder());\n        } finally{\n\n        }\n    }\n    \n    public List getHighScores(){\n        Lock lock = rwl.readLock();\n        lock.lock();\n        try{\n            return Collections.unmodifiableList(highScores);\n        } finally {\n            lock.unlock();\n        }\n    }\n}','Concurrency',0,0,NULL,5),(2055,'Thread-0 []\nThread-2 []\nThread-1 []\n... and will keep running\n\nsince the readlock is never unlocked() in getHighScores() the three threads will\nacquire the read lock but never release it. \n\nThat will prevent any of them from getting the write lock. RRWL allows multiple\nthreads to read at the same time but will wait for an exclusive lock before\nallowing threads to write to it. meaning no other thread can be reading while\nanother thread is writing to the locked object!','public class Hello {\n\n    public static void main(String[] args) {\n       LeaderBoard lb = new LeaderBoard();\n       Player a = new Player(lb);\n       Player b = new Player(lb);\n       Player c = new Player(lb);\n       \n       a.start();\n       b.start();\n       c.start();\n    }\n    \n}\n\nclass LeaderBoard {\n    private ReadWriteLock rwl = new ReentrantReadWriteLock();\n    private List<Integer> highScores = new ArrayList<Integer>();\n    public void addScore(Integer score){\n        Lock lock = rwl.writeLock();\n        lock.lock();\n        try{\n            if(highScores.size() < 10) {\n                highScores.add(score);\n            } else if(highScores.get(highScores.size() - 1) < score) {\n                highScores.set(highScores.size() - 1, score);\n            } else {\n                return;\n            }\n            \n            Collections.sort(highScores,Collections.reverseOrder());\n        } finally{\n            lock.unlock();\n        }\n    }\n    \n    public List getHighScores(){\n        Lock lock = rwl.readLock();\n        lock.lock();\n        try{\n            return Collections.unmodifiableList(highScores);\n        } finally {\n\n        }\n    }\n}\n\nclass Player extends Thread {\n    private LeaderBoard lb;\n    public Player(LeaderBoard x){\n        lb = x;\n        \n    }\n    public void run(){\n        System.out.println(Thread.currentThread().getName()+\" \"+lb.getHighScores());\n        for(int i = 0; i<3; i++){\n            postHighScore();\n        }    \n    }\n    \n    public void postHighScore(){\n        lb.addScore(ThreadLocalRandom.current().nextInt());\n    }\n}\n','Concurrency',0,0,NULL,5),(2056,'\n\nFirst, InputStreamReader can handle all input streams, not just files. Other examples are network connections, classpath resources and ZIP files.\n\nSecond, FileReader does not allow you to specify an encoding and instead uses the plaform default encoding, which makes it pretty much useless as using it will result in corrupted data when the code is run on systems with different platform default encodings.\n\nIn short, forget that FileReader exists.\n','I can\'t seem to determine any difference between InputStreamReader and FileReader besides the way the two are initialized. \nIs there any benefit to using one or the other? \nMost other articles cover FileInputStream vs InputStreamReader, but I am contrasting with FileReader instead. \nSeems to me they both have the same purpose.','General',0,0,NULL,5),(2057,'-This is impossible to do.\n The reason to not include it, is the wide range of input types it supports. One example is streams. These don\'t store the results after they have been passed on,\n so they don\'t support resetting.\n So the elegant way is to create a new Scanner. \n If you give it many custom settings, create a factory method.\n\n-There is no \"counter\" in the Scanner object. \n Instead think of it as more like a conveyor belt. \n The belt has no knowledge or care about what\'s on it. \n It just keeps spitting things out at you while there are items left on it. \n And once you take them, they\'re gone from it for good.\n','while (scanNumOfLines.hasNextLine())    \n    {\n    NumOfLines ++;\n    scanNumOfLines.nextLine();\n    }\n    System.out.println(\"NumOfLines = \"+NumOfLines);\n\nSo it counts fine, but I want to re-use the scanner for another purpose, but the nextLine has moved to the last line of the file, and I want to reset it back to the first line.\n\n(Instead, I had to use another scanner for the other purpose, and to me this seems less elegant than it should be.)\n\nI\'m sure there must be a scanner method that resets the counter to zero?','General',0,0,NULL,5),(2058,'- \n\nAs a formal method parameter is a local variable, you can access them from inner anonymous classes only if they are declared as final.\n\nThis saves you from declaring another local final variable in the method body:\n\n void m(final int param) {\n        new Thread(new Runnable() {\n            public void run() {\n                System.err.println(param);\n            }\n        }).start();\n    }\n\n\n\n\n- final is used here to ensure the two indexes i and j won\'t accidentally be reset by the method. It\'s a handy way to protect against an insidious bug that erroneously changes the value of your parameters. \nGenerally speaking, short methods are a better way to protect from this class of errors,\nbut final parameters can be a useful addition to your coding style.\nNote that final parameters are not considered part of the method signature, and are ignored by the compiler when resolving method calls. Parameters can be declared final (or not) with no influence on how the method is overriden.\n\n-Might be better to use objects rather than primitives for this example, as primitive changes will always only be visible inside the method. \nAnd in the case of objects, you can still change them. You just can\'t point at a new object. In fact now I think about it, final doesn\'t really change anything \ncompared to leaving it out, other than saving a variable declaration with AICs and having the compiler point out accidental modifications of parameters that \nyou didn\'t want to modify for some reason.\n\n\n\nThe final prevents you from assining a new value to the variable, and this can be helpful in catching typos. \nStylistically you might like to keep the parameters received unchanged and assign only to local variables, \nso final would help to enforce that style.\n\npublic int example(final int basicRate){\n    int discountRate;\n\n    discountRate = basicRate - 10;\n    // ... lots of code here \n    if ( isGoldCustomer ) {\n        basicRate--;  // typo, we intended to say discountRate--, final catches this\n    }\n    // ... more code here\n\n    return discountRate;\n}\n\n','What difference that final makes between the code below. Is there any advantage in declaring the arguments as final.\n\npublic String changeTimezone( Timestamp stamp, Timezone fTz, Timezone toTz){  \n    return ....\n}\n\npublic String changeTimezone(final Timestamp stamp, final Timezone fTz, \n        final Timezone toTz){\n    return ....\n}\n\n','General',0,0,NULL,5),(2059,'compiles fine','abstract class A {\n    public abstract void foo(final String s);\n}\n\nclass B extends A {\n    public void foo(String x){\n        System.out.println(x);\n    }\n}','General',0,0,NULL,5),(2060,'only the first,\n\nthe only argument constructor for cachedthreadpool takes a threadfactory.\n\na fixed thread pool has to have a size.','Executor ex = Executors.newFixedThreadPool(9);\nExecutor ex2 = Executors.newFixedThreadPool();\nExecutor ex3 = Executor.newFixedThreadPool(9);\nExecutor ex4 = Executors.newCachedThreadPool(7);\n\nwhich can compile ?','Executors',0,0,NULL,5),(2061,'will not compile, unreported exception ExecutionException thrown by .get()','private Integer executeTask (ExecutorService service, Callable<Integer> task){\n        try{\n            Future<Integer> future = service.submit(task);\n            return future.get();\n        } catch(InterruptedException e){\n            return null;\n        }\n    }','Executors',0,0,NULL,5),(2062,'will not compile, unreported Exeption InterruptedException thrown by .get()\n\nshould be :\n\n	catch(ExecutionException | InterruptedException e){\n            return null;\n        }','private Integer executeTask (ExecutorService service, Callable<Integer> task){\n        try{\n            Future<Integer> future = service.submit(task);\n            return future.get();\n        } catch(ExecutionException e){\n            return null;\n        }\n    }','Executors',0,0,NULL,5),(2063,'will execute the submitted task\n\nfuture.get() will block until the activity is done.',' private Integer executeTask (ExecutorService service, Callable<Integer> task){\n        try{\n            Future<Integer> future = service.submit(task);\n            return future.get();\n        } catch(InterruptedException | ExecutionException e){\n            return null;\n        }\n    }','Executors',0,0,NULL,5),(2064,'try{\n	Future<Integer> future = service.submit(task);\n	return future.get();\n} catch(InterruptedException | ExecutionException e){\n   	return null;\n}\n\nor ...\n\ntry{\n	Future<Integer> future = service.submit(task);\n	return future.get();\n} catch(Exception e){\n   	return null;\n}\n\n.get() will block until a result is available',' private Integer executeTask (ExecutorService service, Callable<Integer> task){\n        // insert code \n    }\n\nwhat code could you insert here to execute the task using the service','Executors',0,0,NULL,5),(2065,'FALSE, A Callable<E> can do that a runnable cannot do either of those things.','A runnable can return a result and throw an exception','Executors',0,0,NULL,5),(2066,'1 and 5\n\nWhen creating multiple forkjointask instances all tasks except one shuld be forked\nfirst so that they can be picked up by other forkjoin worker threads.\nThe final task should then be executed within the same thread by calling compute()\nbefore calling join on all the forked threads to await their results. \n\ncallin methods in the wrong order will not cause compiler error so care must be taken','With RecursiveTask subclasses which are true ?\n\n1.fork() and join() should be called on the same task.\n2.fork() and compute() should be called on the same task.\n3.compute() and join() should be called on the same task.\n4.compute() should be called before fork()\n5.fork() should be called before compute()\n6.join() should be called after fork() but before compute()','Concurrency',0,0,NULL,5),(2067,'55','public class Hello {\n\n    public static void main(String[] args) {\n        Fibonacci fibonacci = new Fibonacci(10);\n        ForkJoinPool pool = new ForkJoinPool();\n        System.out.println(pool.invoke(fibonacci));\n    }\n}\n\nclass Fibonacci extends RecursiveTask<Long> {\n    final long n;\n    \n    Fibonacci(long n) {\n        this.n = n;\n    }\n    \n    public Long compute() {\n        if (n<=10) {\n            return do_fibonacci(n);\n        }\n        ForkJoinTask<Long> subTask = new Fibonacci(n-1).fork();\n        return new Fibonacci(n-2).compute() + subTask.join();\n    }\n    \n    static long do_fibonacci(long n) {\n        if ( n<=1 ) return n;\n        return do_fibonacci(n-1) + do_fibonacci(n-2);\n    }\n}','Concurrency',0,0,NULL,5),(2068,'55, join() returns the result of the forked procedure. \n\nfork() and join() should be called on the same, Task','public class Hello {\n\n    public static void main(String[] args) {\n        Fibonacci fibonacci = new Fibonacci(10);\n        ForkJoinPool pool = new ForkJoinPool();\n        System.out.println(pool.invoke(fibonacci));\n    }\n}\n\nclass Fibonacci extends RecursiveTask<Long> {\n    final long n;\n    \n    Fibonacci(long n) {\n        this.n = n;\n    }\n    \n    public Long compute() {\n        if (n<=10) {\n            return do_fibonacci(n);\n        }\n        //ForkJoinTask<Long> subTask = new Fibonacci(n-1).fork();\n        //return new Fibonacci(n-2).compute() + subTask.join();\n        //same as ...\n        ForkJoinTask<Long> f1 = new Fibonacci(n-1);\n        Fibonacci f2 = new Fibonacci(n-2);\n        f1.fork();\n        Long l1 = f2.compute();\n        Long l2 = f1.join();\n        return l1+l2;\n    }\n    \n    static long do_fibonacci(long n) {\n        if ( n<=1 ) return n;\n        return do_fibonacci(n-1) + do_fibonacci(n-2);\n    }\n}','Concurrency',0,0,NULL,5),(2069,'Polymorphism bites you in the ass here again,\nclass Fibonacci has a compute method not FJT','class Fibonacci extends RecursiveTask<Long> {\n    final long n;\n    \n    Fibonacci(long n) {\n        this.n = n;\n    }\n    \n    public Long compute() {\n        if (n<=10) {\n            return do_fibonacci(n);\n        }\n        //ForkJoinTask<Long> subTask = new Fibonacci(n-1).fork();\n        //return new Fibonacci(n-2).compute() + subTask.join();\n        //same as ...\n        ForkJoinTask<Long> f1 = new Fibonacci(n-1);\n        ForkJoinTask<Long> f2 = new Fibonacci(n-2);\n        f1.fork();\n        Long l1 = f2.compute();\n        Long l2 = f1.join();\n        return l1+l2;\n    }\n    \n    static long do_fibonacci(long n) {\n        if ( n<=1 ) return n;\n        return do_fibonacci(n-1) + do_fibonacci(n-2);\n    }\n}','Concurrency',0,0,NULL,5),(2070,'type fibonacci does not take parameters','public class Hello {\n\n    public static void main(String[] args) {\n        Fibonacci fibonacci = new Fibonacci(10);\n        ForkJoinPool pool = new ForkJoinPool();\n        System.out.println(pool.invoke(fibonacci));\n    }\n}\n\nclass Fibonacci extends RecursiveTask<Long> {\n    final long n;\n    \n    Fibonacci(long n) {\n        this.n = n;\n    }\n    \n    public Long compute() {\n        if (n<=10) {\n            return do_fibonacci(n);\n        }\n        //ForkJoinTask<Long> subTask = new Fibonacci(n-1).fork();\n        //return new Fibonacci(n-2).compute() + subTask.join();\n        //same as ...\n        ForkJoinTask<Long> f1 = new Fibonacci(n-1);\n        Fibonacci<Long> f2 = new Fibonacci(n-2);\n        f1.fork();\n        Long l1 = f2.compute();\n        Long l2 = f1.join();\n        return l1+l2;\n    }\n    \n    static long do_fibonacci(long n) {\n        if ( n<=1 ) return n;\n        return do_fibonacci(n-1) + do_fibonacci(n-2);\n    }\n}','General',0,0,NULL,5),(2071,'this program will never complete subtask is never forked so using join() will \nnever be able to return a result and it will block forever. \n\nto fix \n\nsubtask.fork();\n\n	ForkJoinTask<Long> subTask = new Fibonacci(n-1).fork();\n        ret = new Fibonacci(n-2).compute() + subTask.join();\n        result[(int)n] = new Long(ret);\n        return ret;','public class Hello {\n\n    public static void main(String[] args) {\n         Fibonacci fibonacci = new Fibonacci(15);\n         ForkJoinPool pool = new ForkJoinPool();\n         System.out.println(pool.invoke(fibonacci));\n    }\n}\n\n\nclass Fibonacci extends RecursiveTask<Long> {\n    final long n;\n    public static Long[] result = new Long[2];\n    public static int max_num = 1;\n    \n    public static void set_max(int num) {\n        result[0] = new Long(1);\n        result[1] = new Long(1);\n        if ( num > max_num ) {\n            Long[] new_result = new Long[num+1];\n            \n            for (int i=0; i<=max_num; i++) {\n                new_result[i] = result[i];\n            }\n            \n            result = new_result;\n            \n            for (int i=max_num+1; i<=num; i++) {\n                result[i] = new Long(0);\n            }\n            max_num = num;            \n        }\n    }\n    \n    Fibonacci(long n) {\n        this.n = n;\n        if ( n > 1 )\n            set_max((int)n);\n    }\n        \n    public Long compute() {\n        Long ret;\n        if ( result[(int)n].longValue() != 0 ) {\n            return result[(int)n];\n        }\n        if (n<=10) {\n            return do_fibonacci(n);\n        }\n        ForkJoinTask<Long> subTask = new Fibonacci(n-1);\n        ret = new Fibonacci(n-2).compute() + subTask.join();\n        result[(int)n] = new Long(ret);\n        return ret;\n    }\n    \n    static long do_fibonacci(long n) {\n        long ret;\n        if (result[(int)n].longValue() != 0) {\n            ret = result[(int)n].longValue();\n        } else {\n            long ret_n_1 = do_fibonacci(n-1);\n            long ret_n_2 = do_fibonacci(n-2);\n            ret = ret_n_1 + ret_n_2;\n            result[(int)n] = new Long(ret);\n        }\n        return ret;\n    }\n}','General',0,0,NULL,5),(2072,'will wait forever a subtask has to be fork()ed before it can rejoin the \nmain task. ','public class Hello {\n\n    public static void main(String[] args) {\n         Fibonacci fibonacci = new Fibonacci(15);\n         ForkJoinPool pool = new ForkJoinPool();\n         System.out.println(pool.invoke(fibonacci));\n    }\n}\n\n\nclass Fibonacci extends RecursiveTask<Long> {\n    final long n;\n    public static Long[] result = new Long[2];\n    public static int max_num = 1;\n    \n    public static void set_max(int num) {\n        result[0] = new Long(1);\n        result[1] = new Long(1);\n        if ( num > max_num ) {\n            Long[] new_result = new Long[num+1];\n            \n            for (int i=0; i<=max_num; i++) {\n                new_result[i] = result[i];\n            }\n            \n            result = new_result;\n            \n            for (int i=max_num+1; i<=num; i++) {\n                result[i] = new Long(0);\n            }\n            max_num = num;            \n        }\n    }\n    \n    Fibonacci(long n) {\n        this.n = n;\n        if ( n > 1 )\n            set_max((int)n);\n    }\n        \n    public Long compute() {\n        Long ret;\n        if ( result[(int)n].longValue() != 0 ) {\n            return result[(int)n];\n        }\n        if (n<=10) {\n            return do_fibonacci(n);\n        }\n        ForkJoinTask<Long> subTask = new Fibonacci(n-1);\n        ret = new Fibonacci(n-2).compute() + subTask.join();\n        subTask.fork();\n        result[(int)n] = new Long(ret);\n        return ret;\n    }\n    \n    static long do_fibonacci(long n) {\n        long ret;\n        if (result[(int)n].longValue() != 0) {\n            ret = result[(int)n].longValue();\n        } else {\n            long ret_n_1 = do_fibonacci(n-1);\n            long ret_n_2 = do_fibonacci(n-2);\n            ret = ret_n_1 + ret_n_2;\n            result[(int)n] = new Long(ret);\n        }\n        return ret;\n    }\n}','General',0,0,NULL,5),(2073,'This is the same behavior of your typical ReadWriteLock usage case if there\n is available data for reading. If no data exists, then a reader becomes a\n \"writer\" (in the lock sense) and waits until some data is available. The \ncycle repeats until some available data is returned (or until an interrupt \noccurs).\n\nSince you\'re using a ReadWriteLock, it means you\'re expecting a much \ngreater number of reads than writes and so you chose a lock that minimizes \ncontention between reader threads (the readLock).\n\nThe method waitForData() turns readers into \"writers\" because they lock on\n the writeLock instead, resulting in an increased contention between all\n threads (readers and writers). However, since writes are assumed to be \nmuch rarer than reads, a situation where data keeps toggling fast \nbetween \"available\" and \"unavailable\" is not expected. In other words, \nassuming writes are rare:\n\n    If there is no available data for reading, then virtually all readers\n will typically block in the method waitForData() after some time, and\n will all be notified at the same time when some new data is written.\n\n    If there is some available data for reading, then all readers will\n simply read it without creating any contention among the threads when \nlocking the readLock.\n','private final ReentrantReadWriteLock    rwl         = new ReentrantReadWriteLock();\nprotected final Lock                    readLock    = rwl.readLock();\nprotected final Lock                    writeLock   = rwl.writeLock();\nprotected final Condition               hasData     = writeLock.newCondition();\n\n\npublic void write() {\n\n    writeLock.lock();\n    try {\n        // write data\n        // ...\n        if (something_written) {\n            hasData.signalAll();\n        }\n    }\n    finally {\n        writeLock.unlock();\n    }\n}\n\n// replace Object by something else\npublic Object read() throws InterruptedException {\n\n    Object data = tryRead();\n\n    while (data == null) {\n        waitForData();\n        data = tryRead();\n    }\n\n    return data;\n}\n\n// replace Object by something else\nprivate Object tryRead() {\n\n    readLock.lock();\n    try {\n        Object data = null;\n        // read data\n        // ...\n        // if there no data available, return null\n        return data;\n    }\n    finally {\n        readLock.unlock();\n    }\n}\n\nprivate void waitForData() throws InterruptedException {\n\n    writeLock.lock();\n    try {\n        boolean data_available = // check data\n        while (!data_available) {\n            hasData.await(1000L, TimeUnit.MILLISECONDS);\n            data_available = // check data\n        }\n    }\n    finally {\n        writeLock.unlock();\n    }\n}\n','Concurrency',0,0,NULL,5),(2074,'What this does is force your reader thread to sleep until some data is written by the writer thread .','private final ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();\nprotected final Lock readLock = rwl.readLock();\nprotected final Lock writeLock = rwl.writeLock();\nprotected final Condition hasData = writeLock.newCondition();\nprivate HashMap myData = new HashMap(); //example structure to read and write\n\nprivate final ReentrantLock dataArrivalLock = new ReentrantLock();\nprivate final Condition dataArrivalSignal = dataArrivalLock.newCondition();\n\nYour writer method pattern :\n\ntry {\n   writeLock.lock();    \n\n   //...\n   myData.put(\"foo\",\"ffoo\"); //write something !!\n   if( something_written ) {\n      hasData.signalAll();\n   }\n\n}\nfinally {\n   writeLock.unlock();\n}\n  try {\n                //signal other threads that data has been put in\n                dataArrivalLock.lock();\n                dataArrivalSignal.signalAll();\n\n            } finally {\n                dataArrivalLock.unlock();\n            }\n\nYour reader method pattern\n\ntry {\n            boolean gotData = false;\n            while (!gotData) {\n                try {\n                    readLock.lock();\n                    if (myData.size() > 0) {\n                        gotData = true;\n                        //retrieve the data that is written by writer thred!!\n                        myData.get(\"foo\");\n                    }\n                } finally {\n                    readLock.unlock();\n                }\n                if(!gotData) {\n //sleep the reader thread for x milliseconds. x depends on your application requirement\n                  //   Thread.sleep(250);\n                    try {\n                        //instead of Thread.sleep(), use the dataArrivalLock signal to wakeup\n                        dataArrivalLock.lock();\n                        dataArrivalSignal.await();\n                        //based on how the application works a timed wait might be better !!\n                        //dataArrivalSignal.await(250);\n                    } finally {\n                        dataArrivalLock.unlock();\n                    }\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        } ','Concurrency',0,0,NULL,5),(2075,'Read lock does not support Conditions so calling newCondition() will cause \nan UnsupportedOperationException','class CarRadio extends Thread {\n    \n    public void run(){\n      while(true){  \n        Song nextSong = DJ.spinNextTrack();\n        play(nextSong);\n        try{ Thread.sleep(2000); } catch(InterruptedException e) { }\n      }\n    }\n    public void play(Song song){\n        System.out.println(\"CarRadio: \"+song.getClip());\n    }\n    \n}\n\nclass DJ {\n    private final static LinkedList<Song> queue = new LinkedList<>();\n    private final static ReentrantReadWriteLock queueLock = new ReentrantReadWriteLock();\n    private final static Lock readLock = queueLock.readLock();\n    private final static Lock writeLock = queueLock.writeLock();\n    private final static Condition newSong = writeLock.newCondition();\n    private final static Condition readSong = readLock.newCondition();\n    private final static DJ INSTANCE = new DJ();\n    \n    private DJ(){\n\n    }\n    \n    public static DJ callDJ(){\n        return INSTANCE;\n    }\n\n    public static Song spinNextTrack(){\n        readLock.lock();\n        try{\n            if(queue.isEmpty()){\n                try { newSong.await(); }catch(InterruptedException e) { }\n            }\n            return queue.poll(); \n        } finally {\n            readLock.unlock();\n        }      \n    }\n\n    public static void addToQueue(Song song){\n        writeLock.lock();\n        try{\n            //this lock blocks until acquired\n            //queueLock.writeLock().lock();\n            queue.add(song);\n            newSong.signalAll();\n        } finally{\n            writeLock.unlock();\n        }\n    }\n}\n\nclass ConstantPop extends Thread {\n    private String[] sounds = {\" Lah \", \" La La \", \" Naaahh \", \" YOLO \" };\n    private static int songCounter = 0;\n    \n    public void run(){\n        while(true){\n            Song hotNewSong = studio();\n            DJ.addToQueue(hotNewSong);\n            try { Thread.sleep(2000); } catch(InterruptedException e) { }  \n        }\n    }\n    private Song studio(){\n        StringBuilder sb = new StringBuilder();\n        for(int i = 0; i<=3; i++){\n            sb.append(sounds[ThreadLocalRandom.current().nextInt(0,3)]);\n        }\n        songCounter++;\n        return new Song(\"PopSong.\"+songCounter,sb.toString());\n    }\n}','Concurrency',0,0,NULL,5),(2076,'Copy on write, because they mkae a new copy of the collection for each write.','Which Collection from java.util.concurrent is best when there are more reads\nthan writes','Concurrency',0,0,NULL,5),(2077,'putIfAbsent(K key, V value)\n\nremove(Object key, Object value)\n\nreplace(K key, V value)\n\nreplace(K key, V oldValue, V newValue)','ConcurrentSkipListMap and concurrentMap atomic methods','Concurrency',0,0,NULL,5),(2078,'a concrete class with static methods is used to create instances of objects \nthat implement an interface.','Factory patter:','Concurrency',0,0,NULL,5),(2079,'Factory,\n\nfactory is used to create instances of classes that implement an interface.\nCan be used at runtime to decide which object to create at runtime','what pattern ?\n\npublic interface Vehicle {\n	public void start();\n	public void stop();\n}\n\npublic class Car implements Vehicle {\n	public void start() { }\n	public void stop() { }\n}\n\npublic class CarManufacturer {\n	public static Vehicle getVehicle(String type) {\n		//create an instance of the type passed in\n	}\n}\n\nclass MyClass {\n	psmv(sa) {\n		Vehicle ferrari = CarManufacturer.getVehicle(\"Ferrari\");\n	\n		ferrari.start();\n	}\n}','Concurrency',0,0,NULL,5),(2080,'','for jdbc 3.0 drivers and earlier you are responsible for loading the class\nusing static forName(). Later driver classes are loaded automatically.','Concurrency',0,0,NULL,5),(2081,'10001\nGeorgi\nFacello\n10002\nBezalel\nSimmel\n10003\nParto\nBamford\n10004\nChirstian\nKoblick\n10005\nKyoichi\nMaliniak\n10006\nAnneke\nPreusig\n10007\nTzvetan\nZielinski\n10008\nSaniya\nKalloufi\n10009\nSumant\nPeac\n10010\nDuangkaew\nPiveteau','public class Hello {\n    public static void main(String[] args){\n        try {\n            Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\");\n            Statement st = conn.createStatement();\n            String query = \"Select * From employees limit 10\";\n            ResultSet rs = st.executeQuery(query);\n            while(rs.next()){\n                System.out.println(rs.getInt(\"emp_no\"));\n                System.out.println(rs.getString(\"first_name\"));\n                System.out.println(rs.getString(\"last_name\"));\n            } \n            \n        } catch(SQLException e){ }\n        \n    }\n}\n','Concurrency',0,0,NULL,5),(2082,'will not compile, executeUPdate returns an int of updated rows.','public class Hello {\n    public static void main(String[] args){\n        try {\n            Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\");\n            Statement st = conn.createStatement();\n            String update = \"update employee set emp_no = 11111 where first_name = Georgi\";\n            ResultSet rs = st.executeUpdate(update);\n            while(rs.next()){\n                System.out.println(rs.getInt(\"emp_no\"));\n                System.out.println(rs.getString(\"first_name\"));\n                System.out.println(rs.getString(\"last_name\"));\n            } \n            \n        } catch(SQLException e){ }\n        \n    }\n}','Concurrency',0,0,NULL,5),(2083,'execute(String sql) \n\nthe return value is true if the result is a result set and false if the \nquery is an update count or no results. \n\n','what jdbc method would you use when you are unsure of the result of a query\nor update','Concurrency',0,0,NULL,5),(2084,'false \n\nexecute returns true if it returns a result set and false for an update count','public class Hello {\n    public static void main(String[] args){\n        try {\n            Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\");\n            Statement st = conn.createStatement();\n            String update = \"Update employees Set first_name = \'Big John\' where first_name = \'Georgi\'\";\n            boolean b = st.execute(update);\n            System.out.println(b);\n        } catch(SQLException e){System.out.println(\"something went wrong\"); }\n        \n    }\n}','Concurrency',0,0,NULL,5),(2085,'if getUpdateCount() returns -1 then there were no results.','public class Hello {\n    public static void main(String[] args){\n        try {\n            Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\");\n            Statement st = conn.createStatement();\n            String update = \"Update employees Set first_name = \'Big John\' where first_name = \'Georgi\'\";\n            boolean b = st.execute(update);\n            if(b){\n                //ResultSet res = update.getResultSet();\n                ResultSet res = st.getResultSet();\n            } else {\n                int numrows = st.getUpdateCount();\n                if(numrows == -1){\n                    System.out.println(\"No Results\");\n                }\n            }\n        } catch(SQLException e){System.out.println(\"something went wrong\"); }\n        \n    }\n}','Concurrency',0,0,NULL,5),(2086,'will not compiles, getResultSet is from a statement object','public class Hello {\n    public static void main(String[] args){\n        try {\n            Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\");\n            Statement st = conn.createStatement();\n            String update = \"Update employees Set first_name = \'Big John\' where first_name = \'Georgi\'\";\n            boolean b = st.execute(update);\n            if(b){\n                ResultSet res = update.getResultSet();\n            } else {\n                int numrows = st.getUpdateCount();\n                if(numrows == -1){\n                    System.out.println(\"No Results\");\n                }\n            }\n        } catch(SQLException e){System.out.println(\"something went wrong\"); }\n        \n    }\n}','Concurrency',0,0,NULL,5),(2087,'something went wrong\n\nyou have to always call next() before processing a rown from a result set \nthe cursors starts out as before the first row.\n\nIt is a sqlexception to try to get a row when it is before the first row.','public class Hello {\n    public static void main(String[] args){\n        try {\n            Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\");\n            Statement st = conn.createStatement();\n            String update = \"Select first_name from employees\";\n            boolean b = st.execute(update);\n            if(b){\n                //ResultSet res = update.getResultSet();\n                ResultSet res = st.getResultSet();\n                System.out.println(res.getString(\"first_name\"));\n            } else {\n                int numrows = st.getUpdateCount();\n                if(numrows == -1){\n                    System.out.println(\"No Results\");\n                }\n            }\n            \n            \n        } catch(SQLException e){System.out.println(\"something went wrong\"); }\n        \n    }\n}','Concurrency',0,0,NULL,5),(2088,'Big John','public class Hello {\n    public static void main(String[] args){\n        try {\n            Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\");\n            Statement st = conn.createStatement();\n            String update = \"Select first_name from employees\";\n            boolean b = st.execute(update);\n            if(b){\n                //ResultSet res = update.getResultSet();\n                ResultSet res = st.getResultSet();\n                res.next();\n                System.out.println(res.getString(\"first_name\"));\n            } else {\n                int numrows = st.getUpdateCount();\n                if(numrows == -1){\n                    System.out.println(\"No Results\");\n                }\n            }\n            \n            \n        } catch(SQLException e){System.out.println(\"something went wrong\"); }\n        \n    }\n}\n','Concurrency',0,0,NULL,5),(2089,'SQLException invalid value for getInt()\n\nyour sql query only selected the firstnames, there are no other coluns to get\ninfo from. ','ublic class Hello {\n    public static void main(String[] args){\n        try {\n            Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\");\n            Statement st = conn.createStatement();\n            String update = \"Select first_name from employees\";\n            boolean b = st.execute(update);\n            if(b){\n                ResultSet res = st.getResultSet();\n                res.next();\n                System.out.println(res.getInt(1));\n                System.out.println(res.getDate(2));\n                System.out.println(res.getString(3));\n                \n            } else {\n                int numrows = st.getUpdateCount();\n                if(numrows == -1){\n                    System.out.println(\"No Results\");\n                }\n            }\n            \n            \n        } catch(SQLException e){System.out.println(e); }\n        \n    }\n}','JDBC',0,0,NULL,5),(2090,'run:\n10001\n1953-09-02\nBig John\nBUILD SUCCESSFUL (total time: 1 second)\n','public class Hello {\n    public static void main(String[] args){\n        try {\n            Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\");\n            Statement st = conn.createStatement();\n            String update = \"Select * from employees\";\n            boolean b = st.execute(update);\n            if(b){\n                ResultSet res = st.getResultSet();\n                res.next();\n                System.out.println(res.getInt(1));\n                System.out.println(res.getDate(2));\n                System.out.println(res.getString(3));\n                \n            } else {\n                int numrows = st.getUpdateCount();\n                if(numrows == -1){\n                    System.out.println(\"No Results\");\n                }\n            }\n            \n            \n        } catch(SQLException e){System.out.println(e); }\n        \n    }\n}','JDBC',0,0,NULL,5),(2091,'sql exception index out of range,\n\nindexs range from 1 to the size','public class Hello {\n    public static void main(String[] args){\n        try {\n            Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\");\n            Statement st = conn.createStatement();\n            String update = \"Select * from employees\";\n            boolean b = st.execute(update);\n            if(b){\n                ResultSet res = st.getResultSet();\n                res.next();\n                System.out.println(res.getInt(0));\n                System.out.println(res.getDate(1));\n                System.out.println(res.getString(2));\n                \n            } else {\n                int numrows = st.getUpdateCount();\n                if(numrows == -1){\n                    System.out.println(\"No Results\");\n                }\n            }\n            \n            \n        } catch(SQLException e){System.out.println(e); }\n        \n    }\n}','JDBC',0,0,NULL,5),(2092,'sqlexception, next() was not called before processing a result set','public class Hello {\n    public static void main(String[] args){\n        try {\n            Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\");\n            Statement st = conn.createStatement();\n            String update = \"Select * from employees\";\n            boolean b = st.execute(update);\n            if(b){\n                ResultSet res = st.getResultSet();\n                System.out.println(res.getInt(1));\n                System.out.println(res.getDate(2));\n                System.out.println(res.getString(3));\n                \n            } else {\n                int numrows = st.getUpdateCount();\n                if(numrows == -1){\n                    System.out.println(\"No Results\");\n                }\n            }\n            \n            \n        } catch(SQLException e){System.out.println(e); }\n        \n    }\n}\n','JDBC',0,0,NULL,5),(2093,'sql Date stores in the form yyyy mm dd','java.sql.Date extends java.util.Date\n\nwhats the main difference\n\njava.sql.Date pubDate = rs.getDate(\"PubDate\");','JDBC',0,0,NULL,5),(2094,'\"hh:mm:ss\"','java.sql.Time time = rs.getTime(\"FinishTime\");\n\nwhat form does this kind of Time take ?','JDBC',0,0,NULL,5),(2095,'','use getObject for a general purpose get()\n\njdbc will return a wrapper for the appropriate sql type.\n\nso a sql int would return integer\n\nObject o = rs.getObject(\"AuthorID\");\nif( o instanceof Integer){\n	//do\n}','JDBC',0,0,NULL,5),(2096,'String query = \"  \";\nResultSet res = stmt.executeQuery(query);\nReslutSetMetaData rsmd = rs.getMetaData();\nrs.next();\nint colCount = rsmd.getColumnCount();','How can you figure out the number of columns in a ResultSet ?','JDBC',0,0,NULL,5),(2097,'employees\nemp_no\n11\nemployees\nbirth_date\n10\nemployees\nfirst_name\n14\nemployees\nlast_name\n16\nemployees\ngender\n1\nemployees\nhire_date\n10','public class Hello {\n    public static void main(String[] args){\n        try {\n            Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\");\n            Statement st = conn.createStatement();\n            String q = \"Select * from employees\";\n            \n            ResultSet rs = st.executeQuery(q);\n            ResultSetMetaData rmd = rs.getMetaData();\n            int cols = rmd.getColumnCount();\n            \n            for(int i = 1; i <= cols; i++){\n                System.out.println(rmd.getTableName(i));\n                System.out.println(rmd.getColumnName(i));\n                System.out.println(rmd.getColumnDisplaySize(i));\n            } \n        } catch(SQLException e){System.out.println(e); }\n        \n    }\n}','JDBC',0,0,NULL,5),(2098,'First entry:\nMicheal Boyd\nLast entry:\nKenroku Malabarba\nrow: 20\nKyoichi Maliniak\nrow: 30\nGuoxiang Nooteboom','public class Hello {\n    public static void main(String[] args){\n        try {\n            Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\");\n            Statement st = conn.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE,ResultSet.CONCUR_READ_ONLY);\n            String q = \"Select * From employees limit 100\";\n            ResultSet rs = st.executeQuery(q);\n            \n            rs.first();\n            System.out.println(\"First entry:\");\n            System.out.println(rs.getString(\"first_name\") + \" \" +rs.getString(\"last_name\"));\n            \n            rs.last();\n            System.out.println(\"Last entry:\");\n            System.out.println(rs.getString(\"first_name\") + \" \" +rs.getString(\"last_name\"));\n            \n            rs.absolute(20);\n            System.out.println(\"row: \"+ rs.getRow());\n            System.out.println(rs.getString(\"first_name\") + \" \" +rs.getString(\"last_name\"));\n            \n            rs.relative(10);\n            System.out.println(\"row: \"+ rs.getRow());\n            System.out.println(rs.getString(\"first_name\") + \" \" +rs.getString(\"last_name\"));  \n        } catch(SQLException e){System.out.println(e); }\n        \n    }\n}','JDBC',0,0,NULL,5),(2099,'true','Once created you cannot change the concurrency or Cursor type of an existing\nstatement object.','JDBC',0,0,NULL,5),(2100,'','if cursor or concurrency settings are not supported then the driver will show\na warning and silently revert to default settings. ','JDBC',0,0,NULL,5),(2101,'what is b? :8\n','public class Hello {\n    public static void main(String[] args){\n       int a = 8;\n        System.out.println(\"what is b? :\"+a++);\n    }\n}','JDBC',0,0,NULL,5),(2102,'method local inner classes cannot access non final local variables,\n\nalso method local classes are just like local variables they cannot be \n	static private public protected or anything else','public class Hello {\n   \n    public static void main(String[] args) {\n        Hello h = new Hello();\n        h.methodlocal();\n    }\n    \n    public void methodlocal(){\n        int y = 56;\n        \n        private class Zombie {\n            public int size;\n        \n            public Zombie(int x){ size = x;}\n            public void mone(){\n                System.out.println(\"ughhhg: \"+ size);\n            }\n            \n            public void accessTheLiving(){\n                System.out.println(\"local var: \"+y);\n            }\n            \n        }\n        \n        Zombie zom = new Zombie(7);\n        \n    }\n\n}','JDBC',0,0,NULL,5),(2103,'compiles fine','public class Hello {\n    public static void main(String[] args){\n        List<Animal> animals = new ArrayList<Animal>();\n        animals.add(new Dog());\n        animals.add(new Animal());\n    }\n    public static void addAnimal(List<Object> animals) {\n	animals.add(new Dog());\n    }\n}\n\nclass Dog extends Animal {}\nclass Animal { }','JDBC',0,0,NULL,5),(2104,'will not compile, \n\nfirst you cant add to a collection defined with ? extends. \n\nsecond, since dest is defined with ? super it is saying that that collection\ncan be of any type of super class of G,thouhg you can still add only G. \n\nTherefore the iterator will return objects not Gs.\n\nYou are taking from dest and adding to src. dest is the producer and src is the\nconsumer. Producers extend Consumers Super. ITs backward here. ','public class Hello<T> {\n    \n    public static void main(String[] args){\n        ArrayList<Beagle> a = new ArrayList<>();\n        ArrayList<Animal> b = new ArrayList<>();\n        \n        Hello<String> x = new Hello<>();\n        \n        \n        \n        x.copyColl(a,b);\n        \n\n    } \n    public <G extends Being> void copyColl(Collection<? extends G> src, Collection<? super G> dest){\n        \n        for(G n : dest)\n            src.add(n);\n        \n    }\n}\n\nclass Beagle extends Animal { }\nclass Animal extends Being {} \nclass Being { }','Collections',0,0,NULL,5),(2105,'will not compile redwolf does not extend beagle','public class Hello<T> {\n    \n    public static void main(String[] args){\n        ArrayList<RedWolf> a = new ArrayList<>();\n        ArrayList<Animal> b = new ArrayList<>();\n        \n        Hello<String> x = new Hello<>();\n        \n        \n        \n        x.copyColl(a,b);\n        \n\n    } \n    public <G extends Beagle> void copyColl(Collection<? extends G> src, Collection<? super G> dest){\n        \n        for(G g : src)\n            dest.add(g);\n        \n    }\n}\n\n\nclass GoodBeagles extends Beagle { }\nclass Beagle extends Animal { }\nclass Animal extends Being {} \nclass Being { }\nclass Wolf { } \nclass RedWolf{ }','Collections',0,0,NULL,5),(2106,'shows the number of rows ','public class Hello {\n    public static void main(String[] dicks){\n         try {\n            Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\");\n            Statement st = conn.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_UPDATABLE);\n            String q = \"Select * from employees\";\n            ResultSet rs = st.executeQuery(q);\n            \n            if(rs.last()){\n               int rowCount = rs.getRow();\n               rs.beforeFirst();\n                System.out.println(rowCount);\n            }\n            \n            \n        } catch(SQLException e){System.out.println(e); }\n    }\n}','Collections',0,0,NULL,5),(2107,'91\n\nif absolute takes a - number it starts from the last row and works backward. \n\nreturns false if the cursor is beyond the lst row or beffore the first','public class Hello {\n    public static void main(String[] dicks){\n         try {\n            Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\");\n            Statement st = conn.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_UPDATABLE);\n            String q = \"Select * from employees limit 100\";\n            ResultSet rs = st.executeQuery(q);\n            rs.absolute(-10);\n             System.out.println(rs.getRow()); \n        } catch(SQLException e){System.out.println(e); }\n    }\n}','Collections',0,0,NULL,5),(2108,'Sachin Tsukuda','public class Hello extends Thread {\n    public static void main(String[] args){\n        try(Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees\", \"root\", \"Basketball12\")){\n            String getAllEmployeeNames = \"select first_name,last_name from employees\";\n            Statement st1 = conn.createStatement();\n            \n            ResultSet empnames = st1.executeQuery(getAllEmployeeNames);\n            \n            empnames.last();\n            \n            System.out.println(empnames.getString(\"first_name\")+\" \"+empnames.getString(\"last_name\"));\n            \n        }catch(SQLException e){\n            System.out.println(e);\n        }\n    }\n}','JDBC',0,0,NULL,5),(2109,'0','public class Hello {\n    public static void main(String[] dicks){\n         try {\n            Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\");\n            Statement st = conn.createStatement(ResultSet.TYPE_FORWARD_ONLY,ResultSet.CONCUR_UPDATABLE);\n            String q = \"Select * from employees limit 100\";\n            ResultSet rs = st.executeQuery(q);\n            System.out.println(rs.getRow()); \n        } catch(SQLException e){System.out.println(e); }\n    }\n}','JDBC',0,0,NULL,5),(2110,'also 0','public class Hello {\n    public static void main(String[] dicks){\n         try {\n            Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\");\n            Statement st = conn.createStatement(ResultSet.TYPE_FORWARD_ONLY,ResultSet.CONCUR_UPDATABLE);\n            String q = \"Select * from employees limit 100\";\n            ResultSet rs = st.executeQuery(q);\n            rs.afterLast();\n            System.out.println(rs.getRow()); \n        } catch(SQLException e){System.out.println(e); }\n    }\n}','JDBC',0,0,NULL,5),(2111,'run:\n0\njava.sql.SQLException: No operations allowed after statement closed.\nBUILD SUCCESSFUL (total time: 0 seconds)\n\nit is not an exception to call getRow after the last row or before the first.\nit will simply give zero. \n','public class Hello {\n    public static void main(String[] dicks){\n         try {\n            Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\");\n            Statement st = conn.createStatement(ResultSet.TYPE_FORWARD_ONLY,ResultSet.CONCUR_UPDATABLE);\n            String q = \"Select * from employees limit 100\";\n            String q2 = \"Select * from salaries limit 100\";\n            ResultSet rs = st.executeQuery(q);\n            rs.afterLast();\n            System.out.println(rs.getRow()); \n            conn.close();\n            rs = st.executeQuery(q2);\n            while(rs.next()){\n                System.out.println(rs.getInt(\"salary\"));\n            }\n        } catch(SQLException e){System.out.println(e); }\n    }\n}','JDBC',0,0,NULL,5),(2112,'0','public class Hello {\n    public static void main(String[] dicks){\n         try(Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\");\n            Statement st = conn.createStatement(ResultSet.TYPE_FORWARD_ONLY,ResultSet.CONCUR_UPDATABLE);) {\n            String q = \"Select * from employees limit 100\";\n            String q2 = \"Select * from salaries limit 100\";\n            ResultSet rs = st.executeQuery(q);\n            rs.afterLast();\n            System.out.println(rs.getRow()); \n        } catch(SQLException e){System.out.println(e); }\n    }\n}','JDBC',0,0,NULL,5),(2113,'Class.forName(\"org.abc.mmmysql.Driver\");','String url = \"   \";\nString user = \"  \";\nString pwd = \"    \";\n\n// insert here\nConnection conn = DriverManaget.getConnection(url,user,pwd);\n\nwhat would you use to load a JDBC 3.0 driver class','JDBC',0,0,NULL,5),(2114,'Must include a MEAT-INF file, this allows the driver to autoload.\n\nMust provide implementations of Driver, Connection, Statement, ResultSet\ninterfaces\n\nMust support transactions\n\n','What does it take for a driver to be jdbc 4.0 compliant ?	','JDBC',0,0,NULL,5),(2115,'3\n4\n6','What three are availabe through an instance of DatabaseMetaData ?\n\n1 number of columns returned\n2 number of rows returned\n3 name of jdbc driver\n4 default transaciton isolation level\n5 last query used\n6 names of stored procedures\n7 current Savepoint name','JDBC',0,0,NULL,5),(2116,'SQLException, next() wass not called the cursors starts of pointing to BEFORE\nthe first row. ','try {\n	Statement st = conn.createStatement();\n	String query = \"Select * From Author Where LastName Like \'Rand%\'\";\n	Resultset rs = st.executeQuery(query);\n	if(rs == null) {\n		sout( \"no results\" );\n	} else {\n		sout(rs.getString(\"FirstName\");\n	}\n} catch(SQLException se) {\n	sout(\"SQLException\");\n}','JDBC',0,0,NULL,5),(2117,'SQLException\n\nexecuteQuery cannot be used to execute update insrt delete or ddl statements \nor it will throw a sqlexception. \n','public class Hello {\n    public static void main(String[] dicks){\n         try(Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employee?useSSL=false\", \"root\", \"Basketball12\")){\n             String query = \"Update employees set first_name = \'Hefty\' where emp_no = 10001\"; \n             Statement st = conn.createStatement();\n             st.executeQuery(query);\n         } catch(SQLException e){\n             System.out.println(\"SQLException\");\n         }\n    }\n \n}','JDBC',0,0,NULL,5),(2118,'SQLException\n\ntrying to access a closed ResultSet. ','try {\n	ResultSet rs = null;\n	try (Statement st = conn.createStatement()) {\n		String query = \"Select * From Customer\";\n		rs = st.executeQuery(query);\n	} catch(SQLException se) {\n		sout(\"Illegal query\");	\n	}\n\n	while (rs.next()) {\n		//process customers \n	}\n} catch(SQLException e) {\n	sout(\"SQLException\");\n}','JDBC',0,0,NULL,5),(2119,'these would all produce their indicated rsults, update will produce and update count\neven if no rows are affected','Statement st = conn.createStatement();\nResultSet rs;\nString query = \"<QUERY HERE>\";\nst.execute(query);\nif ((Rs = st.getResultSet()) != null) {\n	sout(\"Results\");\n}\nif (st.getUpdateCount() > -1) {\n	sout(\"update\");\n}\n\nSelect * from customer\ninsert into ...\nupdate...\ndelete...','JDBC',0,0,NULL,5),(2120,'exception\n\nparameters are numbered starting from 1 not 0.','String q = \"update customer set Last_name = ? Where Customer_id = ?\";\ntry {\n	PreparedStatement pt = conn.prepareStatement(q);\n	pt.setString(0,\"Smith\");\n	pt.setString(1,\"5001\");\n	int result = pt.executeUpdate();\n	if(result != 1) sout(\"error\");\n} catch(SQLException e) {\n	sout(\"Exception\");\n}','JDBC',0,0,NULL,5),(2121,'yes yes sqlexception everything is smooth on the first iteration, but \nthe second the preparedstatement index paramenters will be 3 and 4 when there\nare only two parameters, this will cause the exc.','try {\n	String[] searchPair = {\"%a%\", \"%b%\",\"%c%\",\"%d%\" };\n	String query = \"Sleect ... ? ... ?\";\n	PreparedStatement pt = conn.PrepareStatement(query);\n	for(int i = 0; i < searchPair.length; i+=2) {\n		pt.setString(i+1, searchPAir[i]);\n		pt.setString(i+2, searchPair[i++]);\n		ResultSet rs = pt.executeQuery();\n		while(rs.next()) {\n			sout(\"yes\");\n		}\n	}\n} catch(Sqlexcepiton ee) {\n	sout	(\"SQLException\");\n}\n			','JDBC',0,0,NULL,5),(2122,'Collections of type ? can be assigned to by any type of list but cannot be\nadded to. ','public class Hello {\n    public static void main(String[] dicks){\n         List<?> list = new ArrayList<Dog>();\n         list.add(new Dog());\n         list.add(new Dog());\n         list.add(new Dog());\n    }\n \n}\n\nclass Dog {\n    \n}','Collections',0,0,NULL,5),(2123,'will not compile, object cannot be converted to Dog.\nThe objects comming out of a List<?> are Objects.','public class Hello {\n    public static void main(String[] dicks){\n         List<Dog> Doglist = new ArrayList<Dog>();\n         Doglist.add(new Dog(\"Charly\"));\n         Doglist.add(new Dog(\"Baily\"));\n         Doglist.add(new Dog(\"Wiley\"));\n         \n         List<?> unmodifiableDogList = Doglist;\n         \n         for(Dog d : unmodifiableDogList){\n             System.out.println(d.getName());\n         }\n    }\n \n}\n\nclass Dog {\n    private String name;\n    public Dog(String s ){\n        name = s;\n    }\n    \n    public String getName(){\n        return name;\n    }\n    \n}','Collections',0,0,NULL,5),(2124,'althought the base type here is ArrayList Doglist is defined as a list \nso it cannot be assigned to an ArrayList ','public class Hello {\n    public static void main(String[] dicks){\n         List<Dog> Doglist = new ArrayList<Dog>();\n         Doglist.add(new Dog(\"Charly\"));\n         Doglist.add(new Dog(\"Baily\"));\n         Doglist.add(new Dog(\"Wiley\"));\n         \n         ArrayList<?> unmodifiableDogList = Doglist;\n         \n         for(Object d : unmodifiableDogList){\n             System.out.println(d.getName());\n         }\n    }\n \n}\n\nclass Dog {\n    private String name;\n    public Dog(String s ){\n        name = s;\n    }\n    \n    public String getName(){\n        return name;\n    }\n    \n}','Collections',0,0,NULL,5),(2125,'compiles fine the reference type is still defined as a raw type','public class Hello<T> {\n    public static void main(String[] args){\n        \n        Dog d = new Dog();\n        \n        ArrayList x = makeArrayList(d);\n        \n        ArrayList c = new ArrayList<String>();\n        c.add(new Dog());\n        c.add(90);\n\n    } \n    public static <G> ArrayList<G> makeArrayList(G g){\n        ArrayList<G> genlist = new ArrayList();\n        genlist.add(g);\n        return genlist;\n        \n    }\n}\n\nclass Dog {\n    \n}','Collections',0,0,NULL,5),(2126,'will not compile, all those methods throw IOExceptions','public class Hello {\n    public static void main(String[] args){\n       File file1 = new File(\"~/Public/TestDir/file1\");\n       File file2 = new File(\"~/Public/TestDir/file2\");\n       File dir = new File(\"~/Public/TestDir\");\n       \n       if(dir.exists() && dir.isDirectory()){\n           file1.createNewFile();\n           file2.createNewFile();\n       } else {\n           dir.mkdir();\n           file1.createNewFile();\n           file2.createNewFile();\n       }\n    } \n}','IO',0,0,NULL,5),(2127,'fine','public class Hello<T> {\n    \n    public static void main(String[] args){\n        \n        Dog d = new Dog();\n        \n        ArrayList<? extends Dog> c = new ArrayList<Beagle>();\n        Animal a = c.get(0);\n    } \n}\n\nclass Animal{}\nclass Dog extends Animal { }\nclass Beagle extends Dog { }','Generics',0,0,NULL,5),(2128,'will not compile wrong number of type arguments, \nthis is a generic method, \n\nit should be <? extends Animal>','public class Hello<T> {\n    \n    public static void main(String[] args){\n        ArrayList<Animal> a;\n        ArrayList<Beagle> b;\n        \n        Hello<String> x = new Hello<>();\n        \n        x.copyColl(a,b);\n        \n\n    } \n    public <G> void copyColl(Collection<G extends Animal> src, Collection<G> dest){\n        \n        for(G n : src)\n            dest.add(n);\n        \n    }\n}\n\nclass Animal{}\nclass Dog extends Animal { }\nclass Beagle extends Dog { }','Generics',0,0,NULL,5),(2129,'in java 7 and beyond the compiler can infer the type from the return type !','public class Hello<T> {\n    \n    public static void main(String[] args) {\n        Cat cat = parse(\"cat\");\n        Dog dog = parse(\"dog\");\n        System.out.println(\"the cat object is a \" + cat);\n        System.out.println(\"the dog object is a \" + dog);\n    }\n\n    private static class Dog {\n        public String toString() { return \"dog\"; }\n    }\n\n    private static class Cat {\n        public String toString() { return \"cat\"; }\n    }\n\n    private static Object untypedParse(String stringToParse) {\n        if(stringToParse.equals(\"dog\")) {\n            return new Dog();\n        } else if(stringToParse.equals(\"cat\")) {\n            return new Cat();\n        } else {\n            throw new RuntimeException(\"not expected\");\n        }\n    }\n\n    public static <T> T parse(String stringToParse) {\n        return (T)untypedParse(stringToParse);\n    }\n\n}','Generics',0,0,NULL,5),(2130,'First it should be: public static <T> T fromXML<T>(String xml)\n\nIn Java, generics are compile-time only data, which are lost at run time. \nSo, if you called a method like that, the JVM would have no way of knowing what T.class was. \nThe normal way to get around this is to pass a class instance object as a parameter to the method, \nlike this:\n\npublic static <T> T fromXml(Class<T> clazz, String xml) {\n  try {\n    JAXBContext context = JAXBContext.newInstance(clazz);\n    Unmarshaller um = context.createUnmarshaller();\n    return (T)um.unmarshal(new StringReader(xml));\n  } catch (JAXBException je) {\n    throw new RuntimeException(\"Error interpreting XML response\", je);\n  }\n}\n\nfromXml(SomeSubObject.class, \"<xml/>\");\n\n','//How to fix this\npublic static T fromXml<T>(String xml) {\n  try {\n    JAXBContext context = JAXBContext.newInstance(T.class);\n    Unmarshaller um = context.createUnmarshaller();\n    return (T)um.unmarshal(new StringReader(xml));\n  } catch (JAXBException je) {\n    throw new RuntimeException(\"Error interpreting XML response\", je);\n  }\n}\n\n//Also the call doesn\'t work...\nfromXml<SomeSubObject>(\"<xml/>\");','Generics',0,0,NULL,5),(2131,'java.sql.SQLException: Parameter index out of range (4 > number of parameters, which is 3).','public class Hello<T> {\n    \n    public static void main(String[] args){\n        try (Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\")){\n            String prepInsert = \"Insert into employees values(?,\'1962-11-07\',?,?,\'F\',\'1962-11-07\')\";\n            PreparedStatement ps = conn.prepareStatement(prepInsert,ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_UPDATABLE);\n            ps.setInt(1,555);\n            ps.setString(3,\"Angela\");\n            ps.setString(4,\"Horton\");\n            \n            int rowsupdated = ps.executeUpdate();\n            \n            System.out.println(rowsupdated);\n\n        }catch(Exception e){\n            System.out.println(e);\n            \n        }\n        \n    }\n}','JDBC',0,0,NULL,5),(2132,'1\n1\n\nyou can use a prepared statement multiple times','public class Hello<T> {\n    \n    public static void main(String[] args){\n        try (Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\")){\n            String prepInsert = \"Insert into employees values(?,\'1962-11-07\',?,?,\'F\',\'1962-11-07\')\";\n            PreparedStatement ps = conn.prepareStatement(prepInsert,ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_UPDATABLE);\n            ps.setInt(1,556);\n            ps.setString(2,\"Angela\");\n            ps.setString(3,\"Horton2\");\n            \n            int rowsupdated = ps.executeUpdate();\n            System.out.println(rowsupdated);\n            \n            ps.setInt(1,666);\n            ps.setString(2,\"MAX\");\n            ps.setString(3,\"AMILLION\");\n            \n            rowsupdated = ps.executeUpdate();\n            \n            System.out.println(rowsupdated);\n\n        }catch(Exception e){\n            System.out.println(e);\n            \n        }\n        \n    }\n}','JDBC',0,0,NULL,5),(2133,'Angela 555','public class Hello<T> {\n    \n    public static void main(String[] args){\n        try (Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\")){\n            String prepInsert = \"Select * from employees where first_name = ? OR last_name = ?\";\n            PreparedStatement ps = conn.prepareStatement(prepInsert,ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_UPDATABLE);\n            ps.setString(1,\"Georgi\");\n            ps.setString(2,\"Horton\");\n            \n            ResultSet rs = ps.executeQuery();\n            \n            while(rs.next()){\n                System.out.println(rs.getString(\"first_name\")+\" \"+rs.getString(\"emp_no\"));\n            }\n        }catch(Exception e){\n            System.out.println(e);           \n        }\n    }\n}','JDBC',0,0,NULL,5),(2134,'com.mysql.jdbc.exceptions.jdbc4.MySQLSyntaxErrorException: You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near \'? OR last_name = ?\' at line 1\n\npreparedstatement execute query does not take a String parameter, it already\nknows the query to execute. ','public class Hello<T> {\n    \n    public static void main(String[] args){\n        try (Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\")){\n            String prepInsert = \"Select * from employees where first_name = ? OR last_name = ?\";\n            PreparedStatement ps = conn.prepareStatement(prepInsert,ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_UPDATABLE);\n            ps.setString(1,\"Georgi\");\n            ps.setString(2,\"Horton\");\n            \n            ResultSet rs = ps.executeQuery(prepInsert);\n            \n            while(rs.next()){\n                System.out.println(rs.getString(\"first_name\")+\" \"+rs.getString(\"emp_no\"));\n            }\n        }catch(Exception e){\n            System.out.println(e);           \n        }\n    }\n}','JDBC',0,0,NULL,5),(2135,'calls the stored proceudre getBooksInDateRange','int customerID = 5001;\njava.sql.Date fromDate = ...;\njava.sql.Date toDate = ...;\nString getBooksInDateRange = \"{call getBooksDateRange(?,?,?)}\";\n\nCallableStatement cstmt = conn.prepareCall(getBooksInDateRange,ResultSet.TYPE_SCROLL_INSESNSITIVE,ResultSet.CONCUR_UPDATABLE);\n\ncstmt.setInt(1,customerID);\ncstmt.setDate(2,fromDate);\ncstmt.setDate(3,toDate);\nResultSet rs = cstmt.executeQuery();\n\n\n','JDBC',0,0,NULL,5),(2136,'to use a stored procedure you have to register the out parameter \nfirst. As shown here. ','int customerID = 5001;\njava.sql.Date fromDate = ...;\njava.sql.Date toDate = ...;\nString getBooksInDateRange = \"{? =call customerTotal (?)}\";\n\nCallableStatement cstmt = conn.prepareCall(getBooksInDateRange,ResultSet.TYPE_SCROLL_INSESNSITIVE,ResultSet.CONCUR_UPDATABLE);\n\ncstmt.registerOutParameter(1,java.sql.Types.DOUBLE);\n\ncstmt.setInt(2,customerID);\n\ncstmt.execute(); // not returning a resultset\n\nint total = cstmt.getDouble(1);\n','JDBC',0,0,NULL,5),(2137,'sqlexception execute doesn\'t take a parameter','int customerID = 5001;\njava.sql.Date fromDate = ...;\njava.sql.Date toDate = ...;\nString getBooksInDateRange = \"{? =call customerTotal (?)}\";\n\nCallableStatement cstmt = conn.prepareCall(getBooksInDateRange,ResultSet.TYPE_SCROLL_INSESNSITIVE,ResultSet.CONCUR_UPDATABLE);\n\ncstmt.registerOutParameter(1,java.sql.Types.DOUBLE);\n\ncstmt.setInt(2,customerID);\n\ncstmt.execute(getBookInDateRange); // not returning a resultset\n\nint total = cstmt.getDouble(1);\n                                  ','JDBC',0,0,NULL,5),(2138,'registers an INOUT parameter','int customerID = 5001;\nint numberOfOrders;\nCallableStatement ct = conn.prepareCall(\"{call customerOrderCount (?) }\");\nct.setInt(1,customerID);\nct.registerOutParameter(1.java.sql.Types.INTEGER);  // the out\n\nct.execute();\n\nint numberoforders = ct.getInt(1);','JDBC',0,0,NULL,5),(2139,'storedprocedures is code thta you dont have insight to and if you invoke executeQuery()\non a procedure that doesn\'t return a result set you get a sqlException\n\nso its best to use execute()','int customerID = 5001;\nint numberOfOrders;\nCallableStatement ct = conn.prepareCall(\"{call customerOrderCount (?) }\");\nct.setInt(1,customerID);\nct.registerOutParameter(1.java.sql.Types.INTEGER);  // the out\n\nct.executeQuery();\n\nint numberoforders = ct.getInt(1);','JDBC',0,0,NULL,5),(2140,'','int customerID = 5001;\nint numberOfOrders;\nCallableStatement ct = conn.prepareCall(\"{call customerOrderCount (?) }\");\nct.setInt(1,customerID);\nct.registerOutParameter(1.java.sql.Types.INTEGER);  // the out\n\nct.execute();\n\nint numberoforders = ct.getInt(1);\n\nif(ct.getMoreResults()) // returns true if there is a resultset to get. ','JDBC',0,0,NULL,5),(2141,'','RowSetFactory rsf = RowSetProvider.newFactory();\nJdbcRowSet jrs = rsf.createJdbcRowSet();\n// Provider returns a facotry that will create Rowset objects from\n// the reference implementation\n\n//with the factory it is easy to swap out the implementation\n\nRowSetFactorys rsf2 = RowSetProvider.newFactory(\"com.example.MyRowSetProvider\",null);\nJdbcRowSet jrs = rsf.createJdbcRowSet();','JDBC',0,0,NULL,5),(2142,'prints the first 100 employees\' full names\n\nyou construct a JdbcRowSet from a RowSetProvider.newFactory().createJdbcRowSet();\n\ninstead of statement conncection and resultSet you use RowSet commands\nto set the uname, pw and url. \n\nthen simply execute it. ','public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n        try(JdbcRowSet jrs = RowSetProvider.newFactory().createJdbcRowSet()){\n            String query = \"Select * from employees limit 100\";\n            jrs.setCommand(query);\n            jrs.setUrl(url);\n            jrs.setUsername(user);\n            jrs.setPassword(pw);\n            jrs.execute();\n            while(jrs.next()){\n                System.out.println(jrs.getString(\"first_name\") + \" \" + jrs.getString(\"last_name\"));\n            }    \n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n}','JDBC',0,0,NULL,5),(2143,'will not compile the proper way to create a JdbcRowSet is\n\n	JdbcRowSet jrs = RowSetProvider.newFactory().createJdbcRowSet()','public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n        try(JdbcRowSet jrs = RowSetProvider.createJdbcRowSet()){\n            String query = \"Select * from employees limit 100\";\n            jrs.setCommand(query);\n            jrs.setUrl(url);\n            jrs.setUsername(user);\n            jrs.setPassword(pw);\n            jrs.execute();\n            while(jrs.next()){\n                System.out.println(jrs.getString(\"first_name\") + \" \" + jrs.getString(\"last_name\"));\n            }    \n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n}','JDBC',0,0,NULL,5),(2144,'Will not compil creating a JdbcRowSet throws an sql exception so it is usually\ncreated in a try() - catch block, \n\nNot to mention every other of those commands throws an sqlexception','public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n            JdbcRowSet jrs = RowSetProvider.newFactory().createJdbcRowSet();\n            String query = \"Select * from employees limit 100\";\n            jrs.setCommand(query);\n            jrs.setUrl(url);\n            jrs.setUsername(user);\n            jrs.setPassword(pw);\n            jrs.execute();\n            while(jrs.next()){\n                System.out.println(jrs.getString(\"first_name\") + \" \" + jrs.getString(\"last_name\"));\n            }    \n    }\n}','JDBC',0,0,NULL,5),(2145,'NullPointerException, the username and password and url were not set, \n\nIT could Also throw an sqlexception for this,\n\nexecute fills the rowset with data. Just alswyas make sure that data is set.','public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n        try(JdbcRowSet jrs = RowSetProvider.newFactory().createJdbcRowSet()){\n            String query = \"Select * from employee limit 100\";\n            jrs.setCommand(query);\n            jrs.execute();\n            while(jrs.next()){\n                System.out.println(jrs.getString(\"first_name\") + \" \" + jrs.getString(\"last_name\"));\n            }    \n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n}','JDBC',0,0,NULL,5),(2146,'RowSet extends Result set so it is a result set\n\nseting the type still uses the resultset types. ','public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n        try(JdbcRowSet jrs = RowSetProvider.newFactory().createJdbcRowSet()){\n            String query = \"Select * from employees limit 100\";\n            jrs.setCommand(query);\n            jrs.setUrl(url);\n            jrs.setUsername(user);\n            jrs.setPassword(pw);\n            jrs.setType(ResultSet.TYPE_SCROLL_INSENSITIVE);\n            jrs.execute();\n            while(jrs.next()){\n                System.out.println(jrs.getString(\"first_name\") + \" \" + jrs.getString(\"last_name\"));\n            }    \n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n}','JDBC',0,0,NULL,5),(2147,'will not compile,\n\nResultSet.TYPE_SCROLL_INSENSITIVE\n\nThose fields are inherited from ResultSet. \n\nFields inherited from interface java.sql.ResultSet\nCONCUR_READ_ONLY, \nCONCUR_UPDATABLE, \nTYPE_FORWARD_ONLY, \nTYPE_SCROLL_INSENSITIVE, \nTYPE_SCROLL_SENSITIVE','public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n        try(JdbcRowSet jrs = RowSetProvider.newFactory().createJdbcRowSet()){\n            String query = \"Select * from employees limit 100\";\n            jrs.setCommand(query);\n            jrs.setUrl(url);\n            jrs.setUsername(user);\n            jrs.setPassword(pw);\n            jrs.setType(RowSet.TYPE_SCROLL_INSENSITIVE);\n            jrs.execute();\n            while(jrs.next()){\n                System.out.println(jrs.getString(\"first_name\") + \" \" + jrs.getString(\"last_name\"));\n            }    \n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n}','JDBC',0,0,NULL,5),(2148,'SQLException, you cannot Update insert or delete with execute() on a RowSet.\n\nto update the data you just update the data on your JdbcRowSet.\n\nthere are no executeQuery() or executeUpdate methods for RowSets. ','public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n        try(JdbcRowSet jrs = RowSetProvider.newFactory().createJdbcRowSet()){\n            String query = \"Update employees set first_name = \'Mike\' where emp_no = 789\";\n            jrs.setCommand(query);\n            jrs.setUrl(url);\n            jrs.setUsername(user);\n            jrs.setPassword(pw);\n            jrs.setType(ResultSet.TYPE_SCROLL_INSENSITIVE);\n            jrs.execute();\n            while(jrs.next()){\n                System.out.println(jrs.getString(\"first_name\") + \" \" + jrs.getString(\"last_name\"));\n            }    \n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n}','JDBC',0,0,NULL,5),(2149,'will not compile there is no executeUpdate() for RowSets,\nbecause you do not update insert or delete in this way. You use the update api.\n\nThis would be a sql exception anyway because you cannot perform update \ninsert or deletes with a sql command and a jdbc rowset.','public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n        try(JdbcRowSet jrs = RowSetProvider.newFactory().createJdbcRowSet()){\n            String query = \"Update employees set first_name = \'Mike\' where emp_no = 789\";\n            jrs.setCommand(query);\n            jrs.setUrl(url);\n            jrs.setUsername(user);\n            jrs.setPassword(pw);\n            jrs.setType(ResultSet.TYPE_SCROLL_INSENSITIVE);\n            jrs.executeUpdate();\n            while(jrs.next()){\n                System.out.println(jrs.getString(\"first_name\") + \" \" + jrs.getString(\"last_name\"));\n            }    \n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n}','JDBC',0,0,NULL,5),(2150,'will not compiles there is no executeQuery() with Jdbcrowsets. The Command is \nexecute()','public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n        try(JdbcRowSet jrs = RowSetProvider.newFactory().createJdbcRowSet()){\n            String query = \"Select * from employees limit 100\";\n            jrs.setCommand(query);\n            jrs.setUrl(url);\n            jrs.setUsername(user);\n            jrs.setPassword(pw);\n            jrs.setType(ResultSet.TYPE_SCROLL_INSENSITIVE);\n            jrs.executeQuery();\n            while(jrs.next()){\n                System.out.println(jrs.getString(\"first_name\") + \" \" + jrs.getString(\"last_name\"));\n            }    \n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n}','JDBC',0,0,NULL,5),(2151,'first set the user pw and url with:\n\n	       jrs.setUrl(url);\n            jrs.setUsername(user);\n            jrs.setPassword(pw);\n\nthen set the command: \n		String query = \"Select * from employees limit 100\";\n            jrs.setCommand(query);\n\nthen use the only command to execute:\n\nexecute()','How do you execute a query with a JdbcRowSet object ? ','JDBC',0,0,NULL,5),(2152,'NullpointerExeption you never set the command, could be an sqlException too\n\ndont forget to:\n\nsetCommand(query);','public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n        try(JdbcRowSet jrs = RowSetProvider.newFactory().createJdbcRowSet()){\n            String query = \"Select * from employees limit 100\";\n            jrs.setUrl(url);\n            jrs.setUsername(user);\n            jrs.setPassword(pw);\n            jrs.setType(ResultSet.TYPE_SCROLL_INSENSITIVE);\n            jrs.execute();\n            while(jrs.next()){\n                System.out.println(jrs.getString(\"first_name\") + \" \" + jrs.getString(\"last_name\"));\n            }    \n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n}','JDBC',0,0,NULL,5),(2153,'will not copile the method is setCommand not setQuery','public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n        try(JdbcRowSet jrs = RowSetProvider.newFactory().createJdbcRowSet()){\n            String query = \"Select * from employees limit 100\";\n            jrs.setQuery(query);\n            jrs.setUrl(url);\n            jrs.setUsername(user);\n            jrs.setPassword(pw);\n            jrs.execute();\n            while(jrs.next()){\n                System.out.println(jrs.getString(\"first_name\") + \" \" + jrs.getString(\"last_name\"));\n            }    \n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n}','JDBC',0,0,NULL,5),(2154,'','You can update data in the database with a resultset but thats not on the \nexam so DONT WORRY ABOUT IT. \n\nyou can do the same with RowSet and that IS on the exam so thats what you shuld focus on','JDBC',0,0,NULL,5),(2155,'change the last employees first name to \'Big Max\'','public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n        try(JdbcRowSet jrs = RowSetProvider.newFactory().createJdbcRowSet()){\n            String query = \"Select * from employees limit 100\";\n            jrs.setCommand(query);\n            jrs.setUrl(url);\n            jrs.setUsername(user);\n            jrs.setPassword(pw);\n            jrs.execute();\n            while(jrs.next()){\n                System.out.println(jrs.getString(\"first_name\") + \" \" + jrs.getString(\"last_name\"));\n            }\n            jrs.last();\n            jrs.updateString(\"first_name\",\"Big Max\");\n            jrs.updateRow();\n            \n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n}','JDBC',0,0,NULL,5),(2156,'This will print nothing, the cursor is already at the last poisiton so\nthere is not next for jrs to go to to fix add \n\n	jrs.first()\n\njust before the while loop.','public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n        try(JdbcRowSet jrs = RowSetProvider.newFactory().createJdbcRowSet()){\n            String query = \"Select * from employees limit 100\";\n            jrs.setCommand(query);\n            jrs.setUrl(url);\n            jrs.setUsername(user);\n            jrs.setPassword(pw);\n            jrs.execute();\n            \n            jrs.last();\n            jrs.updateString(\"first_name\",\"Big Max\");\n            jrs.updateRow();\n\n            while(jrs.next()){\n                System.out.println(jrs.getString(\"first_name\") + \" \" + jrs.getString(\"last_name\"));\n            }\n            \n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n}','JDBC',0,0,NULL,5),(2157,'will show the updated rows ','public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n        try(JdbcRowSet jrs = RowSetProvider.newFactory().createJdbcRowSet()){\n            String query = \"Select * from employees limit 100\";\n            jrs.setCommand(query);\n            jrs.setUrl(url);\n            jrs.setUsername(user);\n            jrs.setPassword(pw);\n            jrs.execute();\n            \n            jrs.last();\n            jrs.updateString(\"first_name\",\"Big Max\");\n            jrs.updateRow();\n            jrs.first();\n            while(jrs.next()){\n                System.out.println(jrs.getString(\"first_name\") + \" \" + jrs.getString(\"last_name\"));\n            }\n            \n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n}','JDBC',0,0,NULL,5),(2158,'will update the first row of the RowSet and write teh changes to the database\n\nprints: Big Max Big Dick Bisesi','public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n        try(JdbcRowSet jrs = RowSetProvider.newFactory().createJdbcRowSet()){\n            String query = \"Select * from employees limit 100\";\n            jrs.setCommand(query);\n            jrs.setUrl(url);\n            jrs.setUsername(user);\n            jrs.setPassword(pw);\n            jrs.execute();\n            jrs.first();\n            jrs.updateString(\"first_name\",\"Big Max\");\n            jrs.updateString(\"last_name\",\"Big Dick Bisesi\");\n            jrs.updateRow();\n            System.out.println(jrs.getString(\"first_name\") + \" \" + jrs.getString(\"last_name\"));\n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n}','JDBC',0,0,NULL,5),(2159,'SQLException: Invalid State\n\nexecute() was never used.','public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n        try(JdbcRowSet jrs = RowSetProvider.newFactory().createJdbcRowSet()){\n            String query = \"Select * from employees limit 100\";\n            jrs.setCommand(query);\n            jrs.setUrl(url);\n            jrs.setUsername(user);\n            jrs.setPassword(pw);\n            jrs.first();\n            jrs.updateString(\"first_name\",\"Big Max\");\n            jrs.updateString(\"last_name\",\"Big Dick Bisesi\");\n            jrs.updateRow();\n            System.out.println(jrs.getString(\"first_name\") + \" \" + jrs.getString(\"last_name\"));\n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n}','JDBC',0,0,NULL,5),(2160,'NullPointerException the cursor is before the first row','public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n        try(JdbcRowSet jrs = RowSetProvider.newFactory().createJdbcRowSet()){\n            String query = \"Select * from employees limit 100\";\n            jrs.setCommand(query);\n            jrs.setUrl(url);\n            jrs.setUsername(user);\n            jrs.setPassword(pw);\n            jrs.execute();\n            jrs.beforeFirst();\n            jrs.updateString(\"first_name\",\"Big Max\");\n            jrs.updateString(\"last_name\",\"Big Dick Bisesi\");\n            jrs.updateRow();\n            System.out.println(jrs.getString(\"first_name\") + \" \" + jrs.getString(\"last_name\"));\n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n}','JDBC',0,0,NULL,5),(2161,'NPE moving to absolute(0) moves to before the first row. \n\nmoving abosolute(-n) starts at the last row and moves the cursor backward','public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n        try(JdbcRowSet jrs = RowSetProvider.newFactory().createJdbcRowSet()){\n            String query = \"Select * from employees limit 100\";\n            jrs.setCommand(query);\n            jrs.setUrl(url);\n            jrs.setUsername(user);\n            jrs.setPassword(pw);\n            jrs.execute();\n            jrs.absolute(0);\n            jrs.updateString(\"first_name\",\"Big Max\");\n            jrs.updateString(\"last_name\",\"Big Dick Bisesi\");\n            jrs.updateRow();\n            System.out.println(jrs.getString(\"first_name\") + \" \" + jrs.getString(\"last_name\"));\n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n}','JDBC',0,0,NULL,5),(2162,'changes the fifth row in the rowset.\n\nAngela Bit Butt Horton','public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n        try(JdbcRowSet jrs = RowSetProvider.newFactory().createJdbcRowSet()){\n            String query = \"Select * from employees limit 100\";\n            jrs.setCommand(query);\n            jrs.setUrl(url);\n            jrs.setUsername(user);\n            jrs.setPassword(pw);\n            jrs.execute();\n            jrs.absolute(5);\n            jrs.updateString(\"first_name\",\"Angela\");\n            jrs.updateString(\"last_name\",\"Big Butt Horton\");\n            jrs.updateRow();\n            System.out.println(jrs.getString(\"first_name\") + \" \" + jrs.getString(\"last_name\"));\n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n}','JDBC',0,0,NULL,5),(2163,'jrs.moveToInsertRow();\njrs.updateString(\"first_name\",\"Jonny\");\njrs.udateString...\njrs.updateInt...\njrs.insertRow();\njrs.moveToCurrentRow();','How to insert a new row into a RowSet ?','JDBC',0,0,NULL,5),(2164,'sqlexception: invalid state there is no rowset to perforem these changes on \nbecause execute() wasn\'t called.','public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n        try(JdbcRowSet jrs = RowSetProvider.newFactory().createJdbcRowSet()){\n            String query = \"Select * from employees limit 100\";\n            jrs.setCommand(query);\n            jrs.setUrl(url);\n            jrs.setUsername(user);\n            jrs.setPassword(pw);\n            \n            jrs.moveToInsertRow();\n            jrs.updateInt(\"emp_no\",12345);\n            jrs.updateString(\"firs_name\",\"Blue\");\n            jrs.updateString(\"last_name\",\"Bella\");\n            jrs.insertRow();\n            \n            //System.out.println(jrs.getString(\"first_name\") + \" \" + jrs.getString(\"last_name\"));\n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n}','JDBC',0,0,NULL,5),(2165,'Blue Bella this prints the values just inserted in the insert row.','public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n        try(JdbcRowSet jrs = RowSetProvider.newFactory().createJdbcRowSet()){\n            String query = \"Select * from employees limit 100\";\n            jrs.setCommand(query);\n            jrs.setUrl(url);\n            jrs.setUsername(user);\n            jrs.setPassword(pw);\n            \n            jrs.execute();\n            \n            jrs.moveToInsertRow();\n            jrs.updateInt(\"emp_no\", 789);\n            jrs.updateString(\"first_name\",\"Blue\");\n            jrs.updateString(\"last_name\",\"Bella\");\n            jrs.insertRow();\n            \n            System.out.println(jrs.getString(\"first_name\") + \" \" + jrs.getString(\"last_name\"));\n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n}','JDBC',0,0,NULL,5),(2166,'null null','public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n        try(JdbcRowSet jrs = RowSetProvider.newFactory().createJdbcRowSet()){\n            String query = \"Select * from employees limit 100\";\n            jrs.setCommand(query);\n            jrs.setUrl(url);\n            jrs.setUsername(user);\n            jrs.setPassword(pw);\n            jrs.execute();\n            jrs.moveToInsertRow();\n            System.out.println(jrs.getString(\"first_name\") + \" \" + jrs.getString(\"last_name\"));\n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n}','JDBC',0,0,NULL,5),(2167,'NPE setURL was left out ','public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n        try(JdbcRowSet jrs = RowSetProvider.newFactory().createJdbcRowSet()){\n            String query = \"Select * from employees limit 100\";\n            jrs.setCommand(query);\n            jrs.setUsername(user);\n            jrs.setPassword(pw);\n            jrs.execute();\n            jrs.moveToInsertRow();\n            System.out.println(jrs.getString(\"first_name\") + \" \" + jrs.getString(\"last_name\"));\n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n}','JDBC',0,0,NULL,5),(2168,'will not compile non static variable cannot be referenced from static context','public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n        try(JdbcRowSet jrs = RowSetProvider.newFactory().createJdbcRowSet()){\n            String query = \"Select * from employees limit 100\";\n            jrs.setCommand(query);\n            jrs.setUrl(url);\n            jrs.setUsername(user);\n            jrs.setPassword(pw);\n            jrs.execute();\n            \n            jrs.addRowSetListener(new MyRowSetListener());\n            \n            jrs.moveToInsertRow();\n            jrs.updateInt(\"emp_no\",3);\n            jrs.updateString(\"first_name\",\"Micheal\");\n            jrs.updateString(\"last_name\",\"Boyd\");\n            jrs.insertRow();\n            \n            jrs.moveToCurrentRow();\n            \n            while(jrs.next()){\n                System.out.println(jrs.getString(\"first_name\") + \" \" + jrs.getString(\"last_name\"));\n            }\n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n    \n    class MyRowSetListener implements RowSetListener {\n        \n        public void rowChanged(RowSetEvent event) {\n            if(event.getSource() instanceof RowSet) {\n                try{\n                    ((RowSet) event.getSource()).execute();\n                    //re excute the query every time the rowset is updchanged to update it\n                } catch(SQLException e){\n                    \n                }\n                \n            }\n        }\n        \n        public void cursorMoved(RowSetEvent e) { }\n        public void rowSetChanged(RowSetEvent e){ }\n    }\n}','JDBC',0,0,NULL,5),(2169,'create a rowsetlistener','\npublic class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n        try(JdbcRowSet jrs = RowSetProvider.newFactory().createJdbcRowSet()){\n            String query = \"Select * from employees limit 100\";\n            jrs.setCommand(query);\n            jrs.setUrl(url);\n            jrs.setUsername(user);\n            jrs.setPassword(pw);\n            jrs.execute();\n            \n            jrs.addRowSetListener(new MyRowSetListener());\n            \n            jrs.moveToInsertRow();\n            jrs.updateInt(\"emp_no\",3);\n            jrs.updateString(\"first_name\",\"Micheal\");\n            jrs.updateString(\"last_name\",\"Boyd\");\n            jrs.insertRow();\n            \n            jrs.moveToCurrentRow();\n            \n            while(jrs.next()){\n                System.out.println(jrs.getString(\"first_name\") + \" \" + jrs.getString(\"last_name\"));\n            }\n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n    \n    static class MyRowSetListener implements RowSetListener {\n        \n        public void rowChanged(RowSetEvent event) {\n            if(event.getSource() instanceof RowSet) {\n                try{\n                    ((RowSet) event.getSource()).execute();\n                    //re excute the query every time the rowset is updchanged to update it\n                } catch(SQLException e){\n                    \n                }\n                \n            }\n        }\n        \n        public void cursorMoved(RowSetEvent e) { }\n        public void rowSetChanged(RowSetEvent e){ }\n    }\n}','JDBC',0,0,NULL,5),(2170,'got it','a JdbcRowSet is connected which means its update are actively written to\nthe db, a CachedRowSet and all the rest are disconnected which means they\ncan connect to get the data disconnect change the data then re connect to \nupdate their changes, thats what a cache is.','JDBC',0,0,NULL,5),(2171,'CachedRowSet cs = RowSetProvider.newFactory().createCachedRowSet();','how do you create a CachedRowSet','JDBC',0,0,NULL,5),(2172,'will not compile thats not how you create a RowSet. you should add \n\n	createJdbcRowSet();','\npublic class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n        try(JdbcRowSet jrs = RowSetProvider.newFactory().createJdbcRowSet()){\n            String query = \"Select * from employees limit 100\";\n            jrs.setCommand(query);\n            jrs.setUrl(url);\n            jrs.setUsername(user);\n            jrs.setPassword(pw);\n            jrs.execute();\n            \n            jrs.addRowSetListener(new MyRowSetListener());\n            \n            jrs.moveToInsertRow();\n            jrs.updateInt(\"emp_no\",3);\n            jrs.updateString(\"first_name\",\"Micheal\");\n            jrs.updateString(\"last_name\",\"Boyd\");\n            jrs.insertRow();\n            \n            jrs.moveToCurrentRow();\n            \n            while(jrs.next()){\n                System.out.println(jrs.getString(\"first_name\") + \" \" + jrs.getString(\"last_name\"));\n            }\n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n    \n    static class MyRowSetListener implements RowSetListener {\n        \n        public void rowChanged(RowSetEvent event) {\n            if(event.getSource() instanceof RowSet) {\n                try{\n                    ((RowSet) event.getSource()).execute();\n                    //re excute the query every time the rowset is updchanged to update it\n                } catch(SQLException e){\n                    \n                }\n                \n            }\n        }\n        \n        public void cursorMoved(RowSetEvent e) { }\n        public void rowSetChanged(RowSetEvent e){ }\n    }\n}','JDBC',0,0,NULL,5),(2173,'acceptChanges();','When your done changing CachedRowSet what do you call?','JDBC',0,0,NULL,5),(2174,'Connection conn = DriverManager..\nconn.setAutoCommit(false); // begin transaction','how do you begin a transaction in jdbc ?','JDBC',0,0,NULL,5),(2175,'you exlicityly commmit the current transaction\n\nyou excplicityl roll back the current transaction\n\nthere is a failure that forces automatic rollback.','A jdbc transaction includes all of the sQL queries you execute until either ...?','JDBC',0,0,NULL,5),(2176,'start a transacation by setting autoCommit(false), then make sure you commit()\nit otherwise everything you just did will be automatically rolledback. \n\nAs soon you commit() another transaction is started.\n\nThere can only be one transaction at a time. ','public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n       try(Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\")){\n           conn.setAutoCommit(false);\n           Statement stmt = conn.createStatement();\n           stmt.execute(\"Insert into employees values (601,\'Dixon\',\'Ramey\')\");\n           stmt.execute(\"Insert into employees values (602,\'Alex\',\'Ramey\')\");\n           stmt.execute(\"Insert into employees values (603,\'Kevin\',\'Ramey\')\");\n           \n           conn.commit();\n           \n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n    \n}','JDBC',0,0,NULL,5),(2177,'will not compile, Connection is scoped only within that try block because it is\nin a try with resources, conn in the catch is out of scope. ','public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n       try(Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\")){\n           conn.setAutoCommit(false);\n           Statement stmt = conn.createStatement();\n           stmt.execute(\"Insert into employees values (601,\'Dixon\',\'Ramey\')\");\n           stmt.execute(\"Insert into employees values (602,\'Alex\',\'Ramey\')\");\n           stmt.execute(\"Insert into employees values (603,\'Kevin\',\'Ramey\')\");\n           \n           conn.commit();\n           \n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n            \n            conn.rollback();\n        }\n    }\n    \n}','JDBC',0,0,NULL,5),(2178,'WNC DriverManager.getConnection throws a sqlexception ','public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\");\n  \n        try{   \n        \n            conn.setAutoCommit(false);\n           Statement stmt = conn.createStatement();\n           stmt.execute(\"Insert into employees values (601,\'Dixon\',\'Ramey\')\");\n           stmt.execute(\"Insert into employees values (602,\'Alex\',\'Ramey\')\");\n           stmt.execute(\"Insert into employees values (603,\'Kevin\',\'Ramey\')\");\n           \n           conn.commit();\n           \n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n            \n            conn.rollback();\n        }\n    }\n    \n}','JDBC',0,0,NULL,5),(2179,'if the insertions go as planned then commit the transaction otherwise try again\n','public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n       try(Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\")){\n           conn.setAutoCommit(false);\n           Statement stmt = conn.createStatement();\n           int updatecount = 0;\n           \n           updatecount += stmt.executeUpdate(\"Insert into employees values (701,\'Dixon\',\'Ramey\')\");\n           updatecount += stmt.executeUpdate(\"Insert into employees values (702,\'Alex\',\'Ramey\')\");\n           updatecount += stmt.executeUpdate(\"Insert into employees values (703,\'Kevin\',\'Ramey\')\");\n           \n           if(updatecount == 3){\n               System.out.println(\"Transaction complete\");\n                conn.commit();\n           } else {\n               System.out.println(\"Something didn\'t go through\");\n               conn.rollback();\n           }\n\n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n    \n}','JDBC',0,0,NULL,5),(2180,'sqlexception transaction has not been started. setAutoCommit(false) to start one','public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n       try(Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\")){\n           Statement stmt = conn.createStatement();\n           int updatecount = 0;\n           \n           updatecount += stmt.executeUpdate(\"Insert into employees values (701,\'Dixon\',\'Ramey\')\");\n           updatecount += stmt.executeUpdate(\"Insert into employees values (702,\'Alex\',\'Ramey\')\");\n           updatecount += stmt.executeUpdate(\"Insert into employees values (703,\'Kevin\',\'Ramey\')\");\n           \n           if(updatecount == 3){\n               System.out.println(\"Transaction complete\");\n                conn.commit();\n           } else {\n               System.out.println(\"Something didn\'t go through\");\n               conn.rollback();\n           }\n\n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n    \n}','JDBC',0,0,NULL,5),(2181,'setting autocommit to true will committ any current transaction and turn auto commit back on','public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n       try(Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\")){\n           conn.setAutoCommit(false);\n           Statement stmt = conn.createStatement();\n           int updatecount = 0;\n           \n           updatecount += stmt.executeUpdate(\"Insert into employees values (706,\'Dixon\',\'Ramey\')\");\n           updatecount += stmt.executeUpdate(\"Insert into employees values (707,\'Alex\',\'Ramey\')\");\n           updatecount += stmt.executeUpdate(\"Insert into employees values (708,\'Kevin\',\'Ramey\')\");\n           \n           if(updatecount == 3){\n               System.out.println(\"Transaction complete\");\n                conn.setAutoCommit(true);\n           } else {\n               System.out.println(\"Something didn\'t go through\");\n               conn.rollback();\n           }\n\n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n    \n}','JDBC',0,0,NULL,5),(2182,'FALSE ! Connection objects','JDBC:\n\nYou call setAutoCommit(false) on Statement ojbects ','JDBC',0,0,NULL,5),(2183,'','a savepoint represents a point in the transaction that you can rollback to.\nit is created from a connection object.','JDBC',0,0,NULL,5),(2184,'how to use a savepoint','public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n       try(Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\")){\n           conn.setAutoCommit(false);//start a transaction\n           Statement stmt = conn.createStatement();\n           int updatecount = 0;\n           \n           updatecount += stmt.executeUpdate(\"Insert into employees values (710,\'steve\',\'davidson\')\");\n           updatecount += stmt.executeUpdate(\"Insert into employees values (711,\'Alex\',\'The great\')\");\n           updatecount += stmt.executeUpdate(\"Insert into employees values (713,\'baily\',\'Ramey\')\");\n           Savepoint sp1 = conn.setSavepoint();\n           \n           stmt.executeUpdate(\"Insert into employees values(801,\'Whitey\',\'Ford\')\");\n           \n           conn.rollback();\n\n           ResultSet rs = stmt.executeQuery(\"select * from employees where first_name = \\\'Whitey\\\'\");\n           \n           while(rs.next()){\n               System.out.println(rs.getInt(\"emp_no\"));\n           }\n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n    \n}','JDBC',0,0,NULL,5),(2185,'Prepared and Callable statement setXXX() methods number parameters from \n1 not 0. ','public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n       try(Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\")){\n          String call = \"{CALL REMOVEBOOKS(?,?)}\";\n          String titleToRemove = null;\n          int maxBooks = 0;\n          CallableStatement cstmt = conn.prepareCall(call);\n          String titles = \"%Hero%\";\n          int numBooksRemoved;\n          cstmt.setInt(0,maxBooks);\n          cstmt.setString(1,titleToRemove);\n          cstmt.registerOutParameter(0,java.sql.Types.INTEGER);\n          cstmt.execute();\n          numBooksRemoved = cstmt.getInt(0); \n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n    \n}','JDBC',0,0,NULL,5),(2186,'executeQuery() for callable and preparedstatements must not have the query passed\nin as a parameter. \n\nAlso the indexes are numbered incorectly','public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n       try(Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\")){\n          String call = \"{CALL REMOVEBOOKS(?,?)}\";\n          String titleToRemove = null;\n          int maxBooks = 0;\n          CallableStatement cstmt = conn.prepareCall(call);\n          String titles = \"%Hero%\";\n          int numBooksRemoved;\n          cstmt.setInt(0,maxBooks);\n          cstmt.setString(1,titleToRemove);\n          cstmt.registerOutParameter(0,java.sql.Types.INTEGER);\n          cstmt.executeQuery(query);\n          numBooksRemoved = cstmt.getInt(0); \n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n    \n}','JDBC',0,0,NULL,5),(2187,'sqlexception executeQuery() for callable and prepared statements must not have\nthe query passed in as a parameter ','public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n       try(Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\")){\n          String call = \"{CALL REMOVEBOOKS(?,?)}\";\n          String titleToRemove = null;\n          String query = \"select * from Books\";\n          int maxBooks = 0;\n          CallableStatement cstmt = conn.prepareCall(call);\n          String titles = \"%Hero%\";\n          int numBooksRemoved;\n          cstmt.setInt(1,maxBooks);\n          cstmt.setString(2,titleToRemove);\n          cstmt.registerOutParameter(1,java.sql.Types.INTEGER);\n          cstmt.executeQuery(query);\n          numBooksRemoved = cstmt.getInt(1);\n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n    \n}','JDBC',0,0,NULL,5),(2188,'sqlexception for registering the out parameter after the execute call.','public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n       try(Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\")){\n          String call = \"{CALL REMOVEBOOKS(?,?)}\";\n          String titleToRemove = null;\n          String query = \"select * from Books\";\n          int maxBooks = 0;\n          CallableStatement cstmt = conn.prepareCall(call);\n          String titles = \"%Hero%\";\n          int numBooksRemoved;\n          cstmt.setInt(1,maxBooks);\n          cstmt.setString(2,titleToRemove);\n          cstmt.execute();\n          cstmt.registerOutParameter(1,java.sql.Types.INTEGER);\n          numBooksRemoved = cstmt.getInt(1);\n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n    \n}','JDBC',0,0,NULL,5),(2189,'this stored proceudre does not return a resultset, so while it will compile\nbcasue executeQuery() will return a ResultSet to rs. cstmt.getInt(1); will throw\na sql exception.','public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n       try(Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\")){\n          String call = \"{CALL REMOVEBOOKS(?,?)}\";\n          String titleToRemove = null;\n          String query = \"select * from Books\";\n          int maxBooks = 0;\n          CallableStatement cstmt = conn.prepareCall(call);\n          String titles = \"%Hero%\";\n          int numBooksRemoved;\n          cstmt.setInt(1,maxBooks);\n          cstmt.setString(2,titleToRemove);\n          cstmt.registerOutParameter(1,java.sql.Types.INTEGER);\n          ResultSet rs = cstmt.executeQuery();\n          rs.next();\n          numBooksRemoved = cstmt.getInt(1);\n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n    \n}','JDBC',0,0,NULL,5),(2190,'this is the way to use a CallableStatement.','public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n       try(Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\")){\n          String call = \"{CALL REMOVEBOOKS(?,?)}\";\n          String titleToRemove = null;\n          String query = \"select * from Books\";\n          int maxBooks = 0;\n          CallableStatement cstmt = conn.prepareCall(call);\n          String titles = \"%Hero%\";\n          int numBooksRemoved;\n          cstmt.setInt(1,maxBooks);\n          cstmt.setString(2,titleToRemove);\n          cstmt.registerOutParameter(1,java.sql.Types.INTEGER);\n          cstmt.execute();\n          numBooksRemoved = cstmt.getInt(1);\n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }  \n}','JDBC',0,0,NULL,5),(2191,'Will not compile RowSetFactory does not implement autocloseable','try(RowSetFactory rsf = RowSetProvider.newFactory()) {\nRowSet rws = rsf.createRowSet();','JDBC',0,0,NULL,5),(2192,'this database will be unchanged. the error here is that acceptChanges() was\nnever called to reconcile the changes made with the in memory version and the\nactual db.\n\nthe database being offline anytime after the execute() is invoked in irrelevent\n','String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n       //try(Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\")){\n        \n        try(CachedRowSet crs = RowSetProvider.newFactory().createCachedRowSet()) {\n            String query = \"Select * From employee\";\n            crs.setCommand(query);\n            crs.setUrl(url);\n            crs.setUsername(user);\n            crs.setPassword(pw);\n            crs.execute();\n            crs.last();\n            crs.updateString(\"last_name\", \"Sullivan\");\n            //database goes offline\n            crs.moveToInsertRow();\n            crs.updateInt(\"ID\",101);\n            crs.updateString(\"first_name\",\"Billy\");\n            crs.updateString(\"last_name\",\"Blue\");\n            crs.insertRow();\n            crs.moveToCurrentRow();\n            crs.absolute(10);\n            crs.deleteRow();\n            //db backonline\n        } catch(SQLException e){\n            System.out.println(e);\n        }','JDBC',0,0,NULL,5),(2193,'crs.insertRow();\n\nalso crs.acceptChanges()','public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n       //try(Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\")){\n        \n        try(CachedRowSet crs = RowSetProvider.newFactory().createCachedRowSet()) {\n            String query = \"Select * From employee\";\n            crs.setCommand(query);\n            crs.setUrl(url);\n            crs.setUsername(user);\n            crs.setPassword(pw);\n            crs.execute();\n            crs.last();\n            crs.updateString(\"last_name\", \"Sullivan\");\n            //database goes offline\n            crs.moveToInsertRow();\n            crs.updateInt(\"ID\",101);\n            crs.updateString(\"first_name\",\"Billy\");\n            crs.updateString(\"last_name\",\"Blue\");\n            crs.moveToCurrentRow();\n            crs.absolute(10);\n            crs.deleteRow();\n            //db backonline\n        } catch(SQLException e){\n            System.out.println(e);\n        }\n    }  \n}\nwhats missing here ?','JDBC',0,0,NULL,5),(2194,'crs.execute() is missing','public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n       //try(Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\")){\n        \n        try(CachedRowSet crs = RowSetProvider.newFactory().createCachedRowSet()) {\n            String query = \"Select * From employee\";\n            crs.setCommand(query);\n            crs.setUrl(url);\n            crs.setUsername(user);\n            crs.setPassword(pw);\n            crs.last();\n            crs.updateString(\"last_name\", \"Sullivan\");\n            //database goes offline\n            crs.moveToInsertRow();\n            crs.updateInt(\"ID\",101);\n            crs.updateString(\"first_name\",\"Billy\");\n            crs.updateString(\"last_name\",\"Blue\");\n            crs.insertRow();\n            crs.moveToCurrentRow();\n            crs.absolute(10);\n            crs.deleteRow();\n            //db backonline\n        } catch(SQLException e){\n            System.out.println(e);\n        }\n    }  \n}','JDBC',0,0,NULL,5),(2195,'the first two updates are executed, but then a sqlexception is thrown because \na transaction was never started to rollback.\n\nyou would have had to setAutoCommit(false) to start a transaction.\n\nThe first two were automatically commited. ','public class Hello {\n    public static void main(String[] args){\n        \n        boolean businessrule = true;\n       try(Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\")){\n            String query = \"Inser into ...\";\n            String query2 = \"Updat table...\";\n            \n            Statement st = conn.createStatement();\n            \n            st.executeUpdate(query);\n            st.executeUpdate(query2);\n            \n            if(businessrule){\n                conn.rollback();\n            }\n        } catch(SQLException e){\n            System.out.println(e);\n        }\n    }  \n}','JDBC',0,0,NULL,5),(2196,'if the business rule remains false then both updates will be comitted.\nsince autocommit is false.','public class Hello {\n    public static void main(String[] args){\n        \n        boolean businessrule = false;\n       try(Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\")){\n            conn.setAutoCommit(false);\n            String query = \"Inser into ...\";\n            String query2 = \"Updat table...\";\n            \n            Statement st = conn.createStatement();\n            \n            st.executeUpdate(query);\n            st.executeUpdate(query2);\n            \n            if(businessrule){\n                conn.rollback();\n            } else {\n                conn.commit();\n            }\n        } catch(SQLException e){\n            System.out.println(e);\n        }\n    }  \n}','JDBC',0,0,NULL,5),(2197,'no rows are added at all, the rollback() rolls back to the savepoint but erasing the\nsecond update, but because there is no commit() at all the first update will also be \nrolledback when the try block closes for good becaus autocommitmode was set\nto false. ','public class Hello {\n    public static void main(String[] args){\n\n       try(Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\")){\n            conn.setAutoCommit(false);\n            String query = \"Inser into ...\";\n            String query2 = \"Updat table...\";\n            Statement st = conn.createStatement();\n            \n            st.executeUpdate(query);\n            \n            Savepoint sp1 = conn.setSavepoint();\n            \n            st.executeUpdate(query2);\n            \n            conn.rollback();\n           \n        } catch(SQLException e){\n            System.out.println(e);\n        }\n    }  \n}','JDBC',0,0,NULL,5),(2198,'First entry:\nMicheal Boyd\nLast entry:\nKenroku Malabarba\nrow: 20\nKyoichi Maliniak\nrow: 30\nGuoxiang Nooteboom\nupdate executed\njava.sql.SQLException: Operation not allowed after ResultSet closed\n\nAfter re executing a statement, all ResultSets tied to that statemnt are \nautomatically closed','public class Hello {\n    public static void main(String[] args){\n        try {\n            Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\");\n            Statement st = conn.createStatement();\n            String q = \"Select * From employees limit 100\";\n            ResultSet rs = st.executeQuery(q);\n            \n            rs.first();\n            System.out.println(\"First entry:\");\n            System.out.println(rs.getString(\"first_name\") + \" \" +rs.getString(\"last_name\"));\n            \n            rs.last();\n            System.out.println(\"Last entry:\");\n            System.out.println(rs.getString(\"first_name\") + \" \" +rs.getString(\"last_name\"));\n            \n            rs.absolute(20);\n            System.out.println(\"row: \"+ rs.getRow());\n            System.out.println(rs.getString(\"first_name\") + \" \" +rs.getString(\"last_name\"));\n            \n            rs.relative(10);\n            System.out.println(\"row: \"+ rs.getRow());\n            System.out.println(rs.getString(\"first_name\") + \" \" +rs.getString(\"last_name\")); \n            \n            String update = \"insert into employees values(09,\'Broden\',\'Chapman\')\";\n            boolean results = st.execute(update);\n            \n            if(!results){\n                System.out.println(\"update executed\");\n            }\n            \n            rs.last();\n            System.out.println(\"new entry row: \"+ rs.getRow());\n            System.out.println(rs.getString(\"first_name\") + \" \" +rs.getString(\"last_name\")); \n\n        } catch(SQLException e){System.out.println(e); }\n        \n    }\n}','JDBC',0,0,NULL,5),(2199,'Will not compile, this is not the right syntax for multi - catch\nshould be \n\n	} catch(SQLException | IOException e){  ... }','public class Hello {\n    public static void main(String[] args){\n        try {\n            Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\");\n            Statement st = conn.createStatement();\n            String q = \"Select * From employees limit 100\";\n            getDBfile();\n            ResultSet rs = st.executeQuery(q);\n            \n            rs.first();\n            System.out.println(\"First entry:\");\n            System.out.println(rs.getString(\"first_name\") + \" \" +rs.getString(\"last_name\"));\n            \n            rs.last();\n            System.out.println(\"Last entry:\");\n            System.out.println(rs.getString(\"first_name\") + \" \" +rs.getString(\"last_name\"));\n            \n            rs.absolute(20);\n            System.out.println(\"row: \"+ rs.getRow());\n            System.out.println(rs.getString(\"first_name\") + \" \" +rs.getString(\"last_name\"));\n            \n            rs.relative(10);\n            System.out.println(\"row: \"+ rs.getRow());\n            System.out.println(rs.getString(\"first_name\") + \" \" +rs.getString(\"last_name\")); \n            \n            String update = \"insert into employees values(09,\'Broden\',\'Chapman\')\";\n            boolean results = st.execute(update);\n            \n            if(!results){\n                System.out.println(\"update executed\");\n            }\n            \n            rs.last();\n            System.out.println(\"new entry row: \"+ rs.getRow());\n            System.out.println(rs.getString(\"first_name\") + \" \" +rs.getString(\"last_name\")); \n\n        } catch(SQLException e | IOException e){System.out.println(e); }\n        \n    }\n    \n    public static void getDBfile() throws IOException { }  \n}','General',0,0,NULL,5),(2200,'First entry:\nHired today: Fri Jul 28 11:29:33 EDT 2017\nMicheal Boyd\nLast entry:\nTuval Kalloufi\nrow: 20\nChirstian Koblick\nrow: 30\nBerni Genin\nupdate executed\njava.sql.SQLException: Operation not allowed after ResultSet closed','public class Hello {\n    public static void main(String[] args){\n        try {\n            Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\");\n            PreparedStatement pst = conn.prepareStatement(\"Select * From employees limit 100\");\n            ResultSet rs = pst.executeQuery();\n            \n            java.util.Date d = new java.util.Date();\n\n            rs.first();\n            System.out.println(\"First entry:\");\n            System.out.println(\"Hired today: \"+d);\n            System.out.println(rs.getString(\"first_name\") + \" \" +rs.getString(\"last_name\"));\n            \n            rs.last();\n            System.out.println(\"Last entry:\");\n            System.out.println(rs.getString(\"first_name\") + \" \" +rs.getString(\"last_name\"));\n            \n            rs.absolute(20);\n            System.out.println(\"row: \"+ rs.getRow());\n            System.out.println(rs.getString(\"first_name\") + \" \" +rs.getString(\"last_name\"));\n            \n            rs.relative(10);\n            System.out.println(\"row: \"+ rs.getRow());\n            System.out.println(rs.getString(\"first_name\") + \" \" +rs.getString(\"last_name\")); \n            \n            String update = \"insert into employees values(11,\'Broden\',\'Chapman\')\";\n            boolean results = pst.execute(update);\n            \n            if(!results){\n                System.out.println(\"update executed\");\n            }\n            \n            rs.last();\n            System.out.println(\"new entry row: \"+ rs.getRow());\n            System.out.println(rs.getString(\"first_name\") + \" \" +rs.getString(\"last_name\")); \n\n        } catch(SQLException e){System.out.println(e); }\n        \n    }\n}','JDBC',0,0,NULL,5),(2201,'public long getTime()\n\nReturns the number of milliseconds \nsince January 1, 1970, 00:00:00 GMT represented by this Date object.','public static void main(sa) {\n	//most useless method\n	Date d = new Date();\n	sout( d.getTime() + \" \" );\n}\n\nwhat does this show ?','Strings',0,0,NULL,5),(2202,'WNC, the correct way to create a Calendar is \n\n	Calendar c = Calendar.getInstance();','public class Hello {\n    public static void main(String[] args){\n        try {\n            Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\");\n            PreparedStatement pst = conn.prepareStatement(\"Select * From employees limit 100\");\n            ResultSet rs = pst.executeQuery();\n            \n            Date d = new Date();\n            //Calendar c = Calendar.getInstance();\n            Calendar c = new Calendar();\n            c.setTime(d);\n\n            rs.first();\n            System.out.println(\"First entry:\");\n            System.out.println(\"Hired today: \"+d);\n            System.out.println(\"Start first upcoming monday: \"+firstNextMonday(d));\n            System.out.println(rs.getString(\"first_name\") + \" \" +rs.getString(\"last_name\"));\n            \n            c.add(Calendar.MONTH,-1);\n            Date monthago = c.getTime();\n            rs.last();\n            System.out.println(\"Last entry:\");\n            System.out.println(\"Hired a month ago: \"+monthago);\n            System.out.println(rs.getString(\"first_name\") + \" \" +rs.getString(\"last_name\"));\n            ','Strings',0,0,NULL,5),(2203,'WNC, the corrct ways to create a Calendar is \n\n	Calendar c = Calendar.getInstance();\n\nif that was corrected then this program would print:\n\n	First entry:\n	Hired today: Mon Aug 07 16:39:34 EDT 2017\n\nand keep running forever...\n\n	you were using accesing a static field at c.DAY_OF_WEEK\n	\n	it should be:\n\n	while(c.get(Calendar.DAY_OF_WEEK) != c.MONDAY){\n            //c.add(1,DAY_OF_WEEK);\n            c.add(c.DAY_OF_WEEK,1);\n        }\n\nif today was monday it would print the excact time and day of right now','public class Hello {\n    public static void main(String[] args){\n        try {\n            Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\");\n            PreparedStatement pst = conn.prepareStatement(\"Select * From employees limit 100\");\n            ResultSet rs = pst.executeQuery();\n            \n            Date d = new Date();\n            Calendar c = new Calendar();\n            c.setTime(d);\n\n            rs.first();\n            System.out.println(\"First entry:\");\n            System.out.println(\"Hired today: \"+d);\n            System.out.println(\"Start first upcoming monday: \"+firstNextMonday(d));\n            System.out.println(rs.getString(\"first_name\") + \" \" +rs.getString(\"last_name\"));\n            \n            c.add(Calendar.MONTH,-1);\n            Date monthago = c.getTime();\n            rs.last();\n            System.out.println(\"Last entry:\");\n            System.out.println(\"Hired a month ago: \"+monthago);\n            System.out.println(rs.getString(\"first_name\") + \" \" +rs.getString(\"last_name\"));\n        } catch(SQLException e){ }\n        \n    }\n    \n    public static Date firstNextMonday(Date d){\n        Calendar c = Calendar.getInstance();\n        c.setTime(d);\n        \n        while(c.DAY_OF_WEEK != c.MONDAY){\n            //c.add(1,DAY_OF_WEEK);\n            c.add(c.DAY_OF_WEEK,1);\n        }\n        \n        return c.getTime();\n        \n    }\n}','Strings',0,0,NULL,5),(2204,'java.sql.SQLException: No value specified for parameter 1','public class Hello {\n    public static void main(String[] args){\n        try {\n            Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\");\n            PreparedStatement pst = conn.prepareStatement(\"Select * From employees where first_name = ?\");\n            ResultSet rs = pst.executeQuery();\n            \n            Date d = new Date();\n            Calendar c = Calendar.getInstance();\n            c.setTime(d);\n            \n            DateFormat dateformat = DateFormat.getInstance();\n\n            rs.first();\n            System.out.println(\"First entry:\");\n            System.out.println(\"Hired today: \"+d);\n            System.out.println(\"Start first upcoming monday: \"+firstNextMonday(d));\n            System.out.println(rs.getString(\"first_name\") + \" \" +rs.getString(\"last_name\"));\n            \n            c.add(Calendar.MONTH,-1);\n            Date monthago = c.getTime();\n            rs.last();\n            System.out.println(\"Last entry:\");\n            System.out.println(\"Hired a month ago: \"+monthago);\n            System.out.println(rs.getString(\"first_name\") + \" \" +rs.getString(\"last_name\"));\n            \n            c.setTime(d);\n            c.add(Calendar.YEAR,-1);\n            c.add(Calendar.MONTH, -6);\n            Date yearandahalf = c.getTime();\n            rs.absolute(20);\n            System.out.println(\"row: \"+ rs.getRow());\n            System.out.println(\"Hired a year and a half ago\"+yearandahalf);\n            System.out.println(rs.getString(\"first_name\") + \" \" +rs.getString(\"last_name\"));\n	} catch(SQLException e) { }\n   }\n}','Strings',0,0,NULL,5),(2205,'7/28/17 12:39 PM','public static void main(String[] args){\n        Date d = new Date();\n        DateFormat df = DateFormat.getInstance();\n        \n        System.out.println(df.format(d));\n        \n    }','Strings',0,0,NULL,5),(2206,'Jul 28, 2017','public static void main(String[] args){\n\n        Date d = new Date();\n        DateFormat df = DateFormat.getDateInstance();\n        \n        System.out.println(df.format(d));\n        \n    }','Strings',0,0,NULL,5),(2207,' public static void main(String[] args){\n        Date d = new Date();\n        DateFormat df = DateFormat.getDateInstance(DateFormat.SHORT);\n        \n        System.out.println(df.format(d));\n        \n    }','What dateformat is this\n\n7/28/17','Strings',0,0,NULL,5),(2208,'will not compile, ParseException must be caught or thrown','public static void main(String[] args){\n        Date d = new Date();\n        DateFormat df = DateFormat.getDateInstance(DateFormat.SHORT);\n        \n        String s = df.format(d);\n        \n        Date d2 = df.parse(s);\n    }','Strings',0,0,NULL,5),(2209,'parsedFri Jul 28 00:00:00 EDT 2017','public static void main(String[] args){\n        Date d = new Date();\n        DateFormat df = DateFormat.getDateInstance(DateFormat.SHORT);\n        \n        String s = df.format(d);\n        \n        try{\n            Date d2 = df.parse(s);\n            System.out.println(\"parsed \"+d2);\n        } catch( ParseException e){\n            \n        }\n    }','Strings',0,0,NULL,5),(2210,'WNC dateformat is abstract cannot be instantiated ','public static void main(String[] args){\n        Date d = new Date();\n        DateFormat df = new DateFormat(DateFormat.SHORT);\n        \n        String s = df.format(d);\n        \n        try{\n            Date d2 = df.parse(s);\n            System.out.println(\"parsed \"+d2);\n        } catch( ParseException e){\n            \n        }\n    }','Strings',0,0,NULL,5),(2211,'The regular DF constructor doesn\'t take a style or Locale.\n\nGet a default date/time \nformatter that uses the SHORT style for both the date and the time.\n\nwith statements preparedstatements callablestatements:\n\n	executeQuery() returns a ResultSet\n	executeUpdate() returns an int\n	execute()  returns a boolean','try {\n            Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\");\n            PreparedStatement pst = conn.prepareStatement(\"Select * From employees limit 100\");\n            ResultSet rs = pst.executeQuery();\n            \n            Date d = new Date();\n            Calendar c = Calendar.getInstance();\n            c.setTime(d);\n            \n            DateFormat dateformat = DateFormat.getInstance();\n            Locale italian = new Locale(\"it\");\n            DateFormat italianformat = DateFormat.getInstance(DateFormat.FULL,italian);\n} catch(SQLException e){ }','Strings',0,0,NULL,5),(2212,'WNC you can only set a DateFormat and NumberFormat can only set\n local at the time of instantiation. There is not method to change locale\nafterward.','public class Hello {\n    public static void main(String[] args){\n        DateFormat df = DateFormat.getDateInstance(DateFormat.FULL,Locale.KOREA);\n        Date now = new Date();\n        \n        System.out.println(df.format(now));\n        \n        df.setLocale(Locale.US);\n        \n        System.out.println(df.format(now));\n    }\n}','Strings',0,0,NULL,5),(2213,'Brazil\nDenmark\nItaly\nBrasil\nDanmark\nItalia','public class Hello {\n    public static void main(String[] args){\n        Locale loc1 = new Locale(\"pt\",\"BR\");\n        Locale loc2 = new Locale(\"da\",\"DK\");\n        Locale loc3 = new Locale(\"it\", \"IT\");\n        \n        System.out.println(loc1.getDisplayCountry());\n        System.out.println(loc2.getDisplayCountry());\n        System.out.println(loc3.getDisplayCountry());\n        \n        //display the countrys name in that language\n        \n        System.out.println(loc1.getDisplayCountry(loc1));\n        System.out.println(loc2.getDisplayCountry(loc2));\n        System.out.println(loc3.getDisplayCountry(loc3));\n    }\n}','Strings',0,0,NULL,5),(2214,'3\n123.435','public class Hello {\n    public static void main(String[] args){\n        float f1 = 123.43535353f;\n        NumberFormat nf = NumberFormat.getInstance();\n        System.out.println(nf.getMaximumFractionDigits());\n        \n        System.out.println(nf.format(f1));\n        \n    }\n}','Strings',0,0,NULL,5),(2215,'3\n123.435\n123.43536','public class Hello {\n    public static void main(String[] args){\n        float f1 = 123.43535353f;\n        NumberFormat nf = NumberFormat.getInstance();\n        System.out.println(nf.getMaximumFractionDigits());\n        \n        System.out.println(nf.format(f1));\n        \n        nf.setMaximumFractionDigits(5);\n        \n        System.out.println(nf.format(f1));\n        \n    }\n}','Strings',0,0,NULL,5),(2216,'345.3435\n345','public class Hello {\n    public static void main(String[] args){\n        float f1 = 123.43535353f;\n        NumberFormat nf = NumberFormat.getInstance();\n        \n        try{\n            System.out.println(nf.parse(\"345.3435\"));\n            nf.setParseIntegerOnly(true);\n            System.out.println(nf.parse(\"345.3435\"));\n        } catch(ParseException e){\n            \n        }\n    }\n}','Strings',0,0,NULL,5),(2217,'123.435\n123.435\n$123.44\n?123\n\ncould vary from maching to machine','public class Hello {\n    public static void main(String[] args){\n        float f1 = 123.43535353f;\n        NumberFormat nf = NumberFormat.getInstance();\n        NumberFormat nf2 = NumberFormat.getInstance(Locale.KOREA);\n        NumberFormat nf3 = NumberFormat.getCurrencyInstance();\n        NumberFormat nf4 = NumberFormat.getCurrencyInstance(Locale.KOREA);\n        \n        System.out.println(nf.format(f1));\n        System.out.println(nf2.format(f1));\n        System.out.println(nf3.format(f1));\n        System.out.println(nf4.format(f1));\n\n    }\n}','Strings',0,0,NULL,5),(2218,'0\n7\n17','public class Hello {\n    public static void main(String[] args){\n        Pattern p = Pattern.compile(\"ab\");\n        Matcher m = p.matcher(\"abakdnfab kekrls ab\");\n        \n        while(m.find()){\n            System.out.println(m.start());\n        }\n        \n    }\n}','Strings',0,0,NULL,5),(2219,'13\n14\n30\n31\n58\n59\n\n\\\\d looks for digits','public class Hello {\n    public static void main(String[] args){\n        Pattern p = Pattern.compile(\"\\\\d\");\n        Matcher m = p.matcher(\"The silly Dog89 ran for miles.56 Like a silly little puppy45\");\n        \n        while(m.find()){\n            System.out.println(m.start());\n        }\n        \n    }\n}','Strings',0,0,NULL,5),(2220,'\\\\d looks for digits, \\\\D looks for nondigitis\nfirst:\n22\n23\n\nsecond:\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n24\n25\n26\n27\n28\n29\n30','first:\n    public static void main(String[] args){\n        Pattern p = Pattern.compile(\"\\\\d\");\n        Matcher m = p.matcher(\"The silly Dog ran for 89 miles.\");\n        \n        while(m.find()){\n            System.out.println(m.start());\n        }\n        \n    }\nsecond:\n	public static void main(String[] args){\n        Pattern p = Pattern.compile(\"\\\\D\");\n        Matcher m = p.matcher(\"The silly Dog ran for 89 miles.\");\n        \n        while(m.find()){\n            System.out.println(m.start());\n        }\n        \n    }\n','Strings',0,0,NULL,5),(2221,'a whitespace character \\t \\n \\f \\r','regex metacharacter:\n\n\\s','Strings',0,0,NULL,5),(2222,'non white space','regex metacharacter:\n\n\\S','Strings',0,0,NULL,5),(2223,'a-z A-Z digits or _','regex metacharacter:\n\n\\w word character\n\nmeaning what ?','Strings',0,0,NULL,5),(2224,'everything besides a-z A-Z _ or digits','regex metacharacter:\n\n\\W non word character\n\nmeaning what ?','Strings',0,0,NULL,5),(2225,'3\n9\n13\n17\n21\n24\n\nwhitespace characters','public static void main(String[] args){\n        Pattern p = Pattern.compile(\"\\\\s\");\n        Matcher m = p.matcher(\"The silly Dog ran for 89 miles.\");\n        \n        while(m.find()){\n            System.out.println(m.start());\n        }\n        \n    }','Strings',0,0,NULL,5),(2226,'all the non white spaces:\n0\n1\n2\n4\n5\n6\n7\n8\n10\n11\n12\n14\n15\n16\n18\n19\n20\n22\n23\n25\n26\n27\n28\n29\n30','public static void main(String[] args){\n        Pattern p = Pattern.compile(\"\\\\S\");\n        Matcher m = p.matcher(\"The silly Dog ran for 89 miles.\");\n        \n        while(m.find()){\n            System.out.println(m.start());\n        }\n        \n    }','Strings',0,0,NULL,5),(2227,'0   all the word characters similiar to \\\\S\n1\n2\n4\n5\n6\n7\n8\n10\n11\n12\n14\n15\n16\n18\n19\n20\n22\n23\n25\n26\n27\n28\n29','public static void main(String[] args){\n        Pattern p = Pattern.compile(\"\\\\w\");\n        Matcher m = p.matcher(\"The silly Dog ran for 89 miles.\");\n        \n        while(m.find()){\n            System.out.println(m.start());\n        }\n        \n    }','Strings',0,0,NULL,5),(2228,'3  //non word character similar to \\\\S numbers are word characters\n9\n13\n17\n21\n24\n30','public static void main(String[] args){\n        Pattern p = Pattern.compile(\"\\\\W\");\n        Matcher m = p.matcher(\"The silly Dog ran for 89 miles.\");\n        \n        while(m.find()){\n            System.out.println(m.start());\n        }\n        \n    }','Strings',0,0,NULL,5),(2229,'a word boundary, anytime there is a word character and a non word right next to\neach other.\nThere are invisible non word characters at the end and beginning of a string.\n\n0\n3\n4\n9\n10\n13\n14\n17\n18\n21\n22\n24\n25\n30','public class Hello {\n    public static void main(String[] args){\n        Pattern p = Pattern.compile(\"\\\\b\");\n        Matcher m = p.matcher(\"The silly Dog ran for 89 miles.\");\n        \n        while(m.find()){\n            System.out.println(m.start());\n        }\n        \n    }\n}','Strings',0,0,NULL,5),(2230,'//non word boundary each of these is a case where there IS NO word boundary\nor two word characters are beside each other or two non words are beside each other\nreturns the position of the second character.\n\n1 \n2\n5\n6\n7\n8\n11\n12\n15\n16\n19\n20\n23\n26\n27\n28\n29\n31','public class Hello {\n    public static void main(String[] args){\n        Pattern p = Pattern.compile(\"\\\\B\");\n        Matcher m = p.matcher(\"The silly Dog ran for 89 miles.\");\n        \n        while(m.find()){\n            System.out.println(m.start());\n        }\n        \n    }\n}','Strings',0,0,NULL,5),(2231,'4\n5\n11\n19\n26\n29','public static void main(String[] args){\n        Pattern p = Pattern.compile(\"[soi]\");\n        Matcher m = p.matcher(\"The silly Dog ran for 89 miles.\");\n        \n        while(m.find()){\n            System.out.println(m.start());\n        }\n        \n    }','Strings',0,0,NULL,5),(2232,'1\n2\n4\n5\n6\n7\n8\n11\n12\n14\n15\n16\n18\n19\n20\n25\n26\n27\n28\n29','public class Hello {\n    public static void main(String[] args){\n        Pattern p = Pattern.compile(\"[a-z]\");\n        Matcher m = p.matcher(\"The silly Dog ran for 89 miles.\");\n        \n        while(m.find()){\n            System.out.println(m.start());\n        }\n        \n    }\n}\n','Strings',0,0,NULL,5),(2233,'15','public class Hello {\n    public static void main(String[] args){\n        Pattern p = Pattern.compile(\"[a-cA-C]\");\n        Matcher m = p.matcher(\"The silly Dog ran for 89 miles.\");\n        \n        while(m.find()){\n            System.out.println(m.start());\n        }\n        \n    }\n}','Strings',0,0,NULL,5),(2234,'// the mistake here is that ? gives you \"ZERO OR ONE\" so if there is no a \nthere that still mathces!\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58','public class Hello {\n    public static void main(String[] args){\n        Pattern p = Pattern.compile(\"a?\");\n        Matcher m = p.matcher(\"The silly Dog ran for at least 89 miles.I am tired he said\");\n        \n        while(m.find()){\n            System.out.println(m.group());\n        }\n        \n    }\n}','Strings',0,0,NULL,5),(2235,'public class Hello {\n    public static void main(String[] args){\n        Pattern p = Pattern.compile(\" a.\");\n        Matcher m = p.matcher(\"The silly Dog ran for at least 89 miles.I am tired he said\");\n        \n        while(m.find()){\n            System.out.println(m.start());\n            System.out.println(m.group());\n        }\n        \n    }\n}\n\n21\n at\n41\n am','creaet a regex that finds a word composed of an \'a\' with any character next to it','Strings',0,0,NULL,5),(2236,'Without the space at the beginning of the pattern you allow a then any character\nto but up against any other character if you wanted it to just be individual\nwords then you could add a space at the beginning or a whitespce character.\n15\nan\n22\nat\n27\nas\n42\nam\n55\nai','public class Hello {\n    public static void main(String[] args){\n        Pattern p = Pattern.compile(\"a.\");\n        Matcher m = p.matcher(\"The silly Dog ran for at least 89 miles.I am tired he said\");\n        \n        while(m.find()){\n            System.out.println(m.start());\n            System.out.println(m.group());\n        }\n        \n    }\n}\n\n','Strings',0,0,NULL,5),(2237,'21\n at\n41\n am','public class Hello {\n    public static void main(String[] args){\n        Pattern p = Pattern.compile(\"\\\\sa.\");\n        Matcher m = p.matcher(\"The silly Dog ran for at least 89 miles.I am tired he said\");\n        \n        while(m.find()){\n            System.out.println(m.start());\n            System.out.println(m.group());\n        }\n        \n    }\n}','Strings',0,0,NULL,5),(2238,'49\n first ','public class Hello {\n    public static void main(String[] args){\n        //five letter words\n        Pattern p = Pattern.compile(\"\\\\s.....\\\\s\");\n        Matcher m = p.matcher(\"A regular expression, specified as a string, must first be compiled into an instance of this class\");\n        \n        while(m.find()){\n            System.out.println(m.start());\n            System.out.println(m.group());\n        }\n        \n    }\n}','Strings',0,0,NULL,5),(2239,'/home/maxbisesi/Documents/allfiles\n\nNone of these methods throw an IOE','public class Hello {\n    public static void main(String[] dicks){\n      Path src = Paths.get(\"/home/maxbisesi/Documents/allfiles/copy.txt\");\n      Path srcParent = src.getParent();\n      System.out.println(srcParent);\n      \n    }\n\n}','IO',0,0,NULL,5),(2240,'0\nyyxxxyxx\n8\n\n* is greedy so it reads then entire source then works backward, until it finds\nthe rightmost match. ',' public static void main(String[] args){\n        //five letter words\n        Pattern p = Pattern.compile(\".*xx\");\n        Matcher m = p.matcher(\"yyxxxyxx\");\n        \n        while(m.find()){\n            System.out.println(m.start());\n            System.out.println(m.group());\n		  System.out.println(m.end());\n        }\n        \n      \n    }','Strings',0,0,NULL,5),(2241,'0\nyyxxxy\n6\n\ngreedy reads the whole source data first','public static void main(String[] args){\n        //five letter words\n        Pattern p = Pattern.compile(\".*y\");\n        Matcher m = p.matcher(\"yyxxxyxx\");\n        \n        while(m.find()){\n            System.out.println(m.start());\n            System.out.println(m.group());\n            System.out.println(m.end());\n        }\n        \n      \n    }','Strings',0,0,NULL,5),(2242,'This pattern says its looking for zero or more digits, \nso at the positions other than 2 5 and 11 it does find 0 digits\n\n0:__\n1:__\n2:_4_\n3:__\n4:__\n5:_89_\n7:__\n8:__\n9:__\n10:__\n11:_90_\n13:__\n14:__\n\n',' public static void main(String[] args){\n        //five letter words\n        Pattern p = Pattern.compile(\"\\\\d*\");\n        Matcher m = p.matcher(\"yy4xx89xxye90g\");\n        \n        while(m.find()){\n            System.out.println(m.start()+\":_\"+m.group()+\"_\");\n        }\n        \n      \n    }','Strings',0,0,NULL,5),(2243,'Greedy will allow zero length matches, proven by the start and end indexs being \nthe same.\n\n0:_a_:1\n1:__:1\n2:_a_:3\n3:_a_:4\n4:__:4\n5:__:5\n6:__:6\n7:_a_:8\n8:_a_:9\n9:_a_:10\n10:__:10\n11:__:11\n12:_a_:13\n13:_a_:14\n14:_a_:15\n15:__:15','public static void main(String[] args){\n        //five letter words\n        Pattern p = Pattern.compile(\"a?\");\n        Matcher m = p.matcher(\"abaabbbaaabbaaa\");\n        \n        while(m.find()){\n            System.out.println(m.start()+\":_\"+m.group()+\"_:\"+m.end());\n        }\n        \n      \n    }','Strings',0,0,NULL,5),(2244,'hello\nmy\ndarling','public class Hello {\n    public static void main(String[] args){\n        String[] tokens = \"hello my darling\".split(\" \");\n        \n        for(String s : tokens){\n            System.out.println(s);\n        }\n    }\n\n}','Strings',0,0,NULL,5),(2245,'hello\nmy\ndarling','public static void main(String[] args){\n        String[] tokens = \"hello5my5darling\".split(\"\\\\d\");\n        \n        for(String s : tokens){\n            System.out.println(s);\n        }\n    }','Strings',0,0,NULL,5),(2246,'b\ni\ng\ni\nb\nh\nj\nv\nu\n \nl\no\nu\nf\n \nk\nv\nc\ni\ny','public static void main(String[] args){\n        String[] tokens = \"bigibhjvu louf kvciy\".split(\"\");\n        \n        for(String s : tokens){\n            System.out.println(s);\n        }\n    }','Strings',0,0,NULL,5),(2247,'whitespace','what is scanners default delemiter','Strings',0,0,NULL,5),(2248,'01234456','public static void main(String[] args){\n        Pattern p = Pattern.compile(\"\\\\d*\");\n        Matcher m = p.matcher(\"ab34ef\");\n        while(m.find()){\n            System.out.print(m.start() + m.group());\n        }\n    }','Strings',0,0,NULL,5),(2249,'0123445687891234514','public static void main(String[] args){\n        Pattern p = Pattern.compile(\"\\\\d*\");\n        Matcher m = p.matcher(\"ab34ef8hk12345\");\n        while(m.find()){\n            System.out.print(m.start() + m.group());\n        }\n    }','Strings',0,0,NULL,5),(2250,'\n\n\n\n\n\n\n\n\n\n\nException in thread \"main\" java.util.MissingResourceException: \nCan\'t find bundle for base name NickNames, locale en_US\n\n\n\n\n\n\n\n\n\n\n\n','public class Hello {\n    public static void main(String[] args){\n        ResourceBundle rb = ResourceBundle.getBundle(\"NickNames\");\n        System.out.println(rb.getString(\"Max Bisesi\"));\n        \n    }\n}\n\nclass NickNames extends ListResourceBundle {\n    protected Object[][] getContents(){\n        return new Object[][]{{\"hello\",\"from java\"},{\"Max Bisesi\",\"Big Bad Max\"},{\"Garret Gieske\", \"gieske\"}};\n    }\n}','Locale',0,0,NULL,5),(2251,'en_US\nde_DE','public static void main(String[] args){\n       Locale initial = Locale.getDefault();\n        System.out.println(initial);\n        \n        Locale.setDefault(Locale.GERMANY);\n        System.out.println(Locale.getDefault());\n        \n    }','Locale',0,0,NULL,5),(2252,'ResourceBundle.getBundle(basename);\nResourceBundle.getBundle(basename, locale);\n\nfirst uses default locale','two ways to get a ResourceBundle: ?','Locale',0,0,NULL,5),(2253,'got it !','Java chooses the most specific resource bundle it can while while giving\npreference to java ListResourceBundle','Locale',0,0,NULL,5),(2254,'RB_fr_CA.java // a java class mathcing excactly\nRB_fr_CA.properties // then it looks for exectaly matching property files\n\nRB_fr.java\nRB_fr.properites // if it cant find both it will look for the Language\n\n\nRB_en_US.java\nRB_en_US.poperties   // use the default locale instead\n\nRB_en.java\nRB_en.properties   //just llook for the default language\n\nRB.java\nRB.properties    //try default Bundle name','request french canadian resource bundle\n\nLocale loc = new Locale(\"fr\",\"CA\");\nResourceBundle rb = ResourceBundle.getBundle(\"RB\",loc);\n\nhow will java search for that bundle ?','Locale',0,0,NULL,5),(2255,'missingresourceexception','What happens if java cant find a resourceBundle','Locale',0,0,NULL,5),(2256,'Take a ride in the lift','ResourceBundles can inherit properties from parents\n\nRB_en.properties\n	ride.in=Take a ride in\n\nRB_en_US.properties\n	elevator=elevator\n\nRB_en_UK.properties\n	elevator=lift\n\nLocale locale = new Locale(\"en\",\"UK\");\nResourceBundle rb = ResourceBundle.getBundle(\"RB\",locale);\nsout(rb.getString(\"ride.in\") + rb.getString(\"elevator\"));','Locale',0,0,NULL,5),(2257,'MissingResourceException','public static void main(String[] args){\n      ResourceBundle rb = ResourceBundle.getBundle(\"Flag\",new Locale(\"en_CA\"));\n        System.out.println(rb.getString(\"key\"));\n        \n    }\n\nthere are no resourcebundles loaded','Locale',0,0,NULL,5),(2258,'Flag_en_CA.properties\nFlag_en.java\nFlag_en.properties\nFlag.properties','public static void main(String[] args){\n      ResourceBundle rb = ResourceBundle.getBundle(\"Flag\",new Locale(\"en_CA\"));\n        System.out.println(rb.getString(\"key\"));\n        \n    }\n\ndefault locale is Italian if there is only one resource bundle on the classpath\nhow will java search for that bundle based on the above ?','Locale',0,0,NULL,5),(2259,'Flag_en.properties\n\nFlag_fr_CA.properties the language does not match\n\nFlag_CA.properties, CA is not a valid lang code','public static void main(String[] args){\n      ResourceBundle rb = ResourceBundle.getBundle(\"Flag\",new Locale(\"en_CA\"));\n        System.out.println(rb.getString(\"key\"));\n        \n    }\n\nwhich will be chosen ?\n\nFlag_fr_CA.properties\nFlag_en.properties\nFlag_CA.properties ','Locale',0,0,NULL,5),(2260,'1 \n3 \n6 \n8 \n9 \n11 \n\n\\\\b says that the number reported is the end of a boundary between a wordcharacter\nand a non word character,\n\nbetween 0 and 1 is a boundary between a word and a non word.\n\nimagine the end and beginning of a string is an invisible non word.\nposition 0 was not returned here because ^ is non word and that against the \ninvisble non word is not a boundary','public static void main(String[] args){\n      Pattern p = Pattern.compile(\"\\\\b\");\n      Matcher m = p.matcher(\"^23 *$76 bc\");\n      while(m.find()){\n          System.out.println(m.start()+\" \");\n      }\n        \n    }','Locale',0,0,NULL,5),(2261,'1\n3\n4\n6','  public static void main(String[] args){\n      Pattern p = Pattern.compile(\"\\\\b\");\n      Matcher m = p.matcher(\"#ab de#\");\n      while(m.find()){\n          System.out.println(m.start()+\" \");\n      }\n        \n    }','Locale',0,0,NULL,5),(2262,'0 \n2 \n5 \n7\n\nif there is a non word boundary between the last character and \nthe invible end of string non word boundary then start will give \nthe very last character index, where normally it would give the second \nindex of the two characters creating the non word boudary. ',' public static void main(String[] args){\n      Pattern p = Pattern.compile(\"\\\\B\");\n      Matcher m = p.matcher(\"#ab de#\");\n      while(m.find()){\n          System.out.println(m.start()+\" \");\n      }\n        \n    }','Strings',0,0,NULL,5),(2263,'0 \n4 \n8 \n9','public static void main(String[] args){\n      Pattern p = Pattern.compile(\"\\\\b\");\n      Matcher m = p.matcher(\"abci####r\");\n      while(m.find()){\n          System.out.println(m.start()+\" \");\n      }\n        \n    }','Locale',0,0,NULL,5),(2264,'something like this ^^rt##r\n\nthe output is determined by the difference between a boundary adn a word boundary\n\n','when searched using \\\\b what string would give the result: 2467 ?','Strings',0,0,NULL,5),(2265,'^^^^^^^\n\nimagine Strings contain non word characters at the beginning and end of\neach string. Here, \\\\B is saying that there is NOT a word boundary between\nthe imaginary non word character that represents the beginning of the string\nand the first ^ symbol because they are both non words.\n\nThen there is NOT a word boundary between the first and subsequent ^ symbols\nbecause they are all non words. ','when searched with \\\\B what string could give 1234567 ? ','Locale',0,0,NULL,5),(2266,'..\n. a.\n. b .\n. c.\n.d .\n.e.\n\nif the first character in the String is a delimter the first array\nelement will be an empty token','public static void main(String[] args){\n        String[] chunks = \"1 a2 b 3 c4d 5e\".split(\"\\\\d\");\n        \n        for(String s : chunks){\n            System.out.println(\".\"+s+\".\");\n        }\n        \n    }','Locale',0,0,NULL,5),(2267,'got it ','if the first character in the String is a delimter the first array\nelement will be an empty token','Locale',0,0,NULL,5),(2268,'Changed line5 to new Locale(\"en\",\"UK\")','Train_en_US.properties: train=subway\nTrain_en_UK.properties: train=undergroudn\nTrain_en_.properties: ride = ride;\n\npublic class Choochoo {\n	public static void main(String[] args) {\n		Locale.setDefault(new Locale(\"en\",\"US\"));\n		ResourceBundle rb = \n	ResourceBundle.getBundle(\"Train\",new Locale(\"en\",\"US\"));\n		sout( rb.getString(\"ride\")+\" \"+rb.getString(\"train\"));\n	}\n}\n\nwhich change can you make independently to change the output to \"ride underground\"\n\nchange line 1 to Locale.setDefault(new Locale(\"en\",\"UK));\nAdd train=underground to Train_en.porperties\nchange line5 to new Locale(\"en\",\"UK\"));\nDelete Train_en_US.properties','Locale',0,0,NULL,5),(2269,'go it ','when using StringBuilder if you append past the current capacity it\ncan be automatically increased.\n\nif you insert past it you will receive an exception','Locale',0,0,NULL,5),(2270,'0  \n9 abcdef789','public static void main(String[] args){\n        StringBuilder sb = new StringBuilder(8);\n        System.out.println(sb.length() + \" \" + sb + \" \");\n        sb.insert(0,\"abcdef\");\n        sb.append(\"789\");\n        System.out.println(sb.length() + \" \" + sb);   \n    }','Locale',0,0,NULL,5),(2271,'0  \n10 abcdefghij\n\nthe string builders capacity has been increased automatically','public static void main(String[] args){\n        StringBuilder sb = new StringBuilder(8);\n        System.out.println(sb.length() + \" \" + sb + \" \");\n        sb.insert(0,\"abcdefghij\");\n        System.out.println(sb.length() + \" \" + sb);   \n    }','General',0,0,NULL,5),(2272,'will not compile, there is no method getInteger();','public class Hello {\n    public static void main(String[] args){\n        ResourceBundle rb = ResourceBundle.getBundle(\"NickNames\",Locale.getDefault());\n        Object ob = rb.getInteger(\"123\");\n        \n    }\n}\n\nclass NickNames extends ListResourceBundle {\n    protected Object[][] getContents(){\n        return new Object[][]{{\"hello\",\"from java\"},{\"Max Bisesi\",\"Big Bad Max\"},{\"Garret Gieske\", \"gieske\"},{\"123\",678}};\n    }\n}','General',0,0,NULL,5),(2273,'ClassCastException\n\nyoou can either use getString to get a string or getObject to get anything else\nbut you cannot use getString to get an object','public class Hello {\n    public static void main(String[] args){\n        ResourceBundle rb = ResourceBundle.getBundle(\"Hello.NickNames\",Locale.getDefault());\n        Object ob = rb.getString(\"123\");\n        \n    }\n}\n\nclass NickNames extends ListResourceBundle {\n    protected Object[][] getContents(){\n        return new Object[][]{{\"hello\",\"from java\"},{\"Max Bisesi\",\"Big Bad Max\"},{\"Garret Gieske\", \"gieske\"},{\"123\",678}};\n    }\n}','General',0,0,NULL,5),(2274,'abcd abc false\nabcd abcd true\n\nstring objects are immutable references are mutable\n\nSo here, when the s1+=\"d\" executes. The String \"abc\" was once referenced\nby s1 but it not longer is. Now it is referenced by s2. a New String object\nis created abcd and s1 is reassinged to reference that.','public static void main(Sa) {\n	String s1 = \"abc\";\n	String s2 = s1;\n	s1 += \"d\";\n	sout(s1+\" \"+s2+\" \"+ (s1==s2));\n	\n	StringBuffer sb1 = new StringBuffer(\"abc\");\n	StringBuffer sb2 = sb1;\n	sb1.append(\"d\");\n	sout(sb1+ \" \" + sb2 + \" \" + (sb1==sb2));\n}','General',0,0,NULL,5),(2275,' maxy  denny \n\nstrings are immutable, when s.trim() is executed a new String is created\nand a reference to it is returned then immediately lost. s and x remain\npointing to the strings \" maxy \" and \" denny \".\n','public class Hello {\n    public static void main(String[] args){\n       String s = \" maxy \";\n       String x = \" denny \";\n       s.trim();\n       x.trim();\n       String y = s+x;\n       \n        System.out.println(y);\n    }\n}','General',0,0,NULL,5),(2276,'987.12346 // rounds doesn\'t truncate\n987.123456 // setMaxFracDigs applies to formating but not parsing','String s = \"987.123456\";\ndouble d = 987.123456d;\nNumberFormat nf = NumberFormat.getInstance();\nnf.setMaximumFractionDigits(5);\nsout(nf.format(d) + \" \");\ntry {\n	sout(nf.parse(s));\n} catch(ParseException e){ }','General',0,0,NULL,5),(2277,'3\n\n\\\\d looks for digits\n\n+ says one or more ','public static void main(String[] args){\n        Pattern p = Pattern.compile(\"\\\\d+\");\n        Matcher m = p.matcher(\"ab2c4d67\");\n        int count = 0;\n        while(m.find()){\n            count++;\n        }\n        System.out.println(count);\n    }','Strings',0,0,NULL,5),(2278,'this one is confusing but remember + is greedy\n\nits not a series of word characters in this case the whole damn thing is \none word character',' public static void main(String[] args){\n        Pattern p = Pattern.compile(\"\\\\w+\");\n        Matcher m = p.matcher(\"ab2c4d67\");\n        int count = 0;\n        while(m.find()){\n            count++;\n        }\n        System.out.println(count);\n    }','Strings',0,0,NULL,5),(2279,'1\n\nthe whole string is one long non whitespace character and + is greedy\nso it took the whole thing','public static void main(String[] args){\n        Pattern p = Pattern.compile(\"\\\\S+\");\n        Matcher m = p.matcher(\"ab2c4d67\");\n        int count = 0;\n        while(m.find()){\n            count++;\n        }\n        System.out.println(count);\n    }','Strings',0,0,NULL,5),(2280,'1\n\n+ is greedy so this whole number is one big digit, greedy took the whole \nthing',' public static void main(String[] args){\n        Pattern p = Pattern.compile(\"\\\\d+\");\n        Matcher m = p.matcher(\"78254467\");\n        int count = 0;\n        while(m.find()){\n            count++;\n        }\n        System.out.println(count);\n    }','Strings',0,0,NULL,5),(2281,'1\n\nthe whole string is one big non word character so the greedy + took the whole\nthing','public static void main(String[] args){\n        Pattern p = Pattern.compile(\"\\\\W+\");\n        Matcher m = p.matcher(\"$%^&*\");\n        int count = 0;\n        while(m.find()){\n            count++;\n        }\n        System.out.println(count);\n    }','Strings',0,0,NULL,5),(2282,'1 2 followed by an exception','psvm(Sa){\n	String input = \"1 2 a 3 45 6\";	\n	Scanner sc = new Scanner(input);\n	int x = 0;\n	do {\n		x = sc.nextInt();\n		sout(x);	\n	} while(x!=0);\n}','General',0,0,NULL,5),(2283,' When the syntax is \"glob\" then the String representation of the path is matched using a limited pattern language that resembles regular expressions but with a simpler syntax. For example:\n\n    *.java 	Matches a path that represents a file name ending in .java\n    *.* 	Matches file names containing a dot\n    *.{java,class} 	Matches file names ending with .java or .class\n    foo.? 	Matches file names starting with foo. and a single character extension\n    /home/*/* 	Matches /home/gus/data on UNIX platforms\n    /home/** 	Matches /home/gus and /home/gus/data on UNIX platforms\n    C:\\\\* 	Matches C:\\foo and C:\\bar on the Windows platform (note that the backslash is escaped; as a string literal in the Java Language the pattern would be \"C:\\\\\\\\*\")\n\nThe following rules are used to interpret glob patterns:\n\n    The * character matches zero or more characters of a name component without crossing directory boundaries.\n\n    The ** characters matches zero or more characters crossing directory boundaries.\n\n    The ? character matches exactly one character of a name component.\n\n    The backslash character (\\) is used to escape characters that would otherwise be interpreted as special characters. The expression \\\\ matches a single backslash and \"\\{\" matches a left brace for example.\n\n    The [ ] characters are a bracket expression that match a single character of a name component out of a set of characters. For example, [abc] matches \"a\", \"b\", or \"c\". The hyphen (-) may be used to specify a range so [a-z] specifies a range that matches from \"a\" to \"z\" (inclusive). These forms can be mixed so [abce-g] matches \"a\", \"b\", \"c\", \"e\", \"f\" or \"g\". If the character after the [ is a ! then it is used for negation so [!a-c] matches any character except \"a\", \"b\", or \"c\".\n\n    Within a bracket expression the *, ? and \\ characters match themselves. The (-) character matches itself if it is the first character within the brackets, or the first character after the ! if negating.\n\n    The { } characters are a group of subpatterns, where the group matches if any subpattern in the group matches. The \",\" character is used to separate the subpatterns. Groups cannot be nested.\n\n    Leading period/dot characters in file name are treated as regular characters in match operations. For example, the \"*\" glob pattern matches file name \".login\". The Files.isHidden(java.nio.file.Path) method may be used to test whether a file is considered hidden.\n\n    All other characters match themselves in an implementation dependent manner. This includes characters representing any name-separators.\n\n    The matching of root components is highly implementation-dependent and is not specified.\n\nWhen the syntax is \"regex\" then the pattern component is a regular expression as defined by the Pattern class.\n\nFor both the glob and regex syntaxes, the matching details, such as whether the matching is case sensitive, are implementation-dependent and therefore not specified.','Glob rules','Strings',0,0,NULL,5),(2284,'Exception in thread \"main\" java.lang.IllegalArgumentException\n\ngetPathMatcher() argument must take the form:\n\n	syntax:pattern\n\nspecify glob or regex ','public class Hello {\n    public static void main(String[] args) {\n        PathMatcher matcher = FileSystems.getDefault().getPathMatcher(\"*\");\n        Path p1 = Paths.get(\"One.java\");\n        \n        System.out.println(matcher.matches(p1));\n\n    }\n\n}','Strings',0,0,NULL,5),(2285,'false, \nthe space after \'glob:\' matters. \n\nto give expected behavior take that space away.','public class Hello {\n    public static void main(String[] args) {\n        PathMatcher matcher = FileSystems.getDefault().getPathMatcher(\"glob: *\");\n        Path p1 = Paths.get(\"One.java\");\n        \n        System.out.println(matcher.matches(p1));\n\n    }\n\n}','Strings',0,0,NULL,5),(2286,'true,\n\nin glob * means any string inside directory bounds','public class Hello {\n    public static void main(String[] args) {\n        PathMatcher matcher = FileSystems.getDefault().getPathMatcher(\"glob:*\");\n        Path p1 = Paths.get(\"One.java\");\n        \n        System.out.println(matcher.matches(p1));\n\n    }\n\n}','Strings',0,0,NULL,5),(2287,'p1 could be:\n\"glob:*\" \"glob:**\" \"glob:*.{java,class}\" \"glob:One.????\"\n\n ','public class Hello {\n    public static void main(String[] args) {\n        PathMatcher matcher = FileSystems.getDefault().getPathMatcher(\"glob:\");\n        Path p1 = Paths.get(\"One.java\");\n        Path p2 = Paths.get(\"/home/Files/two.txt\");\n        Path p3 = Paths.get(\"/home/Pictures/amy1.pic\");\n        \n        System.out.println(matcher.matches(p1));\n        System.out.println(matcher.matches(p2));\n        System.out.println(matcher.matches(p3));\n\n    }\n\n}\ncreate a glob to match each of these paths','Strings',0,0,NULL,5),(2288,'true\ntrue\ntrue\n\nin a bracketed expression * ? and / match themselves\n\n* matches anything within a directory boundary','public class Hello {\n    public static void main(String[] args) {\n        PathMatcher matcher = FileSystems.getDefault().getPathMatcher(\"glob:*{*txt,*pic,/dir}\");\n        Path p1 = Paths.get(\"files.*txt\");\n        Path p2 = Paths.get(\"pictures.*pic\");\n        Path p3 = Paths.get(\"home/dir\");\n        \n        System.out.println(matcher.matches(p1));\n        System.out.println(matcher.matches(p2));\n        System.out.println(matcher.matches(p3));\n    }\n\n}','Strings',0,0,NULL,5),(2289,'false \nfalse\ntrue\n\n* doesn\'t work accross directory bounds ','public class Hello {\n    public static void main(String[] args) {\n        PathMatcher matcher = FileSystems.getDefault().getPathMatcher(\"glob:*{*txt,*pic,/dir}\");\n        Path p1 = Paths.get(\"home/files.*txt\");\n        Path p2 = Paths.get(\"documents/pictures.*pic\");\n        Path p3 = Paths.get(\"home/dir\");\n        \n        System.out.println(matcher.matches(p1));\n        System.out.println(matcher.matches(p2));\n        System.out.println(matcher.matches(p3));\n    }\n\n}','Strings',0,0,NULL,5),(2290,'will not compile the proper syntax is:\n\n	FileSystems.getDefault().getPathMatcher()','public class Hello {\n    public static void main(String[] args) {\n        PathMatcher matcher = FileSystems.getPathMatcher(\"glob:*{*txt,*pic,/dir}\");\n        Path p1 = Paths.get(\"home/files.*txt\");\n        Path p2 = Paths.get(\"documents/pictures.*pic\");\n        Path p3 = Paths.get(\"home/dir\");\n        \n        System.out.println(matcher.matches(p1));\n        System.out.println(matcher.matches(p2));\n        System.out.println(matcher.matches(p3));\n    }\n\n}','Strings',0,0,NULL,5),(2291,'you can also do this to use regex instead of glob.\n\nhere they would all say \'true\'','public class Hello {\n    public static void main(String[] args) {\n        PathMatcher matcher = FileSystems.getDefault().getPathMatcher(\"regex:.*\");\n        Path p1 = Paths.get(\"home/files.*txt\");\n        Path p2 = Paths.get(\"documents/pictures.*pic\");\n        Path p3 = Paths.get(\"home/dir\");\n        \n        System.out.println(matcher.matches(p1));\n        System.out.println(matcher.matches(p2));\n        System.out.println(matcher.matches(p3));\n    }\n\n}','Strings',0,0,NULL,5),(2292,'will not compile, \n\nGazer is declared after it is used in a method,thats not allowed move it to before','public class Hello {\n	private int size = 7;\n	private static int length = 3;\n	public static void main(String[] args) {\n		new Hello().go();\n	}\n	void go(){\n		int size = 5;\n                 System.out.println(new Gazer().adder());\n                 \n                 class Gazer {\n                     private int size = 6;\n                      int adder() { return size * length; }\n                }\n	}\n	\n}','Strings',0,0,NULL,5),(2293,'WNC,  \n\nlocal variable size is accessed from within inner class needs to be final,\n\n\n	','public class Hello {\n	private int size = 7;\n	private static int length = 3;\n	public static void main(String[] args) {\n		new Hello().go();\n	}\n	void go(){\n		int size = 5;\n                class Gazer {\n                      int adder() { return size * length; }\n                }\n                 System.out.println(new Gazer().adder());\n	}\n}','Strings',0,0,NULL,5),(2294,'21\n\nnothing wrong here, instances can access statics just not the other way around!','public class Hello {\n	private int size = 7;\n	private static int length = 3;\n	public static void main(String[] args) {\n		new Hello().go();\n	}\n	void go(){\n                class Gazer {\n                      int adder() { return size * length; }\n                }\n                 System.out.println(new Gazer().adder());\n	}\n}','Inner Classes',0,0,NULL,5),(2295,'WNC\n\nsuper to bound a named type parameter (e.g. <S super T>) as opposed to a wildcard (e.g. <? super T>) is ILLEGAL simply because even if it\'s allowed, it wouldn\'t do what you\'d hoped it would do, because since Object is the ultimate super of all reference types, and everything is an Object, in effect there is no bound.\n\nIn your specific example, since any array of reference type is an Object[] (by Java array covariance), it can therefore be used as an argument to <S super T> S[] toArray(S[] a) (if such bound is legal) at compile-time, and it wouldn\'t prevent ArrayStoreException at run-time.\n\nWhat you\'re trying to propose is that given:\n\nList<Integer> integerList;\n\nand given this hypothetical super bound on toArray:\n\n<S super T> S[] toArray(S[] a) // hypothetical! currently illegal in Java\n\nthe compiler should only allow the following to compile:\n\nintegerList.toArray(new Integer[0]) // works fine!\nintegerList.toArray(new Number[0])  // works fine!\nintegerList.toArray(new Object[0])  // works fine!\n\nand no other array type arguments (since Integer only has those 3 types as super). That is, you\'re trying to prevent this from compiling:\n\nintegerList.toArray(new String[0])  // trying to prevent this from compiling\n\nbecause, by your argument, String is not a super of Integer. However, Object is a super of Integer, and a String[] is an Object[], so the compiler still would let the above compile, even if hypothetically you can do <S super T>!\n\nSo the following would still compile (just as the way they are right now), and ArrayStoreException at run-time could not be prevented by any compile-time checking using generic type bounds:\n\nintegerList.toArray(new String[0])  // compiles fine!\n// throws ArrayStoreException at run-time\n\nGenerics and arrays don\'t mix, and this is one of the many places where it shows.\nA non-array example\n\nAgain, let\'s say that you have this generic method declaration:\n\n<T super Integer> void add(T number) // hypothetical! currently illegal in Java\n\nAnd you have these variable declarations:\n\nInteger anInteger\nNumber aNumber\nObject anObject\nString aString\n\nYour intention with <T super Integer> (if it\'s legal) is that it should allow add(anInteger), and add(aNumber), and of course add(anObject), but NOT add(aString). Well, String is an Object, so add(aString) would still compile anyway.','public class Hello<T> {\n    \n    public static void main(String[] args){\n        \n        Dog d = new Dog();\n        \n        ArrayList<?> c = makeArrayList(new Animal());\n        \n\n    } \n    public static <G super Dog> ArrayList<G> makeArrayList(G g){\n        ArrayList<G> genlist = new ArrayList<>();\n        genlist.add(g);\n        return genlist;\n        \n    }\n}\n\nclass Animal{}\nclass Dog extends Animal{}','Generics',0,0,NULL,5),(2296,'will not compile to import a static member an import sattemten must say \nimport static wiht either a wildcard or excplicity the member to be imported','package xcom;\npublic class Stuff{\n	public static int MY_COSTANT = 5;\n	public static int dosStuff(int x) { return (x++)*x; }\n}\n\nimport static xcom.Stuff;\nimport static java.lang.System;\nclass User {\n	public static void mian(SA){\n		new User().go()\n	}\n	void go(){\n			out.println(doStuff(MY_CONSTANT);\n	}\n}','General',0,0,NULL,5),(2297,'WNC,\n\nsubmitting a Callable to an ExecutorService gets you a Future of the type \nreturned by the call(), then you get that result from the future with \nget() wich can block.','public class Hello {\n    \n    public static void main(String[] args){\n        Path file = Paths.get(\"~/Public/Data\");\n        FileSearcher fs = new FileSearcher(file,\"\\\\b\\\\W\\\\w+\");\n        ExecutorService es = Executors.newCachedThreadPool();\n        HashMap<Integer,String> searchresults = es.submit(fs);\n        System.out.println(\"We\'re wating on your search results\");\n        Future<HashMap<Integer,String>> futuresearch;\n        \n        try{\n            //HashMap<Integer,String> searchresults = futuresearch.get();\n            searchresults = futuresearch.get();\n            if(searchresults == null){\n                System.out.println(\"There were no results bro\");\n                System.exit(0);\n            }\n            \n        }catch(ExecutionException | InterruptedException e){\n            \n        }\n    }\n}\n\nclass FileSearcher implements Callable<HashMap<Integer,String>> {\n    private Path fileToLoad;\n    private String regex;\n    public FileSearcher(Path file,String reg){\n        fileToLoad = file;\n        regex = reg;\n    }\n    \n    public HashMap<Integer,String> call() throws IOException{\n        int linenum = 0;\n        HashMap<Integer,String> map = new HashMap<>();\n        BufferedReader br = new BufferedReader(new FileReader(fileToLoad.toFile()));\n        Pattern p = Pattern.compile(regex);\n        Matcher m;\n        String line;\n        while((line = br.readLine()) != null){\n            map.put(++linenum,line);\n        }\n        return map;\n    }\n}','Executors',0,0,NULL,5),(2298,'-12\n\nNearly does not properly override equals(Object o).\n\nSo by nearly\'s wrongly implemented equals() they are equal so you get -1\n\nbut Set knows the true equals to use and here it cant find it so it uses\nthe default equal which states that all objects are different and allows in\ntwo identicle objects. ','class Nearly {\n	String value;\n	public Nearly(String v) { value = v; }\n	public int hashCode() { return 1; }\n	public boolean equals(Nearly n){\n		if(value.charAt(0) == n.value.charAt(0)) return true;\n		return false;\n	}\n	psvm(sa){	\n		Nearly n1 = new Nearly(\"aaa\");\n		Nearly n2 = new Nearly(\"aaa\");\n		String s = \"-\";\n		if(n1.equals(n2)) s += \"1\";\n		if(n1 == n2) s += \"2\";\n		Set<Nearly> set = new HashSet<Nearly>();\n		set.add(n1);	\n		set.add(n2);\n		sout( s + set.size() );\n	}\n}','OOP',0,0,NULL,5),(2299,'x5.hashCode() == x6.hashCode()\n\nif the hashcode values are not equal the two objects must not be equal\n\nif equals() is not true there is not guarentee of results from hashcode\n\nhashcode will often return equals values even if the two objects are not equal','x = 0;\nif(x1.hashCode() != x2.hashCode() ) x = x +1;\nif(x3.equals(x4) == false) x = x + 10;\nif(x5.equals(x6) == true) x = x + 100;\nif(x7.hashCode() == x8.hashCode() ) x = x + 1000;\nsout( \"x = \" + x);\n\nif the output is x = 1111 what has to always be true ?\n\nx2.equals(x1) == true\nx3.hashCode() != x4.hashCode()\nx5.hashCode() == x6.hashCode()\nx8.equals(x7) == true','OOP',0,0,NULL,5),(2300,'got it','if the hashcode values are not equal the two objects must not be equal','OOP',0,0,NULL,5),(2301,'','import static statements must import explicitly the members ','OOP',0,0,NULL,5),(2302,'return ((Sortof)o).code.length * ((Sortof)o).bal == this.code.length * this.bal;\n\nreturn ((Sortof)o).code.length * ((Sortof)o).bal * ((Sortof)o).rate == this.code.length * this.bal * this.rate;\n\n\nthe equals algorithm must be at least as precise as hashcode at determining\nwhat is \"meaningfully equivalent\" ','class Sortof {\n	String name;\n	int bal;\n	String code;\n	short rate;\n	public int hashCode() {\n		return (code.length() * bal);\n	}\n	public boolean equals(Object o){\n		//insert here\n	}\n}\n\nhow can you fullfill the equals and hashcode contracts for this class ?\n','OOP',0,0,NULL,5),(2303,'b4 and b8','public class Hello{\n    public static void main(String[] args){\n        Bango b1 = new Bango();\n        Bango b2 = new Bongo();\n        Bango b3 = new Bingo();\n        \n        Bongo b4 = b2;\n        Bongo b5 = (Bongo)b2;\n        Bango b6 = b3;\n        Bango b7 = (Bango) b3;\n        Bingo b8 = b3;\n        Bingo b9 = (Bingo) b3;\n        Bango b10 = (Bongo) b3;\n    \n    }\n}\n\nclass Bango { }\nclass Bongo extends Bango { }\nclass Bingo extends Bongo { }\n\nwhich wont compile ? ','OOP',0,0,NULL,5),(2304,'WILL NOT COMPILE','class Clojure extends FP {\n	boolean typed;\n	public static void main(String[] args){\n		Clojure c = new Clojure();\n		c.monad();\n	}\n	void mondad() {\n		sout(\"foo\");\n	}\n}\n\nclass FP {\n	String name = \"basic\";\n	protected FP(String s){ name = s; }\n}','OOP',0,0,NULL,5),(2305,'Will not compile only instance methods can be overriden and calls to super \nare only for obverridne methods. ','class AlternateFuel {\n	int getRating() { return 42; }\n	static int getRating2() { return 43; }\n}\nclass Bio extends AlternateFuel {\n	psvm(){\n		new Bio().go();\n		sout( super.getRating2() );\n	}\n	void go() {\n		sout( super.getRating() );\n	}\n}','OOP',0,0,NULL,5),(2306,'2 2 1\n\ninstance variables are not overriden, the variable used is related to \nthe reference type. \n\nsuper can be used to access super class instance variables','class Alpha { int over = 1; }\nclass Beta extends Alpha { int over = 2; }\nclass Gamma extends Beta {\n	int over = 3;\n	public static void main(SA){\n		new Gamma().go();\n	}\n\n	void go() {	\n		Beta b = new Gamma();\n		Alpha a = new Gamma();\n		sout( super.over+\" \"+b.over+\" \"+a.over );\n	}\n}','OOP',0,0,NULL,5),(2307,'two legal overrides, one a covariant return\n\ntwo legal overloads ','class Programmer {\n	Programmer debug(){ return this; }\n}\n\nclass SCJP extends Programmer {\n	//insert here\n}\n\nProgrammer debug() { return this; }\nSCJP debug() { return this; }\n\nint debug(int x) { return 1; }\nObject debug(String s){ return this; }','OOP',0,0,NULL,5),(2308,'legal overload','class Programmer {\n	Programmer debug(){ return this; }\n}\n\nclass SCJP extends Programmer {\n	Object debug(String s){ return this; }\n}\n\n','OOP',0,0,NULL,5),(2309,'WNC, they have to be in the same inheritance tree','public class Hello{\n    public static void main(String[] args){\n        Short s = null;\n        \n        boolean b = (s instanceof String);\n    \n    }\n}','OOP',0,0,NULL,5),(2310,'false\n\nif two objects are equal, their hashCodes must be equal\n\nif two objects are not equal, their hashCodes must not be equal. ','Class Dog follows the equals and hashcode contract, x and y are reference variable\nto two Dog objects which are true?\n\nif x.equals(y) is true then x.hashCode() == y.hashCode() may be false\n','OOP',0,0,NULL,5),(2311,'got it','join() throws InterruptedException','Threads',0,0,NULL,5),(2312,'6','public class Hello{\n    public static void main(String[] args){\n        Pattern p = Pattern.compile(\"\\\\W\");\n        Matcher m = p.matcher(\"565757 43353535\");\n        \n        while(m.find()){\n            System.out.println(m.start());\n        }\n        \n    }\n}','Strings',0,0,NULL,5),(2313,'got it','YOU CANT USE SUPER WHEN DEFINING A GENERIC CLASS','Generics',0,0,NULL,5),(2314,'WNC close() throws IOEXception, cannot throw new or broader checked exceptions','class E implements Closeable { public void close() throws Exception {}}','Collections',0,0,NULL,5),(2315,'start() and run()','What methods are defined in the thread class ?','Threads',0,0,NULL,5),(2316,'got it','Both wait() and notify() must be called from a synchronized context\n\nthe wait() method is overloaded to accept a duration','Threads',0,0,NULL,5),(2317,'got it','if a class has synchronized code multiple threads can still access the unsynchronized\ncode\n\nwhen a thread invokes wait() it releases its locks','Threads',0,0,NULL,5),(2318,'notifyAll() would be a mistake since only one waiting thread can have \na widget. \n\nnotify() is better \n\nif they are all notified only one would get the new widget but the others \nwould probably throw an exception since they try to get a widgeth without\ndouble checking if one is available','class Widget { }\nclass WidgetMaker extends Thread {\n    List<Widget> finishedWidget = new ArrayList<Widget>();\n    public void run(){\n        try{\n            while(true){\n                Thread.sleep(2000);\n                Widget w = new Widget();\n                \n                //insert something\n                \n            }\n        } catch(InterruptedException e){ }\n    }\n    \n    public Widget waitForWidget() {\n        synchronized(finishedWidget) {\n            if(finishedWidget.size() == 0){\n                try{\n                    finishedWidget.wait();\n                } catch(InterruptedException e){ }\n            }\n            return finishedWidget.remove(0);\n        }\n    }\n}\n\npublic class Hello extends Thread{\n    private WidgetMaker maker;\n    public Hello(String name, WidgetMaker me){\n        super(name);\n        this.maker = me;\n    }\n    \n    public void run(){\n        Widget w = maker.waitForWidget();\n        System.out.println(getName() + \"got a widget\");\n    }\n   \n    public static void main(String[] args) {\n       WidgetMaker maker = new WidgetMaker();\n       maker.start();\n       new Hello(\"lenny\",maker).start();\n       new Hello(\"Moe\",maker).start();\n       new Hello(\"Ben\",maker).start();\n    }\n}\n\nif each user should get its own widget which no other user is using what should\nyuou put in //insert here ? \n\nsynchronized(finishedWidget){\n	finshedWidget.add(w);\n	finishedWidget.notify();\n}\n\nor \n\nsynchronized(finishedWidget){\n	finshedWidget.add(w);\n	finishedWidget.notifyAll();\n}','Threads',0,0,NULL,5),(2319,'NO, \nThese two run() method lock onto an instance of Hello but there are two \ndifferent instances so that wont prevent thme from running at the same time.\n\nyou can do...\n\n	public void run(){ synchronized(Letters.class){write();} }\n	\n	or\n	\n	public void run(){ synchronized(System.out){ write(); } }\n\nnow they wont run at the same time as they go for the same locks','public class Hello extends Thread{\n    private String name;\n    public Hello(String name){ this.name = name; }\n    public void write() {\n        System.out.println(name);\n        System.out.println(name);\n    }\n    public static void main(String[] args) {\n        new Hello(\"X\").start();\n        new Hello(\"Y\").start(); \n    }\n}\n\nyou want to guarentee that output is XXYY or YYXX how can you do this ?\n\n\npublic synchronized void run() { write(); }\npublic void run(){ synchronized(this){ write(); } }','Threads',0,0,NULL,5),(2320,'This class is thread safe \n\nline a would always print true if a lock were used befor int old','class Calculator {\n    private AtomicInteger i = new AtomicInteger();\n    public void add(int val){\n        int old = i.get();\n        int newval = old + val;\n        System.out.println(i.compareAndSet(old,newval));   //LINE A\n    }\n    public int getValue() {\n        return i.get();\n    }\n}','Concurrency',0,0,NULL,5),(2321,'class Asynchronous implements Runnable\nclass Asynchronous implements Callable<String>\n\nif the object sent to submit is a Runnable, the submit method will return\nan instance of Future whos get method will return null\n\notherwise Futures get method will return a type of the Type of class of Callable','public class Hello {\n    ExecutorService service = Executors.newFixedThreadPool(8);\n    \n        public void runAsynchronously(Asynchronous object){\n            Future<?> result = service.submit(object);\n        }\n        \n }\n\nwhat is a valid declaration of Asynchronous ?\n','Concurrency',0,0,NULL,5),(2322,'got it','ExecutorService method:\n\nsubmit\n\nFuture<?> submit(Runnable task)\n\nSubmits a Runnable task for execution and returns a Future representing that task. \nThe Future\'s get method will return null upon successful completion.','Concurrency',0,0,NULL,5),(2323,'executing a runnable\nnull','public class Hello {\n\n    private static ExecutorService service = Executors.newFixedThreadPool(8);\n\n    public static void runAsynchronously(Asynchronous object) {\n        Future<?> result = service.submit(object);\n        try{\n            System.out.println(result.get());\n        } catch(InterruptedException | ExecutionException e){ }\n    }\n\n    public static void main(String[] args) {\n        runAsynchronously(new Asynchronous());\n    }\n\n}\n\nclass Asynchronous implements Runnable {\n\n    public void run() {\n        System.out.println(\"executing a runnable\");\n    }\n}','Concurrency',0,0,NULL,5),(2324,'yes,\n\nyou could also use Atomic integer with getAndIncrement and getAndDecrement\ninstead of value and the lock ','public class Hello {\n    private Lock lock = new ReentrantLock();\n    private int value = 0;\n    public void increment(){\n        lock.lock();\n        value++;\n        lock.unlock();\n    }\n    public void decrement(){\n        lock.lock();\n        value--;\n        lock.unlock();\n    }\n    public int getValue(){\n        return value;\n    }\n    public static void main(String[] args){\n        \n    }    \n}\n\nis this class thread safe ?','Concurrency',0,0,NULL,5),(2325,'WNC fj should be a ForkJoinPool and use ivoke instead of submit','public static void main(SA) { \n	int[] myData = new int[10000000];\n	ForkJoin fj = new ForkJoin();\n\n	MyRecursiveInitClass action = new MyRecursiveInitClass(x,y,mydata);\n\n	fj.submit(action);\n\n	doStuff(myData);\n}\n\n','Concurrency',0,0,NULL,5),(2326,'true got it','A ForkJoinPool implements Executor and ExecutorService\n\nextends AbstractExecutorService','Concurrency',0,0,NULL,5),(2327,'got it','ForkJoinPool is a ExecutorService\n\nthe implementation of the compute() in ForkJoinTask the fork method should \nalways be be called before the join() or the invokeAll()\n\ninvoke() from class ForkJoinPool only accpts as parameters istances of \nForkJoinTask \n\nif the algorithim does not have to return a value you should extends RecursiveAction\nnot RecursiveTask\n\nForkJoinPool is a ExecutorService so it can be usd to process a Callable\nvia the submit method.','Concurrency',0,0,NULL,5),(2328,'200 is printed this does not throw a ConcurrentModificationException because\na CopyOnWriteArrayList allows modifications while being iterated.\n\n\n\n','public class ConcurrentModification {\nList<Integer> list = new CopyOnWriteArrayList<>();\n\npublic void work(){\n	Iterator<Integer> iter = list.iterator();\n	while(it.hasNext()){\n		it.next();\n		list.add(100);\n	}\n	sout( list.size() );\n	}\n}','Concurrency',0,0,NULL,5),(2329,'Thread-1removed element: null\nThread-1removed element: null\nThread-1removed element: null\nThread-1removed element: null\nThread-1removed element: null\nThread-0removed element: null\nThread-0removed element: null\nThread-0removed element: null\nThread-0removed element: null\nThread-0removed element: null\nThread-2removed element: null\nThread-3removed element: null\nThread-2removed element: null\nThread-3removed element: null\nThread-2removed element: null\nThread-3removed element: null\nThread-2removed element: null\nThread-3removed element: null\nThread-2removed element: null\nThread-3removed element: null\n\npeek() returns null if empty','public class Hello implements Runnable {\n    private static ArrayBlockingQueue<Integer> abq = new ArrayBlockingQueue<>(10);\n    public static void main(String[] args){\n       Hello h = new Hello();\n       Thread t1 = new Thread(h);\n       Thread t2 = new Thread(h);\n       Thread t3 = new Thread(h);\n       Thread t4 = new Thread(h);\n       \n       t1.start();\n       t2.start();\n       t3.start();\n       t4.start();\n       \n    }\n    public void run(){\n        for(int i = 0; i<5; i++){\n            System.out.println(Thread.currentThread().getName()+\"removed element: \"+abq.peek());\n        }\n        \n    }\n}','Concurrency',0,0,NULL,5),(2330,'got it ','ArrayBlockingQueue\n\n\npeek() returns null if empty','Concurrency',0,0,NULL,5),(2331,'got it ','peek() and poll() in interface Queue return null if empty','General',0,0,NULL,5),(2332,'WNC enum types must not be local','public class Hello {\n    enum A { A };\n    public static void main(String[] args) {\n        enum B{ B };\n    }\n}\nenum C{ C }','General',0,0,NULL,5),(2333,'\n\nEnums are static nested classes because they define static member variables \n(the enum values), and this is disallowed for inner classes: \nhttp://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.1.3\n\nUpdate: I was looking through the JLS (java language specification) for\n more detail on the restrictions of static nested classes, and didn\'t find \nit (although it\'s probably there, hidden under a different topic). From a \npure implementation perspective, there\'s no reason that this couldn\'t be \ndone. \n\nAs a comment: if your methods are large enough that they require their own \nenums, then it\'s a strong sign that you need refactoring.\n','enums cant be local to a method ','General',0,0,NULL,5),(2334,'WNC cannot override final methods','public class Hello extends Flipper {\n    public static void main(String[] args) {\n        \n    }\n    public void flip(){System.out.println(\"hello\");}\n}\nclass Flipper {\n    public final void flip() { System.out.println(\"flip\"); }\n}','General',0,0,NULL,5),(2335,'-ss','public class Hello{\n    static String s = \"-\";\n    \n    public static void main(String[] args) {\n        go();\n        System.out.println(s);\n    }\n    { go(); }\n    static { go(); }\n    static void go(){ s+=\"s\"; }\n}','OOP',0,0,NULL,5),(2336,'compiles fine how to use an enum','public class Hello{\n    \n    public static void main(String[] args) {\n       Bigger.Faster bf = Bigger.Faster.HIGHER;\n    }\n   \n}\nclass Bigger {\n    enum Faster { HIGHER,  LONGER };\n}','General',0,0,NULL,5),(2337,'WNC,\n\nthe constants are declared with String constructors so the default constructor\nwont do. ','public class Hello{\n    \n    public static void main(String[] args) {\n        System.out.println(Bulbs.ON);\n    }\n   \n}\nenum Bulbs{ ON(\"Bright\"), OFF(\"Dim\") };','General',0,0,NULL,5),(2338,'how to contruct a string argumnet enum constant','public class Hello{\n    \n    public static void main(String[] args) {\n        System.out.println(Bulbs.ON);\n    }\n   \n}\nenum Bulbs{ \n    ON(\"Bright\"), OFF(\"Dim\");\n    \n    String name;\n\n    Bulbs(String x){ name = x; }\n};','General',0,0,NULL,5),(2339,'WNC enum constructos cannot be public or protected.\n\nThe constructor for an enum type must be package-private or private access.\'\n It automatically creates the constants that are defined at the beginning \nof the enum body. You cannot invoke an enum constructor yourself. \n\nThink of Enums as a class with a finite number of instances. \nThere can never be any different instances beside the ones you initially\n declare.\n\nThus, you cannot have a public or protected constructor, because that would\n allow more instances to be created.','public class Hello{\n    \n    public static void main(String[] args) {\n        System.out.println(Bulbs.ON);\n    }\n   \n}\nenum Bulbs{ \n    ON(\"Bright\"), OFF(\"Dim\");\n    \n    String name;\n\n    public Bulbs(String x){ name = x; }\n};','General',0,0,NULL,5),(2340,'B \nC \nb-m1\nB \nC \nc-m1\nB \nC \n\nabstract classes can have constructors, when a subclass constructor is called\nit calls its super first.\n\n','public class Hello extends B{\n    void m1() { System.out.println(\"c-m1\"); }\n    void m2() { }\n    \n    public static void main(String[] args) {\n        new Hello().go();\n        new Hello().m1();\n        new Hello().m2();\n    }\n    \n    void go(){ super.m1(); }\n    Hello(){ System.out.println(\"C \"); }\n}\nabstract class B {\n    void m1() { System.out.println(\"b-m1\");}\n    abstract void m2();\n    B() { System.out.println(\"B \");}\n    \n}','General',0,0,NULL,5),(2341,'A\nB\nD\nE\nG\nH','class Top {\n    { System.out.println(\"A\"); }\n    public Top(){ System.out.println(\"B\"); }\n    public Top(String s){ System.out.println(\"C\"); }\n}\n\nclass Middle extends Top {\n    {System.out.println(\"D\");}\n    public Middle(){ System.out.println(\"E\"); }\n    public Middle(String z){System.out.println(\"F\"); }\n}\npublic class Hello extends Middle{\n   {System.out.println(\"G\");}\n   public Hello(){ System.out.println(\"H\");}\n   public Hello(String x){ System.out.println(\"Z\");}\n    public static void main(String[] args) {\n      new Hello();\n    }\n}','OOP',0,0,NULL,5),(2342,'You can tell that DateFormat is not a singleton because it takes a parameter\n','DateFormat f3 = DateFormat.getDateInstance(DateFormat.SHORT);\nDateFormat f4 = DateFormat.getDateInstance(DateFormat.SHORT);\n\nif f3 == f4 always returns true, DateFormat is a factory\nif f3 == f4 always returns false, DateFormat is a factory','OOP',0,0,NULL,5),(2343,'','A factory can have a public constructor\n\na factory can reate a new object each time you call it ','OOP',0,0,NULL,5),(2344,'','overriding requires the use of IS A relationship','OOP',0,0,NULL,5),(2345,'','IS A relationships always rely on inheritance\n\nIS A relationships always require at least two class types\n\nPolymorphism always relies on IS A relationships','OOP',0,0,NULL,5),(2346,'tight coupling','BioDiesel b4 = new BioDiesel(new Viscosity());','OOP',0,0,NULL,5),(2347,'Got it','DAO implementation must implements an interface,\n\nincreases cohesion by seperating data access code from the object representing\nthe data','OOP',0,0,NULL,5),(2348,'object composition, method delegation','what is this an example of:\n\ninterface B { void c(); }\n\nclass A implements B {\n	private B;\n\n	public A(B b){ this.b = b; }\n\n	public void c(){ b.c(); }\n\n	public void d(){ }\n}','OOP',0,0,NULL,5),(2349,'singleton\nthough not good with the nameing convention, should be getInstance()','public class Stadium { \n	private static final Stadium i = new Stadium();\n	public static Stadium newStadium() {\n		return i;\n	}\n	private Stadium() { }\n}','OOP',0,0,NULL,5),(2350,'object composition','interface Box{\n    void pack();\n    void seal();\n}\n\ninterface Mailer {\n    void addPostage();\n    void ship();\n}\n\nclass GiftBox implements Box{\n    public void pack(){ }\n    public void seal() { }\n}\n\nclass MailerBox implements Box,Mailer {\n    private Box box;\n    public MailerBox(Box box){\n        this.box = box;\n    }\n    public void pack(){ box.pack(); }\n    public void seal(){ box.seal(); }\n    public void addPostage(){\n        System.out.println(\"post\");\n    }\n    public void ship(){\n        System.out.println(\"Put in a box\");\n    }\n}','OOP',0,0,NULL,5),(2351,'Daos should immplement an interface so that is is easy to swap out database\nimplementations','public interface BookDao {\n	Collection<Book> findAllBooks();\n	Book findBookByIsbn(Book book);\n	void create(Book book);	\n	void delet(Book book);\n	void update(Book book);\n}\n\npublic class inMemoryDao implements BookDao { }\n\n','OOP',0,0,NULL,5),(2352,'got it ','loose coupling is desirable, classes are well encapulated minimize reference\nto each other and limit the breadth of API use','OOP',0,0,NULL,5),(2353,'got it','Object compositoin takes advantage of ISA HASA and polymorphism','OOP',0,0,NULL,5),(2354,'got it ','a Factory creates any subclass of an interface or abstract class\nFactoy is an abstract class\nThe Factory method return type is an interface or abstract class\nreturns subclasses of the target subect','OOP',0,1,NULL,5),(2355,'','You want the factory class to be an abstract class so that\nyou can implement some concrete code if necesarry. ','OOP',0,0,NULL,5),(2356,'Factory, A is the object we are creating and G is the abstract super class\nfor the factory what is not shown is the subclass that impleents the factory. ','class A() { }\n\nabstract class G {\n	A m() { return n(); }\n	abstract A n();\n}\n\nwhich design pattern ?','OOP',0,0,NULL,5),(2357,'one, \n\nQueue\n\nQueue is a ordered collection of items.\n\nItems are deleted at one end called ‘front’ end of the queue.\n\nItems are inserted at other end called ‘rear’ of the queue.\n\nThe first item inserted is the first to be removed (FIFO).\n\nStack\n\nStack is a collection of items.\n\nIt allows access to only one data item: the last item inserted.\n\nItems are inserted & deleted at one end called ‘Top of the stack’.\n\nIt is a dynamic & constantly changing object.\n\nAll the data items are put on top of the stack and taken off the top\n\nThis structure of accessing is known as Last in First out structure (LIFO)','class Hello{\n    public static void main(String[] args) {\n        Queue<String> x = new PriorityQueue<>();\n        x.add(\"one\");\n        x.add(\"two\");\n        x.add(\"thread\");\n        System.out.println(x.poll());\n    }\n}','Generics',0,0,NULL,5),(2358,'WNC, TreeSet does not implement Queue so it does not have poll()','class Hello{\n    public static void main(String[] args) {\n        TreeSet<String> x = new TreeSet<>();\n        x.add(\"one\");\n        x.add(\"two\");\n        x.add(\"thread\");\n        System.out.println(x.poll());\n    }\n}','Collections',0,0,NULL,5),(2359,'A private member can be access via a reference variable from within the object\nthat private was declared.  \n\nMethods, Variables and Constructors that are declared private can only be \naccessed within the declared class itself.\n\n','class A {   \n      private void methodA() {System.out.println(\"Hello, I am A!\");}   \n      public static void main(String[] args) {   \n        A a = new A();   \n        a.methodA(); }   \n} ','General',0,0,NULL,5),(2360,'-3 -1 5\n\nit doesnt matter what order the numbers are added to the set, it is a treeset\n\nthe negate() creates a new set withc negated values they are then put into \nincreasing order','class Hello{\n    private Set<Integer> numbers = new TreeSet<Integer>();\n    public Hello(int...nums){\n        for(int n: nums){\n            numbers.add(n);\n        }\n    }\n    public Hello negate(){\n        Hello negatives = new Hello();\n        for(int n : numbers){\n            negatives.numbers.add(-n);\n        }\n        return negatives;\n    }\n    public void show(){\n        for(int n : numbers){\n            System.out.println(n+\" \");\n        }\n    }\n    public static void main(String[] args) {\n        new Hello(1,3,-5).negate().show();\n    }\n}','General',0,0,NULL,5),(2361,'42,\n\n100 is the initial capacity.\n\nThis sorts in reverse order. ','public static void main(String[] args) {\n        \n        Comparator<Integer> cmp = new Comparator<Integer>() {\n            public int compare(Integer n1, Integer n2){\n                return n2.compareTo(n1);\n            }\n        };\n        \n        PriorityQueue pq = new PriorityQueue<Integer>(100,cmp);\n        pq.addAll(Arrays.asList(16,8,42,15,4,23));\n        System.out.println(pq.poll());\n}','Collections',0,0,NULL,5),(2362,'Sea\n4 \nfalse\n\nput returns the value previously associated with the key, or null if there\nwas nothing with it previously. ','public static void main(String[] args) {\n        Map<Integer,String> lat = new HashMap<>();\n        lat.put(60,\"Sea\");\n        lat.put(66,\"circle\");\n        System.out.println(lat.put(62,\"island\"));\n        System.out.println(lat.put(60,\"ocean\"));\n        lat.put(65,\"island\");\n        System.out.println(lat.size() + \" \");\n        System.out.println(lat.containsValue(\"sea\") + \" \");\n}','Collections',0,0,NULL,5),(2363,'only return s and return null, \n\nalthough String and StringBuilder are both subtypes of charsequence they are\nnot necesarrily subtypes of whatever is passed in ','public <S extends CharSequence> S foo(S s){\n	//return s;\n	//return (Object) s;\n	//return s.toString();\n	//return new StringBuilder(s);\n	//return (S) new StringBUilder(s);\n	//return null\n}\n\nwhich compile?','Collections',0,0,NULL,5),(2364,'four one three two\n\nTreeSet assures no duplicate entries, it will return elements in natrual\norder for strings thats alphebetical. ','TreeSet map = new TreeSet();\nmap.add(\"one\");\nmap.add(\"two\");\nmap.add(\"three\");\nmap.add(\"four\")\nmap.add(\"one\");\nIterator it = map.iterator();\nwhile(it.hasNext()){\n	sout(	it.next() + \" \" );\n}','Collections',0,0,NULL,5),(2365,'V \nWallace \nDuncan \n42 \n\nqueue is a FIFO \n\na compiler warning will be produced but it will still compile and run without\nexception ','class Hello{\n   public static void main(String[] args){\n       Queue<String> q = new LinkedList<String>();\n       q.add(\"V\");\n       q.add(\"Wallace\");\n       q.add(\"Duncan\");\n       showAll(q);\n   }\n   \n   public static void showAll(Queue q) {\n       q.add(new Integer(42));\n       while(!q.isEmpty()){\n           System.out.println(q.remove()+ \" \");\n       }\n   }\n}','Collections',0,0,NULL,5),(2366,'only Integer.valueOf(\"-1\") and 0xCAFE\n\nThis TreeSet will allow only numbers but the numbers must be mutually comparable\nthe 108 is an integer so anything added afterward must be an integer.\n\n0xCAFE is a valid hex literal for an int. \n\n3.14 is a double. ','public static void main(String[] args){\n       TreeSet<Number> tree = new TreeSet<Number>();\n       tree.add(108);\n       //tree.add(3.14);\n       //tree.add(\"42\");\n       //tree.add(Integer.valueOf(\"-1\");\n       //tree.add(null);\n       //tree.add(new Long(123));\n       //tree.add(0XCAFE);\n       \n   }\n\nwhich will compile and run ?','Collections',0,0,NULL,5),(2367,'ClassCastExcepiton','public static void main(String[] args){\n       TreeSet<Number> tree = new TreeSet<Number>();\n       tree.add(108);\n       tree.add(3.14);\n       //tree.add(\"42\");\n       tree.add(Integer.valueOf(\"-1\"));\n       tree.add(null);\n       tree.add(new Long(123));\n       tree.add(0XCAFE);\n       \n   }','Collections',0,0,NULL,5),(2368,'Internally, a Java compiler operates over a richer set of types than those \nthat can be written down explicitly in a Java program. The compiler-internal\n types which cannot be written in a Java program are called non-denotable\n types. Non-denotable types can occur as the result of the inference used\n by diamond. Therefore, using diamond with anonymous inner classes is not \nsupported since doing so in general would require extensions to the class \nfile signature attribute to represent non-denotable types, a de facto JVM \nchange. It is feasible that future platform versions could allow use of \ndiamond when creating an anonymous inner class as long as the inferred type \nwas denotable.','diamond operator cannot be used with anonymous classes','General',0,0,NULL,5),(2369,'LinkedList\n\nallows duplicates and has methods apporopriate for pushing and popping from the\nstack addFirst() getFirst()','What collection would be best to implement a stack that does not have \nthe overhead of synchronized methods ?','Collections',0,0,NULL,5),(2370,'chain meter','public static void main(String[] args){\n       String[] s = { \"inch\", \"foot\", \"yard\", \"rod\", \"meter\" };\n       List list = Arrays.asList(s);\n       list.set(4,\"chain\");\n       System.out.println(s[4]);\n       s[2] = \"meter\";\n       System.out.println(\" \" + list.get(2));\n   }','Collections',0,0,NULL,5),(2371,'ArrayIndexOutofBoundsException you are refereing to place 4 when there is \nonly 3 indexs 0-3','public static void main(String[] args){\n       String[] s = { \"inch\", \"foot\", \"yard\", \"rod\" };\n       List list = Arrays.asList(s);\n       list.set(4,\"chain\");\n       System.out.println(s[4]);\n       s[2] = \"meter\";\n       System.out.println(\" \" + list.get(2));\n   }','Collections',0,0,NULL,5),(2372,'UnsupportedOerationException,\n\nwhen you use asList the list and array becomes bound at the hip. so changes\nin one refect in the other,\n\nyou can only reset indexes though you cannot make any new addition or removals\nto the list, and you cant add or remove from an array anyway.',' public static void main(String[] args){\n       String[] s = { \"inch\", \"foot\", \"yard\", \"rod\", \"meter\" };\n       List list = Arrays.asList(s);\n       list.set(4,\"chain\");\n       System.out.println(s[4]);\n       s[2] = \"meter\";\n       System.out.println(\" \" + list.get(2));\n       list.add(9);\n   }','Collections',0,0,NULL,5),(2373,'compiles fine. ','class BackLister {\n    public static <T> List<T> backwards(List<T> input)\n    {\n        List<T> output = new LinkedList<T>();\n        for(T t : input)\n            output.add(0,t);\n        return output;\n    }\n}','Collections',0,0,NULL,5),(2374,'public static <T> List<T> backwards(List<T> iput)\n	- a standard way to create a generic method\n\npublic static <T> List<T> backwards(List<? extends T> input)\n	-this says to the compile \" I want to be allowed to pass\n		in lsits of subtypes of the declared type but only\n		to invoke methods on the elements.\n\npublic static <T> List<? super T> backwards(List<T> input)\npublic static <T> List<? extends T> backwards(List<T> input)\n\n\npublic static <T> List<T> backwards(List<? super T> input)\n\n	this will nto compile because if the input can containt any super type\nof T then those elements couldn\'t be added to a collection of type T','class BackLister {\n    //insert here \n    {\n        List<T> output = new LinkedList<T>();\n        for(T t : input)\n            output.add(0,t);\n        return output;\n    }\n}\n\npublic static <T> List<T> backwards(List<T> iput)\npublic static <T> List<T> backwards(List<? extends T> input)\npublic static <? super T> List<T> backwards(List<T> input)\npublic static <? extends T> List<T> backwards(List<T> input)\npublic static <T> List<? extends T> backwards(List<T> input)\npublic static <T> List<T> backwards(List<? super T> input)\npublic static <T> List<? super T> backwards(List<T> input)\n\nwhich compile and run without error ?\n','Collections',0,0,NULL,5),(2375,'WNC,\n\nif the input can contain any super type of T then those elements couldn\'t be\nadded to a collection of type T.','class Hello{\n   public static void main(String[] args){\n       ArrayList<Integer> ints = new ArrayList<>();\n       ints.add(9);\n       ints.add(8);\n       ints.add(7);\n   }\n\n    public static <T> List<T> backwards(List<? super T> input)\n    {\n        List<T> output = new LinkedList<T>();\n        for(T t : input)\n            output.add(0,t);\n        return output;\n    }\n}','Collections',0,0,NULL,5),(2376,'WILL NEVER COPMPILE\n\ncannot use wildcards in the type declaration','public static <? extends T> List<T> backwards(List<T> input)','Collections',0,0,NULL,5),(2377,'WILL NEVER COMPILE\n\ncannot use wildcards in the type variable delcaraiotn','public static <? super T> List<T> backwards(List<T> input)','Collections',0,0,NULL,5),(2378,'got it ','CANNOT USE ? WILDCARDS IN THE TYPE VARIABLE DECLARATION OF THE GENERIC METHOD','Collections',0,0,NULL,5),(2379,'WNC,\n\nnon static type variable G cannot be used in static context','class Hello<G>{\n   public static void main(String[] args){\n       ArrayList<G> ints = new ArrayList<>();\n   }\n\n    public static <T> List<T> backwards(List<? super T> input)\n    {\n        ArrayList<G> ints = new ArrayList<>();\n        List<T> output = new LinkedList<T>();\n        for(T t : input)\n            output.add(0,t);\n        return output;\n    }\n}\n','Collections',0,0,NULL,5),(2380,'WNC non static type variable G cannot be referenced from a static context','class Hello<G>{\n   public static void main(String[] args){\n       \n   }\n\n    public static <T extends G> List<T> backwards(List<T> input)\n    {\n        List<T> output = new LinkedList<T>();\n        for(T t : input)\n            output.add(0,t);\n        return output;\n    }\n}','Collections',0,0,NULL,5),(2381,'','This is the first part of PECS i.e. PE (Producer extends). To more relate it to real life terms, let’s use an analogy of a basket of fruits (i.e. collection of fruits). When we pick a fruit from basket, then we want to be sure that we are taking out only fruit only and nothing else; so that we can write generic code like this:\n\nFruit get = fruits.get(0);\n\nIn above case, we need to declare the collection of fruits as List<? extends Fruit>. e.g.\nclass Fruit {\n   @Override\n   public String toString() {\n      return \"I am a Fruit !!\";\n   }\n}\n \nclass Apple extends Fruit {\n   @Override\n   public String toString() {\n      return \"I am an Apple !!\";\n   }\n}\n \npublic class GenericsExamples\n{\n   public static void main(String[] args)\n   {\n      //List of apples\n      List<Apple> apples = new ArrayList<Apple>();\n      apples.add(new Apple());\n       \n      //We can assign a list of apples to a basket of fruits;\n      //because apple is subtype of fruit \n      List<? extends Fruit> basket = apples;\n       \n      //Here we know that in basket there is nothing but fruit only\n      for (Fruit fruit : basket)\n      {\n         System.out.println(fruit);\n      }\n       \n      //basket.add(new Apple()); //Compile time error\n      //basket.add(new Fruit()); //Compile time error\n   }\n}','Collections',0,0,NULL,5),(2382,'','a producer will extend the type being used because it will possibly contain\nsubtypes, it is a producer therefore you shouldn\'t have to nor want to\nadd anything else to it. so <? extends G> is for producers nothing will be\nadded to this collection','Collections',0,0,NULL,5),(2383,'','class Fruit {\n   @Override\n   public String toString() {\n      return \"I am a Fruit !!\";\n   }\n}\n \nclass Apple extends Fruit {\n   @Override\n   public String toString() {\n      return \"I am an Apple !!\";\n   }\n}\n \nclass AsianApple extends Apple {\n   @Override\n   public String toString() {\n      return \"I am an AsianApple !!\";\n   }\n}\n \npublic class GenericsExamples\n{\n   public static void main(String[] args)\n   {\n      //List of apples\n      List<Apple> apples = new ArrayList<Apple>();\n      apples.add(new Apple());\n       \n      //We can assign a list of apples to a basket of apples\n      List<? super Apple> basket = apples;\n       \n      basket.add(new Apple());      //Successful\n      basket.add(new AsianApple()); //Successful\n      basket.add(new Fruit());      //Compile time error\n   }\n}\n\nWe are able to add apple and even Asian apple inside basket, but we are not\n able to add Fruit (super type of apple) to basket. Why?\n\nReason is that basket is a reference to a List of something that is a \nsupertype of Apple. Again, we cannot know which supertype it is, but we\n know that Apple and any of its subtypes (which are subtype of Fruit) can \nbe added to be without problem (you can always add a subtype in collection \nof supertype). So, now we can add any type of Apple inside basket.\n\nproducers use super','Collections',0,0,NULL,5),(2384,'WNC though it is not thrown go() declares that it throws an excpetion so it \nshould be handled by main','class Hello{\n   public static void main(String[] args){\n       new Hello().go();\n   }\n   void go() throws IOException {\n       String row;\n       try {\n          FileReader fr = new FileReader(\"TestFile.txt\");\n          BufferedReader br = new BufferedReader(fr);\n          while((row = br.readLine()) != null)\n               System.out.println(row);\n       } catch(IOException e){\n           System.out.println(\"IOERROR\");\n       } finally {\n           System.out.println(\"done\");    \n       }\n   }\n}','Exceptions',0,0,NULL,5),(2385,'multi catch may not contain exception types that are in the same heirarchy','class Party {\n    static class Rain extends Exception { }\n    static class Thunderstorm extends Rain{ }\n    public void eat() {\n        try {\n            bbq();\n        } catch(Rain | Thunderstorm e){\n            \n        }\n    }\n    private void bbq() throws Rain, Thunderstorm{ }\n}','Exceptions',0,0,NULL,5),(2386,'done\n\nboth assert statements are true so the methods are never called','class Hello{\n   public static int y;\n   public static void main(String[] args){\n       int t = 2;\n       assert t < 4 : bar(7);\n       assert t > 1 : foo(8);\n       System.out.println(\"done\");\n   }\n    public static int foo(int x) {\n        System.out.println(\"foo \");\n        return y = x;\n    }\n    public static int bar(int z) {\n        System.out.println(\"bar \");\n        return y = z;\n    }\n}','Exceptions',0,0,NULL,5),(2387,'finally\nException in thread \"main\" java.lang.ArrayIndexOutOfBoundsException: 0\n	at hello.Hello.main(Hello.java:53)\n/home/maxbisesi/.cache/netbeans/8.1/executor-snippets/run.xml:53: Java returned: 1\n\n\nTHe other two excpeitons weren\'t suppressed they were forgotten when \nfinally threw a new exception. \n\nso getSuppressed() cant find anything and throws the indexOB exception.','class Hello{\n    static class A implements AutoCloseable {\n        public void close() throws Exception {\n            throw new Exception(\"catch\");\n        }\n    }\n    \n    private static void method() throws Exception {\n        try(A a = new A()) {\n            throw new Exception(\"try\");\n        } finally {\n            throw new Exception(\"finally\");\n        }\n    }\n\n   public static void main(String[] args){\n       try {\n           method();\n       } catch(Exception e) {\n           System.out.println(e.getMessage());\n           System.out.println(e.getSuppressed()[0]);\n       }\n   }\n\n}','Exceptions',0,0,NULL,5),(2388,'got it','%[arg_index][flags][width][.precision]conversion char\n\nflags\n-=-=-=-=-=-\n- left justify\n+ include a sign\n0 pad argument with zeros\n, use locale specific grouping serperators\n( Enclose negative numbers in parentheses\n\nconversion chars\n-=-=-=-=-=-=-=-=-=-\nb boolean\nc char\nd integer\nf floating point\ns string','Strings',0,0,NULL,5),(2389,'got it','Barring booleans, if your conversion character doesn\'t match your argument type,\nan exception will be thrown','Strings',0,0,NULL,5),(2390,'>    317< \n>0000831< \n>+7566  < \n\n','private static void method() throws Exception {\n        int a = 831;\n        int b = 7566;\n        int c = 317;\n        System.out.printf(\">%1$(7d< \\n\",c);\n        System.out.printf(\">%0,7d< \\n\",a);\n        System.out.printf(\">%+-7d< \\n\",b);\n    }','Strings',0,0,NULL,5),(2391,'use locale specific seperators','format flags:\n\n,','Strings',0,0,NULL,5),(2392,'Encolose negative numbers in paranethes','format flags:\n\n(','Strings',0,0,NULL,5),(2393,'Pad this argument with zeroes','format flags:\n\n0','Strings',0,0,NULL,5),(2394,'Include a sign with this argument','format flags:\n\n+','Strings',0,0,NULL,5),(2395,'left justify this argument','format flags:\n\n-','Strings',0,0,NULL,5),(2396,'boolean\ncharacter\ninteger\nfloating point\nstring','format conversion chararcters:\n\nb\nc\nd\nf\ns','Strings',0,0,NULL,5),(2397,'The world is not enough, and there is no tomorrow\n\neverything after the conversion character is printed as is','private static void method() throws Exception {\n        int a = 831;\n        String s = \"The world is not enough\";\n        boolean yea = true;\n        \n        System.out.printf(\"%1$s, and there is no tomorrow\",s);\n    }','Strings',0,0,NULL,5),(2398,'831, and there is no tomorrow','private static void method() throws Exception {\n        int a = 831;\n        String s = \"The world is not enough\";\n        boolean yea = true;\n        \n        System.out.printf(\"%1$s, and there is no tomorrow\",a);\n    }','Strings',0,0,NULL,5),(2399,'831, and there is no tomorrow','private static void method() throws Exception {\n        int a = 831;\n        String s = \"The world is not enough\";\n        boolean yea = true;\n        \n        System.out.printf(\"%1$s, and there is no tomorrow\",a);\n    }','Strings',0,0,NULL,5),(2400,'831, and there is no tomorrow','private static void method() throws Exception {\n        int a = 831;\n        String s = \"The world is not enough\";\n        boolean yea = true;\n        \n        System.out.printf(\"%1$s, and there is no tomorrow\",a);\n    }','Strings',0,0,NULL,5),(2401,'831, and there is no tomorrow','private static void method() throws Exception {\n        int a = 831;\n        String s = \"The world is not enough\";\n        boolean yea = true;\n        \n        System.out.printf(\"%1$s, and there is no tomorrow\",a);\n    }','Strings',0,0,NULL,5),(2402,'831, and there is no tomorrow','private static void method() throws Exception {\n        int a = 831;\n        String s = \"The world is not enough\";\n        boolean yea = true;\n        \n        System.out.printf(\"%1$s, and there is no tomorrow\",a);\n    }','Strings',0,0,NULL,5),(2403,'831, and there is no tomorrow','private static void method() throws Exception {\n        int a = 831;\n        String s = \"The world is not enough\";\n        boolean yea = true;\n        \n        System.out.printf(\"%1$s, and there is no tomorrow\",a);\n    }','Strings',0,0,NULL,5),(2404,'831, and there is no tomorrow','private static void method() throws Exception {\n        int a = 831;\n        String s = \"The world is not enough\";\n        boolean yea = true;\n        \n        System.out.printf(\"%1$s, and there is no tomorrow\",a);\n    }','Strings',0,0,NULL,5),(2405,'831, and there is no tomorrow','private static void method() throws Exception {\n        int a = 831;\n        String s = \"The world is not enough\";\n        boolean yea = true;\n        \n        System.out.printf(\"%1$s, and there is no tomorrow\",a);\n    }','Strings',0,0,NULL,5),(2406,'831, and there is no tomorrow','private static void method() throws Exception {\n        int a = 831;\n        String s = \"The world is not enough\";\n        boolean yea = true;\n        \n        System.out.printf(\"%1$s, and there is no tomorrow\",a);\n    }','Strings',0,0,NULL,5),(2407,'831, and there is no tomorrowa','private static void method() throws Exception {\n        int a = 831;\n        String s = \"The world is not enough\";\n        boolean yea = true;\n        \n        System.out.printf(\"%1$s, and there is no tomorrow\",a);\n    }','Strings',0,0,NULL,5),(2408,'831, and there is no tomorrowa','private static void method() throws Exception {\n        int a = 831;\n        String s = \"The world is not enough\";\n        boolean yea = true;\n        \n        System.out.printf(\"%1$s, and there is no tomorrow\",a);\n    }','Strings',0,0,NULL,5),(2409,'831, and there is no tomorrowa','private static void method() throws Exception {\n        int a = 831;\n        String s = \"The world is not enough\";\n        boolean yea = true;\n        \n        System.out.printf(\"%1$s, and there is no tomorrow\",a);\n    }','Strings',0,0,NULL,5),(2410,'831, and there is no tomorrowa','private static void method() throws Exception {\n        int a = 831;\n        String s = \"The world is not enough\";\n        boolean yea = true;\n        \n        System.out.printf(\"%1$s, and there is no tomorrow\",a);\n    }','Strings',0,0,NULL,5),(2411,'831, and there is no tomorrowa','private static void method() throws Exception {\n        int a = 831;\n        String s = \"The world is not enough\";\n        boolean yea = true;\n        \n        System.out.printf(\"%1$s, and there is no tomorrow\",a);\n    }','Strings',0,0,NULL,5),(2412,'831, and there is no tomorrowa','private static void method() throws Exception {\n        int a = 831;\n        String s = \"The world is not enough\";\n        boolean yea = true;\n        \n        System.out.printf(\"%1$s, and there is no tomorrow\",a);\n    }','Strings',0,0,NULL,5),(2413,'831, and there is no tomorrowa','private static void method() throws Exception {\n        int a = 831;\n        String s = \"The world is not enough\";\n        boolean yea = true;\n        \n        System.out.printf(\"%1$s, and there is no tomorrow\",a);\n    }','Strings',0,0,NULL,5),(2414,'831, and there is no tomorrowa','private static void method() throws Exception {\n        int a = 831;\n        String s = \"The world is not enough\";\n        boolean yea = true;\n        \n        System.out.printf(\"%1$s, and there is no tomorrow\",a);\n    }','Strings',0,0,NULL,5),(2415,'         a  61         a  61         b  62         b  62         c  63         c  63         d  64         d  64         e  65         e  65         f  66\n         f  66         g  67         g  67         h  68         h  68         i  69         i  69         j  6a         j  6a         k  6b         k  6b         l  6c\n         l  6c         m  6d         m  6d         n  6e         n  6e         o  6f         o  6f         p  70         p  70         q  71         q  71         r  72\n         r  72         s  73         s  73         t  74         t  74         u  75         u  75         v  76         v  76         w  77         w  77         x  78\n         x  78         y  79         y  79         z  7a         z  7','public static void main(String[] args){\n        int count = 0;\n            for (int ch = \'a\'; ch <= \'z\'; ch++) {\n            System.out.printf(\"      %1$4c%1$4x\", ch);\n            if (++count % 6 == 0) {\n                 System.out.printf(\"%n\");\n             }\n        System.out.printf(\"      %1$4c%<4x\", ch);\n        }\n\n   }','Strings',0,0,NULL,5),(2416,'A\nThis is a string\nThis is also a string\nTHIS IS ALSO A STRING\n1234','public static void main( String args[] )\n   { \n      char character = \'A\';\n      String string = \"This is also a string\";\n      Integer integer = 1234;  // initialize integer (autoboxing)\n\n      System.out.printf( \"%c\\n\", character );\n      System.out.printf( \"%s\\n\", \"This is a string\" );\n      System.out.printf( \"%s\\n\", string );\n      System.out.printf( \"%S\\n\", string );\n      System.out.printf( \"%s\\n\", integer ); // implicit call to toString\n   }','Strings',0,0,NULL,5),(2417,'false\ntrue\ntrue\nFALSE\nHashcode of \"hello\" is 5e918d2\nHashcode of \"Hello\" is 42628b2\nHashcode of null is NULL\nPrinting a % in a format string\nPrinting a new line \nnext line starts here','public static void main( String args[] ) \n   {\n      Object test = null;\n      System.out.printf( \"%b\\n\", false );\n      System.out.printf( \"%b\\n\", true );\n      System.out.printf( \"%b\\n\", \"Test\" );\n      System.out.printf( \"%B\\n\", test );\n      System.out.printf( \"Hashcode of \\\"hello\\\" is %h\\n\", \"hello\" );\n      System.out.printf( \"Hashcode of \\\"Hello\\\" is %h\\n\", \"Hello\" );\n      System.out.printf( \"Hashcode of null is %H\\n\", test );\n      System.out.printf( \"Printing a %% in a format string\\n\" );\n      System.out.printf( \"Printing a new line %nnext line starts here\" );\n   }','Strings',0,0,NULL,5),(2418,'a boolean conversion character will convert anything non boolean to \"true\"\nand a false to boolean to \"false\"','public static void main(String[] args){\n        int count = 0;\n        String s = \" true\";\n        boolean yea = true;\n        boolean nah = false;\n        System.out.printf(\"use boolean to convert non-boolean\\n count:%b \\n s:%b \\n yea:%b \\n nah:%b \",count,s,yea,nah);\n   }','Strings',0,0,NULL,5),(2419,'use string to convert non-boolean\n count:0 \n s: true \n yea:true \n nah:false','public static void main(String[] args){\n        int count = 0;\n        String s = \" true\";\n        boolean yea = true;\n        boolean nah = false;\n        System.out.printf(\"use string to convert non-boolean\\n count:%s \\n s:%s \\n yea:%s \\n nah:%s \",count,s,yea,nah);\n   }','Strings',0,0,NULL,5),(2420,'got it ','At least five wide 	\n\nprintf(\"\'%5d\'\", 10); 	\'   10\'\n\nAt least five-wide, left-justified 	\n\nprintf(\"\'%-5d\'\", 10); 	\'10   \'\n\nAt least five-wide, zero-filled 	\n\nprintf(\"\'%05d\'\", 10); 	\'00010\'\n\nAt least five-wide, with a plus sign 	\n\nprintf(\"\'%+5d\'\", 10); 	\'  +10\'\n\nFive-wide, plus sign, left-justified 	\n\nprintf(\"\'%-+5d\'\", 10); 	\'+10  \'','Strings',0,0,NULL,5),(2421,'got it','The %3d specifier is used with integers, and means a minimum width of three\n spaces, which, by default, will be right-justified:\n\nprintf(\"%3d\", 0); 	0\nprintf(\"%3d\", 123456789); 	123456789\nprintf(\"%3d\", -10); 	-10\nprintf(\"%3d\", -123456789); 	-123456789','Strings',0,0,NULL,5),(2422,'got it','To left-justify integer output with printf, just add a minus sign (-) after\n the % symbol, like this:\n\nprintf(\"%-3d\", 0); 	0\nprintf(\"%-3d\", 123456789); 	123456789\nprintf(\"%-3d\", -10); 	-10\nprintf(\"%-3d\", -123456789); 	-123456789','Strings',0,0,NULL,5),(2423,'got it','As a summary of printf integer formatting, here’s a little collection of \ninteger formatting examples. Several different options are shown, including\n a minimum width specification, left-justified, zero-filled, and also a \nplus sign for positive numbers.\n\nAt least five wide 	printf(\"\'%5d\'\", 10); 	\'   10\'\nAt least five-wide, left-justified 	printf(\"\'%-5d\'\", 10); 	\'10   \'\nAt least five-wide, zero-filled 	printf(\"\'%05d\'\", 10); 	\'00010\'\nAt least five-wide, with a plus sign 	printf(\"\'%+5d\'\", 10); 	\'  +10\'\nFive-wide, plus sign, left-justified 	printf(\"\'%-+5d\'\", 10); 	\'+10  \'','Strings',0,0,NULL,5),(2424,'got it','A simple string 	printf(\"\'%s\'\", \"Hello\"); 	\'Hello\'\nA string with a minimum length 	printf(\"\'%10s\'\", \"Hello\"); 	\'     Hello\'\nMinimum length, left-justified 	printf(\"\'%-10s\'\", \"Hello\"); 	\'Hello     \'','Strings',0,0,NULL,5),(2425,'got it if the argument is larger than the width, it will be extended','Print one position after the decimal 	\n\nprintf(\"\'%.1f\'\", 10.3456); 	\'10.3\'\n\nTwo positions after the decimal 	\n\nprintf(\"\'%.2f\'\", 10.3456); 	\'10.35\'\n\nEight-wide, two positions after the decimal 	\n\nprintf(\"\'%8.2f\'\", 10.3456); 	\'   10.35\'\n\nEight-wide, four positions after the decimal 	\n\nprintf(\"\'%8.4f\'\", 10.3456); 	\' 10.3456\'\n\nEight-wide, two positions after the decimal, zero-filled 	\n\nprintf(\"\'%08.2f\'\", 10.3456); 	\'00010.35\'\n\nEight-wide, two positions after the decimal, left-justified 	\n\nprintf(\"\'%-8.2f\'\", 10.3456); 	\'10.35   \'\n\nPrinting a much larger number with that same format 	\n\nprintf(\"\'%-8.2f\'\", 101234567.3456); 	\'101234567.35\'','Strings',0,0,NULL,5),(2426,'Exception in thread \"main\" java.util.FormatFlagsConversionMismatchException: Conversion = s, Flags = (\n\nfor using flags that dont apply to strings','public static void main(String[] args){\n        int count = 0;\n        String s = \" true\";\n        boolean yea = true;\n        boolean nah = false;\n        System.out.printf(\"%1$(4s\",s);\n   }','Strings',0,0,NULL,5),(2427,'Exception in thread \"main\" java.util.FormatFlagsConversionMismatchException:\n Conversion = s, Flags = 0','public static void main(String[] args){\n        int count = 0;\n        String s = \" true\";\n        boolean yea = true;\n        boolean nah = false;\n        System.out.printf(\"%1$0s\",s);\n   }','Strings',0,0,NULL,5),(2428,'(34)\n\nit goes like this:\n\narg_index flags width precision conversion character\n\nso here the fomat string means index 1, pad with zeroes, \nwidth of three, enclose negatives in zero, convert from an int','public static void main(String[] args){\n        int count = -34;\n        String s = \" true\";\n        boolean yea = true;\n        boolean nah = false;\n        System.out.printf(\"%1$0(3d\",count);\n   }','Strings',0,0,NULL,5),(2429,'Exception in thread \"main\" java.util.IllegalFormatConversionException:\n d != java.lang.Double','public static void main(String[] args){\n        double count = -34.45;\n        String s = \" true\";\n        boolean yea = true;\n        boolean nah = false;\n        System.out.printf(\"%1$0(3d\",count);\n   }','Strings',0,0,NULL,5),(2430,'(34.450000)','public static void main(String[] args){\n        double count = -34.45;\n        String s = \" true\";\n        boolean yea = true;\n        boolean nah = false;\n        System.out.printf(\"%1$0(3f\",count);\n   }','Strings',0,0,NULL,5),(2431,'\nWNC\ncant return <? super Cards> when return type is <Card>','public static ArrayList<Card> findCardsWithNoCategory(ArrayList<? extends Card> list){\n        ArrayList<? super Card> cards = new ArrayList<Card>();\n        \n        for(Card c : list){\n            if(c.getCategory().equals(\"\") || c.getCategory().equals(\" \")){\n                cards.add(c);\n            }\n        }\n        \n        return cards;\n        \n    }','Generics',0,0,NULL,5),(2432,'Files.newDirectoryStream(Path p, String glob)\n\nDirectoryStream only uses glob\n\nso you dont have to say \"glob: *\"\n\nif you do it wont match anything','DirectoryStream dm = ...\n\nFileSystem.getDefault().getDirectoryStream(Path p, String glob);\n\nFiles.getDefault().newDirectoryStream(File f, String regex);\n\nFiles.getDefault().newDirectoryStream(Path p, String glob);\n\nFiles.newDirectoryStream(Path p, String glob);\n\nFiles.getDirectoryStream(Files f, String regex);\n\n','IO',0,0,NULL,5),(2433,'Files.newDirectoryStream(Path p, String glob)\n\nDirectoryStream only uses glob\n\nso you dont have to say \"glob: *\"\n\nif you do it wont match anything','DirectoryStream dm = ...\n\nFileSystem.getDefault().getDirectoryStream(Path p, String glob);\n\nFiles.getDefault().newDirectoryStream(File f, String regex);\n\nFiles.getDefault().newDirectoryStream(Path p, String glob);\n\nFiles.newDirectoryStream(Path p, String glob);\n\nFiles.getDirectoryStream(Files f, String regex);\n\n','IO',0,0,NULL,5),(2434,'Files.newDirectoryStream(Path p, String glob)\n\nDirectoryStream only uses glob\n\nso you dont have to say \"glob: *\"\n\nif you do it wont match anything','DirectoryStream dm = ...\n\nFileSystem.getDefault().getDirectoryStream(Path p, String glob);\n\nFiles.getDefault().newDirectoryStream(File f, String regex);\n\nFiles.getDefault().newDirectoryStream(Path p, String glob);\n\nFiles.newDirectoryStream(Path p, String glob);\n\nFiles.getDirectoryStream(Files f, String regex);\n\n','IO',0,0,NULL,5),(2435,'Files.newDirectoryStream(Path p, String glob)\n\nDirectoryStream only uses glob\n\nso you dont have to say \"glob: *\"\n\nif you do it wont match anything','DirectoryStream dm = ...\n\nFileSystem.getDefault().getDirectoryStream(Path p, String glob);\n\nFiles.getDefault().newDirectoryStream(File f, String regex);\n\nFiles.getDefault().newDirectoryStream(Path p, String glob);\n\nFiles.newDirectoryStream(Path p, String glob);\n\nFiles.getDirectoryStream(Files f, String regex);','IO',0,0,NULL,5),(2436,'comiles but will not match anything,\nDirectoryStream only takes globs so when you say glob: it trys to match a file\nlike that. ','try(DirectoryStream<Path> dm = Files.newDirectoryStream(home,\"glob:*\")){\n           for(Path path:dm){\n               System.out.println(path);\n           }\n           \n       } catch(IOException e){ System.out.println(e); }','IO',0,0,NULL,5),(2437,'FileSystems.getDefault().getPathMatcher(\"glob:TextFile?.*\");\n\nthe argument to getPathMatcher is (String syntaxandpatter)\n\nso that means it supports glob or regex.\n\nsyntax:pattern\n\nglob:*.txt\nregex:.*{.txt}\n\n*Dont put a space after the : that wll be included in the pattern','PathMatcher pm = ...\n\nFiles.getDefault().getPathMatcher(\"glob:file?.*\");\nFileSystems.getDefault().getPathMatcher(Path dir,\"TextFile?.*\");\nFileSystems.getPathMatcher(\"regex:TextFile?.*\");\nFiles.newPathMatcher(File file, String glob);\n\n','IO',0,0,NULL,5),(2438,'DirectoryNotEmptyException\n\nFiles.delete cannot delete a directory thats not empty','public static void main(String[] args){\n       \n       Path file = Paths.get(\"/home/maxbisesi/Public/Data/InnerDir/emptyFile.txt\");\n       try{\n           Files.createFile(file);\n           System.out.println(\"File created\");\n           Path dir = Paths.get(\"/home/maxbisesi/Public/Data/InnerDir\");\n           Files.delete(dir);\n       } catch(IOException e){\n           System.out.println(e);\n       }\n       \n            \n   }','IO',0,0,NULL,5),(2439,'File created\n/home/maxbisesi/Public/Data/InnerDir\n\nyou can rename a File dir even if it is not empty',' public static void main(String[] args){\n       	// imagine InnerDir contains one text file\n           File file = new File(\"/home/maxbisesi/Public/Data/InnerDir\");\n           file.mkdir();\n           System.out.println(\"File created\");\n           file.renameTo(new File(\"/home/maxbisesi/Public/Data/MaxsDir\"));\n           System.out.println(file);\n\n            \n   }','IO',0,0,NULL,5),(2440,'it will print its two messages then continue to run,\n\nwithout shutdown() the executor doesn\'t know when to stop. ','public class Hello {\n    public static void main(String[] args){\n        ExecutorService ex = Executors.newSingleThreadExecutor(); \n        Future<Integer> futint = ex.submit(new FileCounter());\n        \n        System.out.println(\"Do other things while the files are getting counted\");\n        \n        try{\n            int count = futint.get();\n            System.out.println(count);\n            //ex.shutdown();\n        }catch(ExecutionException | InterruptedException e){\n            \n        }\n        \n    }\n    \n    \n}\n\nclass FileCounter implements Callable<Integer>{\n    private int fileCount = 0;\n    public Integer call() throws IOException{\n        fileCount = count(Paths.get(\"/home/maxbisesi/Documents\"));\n        return fileCount; \n    }\n    \n    public Integer count(Path d) throws IOException {\n        int count = 0;\n	try(DirectoryStream<Path> stream = Files.newDirectoryStream(d)){\n		for(Path path: stream){\n			count++;\n		}\n	}\n        return count;\n    }\n}\nwhat will happen ? ','Executors',0,0,NULL,5),(2441,'got it \n\nshutdownNow() will call Thread.interrupt() in an attemtpt to terminate any \nunfinished tasks.','ExecutorService ex = \n//..\nex.shutdown(); // no more new task but finish the currently executing ones\n\ntry {\n	boolean term = ex.awaitTermination(2,TimeUnit.SECONDS);\n} catch(InterruptedException e){\n	//did not wait the full 2 seconds\n} finally {\n	if(!ex.isTerminated()) // are all tasks done ?\n	{\n		List<Runnable> unfinished = ex.shutdownNow();\n		//a collection of unfinished tasks\n	}\n}','Executors',0,0,NULL,5),(2442,'First entry:\nHired today: Mon Aug 07 16:43:51 EDT 2017\nStart first upcoming monday: Mon Aug 07 16:43:51 EDT 2017\nMicheal Boyd\nLast entry:\nHired a month ago: Fri Jul 07 16:43:51 EDT 2017\nVishv Zockler\n','public class Hello {\n    public static void main(String[] args){\n        try {\n            Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\");\n            PreparedStatement pst = conn.prepareStatement(\"Select * From employees limit 100\");\n            ResultSet rs = pst.executeQuery();\n            \n            Date d = new Date();\n            Calendar c = Calendar.getInstance();\n            c.setTime(d);\n\n            rs.first();\n            System.out.println(\"First entry:\");\n            System.out.println(\"Hired today: \"+d);\n            System.out.println(\"Start first upcoming monday: \"+firstNextMonday(d));\n            System.out.println(rs.getString(\"first_name\") + \" \" +rs.getString(\"last_name\"));\n            \n            c.add(Calendar.MONTH,-1);\n            Date monthago = c.getTime();\n            rs.last();\n            System.out.println(\"Last entry:\");\n            System.out.println(\"Hired a month ago: \"+monthago);\n            System.out.println(rs.getString(\"first_name\") + \" \" +rs.getString(\"last_name\"));\n        } catch(SQLException e){ }\n        \n    }\n    \n    public static Date firstNextMonday(Date d){\n        Calendar c = Calendar.getInstance();\n        c.setTime(d);\n        \n        while(c.get(Calendar.DAY_OF_WEEK) != c.MONDAY){\n            //c.add(1,DAY_OF_WEEK);\n            c.add(c.DAY_OF_WEEK,1);\n        }\n        \n        return c.getTime();\n        \n    }\n}','Executors',0,0,NULL,5),(2443,'ExecutorService ex = Executors.newFixedThreadPool(4);\n\nits none of those','create a fixed thread pool...\n\nExecutor ex = ExecutorService.newFixedThreadPool(4);\nExecutor ex = Executor.newFixedThreadPool(4);\nExecutorService = ExecutorService.newFixedThreadPool(4);\nExecutorService = Executors.newFixedThreadExecutor(4);','Executors',0,0,NULL,5),(2444,'added: true\nadded: true\nadded: true\nadded: true\nadded: true\nadded: true\nadded: true\nadded: true\nadded: true\nadded: true\nadded: true\nadded: true\nadded: true\nadded: true\nadded: true\nadded: true\nadded: true\nadded: true\nadded: true\nadded: true\nadded: false\nqueue is full offer will not add anymore\nadded: false\nqueue is full offer will not add anymore\nadded: false\nqueue is full offer will not add anymore\nadded: false\nqueue is full offer will not add anymore\nadded: false\nqueue is full offer will not add anymore\nadded: false\nqueue is full offer will not add anymore\nadded: false\nqueue is full offer will not add anymore\nadded: false\nqueue is full offer will not add anymore\nadded: false\nqueue is full offer will not add anymore\nadded: false\nqueue is full offer will not add anymore\nadded: false\nqueue is full offer will not add anymore\nadded: false\nqueue is full offer will not add anymore\nadded: false\nqueue is full offer will not add anymore\nadded: false\nqueue is full offer will not add anymore\nnull\n/home/maxbisesi/.config \n/home/maxbisesi/.nano \n/home/maxbisesi/Desktop \n/home/maxbisesi/.bash_history \n/home/maxbisesi/Templates \n/home/maxbisesi/examples.desktop \n/home/maxbisesi/.bashrc \n/home/maxbisesi/.gnupg \n/home/maxbisesi/.java \n/home/maxbisesi/.xsession-errors \n/home/maxbisesi/.local \n/home/maxbisesi/.dmrc \n/home/maxbisesi/.Xauthority \n/home/maxbisesi/.ICEauthority \n/home/maxbisesi/Music \n/home/maxbisesi/qb_aug6.sql \n/home/maxbisesi/Documents \n/home/maxbisesi/NetBeansProjects \n/home/maxbisesi/.netbeans \n/home/maxbisesi/Downloads ','public class Hello {\n\n    private static ArrayBlockingQueue<String> abq = new ArrayBlockingQueue<>(20);\n\n    public static void main(String[] args) {\n        //ExecutorService ex = ExecutorService.newFixedThreadPool(4);\n        ExecutorService ex = Executors.newFixedThreadPool(4);\n        Future<?> fut = ex.submit(new FileLister());\n        try{\n            System.out.println(fut.get()); // will print null\n        } catch(ExecutionException | InterruptedException e){ }\n        \n        for(String file : abq){\n            System.out.println(file+\" \");\n        }\n\n    }\n\n    static class FileLister implements Runnable {\n        public void run() {\n            Path home = Paths.get(\"/home/maxbisesi\");\n            try (DirectoryStream<Path> stream = Files.newDirectoryStream(home)) {\n                for (Path path : stream) {\n                    boolean added = false;\n                    added = abq.offer(path.toString());\n                    System.out.println(\"added: \"+added);\n\n                    if (!added) {\n                        System.out.println(\"queue is full offer will not add anymore\");\n                    }\n                }\n            } catch (IOException e) { }\n        }\n    }\n}','Concurrency',0,0,NULL,5),(2445,'Cat\ntrue\nSheep\nGoat\nCow\nBull\n\nqueues remove from the head, here remove() returns the object removed,\nthe remove(E e) return true or false, the eleemnts are sorted according to\ntheir compareTo which orders in ascending order by size. ','public class Hello {\n    public static void main(String[] dicks){\n        PriorityQueue<Animal> q = new PriorityQueue<>();\n        \n        q.add(new Animal(5,\"Sheep\"));\n        q.offer(new Animal(6,\"Goat\"));\n        q.offer(new Animal(10,\"Cow\"));\n        q.offer(new Animal(12,\"Bull\"));\n        q.offer(new Animal(3,\"Cat\"));\n        q.offer(new Animal(7,\"Sloth\"));\n        \n        System.out.println(q.remove());\n        System.out.println(q.remove(new Animal(7,\"Sloth\")));\n        \n        while(!q.isEmpty()){\n            System.out.println(q.poll());\n        }\n    }\n}\n\nclass Animal implements Comparable<Animal> {\n    private Integer size;\n    private String name;\n    \n    public Animal(int x, String y){\n        size = x;\n        name = y;\n    }\n    public Animal(){\n        size = 0;\n        name = \"\";\n    }\n\n    public int getSize() {\n        return size;\n    }\n\n    public String getName() {\n        return name;\n    }\n    \n    public String toString(){\n        return name;\n    }\n    \n    public int compareTo(Animal o){\n        return size.compareTo(o.getSize());\n        \n    }\n    \n        \n    public boolean equals(Object o){\n        if((o instanceof Animal)){\n            if((((Animal)o).getSize() == this.size) && (((Animal)o).getName().equals(name) ))\n                return true;\n            return false;           \n        } \n        return false;\n    }\n\n}','Collections',0,0,NULL,5),(2446,'java.nio.file.NoSuchFileException: /home/maxbisesi/Public/GenDir/genFile.txt\n\nthe directory must exist before a file is created in it. ','public static void main(String[] args){\n        try{\n            Path p = Paths.get(\"/home/maxbisesi/Public/GenDir/genFile.txt\");\n            Files.createFile(p);\n        } catch(IOException e){System.out.println(e);}\n        \n        \n    }\n\nGenDir directory does not exist. ','IO',0,0,NULL,5),(2447,'It should be jrs.insertRow(), the docs say that updateRow cannot be called\nwhile on the insert row. \n\nThis will not work, will throw a SQLException',' public void addFlashCard(Card c) {\n        try{\n            jrs.moveToInsertRow();\n            jrs.updateString(\"answer\",c.getAnswer());\n            jrs.updateString(\"card\",c.getCard());\n            jrs.updateString(\"category\",c.getCategory());\n            jrs.updateRow();\n            \n            System.out.printf(\"Flash Card added: today: %1$03d \\n last added:\\n %2$s \\n category:%3$s\",todaysCount,c.getCard(),c.getCategory());\n            todaysCount++;\n        } catch(SQLException e){\n            System.out.println(\"something went wrong adding flashcards to rowset\");\n            System.out.println(e);\n        }\n    }','JDBC',0,0,NULL,5),(2448,'true\nlast modified: August 8, 2017 at: 12:14 PM\nlast accessed: August 8, 2017 at: 3:58 PM\ncreated: August 8, 2017 at: 12:14 PM','public class Hello {\n\n    public static void main(String[] args) {\n        new Hello().printDateTime(Paths.get(\"/home/maxbisesi\"));\n    }\n\n    public void printDateTime(Path d) {\n        DateFormat df = DateFormat.getDateInstance(DateFormat.LONG);\n        DateFormat dftime = DateFormat.getTimeInstance(DateFormat.SHORT);\n        try {\n            BasicFileAttributes ba = Files.readAttributes(d, BasicFileAttributes.class);\n            String creationDate = df.format(ba.creationTime().toMillis());\n            String lastAccessedDate = df.format(ba.lastAccessTime().toMillis());\n            String lastModifiedDate = df.format(ba.lastModifiedTime().toMillis());\n\n            String creationTime = dftime.format(ba.creationTime().toMillis());\n            String lastAccessedTime = dftime.format(ba.lastAccessTime().toMillis());\n            String lastModifiedTime = dftime.format(ba.lastModifiedTime().toMillis());\n\n            System.out.println(ba.isDirectory());\n\n            System.out.println(\"last modified: \" + lastModifiedDate + \" at: \" + lastModifiedTime);\n            System.out.println(\"last accessed: \" + lastAccessedDate + \" at: \" + lastAccessedTime);\n            System.out.println(\"created: \" + creationDate + \" at: \" + creationTime);\n\n        } catch (IOException e) { System.out.println(e);}\n\n    }\n}','Strings',0,0,NULL,5),(2449,'WNC unreported IOException at Files.walkFileTree()\n\nnon static inner class FileInfoPrinter cant be access from static context','public class Hello {\n\n    public static void main(String[] args) {\n        Path home = Paths.get(\"/home/maxbisesi\");\n        Files.walkFileTree(home,new FileInfoPrinter());\n    }\n\n    public void printDateTime(Path d) {\n        DateFormat df = DateFormat.getDateInstance(DateFormat.LONG);\n        DateFormat dftime = DateFormat.getTimeInstance(DateFormat.SHORT);\n        try {\n            BasicFileAttributes ba = Files.readAttributes(d, BasicFileAttributes.class);\n            String creationDate = df.format(ba.creationTime().toMillis());\n            String lastAccessedDate = df.format(ba.lastAccessTime().toMillis());\n            String lastModifiedDate = df.format(ba.lastModifiedTime().toMillis());\n\n            String creationTime = dftime.format(ba.creationTime().toMillis());\n            String lastAccessedTime = dftime.format(ba.lastAccessTime().toMillis());\n            String lastModifiedTime = dftime.format(ba.lastModifiedTime().toMillis());\n\n            System.out.println(\"directory: \" + ba.isDirectory());\n\n            System.out.println(\"last modified: \" + lastModifiedDate + \" at: \" + lastModifiedTime);\n            System.out.println(\"last accessed: \" + lastAccessedDate + \" at: \" + lastAccessedTime);\n            System.out.println(\"created: \" + creationDate + \" at: \" + creationTime);\n\n        } catch (IOException e) {\n            System.out.println(e);\n        }\n\n    }\n\n    class FileInfoPrinter extends SimpleFileVisitor<Path> {\n\n        public FileVisitResult preVisitDirectory(Path file, BasicFileAttributes attrs) {\n            System.out.print(file);\n            printDateTime(file);\n            return FileVisitResult.CONTINUE;\n        }\n\n    }\n}','Strings',0,0,NULL,5),(2450,'maxbisesi\n\ngetFileName() is different from getName(int index)\n\nkeep in mind that getFileName() and getName return a Path','public static void main(String[] args) {\n        Path home = Paths.get(\"/home/maxbisesi\");\n        System.out.println(home.getFileName());\n    }\n}','IO',0,0,NULL,5),(2451,'This will print out the contents of the home directory but skipping hidden files\nthat begin with a . like .config.\n\nremember that FileVisitor goes down as deep as it can before returning back up the\ntree.\n\nand files and directories at the same level can get visited in any order. \n\n\n/home/maxbisesi\ndirectory: true\n\nlast modified: August 8, 2017 at: 12:14 PM\nlast accessed: August 8, 2017 at: 3:58 PM\ncreated: August 8, 2017 at: 12:14 PM\n\n/home/maxbisesi/Desktop\ndirectory: true\n\nlast modified: July 21, 2017 at: 9:15 AM\nlast accessed: August 9, 2017 at: 11:33 AM\ncreated: July 21, 2017 at: 9:15 AM\n\n/home/maxbisesi/Templates\ndirectory: true\n\nlast modified: July 21, 2017 at: 9:15 AM\nlast accessed: August 9, 2017 at: 11:33 AM\ncreated: July 21, 2017 at: 9:15 AM\n\n/home/maxbisesi/Music\ndirectory: true\n\nlast modified: July 21, 2017 at: 9:15 AM\nlast accessed: August 9, 2017 at: 11:33 AM\ncreated: July 21, 2017 at: 9:15 AM\n\n/home/maxbisesi/Documents\ndirectory: true\n\nlast modified: July 24, 2017 at: 9:51 AM\nlast accessed: August 9, 2017 at: 11:33 AM\ncreated: July 24, 2017 at: 9:51 AM\n\n/home/maxbisesi/Documents/Code\ndirectory: true\n\nlast modified: August 8, 2017 at: 11:59 AM\nlast accessed: August 8, 2017 at: 11:59 AM\ncreated: August 8, 2017 at: 11:59 AM\n\n/home/maxbisesi/Documents/resumes\ndirectory: true\n\nlast modified: July 24, 2017 at: 9:51 AM\nlast accessed: August 9, 2017 at: 11:33 AM\ncreated: July 24, 2017 at: 9:51 AM\n\n/home/maxbisesi/NetBeansProjects\ndirectory: true\n\nlast modified: July 29, 2017 at: 12:03 PM\nlast accessed: August 9, 2017 at: 11:33 AM\ncreated: July 29, 2017 at: 12:03 PM\n\n/home/maxbisesi/NetBeansProjects/SourceManager\ndirectory: true\n\nlast modified: July 22, 2017 at: 2:52 PM\nlast accessed: August 8, 2017 at: 3:09 PM\ncreated: July 22, 2017 at: 2:52 PM\n\n/home/maxbisesi/NetBeansProjects/SourceManager/dist\ndirectory: true\n\nlast modified: July 22, 2017 at: 2:52 PM\nlast accessed: August 9, 2017 at: 11:33 AM\ncreated: July 22, 2017 at: 2:52 PM\n\n/home/maxbisesi/NetBeansProjects/SourceManager/nbproject\ndirectory: true\n\nlast modified: July 22, 2017 at: 12:35 PM\nlast accessed: August 8, 2017 at: 3:09 PM\ncreated: July 22, 2017 at: 12:35 PM\n','public class Hello {\n\n    public static void main(String[] args) {\n        Path home = Paths.get(\"/home/maxbisesi\");\n        Hello h = new Hello();\n        Hello.FileInfoPrinter fip = h.new FileInfoPrinter();\n        try{\n            Files.walkFileTree(home,fip);\n        }catch(IOException e){ }\n    }\n\n    public static void printDateTime(Path d) {\n        DateFormat df = DateFormat.getDateInstance(DateFormat.LONG);\n        DateFormat dftime = DateFormat.getTimeInstance(DateFormat.SHORT);\n        try {\n            BasicFileAttributes ba = Files.readAttributes(d, BasicFileAttributes.class);\n            String creationDate = df.format(ba.creationTime().toMillis());\n            String lastAccessedDate = df.format(ba.lastAccessTime().toMillis());\n            String lastModifiedDate = df.format(ba.lastModifiedTime().toMillis());\n\n            String creationTime = dftime.format(ba.creationTime().toMillis());\n            String lastAccessedTime = dftime.format(ba.lastAccessTime().toMillis());\n            String lastModifiedTime = dftime.format(ba.lastModifiedTime().toMillis());\n\n            System.out.println(\"directory: \" + ba.isDirectory());\n            System.out.println(\"\");\n            System.out.println(\"last modified: \" + lastModifiedDate + \" at: \" + lastModifiedTime);\n            System.out.println(\"last accessed: \" + lastAccessedDate + \" at: \" + lastAccessedTime);\n            System.out.println(\"created: \" + creationDate + \" at: \" + creationTime);\n            System.out.println(\"\");\n\n        } catch (IOException e) {\n            System.out.println(e);\n        }\n\n    }\n\n    class FileInfoPrinter extends SimpleFileVisitor<Path> {\n        private Pattern p = Pattern.compile(\"\\\\..*\");\n        private Matcher hidden;\n        \n\n        public FileVisitResult preVisitDirectory(Path file, BasicFileAttributes attrs) {\n            hidden = p.matcher(file.getFileName().toString());\n            if(hidden.find()){\n                return FileVisitResult.SKIP_SUBTREE;\n            }\n            System.out.print(file);\n            System.out.println(\"\");\n            printDateTime(file);\n            return FileVisitResult.CONTINUE;\n        }\n\n    }\n}','IO',0,0,NULL,5),(2452,'BasicFileAttributes is absract cannot be instantiated.\n\nshould be:\n\n	BasicFileAttributes ba = Files.readAttributes(path,BasicFileAttributes.class);','public class Hello {\n\n    public static void main(String[] args) {\n        Path home = Paths.get(\"/home/maxbisesi\");\n        Hello h = new Hello();\n        Hello.FileInfoPrinter fip = h.new FileInfoPrinter();\n        try{\n            Files.walkFileTree(home,fip);\n        }catch(IOException e){ }\n    }\n\n    public static void printDateTime(Path d) {\n        DateFormat df = DateFormat.getDateInstance(DateFormat.LONG);\n        DateFormat dftime = DateFormat.getTimeInstance(DateFormat.SHORT);\n        try {\n            //BasicFileAttributes ba = Files.readAttributes(d, BasicFileAttributes.class);\n            BasicFileAttributes ba = new BasicFileAttributes(d, BasicFileAttributes.class);\n            String creationDate = df.format(ba.creationTime().toMillis());\n            String lastAccessedDate = df.format(ba.lastAccessTime().toMillis());\n            String lastModifiedDate = df.format(ba.lastModifiedTime().toMillis());\n\n            String creationTime = dftime.format(ba.creationTime().toMillis());\n            String lastAccessedTime = dftime.format(ba.lastAccessTime().toMillis());\n            String lastModifiedTime = dftime.format(ba.lastModifiedTime().toMillis());\n\n            System.out.println(\"directory: \" + ba.isDirectory());\n            System.out.println(\"\");\n            System.out.println(\"last modified: \" + lastModifiedDate + \" at: \" + lastModifiedTime);\n            System.out.println(\"last accessed: \" + lastAccessedDate + \" at: \" + lastAccessedTime);\n            System.out.println(\"created: \" + creationDate + \" at: \" + creationTime);\n            System.out.println(\"\");\n\n        } catch (IOException e) {\n            System.out.println(e);\n        }\n\n    }\n\n    class FileInfoPrinter extends SimpleFileVisitor<Path> {\n        private Pattern p = Pattern.compile(\"\\\\..*\");\n        private Matcher hidden;\n        \n\n        public FileVisitResult preVisitDirectory(Path file, BasicFileAttributes attrs) {\n            hidden = p.matcher(file.getFileName().toString());\n            if(hidden.find()){\n                return FileVisitResult.SKIP_SUBTREE;\n            }\n            System.out.print(file);\n            System.out.println(\"\");\n            printDateTime(file);\n            return FileVisitResult.CONTINUE;\n        }\n\n    }\n}','IO',0,0,NULL,5),(2453,'FileVisitor method throw IOExceptions,\n\nbut in overrides if you choose not to declare an exception that is ok, demonstrated\nhere. ','class FileInfoPrinter extends SimpleFileVisitor<Path> {\n        private Pattern p = Pattern.compile(\"\\\\..*\");\n        private Matcher hidden;\n        \n\n        public FileVisitResult preVisitDirectory(Path file, BasicFileAttributes attrs){\n            hidden = p.matcher(file.getFileName().toString());\n            if(hidden.find()){\n                return FileVisitResult.SKIP_SUBTREE;\n            }\n            //makeFileCreatedOnMonday(file);\n            System.out.print(file);\n            System.out.println(\"\");\n            printDateTime(file);\n            return FileVisitResult.CONTINUE;\n        }\n        \n        public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\n            makeFileCreatedOnMonday(file);\n            return FileVisitResult.CONTINUE;\n        }\n\n    }','IO',0,0,NULL,5),(2454,'got it','class DateAsker implements Runnable {\n    private final int priority;\n    \n    public DateAsker(){\n        priority = ThreadLocalRandom.current().nextInt(0,5);\n    }\n    \n    \n    public void run(){\n        DateGiver dg = DateGiver.heyyou();\n        BlockingQueue<Date> bq = dg.availability();\n        Calendar c = Calendar.getInstance();\n        \n        try{\n            if(priority >= 4){\n                \n                Date next = bq.take();// blocks until available\n                c.setTime(next);\n                c.add(Calendar.DAY_OF_WEEK,2);\n                bq.put(c.getTime()); // returns void blocks until spac is available\n                \n            } else if(priority < 4 && priority >= 3){\n                \n                Date next = bq.poll(2000,TimeUnit.SECONDS);\n                c.setTime(next);\n                //c.add(Calendar.WEEK_IN_MONTH,2);\n                c.add(Calendar.WEEK_OF_MONTH,2);\n                bq.offer(c.getTime()); // returns true if object was added. false if the queeu is bouned and full  \n\n            } else {\n                Date next = bq.element();// gets the head of the queue without removing it. Throws NoSuchElementException if queue is empty\n                c.roll(Calendar.DAY_OF_MONTH,6);\n                c.roll(Calendar.HOUR_OF_DAY,20);\n                c.set(Calendar.MONTH,Calendar.JANUARY);\n                \n                bq.add(c.getTime()); // throws IllegalStateException if queue is bounded and full.\n                        \n            }\n        } catch(InterruptedException e){\n            \n        }\n\n        \n        \n    }\n}','Concurrency',0,0,NULL,5),(2455,'Singelton','class DateGiver implements Runnable {\n    private BlockingQueue<Date> dates = new ArrayBlockingQueue<>(25);\n    private static final DateGiver INSTANCE = new DateGiver();\n    \n    private DateGiver(){\n        \n    }\n    \n    public static DateGiver heyyou(){\n        return INSTANCE;\n    }\n\n    public void run(){\n        try{\n            Date d = new Date();\n            Calendar c = Calendar.getInstance();\n            c.setTime(d);\n            while(dates.peek() != null){\n                c.add(Calendar.DAY_OF_MONTH, 1);\n                dates.put(c.getTime());\n            }\n        }catch(InterruptedException e){\n            System.out.println(\"Sorry I got interrupted\");\n        }\n        \n    }\n    \n    public BlockingQueue<Date> availability(){\n        return dates;\n    }\n}\n\nwhat design pattern is this ?','OOP',0,0,NULL,5),(2456,'The instance getting method needs to be static. ','class DateGiver implements Runnable {\n    private BlockingQueue<Date> dates = new ArrayBlockingQueue<>(25);\n    private static final DateGiver INSTANCE = new DateGiver();\n    \n    private DateGiver(){\n        \n    }\n    \n    public DateGiver heyyou(){\n        return INSTANCE;\n    }\n\n    public void run(){\n        try{\n            Date d = new Date();\n            Calendar c = Calendar.getInstance();\n            c.setTime(d);\n            while(dates.peek() != null){\n                c.add(Calendar.DAY_OF_MONTH, 1);\n                dates.put(c.getTime());\n            }\n        }catch(InterruptedException e){\n            System.out.println(\"Sorry I got interrupted\");\n        }\n        \n    }\n    \n    public BlockingQueue<Date> availability(){\n        return dates;\n    }\n}\n\nWhat is missing from making this pattern singelton ? ','OOP',0,0,NULL,5),(2457,'WNC, an ArrayBlockingQueue is bounded and needs to be created \nwith an initial capacity.\n\n','class DateGiver implements Runnable {\n    private BlockingQueue<Date> dates = new ArrayBlockingQueue<>();\n    private static final DateGiver INSTANCE = new DateGiver();\n    \n    private DateGiver(){\n        \n    }\n    \n    public static DateGiver heyyou(){\n        return INSTANCE;\n    }\n\n    public void run(){\n        try{\n            Date d = new Date();\n            Calendar c = Calendar.getInstance();\n            c.setTime(d);\n            while(dates.peek() != null){\n                c.add(Calendar.DAY_OF_MONTH, 1);\n                dates.put(c.getTime());\n            }\n        }catch(InterruptedException e){\n            System.out.println(\"Sorry I got interrupted\");\n        }\n        \n    }\n    \n    public BlockingQueue<Date> availability(){\n        return dates;\n    }\n}','OOP',0,0,NULL,5),(2458,'LinkedBlockingQueue','Which concurrent collection is Optionally bounded ?','Concurrency',0,0,NULL,5),(2459,'WNC cannot assign a value to final variable people. \n\ninterface variables are implicity constants. ','public class Hello {\n\n    public static void main(String[] args) {\n        \n        Burnable stick = new Burnable(){\n            public void burn(){\n                System.out.println(\"Theres \"+people+\" people here so get the fire going\");\n            }\n            \n            public int unburn(){\n                System.out.println(\"That\'s impossible\");\n                return 0;\n            }\n            \n            public void shakeoff(){\n                System.out.println(\"That was my shoe!\");\n            }\n            \n            public void lookwhosHere(){\n                people++;\n                System.out.println(\"hey now theres \"+people+\" here.\");\n            }\n            \n        };\n    }\n\n}\n\ninterface Burnable{\n    int people = 10;\n    void burn();\n    void shakeoff();\n    int unburn();\n}','Concurrency',0,0,NULL,5),(2460,'WNC you cannot guarentee that c wont be pointing to a list<Dog> so \nyou cannot assign what is coming out to a Beagle reference. It could be \nAnimal or Dog.','public class Hello<T> {\n    \n    public static void main(String[] args){\n        \n        Dog d = new Dog();\n        \n        ArrayList<? extends Dog> c = new ArrayList<Beagle>();\n        \n        Beagle a = c.get(0);\n    } \n}\n\nclass Animal{}\nclass Dog extends Animal { }\nclass Beagle extends Dog { }\nclass Marly extends Beagle{ }','Concurrency',0,0,NULL,5),(2461,'T does not bind to a specific class here. \n\n\nThis call does not bind T to a specific class. Java does not need to know the exact T because of type erasure implementation of the generics. As long as the types that you pass are consistent with the declaration, the code should compile; in your case, lists of Object and String are consistent with the declaration.\n\nLet\'s expand your code a little so that we could force binding of T to a specific type. Perhaps the easiest way to do it is to pass Class<T>, like this:\n\nstatic <T> void doSomething(List<? super T> list1, List<? extends T> list2, Class<T> cl) {\n    System.out.println(cl);\n}\n\nNow let us try calling doSomething with String.class and with Object.class:\n\ndoSomething(new ArrayList<Object>(), new ArrayList<String>(), Object.class);\ndoSomething(new ArrayList<Object>(), new ArrayList<String>(), String.class);\n\nBoth calls successfully compile, producing the output\n\nclass java.lang.Object\nclass java.lang.String','static <T> void doSomething(List<? super T> list1, List<? extends T> list2) { }\n\ndoSomething(new ArrayList<Object>(), new ArrayList<String>());\n\nWould T type evaluate as Object or String?\n','Generics',0,0,NULL,5),(2462,'helper methods can be used to capture the wildcard','public class WildcardFixed {\n\n    void foo(List<?> i) {\n        fooHelper(i);\n    }\n\n\n    // Helper method created so that the wildcard can be captured\n    // through type inference.\n    private <T> void fooHelper(List<T> l) {\n        l.set(0, l.get(0));\n    }\n\n}','Generics',0,0,NULL,5),(2463,'Compiles fine, any thing coming out of src should be able to be added to dest. \n','public class Hello {\n    \n    public static void main(String[] args){\n        ArrayList<Object> dogs = new ArrayList<>();\n        ArrayList<Object> marlies = new ArrayList<>();\n        \n        copy(dogs,marlies);\n    } \n    \n     public static <T> void copy(List<? super T> dest, List<? extends T> src) {\n         for(T t : src){\n             dest.add(t);\n         }\n    }  \n}\n\nclass Animal{}\nclass Dog extends Animal { }\nclass Beagle extends Dog { }\nclass Marly extends Beagle{ }','Generics',0,0,NULL,5),(2464,'compiles, anything coming the source has to be of type that is safe to be added\nto the dest. ','public class Hello {\n    \n    public static void main(String[] args){\n        ArrayList<Marly> dogs = new ArrayList<>();\n        ArrayList<Animal> marlies = new ArrayList<>();\n        \n        copy(marlies, dogs);\n    } \n    \n     public static <T> void copy(List<? super T> dest, List<? extends T> src) {\n         for(T t : src){\n             dest.add(t);\n         }\n    }  \n}\n\nclass Animal{}\nclass Dog extends Animal { }\nclass Beagle extends Dog { }\nclass Marly extends Beagle{ }','Generics',0,0,NULL,5),(2465,'12\nTurtle 1\nTurtle 2\nTurtle 1\nTurtle 1\nTurtle 2\nTurtle 1\nTurtle 1\nTurtle 1\nTurtle 1\nTurtle 1\nTurtle 1\nTurtle 1\n\nwhile it\'s true that Set don\'t allow duplicates it disallows them by using the \nequals method it can only use equals to among elements in the same bucket. So Because\nturtle didn\'t implement hashCode() all the elements went into seperate buckets\nand there was nothing to compare against.','public class Hello {\n  public static void main(String[] args){\n      LinkedHashSet<Turtle> t = new LinkedHashSet<>();\n      t.add(new Turtle(1)); t.add( new Turtle(2)); t.add(new Turtle(1));\n      t.add(new Turtle(1)); t.add( new Turtle(2)); t.add(new Turtle(1));\n      t.add(new Turtle(1)); t.add(new Turtle(1)); t.add(new Turtle(1));\n      t.add(new Turtle(1)); t.add(new Turtle(1)); t.add(new Turtle(1));\n      \n      System.out.println(t.size());\n      for(Turtle x : t){\n          System.out.println(x);\n      }\n\n  }\n   \n}\n\ninterface Hungry<E> { void munch(E x); }\nabstract class Animal { }\nabstract class Plant { }\nclass Grass extends Plant { }\n\nclass Turtle {\n    int size;\n    String name;\n    public Turtle(int z){\n        size = z;\n        name = \"Turtle \"+size;\n    }\n    \n    public boolean equals(Object o){\n        return (this.size == ((Turtle)o).size);\n    }\n    \n    public String toString(){\n        return name;\n    }\n    \n    //public int hashCode() { return size/5; }\n}','Collections',0,0,NULL,5),(2466,'all animals eat\nall animals eat\nall animals eat\nEat salmon','public class Hello<T> {\n    public static void main(String[] args){\n        Animal cat = new Animal(5);\n        Animal bear = new Bear();\n        \n        cat.eat();\n        Animal.eat();\n        bear.eat();\n        Bear.eat();\n\n    } \n }\n\nclass Animal{\n    private int size;\n    public Animal(int s){\n        size = s;\n    }\n    public static void eat(){\n        System.out.println(\"all animals eat\");\n    }\n    public void makeSound(){\n            System.out.println(\"Sound!\");\n            \n    }\n    \n    public int getSize(){\n        return size;\n    }\n\n    public boolean equals(Object o){\n        // equals without instanceof \n        if(((Animal)o).getSize() == this.size){\n            return true;\n        } else {\n            return false;\n        }\n        \n    }\n}\n\nclass Bear extends Animal{\n    private static int ALLBEARSAREBIG = 100;\n    \n    public Bear(){\n        super(ALLBEARSAREBIG);\n        \n    }\n    \n    public static void eat(){\n        System.out.println(\"Eat salmon\");\n    }\n    \n}','OOP',0,0,NULL,5),(2467,'/tmp/google/file.txt\n../../../tmp/google/file.txt\n/home/max/tmp/tmp/google/file.txt\nException in thread \"main\" java.lang.IllegalArgumentException: \'other\' is different type of Path\n\nif other is an abolute path resolve returns the other, p2 is  an absolute \npath.\n\na relative path cannot be contructed if only one of the paths have a root \ncomponent. ','class Hello {\n    public static void main(String[] args) {     \n        Path p1 = Paths.get(\"/home/max/tmp/\");\n        Path p2 = Paths.get(\"/tmp/google/file.txt\");\n        Path p3 = Paths.get(\"tmp/google/file.txt\");\n        System.out.println(p1.resolve(p2));\n        System.out.println(p1.relativize(p2));\n        System.out.println(p1.resolve(p3));\n        System.out.println(p1.relativize(p3));\n        \n    }\n\n}','IO',0,0,NULL,5),(2468,'got it\n\nrelativize: IllegalArgumentException\nresolve: /home/maxbisesi/Documents/Code','If one path is absolute and the other is relative relativize will throw \nan Illegal argument Exception.\n\nBoth have to be either relative or absolute. \n\n	Path p1 = Paths.get(\"/home/maxbisesi\");\n        Path p2 = Paths.get(\"Documents/Code\");\n        \n        System.out.println(p1.relativize(p2));\n        System.out.println(p1.resolve(p2));','IO',0,0,NULL,5),(2469,'got it','If the other path is absolute relativize will return the other \n\n    \n        Path p1 = Paths.get(\"/home/max/tmp/\");\n        Path p2 = Paths.get(\"/tmp/google/file.txt\");\n\n        System.out.println(p1.resolve(p2));\n\n	/tmp/google/file.txt','IO',0,0,NULL,5),(2470,'/tmp/google/file.txt\n../../../tmp/google/file.txt\n/home/max/tmp/tmp/google/file.txt\n/tmp/google/file.txt/tmp/google/file.txt\n../../../src/dist/all','class Hello {\n    public static void main(String[] args) {     \n        Path p1 = Paths.get(\"/home/max/tmp/\");\n        Path p2 = Paths.get(\"/tmp/google/file.txt\");\n        Path p3 = Paths.get(\"tmp/google/file.txt\");\n        Path p4 = Paths.get(\"src/dist/all\");\n        System.out.println(p1.resolve(p2));\n        System.out.println(p1.relativize(p2));\n        System.out.println(p1.resolve(p3));\n        System.out.println(p2.resolve(p3));\n        System.out.println(p3.relativize(p4));\n        \n    }\n\n}','IO',0,0,NULL,5),(2471,'got it ','Matcher.end() gives the position after the last character. \n\n	Pattern p = Pattern.compile(\".*y\");\n        Matcher m = p.matcher(\"yyxxxyxx\");\n						 012345678\n        \n        while(m.find()){\n            System.out.println(m.start());\n            System.out.println(m.group());\n            System.out.println(m.end());\n        }\n\nm.end() is 6','Strings',0,0,NULL,5),(2472,'b5 and b8\n\nA class Cast will result from trying to downcast. ','public class Hello{\n    public static void main(String[] args){\n        Bango b1 = new Bango();\n        Bango b2 = new Bongo();\n        Bango b3 = new Bingo();\n        \n        Bongo b4 = b2;\n        Bongo b5 = (Bongo)b1;\n        Bango b6 = b3;\n        Bango b7 = (Bango) b3;\n        Bingo b8 = (Bingo)b1;\n        Bingo b9 = (Bingo) b3;\n        Bango b10 = (Bongo) b3;\n    \n    }\n}\n\nclass Bango { }\nclass Bongo extends Bango { }\nclass Bingo extends Bongo { }\n\nwhich throw a ClassCastException ?','Strings',0,0,NULL,5),(2473,'Gemini\nGemini\nEunech','public class Hello {\n    private String name = \"marco\";\n    private final static String gem = \"Gemini\";\n    private static String west = \"Eunech\";\n   \n    public static void main(String[] args) {\n        Hello h = new Hello();\n        h.methodlocal();\n    }\n    \n    public static void methodlocal(){\n        final int y = 56;\n        //System.out.println(name); //wouldnt compile\n        System.out.println(gem);\n        \n        \n        class Zombie {\n            public int size;\n            public static final int num = 5;\n        \n            public Zombie(int x){ size = x; System.out.println(gem); System.out.println(west);} //System.out.println(name); }\n            public void mone(){\n                System.out.println(\"ughhhg: \"+ size);\n            }\n            \n            public void accessTheLiving(){\n                System.out.println(\"local var: \"+y);\n            }\n            \n        }\n        \n        Zombie zom = new Zombie(7);\n        \n    }\n\n}','Inner Classes',0,0,NULL,5),(2474,'Will not compile, at compile time the compiler does not know what type G is\ngoing to be even though its runtime type will be right, this can still not be\nallowed to compile. ','public class Hello<T> {\n    public static void main(String[] args){\n\n        ArrayList<? extends Animal> c = makeArrayList(new Animal(5));\n        \n        \n    } \n    public static <G extends Animal> ArrayList<G> makeArrayList(G g){\n        ArrayList<G> genlist = new ArrayList();\n        \n        Animal max = new Animal(100);\n        Animal bear = new Animal(45);\n        Animal Hippo = new Animal(45);\n        \n        genlist.add(max); \n        genlist.add(bear);\n        genlist.add(Hippo);\n        return genlist;\n        \n    }\n}','Generics',0,0,NULL,5),(2475,'Compiles','public class Hello {\n    public static void main(String[] args){\n\n        ArrayList<? extends Animal> c = makeArrayList(new Animal());\n        ArrayList<? extends Animal> b = makeArrayList(new Dog());\n        \n        \n    } \n    public static <G extends Animal> ArrayList<G> makeArrayList(G g){\n        ArrayList<G> genlist = new ArrayList();\n        genlist.add(g);\n        \n        return genlist;\n        \n    }\n}\n\nclass Dog extends Animal{}\nclass Beagle extends Dog { }\nclass Animal{}','Generics',0,0,NULL,5),(2476,'Will not compile, \n\nhere makeArrayList is only bounded by the INPUT the output is pretty straightforward\nit is excactly type G. Which is Below Dog in the Heirarchy so a Beagle \nList could not be applied to a ? super Dog list. ','public class Hello {\n    public static void main(String[] args){\n\n        ArrayList<? extends Animal> c = makeArrayList(new Animal());\n        ArrayList<? extends Animal> b = makeArrayList(new Dog());\n        ArrayList<? super Dog> a = makeArrayList(new Beagle());\n        \n        \n    } \n    public static <G extends Animal> ArrayList<G> makeArrayList(G g){\n        ArrayList<G> genlist = new ArrayList();\n        genlist.add(g);\n        \n        return genlist;\n        \n    }\n}\n\nclass Dog extends Animal{}\nclass Beagle extends Dog { }\nclass Animal{}','Generics',0,0,NULL,5),(2477,'This will compile.','public class Hello {\n    public static void main(String[] args){\n\n        ArrayList<? extends Animal> c = makeArrayList(new Animal());\n        ArrayList<? extends Animal> b = makeArrayList(new Dog());\n        ArrayList<? super Beagle> a = makeArrayList(new Beagle());\n        \n        \n    } \n    public static <G extends Animal> ArrayList<G> makeArrayList(G g){\n        ArrayList<G> genlist = new ArrayList();\n        genlist.add(g);\n        \n        return genlist;\n        \n    }\n}\n\nclass Dog extends Animal{}\nclass Beagle extends Dog { }\nclass Animal{}','Generics',0,0,NULL,5),(2478,'Will not compile, cannot add Dog to ArrayList typed for T ','public class Hello {\n    public static void main(String[] args){\n        Printer<String> x = Printer.getInstance();\n\n    }\n    public static <T> void addAnimal(List<T> animals) {\n	animals.add(new Dog());\n    }\n    \n    public <G> ArrayList<G> makeArrayList(G g){\n        ArrayList<G> genlist = new ArrayList();\n        genlist.add(g);\n        return genlist;\n        \n    }\n}\n\nclass Dog{ }','Generics',0,0,NULL,5),(2479,'First if you dont shutdown an executorService it will keep running and the \nprogram will never end.\n\nSecond the regex patter created is never applied to the lines coming in.','public class Hello {\n    \n    public static void main(String[] args){\n        Path file = Paths.get(\"/home/maxbisesi/Public/Data/sumOftwointsinarray.txt\");\n        FileSearcher fs = new FileSearcher(file,\"\\\\b\\\\w\\\\w\\\\w\\\\b\");\n        ExecutorService es = Executors.newCachedThreadPool();\n        System.out.println(\"We\'re wating on your search results\");\n        Future<HashMap<Integer,String>> futuresearch = es.submit(fs);\n        \n        try{\n            HashMap<Integer,String> searchresults;\n            searchresults = futuresearch.get();\n            HashMap<Integer,String> moreresults = futuresearch.get();\n            \n            if(searchresults == null){\n                System.out.println(\"There were no results bro\");\n                System.exit(0);\n            }\n            for(Map.Entry<Integer,String> entry : searchresults.entrySet()){\n                System.out.println(entry.getKey()+\" \"+entry.getValue()+\"\\n\");\n            }\n            \n        }catch(ExecutionException | InterruptedException e){\n            System.out.println(e);\n        }\n    }\n}\n\nclass FileSearcher implements Callable<HashMap<Integer,String>> {\n    private Path fileToLoad;\n    private String regex;\n    public FileSearcher(Path file,String reg){\n        fileToLoad = file;\n        regex = reg;\n    }\n    \n    public HashMap<Integer,String> call() throws IOException{\n        int linenum = 0;\n        HashMap<Integer,String> map = new HashMap<>();\n        BufferedReader br = new BufferedReader(new FileReader(fileToLoad.toFile()));\n        Pattern p = Pattern.compile(regex);\n        Matcher m;\n        String line;\n        while((line = br.readLine()) != null){\n            map.put(++linenum,line);\n        }\n        return map;\n    }\n}\n\nWhat are the flaws here ? ','General',0,0,NULL,5),(2480,'Exception in thread \"main\" java.util.InputMismatchException\n\nfor trying to read a string in as an int thats an exception','public class Hello {\n    \n    public static void main(String[] args){\n        String in = \"1 a 10 . 100 1000\";\n        Scanner s = new Scanner(in);\n        int accum\n        = 0;\n        for (int x = 0; x < 4; x++) {\n        accum += s.nextInt();\n        }\n        System.out.println(accum);\n    }\n}','Strings',0,0,NULL,5),(2481,'Will not compile, String cannot be converted to boolean.\n\nthe additional info in an assert statement must be a string. ','public static void main(String[] args) {\n            int x = 7;\n            assert (x == 6) ? \"x == 6\" : \"x != 6\";\n        }\n    }','Exceptions',0,0,NULL,5),(2482,'IllegalMonitorStateException\n\nthe method go() is synchronized, that means it will lock onto to the currently\nexecuting object. which Here is this, or the \'new Hello()\'\n\na new Thread is started and then waited on but thats not allowed because go\nis synchronized onto the current object.\n\nit should be:\n\n	Thread t1 = new Thread();\n        t1.start();\n        synchronized(t1){\n            System.out.print(\"1 \");\n            t1.wait(5000);\n            System.out.print(\"2 \");\n        }\n        \n        System.out.println(\"All done, main thread\");','public class Hello {\n\n    public static void main(String[] args) {\n        try {\n            new Hello().go();\n        } catch (Exception e) {\n            System.out.println(e);\n        }\n    }\n\n    synchronized void go() throws InterruptedException {\n        Thread t1 = new Thread();\n        t1.start();\n        System.out.print(\"1 \");\n        t1.wait(5000);\n        System.out.print(\"2 \");\n    }\n}','Threads',0,0,NULL,5),(2483,'1 2 All done, main thread','public class Hello {\n\n    public static void main(String[] args) {\n        try {\n            new Hello().go();\n        } catch (Exception e) {\n            System.out.println(e);\n        }\n    }\n\n    synchronized void go() throws InterruptedException {\n        Thread t1 = new Thread();\n        t1.start();\n        synchronized(t1){\n            System.out.print(\"1 \");\n            t1.wait(5000);\n            System.out.print(\"2 \");\n        }\n        \n        System.out.println(\"All done, main thread\");\n    }\n}','Threads',0,0,NULL,5),(2484,'WNC, \n\nyou cannot use a wildcard when creating a Generic class. ','class Printer<? extends Animal> {\n    private ArrayList<T> joblist = new ArrayList<>();\n    private T instance;\n    \n    public Printer(){\n        \n    }\n    \n    public Printer(T b){\n       instance = b;\n    }\n    \n    public void addJob(T t){\n        joblist.add(t);\n    }\n    \n    public void makeSound() {\n        instance.makeSound();\n    }\n    \n    public T getAnewT(){\n        return instance;\n    }\n}\n\nclass Animal{public void makeSound(){\n            System.out.println(\"Sound!\");\n}\n}\nclass Dog extends Animal{}\nclass Beagle extends Dog{}','Generics',0,0,NULL,5),(2485,'If a reference is null it is not an instance of anything. ',' public static void main(String[] args) {\n        String s = null;\n        if(s instanceof String){ System.out.println(\"It Worked\"); } \n        else { System.out.println(\"No\"); }\n \n    }','General',0,0,NULL,5),(2486,'true arrays are always objects any array of any type or primitive.','int[] nums = new int[4];\nif(nums instanceof Obejct){\n	sout( \"true\");\n}','General',0,0,NULL,5),(2487,'WNC you do not use instanceof to compare two references ',' public static void main(String[] args) {\n        List<Object> strlist = new ArrayList<>();\n        ArrayList<String> arraylst = new ArrayList<>();\n        ArrayList<Object> oblist = new ArrayList<>();\n        \n        if(arraylst instanceof strlist){\n            System.out.println(\"it worked!\");\n        } else{\n            System.out.println(\"no\");\n        }\n\n \n    }','General',0,0,NULL,5),(2488,'WNC, instanceof cannot test generic types. Generics are a compile time feature',' public static void main(String[] args) {\n        List<Object> strlist = new ArrayList<>();\n        ArrayList<String> arraylst = new ArrayList<>();\n        ArrayList<Object> oblist = new ArrayList<>();\n        \n        if(arraylst instanceof List<String>){\n            System.out.println(\"it worked!\");\n        } else{\n            System.out.println(\"no\");\n        }\n\n \n    }','General',0,0,NULL,5),(2489,'home\nmaxbisesi\nPublic\nData\nTextFile1.txt','public static void main(String[] args) {\n        Path p1 = Paths.get(\"/home/maxbisesi/Public/Data/TextFile1.txt\");\n        \n        System.out.println(p1.getName(0));\n        System.out.println(p1.getName(1));\n        System.out.println(p1.getName(2));\n        System.out.println(p1.getName(3));\n        System.out.println(p1.getName(4));\n    }','IO',0,0,NULL,5),(2490,'5\nIllegalArgumentException\n\nwith getName() the element that is the closest to the root directory, has an\nindex of 0. \n\nthrows an IllegalArgumentException if the index is greater than the number \nof elements. ','public static void main(String[] args) {\n        Path p1 = Paths.get(\"/home/maxbisesi/Public/Data/TextFile1.txt\");\n        System.out.println(p1.getNameCount());\n        System.out.println(p1.getName(5));\n    }','IO',0,0,NULL,5),(2491,'/\nnull\n\nReturns the root component of this path as a Path object, or null if this \npath does not have a root component.','public static void main(String[] args) {\n        Path p1 = Paths.get(\"/home/maxbisesi/Public/Data/TextFile1.txt\");\n        Path p2 = Paths.get(\"maxbisesi/Public/Data\");\n        System.out.println(p1.getRoot());\n        System.out.println(p2.getRoot());\n        \n    }','IO',0,0,NULL,5),(2492,'WNC,\n\ngetRoot() getName() subPath() resolve() relativize() toAbsolute() \n\nall return Path objects','public static void main(String[] args) {\n        Path p1 = Paths.get(\"/home/maxbisesi/Public/Data/TextFile1.txt\");\n        Path p2 = Paths.get(\"maxbisesi/Public/Data\");\n        String root = p1.getRoot();        \n    }','IO',0,0,NULL,5),(2493,'true\nfalse','public static void main(String[] args) {\n\n        Path p1 = Paths.get(\"/home/maxbisesi/Public/Data/TextFile1.txt\");\n        Path p2 = Paths.get(\"maxbisesi/Public/Data\");\n        \n        boolean ab = p1.isAbsolute();\n        boolean ab2 = p2.isAbsolute();\n        \n        System.out.println(ab);\n        System.out.println(ab2);\n        \n    }','IO',0,0,NULL,5),(2494,'/home/maxbisesi/Public/Data',' public static void main(String[] args) {\n\n        Path p1 = Paths.get(\"/home/maxbisesi/Public/Data/TextFile1.txt\");\n        \n        Path parent = p1.getParent();\n        \n        System.out.println(parent);\n        \n    }','IO',0,0,NULL,5),(2495,'/home/maxbisesi/Public/Data\nnull\n\ngetParent() \n	returns the paths parent or null if the path does not have a parent',' public static void main(String[] args) {\n\n        Path p1 = Paths.get(\"/home/maxbisesi/Public/Data/TextFile1.txt\");\n        Path p2 = Paths.get(\"maxbisesi/Public/Data\");\n        Path p3 = Paths.get(\"maxbisesi\");\n        \n        Path parent = p1.getParent();\n        Path parent2 = p3.getParent();\n        \n        System.out.println(parent);\n        System.out.println(parent2);\n        \n    }','IO',0,0,NULL,5),(2496,'true\n\nthe element that is closest to the root directory in the heirarchy has an\nindex of zero. ','Path methods getName() and subPath() all use zero based indexs ','IO',0,0,NULL,5),(2497,'maxbisesi/Public','public static void main(String[] args) {\n\n        Path p1 = Paths.get(\"/home/maxbisesi/Public/Data/TextFile1.txt\");\n        Path p2 = Paths.get(\"maxbisesi/Public/Data\");\n        \n        Path sub = p1.subpath(1,3); \n        \n        System.out.println(sub);\n        \n    }','IO',0,0,NULL,5),(2498,'home/maxbisesi/Public','public static void main(String[] args) {\n\n        Path p1 = Paths.get(\"/home/maxbisesi/Public/Data/TextFile1.txt\");\n        Path p2 = Paths.get(\"maxbisesi/Public/Data\");\n        \n        Path sub = p1.subpath(0,3); \n        \n        System.out.println(sub);\n        \n    }','IO',0,0,NULL,5),(2499,'Public/Data/TextFile1.txt\n\n    beginIndex - the index of the first element, inclusive\n    endIndex - the index of the last element, exclusive','public static void main(String[] args) {\n\n        Path p1 = Paths.get(\"/home/maxbisesi/Public/Data/TextFile1.txt\");\n        Path p2 = Paths.get(\"maxbisesi/Public/Data\");\n        \n        Path sub = p1.subpath(2,5); \n        \n        System.out.println(sub);\n        \n    }','IO',0,0,NULL,5),(2500,'learn it','Path subpath(int beginIndex,int endIndex)\n\n    beginIndex - the index of the first element, inclusive\n    endIndex - the index of the last element, exclusive','IO',0,0,NULL,5),(2501,'IllegalArgumentException\n\nonly 5 elemetns\n\n    beginIndex - the index of the first element, inclusive\n    endIndex - the index of the last element, exclusive','public static void main(String[] args) {\n\n        Path p1 = Paths.get(\"/home/maxbisesi/Public/Data/TextFile1.txt\");\n        Path p2 = Paths.get(\"maxbisesi/Public/Data\");\n        \n        Path sub = p1.subpath(2,6); \n        \n        System.out.println(sub);\n        \n    }','IO',0,0,NULL,5),(2502,'will read characters from the first file encode them and put them in the\nnext. ','public void scrambleFile(Path file) {\n        \n        FileReader inputStream = null;\n        FileWriter outputStream = null;\n\n        try {\n            inputStream = new FileReader(file.toFile());\n            Path fileToWrite = Paths.get(file.getParent().toString(),\"ScrambledFile\"+filecount+\".txt\");\n            outputStream = new FileWriter(fileToWrite.toString());\n\n            int c;\n            while((c = inputStream.read()) != -1){\n                Character a = key.get((char)c);\n                if(a == null){\n                    continue;\n                } else {\n                    outputStream.write((int)a);\n                }\n                \n            }\n            \n            inputStream.close();\n            outputStream.close();\n\n        } catch(IOException e){\n            System.out.println(e);\n        } \n        \n        filecount++;\n    }','IO',0,0,NULL,5),(2503,'MissingFormatWidthException\n\nwith - and 0 the width is required.','public static void main(String[] args) {\n        double count = -34.45;\n        String s = \" true\";\n        boolean yea = true;\n        boolean nah = false;\n        System.out.printf(\"%1$0(f\",count);\n        \n    }','IO',0,0,NULL,5),(2504,'got it ','java.util.formatter\n\nthe flags - and 0 require you to specify the width','Strings',0,0,NULL,5),(2505,'- and 0 ','what flags in java.util.formatter require you to specify the width ?','Strings',0,0,NULL,5),(2506,'IllegalMonitorStateException,\n\nthe running thread was not synchronized onto t1, \nyou must be synchronized onto an object to wait on it.','public class Hello extends Thread {\n    public static void main(String[] args){\n        new CodeMaker().start();\n    }\n}\n\nclass CodeMaker  extends Thread {\n    private String code;\n    private int counter;\n    private ArrayList<String> al;\n    private char[] letters = {\'A\',\'B\',\'C\',\'D\',\'E\',\'F\',\'G\',\'H\',\'I\'};\n    \n    public CodeMaker(){\n        counter = 0;\n        al = new ArrayList<>();\n    }\n\n    class SectionGenerator implements Runnable{\n        private String sec = \"\";\n        private Random ran = new Random();\n\n        public void run() {\n            //tried to use notify outside of synchronized context\n            synchronized(this){\n                int x = ran.nextInt(3);\n                int y = ran.nextInt(3);\n                int z = ran.nextInt(3);\n            \n            \n                sec += letters[x];\n                sec += letters[y];\n                sec += letters[z];\n                notifyAll();\n            }\n        }\n        \n        public synchronized String section(){\n            return sec;\n        }\n\n    }\n    \n    class NumberGenerator implements Runnable{\n        private String number = \"\";\n        private Random ran = new Random();\n        \n        public void run(){\n            //tried to use notify outside of synchronized context\n            synchronized(this){\n                int x1 = ran.nextInt(100);\n                int x2 = ran.nextInt(100);\n                int x3 = ran.nextInt(100);\n            \n                number += x1+\".\"+x2+\".\"+x3;\n                notifyAll();\n            }\n        }\n        \n        public synchronized String Number(){\n            return number;\n        }\n    }\n    \n   public synchronized void run(){\n       \n       SectionGenerator sg1 = new SectionGenerator();\n       NumberGenerator ng1 = new NumberGenerator();\n       Thread t1 = new Thread(sg1);\n       Thread t2 = new Thread(ng1);\n       \n       t1.start();\n       t2.start();\n       \n       try{\n        t1.wait();\n        code += sg1.section();\n        t2.wait();\n        code += ng1.Number();\n       } catch(InterruptedException e){\n           \n       }\n       System.out.println(code);\n\n       \n   }\n    \n    \n}\n','Threads',0,0,NULL,5),(2507,'its CONCUR_READ_ONLY not TYPE_READ_ONLY','public class Hello extends Thread {\n    public static void main(String[] args){\n        try(Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees\", \"root\", \"Basketball12\")){\n            String getAllEmployeeNames = \"select first_name,last_name from employees\";\n            Statement st1 = conn.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.TYPE_READ_ONLY);\n            \n            ResultSet empnames = st1.executeQuery(getAllEmployeeNames);\n            \n            empnames.last();\n            \n            System.out.println(empnames.getString(\"first_name\")+\" \"+empnames.getString(\"last_name\"));\n            \n        }catch(SQLException e){\n            System.out.println(e);\n        }\n    }\n}','JDBC',0,0,NULL,5),(2508,'Cristinel Bouloucos\nKazuhito Cappelletti\n\ncom.mysql.jdbc.NotUpdatable: Result Set not updatable.This result set must \ncome from a statement that was created with a result set type of \nResultSet.CONCUR_UPDATABLE, the query must select only one table, can not \nuse functions and must select all primary keys from that table. See the \nJDBC 2.1 API Specification, section 5.6 for more details.This result set \nmust come from a statement that was created with a result set type of \nResultSet.CONCUR_UPDATABLE, the query must select only one table, can not \nuse functions and must select all primary keys from that table. See the\n JDBC 2.1 API Specification, section 5.6 for more details.','public static void main(String[] args){\n        try(Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees\", \"root\", \"Basketball12\")){\n            String getAllEmployeeNames = \"select first_name,last_name from employees\";\n            Statement st1 = conn.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);\n            \n            ResultSet empnames = st1.executeQuery(getAllEmployeeNames);\n            \n            empnames.absolute(34);\n            System.out.println(empnames.getString(\"first_name\")+\" \"+empnames.getString(\"last_name\"));\n            empnames.previous();\n            System.out.println(empnames.getString(\"first_name\")+\" \"+empnames.getString(\"last_name\"));\n            empnames.deleteRow();\n            System.out.println(empnames.getString(\"first_name\")+\" \"+empnames.getString(\"last_name\"));\n            \n        }catch(SQLException e){\n            System.out.println(e);\n        }\n    }','JDBC',0,0,NULL,5),(2509,'CONCUR_UPDATABLE lets you delete rows. It will save those changes to the underlying db','public class Hello {\n    public static void main(String[] args){\n        try(Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees\", \"root\", \"Basketball12\")){\n            String getAllEmployeeNames = \"select emp_no,first_name,last_name from employees\";\n            Statement st1 = conn.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_UPDATABLE);\n            \n            ResultSet empnames = st1.executeQuery(getAllEmployeeNames);\n            \n            empnames.absolute(34);\n            System.out.println(empnames.getString(\"first_name\")+\" \"+empnames.getString(\"last_name\"));\n            empnames.previous();\n            System.out.println(empnames.getString(\"first_name\")+\" \"+empnames.getString(\"last_name\"));\n            empnames.deleteRow();\n            System.out.println(empnames.getString(\"first_name\")+\" \"+empnames.getString(\"last_name\"));\n            \n        }catch(SQLException e){\n            System.out.println(e);\n        }\n    }\n}','JDBC',0,0,NULL,5),(2510,'SCROLL SENSITIVE will show what chagnes you have made. ','public class Hello {\n    public static void main(String[] args){\n        try(Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees\", \"root\", \"Basketball12\")){\n            String getAllEmployeeNames = \"select emp_no,first_name,last_name from employees\";\n            Statement st1 = conn.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE,ResultSet.CONCUR_UPDATABLE);\n            \n            ResultSet empnames = st1.executeQuery(getAllEmployeeNames);\n            \n            empnames.absolute(40);\n            System.out.println(empnames.getString(\"first_name\")+\" \"+empnames.getString(\"last_name\"));\n            empnames.next();\n            System.out.println(empnames.getString(\"first_name\")+\" \"+empnames.getString(\"last_name\"));\n            empnames.next();\n            System.out.println(empnames.getString(\"first_name\")+\" \"+empnames.getString(\"last_name\"));\n\n            empnames.next();\n            System.out.println(empnames.getString(\"first_name\")+\" \"+empnames.getString(\"last_name\"));\n            empnames.updateString(\"first_name\",\"BIG MAX\");\n            empnames.updateRow();\n            System.out.println(empnames.getString(\"first_name\")+\" \"+empnames.getString(\"last_name\"));\n            \n            \n        }catch(SQLException e){\n            System.out.println(e);\n        }\n    }\n}','JDBC',0,0,NULL,5),(2511,'','Arrays/Collections must be sorted before being searched. Otherwise results\nwill be unpredictable','Collections',0,0,NULL,5),(2512,'abcd\nabc abc true\nabcd abcd true\n\nstrings are immutable','public static void main(String[] args) {\n	String s1 = \"abc\";\n	String s2 = s1;\n	System.out.println(s1+\"d\");\n	System.out.println(s1+\" \"+s2+\" \"+ (s1==s2));\n	\n	StringBuffer sb1 = new StringBuffer(\"abc\");\n	StringBuffer sb2 = sb1;\n	sb1.append(\"d\");\n	System.out.println(sb1+ \" \" + sb2 + \" \" + (sb1==sb2));\n    }','Strings',0,0,NULL,5),(2513,'builds the directory structure, throwing IOE if necessary','public static void main(String[] args) throws IOException {\n       File file1 = new File(\"/home/maxbisesi/Public/TestDir/file1\");\n       File file2 = new File(\"/home/maxbisesi/Public/TestDir/file2\");\n       File dir = new File(\"/home/maxbisesi/Public/TestDir\");\n       \n       if(dir.exists() && dir.isDirectory()){\n           file1.createNewFile();\n           file2.createNewFile();\n       } else {\n           dir.mkdir();\n           file1.createNewFile();\n           file2.createNewFile();\n       }\n    } ','IO',0,0,NULL,5),(2514,'all inner interfaces are implicitly static','public class Hello {\n    public static void main(String[] args){\n        \n    }\n    \n    interface Handeler{\n        void handle();\n    }\n}\n\nclass Adder implements Hello.Handeler {\n        public void handle(){\n            System.out.println(\"I got this.\");\n        }\n}','OOP',0,0,NULL,5),(2515,'got it','All variables in an interface are implicitly static','OOP',0,0,NULL,5),(2516,'got it ','interface varialbes are implicitly static and final','OOP',0,0,NULL,5),(2517,'does not compile in java 7','interface hungry{\n    static void milk();\n}','OOP',0,0,NULL,5),(2518,'B\nC\n\nthe jvm keeps a constant string pool. With strings == checks the similarity\nof the objects themselves.','public static void main(String[] args) {\n        String s1 = \"hi\";\n        String s2 = new String(\"hi\");\n        String s3 = \"hi\";\n        \n        if(s1 == s2){\n            System.out.println(\"A\");\n        } else{\n            System.out.println(\"B\");\n        }\n        \n        if(s1 == s3){\n            System.out.println(\"C\");\n        } else {\n            System.out.println(\"D\");\n        }\n        \n        \n    }','Strings',0,0,NULL,5),(2519,'true\nThe jvm keeps a pool of Strings and == compares the actuall strings ','public static void main(String[] args) {\n        String s1 = \"hi\";\n        String s3 = \"hi\";\n        \n        System.out.println((s1 == s3));\n        \n        \n    }','Strings',0,0,NULL,5),(2520,'0,0\n\nx=x only reassigns the passed parameter not the member. \n\nyou must use this.x = x;','public class Hello {\n    \n\n    public static void main(String[] args) {\n        Point2D p = new Point2D(10,20);\n        System.out.println(p);\n    }\n    \n}\n\nclass Point2D {\n    private int x,y;\n    \n    public Point2D(int x, int y){\n        x=x;\n    }\n    \n    public String toString(){\n        return x+\",\"+y;\n    }\n}','OOP',0,0,NULL,5),(2521,'k==j: true\nk.equals(j): true\n\nInteger objects are immutable just like strings are. \n\nIf there is an Integer object for a value already exists java will not \ncreate a new object. \n\ntwo integer objects are equal no matter if you use == or equals. Because object \nvalues are all imutable. ','public class Hello {\n    \n\n    public static void main(String[] args) {\n        Integer i = 10;\n        Integer j = 11;\n        Integer k = ++i;\n        System.out.println(\"k==j: \"+(k==j));\n        System.out.println(\"k.equals(j): \"+(k.equals(j)));\n    }\n    \n}','OOP',0,0,NULL,5),(2522,'false\nfalse \ntrue\n\narray objects dont have an equals method. There\'s is inherited from the \nObject class. \n\nThe two objects are not equal themselves they are both seperate.\n\nArrays class has various methods for testing equality of arrays. ','public static void main(String []args) {\n            int []arr1 = {1, 2, 3, 4, 5};\n            int []arr2 = {1, 2, 3, 4, 5};\n            System.out.println(\"arr1 == arr2 is \" + (arr1 == arr2));\n            System.out.println(\"arr1.equals(arr2) is \" + arr1.equals(arr2));\n\n            System.out.println(\"Arrays.equals(arr1, arr2) is \" +java.util.Arrays.equals(arr1, arr2));\n}','OOP',0,0,NULL,5),(2523,'Animal\nBear\nObject\nAnimal\n\noverloading is based on the static types of the objects\noverridig and runtime resolution resolves to the dynamic type. ','public class Hello {\n\n        public static void main(String []args) {\n            Animal a = new Animal();\n            Animal b = new Bear();\n            \n            overload(a);\n            overload((Bear)b);\n            overload((Object)b);\n            overload(b);\n            \n        }\n        \n        public static void overload(Animal a){\n            System.out.println(\"Animal\");\n        }\n        public static void overload(Bear b){\n            System.out.println(\"Bear\");\n        }\n        public static void overload(Grizzly g){\n            System.out.println(\"Grizzly\");\n        }\n        public static void overload(Object o){\n            System.out.println(\"Object\");\n        }\n}\n\nclass Animal{}\nclass Bear extends Animal{}\nclass Grizzly extends Bear{}','OOP',0,0,NULL,5),(2524,'foo(long)\n\nfor an integer literal the jvm matches in the following order:\n\n	int, long,Integer, int...\n\n','public class Hello {\n\n        public static void main(String []args) {\n                foo(10);\n        }\n        public static void foo(Integer i) { System.out.println(\"foo(Integer)\"); }\n        public static void foo(short i) { System.out.println(\"foo(short)\"); }\n        public static void foo(long i) { System.out.println(\"foo(long)\"); }\n        public static void foo(int ... i) { System.out.println(\"foo(int ...)\"); }\n}','OOP',0,0,NULL,5),(2525,'WNC reference to foo is ambiguous','public class Hello {\n\n        public static void main(String []args) {\n                foo(null);\n        }\n        public static void foo(Integer i) { System.out.println(\"foo(Integer)\"); }\n        public static void foo(short i) { System.out.println(\"foo(short)\"); }\n        public static void foo(long i) { System.out.println(\"foo(long)\"); }\n        public static void foo(int ... i) { System.out.println(\"foo(int ...)\"); }\n}','OOP',0,0,NULL,5),(2526,'A\nB\nC\nD\n\nhow to iterate through an enum. \n\nuse values()','enum Cards{ A,B,C,D };\npublic class Hello {\n\n        public static void main(String []args) {\n                for(Cards card: Cards.values()){\n                    System.out.println(card +\" \");\n                }\n        }\n\n}','General',0,0,NULL,5),(2527,'WNC,\n\nreference to name is ambiguous','abstract class AbstractBook {\n    public String name;\n}\n\ninterface sleepy{\n    public String name = \"undefined\";\n}\n\nclass Book extends AbstractBook implements sleepy{\n    public Book(String name){\n        this.name = name;\n    }\n            \n}\npublic class Hello {\n\n        public static void main(String []args) {\n           AbstractBook ab = new Book(\"Diamonds\");\n            System.out.println(ab.name);\n        }\n\n}','General',0,0,NULL,5),(2528,'the removed element is 1\n\nDeque is a double ended queue. \n\ncan be added and removed from the head or tail. ','public class Hello {\n\n    public static void main(String []args) {\n        Deque<Integer> deque = new ArrayDeque<>();\n        deque.addAll(Arrays.asList(1, 2, 3, 4, 5));\n        System.out.println(\"The removed element is: \" + deque.remove());\n    }\n}','General',0,0,NULL,5),(2529,'got it ','Dequeue methods:\n\n           First Element (Head) 	             Last Element (Tail)\n\n	Throws exception 	Special value 	Throws exception 	Special value\nInsert: 	addFirst(e) 	offerFirst(e) 	addLast(e) 	offerLast(e)\nRemove:	removeFirst() 	pollFirst() 	removeLast() 	pollLast()\nExamine: 	getFirst() 	peekFirst() 	getLast() 	peekLast()','Collections',0,0,NULL,5),(2530,'true','a LinkedList is a Dequeue','Collections',0,0,NULL,5),(2531,'5\n9\n5\n9\n1\n3\n\n',' public static void main(String []args) {\n        Deque<Integer> d = new ArrayDeque<>(5);\n        d.add(5);\n        d.add(1);\n        d.add(7);\n        d.add(1);\n        d.add(3); \n        d.add(9);\n        \n        System.out.println(d.getFirst());\n        System.out.println(d.getLast());\n        System.out.println(d.pollFirst());\n        System.out.println(d.pollLast());\n        System.out.println(d.removeFirst());\n        System.out.println(d.removeLast());\n    }','Collections',0,0,NULL,5),(2532,'remove throws an exception if the queue is empty','Dequeu whats the difference between pollFirst and removeFirst','Collections',0,0,NULL,5),(2533,'6\n5\n4\n3\n2\n1\nException in thread \"main\" java.util.NoSuchElementException\n\nremove throws an exception if queue is empty','public class Hello {\n\n    public static void main(String []args) {\n        Deque<Integer> d = new ArrayDeque<>(5);\n        d.add(1);\n        d.add(2);\n        d.add(3);\n        d.add(4);\n        d.add(5); \n        d.add(6);\n        \n        for(int i = 0; i < 10; i++){\n            System.out.println(d.removeLast());\n        }\n    }\n}','Collections',0,0,NULL,5),(2534,'6\n5\n4\n3\n2\n1\nnull\nnull\nnull\nnull\n\npoll returns null if empty','public class Hello {\n\n    public static void main(String []args) {\n        Deque<Integer> d = new ArrayDeque<>(5);\n        d.add(1);\n        d.add(2);\n        d.add(3);\n        d.add(4);\n        d.add(5); \n        d.add(6);\n        \n        for(int i = 0; i < 10; i++){\n            System.out.println(d.pollLast());\n        }\n    }\n}','Collections',0,0,NULL,5),(2535,'1\n1\n1\n1\n1\n1\n1\n element retrrieves but does not remove the head, similar to peek() only \nelement throws an exception if dequeu is empty','public static void main(String []args) {\n        Deque<Integer> d = new ArrayDeque<>(5);\n        d.add(1);\n        d.add(2);\n        d.add(3);\n        d.add(4);\n        d.add(5); \n        d.add(6);\n        \n        for(int i = 0; i < 10; i++){\n            System.out.println(d.element());\n        }\n    }','Collections',0,0,NULL,5),(2536,'getFirst getLast element removeFirst removeLast remove\n\nremove and removeFirst are equivalent','which dequeue methods throw exceptions if the queue is empty ? \n','Collections',0,0,NULL,5),(2537,'cool','A dequeue is FIFO therefore the methods that add and addLast are\nequivalent\n\nwhere the ones that remove and removeFirst are equivalent. ','Collections',0,0,NULL,5),(2538,'false true false true','public static void main(String []args) {\n\n            String pattern = \"a*b+c{3}\";\n            String []strings = { \"abc\", \"abbccc\", \"aabbcc\", \"aaabbbccc\" };\n            for(String str : strings) {\n                System.out.print(Pattern.matches(pattern, str) + \" \");\n            }\n    }','Strings',0,0,NULL,5),(2539,'true true  true true\n\n+ one or more \n* zero or more',' public static void main(String []args) {\n\n            String pattern = \"a*b+c+\";\n            String []strings = { \"abc\", \"abbccc\", \"aabbcc\", \"aaabbbccc\" };\n            for(String str : strings) {\n                System.out.print(Pattern.matches(pattern, str) + \" \");\n            }\n    }','Strings',0,0,NULL,5),(2540,'will compile and throw InvalidKeyException,\n\nfirst an overriden method does not have to throw an excpeiton if its super does\n\nsecond IllegalArgumentException is a runtime exception anyway so it does \nnot have to be declared thrown. ','class InvalidKeyException extends IllegalArgumentException{ }\n\nclass New {\n    public void foo() throws InvalidKeyException{ }\n}\npublic class Hello extends New {\n\n    public static void main(String []args) {\n        new Hello().foo();\n    }\n    \n    public void foo(){\n        throw new InvalidKeyException();\n    }\n        \n}','Exceptions',0,0,NULL,5),(2541,'in catch -> in finally->\n\nreturn means the function will return but finally will still be executed first.\n\n','public static void main(String []args) {\n        \n        try {\n            int i = 10/0; // LINE A\n            System.out.print(\"after throw -> \");\n        } catch(ArithmeticException ae) {\n            System.out.print(\"in catch -> \");\n            return;\n        } finally {\n            System.out.print(\"in finally -> \");\n        }\n            System.out.print(\"after everything\");\n    }','Exceptions',0,0,NULL,5),(2542,'Error + e \n\nyou should never catch an assertion error but if you were to It would be\ncaught by \'Error\'','public static void main(String []args) {\n	try {\n		assert false;\n	} catch(RuntimeException re) {\n		System.out.println(\"RuntimeException\");\n	} catch(Exception e) {\n		System.out.println(\"Exception\");\n	} catch(Error e) {\n		// LINE A\n		System.out.println(\"Error\" + e);\n	} catch(Throwable t) {\n		System.out.println(\"Throwable\");\n	}\n}\n\njava -ea Hello','Exceptions',0,0,NULL,5),(2543,'creates all the files and directories','public class Hello {\n\n    public static void main(String[] args) {\n        String[] fileList = {\"/file1.txt\", \"/subdir/file2.txt\", \"/file3.txt\"};\n        for (String file : fileList) {\n            try {\n                new File(file).mkdirs();\n            } catch (Exception e) {\n                System.out.println(\"file creation failed\");\n                System.exit(-1);\n            }\n        }\n   }\n}','IO',0,0,NULL,5),(2544,'Allen\nClark\nbob\nromeo\n\nthis shows that TreeSets sort there elements. And Capitols sort before lowers','public class Hello {\n\n    public static void main(String[] args) {\n      String names = \"<bob> romeo. Allen> ^ Clark\";\n      Set<String> words = new TreeSet<>();\n      try(Scanner tokenizer = new Scanner(names)){\n          tokenizer.useDelimiter(\"\\\\W\");\n          while(tokenizer.hasNext()){\n              String word = tokenizer.next();\n              if(!word.trim().equals(\"\")){\n                  words.add(word);\n              }\n          }\n          for(String word : words){\n              System.out.println(word);\n          }\n      }\n   }\n}','Strings',0,0,NULL,5),(2545,'0 1 \n\nwith subpath the element closest to the root is 0, the ending index is exclusive','Path wordpadPath = Paths.get(\"C:\\\\Program Files\\\\Windows NT\\\\Accessories\\\\wordpad.exe\");\nSystem.out.println(wordpadPath.subpath(beginIndex, endIndex));\n \nWhat are the values of the integer values beginIndex and endIndex in this program that will result in this code\nsegment printing the string “Program Files” as output?\n\na) beginIndex = 1 and endIndex = 2\nb) beginIndex = 0 and endIndex = 1\nc) beginIndex = 1 and endIndex = 1\nd) beginIndex = 4 and endIndex = 16','IO',0,0,NULL,5),(2546,'cool','Which one of the following options is a correct way to create a watch service for watching a directory for\nchanges?\n\nWatchService watch = FileSystems.getDefault().newWatchable();\nWatchService watcher = FileSystems.getDefault().newWatchService();\nWatchService dirWatcher = FileSystems.getDefault().newDirectoryWatchService();\nWatchService fileWatcher = FileSystems.getNewFileWatchService();\nWatchService fileDirWatcher = WatchService.getNewFileDirectoryWatchService();','IO',0,0,NULL,5),(2547,'c e \n\nd is wrong because CallabeStatement PreparedStatement, and Statement \nare not classes they are interfaces.\n','a) Objects of type Statement can handle IN, OUT, and INOUT parameters.\nb) PreparedStatement is used for executing stored procedures.\nc) You can get an instance of PreparedStatement by calling prepareStatement() method in the Connection\ninterface.\nd) CallableStatement extends the PreparedStatement class; PreparedStatement in turn extends the Statement\nclass.\ne) The interface Statement and its derived interfaces implement the AutoCloseable interface, hence it can be used\nwith try-with-resources statement.','JDBC',0,0,NULL,5),(2548,'sqlexception autocommit is true. \n\nyou cannot set a savepoint, rollback, or commit with autocommit on','// assume that connection is successfully established to the database\nconnection.setAutoCommit(true);\nStatement statement = connection.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE,\nResultSet.CONCUR_UPDATABLE);\nresultSet = statement.executeQuery(\"SELECT * FROM TempSensor\");\n \n// assume that the initial value of temp is \"0\" in the table\n \nresultSet.moveToInsertRow();\nresultSet.updateString(\"temp\", \"100\");\nresultSet.insertRow();\nSavepoint firstSavepoint = connection.setSavepoint();\n \nresultSet.moveToInsertRow();\nresultSet.updateString(\"temp\", \"200\");\nresultSet.insertRow();\nSavepoint secondSavepoint = connection.setSavepoint();\n \nresultSet.moveToInsertRow();\nresultSet.updateString(\"temp\", \"300\");\nresultSet.insertRow();\nSavepoint thirdSavepoint = connection.setSavepoint();\n \nconnection.rollback(secondSavepoint);\nconnection.commit();','JDBC',0,0,NULL,5),(2549,'worker\n\nthen hangs...\n\nwhen the current thread joins onto itself to terminate it never does because\nit is waiting for itslef.','class Worker extends Thread {\n    public void run() {\n        System.out.println(Thread.currentThread().getName());\n    }\n}\n \nclass Hello {\n    public static void main(String []args) throws InterruptedException {\n        Thread.currentThread().setName(\"Master \");\n        Thread worker = new Worker();\n        worker.setName(\"Worker \");\n        worker.start();\n        Thread.currentThread().join();\n        System.out.println(Thread.currentThread().getName());\n    }\n}','Threads',0,0,NULL,5),(2550,'[10, 5, 10, 20]\n[20, 5, 10]\n[5, 10, 20]\n[5, 10, 20]\n\nconcurrentSkipListSet is sorted.','class Hello {\n    public static void main(String []args) throws InterruptedException {\n        List list = Arrays.asList(10,5,10,20);\n        System.out.println(list);\n        System.out.println(new HashSet(list));\n        System.out.println(new TreeSet(list));\n        System.out.println(new ConcurrentSkipListSet(list));\n    }\n}','Collections',0,0,NULL,5),(2551,'c\n\nsince java cant find \n	ResourceBundle_fr_CA.properties\n	ResourceBundle_fr.properties\n\njava will search for canidate locales for teh base bundle named ResourceBundle and \na default locale\n\n	ResourceBundle_en_US.properties\n	ResourceBundle_en.properties','Assume that you’ve the following resource bundles in your classpath:\nResourceBundle.properties\nResourceBundle_ar.properties\nResourceBundle_en.properties\nResourceBundle_it.properties\nResourceBundle_it_IT_Rome.properties\n \nAlso assume that the default locale is English (US), where the language code is en and country code is US. Which\none of these five bundles will be loaded for the call\nloadResourceBundle(\"ResourceBundle\", new Locale(\"fr\", \"CA\", \"\"));?\n \na) ResourceBundle.properties\nb) ResourceBundle_ar.properties\nc) ResourceBundle_en.properties\nd) ResourceBundle_it.properties\ne) ResourceBundle_it_IT_Rome.properties','Locale',0,0,NULL,5),(2552,'only i will compile.\n\nputting a 0 in front of the numbers indicates that it is an octal which can \nbe applied to ints. ','public static void main(String []args) throws InterruptedException {\n        int i = 012;\n        int a = 10.0l;\n        int b = 10.0f;\n        int c = 10.0;\n    }','General',0,0,NULL,5),(2553,'ok',' public static void main(String []args) throws InterruptedException {\n        byte b = 100;\n        int i = 3456;\n        short s = 400;\n        long l = 6000;\n        float f = 356.0f;\n        double d = 45000.0;\n        \n        //commented assingments do not compile\n        i = b;\n        // b = i;\n        i = s;\n        //s = i;\n        l = i;\n        //i = l;\n        f = i;\n        //i = f;\n        f = l;\n        //l = f;\n        d = f;\n        //f = d;\n        d = s;\n        l = s;\n        l = b;\n        d = i;\n        f = s;\n        l = b;  \n    }','General',0,0,NULL,5),(2554,'NPE','public static void main(String []args){\n        Boolean b = null;\n        System.out.println(b ? true: false);\n                \n    }','General',0,0,NULL,5),(2555,' private Point() {\n	this(0, 0);\n}\n\nyou cannot call super and this. super or this should be the first calls \nin a constructor. ','class Point {\n        private int x = 0, y;\n        public Point(int x, int y) {\n        this.x = x;\n        this.y = y;\n    }\n        // DEFAULT_CTOR\n}\n\na) public Point() {\n	this(0, 0);\n	super();\n}\n \nb) public Point() {\n	super();\n	this(0, 0);\n}\n \nc) private Point() {\n	this(0, 0);\n}\n \nd) public Point() {\n	this();\n}\n \ne) public Point() {\n	this(x, 0);\n}\n\n\nWhich one of the following definitions of the Point constructor can be replaced without compiler\nerrors in place of the comment DEFAULT_CTOR?','General',0,0,NULL,5),(2556,'yes, instance of AnEnum\nyes, instance of EnumBase\nyes, instance of Enum\n\n\nyes, instance of AnEnum\nyes, instance of EnumBase\nyes, instance of Enum\n\nAn enumeration can implement an interface (but cannot extend a class, or cannot be\na base class).\nEach enumeration constant is an object of its enumeration type. An enumeration\nautomatically extends the abstract class java.util.Enum. Hence, all the three instanceof\nchecks succeed.','interface EnumBase { }\n \nenum AnEnum implements EnumBase {ONLY_MEM;}\n \nclass Hello {\n    public static void main(String []args) {\n        if(AnEnum.ONLY_MEM instanceof AnEnum) {\n            System.out.println(\"yes, instance of AnEnum\");\n        }\n        if(AnEnum.ONLY_MEM instanceof EnumBase) {\n            System.out.println(\"yes, instance of EnumBase\");\n        }\n        if(AnEnum.ONLY_MEM instanceof Enum) {\n            System.out.println(\"yes, instance of Enum\");\n        }\n    }\n}','General',0,0,NULL,5),(2557,'ok','enums can implement an interface,\n\ncannot extend a class, they already implicitly extend Enum class\n\nno class can extend an enum\n\nenum constants are objects of its class','General',0,0,NULL,5),(2558,'a) Enum can have private constructor.\nc) Enum can have public methods and fields.\nd) Enum can implement an interface.','Which of the following statements are true with respect to enums? \n\na) An enum can have private constructor.\nb) An enum can have public constructor.\nc) An enum can have public methods and fields.\nd) An enum can implement an interface.\ne) An enum can extend a class.','General',0,0,NULL,5),(2559,'Think of Enums as a class with a finite number of instances. \nThere can never be any different instances beside the ones you initially \ndeclare.\n\nThus, you cannot have a public or protected constructor, because that\n would allow more instances to be created.','enums cannot have public or protected constructors \n\nwhy ?','General',0,0,NULL,5),(2560,'compiles','interface EnumBase { }\n \nenum AnEnum implements EnumBase {\n    ONLY_MEM;\n    private AnEnum(){\n        \n    }\n}','General',0,0,NULL,5),(2561,'WNC','interface EnumBase { }\n \nenum AnEnum implements EnumBase {\n    ONLY_MEM;\n    public AnEnum(){\n        \n    }\n}','General',0,0,NULL,5),(2562,'compiles','interface EnumBase { }\n \nenum AnEnum implements EnumBase {\n    ONLY_MEM;\n     AnEnum(){\n        \n    }\n}','General',0,0,NULL,5),(2563,'WNC','interface EnumBase { }\n \nenum AnEnum implements EnumBase {\n    ONLY_MEM;\n    protected AnEnum(){\n        \n    }\n}','General',0,0,NULL,5),(2564,'b)\nClass Test is related with ClassC with a composition relationship.\nWhen a class inherits from another class, they share an is-a relationship. On the other\nhand, if a class uses another class (by declaring an instance of another class), then the first\nclass has a has-a relationship with the used class.','	class ClassA {}\n	interface InterfaceB {}\n	class ClassC {}\n\n	class Test extends ClassA implements InterfaceB {\n		String msg;\n		ClassC classC;\n	}\n\na) Class Test is related with ClassA with a has-a relationship.\nb) Class Test is related to ClassC with a composition relationship.\nc) Class Test is related with String with an is-a relationship.\nd) Class ClassA is related with InterfaceB with an is-a relationship.','General',0,0,NULL,5),(2565,'a) java.text.Format is the abstract base class that supports formatting of locale sensitive\ninformation such as date, time, and currency\nc) java.text.NumberFormat derives from java.text.Format class; it is the base class for\nprocessing numbers, currency, etc. in a locale sensitive way.\nd) java.text.DateFormat derives from java.text.Format class; it is the base class for\nprocessing date and time information based on locale.\nClass java.text.SimpleDateForma','a) j  ava.text.Format is the abstract base class that supports formatting of locale sensitive\ninformation such as date, time, and currency\n\nb) j  ava.text.CustomTimeFormat allows you to define custom patterns for processing\ntime for specific locales.\n\nc) j  ava.text.NumberFormat derives from the java.text.Format class; it is the base\nclass for processing numbers, currency, etc. in a locale sensitive way.\n\nd) j  ava.text.DateFormat derives from the java.text.Format class; it is the base class\nfor processing date and time information based on locale.','General',0,0,NULL,5),(2566,'b) AtomicInteger\nc) AtomicLong\n\nClasses AtomicInteger and AtomicLong extend Number class.\nAtomicBoolean does not extend java.lang.Number. Classes named as AtomicFloat or\nAtomicDouble do not exist in the java.util.concurrent.atomic package.','Which of the following classes in the java.util.concurrent.atomic package inherit from\njava.lang.Number? (Select all that apply).\na) AtomicBoolean\nb) AtomicInteger\nc) AtomicLong\nd) AtomicFloat\ne) AtomicDouble','General',0,0,NULL,5),(2567,'false \ntrue\n\nthe newly created object is not part of the student set so it will show false.\n\ns10 however is the excact object added. Since equals is not overriden, this \ncollection can only identify equal objects using the unoverriden equals()\nfrom object which says that two objects are equal only if they are the excact\nsame reference variable which in this case is true..','class Student{\n    public Student(int r) {\n    rollNo = r;\n    }\n\n    int rollNo;\n    public int hashCode(){\n        return rollNo;\n    }\n}\n\nclass Hello {\n        public static void main(String[] args){\n            HashSet<Student> students = new HashSet<>();\n            students.add(new Student(5));\n            Student s10 = new Student(10);\n            students.add(s10);\n            System.out.println(students.contains(new Student(10)));\n            System.out.println(students.contains(s10));\n        }\n}','Collections',0,0,NULL,5),(2568,'all four\n\nExecutor is an interface with a single method execute(Runnable r).\n\nWith Executor you create your own implementation to determine how you want threads\nto execute tasks. \n\nExecutor implementations in .concurrent package implement ExecutorService\nwhich is more complete\n\nExecutorService interface extends Executor. \n\nExecutors provides basic concrete implementations of these interfaces. ','a) The Executor interface declares a single method execute(Runnable command) that\nexecutes the given command at sometime in the future.\nb) The Callable interface declares a single method call() that computes a result.\nc) The Exchanger class provides a “synchronization point at which threads can pair and\nswap elements within pairs”.\nd) The TimeUnit enumeration represents time duration and is useful for specifying\ntiming parameters in concurrent programs.','Collections',0,0,NULL,5),(2569,'ok','Executor is an interface with a single method execute(Runnable r).\n\nWith Executor you create your own implementation to determine how you want threads\nto execute tasks. \n\nExecutor implementations in .concurrent package implement ExecutorService\nwhich is more complete\n\nExecutorService interface extends Executor. \n\nExecutors provides basic concrete implementations of these interfaces. ','Executors',0,0,NULL,5),(2570,'executor and singleton','public class JabRefExecutorService implements Executor {\n\n    public static final JabRefExecutorService INSTANCE = new JabRefExecutorService();\n    private static final Log LOGGER = LogFactory.getLog(JabRefExecutorService.class);\n    private final ExecutorService executorService = Executors.newCachedThreadPool(r -> {\n        Thread thread = new Thread(r);\n        thread.setName(\"JabRef CachedThreadPool\");\n        thread.setUncaughtExceptionHandler(new FallbackExceptionHandler());\n        return thread;\n\n    });\n    private final ExecutorService lowPriorityExecutorService = Executors.newCachedThreadPool(r -> {\n        Thread thread = new Thread(r);\n        thread.setName(\"JabRef LowPriorityCachedThreadPool\");\n        thread.setUncaughtExceptionHandler(new FallbackExceptionHandler());\n        return thread;\n    });\n    private final Timer timer = new Timer(\"timer\", true);\n    private Thread remoteThread;\n\n    private JabRefExecutorService() { }\n\n    @Override\n    public void execute(Runnable command) {\n        if (command == null) {\n            LOGGER.debug(\"Received null as command for execution\");\n            return;\n        }\n\n        executorService.execute(command);\n    }','Executors',0,0,NULL,5),(2571,'Arrays.asList returns an unmodifiable list. you cannot add or remove from it','class Hello {\n        public static void main(String[] args){\n            List<String> coaches = Arrays.asList(\"Joe\",\"Dean\",\"Will\",\"Aaron\");\n            System.out.println(coaches.remove(\"Joe\"));\n        }\n}','Collections',0,0,NULL,5),(2572,'Arrays.asList returns an unmodifiable list. you cannot add to it or remove from\nit. \n\n','class Hello {\n        public static void main(String[] args){\n            List<String> coaches = Arrays.asList(\"Joe\",\"Dean\",\"Will\",\"Aaron\");\n            //System.out.println(coaches.remove(\"Joe\"));\n            coaches.add(\"Reese\");\n        }\n}','Collections',0,0,NULL,5),(2573,'ok','Arrays.asList returns an umodifiable list you cannot add to it or remove\nfrom it or you will get an unsupportedoperationexception. ','Collections',0,0,NULL,5),(2574,'compiles fine. ','class Hello {\n        public static void main(String[] args){\n            List<String> coaches = Arrays.asList(\"Joe\",\"Dean\",\"Will\",\"Aaron\");\n            //System.out.println(coaches.remove(\"Joe\"));\n            coaches.set(0,\"Dan\");\n        }\n}','Collections',0,0,NULL,5),(2575,'115110\nThe string concatenation operator works as follows: if both the operands are numbers,\nit performs the addition; otherwise it concats the arguments by calling the toString()\nmethod if needed. It evaluates from left to right. Hence, the expression in the program\nresults in the string 115110.','class Test {\n	public static void main(String []args) {\n		String s = new String(\"5\");\n		System.out.println(1+10+s+1+10);\n	}\n}\n \na) 11511\nb) 1105110\nc) 115110\nd) 27','Strings',0,0,NULL,5),(2576,'wow ','The string concatenation operator works as follows: if both the operands are numbers,\nit performs the addition; otherwise it concats the arguments by calling the toString()\nmethod if needed. It evaluates from left to right. ','Strings',0,0,NULL,5),(2577,'a\n\nwith + if the expression is in () it evaluates first. + if the left arg\nis a string both will become strings.\n\nif the two are numbers then addition will be performed. ','class Test {\n	public static void main(String []args) {\n		String s = new String(\"5\");\n		System.out.println(1.0+10.5+s+(1.0+10.5));\n	}\n}\n \na) 11.5511.5\nb) 11.551.010.5\nc) 1.010.551.010.5\nd) 11.55(1.010.5)\ne) 11.55(11.5)','Strings',0,0,NULL,5),(2578,'hell\n00123\n\nIn first printf() method, %3.4s indicates that you want to print the first four characters\nof a string. In the second printf() method call, %05d indicates that you wanted to print\na minimum five digits of an integer. If the number does not have enough digits, then the\nnumber will be preceded by leading zeroes.\n\n\nYou can also use String.format(\"%3.3s\", \"abcdefgh\"). \nThe first digit is the minimum length (the string will be left \npadded if it\'s shorter), the second digit is the maxiumum length \nand the string will be truncated if it\'s longer. So\n\nSystem.out.printf(\"%3.3s%3.3s\", \"abcdefgh\", \"a\");\n\nwill produce\n\n\'abc  a\'','class Printf {\n	public static void main(String []args) {\n		System.out.printf(\"%3.4s %n\", \"hello world\");\n		System.out.printf(\"%05d\", 123);\n	}\n}','Strings',0,0,NULL,5),(2579,'ok','NumberFormatException is a runtime exception','General',0,0,NULL,5),(2580,'no:10 and 7\nno:2$s and 1$s\n\nThe format specifier string %$s indicates that you want to re-order the input values.\nA number (integer) sandwiched between a % and a $ symbol is used to re-order the\ninput values; the number indicates which input variable you want to put here. In %2$s\nit indicates that you want to put the second argument. Similarly, %1$s indicates that you\nwant to put the first argument.','class Test {\npublic static void main(String []args) {\nint a = 7, b = 10;\nSystem.out.printf(\"no:%2$s and %1$s\", a, b);\nSystem.out.printf(\"\\nno:2$s and 1$s\", a, b);\n}\n}','General',0,0,NULL,5),(2581,'\nb\nb\nb','class Test {\npublic static void main(String[] s) {\nString quote = \"aba*abaa**aabaa***\";\nString [] words = quote.split(\"a\\\\**\", 10);\nfor (String word : words) {\nSystem.out.println(word);\n}\n}\n}','Strings',0,0,NULL,5),(2582,'in regex ? indicates 0 or 1','class Test {\n	public static void main(String[] args) {\n		String str1 = \"xxzz\";\n		String str2 = \"xyz\";\n		String str3 = \"yzz\";\n		Pattern pattern = Pattern.compile(\"(xx)*y?z{1,}\");\n		Matcher matcher = pattern.matcher(str1);\n		System.out.println(matcher.matches());\n		System.out.println(pattern.matcher(str2).matches());\n		System.out.println(\n		Pattern.compile(\"(xx)*y?z{1,}\").\n		matcher(str3).matches());\n	}\n}','Strings',0,0,NULL,5),(2583,'Suneetha N.=9876543210, 9898989898: Patil,Pratish\n\n\n\npublic String replaceAll(String replacement)\n\nReplaces every subsequence of the input sequence that matches the pattern \nwith the given replacement string.\n\nThis method first resets this matcher. It then scans the input sequence \nlooking for matches of the pattern. Characters that are not part of any\n match are appended directly to the result string; each match is replaced \nin the result by the replacement string. The replacement string may contain references to captured subsequences as in the appendReplacement method.\n\nNote that backslashes (\\) and dollar signs ($) in the replacement string \nmay cause the results to be different than if it were being treated as a \nliteral replacement string. Dollar signs may be treated as references to\n captured subsequences as described above, and backslashes are used to \nescape literal characters in the replacement string.\n\nGiven the regular expression a*b, the input \"aabfooaabfooabfoob\", and \nthe replacement string \"-\", an invocation of this method on a matcher \nfor that expression would yield the string \"-foo-foo-foo-\".\n\nInvoking this method changes this matcher\'s state. If the matcher is\n to be used in further matching operations then it should first be\n reset. ','class Test {\n	public static void main(String[] args) {\n\n	String str =\"Suneetha N.=9876543210, Pratish Patil=9898989898\";\n\n	Pattern pattern =Pattern.compile(\"(\\\\w+)(\\\\s\\\\w+)(=)(\\\\d{10})\");\n\n	Matcher matcher = pattern.matcher(str);\n\n	String newStr = matcher.replaceAll(\"$4:$2,$1\");\n	System.out.println(newStr);\n}\n}\n ','Strings',0,0,NULL,5),(2584,'ok ','if a final variable is static it has be intitialized right away.','OOP',0,0,NULL,5),(2585,'concurrent modification exception\n\nTreeSets iterator: \n\n	The iterators returned by this class\'s iterator method are fail-fast: \nif the set is modified at any time after the iterator is created, in any \nway except through the iterator\'s own remove method, the iterator will\n throw a ConcurrentModificationException.','public static void main(String[] args) {\n\n            Set<String> set = new TreeSet<String>();\n            set.add(\"S\");\n            set.add(\"R\");\n            Iterator<String> iter = set.iterator();\n            set.add(\"P\");\n            set.add(\"Q\");\n            while(iter.hasNext()) {\n                System.out.print(iter.next() + \" \");\n            }\n    }','Collections',0,0,NULL,5),(2586,'how to correctly load an rb','public class Hello extends Thread {\n\n    public static void main(String[] args) {\n\n         ResourceBundle resBundle = ResourceBundle.getBundle(\"ResourceBundle\", new Locale(\"it\", \"IT\", \"\"));\n         System.out.println(resBundle.getObject(new Integer(1).toString()));\n    }\n        \n     \n}\n\nclass ResourceBundle_it_IT extends ListResourceBundle {\n\n    public Object[][] getContents() {\n        return contents;\n    }\n    static final Object[][] contents = {\n        {\"1\", \"Uno\"},\n        {\"2\", \"Duo\"},\n        {\"3\", \"Trie\"},};\n}','Locale',0,0,NULL,5),(2587,'CopyOnWrite Collections will allow concurrent modification','public static void main(String[] args) {\n\n            Set<String> set = new CopyOnWriteArraySet<String>();\n            set.add(\"2\");\n            set.add(\"1\");\n            Iterator<String> iter = set.iterator();\n            set.add(\"3\");\n            set.add(\"-1\");\n            while(iter.hasNext()) {\n                System.out.print(iter.next() + \" \");\n            }\n    }','Collections',0,0,NULL,5),(2588,'the proper name of a resource bundle has its package in front. ','ResourceBundle resBundle = ResourceBundle.getBundle(\"hello.ResourceBundle\", new Locale(\"it\", \"IT\", \"\"));\n            System.out.println(resBundle.getObject(new Integer(1).toString()));','Locale',0,0,NULL,5),(2589,'One Thread continously interates throgh the set while the other continusly adds\nnew things to it. \n\nThis is allowed with a COWSet. \n\nThough if the Iterator is obtained then an element is added that iterator\nwill not change it will print the elements that were in the set at the time\nof Instantiation of the iterator. ','public class Hello extends Thread {\n    Set<String> set = new CopyOnWriteArraySet<String>();\n    \n    public Hello(){\n        set.add(\"2\");\n        set.add(\"1\");\n        set.add(\"3\");\n        set.add(\"-1\");\n    }\n\n    public static void main(String[] args) {\n        //Thread t1 = new ConcAdder();\n        Hello h = new Hello();\n        Hello.ConcAdder ca = h.new ConcAdder();\n        ca.start();\n        \n        Hello.ConcIter ci = h.new ConcIter();\n        ci.start();\n\n    }\n    \n    class ConcAdder extends Thread{\n        private String[] letters = {\"A\",\"B\",\"C\",\"D\"};\n        public void run(){\n            while(true){\n                try{\n                    sleep(1000);\n                    int a = ThreadLocalRandom.current().nextInt(0,3);\n                    set.add(letters[a]);\n                } catch(InterruptedException e){\n                    \n                }\n            }\n            \n        }\n    }\n    \n    class ConcIter extends Thread {\n        public void run(){\n            while(true){\n                Iterator<String> it = set.iterator();\n\n                while(it.hasNext()){\n                    System.out.println(it.next());\n                }\n                \n                try{\n                    sleep(1000);\n                } catch(InterruptedException e){ }\n            }\n        }\n        \n    }    \n}\n','Concurrency',0,0,NULL,5),(2590,'ok','\npublic interface Iterable<T>\n\nImplementing this interface allows an object to be the target of the\n \"foreach\" statement.\n\n\nIterator<E> is an interface too	','General',0,0,NULL,5),(2591,'2\nException in thread \"Thread-2\" java.lang.UnsupportedOperationException\n1\n3\n-1\n\nYou cannot mutate the collection with Iterator methods when using \na COW colleciton. \n\nThe collection is only thread safe because it copies its entire internal array\nevery time something is added or removed. \n\nSo when an iterator is obtained it gives one copy of the immutable internal\narray. You cannot mutate an array which gives the unsupportedOperation excepiton.','public class Hello extends Thread {\n    Set<String> set = new CopyOnWriteArraySet<String>();\n    \n    public Hello(){\n        set.add(\"2\");\n        set.add(\"1\");\n        set.add(\"3\");\n        set.add(\"-1\");\n    }\n\n    public static void main(String[] args) {\n        //Thread t1 = new ConcAdder();\n        Hello h = new Hello();\n        Hello.ConcAdder ca = h.new ConcAdder();\n        ca.start();\n        \n        Hello.ConcIter ci = h.new ConcIter();\n        ci.start();\n\n    }\n    \n    class ConcAdder extends Thread{\n        private String[] letters = {\"A\",\"B\",\"C\",\"D\"};\n        public void run(){\n            while(true){\n                    int a = ThreadLocalRandom.current().nextInt(0,3);\n                    set.add(letters[a]);\n            }\n            \n        }\n    }\n    \n    class ConcIter extends Thread {\n        public void run(){\n            while(true){\n                Iterator<String> it = set.iterator();\n\n                while(it.hasNext()){\n                    System.out.println(it.next());\n                }\n                \n                it.remove();\n            }\n        }\n        \n    }    \n}','Concurrency',0,0,NULL,5),(2592,'-1\nException in thread \"Thread-2\" java.util.ConcurrentModificationException\n\nTreeSet iterator is fail fast','public class Hello extends Thread {\n    Set<String> set = new TreeSet<String>();\n    \n    public Hello(){\n        set.add(\"2\");\n        set.add(\"1\");\n        set.add(\"3\");\n        set.add(\"-1\");\n    }\n\n    public static void main(String[] args) {\n        //Thread t1 = new ConcAdder();\n        Hello h = new Hello();\n        Hello.ConcAdder ca = h.new ConcAdder();\n        ca.start();\n        \n        Hello.ConcIter ci = h.new ConcIter();\n        ci.start();\n\n    }\n    \n    class ConcAdder extends Thread{\n        private String[] letters = {\"A\",\"B\",\"C\",\"D\"};\n        public void run(){\n            while(true){\n                    int a = ThreadLocalRandom.current().nextInt(0,3);\n                    set.add(letters[a]);\n            }\n            \n        }\n    }\n    \n    class ConcIter extends Thread {\n        public void run(){\n            while(true){\n                Iterator<String> it = set.iterator();\n\n                while(it.hasNext()){\n                    System.out.println(it.next());\n                }\n                \n                //it.remove();\n            }\n        }\n        \n    }    \n}','Concurrency',0,0,NULL,5),(2593,'Base print\nan abstract class can extend a concrete class. ','public abstract class Hello extends Base  {\n    public static void main(String[] yea){\n        Base b = new Base();\n        b.print();\n    }\n}\n\nclass Base{\n    public void print(){\n        System.out.println(\"Base print\");\n    }\n}','OOP',0,0,NULL,5),(2594,'i1 = 10, i2 = 10, i3 = 10, i4 = 10\nunchecked cast warning too.\n\nE becomes whatever you are assigning the variable to','class Hello {\n\n    static <E> E cast(Object item) {\n        return (E) item;\n    }\n\n    public static void main(String[] args) {\n        Object o1 = 10;\n        int i = 10;\n        Integer anInteger = 10;\n\n        Integer i1 = cast(i);\n        Integer i2 = cast(10);\n        Integer i3 = cast(anInteger);\n        Integer i4 = cast(o1);\n\n        System.out.printf(\"i1 = %d, i2 = %d, i3 = %d, i4 = %d\", i1, i2, i3, i4);\n    }\n}','OOP',1,0,NULL,5),(2595,'Exception in thread \"main\" java.lang.ClassCastException: \njava.lang.Integer cannot be cast to java.lang.String','class Hello {\n\n    static <E> E cast(Object item) {\n        return (E) item;\n    }\n\n    public static void main(String[] args) {\n        Object o1 = 10;\n        int i = 10;\n        Integer anInteger = 10;\n\n        String i4 = cast(o1);\n\n        System.out.printf(i4);\n    }\n}','Generics',0,0,NULL,5),(2596,'compiles fine','class Hello {\n\n    static <E> E cast(Sculptable item) {\n        return (E) item;\n    }\n\n    public static void main(String[] args) {\n       Clay c = new Clay();\n       Rock r = cast(c);\n    }\n}\n\ninterface Sculptable{ }\nclass Rock{}\nclass Clay extends Rock implements Sculptable{}','Generics',0,0,NULL,5),(2597,'ArrayStoreException.\n\nThe compiler sees a Vehicle[] and car vehicle object being assigned to it.\n\nhowever the JVM sees a Car[] because the JVM deals with polymorphism. \nand a Vehicle object cannot be added to a Car[]','class Hello {\n\n\n    public static void main(String[] args) {\n        Vehicle[] v = new Car[4];\n        v[0] = new Vehicle();\n        v[1] = new Car();\n        v[2] = new Toyota();\n        \n        System.out.println(v.length);\n    }\n    \n}\n\nclass Vehicle{}\nclass Car extends Vehicle{}\nclass Toyota extends Car{}','Generics',0,0,NULL,5),(2598,'4','class Hello {\n\n\n    public static void main(String[] args) {\n        Vehicle[] v = new Car[4];\n        //v[0] = new Vehicle();\n        v[1] = new Car();\n        v[2] = new Toyota();\n        \n        System.out.println(v.length);\n    }\n    \n}\n\nclass Vehicle{}\nclass Car extends Vehicle{}\nclass Toyota extends Car{}','Generics',0,0,NULL,5),(2599,'true\njava.lang.ArrayStoreException: Point\n\nThe variable pa has type Point[] and the variable cpa has as its value a \nreference to an object of type ColoredPoint[]. A ColoredPoint can be \nassigned to a Point; therefore, the value of cpa can be assigned to pa.\n\nA reference to this array pa, for example, testing whether pa[1] is null, \nwill not result in a run-time type error. This is because the element of\n the array of type ColoredPoint[] is a ColoredPoint, and every ColoredPoint\n can stand in for a Point, since Point is the superclass of ColoredPoint.\n\nOn the other hand, an assignment to the array pa can result in a run-time \nerror. At compile time, an assignment to an element of pa is checked to \nmake sure that the value assigned is a Point. But since pa holds a \nreference to an array of ColoredPoint, the assignment is valid only if \nthe type of the value assigned at run time is, more specifically, a \nColoredPoint.\n\nThe Java Virtual Machine checks for such a situation at run time to \nensure that the assignment is valid; if not, an ArrayStoreException is\nthrown. ','class Point { int x, y; }\nclass ColoredPoint extends Point { int color; }\nclass Test {\n    public static void main(String[] args) {\n        ColoredPoint[] cpa = new ColoredPoint[10];\n        Point[] pa = cpa;\n        System.out.println(pa[1] == null);\n        try {\n            pa[0] = new Point();\n        } catch (ArrayStoreException e) {\n            System.out.println(e);\n        }\n    }\n}','Generics',0,0,NULL,5),(2600,'5\n[2, 1, 9, 6]\ntrue\n[2, 1, 6]','public static void main(String[] args) {\n\n        List<Integer> list = new ArrayList<Integer>();\n        list.add(new Integer(2));\n        list.add(1);\n        list.add(5);\n        list.add(9);\n        list.add(6);\n\n        System.out.println(list.remove(2));\n        System.out.println(list);\n        System.out.println(list.remove(new Integer(9)));\n        System.out.println(list);\n\n\n    }','Collections',0,0,NULL,5),(2601,'Pick a little, eat a little, pick a little, eat a little, burp burp burp, eat a lot, pick a little more.\n\nBoth replaceAll() and replace() methods replace all occurrences of the substring from\nthe given string. The difference between them is that replaceAll() takes regex as the\nfirst argument and replacement string as the second argument. The replace() method\ntakes CharSequence as both the arguments (note that String implements CharSequence\ninterface).','public static void main(String[] args) {\n        String talk = \"Pick a little, talk a little, pick a little, talk a little, cheep cheep cheep, talk a lot, pick a little more\";\n        String eat = talk.replaceAll(\"talk\", \"eat\").replace(\"cheep\", \"burp\");\n        System.out.println(eat);\n    }','Strings',0,0,NULL,5),(2602,'ok','replace(char oldChar, char newChar)\nReturns a new string resulting from replacing all occurrences of oldChar in this string with newChar.\n\nString 	replace(CharSequence target, CharSequence replacement)\nReplaces each substring of this string that matches the literal target sequence with the specified literal replacement sequence.\n\nString 	replaceAll(String regex, String replacement)\nReplaces each substring of this string that matches the given regular expression with the given replacement.\n\nString 	replaceFirst(String regex, String replacement)\nReplaces the first substring of this string that matches the given regular expression with the given replacement.','Strings',0,0,NULL,5),(2603,'For 4 days and 4 nights, we battled the wind, the cold, the despair.','public static void main(String[] args) {\n        String talk = \"For 30 days and 30 nights, we battled the wind, the cold, the despair.\";\n        String rep = talk.replaceAll(\"\\\\d+\", \"4\");\n        System.out.println(rep);\n    }','Strings',0,0,NULL,5),(2604,'For 30 days and 30 nights, we battled the wind, the cold, the despair.\n\nreplace takes a charsequence as a first arg not regex','public static void main(String[] args) {\n        String talk = \"For 30 days and 30 nights, we battled the wind, the cold, the despair.\";\n        String rep = talk.replace(\"\\\\d+\", \"4\");\n        System.out.println(rep);\n    }','Strings',0,0,NULL,5),(2605,'true\n\ntype erasure will make ArrayList raw and ArrayList<String> the same type of class\n','public static void main(String []args) {\n        Class c1 = new ArrayList<String>().getClass();\n        // LINE A\n        Class c2 = ArrayList.class;\n        // LINE B\n        System.out.println(c1 == c2);\n    }','General',0,0,NULL,5),(2606,'When executed, the program prints the following: B\n\nThe overload resolution matches to the most specific overload. When the argument null is\npassed, there are two candidates, Overload(Object) and Overload(double[]), and of these\ntwo, Overload(double[]) is the most specific overload, so the compiler resolves to calling\nthat method.\n\nOne method or constructor is less specific than another if it can accept \nany parameters passed to the other \n\nn our program, both constructors are accessible and applicable. \nThe constructor Confusing(Object) accepts any parameter passed to\n Confusing(double[]), so Confusing(Object) is less specific. \n(Every double array is an Object, but not every Object is a double array.)\n The most specific constructor is therefore Confusing(double[]), \nwhich explains the program\'s output.','class Hello {\n\n    private static void overload(Object o){ System.out.println(\"A\"); }\n    private static  void overload(double[] d){ System.out.println(\"B\"); }\n    private static void overload(){ System.out.println(\"C\"); }\n    \n    public static void main(String []args) {\n        overload(null);\n    }\n}','General',0,0,NULL,5),(2607,'NPE\n\n When the superclass constructor is called it calls the subclass foo()\nnot its own, resulting in an NPE.','class Hello extends Super {\n    public Hello(){\n        member = \"HI\";\n    }\n    public void foo(){\n        System.out.println(\"in Hello foo \"+ member.toLowerCase());\n    }\n    private String member;\n    \n    public static void main(String []args) {\n        Super s = new Hello();\n        s.foo();\n        \n    }\n}\n\nclass Super{\n    public Super(){\n        foo();\n    }\n    \n    public void foo(){\n        System.out.println(\"Super foo\");\n    }\n}','General',0,0,NULL,5),(2608,'pqr.foo();\n\n  In this program, the member pqr is imported statically. So, the foo() method can be accessed by\nqualifying it as pqr.foo(). Note that foo() itself is not imported statically, so it cannot be invoked directly\nin this program.','// class PQR in mock package\npackage mock;\n \npublic class PQR {\n	public static void foo() {\n		System.out.println(\"foo\");\n	}\n}\n \n// class XYZ in mock package\npackage mock;\nimport static mock.*;\n \npublic class XYZ {\n	public static PQR pqr;\n}\n \n// class StatImport\nimport static mock.XYZ.*;\n \nclass StatImport {\n	public static void main(String []args) {\n		// STMT\n	}\n}','General',0,0,NULL,5),(2609,'This program will print 10 in the console.\nThe valueOf(int) method is a static method in String that returns the String\nrepresentation of the integer value that is passed as its argument. Since calling a static\nmethod does not require dereferencing the reference variable on which it is called, this\nprogram does not throw a NullPointerException.\n\nshows the danger of using references to access static methods. ','psvm(String[] args){\n	String st = null;\n	sout( st.valueOf(10) );\n}','Strings',0,0,NULL,5),(2610,'Area of Square = 100.0\nArea of circle = 314.2857142857143\n\nshows dynamic binding','abstract class Shape{\n  protected final static double PI = 22.0/7.0;\n  protected double length;\n  public abstract double area();\n}\n\nclass Square extends Shape{\n  Square(double side){\n	length=side;// initialises inherited length\n  }\n  public double area(){// overrides area() of Shape\n	return length*length;// length inherited from Shape\n  }\n}\n\nclass Circle extends Shape{\n  Circle(double radius){\n	length=radius;// initialises inherited length\n  }\n  public double area(){// overrides area() of Shape\n	return PI*length*length;// PI & length inherited from Shape\n  }\n}\n\n/**\n * Polymorphism & Dynamic binding test class\n **/\npublic class l1PolyTest{\n  public static void main(String[] args){\n	Shape sh;// no object instance just variable declaration\n	Square sq = new Square(10.0);// sq is a Square object reference \n	Circle circ = new Circle(10.0);// circ is a Circle object reference\n\n	sh=sq;// sh dynamically bound to the Square object referenced by sq\n	System.out.println(\"Area of Square = \" + sh.area());\n\n	sh=circ; // sh dynamically bound to the Circle object referenced by circ\n	System.out.println(\"Area of circle = \" + sh.area());\n  }\n}','OOP',0,0,NULL,5),(2611,' MAp does not think about it a map maps keys to values that behavior is completely\nunlike all the other collection types. ','Which one of the following interfaces does NOT inherit from java.util.Collection<E>\ninterface?\n \na) Set<E>\nb) Queue<E>\nc) List<E>\nd) Map<K, V>','Collections',0,0,NULL,5),(2612,'ok','finallize() and clone methods of Object class can be overriden along \nwith equals hashcode and to string','OOP',0,0,NULL,5),(2613,'Error at line 4, you cannot construct a locale out of another locale.','class Test {\n	public static void main(String []args) {\n		Locale locale1 = new Locale(\"en\"); //#1\n		Locale locale2 = new Locale(\"en\", \"in\"); //#2\n		Locale locale3 = new Locale(\"th\", \"TH\", \"TH\"); //#3\n		Locale locale4 = new Locale(locale3); //#4\n		System.out.println(locale1 + \" \" + locale2 + \" \" + locale3 + \" \" + locale4);\n	}\n}','Locale',0,0,NULL,5),(2614,'compiles and runs without error, \n\nany string can be passed to a locale it is not an error if the string is \nnot a valid country and language. ','public static void main(String []args) {\n        Locale l = new Locale(\"big\",\"Dick\");\n    }','Locale',0,0,NULL,5),(2615,'D1 Opened\nException in thread \"main\" java.io.IOException: Unknown\nClosing device D1\n\nSince an exception is thrown in the contructor of D2 it is never fullly initialized\nits reference is null.\n\nYou may think that this should cause a NPE by having Automatic Resource Management\ncall close() on a null object. But that is too deep in scope. Just Understand\nthat ARM skips D2 and calls close on d1. ','class Hello implements AutoCloseable {\n    String header = null;\n    public Hello(String name) throws IOException{\n        header = name;\n        if(\"D2\".equals(name)) throw new IOException(\"Unknown\");\n        System.out.println(header + \" Opened\");        \n    }\n\n    public String read() throws IOException{\n        return \"\";\n    }\n    \n    public void close(){\n        System.out.println(\"Closing device \"+header);\n        throw new RuntimeException(\"RTE while closing \"+header);\n    }\n\n    public static void main(String []args) throws Exception {\n        try(Hello d1 = new Hello(\"D1\");\n            Hello d2 = new Hello(\"D2\")){\n            throw new Exception(\"test\");\n        } \n    }\n}','Exceptions',0,0,NULL,5),(2616,'it will print DATA\n\nthink of the main method as the main thread. \nNo matter who gets the lock first it will still print DATA','class Resource {\n    public String data = \"DATA\";\n}\n\nclass Looney implements Runnable {\n    Resource r; int number;\n    public Looney(Resource r, int number) {\n        this.r = r;  this.number = number;\n    }\n\n    public void run(){\n        synchronized(r)  {\n            r.data = \"DATA \"+number;\n            r.notifyAll();\n            r.data = \"DATA\";\n        }\n    }\n}\n\npublic class Hello {\n\n    public static void main(String[] args) {\n        Resource r = new Resource();\n        Looney l = new Looney(r, 1);\n        Thread  t = new Thread(l);\n        t.start();\n        synchronized(r)  {\n            System.out.println(r.data);\n        }\n    }\n\n}\n','Threads',0,0,NULL,5),(2617,'WNC,\n\nby creating one instance of the outer class you automatically create an \ninstance of its static nested class and there can only be one of those.\nSo basically there wont be multiple static nested classes associated with\none outer class.\n\nanonymous class can never be static','public class Hello\n{\n   public class A{\n   }\n   public static class B {\n   }\n   public static void main(String args[]){\n      class C{\n      }\n      new Hello().new B();\n   }\n}','Inner Classes',0,0,NULL,5),(2618,'oh yea \n\nAn anonymous class is never abstract (§8.1.1.1). An anonymous class is \nalways an inner class (§8.1.3); it is never static (§8.1.1, §8.5.1). \nAn anonymous class is always implicitly final (§8.1.1.2).\n\nIf you want to baffle those maintaining your code, wags have discovered \njavac.exe will permit anonymous classes inside static init code and static\n methods, even though the language spec says than anonymous classes are \nnever static. These anonymous classes, of course, have no access to the \ninstance fields of the object. I don’t recommend doing this. The feature \ncould be pulled at any time. \n\n\nLet C be the class being instantiated, and let i be the instance being created. If C is an inner class then i may have an immediately enclosing instance. The immediately enclosing instance of i (§8.1.3) is determined as follows.\nIf C is an anonymous class, then:\nIf the class instance creation expression occurs in a static context (§8.1.3), then i has no immediately enclosing instance.\n Otherwise, the immediately enclosing instance of i is this.\nSo an anonymous class in a static context is roughly equivalent to a static nested class in that it does not keep a reference to the enclosing class, even though it\'s technically not a static class.','public class Hello\n{\n    private static Runnable r = new Runnable(){\n          public void run(){\n              System.out.println(\"oh yea\");\n          }\n      };\n  \n   public static void main(String args[]){\n      new Thread(r).start();\n   }\n}','Inner Classes',0,0,NULL,5),(2619,'Playo','public class Hello\n{\n    public static Cinco c = new Cinco(){\n        Playo p = new Playo();\n    };\n  \n   public static void main(String args[]){\n      \n   }\n}\n\nclass Cinco{\n    public static final int cinco = 5;\n    \n    class Playo{\n        \n        public Playo(){\n            System.out.println(\"Playo\");\n        }\n        \n    }\n    public void output(){\n        int x = 9;\n        System.out.println(\"output: \"+9);\n    }\n    \n    public String name(){\n        return \"Cinco\";\n    }\n}','Inner Classes',0,0,NULL,5),(2620,'WNC,\n\nqualified new static class. ','public class Hello\n{\n    public static Cinco c = new Cinco(\"cinco\"){\n        Playo p = new Playo(\"anon\");\n    };\n  \n   public static void main(String args[]){\n      Cinco.Playo cp = c.new Playo(\"main\");\n      Cinco.Mueno cp1 = c.new Mueno();\n   }\n}\n\nclass Cinco{\n    public static final int cinco = 5;\n    String name;\n    \n    public Cinco(String name){\n        this.name = name;\n    }\n    \n    class Playo{\n        \n        public Playo(String s){\n            System.out.println(\"Playo \"+s);\n        }\n        \n    }\n    \n    static class Mueno{\n        public void m1(){\n            System.out.println(\"mueno\");\n        }\n    }\n\n    public void output(){\n        int x = 9;\n        Cinco.Playo r = this.new Playo(\"this\");\n        System.out.println(\"output: \"+9);\n    }\n    \n    public String name(){\n        return \"Cinco\";\n    }\n}','Inner Classes',0,0,NULL,5),(2621,'WNC\n\npackage c doesnt exist','public class Hello\n{\n    public static Cinco c = new Cinco(\"cinco\"){\n        Playo p = new Playo(\"anon\");\n    };\n  \n   public static void main(String args[]){\n      Cinco.Playo cp = c.new Playo(\"main\");\n      Cinco.Mueno cp1 = new c.Mueno();\n   }\n}\n\nclass Cinco{\n    public static final int cinco = 5;\n    String name;\n    \n    public Cinco(String name){\n        this.name = name;\n    }\n    \n    class Playo{\n        \n        public Playo(String s){\n            System.out.println(\"Playo \"+s);\n        }\n        \n    }\n    \n    static class Mueno{\n        public void m1(){\n            System.out.println(\"mueno\");\n        }\n    }\n\n    public void output(){\n        int x = 9;\n        Cinco.Playo r = this.new Playo(\"this\");\n        System.out.println(\"output: \"+9);\n    }\n    \n    public String name(){\n        return \"Cinco\";\n    }\n}','Inner Classes',0,0,NULL,5),(2622,'Playo anon\nPlayo main\nmueno\nMueno mueno','public class Hello\n{\n    public static Cinco c = new Cinco(\"cinco\"){\n        Playo p = new Playo(\"anon\");\n    };\n  \n   public static void main(String args[]){\n      Cinco.Playo cp = c.new Playo(\"main\");\n      Cinco.Mueno cp1 = new Cinco.Mueno();\n      cp1.m1();\n      Cinco.Mueno.m2();\n   }\n}\n\nclass Cinco{\n    public static final int cinco = 5;\n    String name;\n    \n    public Cinco(String name){\n        this.name = name;\n    }\n    \n    class Playo{\n        \n        public Playo(String s){\n            System.out.println(\"Playo \"+s);\n        }\n        \n    }\n    \n    static class Mueno{\n        public void m1(){\n            System.out.println(\"mueno\");\n        }\n        public static void m2(){\n            System.out.println(\"Mueno mueno\");\n        }\n    }\n\n    public void output(){\n        int x = 9;\n        Cinco.Playo r = this.new Playo(\"this\");\n        System.out.println(\"output: \"+9);\n    }\n    \n    public String name(){\n        return \"Cinco\";\n    }\n}','Inner Classes',0,0,NULL,5),(2623,'There is only one important point that you need to know about String in a \nswitch statement:  The String in the switch expression is compared with the\n expressions associated with each case label as if the String.equals method\n were being used. This means if the string in the switch expression turns \nout to be null, it will cause a NullPointerException to be thrown. \n \nswitch(str){ // A NullPointerException will be thrown here if str is null. \n  case \"sss\" : System.out.println(\"sss\") ; }   \nFurther, you cannot do something like:  \n\nswitch(str){   case null : System.out.println(\"null\") \n//This line will not even compile }','\nWhat will the following code print when compiled and run?\n\npublic class TestSIS {\n\n    public static void main(String[] args) {\n        String str = null;\n            switch(str){\n                case \"null\" : System.out.println(\"1\");\n                   break;\n                case \"\" : System.out.println(\"2\");\n                   break;\n                default : System.out.println(\"3\");\n           }\n     }\n}','General',0,0,NULL,5),(2624,'\n    REPLACE_EXISTING\n\n    public static final StandardCopyOption REPLACE_EXISTING\n\n    Replace an existing file if it exists.\n\n    COPY_ATTRIBUTES\n\n    public static final StandardCopyOption COPY_ATTRIBUTES\n\n    Copy attributes to the new file.\n\n    ATOMIC_MOVE\n\n    public static final StandardCopyOption ATOMIC_MOVE\n\n    Move the file as an atomic file system operation.\n','Three StandardCopyOptions ?','IO',0,0,NULL,5),(2625,'\n APPEND If the file is opened for \n\nWRITE access then bytes will be written to the end of the file rather \nthan the beginning.  CREATE Create a new file if it does not exist.  \n\nCREATE_NEW Create a new file, failing if the file already exists.  \n\nDELETE_ON_CLOSE Delete on close.  \n\nDSYNC Requires that every update to the file\'s content be written \nsynchronously to the underlying storage device.  \n\nREAD Open for read access.  \n\nSPARSE Sparse file.  \n\nSYNC Requires that every update to the file\'s content or metadata be \nwritten synchronously to the underlying storage device.  \n\nTRUNCATE_EXISTING If the file already exists and it is opened for WRITE access, then its length is truncated to 0.  \n\nWRITE Open for write access. ','Standard open options ','IO',0,0,NULL,5),(2626,'prints nothing incorrect glob\n\nshould be *.{pdf,rtf}','\nGiven that you have the following files in a directory named \"reports\":\n\nsalary.pdf\npayslips.pdf\nresume.rtf\nexpensesrtf (There is no . in the name)\n\nWhat will the following program print when run assuming that reports directory is present in the current directory?\n\n//assume appropriate imports\npublic class Path3 extends SimpleFileVisitor<Path>{\n    private PathMatcher pm = FileSystems.getDefault().getPathMatcher(\"glob:*pdf,rtf\");\n    public FileVisitResult visitFile(Path file,\n                                   BasicFileAttributes attr) {\n        \n        if(pm.matches(file.getFileName())){\n            System.out.println(file.getFileName());\n        }\n        return FileVisitResult.CONTINUE;\n    }\n\n    public static void main(String[] args) throws IOException{\n        Path3 p3 = new Path3();\n        Path startwith = Paths.get(\"reports\");\n        Files.walkFileTree(startwith, p3);\n    }\n\n}   ','Strings',0,0,NULL,5),(2627,'\n..\\..\\index.html','Path p1 = Paths.get(\"\\\\personal\\\\readme.txt\");         \nPath p2 = Paths.get(\"\\\\index.html\");         \nPath p3 = p1.relativize(p2);         \nSystem.out.println(p3);','IO',0,0,NULL,5),(2628,'fails at line 2. This is narrowing and requires and explicit cast.\n\nCasting a base class to a subclass as in :   \nb = (B) a; is also called as narrowing (as you are trying to narrow the \nbase class object to a more specific class object) and needs explicit cast.\n Casting a sub class to a base class as in : A a = b; is also called as\n widening and does not need any casting. eg. Consider two classes:\n Automobile and Car, where Car extends Automobile Now, \nAutomobile a = new Car() is valid because a car is definitely an\n Automobile. So it does not need casting. But, Car c = a; is not\n valid as \'a\' is an Automobile and it may be a Car, or a Truck or a \nMotorCycle, so the programmer has to explicitly let the compiler know \nthat at runtime \'a\' will be a Car, by writing Car c = (Car) a;','\nWhich is the first line that will cause compilation to fail in the following program?\n\n// Filename: A.java\nclass A\n{\n   public static void main(String args[])\n   {\n      A a = new A();\n      B b = new B();\n      a = b;  // 1\n      b = a;  // 2\n      a = (B) b; // 3\n      b = (B) a; // 4\n   }\n}\nclass B extends A { }\n','OOP',0,0,NULL,5),(2629,'6,\n\nthe default delemiters are a space, \\t\\n\\r\\f','String str = \"tokens\\twith tabs and \\r\\nnew lines.\";           \n StringTokenizer st = new StringTokenizer(str);            \nSystem.out.println(st.countTokens());','Strings',0,0,NULL,5),(2630,'this\nis \na\ntest\n\nthe basic usage of StringTokenizer','public static void main(String args[]){\n       StringTokenizer st = new StringTokenizer(\"this is a test\");\n       while (st.hasMoreTokens()){ \n        System.out.println(st.nextToken());\n       }\n   }','Strings',0,0,NULL,5),(2631,'WNC,\n\n\nfoo is default in Bar, cannot be used outside the package. ','import maxspack.Bar;\n\n\n\npublic class Hello\n{\n  \n   public static void main(String args[]){\n      Bar b = new Bar();\n      b.foo();\n      b.reno();\n   }\n}\n\npackage maxspack;\n\n\npublic class Bar {\n    void foo(){\n        System.out.println(\"maxspack: foo\");\n    }\n    \n    public void reno(){\n        System.out.println(\"reno\");\n    }\n    \n}\n\n','OOP',0,0,NULL,5),(2632,'gives null since, there is no hashCode() in the Bar class. ','public class Hello{\n    static Map<Bar,Integer> map = new HashMap<>();\n    public Hello(){\n        Bar a = new Bar(\"A\");\n        map.put(a,10);\n        Bar b = new Bar(\"B\");\n        map.put(b,10);\n    }\n  \n   public static void main(String args[]){\n     Bar a1 = new Bar(\"A\");\n       System.out.println(map.get(a1));\n   }\n}\n\npackage maxspack;\npublic class Bar {\n    String name;\n    public Bar(String s){\n        name = s;\n    }\n    \n    public boolean equals(Object o){\n        return ((o instanceof Bar) && name.equals(((Bar)o).name));\n    }\n}','OOP',0,0,NULL,5),(2633,'pulse is 78\n78\n\nconfusing and not recomended but will compile ','public class Hello{\n   public static void main(String args[]){\n       Human max = new Human();\n       Human.Heart heart = max.new Heart();\n       \n       heart.pulse();\n       System.out.println(heart.pulse);\n       \n       \n   }\n}\n\nclass Human {\n    \n    \n    class Heart{\n        static final int pulse = 78;\n        \n        public void beat(){\n            System.out.println(\"Thump thump, thump thump\");\n        }\n        \n        public void pulse(){\n            System.out.println(\"pulse is \"+pulse);\n        }\n    }\n}','OOP',0,0,NULL,5),(2634,'ok\n\npublic class SCJP extends Programmer {\n    public int debug = 9;\n    public Object debug(String s){\n        return this;\n    }\n}\n\n// this is ok ','variables and methods can have the same name because syntatically they \nare used completely differently. ','OOP',0,0,NULL,5),(2635,'compiles fine....','class Human {\n    protected final int chromosomes = 46;\n    \n    \n    class Heart{\n        static final int pulse = 78;\n        \n        public void beat(){\n            System.out.println(\"Thump thump, thump thump\");\n        }\n        \n        public void pulse(){\n            System.out.println(\"pulse is \"+pulse);\n        }\n    }\n}\n\nclass Politician extends Human{\n    \n    class BlackHeart extends Heart{\n        public void beat(){\n            System.out.println(\"There seems to be no pulse\");\n        }\n        \n        public void actNormal(){\n            System.out.println(\"ladies and gentelman... pulse: \"+pulse);\n        }\n        \n        public void dna(){\n            System.out.println(\":\"+chromosomes);\n        }\n        \n    }\n}','Inner Classes',0,0,NULL,5),(2636,'compiles','class Human {\n    protected final int chromosomes = 46;\n    \n    \n    class Heart{\n        static final int pulse = 78;\n        \n        public void beat(){\n            System.out.println(\"Thump thump, thump thump\");\n        }\n        \n        public void pulse(){\n            System.out.println(\"pulse is \"+pulse);\n        }\n    }\n}\n\nclass Politician extends Human{\n    \n    class Heart extends Human.Heart{\n        public void beat(){\n            System.out.println(\"There seems to be no pulse\");\n        }\n        \n        public void actNormal(){\n            System.out.println(\"ladies and gentelman... pulse: \"+pulse);\n        }\n        \n        public void dna(){\n            System.out.println(\":\"+chromosomes);\n        }\n        \n    }\n}','Inner Classes',0,0,NULL,5),(2637,'These compile fine,\n\nan inner class can abstract and static and be implemented by another inner \nclass.\n\noverriding can change the access modifier, it can be less restritive but\nnot more so\n','class Human {\n    protected final int chromosomes = 46;\n    \n    \n    class Heart{\n        static final int pulse = 78;\n        \n        public void beat(){\n            System.out.println(\"Thump thump, thump thump\");\n        }\n        \n        public void pulse(){\n            System.out.println(\"pulse is \"+pulse);\n        }\n    }\n    \n    protected void procreate(){\n        \n    }\n    \n    abstract static class Soul{\n        protected abstract void giveLife();\n    }\n}\n\nclass Politician extends Human{\n    \n    public void procreate(){\n        \n    }\n    \n    class BlackHeart extends Heart{\n        public void beat(){\n            System.out.println(\"There seems to be no pulse\");\n        }\n        \n        public void actNormal(){\n            System.out.println(\"ladies and gentelman... pulse: \"+pulse);\n        }\n        \n        public void dna(){\n            System.out.println(\":\"+chromosomes);\n        }\n    }\n    \n    class HungrySoul extends Soul{\n        public void giveLife(){\n            System.out.println(\"I still feel worthless\");\n        }\n        \n    }\n    \n}','Inner Classes',0,0,NULL,5),(2638,'This can compile only in mlic does the instantiation HAVVE to come after the \ndefinition of the class. ','class Human {\n    protected final int chromosomes = 46;\n    \n    protected void procreate(){\n        Heart h = new Heart();\n    }\n    \n    class Heart{\n        static final int pulse = 78;\n        \n        public void beat(){\n            System.out.println(\"Thump thump, thump thump\");\n        }\n        \n        public void pulse(){\n            System.out.println(\"pulse is \"+pulse);\n        }\n    }\n\n    abstract static class Soul{\n        protected abstract void giveLife();\n    }\n}','Inner Classes',0,0,NULL,5),(2639,'private methods cannot be overriden, they are invisible to the subclass','class Human {\n    protected final int chromosomes = 46;\n    \n    class Heart{\n        static final int pulse = 78;\n        \n        public void beat(){\n            System.out.println(\"Thump thump, thump thump\");\n        }\n        \n        public void pulse(){\n            System.out.println(\"pulse is \"+pulse);\n        }\n    }\n    \n    private void breathe(){\n        System.out.println(\"ahhh\");\n    }\n    \n    \n    \n    abstract static class Soul{\n        protected abstract void giveLife();\n    }\n}\n\nclass Politician extends Human{\n    \n    public void procreate(){\n        \n    }\n    \n    public void breath() throws IOException{\n        System.out.println(\"ahhh,\");\n    }\n    \n    class BlackHeart extends Heart{\n        public void beat(){\n            System.out.println(\"There seems to be no pulse\");\n        }\n        \n        public void actNormal(){\n            System.out.println(\"ladies and gentelman... pulse: \"+pulse);\n        }\n        \n        public void dna(){\n            System.out.println(\":\"+chromosomes);\n        }\n    }\n    \n    class HungrySoul extends Soul{\n        public void giveLife(){\n            System.out.println(\"I still feel worthless\");\n        }\n        \n    }\n    \n}','Inner Classes',0,0,NULL,5),(2640,'compiles\n\nprivate methods cannot be overriden, they are invisible to the subclass','class Glass{\n    private void shine(){\n        System.out.println(\"Bling bling\");\n    }\n}\n\nclass Window extends Glass{\n    public void shine() throws Exception{\n        \n    }\n}','Inner Classes',0,0,NULL,5),(2641,'platform and system dependent','\nGiven that test1.txt exists but test2.txt doesn\'t exist, consider the following code?\n\npublic class Copier {\n    \n    public static void copy1(Path p1, Path p2) throws Exception {\n        Files.copy(p1, p2, StandardCopyOption.COPY_ATTRIBUTES);\n    }\n    \n    \n    public static void main(String[] args) throws Exception {\n        Path p1 = Paths.get(\"c:\\\\home\\\\resume2.txt\");\n        Path p2  = Paths.get(\"c:\\\\public\\\\resumes\\\\thankyouletter.txt\");\n        copy1(p1, p2);\n    }\n}\nwhat attributes will be copied ?','Inner Classes',0,0,NULL,5),(2642,'NoSuchFileException /home/maxbisesi/Public/MaxsDir','  public static void main(String[] args){\n        Path p1 = Paths.get(\"/home/maxbisesi/Public/MaxsDir\");\n        Path p2 = Paths.get(\"/home/maxbisesi/Public/TestDir\");\n        \n        try{\n            Files.copy(p1,p2);\n        } catch(IOException e){\n            System.out.println(e);\n            \n        }\n    }\n\nSay MaxsDir does not exist. ','IO',0,0,NULL,5),(2643,'FileAlreadyExistsExxcepiton','public class Hello {\n    public static void main(String[] args){\n        Path p1 = Paths.get(\"/home/maxbisesi/Public/Data/MaxsDir\");\n        Path p2 = Paths.get(\"/home/maxbisesi/Public/TestDir\");\n        \n        try{\n            Files.copy(p1,p2);\n        } catch(IOException e){\n            System.out.println(e);\n            \n        }\n    }\n    \n}\n\nTestDir already exists. ','IO',0,0,NULL,5),(2644,'DirectoryNotEmptyException','public class Hello {\n    public static void main(String[] args){\n        Path p1 = Paths.get(\"/home/maxbisesi/Public/Data/MaxsDir\");\n        Path p2 = Paths.get(\"/home/maxbisesi/Public/TestDir\");\n        \n        try{\n            Files.copy(p1,p2,StandardCopyOption.REPLACE_EXISTING);\n        } catch(IOException e){\n            System.out.println(e);\n            \n        }\n    }\n    \n}\n\nTestDir is not empty	','IO',0,0,NULL,5),(2645,'succesfully copies MaxsDir to TestDir but does not copy all its contents too','public class Hello {\n    public static void main(String[] args){\n        Path p1 = Paths.get(\"/home/maxbisesi/Public/Data/MaxsDir\");\n        Path p2 = Paths.get(\"/home/maxbisesi/Public/TestDir\");\n        \n        try{\n            Files.copy(p1,p2,StandardCopyOption.REPLACE_EXISTING);\n        } catch(IOException e){\n            System.out.println(e);\n            \n        }\n    }\n}\n\nBoth of these are directories and TestDir is empty','IO',0,0,NULL,5),(2646,'1\n\npush() is a stack method that adds the element to the front.\n Therefore, the contents of d change as follows: 1 offer(e) is a\n queue method that adds the element to the end and offerLast(e) is \nequivalent to offer(e). So the deque now contains: 1, 2 push(3) changes \nit to: 3, 1, 2 Now, peek methods don\'t modify the structure, therefore \neven though peekFirst returns 3, the deque doesn\'t change. removeLast() \nremoves the element from the end, so d now contains: 3, 1 pop() is a stack\n method that removes the element from the front. Therefore, the contents of\n d change to: 1',' Deque<Integer> d = new ArrayDeque<>();\n         d.push(1);\n         d.offerLast(2);\n         d.push(3);\n         d.peekFirst();\n         d.removeLast(); \n        d.pop();   \n      System.out.println(d);','Collections',0,0,NULL,5),(2647,'0 \n\nbinarySearch iplemented in this way compares strings by length no matter the \ncontent if the two string are of equal length they are considered equal. ','public static void main(String[] args){\n        \n       class StringSort implements Comparator<String> {\n           public int compare(String s1, String s2){\n               return s1.length() - s2.length();\n           }\n       }\n       \n       String[] strs = {\"a\",\"cc\",\"ffff\"};\n       \n       Arrays.sort(strs,new StringSort());\n       \n       int pos = Arrays.binarySearch(strs,\"b\",new StringSort());\n        System.out.println(pos);\n       \n    }','Strings',0,0,NULL,5),(2648,'-4\n\nnegative insertion point','public static void main(String[] args){\n        \n       class StringSort implements Comparator<String> {\n           public int compare(String s1, String s2){\n               return s1.length() - s2.length();\n           }\n       }\n       \n       String[] strs = {\"a\",\"cc\",\"ffff\"};\n       \n       Arrays.sort(strs,new StringSort());\n       \n       int pos = Arrays.binarySearch(strs,\"tyuioo\",new StringSort());\n        System.out.println(pos);\n       \n    }','Strings',0,0,NULL,5),(2649,'ok','If an array or collection is sorted using comparator it must be searched using\nthe same comparator passed as an argument','Strings',0,0,NULL,5),(2650,'synchronized(mumbo) { mumbo.notifyAll(); }','\nConsider the code shown below -\n\npublic class TestClass\n{\n   public Mumbo mumbo = new Mumbo();\n   public Jumbo jumbo = new Jumbo();\n   class Mumbo\n   {\n      public synchronized void doIt()\n      {\n         try{\n            LINE 1: wait();\n            System.out.println(\"done\");\n         }\n         catch(Exception e) { }\n      }\n   }\n   class Jumbo extends Thread\n   {\n      public void run()\n      {\n         mumbo.doIt();\n      }\n   }\n   public TestClass() throws Exception\n   {\n       jumbo.start();\n      Thread.sleep(1000);\n      LINE 2:    //insert code here\n   }\n   public static void main(String[] args) throws Exception\n   {\n      new TestClass();\n   }\n}\n\nAssume that you have run the above program. The jumbo thread has just executed LINE1 and the thread that called jumbo.start() is about to call LINE 2.\nWhat can you insert at LINE 2, so that the program will print done and exit?','Threads',0,0,NULL,5),(2651,'WNC,\n\nobjects coming out of a collection of type <?> are always objects. ','String[] strs = {\"a\",\"cc\",\"ffff\",\"yyt\"};\n       \n       ArrayList<?> list = new ArrayList<>(Arrays.asList(strs));\n       \n       for(String s : list){\n           System.out.println(s);\n       }','Collections',0,0,NULL,5),(2652,'WNC,\n\nnot because of asList(), You cant create an object with wild card type <?>\n\nthe type of the collection simply has to be established at some point. ','String[] strs = {\"a\",\"cc\",\"ffff\",\"yyt\"};\n       \n       ArrayList<?> list = new ArrayList<?>(Arrays.asList(strs));\n       \n       for(Object s : list){\n           System.out.println(s);\n       }','Collections',0,0,NULL,5),(2653,'an overloaded method can throw an exception. ','class Human {\n    protected final int chromosomes = 46;\n    \n    public void breathe(){\n        System.out.println(\"ahhh\");\n    }\n    \n}\n\nclass Politician extends Human{\n    \n    \n    public void breathe(boolean tf) throws InterruptedException{\n        if(tf){\n            System.out.println(\"ahhh\");\n        } else {\n            System.out.println(\"ughhg\");\n        }\n    }\n      \n}','OOP',0,0,NULL,5),(2654,'output cannot be determined.','public class TestClass implements Runnable {   \n    volatile int x;  \n    public void run(){ x = 5; } \n  \n    public static void main(String[] args)   {       \n		TestClass tc = new TestClass();       \n		tc.x = 10;       \n		new Thread(tc).start(); // 1    \n   		System.out.println(tc.x);   \n   }  \n}','Threads',0,0,NULL,5),(2655,'ok','public class InterfaceTest {\n    interface Gift  { void present(); }\n    interface Guest { void present(); }\n\n    interface Presentable extends Gift, Guest { }\n\n    public static void main(String[] args) {\n        Presentable johnny = new Presentable() {\n            @Override public void present() {\n                System.out.println(\"Heeeereee\'s Johnny!!!\");\n            }\n        };\n        johnny.present();                     // \"Heeeereee\'s Johnny!!!\"\n\n        ((Gift) johnny).present();            // \"Heeeereee\'s Johnny!!!\"\n        ((Guest) johnny).present();           // \"Heeeereee\'s Johnny!!!\"\n\n        Gift johnnyAsGift = (Gift) johnny;\n        johnnyAsGift.present();               // \"Heeeereee\'s Johnny!!!\"\n\n        Guest johnnyAsGuest = (Guest) johnny;\n        johnnyAsGuest.present();              // \"Heeeereee\'s Johnny!!!\"\n    }\n}','OOP',0,0,NULL,5),(2656,'WNC, \n\nIf you implement two interfaces that have a method that is equivalent,\n\nyou can implement those interfaces with one method howeve it has be safely overridden from both interfaces ','interface Cookable{\n    void fry() throws Exception;\n}\n\ninterface Eatable{\n    boolean fry()throws IOException;\n}\n        \n\nclass Egg implements Cookable,Eatable{\n    public void fry(){\n        \n    }\n    \n    public boolean fry(){\n        \n    }\n}','OOP',0,0,NULL,5),(2657,'Throws Missing Resource Exception\n\nYou are trying to create  an RB for a specific locale, Since that specific\nlocale does not exist on the class path it throws an excepiton.\n\nTo select the appropriate ResourceBundle, invoke the ResourceBundle.getBundle method. The following example selects the ButtonLabel ResourceBundle for the Locale that matches the French language, the country of Canada, and the UNIX platform.\n\nLocale currentLocale = new Locale(\"fr\", \"CA\", \"UNIX\");\nResourceBundle introLabels = ResourceBundle.getBundle(\n                                 \"ButtonLabel\", currentLocale);\n\nIf a ResourceBundle class for the specified Locale does not exist, getBundle tries to find the closest match. For example, if ButtonLabel_fr_CA_UNIX is the desired class and the default Locale is en_US, getBundle will look for classes in the following order:\n\nButtonLabel_fr_CA_UNIX\nButtonLabel_fr_CA\nButtonLabel_fr\nButtonLabel_en_US\nButtonLabel_en\nButtonLabel\n','public static void main(String[] args){\n        \n        Locale myloc = new Locale(\"hinglish\",\"IN\");\n        ResourceBundle msgs = ResourceBundle.getBundle(\"mymsgs\", myloc);  \n        \n        Enumeration<String> en = msgs.getKeys(); \n        \n        while(en.hasMoreElements()){     \n            String key = en.nextElement();     \n            String val = msgs.getString(key);     \n            System.out.println(key+\"=\"+val); \n        }\n       \n    }\n\n1. mymsgs_hinglish_US.properties okLabel=OK cancelLabel=Cancel     \n2. mymsgs_hinglish_UK.properties okLabel=YES noLabel=NO','Locale',0,0,NULL,5),(2658,'ok','To select the appropriate ResourceBundle, invoke the ResourceBundle.getBundle method. The following example selects the ButtonLabel ResourceBundle for the Locale that matches the French language, the country of Canada, and the UNIX platform.\n\nLocale currentLocale = new Locale(\"fr\", \"CA\", \"UNIX\");\nResourceBundle introLabels = ResourceBundle.getBundle(\n                                 \"ButtonLabel\", currentLocale);\n\nIf a ResourceBundle class for the specified Locale does not exist, getBundle tries to find the closest match. For example, if ButtonLabel_fr_CA_UNIX is the desired class and the default Locale is en_US, getBundle will look for classes in the following order:\n\nButtonLabel_fr_CA_UNIX\nButtonLabel_fr_CA\nButtonLabel_fr\nButtonLabel_en_US\nButtonLabel_en\nButtonLabel\n','Locale',0,0,NULL,5),(2659,'rb_hinglish_IN.java\nrb_hinglish_IN.properties\n\nrb_hinglish.java\nrb_hinglish.properties\n\nrb.java\nrb.properties','Locale myloc = new Locale(\"hinglish\",\"IN\");\nResourceBundle rb = ResourceBundle.getBundle(\"rb\", myloc);\n\nwhat files will be searched for before throwing a MRE ?','Locale',0,0,NULL,5),(2660,'You may think this will throw an IndexOutOFBoundsException but in fact the\nending index in sublist is EXCLUSIVE so given the indexs 0-100 will perfectly\nmatch the passed in list. \n\nstring: (0)\nstring: (1)\n...\nstring: (99)','public class Hello {\n    public static void main(String[] args){\n        \n        List<String> list = new ArrayList<>();\n        \n        for(int i = 0; i<100; i++){\n            list.add(\"string: (\"+i+\")\");\n        }\n        \n        List<String> section = listSection(list,0,100);\n        \n        for(String s : section){ System.out.println(s); }\n       \n    }\n    \n    public static <E> List<E> listSection(List<E> list,int x, int y){\n        List<E> newlist = list.subList(x,y);\n        return newlist;\n    }\n    \n}','Collections',0,0,NULL,5),(2661,'ok','String.substring(int beginIndex, int endIndex)\n\ninclusive and exclusive \n\nmost functions will be this way. \n\n','Strings',0,0,NULL,5),(2662,'It is ok to aquire a lock multiple times. it is not ok to unlock a non locked\nlock\n\npush is a stack method inserting at the front, like loading a clip of bullets.\n\nadd is a queue method it adds to the end as does offerLast.\n\npop() retrieves and removes from the front. Stack method. ','public class Hello {\n    private static Deque<String> deq = new ArrayDeque<>();\n    public static void main(String[] args){\n        ReentrantLock l1 = new ReentrantLock();\n        ReentrantLock l2 = new ReentrantLock();\n        \n        try{\n            l1.lock();\n            l1.lock();\n            \n            deq.push(\"First push\");\n            deq.offerLast(\"offer Last\");\n            deq.add(\"add\");\n            deq.push(\"push FirstFirst\");\n            \n        } finally{\n            l1.unlock();\n            l1.unlock();\n        }\n        \n        while(!deq.isEmpty())\n            System.out.println(deq.pop());\n        \n       \n    }','Collections',0,0,NULL,5),(2663,'IllegalMonitorStateException for trying to unlock an unlocked lock. ','public class Hello {\n    private static Deque<String> deq = new ArrayDeque<>();\n    public static void main(String[] args){\n        ReentrantLock l1 = new ReentrantLock();\n        ReentrantLock l2 = new ReentrantLock();\n        \n        try{\n            l1.lock();\n            l1.lock();\n            \n            deq.push(\"First push\");\n            deq.addFirst(\"add first\");\n            deq.add(\"add\");\n            deq.offerFirst(\"offerfirst\");\n            deq.offerLast(\"offerLast\");\n            deq.push(\"push last push\");\n            \n        } finally{\n            l1.unlock();\n            l1.unlock();\n            l2.unlock();\n        }\n        \n        while(!deq.isEmpty())\n            System.out.println(deq.pop());\n        \n       \n    }\n    \n    public static <E> List<E> listSection(List<E> list,int x, int y){\n        List<E> newlist = list.subList(x,y);\n        return newlist;\n    }\n    \n}','Concurrency',0,0,NULL,5),(2664,'push last push\nofferfirst\nadd first\nFirst push\nadd\nofferLast','ublic class Hello {\n    private static Deque<String> deq = new ArrayDeque<>();\n    public static void main(String[] args){\n        ReentrantLock l1 = new ReentrantLock();\n        ReentrantLock l2 = new ReentrantLock();\n        \n        try{\n            l1.lock();\n            l1.lock();\n            \n            deq.push(\"First push\");\n            deq.addFirst(\"add first\");\n            deq.add(\"add\");\n            deq.offerFirst(\"offerfirst\");\n            deq.offerLast(\"offerLast\");\n            deq.push(\"push last push\");\n            \n        } finally{\n            l1.unlock();\n            l1.unlock();\n            //l2.unlock();\n        }\n        \n        while(!deq.isEmpty())\n            System.out.println(deq.pop());\n        \n       \n    }','Collections',0,0,NULL,5),(2665,'ok',' Assignment contexts allow the use of one of the following:\n\n        an identity conversion (§5.1.1)\n\n        a widening primitive conversion (§5.1.2)\n\n        a widening reference conversion (§5.1.5)\n\n        a boxing conversion (§5.1.7) optionally followed by a widening reference conversion\n\n        an unboxing conversion (§5.1.8) optionally followed by a widening primitive conversion.\n\ncannot do two of these in one step. \n\n','General',0,0,NULL,5),(2666,'ok','5.1.2. Widening Primitive Conversion\n\n19 specific conversions on primitive types are called the widening primitive conversions:\n\n    byte to short, int, long, float, or double\n\n    short to int, long, float, or double\n\n    char to int, long, float, or double\n\n    int to long, float, or double\n\n    long to float or double\n\n    float to double\n\nA widening primitive conversion does not lose information about the overall magnitude of a numeric value.\n\nA widening primitive conversion from an integral type to another integral type, or from float to double in a strictfp expression (§15.4), does not lose any information at all; the numeric value is preserved exactly.\n\nA widening primitive conversion from float to double that is not strictfp may lose information about the overall magnitude of the converted value.\n\nA widening conversion of an int or a long value to float, or of a long value to double, may result in loss of precision - that is, the result may lose some of the least significant bits of the value. In this case, the resulting floating-point value will be a correctly rounded version of the integer value, using IEEE 754 round-to-nearest mode (§4.2.4).\n\nA widening conversion of a signed integer value to an integral type T simply sign-extends the two\'s-complement representation of the integer value to fill the wider format.\n\nA widening conversion of a char to an integral type T zero-extends the representation of the char value to fill the wider format.\n\nDespite the fact that loss of precision may occur, a widening primitive conversion never results in a run-time exception (§11.1.1).\n\nExample 5.1.2-1. Widening Primitive Conversion\n\nclass Test {\n    public static void main(String[] args) {\n        int big = 1234567890;\n        float approx = big;\n        System.out.println(big - (int)approx);\n    }\n}\n\nThis program prints:\n\n-46\n\nthus indicating that information was lost during the conversion from type int to type float because values of type float are not precise to nine significant digits.\n','General',0,0,NULL,5),(2667,'<T extends C & I> is apparently legal, \n\nmore research is necesarry','class C { \n    public    void mCPublic()    {}\n    protected void mCProtected() {} \n              void mCDefault()   {}\n    private   void mCPrivate()   {} \n} \n\ninterface I {\n    void mI();\n}\n\nclass CT extends C implements I {\n    public void mI() {}\n}\n\nclass Test {\n    <T extends C & I> void test(T t) { 	\n        t.mI();           // OK\n        t.mCPublic();     // OK \n        t.mCProtected();  // OK \n        t.mCDefault();    // OK\n        t.mCPrivate();    // Compile-time error\n    } \n}','General',0,0,NULL,5),(2668,'This will compile because seperateToCategories takes an Animal or a subtype\n\n','class Foo{\n\npublic static ArrayList<Animal> staggerSort(ArrayList<? extends Animal> list){\n        Map<String,List<Number>> byCategory = seperateToCategories(list);\n        return null;\n    }\n    \n    static Map<String,List<Number>> seperateToCategories(ArrayList<? extends Animal> list){\n        return null;\n    }\n    \n}','Generics',0,0,NULL,5),(2669,'java.sql.SQLException: Can\'t call commit when autocommit=true','public class Hello{\n    public static void main(String[] args){\n        Hello h = new Hello();\n        h.access();\n    }\n\n    public void access() {\n        try (Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees\", \"root\", \"Basketball12\")) {\n           Statement st = conn.createStatement();\n           conn.setAutoCommit(true);\n           String q = \"update employees set first_name = \'h\' where emp_no = 10001\";\n           boolean t = st.execute(q);\n           \n           \n           \n           conn.commit();\n\n        } catch (SQLException e) {\n            System.out.println(e);\n        }\n    }\n}','JDBC',0,0,NULL,5),(2670,'ok','new OpenOption[]{StandardOpenOption.READ, StandardOpenOption.DELETE_ON_CLOSE}\nnew OpenOption[]{StandardOpenOption.APPEND, StandardOpenOption.CREATE_NEW}	\n	This throws java.lang.UnsupportedOperationException: \'APPEND\' not 				allowed.\n\n','IO',0,0,NULL,5),(2671,'In this case, .. is at the top level and there is no parent directory at this level. Therefore, it is redundant and is removed from the normalized path. Had there been a parent directory for .., for example, c:/temp/../test.txt, the parent directory and .. would cancel out ( i.e. the result would be c:/test.txt ).','Path p1 = Paths.get(\"c:\\\\..\\\\temp\\\\test.txt\");    System.out.println(p1.normalize().toUri());','IO',0,0,NULL,5),(2675,'tets','test','Executors',0,0,NULL,5),(2695,'','The location of the deployment descriptor is ?	','Servlets',0,1,NULL,5),(2696,'/WEB-INF/web.xml\n','The location of the deployment descritptor is ?','Servlets',0,1,NULL,5),(2697,'try{\n\n}catch(Exception1 | Exception2 e) {\n\n	e = new Exception1();\n}\n\nTHIS WOULD FAIL COMPILATION\n\n','When using multi-catch, the catch block parameter is final and cannot \nhave a new value assigned to it in the catch block.\n\ntry{\n\n} catch(SQLException | IOException e){\n	\n	e = new IOException();\n}\n\n// this shows why thats illegal, your not sure which exception type \nwill come through.\n//updated 2','Exceptions',0,0,NULL,5),(2698,'javac -source 1.3 OldCode.java\n\njavac -source 1.4 NewCode.java','To compile old code that may use \'assert\' as an identifier, \nadd 1.3. This will tell the compiler to treat the word \'assert\' as an identifier.\n\n1.4 will use \'assert\' as a keyword	','Exceptions',0,0,NULL,5),(2699,'java -da com.maxbisesi.Test\n\njava -disableassertions com.maxbisesi.Test','Disable assertions at runtime		','Exceptions',0,0,NULL,5),(2700,'This is a bad idea...\n\npublic void doStuff(){\n	assert (modifyThings());\n	//continue\n}\n\npublic boolean modifyThings() {\n	y = x++;\n	return true;\n}','Dont use assert expressions that can cause side effects...','Exceptions',0,0,NULL,5),(2701,'Fails compilation','You cant use the variable name multiple times in a multi-catch. \nThe following wont compile...\n\ncatch(Exception1 e1 | Exception2 e2){\n\n}','Exceptions',0,0,NULL,5),(2702,'the following are equivalent:\n\ncatch(SQLException | IOException e)\n\ncatch(IOException | SQLException e)','With Multi catch order does NOT matter...		','Exceptions',0,0,NULL,5),(2703,'The following will not compile...\n\ncatch(FileNotFoundException | IOException e)\n\nsince FILNOTFOUND is a subclass of IOException we could have just\nwrtten that in the first place..\n\ncatch(IOException)','With Multi-Catch you have to make sure a given excpetion can only\nmatch one type...\n\ncatch(IOException | SQLException e)\n\nthese two are different types.','Exceptions',0,0,NULL,5),(2704,'This is legal but it is not good practice. It is illegal to reasign the value\nof a multi-catch parameter. \n\ntry {\n	\n} catch(SQLException | IOException e){\n\n	e = new IOException();\n}\n\n^^WILL NOT COMPILE\n','Legal or illegal...\n\ntry {\n	//do something\n} catch(IOException e){\n	\n	e = new IOException();\n}','Exceptions',0,0,NULL,5),(2705,'Will not compile, it is legal to reassign the parameter here. But it is illegal\nto throw e. The method declares that it throws SQL and IO so throwing a \ngeneral exception is unreported. \n\nif the signature was throws Exception then everything would be fine\n\nException as a genreal','public void couldthrow() throws SQLException, IOException { }\n\npublic void rethrow() throws SQLException, IOException {\n	try{\n		couldthrow();\n	} catch(Exception e){ \n		e = new IOException();\n		throw e;\n	}\n}	','Exceptions',0,0,NULL,5),(2706,'Illegal, regular trys have to have a catch or a finally\n\ntry-with can be used by themselves','legal or illegal\n\ntry {\n\n}','Exceptions',0,0,NULL,5),(2707,'does not compile. \nto be declared in a try with the method has to implement auto closeable or\ncloseable','try(String s = \"hi\") {}','Exceptions',0,0,NULL,5),(2708,'will not compile,\nThe declared resources use a commma , not a semi colon ;\n\nshould be:\n\ntry(Resource r = new Resource(); ...','Path p = Paths.get(\"/home/maxbisesi\");\n      try(BufferedReader br = new BufferedReader(new FileReader(p.toFile())), BufferedWriter bw = new BufferedWriter(new FileWriter(p.toFile()))){\n          \n      } catch(IOException e){\n          \n      }','Exceptions',0,0,NULL,5),(2709,'ok, AutoCloseable interface allows throwing any Exception','Class A implements AutoCloseable { \n	public void close() throws Exception {}\n}	','Exceptions',0,0,NULL,5),(2710,'ok sublcasses or implenting methods can throw a subclass of excpetion\nor none at all.\n\nAutoCloseable\'s  close throws an Exception','class B implements AutoCloseable { public void close() {}}\nclass C implements AutoCloseable { public void close() throws IOException {}}','Exceptions',0,0,NULL,5),(2711,'ILLEGAL- Closeable only allows IOExceptions or subclasses','class D implements Closeable { public void close() throws Exception{}}','Exceptions',0,0,NULL,5),(2712,'ok Closeable allows throwing IOExceptions\n\nvoid close() throws IOException','class E implements Closeable { public void close() throws IOException {}}','Collections',0,0,NULL,5),(2713,'you can call close() multiple times all day and nothing will happen the second time and beyond. \nwill not blow up. ','idempotent','Exceptions',0,0,NULL,5),(2714,'nothing bad will happen if you call close() more than one time. ','AutoCloseable\'s close() is idempotent	','Exceptions',0,0,NULL,5),(2715,'might blow up if called more than once','Closeable\'s close() is not idempotent','Exceptions',0,0,NULL,5),(2716,'B\nA\ncatch\n\nResources are closed in reverse order from what they are declared.','class A implements AutoCloseable {\n	public void close() {\n		sout(\"A\");\n	}\n}\n\nclass B implements AutoCloseable {\n	public void close() {\n		sout(\"B\");\n	}\n}\n\nclass C {\n	psvm(sa){\n		try(A a = new A(); B b = new B()){\n			throw new RuntimeException();\n		} catch(EXception e) {\n			sout(\"catch\");\n		}\n	}\n}\n\nwhat does it print?','Exceptions',0,0,NULL,5),(2717,'Try\nsuppressed: java.io.IOException: Closing\n\nafter the exception in the try block gets thrown on line 4, the try with \nresources still calls close() and the catch block catches one \nof the exceptions.\n\nJava adds any excpeittions thrown by close() methods to a suppressed array in the main excpetion. \n\nif no other exception happens in the try block the exceptioon thrown in\nclose() gets treated as the main excpetion  for the catch block. ','public class Suppressed {\n	psvm(sa) {\n		try(One one = new One()) {\n			throw new exception(\"try\");\n		} catch (Exception e) {\n			sout(e.getMessage());\n			\n			for(Throwable t : e.getSuppressed()){\n				sout(\"suppressed:\" + t);\n		}	}\n	}\n}\n\nclass One implements AutoCloseable {\n	public void close() throws IOException {\n		throw new IOException(\"Closing\");\n	}\n}','Exceptions',0,0,NULL,5),(2718,'got it ','If the catch or Finally block throws an exception NO SUPPRESSION HAPPENS\nthe last exception thrown gets sent to the caller rather than the one from the \ntry- just like before try with resources','Exceptions',0,0,NULL,5),(2719,'Closing - 2\nsuppressed: java.io.IOException: Closing - 1\n\nresources close in the opposite order they are declared','class Bad implements AutoCloseable {\n	String name;\n	Bad(String n) { name = n; }\n	public void close() throws IOException {\n		throw new IOException(\"Closing -\" +name);\n	}\n}\n\npublic class Suppressed {\n	public static void main(SA) {\n		try(Bad b1 = new Bad(\"1\"); Bad b2 = new Bad(\"2\")) {\n			\n		} catch(Exception e) {\n			sout(e.getMessage());\n			for(Throwable t : e.getSuppressed()) {\n				sout(\"suppressed:\" + t);\n			}\n		}\n	}\n}','Exceptions',0,0,NULL,5),(2720,'Since all file IO on the exam is related to characters, if you see a Stream\nlike DataOutputStream the the question is probably about serialization\nor something unrelated to the actual IO objective','Stream classes are used to read and write bytes, and Readers and Writers\nare used to read write Characters....','IO',0,0,NULL,5),(2721,'// first time\nfalse\ntrue \ntrue\n\n//second time\ntrue\nfalse\ntrue\n\nexists returns false the first time becasue the file was created as an object\nbut not yet as a physical file. ','psvm(SA) {\n	try {\n		boolean newFile = false;\n		File file = new File(\"fiileWrite1.txt\");\n		sout(file.exists());\n		newFile = file.createNewFile());\n		sout(newFile);\n		sout(file.exists());\n	} catch (IOException e) {}\n}	','IO',0,0,NULL,5),(2722,'This method returns true if it can find the actual file\n\nfalse\ntrue\n\n	the first time it is run','public static void main(String[] args){\n        File newFile = new File(\"/home/maxbisesi/Public/textFile5.txt\");\n        try{\n            System.out.println(newFile.exists());\n            newFile.createNewFile();\n            System.out.println(newFile.exists());\n        } catch(IOException e){\n            \n        }   \n    }','IO',0,0,NULL,5),(2723,'true if the named file does not exist and was successfully created; false if the named file already exists\n','File method: \ntry {\n	createNewFile();\n} catch(IOException e) { } ','IO',0,0,NULL,5),(2724,'File(File parent, String child)\nCreates a new File instance from a parent abstract pathname and a child pathname string.\n\nFile(String pathname)\nCreates a new File instance by converting the given pathname string into an abstract pathname.\n\nFile(String parent, String child)\nCreates a new File instance from a parent pathname string and a child pathname string.','File class Constructors	','IO',0,0,NULL,5),(2725,'createNewFile()\ndelete()\nexists()\nisDirectory()\nisfile()\nlist()\nmkdir()\nrenameTo()','File class key methods ','IO',0,0,NULL,5),(2726,'FileWriter(File file)\n\nFileWriter(String filename)','FileWriter class Constructors	','IO',0,0,NULL,5),(2727,'close()\nflush()\nwrite()','FileWriter class key methods 	','IO',0,0,NULL,5),(2728,'BufferedWriter(Writer out)','BufferedWriter class constructors	','IO',0,0,NULL,5),(2729,'close() \nflush()\nnewLine()\nwrite()','BufferedWriter key methods	','IO',0,0,NULL,5),(2730,'PrintWriter(File file)\nCreates a new PrintWriter, without automatic line flushing, with the specified file.\n\nPrintWriter(File file, String csn)\nCreates a new PrintWriter, without automatic line flushing, with the specified file and charset.\n\nPrintWriter(OutputStream out)\nCreates a new PrintWriter, without automatic line flushing, from an existing OutputStream.\n\nPrintWriter(OutputStream out, boolean autoFlush)\nCreates a new PrintWriter from an existing OutputStream.\n\nPrintWriter(String fileName)\nCreates a new PrintWriter, without automatic line flushing, with the specified file name.\n\nPrintWriter(String fileName, String csn)\nCreates a new PrintWriter, without automatic line flushing, with the specified file name and charset.\n\nPrintWriter(Writer out)\nCreates a new PrintWriter, without automatic line flushing.\n\nPrintWriter(Writer out, boolean autoFlush)\nCreates a new PrintWriter.','PrintWriter constructors','IO',0,0,NULL,5),(2731,'read()','FileReader key methods 	','IO',0,0,NULL,5),(2732,'Reader','BufferedReader constructors	','IO',0,0,NULL,5),(2733,'read()\nreadLine()','BufferedReader key methods','IO',0,0,NULL,5),(2734,'filewrite2.txt would contain the text:\n\nhello\nworld','File file = new file(\"filewriter2.txt\");\nFileWriter fw = new fileWriter(file);\n\nPrintWriter pw = new PrintWriter (fw);\n\npw.println(\"hello\");\npw.println(\"world\"));','IO',0,0,NULL,5),(2735,'','File file = new File(\"filewrite2.txt\");\nFileReader fr = new FileReader(file);\nBufferedReader br = new BufferedReader(fr);\n\nString data = br.readLine();','IO',0,0,NULL,5),(2736,'got it ','File file = new File(\"foo\");\n\nif \"foo\" does not exist no actual file is created.\n\nif \"foo\" does exists, the new File object refers to the existing file. ','IO',0,0,NULL,5),(2737,'io','readers dont have flush methods','IO',0,0,NULL,5),(2738,'a char[]','Console.readPassword() returns...','IO',0,0,NULL,5),(2739,'Returns the path element corresponding to the specified index.\n\nthe 0th element is the one closest to the root.','Path Method:\n\nPath getName(int index)','IO',0,0,NULL,5),(2740,'returns the filename or the last element of the sequence of name elements\n\nor..\n\nReturns the name of the file or directory denoted by this path as a Path object. The file name is the farthest element from the root in the directory hierarchy.','Path Method:\n\nString getFileName()','IO',0,0,NULL,5),(2741,'4','public class Hello {\n    public static void main(String[] dicks) throws IOException{\n      Path src = Paths.get(\"/home/maxbisesi/Documents/copy.txt\");\n\n      System.out.println(src.getNameCount());\n      \n    }\n\n}','IO',0,0,NULL,5),(2742,'\n/home/maxbisesi/Documents','\npublic class Hello {\n    public static void main(String[] dicks) throws IOException{\n      Path src = Paths.get(\"/home/maxbisesi/Documents/copy.txt\");\n      Path srcParent = src.getParent();\n      System.out.println(srcParent);\n      \n    }\n\n}','IO',0,0,NULL,5),(2743,'retunrs the root of thsi path, or null if this path does not have a root.','Path Method:\n\nPath getRoot()		','IO',0,0,NULL,5),(2744,'returns a ssubsequence of this path NOT INCLUDING ROOT. \n\nbeginning INCLUSIVE\n\nending EXCLUSIVE','Path Method:\n\nPath subpath(int beginindex, int endIndex)','IO',0,0,NULL,5),(2745,'that means it can be iterated through in a for loop!','Path extends from Iterable<Path>	','IO',0,0,NULL,5),(2746,'tmp/dir1/dir2/dir3/file.txt','int spaces = 1;\nPath myPath = Paths.get(\"tmp\", \"dir1\", \"dir2\", \"dir3\", \"file.txt\");\n\nfor(Path subpath : myPath){\n	sout( subpath + \"//\" );\n}','IO',0,0,NULL,5),(2747,'returns a path that is this path with redundant name elements eliminated\n\n. can be ignored\n\n.. followed by a directory can be removed as redundant','Path method:\n\nPath normalize()	','IO',0,0,NULL,5),(2748,'/a/b/c','Paths.get(\"/a/./b/./c\").normalize();\n','IO',0,0,NULL,5),(2749,'.classpath','Paths.get(\".classpath\").normalize();','IO',0,0,NULL,5),(2750,'/a/b','Paths.get(\"/a/b/c/..\").normalize()','IO',0,0,NULL,5),(2751,'../a/b/c\n\nThe two dots do say go up one directory, but since there is\'nt a directory\nbefore it Path cant simplify it.','Paths.get(\"../a/b/c\").normalize()','IO',0,0,NULL,5),(2752,'/home/java/models/Model.pdf\n\npath1.resolve(path2) should be read as \"resolve path2 within path1s directory\n','Path dir = Paths.get(\"/home/java\");\nPath file = Paths.get(\"models/Model.pdf\");\nPath result = dir.resolve(file);\n\nsout( result );\n	','IO',0,0,NULL,5),(2753,'/google\n\nResolve the given path against this path.\n\nIf the other parameter is an absolute path then this method trivially returns other.\n If other is an empty path then this method trivially returns this path.\n Otherwise this method considers this path to be a directory and resolves\n the given path against this path. In the simplest case, the given path does not have a root component, \nin which case this method joins the given path to this path \nand returns a resulting path that ends with the given path.','class Hello {\n    public static void main(String[] args) {     \n        Path p1 = Paths.get(\"/home/max/tmp\");\n        Path p2 = Paths.get(\"/google\");\n        System.out.println(p1.resolve(p2));\n        \n    }\n\n}','IO',0,0,NULL,5),(2754,'/home/java/dir\n/home/java/Model.pdf\n/dir/Model.pdf\n/home/java\n/home/java\nModel.pdf/dir\n\nThe first three do what you would exprect. They add the paramenter\nto resolve to the provided path object. The fourth and fifth try to resolve\nan absolute path within the context of something else. The problem is \nthat an aboluste path doesnt\'t depend on other directories it is absolute.\n','Path absolute = Paths.get(\"/home/java\");\nPath relative = Paths.get(\"dir\");\nPath file = Paths.get(\"Model.pdf\");\n\nsout( absolute.resolve(relative) );\nsout( asolute.resolve(file) );\nsout( relative.resolve(file) );\nsout( relative.resolve(absolute) ); // BAD\nsout( file.resolve(absolute) ); //BAD\nsout( file.resolve(relative) ); //BAD','IO',0,0,NULL,5),(2755,'Thhe compilere cannot decide here so it will not compile','Be carefule with questions that come in two flavors. one with a Path parameter\nand the other with a String parameter such as resolve()...\n\nPath path = Paths.get(\"/usr/bin/zip\");\npath.resolve(null);','IO',0,0,NULL,5),(2756,'resolve()','Which Path method is used to combine two paths and set one in another?','IO',0,0,NULL,5),(2757,'relativize()','Which Path method is used to describe how to gret from one path to \nthe other	','IO',0,0,NULL,5),(2758,'country/Swift.mp3\n\n\njava recognized that the /home/java part is the same and returned a path of\njust the remainder.\n\npath1.relativize(path2) should be read as \"give me a path shows how to get from\npath1 to path2\"','Path dir = Paths.get(\"/home/java\");\nPath music = Paths.get(\"/home/java/country/Swift.mp3\");\nPath mp3 = dir.reltivize(music);\n\nsout( mp3 );','IO',0,0,NULL,5),(2759,'.relativize()','\"give me a path shows how to get from\npath1 to path2\"','IO',0,0,NULL,5),(2760,'temp/music.mp3\n\n../..\n\n../../usr/local\n\nmusic.pdf\n\nExcpetion in main thread IllegalArgumentExcpetion\n\n	','Path absolute1 = Paths.get(\"/home/java\");\nPath absolute2 = Paths.get(\"/usr/local\");\nPath absolute3 = Paths.get(\"/home/java/temp/music.mp3\");\nPath relative1 = Paths.get(\"temp\");\nPath relative2 = Paths.get(\"temp/music.pdf\");\n\nsout( absolute1.relativize(absolute3) );\nsout( absolute3.relativize(absolute1) );\nsout( absolute1.relativize(absolute2) );\nsout( relative1.relativize(relative2) );\nsout( absolute1.relativize(relative1) ); //BAD','IO',0,0,NULL,5),(2761,'Path relativize(Path other)\n\nConstructs a relative path between this path and a given path.\n\nRelativization is the inverse of resolution. This method attempts to construct a relative path that when resolved against this path, yields a path that locates the same file as the given path. For example, on UNIX, if this path is \"/a/b\" and the given path is \"/a/b/c/d\" then the resulting relative path would be \"c/d\". Where this path and the given path do not have a root component, then a relative path can be constructed. A relative path cannot be constructed if only one of the paths have a root component. Where both paths have a root component then it is implementation dependent if a relative path can be constructed. If this path and the given path are equal then an empty path is returned.\n\nFor any two normalized paths p and q, where q does not have a root component,\n\n    p.relativize(p.resolve(q)).equals(q) \n\nWhen symbolic links are supported, then whether the resulting path, when resolved against this path, yields a path that can be used to locate the same file as other is implementation dependent. For example, if this path is \"/a/b\" and the given path is \"/a/x\" then the resulting relative path may be \"../x\". If \"b\" is a symbolic link then is implementation dependent if \"a/b/../x\" would locate the same file as \"/a/x\".\n\nParameters:\n    other - the path to relativize against this path\nReturns:\n    the resulting relative path, or an empty path if both paths are equal\nThrows:\n    IllegalArgumentException - if other is not a Path that can be relativized against this path','relativeize()','IO',0,0,NULL,5),(2762,'If this program is run from the root, it is the one in /tmp/file1.txt\n\nif it is run from /tmp it is the one in /tmp/tmp/file1.txt\n\nif the program is run from anywhere else the path refers to a file that doesn\nnot exist. ','When creating a Path you can seperate out folder and filename as much\nor as little as you want. When you don\'t begin with a root the Path\nis considered a relative path, which means Java looks from the current\ndirectory.\n\nPath p6 = Paths.get(\"tmp\", \"file1.txt\"); // relative path\n\n/ (root)\n	| - - tmp\n		| - file1.txt\n		| - tmp\n			| - file1.txt\n','IO',0,0,NULL,5),(2763,'got it ','With IO a file doesn\'t exists just because you create a File object.\nIt is the same with Path objects\n\nPath path = Paths.get(\"fileWrite1.txt\");\nsout(Files.exists(path)); // false\nFiles.createFile(path); \nsout(Files.exists(path)); // true','IO',0,0,NULL,5),(2764,'Path path1 = Paths.get(\"/java/source\");\nPath path2 = Paths.get(\"/java/source/directory\");\nPath file = Paths.get(\"/java/source/directory/Program.java\");\nFiles.createDirectory(path1);\nFiles.createDirectory(path2);\nFiles.createFile(file);\n\n// all at once\n\nFiles.createDirectories(path2);\nFile.createFile(file);','create directories one at a time or all at once	......\n\nTHE directory must exist by the time the file is created','IO',0,0,NULL,5),(2765,'13570164000000','Date januaryFirst = new GregorianCalendar(20q3, Calendar.January, 1).getTime();\n\nFile file = new File(\"c:/temp/file\");\nfile.createNewFile();\nfile.setLastModified(januaryFirst.getTime());\nfile.setLastModified(januaryFirst.getTime());\nsout(file.lastModified());\nfile.delete();','IO',0,0,NULL,5),(2766,'2013-01-01T05','Path path = Paths.get(\"c:/temp/file2\");\nDate januaryFirst = new GregorianCalendar(2013,Calendar.JANUARY, 1).getTime();\nFiles.createFile(path);\nFileTime fileTime = FileTime.fromMillis(januaryFirst.getTime());\nFiles.setLastModifiedTime(path,fileTime);\nsout(Files.getLastModifiedTime(path));\nFiles.delete((path);','IO',0,0,NULL,5),(2767,'\nfile.lastModified();\n\nFiles.getLastModifiedTime(path);','How would you get the last modified date/time of a Path and a File?\n\nFile file = new file(\"test\");\nPath path = Paths.get(\"test\");','IO',0,0,NULL,5),(2768,'A C D E F \n\nin an undeterminable order, although thread angela uses the max reference\n.Sleep is static and therefore she puts herself to sleep. This is why\nreferences shouldn\'t be used for static methods. \n\nmax trys to synchronize on angela but he does not own the lock so he therefore\ncannot and throws an IllegalMonitorStateException. \n\n... ','public class Hello {\n    static Thread max ,angela;\n    public static void main(String[] args){\n        angela = new Thread() {\n            public void run(){\n                System.out.println(\"A\");\n                try {\n                    max.sleep(1000);\n                } catch(Exception e){\n                    System.out.println(\"B\");\n                }\n                System.out.println(\"C\");\n                \n            }\n        };\n        \n        max = new Thread() {\n            public void run(){\n                System.out.println(\"D\");\n                try {\n                    angela.wait(); \n                } catch(Exception e){\n                    System.out.println(\"E\");\n                }\n                \n                System.out.println(\"F\");\n            }\n        };\n        \n        max.start();\n        angela.start();   \n    }\n} ','IO',0,0,NULL,5),(2769,'file.canRead();\n\nFiles.isReadable(path);','How would you get theread permision set of a Path and a File?\n\nFile file = new file(\"test\");\nPath path = Paths.get(\"test\");','IO',0,0,NULL,5),(2770,'file.canWrite();\nfile.canExecute();\n\nFiles.isWritable(path);\nFiles.isExecutable(path);','How would you get write and or execute permision set of a Path and a File?\n\nFile file = new file(\"test\");\nPath path = Paths.get(\"test\");','IO',0,0,NULL,5),(2771,'file.setLastModifed(timeinMillis);\n\nFileTime ft = FileTime.fromMillis(timeInMillis);\nFiles.setLastModifiedTime(path,ft);','How do you set the last modified time of a path and file?\n\nFile file = new file(\"test\");\nPath path = Paths.get(\"test\");','IO',0,0,NULL,5),(2772,'basic.creationTime();\nbasic.lastAccessTime();\nbasick.lastModifiedTime();\n\nbasic.isDirectory();\n\n','BasicFileAttributes basic = Files.readAttributes(path, BasicFileAttributes.class);\n\nhow would you list the creation time, last access time, and last Modified time?	\n','IO',0,0,NULL,5),(2773,'1. BasicFileAttributes is PLURAL, BasicFileAttributeVIew is SINGULAR\n\n2. BasicFIleAttributeView basView = Files.getFileAttributeView(   );   \n\n	BasicFileAtttributes bas = FIles.readAttributes(   );\n\n3. You can ONLY update attributes in BasicFileAttributeView, \n	\n	VIEW IS FOR UPDATING','Three big things about BasicFileAttributes and BasicFileAttributeView...','IO',0,0,NULL,5),(2774,'PosixFileAttributes pox = Files.readAttributes(path, PosixFileAttributes.class);\n','How would you construct a PosixFileAttribute object?	','IO',0,0,NULL,5),(2775,'Path path = Paths.get(\"/tmp/file2\");\nFiles.createFile(path);\nPosixFileAttributes ps = Files.readAttributes(path, PosixFileAttributes.class);\n\nSet<PosixFilePermission> perms = PosixFilePermission.fromString(\"rw-r--r--\");\n\nFiles.setPosixFilePermissions(path,perms);\n\nsout( ps.permissions() );\n\nTHe output would be:\n\n[OWNER_WRITE, GROUP_READ, OTHERS_READ, OWNER_READ ]','How would you set a Unix File\'s permissions in Java?	','IO',0,0,NULL,5),(2776,'BasicFileAttributes basic = Files.readAttributes(path1, BasicFileAttribute.class );\n\nFileTime at = basic.lastAccessTime();\nFileTime update = basic.lastModifiedTime();\nFileTime now = FileTime.fromMillis(System.currentTimeMiilis() );\n\nPath file = Paths.get(\"/temp/file.txt\");\nFiles.createFile(file);\n\nBasicFileAttributeView view = Files.getBasicFileAttributeView(file, BasicFileAttributeView.class);\n\nview.setTimes(update, at, now);','How to take modified times from one file\nand write new BasicFileAttributes\' last modified times\nlast access time and creation time to another file ... ?','IO',0,0,NULL,5),(2777,'... interface\n\nmethods:\n\nString 	name()\nReturns the name of the attribute view.\n\nBasicFileAttributes 	readAttributes()\nReads the basic file attributes as a bulk operation.\n\nvoid 	setTimes(FileTime lastModifiedTime, FileTime lastAccessTime, FileTime createTime)\n\nUpdates any or all of the file\'s last modified time, last access time, and create time attributes.','BasicFileAttributeView is a...\n\nClass\n\nInterface\n\nAbstract class     ?','IO',0,0,NULL,5),(2778,'FileTime 	creationTime()\nReturns the creation time.\n\nObject 	fileKey()\nReturns an object that uniquely identifies the given file, or null if a file key is not available.\n\nboolean 	isDirectory()\nTells whether the file is a directory.\n\nboolean 	isOther()\nTells whether the file is something other than a regular file, directory, or symbolic link.\n\nboolean 	isRegularFile()\nTells whether the file is a regular file with opaque content.\n\nboolean 	isSymbolicLink()\nTells whether the file is a symbolic link.\n\nFileTime 	lastAccessTime()\nReturns the time of last access.\n\nFileTime 	lastModifiedTime()\nReturns the time of last modification.\n\nlong 	size()\nReturns the size of the file (in bytes).','interface BasicFileAttributes methods.... ','IO',0,0,NULL,5),(2779,'GroupPrincipal 	group()\nReturns the group owner of the file.\n\nUserPrincipal 	owner()\nReturns the owner of the file.\n\nSet<PosixFilePermission> 	permissions()\nReturns the permissions of the file.','interface PosixFileAttributes methods','IO',0,0,NULL,5),(2780,'String 	name()\nReturns the name of the attribute view.\n\nPosixFileAttributes 	readAttributes()\nReads the basic file attributes as a bulk operation.\n\nvoid 	setGroup(GroupPrincipal group)\nUpdates the file group-owner.\n\nvoid 	setPermissions(Set<PosixFilePermission> perms)\nUpdates the file permissions.','interface PosixFileAttributeView methods ...','IO',0,0,NULL,5),(2781,'DosFileAttributeView has methods...\n\nsetArchive()\nsetHidden()\nsetReadOnly()\nsetSystem()\n\nfor Windows specific files ','With DosFileAttributeView you can set what new and different file types ?','IO',0,0,NULL,5),(2782,'String 	name()\nReturns the name of the attribute view.\n\nDosFileAttributes 	readAttributes()\nReads the basic file attributes as a bulk operation.\n\nvoid 	setArchive(boolean value)\nUpdates the value of the archive attribute.\n\nvoid 	setHidden(boolean value)\nUpdates the value of the hidden attribute.\n\nvoid 	setReadOnly(boolean value)\nUpdates the value of the read-only attribute.\n\nvoid 	setSystem(boolean value)\nUpdates the value of the system attribute.','interface DosFileAttributeView methods...','IO',0,0,NULL,5),(2783,'DosFileAttributes dos = Files.readAttributes(path, DosFileAttributes.class);\n\nsout( dos.isHidden() );\nsout( dos.isReadOnly() );\n\nFiles.setAttribute(path, \"dos:hidden\", true);\nFiles.setAttribute(path, \"dos:readonly\", true);\n\n','read a DosFileAttributes then declare if it is hidden and readonly \nthen set them so without using a DosFileAttributeView...','IO',0,0,NULL,5),(2784,'\n    setAttribute\n\n    public static Path setAttribute(Path path,\n                    String attribute,\n                    Object value,\n                    LinkOption... options)\n                             throws IOException\n\n    Sets the value of a file attribute.\n\n    The attribute parameter identifies the attribute to be set and takes the form:\n\n        [view-name:]attribute-name \n\n    where square brackets [...] delineate an optional component and the character \':\' stands for itself.\n\n    view-name is the name of a FileAttributeView that identifies a set of file attributes. If not specified then it defaults to \"basic\", the name of the file attribute view that identifies the basic set of file attributes common to many file systems. attribute-name is the name of the attribute within the set.\n\n    The options array may be used to indicate how symbolic links are handled for the case that the file is a symbolic link. By default, symbolic links are followed and the file attribute of the final target of the link is set. If the option NOFOLLOW_LINKS is present then symbolic links are not followed.\n\n    Usage Example: Suppose we want to set the DOS \"hidden\" attribute:\n\n        Path path = ...\n        Files.setAttribute(path, \"dos:hidden\", true);\n     \n\n    Parameters:\n        path - the path to the file\n        attribute - the attribute to set\n        value - the attribute value\n        options - options indicating how symbolic links are handled\n    Returns:\n        the path parameter\n    Throws:\n        UnsupportedOperationException - if the attribute view is not available\n        IllegalArgumentException - if the attribute name is not specified, or is not recognized, or the attribute value is of the correct type but has an inappropriate value\n        ClassCastException - if the attribute value is not of the expected type or is a collection containing elements that are not of the expected type\n        IOException - if an I/O error occurs\n        SecurityException - In the case of the default provider, and a security manager is installed, its checkWrite method denies write access to the file. If this method is invoked to set security sensitive attributes then the security manager may be invoked to check for additional permissions.\n\n','You dont always need a XXXFileAttributeView object in order to change\na files attributes, you can just as easily do so with \"Files\" ...\n	','IO',0,0,NULL,5),(2785,'Files.setPosixFilePermissions\n\npublic static Path setPosixFilePermissions(Path path,\n                           Set<PosixFilePermission> perms)\n                                    throws IOException\n\nSets a file\'s POSIX permissions.\n\nThe path parameter is associated with a FileSystem that supports the PosixFileAttributeView. This attribute view provides access to file attributes commonly associated \nwith files on file systems used by operating systems that implement the Portable \nOperating System Interface (POSIX) family of standards.\n\nParameters:\n    path - A file reference that locates the file\n    perms - The new set of permissions\nThrows:\n    UnsupportedOperationException - if the associated file system does not support the PosixFileAttributeView\n    ClassCastException - if the sets contains elements that are not of type PosixFilePermission\n    IOException - if an I/O error occurs\n    SecurityException - In the case of the default provider, and a security manager is installed, it denies RuntimePermission(\"accessUserInformation\") or its checkWrite method denies write access to the file.','You dont need PosixFileAttributeView to set a file permissions either...','IO',0,0,NULL,5),(2786,'PosixFileAttributes pos = Files.readAttributes(path, PosixFileAttributes.class);\nSet<PosixFilePermissions> perms = PosixFilePermissions.fromString(\"rw-r--r--:);\n\nFiles.setPosixFilePermissions(path,perms);\n\nsout(pos.group());\nsout(pos.permissions());','How to set a linux files permisions from a string ?\n	','IO',0,0,NULL,5),(2787,'DirectoryStream<T> \n\nT is the element returned by the iterator. \n\nTHis allows for the convieninet use of a for - each loop to go through a dir.\n\nThe elements returned by the iterator are in no specific order.\n\n List<Path> listSourceFiles(Path dir) throws IOException {\n       List<Path> result = new ArrayList<>();\n       try (DirectoryStream<Path> stream = Files.newDirectoryStream(dir, \"*.{c,h,cpp,hpp,java}\")) {\n           for (Path entry: stream) {\n               result.add(entry);\n           }\n       } catch (DirectoryIteratorException ex) {\n           // I/O error encounted during the iteration, the cause is an IOException\n           throw ex.getCause();\n       }\n       return result;\n   }\n ','What interface is used to recursively loop through a directory ?	','IO',0,0,NULL,5),(2788,'\n    Files.newDirectoryStream\n\n    public static DirectoryStream<Path> newDirectoryStream(Path dir)\n                                                    throws IOException\n\n    Opens a directory, returning a DirectoryStream to iterate over all entries in the directory. The elements returned by the directory stream\'s iterator are of type Path, each one representing an entry in the directory. The Path objects are obtained as if by resolving the name of the directory entry against dir.\n\n    When not using the try-with-resources construct, then directory stream\'s close method should be invoked after iteration is completed so as to free any resources held for the open directory.\n\n    When an implementation supports operations on entries in the directory that execute in a race-free manner then the returned directory stream is a SecureDirectoryStream.\n\n    Parameters:\n        dir - the path to the directory\n    Returns:\n        a new and open DirectoryStream object\n    Throws:\n        NotDirectoryException - if the file could not otherwise be opened because it is not a directory (optional specific exception)\n        IOException - if an I/O error occurs\n        SecurityException - In the case of the default provider, and a security manager is installed, the checkRead method is invoked to check read access to the directory.\n\n','how do you create a new DirectoryStream<T>','IO',0,0,NULL,5),(2789,'Path\n\nThe directory Stream interface is generic, but thats misleading since the \nonly way create a new DirectoryStream is by using File.newDirectoryStream\nwhich returns a Path.','What type of object are returned by directorystreams iterator ? ','IO',0,0,NULL,5),(2790,'use \nFiles.newDirectoryStream(Path dir, String glob);\n\nthis lets you add a glob in that will compare the string representations \nof their file names agains the given glob.\n\nthis lets you filter your results...\n\n Path dir = ...\n     try (DirectoryStream<Path> stream = Files.newDirectoryStream(dir, \"*.java\")) {\n         :\n     }','How would you filter the object returned by a directory Stream ?	','IO',0,0,NULL,5),(2791,'Nothing will not compile, must catch IOException for DirectoryStream','What will be returned by this code...\n\n	Path dir = Paths.get(\"/home/maxbisesi/Documents\");\n        \n	try(DirectoryStream<Path> ds = Files.newDirectoryStream(dir,\"[vx]*\")){\n            sout( );\n        } ','IO',0,0,NULL,5),(2792,'only 1','How many directories at a time can DirectoryStream look at ?','IO',0,0,NULL,5),(2793,'or ...\nDirectoryStream streams one directory','Think, DirectorySteam acts like ls in bash.','IO',0,0,NULL,5),(2794,'public static Path walkFileTree(Path start,\n                FileVisitor<? super Path> visitor)\n                         throws IOException\n\nWalks a file tree.\n\nThis method works as if invoking it were equivalent to evaluating the expression:\n\n     walkFileTree(start, EnumSet.noneOf(FileVisitOption.class), Integer.MAX_VALUE, visitor)\n     \n\nIn other words, it does not follow symbolic links, and visits all levels of the file tree.\n\nParameters:\n    start - the starting file\n    visitor - the file visitor to invoke for each file\nReturns:\n    the starting file\nThrows:\n    SecurityException - If the security manager denies access to the starting file. In the case of the default provider, the checkRead method is invoked to check read access to the directory.\n    IOException - if an I/O error is thrown by a visitor method','What \"Files\" method do you use along with FileVisitor?','IO',0,0,NULL,5),(2795,'FileVisitResult','FileVisitor methods return what ?','IO',0,0,NULL,5),(2796,'CONTINUE\nSKIP_SIBLINGS = continue without visiting the siblings of this file or directory\n\nSKIP_SUBTREE = continue without visiting the entries in this directory\n\nTERMINATE','Enum FileVisitResult elements','IO',0,0,NULL,5),(2797,'SimpleFileVisitor sf = new SimpleFileVisitor() will not compile','SimpleFileVisitor has a protected constructor so It can only be extended','IO',0,0,NULL,5),(2798,'DirectoryStream throws an IOException. Therefore anytime you use \nDirectoryStream you must catch an IOException\n\ntry(DirectoryStream stream = Files.newDirectoryStream(dir)){\n	sout(\"throw excpetion\");\n	//do stuff\n} catch(IOException e) { \n	log(e);\n}','try(DirectoryStream stream = Files.newDirectoryStream(dir)){\n	sout(\"throw excpetion\");\n	//do stuff\n}\n\nWhats wrong here ?','IO',0,0,NULL,5),(2799,'If DirectroyStream is not typed it will give Object elements. Therefore\nto use an untyped DirectoryStream you would have to use...\n	\n	for(Object file : stream) {\n	\n	}\n\n... but thats usually not what you want so always do this>>>\n\n	try(DirectoryStream<Path> Stream = Files.newDirectoryStream(dir)){\n\n	} catch(IOExcetpion e) {\n\n	}','try(DirectoryStream stream = Files.newDirectoryStream(dir)){\n\n	for(Path file : stream){\n		sout(file.getFileName());\n	}\n} catch(IOException e ){\n\n}\n\nWhats wrong here ??','IO',0,0,NULL,5),(2800,'All character stream classes are descended from Reader and Writer. \nAs with byte streams, there are character stream classes that specialize in file I/O: FileReader and FileWriter. \nThe CopyCharacters example illustrates these classes.\n\nclose() throws IOException here too','\npublic class CopyCharacters {\n    public static void main(String[] args) throws IOException {\n\n        FileReader inputStream = null;\n        FileWriter outputStream = null;\n\n        try {\n            inputStream = new FileReader(\"xanadu.txt\");\n            outputStream = new FileWriter(\"characteroutput.txt\");\n\n            int c;\n            while ((c = inputStream.read()) != -1) {\n                outputStream.write(c);\n            }\n        } finally {\n            if (inputStream != null) {\n                inputStream.close();\n            }\n            if (outputStream != null) {\n                outputStream.close();\n            }\n        }\n    }\n}\n','IO',0,0,NULL,5),(2801,'wrap them in Try Block, they all throw IOExceptions ','What has to be done with pretty much ALL IO classes ?','IO',0,0,NULL,5),(2802,'public String readLine()\n                throws IOException\n\nReads a line of text. A line is considered to be terminated by any one of a line feed (\'\\n\'), a carriage return (\'\\r\'), or a carriage return followed immediately by a linefeed.\n\nReturns:\n    A String containing the contents of the line, not including any line-termination characters, or null if the end of the stream has been reached\nThrows:\n    IOException - If an I/O error occurs\n\n\nOther IO classes have read methods that only read in a single character\nBufferedReader has this too. But this method really helps!','What method does BufferedReader have that makes it valuable	','IO',0,0,NULL,5),(2803,'PrintWriter','Which IO class swallows exceptions and does not throw them but \nsaid exceptions can be checked using checkerror()','IO',0,0,NULL,5),(2804,'wont compile you cant construct a FileWriter from a Path not to mention there is an unreported IOException','Path file = Paths.get(\"/home/dick/bigorsmall.txt\");\nBufferedWriter bw = new BufferedWriter(new FileWriter(file));\n\nbw.write(\"this ones pretty big \");','IO',0,0,NULL,5),(2805,'Copy the file from the source to target and return the target.\n\nthrows FileAlreadyExistsException if target fiile already exists, and no\nREPLACE_EXSISTING copy Option is specified. ','Files method:\n\nPath copy(Path src, Path targ, CopyOption...options)','IO',0,0,NULL,5),(2806,'Moves the file from src to target return target. \n\nthrows:\n\n FileAlreadyExistsException - if the target file exists but cannot be replaced because the REPLACE_EXISTING option is not specified (optional specific exception)\n   \n DirectoryNotEmptyException - the REPLACE_EXISTING option is specified but the file cannot be replaced because it is a non-empty directory (optional specific exception)','Files method:\n\nPath move(Path src, Path target, CopyOption options)','IO',0,0,NULL,5),(2807,'false \ntrue\n\nin glob * means match any character excpet a directory boundary\n\n** mathces any character across directory boundaries. \n\nnotice that PathMatcher(\"syntax:pattern\") can take a glob or a regex but you\nmust specify\n\nedit:\nwas previously:\nDefault().getPathMatcher(\"glob: *.txt\");\n\nthere cant be a space after the : or that will mathch...\n\n	Path path = Paths.get(\"one.txt\");\n        PathMatcher matcher = FileSystems.getDefault().getPathMatcher(\"glob: *.txt\");\n        System.out.println(matcher.matches(path));\n\nwould give false unless the space was removed. | Path p1 = Paths.get(\"/home/One.txt\");\nPath p2 = Paths.get(\"One.txt\");\nPathMatcher matcher = FileSystems.getDefault().getPathMatcher(\"glob: *.txt\");\n\nsout( matcher.matches(p1) );\nsout( matcher.matches(p2) );','Path p1 = Paths.get(\"/home/One.txt\");\nPath p2 = Paths.get(\"One.txt\");\nPathMatcher matcher = FileSystems.getDefault().getPathMatcher(\"glob:*.txt\");\n\nsout( matcher.matches(p1) );\nsout( matcher.matches(p2) );','IO',0,0,NULL,5),(2808,'* matches any character inside a directory boundary\n** matches any character inside a directory boundary\n\n','in Glob what does * mean ? what about ** ?','IO',0,0,NULL,5),(2809,'? matches any single character. ','GLOB\n\nwhat does \"?\" mean ?','IO',0,0,NULL,5),(2810,'true\ntrue\nfalse','public class Hello {\n    public static void main(String[] args) {\n        PathMatcher matcher = FileSystems.getDefault().getPathMatcher(\"glob:**{.pic,.txt}\");\n        Path p1 = Paths.get(\"home/files.txt\");\n        Path p2 = Paths.get(\"documents/pictures/smile.pic\");\n        Path p3 = Paths.get(\"home/dir\");\n        \n        System.out.println(matcher.matches(p1));\n        System.out.println(matcher.matches(p2));\n        System.out.println(matcher.matches(p3));\n    }\n\n}','IO',0,0,NULL,5),(2811,'true\ntrue\nfalse','public void matches(Path path, String glob){\n	PathMatcher matcher = FileSystems.getDefault().getPathMatcher(glob);\n	sout( matcher.matches(path) );\n}\n\nPath p1 = Paths.get(\"Bert-book\");\nPath p2 = Paths.get(\"Kathy-horse\");\nmatches(p1, \"glob:{Bert*,Kathy*}\");\nmatches(p2, \"glob: {Bert, Kathy}*\");\nmatches(p1, \"glob:{Bert,Kathy}\");','IO',0,0,NULL,5),(2812,'wrong, visitFileFailed takes an IOExcpeption as a parameter\nas well as postVisitDirectory','FileVisitor\n\npublic FileVisitResult visitFileFailed(path file, BasicFileAttributes attrs) {\n\n	// do something\n	return FileVisitResult.CONTINUE;\n	\n}\n','IO',0,0,NULL,5),(2813,'right, ','FileVisitor: \n\npublic FileVisitResult preVisitDirectory(path file, BasicFileAttributes attrs) {\n\n	// do something\n	return FileVisitResult.CONTINUE;\n	\n}','IO',0,0,NULL,5),(2814,'right','FileVisitor:\n\npublic FileVisitResult visitFileFailed(path file, IOException e) {\n\n	// do something\n	return FileVisitResult.CONTINUE;\n	\n}','IO',0,0,NULL,5),(2815,'right','FileVisitor:\n\npublic FileVisitResult postVisitDirectory(path file, IOException e) {\n\n	// do something\n	return FileVisitResult.CONTINUE;\n	\n}','IO',0,0,NULL,5),(2816,'9/8/01 7:46 PM \n\nremember that strings are imutable, so even though you called \nreplaceAll on that string you didn\'t assing it to a new sString therefore it\nwas lost.\n\nshould be:\n	String newDate = todayFile.replaceAll(\" \",\"-\");','Date today = new Date();\n\nDateFormat df = DateFormat.getInstance();\n\nString todayFile = df.format(today);\n\nsout(todayFile);	// this gives 9/8/01 7:46 PM\n\ntodayFile.replaceAll(\" \",\"-\");\n\nsout( todayFile );\n\nwhat prints now ?','Strings',0,0,NULL,5),(2817,'wont compile, FileWriter doesn\'t have a Path constructor,\n\nchange p1 to p1.toFile();\n\nFileWriter(File file)\nConstructs a FileWriter object given a File object.\n\nFileWriter(File file, boolean append)\nConstructs a FileWriter object given a File object.\n\nFileWriter(FileDescriptor fd)\nConstructs a FileWriter object associated with a file descriptor.\n\nFileWriter(String fileName)\nConstructs a FileWriter object given a file name.\n\nFileWriter(String fileName, boolean append)\nConstructs a FileWriter object given a file name with a boolean indicating whether or not to append the data written.','Path p1 = Paths.get(todayFile+\".txt\");\nSystem.out.println(p1);\n        \nBufferedWriter bw = new BufferedWriter(new FileWriter(p1));','IO',0,0,NULL,5),(2818,'4 3 \n\ntwo rules apply to the first doX, you cannot widen and then box in\none step, and var-args are always chosen last. So you cannot widen shorts\nto ints or longs then box them to Integer or Long but you can box short\nto Short then widen that to Number, that takes priority over var args.\n\nthe second doX simmply boxs int to Integer.\n\n\n\n    Assignment contexts allow the use of one of the following:\n\n        an identity conversion (§5.1.1)\n\n        a widening primitive conversion (§5.1.2)\n\n        a widening reference conversion (§5.1.5)\n\n        a boxing conversion (§5.1.7) optionally followed by a widening reference conversion\n\n        an unboxing conversion (§5.1.8) optionally followed by a widening primitive conversion.\n\n\n','class Eggs {\n	int doX(Long x, Long y){ return 1; }\n	int doX(long...){ return 2; }\n	int doX(Integer x, Integery){ return 3; }\n	int doX(Number n, Number m){ return 4; }\n	public static void main(SA){\n		new Eggs().go();\n	}\n	void go(){\n		short s = 7;\n		sout(doX(s,s) + \" \");\n		sout(doX(7,7));\n	}\n}','General',0,0,NULL,5),(2819,'the first is the directory to start walking at in the form of a Path\n\nthe second is an object of the class that extends SimpleFileVisitor<Path>','What is the first and second argument to Files.walkFileTree()','IO',0,0,NULL,5),(2820,'visitFileFailed and postVisitDirectory','Which Two FileVisitor methods take IOExceptions as parameters	?','IO',0,0,NULL,5),(2821,'preVisitDirectory and visitFile','Which two FileVisitor methods take BasicFileAttributes as parameters ?','IO',0,0,NULL,5),(2822,'now the output is:\n	pre: /home\n	file: /home/a.txt\n	pre: /home/child\n	pre: /home/emptyChild\n	post: /home/emptyChild\n	post: /home\n\npostVisitDirectory is never called if the subtree of the directory is skipped','/home\n	- a.txt\n	- emptyChild	\n	- child\n		- b.txt\n		- grandchild\n			- c.txt\n\npublic class PrintDirs extends SimpleFileVisitor<Path> {\n	public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) {\n		sout( \"pre\" + dir);\n		String name = dir.getFileName().toString();\n		\n		if (name.equals(\"child\"))\n			return FileVisitResult.SKIP_SUBTREE;\n		return FileVisitResult.CONTINUE;\n\n	}\n}\n			\n			\n		\n	','IO',0,0,NULL,5),(2823,'','postVisitDirectory is never called if the subtree of the directory is skipped','IO',0,0,NULL,5),(2824,'assuming child is encountered beffore emptyChild, the output is: \n\npre: /home\nfile: /home/a.txt\npre: /home/child\nfile: /home/child/b.txt\npre: /home/child/grandchild\npost: /home/child\npre: /home/emptyChild\npost: /home\n\nyou skip the grandchld subtree so you dont see the postVisitDirectory call\n\nchild is a sibling but it was encountered before emptychild so it was not skipped','/home\n	- a.txt\n	- emptyChild	\n	- child\n		b.txt\n		grandchild\n		c.txt\n\n\" assume you have FileVisitor method from previous flashcards where the\npre post and file are printed before printing the path of that dir or file \"\n\npublic FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) {\n	sout( \"pre: \" + dir);\n	String name = dir.getFileName().toString();\n	\n	if (name.equals(\"grandchild\"))\n		return FileVisitResult.SKIP_SUBTREE;\n	if ( name.equals(\"emptychild\")\n		return FileVisitResult.SKIP_SIBLINGS;\n	return FileVisitResult.CONTINUE;','IO',0,0,NULL,5),(2825,'true \nfalse\nfalse\nfalse\n\n{A*,b} means A followed by anything or the single character b\n\n/**/ means one or more directories with any name\n\n\\\\* the actuall asterix character \\ escapes the * the second \\ espaces the first \\ ','public void matches(Path path, String glob){\n	PathMatcher matcher = FileSystems.getDefault().getPathMatcher(glob);\n	sout( matcher.matches(path) );\n}\n\nPath p1 = Paths.get(\"0*b/test/1\");\nPath p2 = Paths.get(\"9\\\\*b/test/1\");\nPath p3 = Paths.get(\"01b/test/1\");\nPath p4 = Paths.get(\"0*b/1\");\n\nString glob = \"[0-9]\\\\*{A*,b}/**/1\");\n\nmatches(p1,glob);\nmatches(p2,glob);\nmatches(p3,glob);\nmatches(p4,glob);\n','IO',0,0,NULL,5),(2826,'IOException','What exception if any do FileVisitor methods throw ?','IO',0,0,NULL,5),(2827,'glob: **\n\nregex: .*','glob vs regex: \n\nZero or more of any character, including directory bounndary','IO',0,0,NULL,5),(2828,'zero or or more of any character including directory boundary','regex:\n\n.*','IO',0,0,NULL,5),(2829,'glob: *\n\nregex: no syntax required','glob vs regex:\n\nZero or more of any character, not a directory boundary','IO',0,0,NULL,5),(2830,'glob: ?\n\nregex: .','Glob vs regex:\n\nexcactly one character','IO',0,0,NULL,5),(2831,'glob:\n	{cat, dog}*\n\nregex:\n\n	(cat|dog).*','glob vs regex:\n\nBegins with cat or dog','IO',0,0,NULL,5),(2832,'regex','(cat|dog).*\n\nglob or regex ?','IO',0,1,NULL,5),(2833,'FileSystems.getDefault().getPathMatcher();','You are creating a PathMatcher\n\nPathMatcher matcher = ________._________().__________();','IO',0,0,NULL,5),(2834,'FileSystems.getDefault().newWatchService();','You are creating a WatchService:\n\nWatchService watcher = _____________.__________()._________()','IO',0,0,NULL,5),(2835,'WatchKey\ntry {\n	WatchKey key;\n	try {\n	key = watcher.take();\n              } catch(interuptedException x) {\n		return;\n	}\n	for(WatchEvent<?> event : key.pollEvents()){\n	//do stuff\n	}','What do you get from a WatchService to indicate a deletion creation or modification','IO',0,0,NULL,5),(2836,'take() will wait and block forever until an event takes place. Will throw\nInteruptedException if interuped without taking an event. \n\npoll() returns null if an event is not imediately available. ','What are two ways to get a WatchKey ? \nand whats the difference between them ? ','IO',0,0,NULL,5),(2837,'does not compile countGold() cannot be called from a static context','public class Frodo etends Hobbit {\n	public static void main(SA) { \n		int mygold = 7;\n		sout(countGold(mygold,6));\n	}\n}\nclass Hobbit {\n	int countGold(int x, int y) { return x + y; }\n}','IO',0,0,NULL,5),(2838,'1) If two objects are equal, then they must have the same hash code.\n2) If two objects have the same hash code, they may or may not be equal. \n3) If two objects are not equal, they must NOT have the same hashcode\n','The contract between equals() and hashCode() is:','OOP',0,0,NULL,5),(2839,'shows all files and directories in /home/maxbisesi\n\nsqlexception if the path is not a valid path',' public static void main(String[] args){\n       Path dir = Paths.get(\"/home/maxbisesi\");\n       try(DirectoryStream<Path> stream = Files.newDirectoryStream(dir,\"*\");){\n            for(Path path : stream){\n               System.out.println(path);\n            }\n        } catch(IOException e){\n            System.out.println(\"SQLException\");\n            System.out.println(e);\n        }\n   }','IO',0,0,NULL,5),(2840,'x.a() thread1 x.a() in thread2\nx.b() thread1 x.b() in thread2\nx.b() thread1 y.b() in thread2\n\nthe same instance method of the same instance is blocked while a static\nmethod accross all methods is blocked. ','public class Hello {\n    synchronized void a() { actBusy(); }\n    static synchronized void b() { actBusy(); }\n    static void actBusy() {\n        try {\n            Thread.sleep(1000);\n            \n        } catch( InterruptedException e){}\n            \n        \n    }\n    public static void main(String[] args) {\n        final Hello x = new Hello();\n        final Hello y = new Hello();\n        \n        Runnable runnable = new Runnable() {\n            public void run() {\n                int option = (int) (Math.random() * 4);\n                switch(option) {\n                    case 0: x.a(); break;\n                    case 1: x.b(); break;\n                    case 2: y.a(); break;\n                    case 3: y.b(); break;\n                }\n            }\n        };\n        \n        Thread t1 = new Thread(runnable);\n        Thread t2 = new Thread(runnable);\n        \n        t1.start();\n        t2.start();\n    \n    }\n\n}  \n\nwhich methods could never be running at the same time ?','Threads',0,0,NULL,5),(2841,'got it ','Method forwarding relies on Has-a relationships','OOP',0,0,NULL,5),(2842,'method forwarding\n\nan object composition principle that calles methods on an instance variable of an object','class Animal implements Burriable {\n    private Integer size;\n    private String name;\n    \n    public Animal(int x, String y){\n        size = x;\n        name = y;\n    }\n    public Animal(){\n        size = 0;\n        name = \"\";\n    }\n\n    public int getSize() {\n        return size;\n    }\n\n    public String getName() {\n        return name;\n    }\n    \n    public void bury(){\n        System.out.println(\"just toss him in there...\");\n    }\n    public void digUp(){\n        System.out.println(\"Hang on this ones still kickin !\");\n    }\n    public void pray(){\n        System.out.println(\"...Lord forgive us for what we have done, hes only been gone for \"+YEARSDEAD+\" years.\");\n    }\n}\n\nclass Dog implements Burriable{\n    private Animal animal;\n    public Dog(Animal a){\n        animal = a;\n    }\n    \n    public void bury(){\n        animal.bury();\n    }\n    public void digUp(){\n        animal.digUp();\n    }\n    public void pray(){\n        animal.pray();\n    }\n    \n    public String yelpForHelp(){\n        return \"ar ar arrr....\";\n    }\n}\n\ninterface Burriable {\n    int YEARSDEAD = 1;\n    void bury();\n    void digUp();\n    void pray();\n}\n\nwhat OOP principle is this ?','OOP',0,0,NULL,5),(2843,'The singleton pattern is identifiable bby the static variable for the single instance and the accessor returning it. ','public class F {\n	private static final F f = new F();\n	public static F c(){\n		return f;\n	}\n\n	public void update(F a) { }\n	\n	public void delete(F a) { }\n\n}\nwhat design pattern is this ? ','OOP',0,0,NULL,5),(2844,'object composition, you can tell because of the method forwarding. \nSingleton is tempting but the getInstance method here returns a NEW instance\ninstead a single private static one like it should to be singleton. ','public class E {\n	private D d;\n	public void m() {\n		d.m();\n	}\n\n		public static E getInstance() {\n			return new E();\n		}\n}\n\nclass D {\n	public void m() { }\n}\n\nwhat design pattern principle is this ?\n','OOP',0,0,NULL,5),(2845,'Factory,\n\nClass A is the object we are creating using the factory method. class G\nis the abstract superclass for the factory. Not shown is a class implementing \nclass G that actually creates the object. ','class A {}\n\nabstract class G {\n	A m() { return n(); }\n	abstract A n();\n}\n\nwhat principle is demostrated','OOP',0,0,NULL,5),(2846,'Reuse The DAO pattern centralize logic for the data access code making reuse\neasier and allowing you to switch out implementations. ','which is a benefit of the DAO pattern ?	','OOP',0,0,NULL,5),(2847,'regular files, hidden files, and subdirectories','public void print(Path d) throws IOException {\n	try(DirectoryStream<Path> stream = Files.newDirectoryStream(d)){\n		for(Path path: stream){\n			sout( path.getFileName() );\n		}\n	}\n}\n\nwhat files will this display ? ','IO',0,0,NULL,5),(2848,'The first time the file will be created and copied normally the second time you\nwill get a file already exists excpeiotn','public class Hello {\n    public static void main(String[] dicks) throws IOException{\n      Path src = Paths.get(\"/home/maxbisesi/Documents/copy.txt\");\n      Files.createFile(src);\n      \n      Files.copy(src, Paths.get(\"/home/maxbisesi/Documents/newcopy.txt\"));\n      \n    }\n\n}\n\nwhat happens if this is ran twice and all preivous files dont exist before','IO',0,0,NULL,5),(2849,'Compilation fails, to compile would have to be \n\n	Object item = list.get(0);','public class Hello {\n    public static void main(String[] dicks){\n        ArrayList list = new ArrayList();\n        \n        list.add(\"java\");\n        list.add(\"sucks\");\n        \n        String item = list.get(0);\n\n    }\n\n}','Collections',0,0,NULL,5),(2850,'Will not compile, there is no scope there \n\nif(true){\n	int b = 1;\n} \n	this would though !','if(true)\n       int b = 1;\n        ','General',0,0,NULL,5),(2851,'CooLooLCuuL\n\n* is the greedy quantifier, it takes as much as it can. ','public class Hello {\n    public static void main(String[] dicks){\n        Pattern p = Pattern.compile(\"C.*L\");\n        Matcher m = p.matcher(\"CooLooLCuuLooC\");\n        \n        while(m.find())\n            System.out.println(m.group());\n\n    }\n\n}','Strings',0,0,NULL,5),(2852,'False it gets the same priority as the thread that created it ','If a thread\'s priority is not specified explicitly then it gets\nNORM_PRIORITY\n\nT or F ','Threads',0,0,NULL,5),(2853,'Will not compile, method eat in class animal cannot be applied to given types','public class Hello {\n    public static void main(String[] dicks){\n        Animal ah2 = new Horse();\n        ah2.eat(\"carrots\");\n    }\n\n}\n\nclass Animal{\n    public void eat(){ }\n}\n\nclass Horse extends Animal {\n    public void eat() { }\n    public void eat(String s ){ } \n}\n    ','General',0,0,NULL,5),(2854,'Horse','public class Hello {\n    public static void main(String[] dicks){\n        Animal ah2 = new Horse();\n        ah2.eat();\n    }\n\n}\n\nclass Animal{\n    public void eat(){ System.out.println(\"Animal\"); }\n}\n\nclass Horse extends Animal {\n    public void eat(){ System.out.println(\"Horse\");} \n}\n\n','General',0,0,NULL,5),(2855,'will not compile overriden method \ncannot throw new or broader checked exceptions','public class Hello {\n    public static void main(String[] dicks){\n        Animal ah2 = new Horse();\n        ah2.eat();\n    }\n\n}\n\nclass Animal{\n    public void eat(){ System.out.println(\"Animal\"); }\n}\n\nclass Horse extends Animal {\n    public void eat() throws IOException{ System.out.println(\"Horse\");} \n}','General',0,0,NULL,5),(2856,'Animal\n\neat in horse is an overload, it still inherits Animals eat()','public class Hello {\n    public static void main(String[] dicks){\n        Animal ah2 = new Horse();\n        ah2.eat();\n    }\n\n}\n\nclass Animal{\n    public void eat(){ System.out.println(\"Animal\"); }\n}\n\nclass Horse extends Animal {\n    public void eat(int x) throws IOException{ System.out.println(\"Horse\");} \n}','General',0,0,NULL,5),(2857,'SQLException\n	Statement objects do not support multiple open ResultSets.\n	\n	Only a single ResultSet can be opened from the same statement object\n\n	*if the same statement object is executed more than once the previous\n	ResultSet is closed automatically\n		\n		... and attempting to access a closed RS is a SQLException','//assume valid Connection cn, and good database connection\n\nString query = \"Select * from Answer\";\ntry(Statement stmt = cn.createStatement()){\n	ResultSet rs1 = stmt.executeQuery(query);\n	stmt.executeQuery(\"select * from Question\");\n	while(rs1.next(){\n		sout(rs1.getInt(\"fk_question_num\");\n	}\n} catch(SQLException e){\n	\n}','JDBC',0,0,NULL,5),(2858,'','','blank',0,0,NULL,5),(2859,'SQLException , attempting to execute a query without setting a parameter\nresults in an SQLException\n\n	should be>>>\n		\n		pstmt.setString(1,\"dick\");\n\nIndexing starts at 1','try(Connection conn = DriverManager.getConnection(url,user,pw)){\n	String pQuery = \"Select unitPrice From Book Where Title Like ?\";\n\n	PreparedStatement pstmt = conn.prepareStatement(pQuery);\n\n	ResultSet rs = pstmt.executeQuery();\n} catch(SQLException sq) {\n}\n','JDBC',0,0,NULL,5),(2860,'compiles and runs just fine ','public class Hello {\n    public static void main(String[] dicks){\n        try{\n            couldthrow();\n        } catch(IOException | SQLException e){\n            \n        }\n        \n    }\n    \n    public static void couldthrow() throws IOException, SQLException{\n        \n    }\n\n}','Exceptions',0,0,NULL,5),(2861,'instanceof test','public boolean equals(Object o) { \n	if(((Moof)o).getMoofValue() == this.moofValue {\n		return true;\n	} else {\n		return false;\n	}\n}\n\nwhats missing here','Collections',0,0,NULL,5),(2862,'got it','equals() hashCode() and toString() are all PUBLIC','Collections',0,0,NULL,5),(2863,'for any reference value x, x.equals(x) should be true. ','equals() Contract\n\nreflexive	','Collections',0,0,NULL,5),(2864,'for any reference values x and y, \n\nx.equals(y) shoud be true if and only if \ny.equals(x) returns true. ','equals() contract,\n\nsymmetric','Collections',0,0,NULL,5),(2865,'reflxive, x.equals(x) is always true\n\nsymetric, x.equals(y) and y.equals(x)\n\ntransitive, if x.equals(y) and y.equals(z) then x.equals(z)\n\nconsistent, x.equals(y) is true no matter how many times you call it\n\nif x is non null, x.equals(null) is always false','what are the four tenants of the equals contract ?','Collections',0,0,NULL,5),(2866,'MUST also be equal.','if two objects are considered equal, their hashcodes...','Collections',0,0,NULL,5),(2867,'Yes just inefficient, all objects will go in the same bucket. The Collection\nwill search through a single big bucket using equal() to find the instance\nits looking for. In that case you defeat the purpose of using a hashed collection. ','Is it still legal to have a hashcode that always returns the same number ?','Collections',0,0,NULL,5),(2868,'When it is invoked on the same object more than once during an execution\nof a java application the hashcode() method must consistently return the \nsame integer \n\nIf two objects are equal according to the equals method, then calling hashchode)( \non each of the objects must produce the same integer\n\nunequal objects can still produce the same hashcodes \n\n*That means that equals and hashCode must work with same attributes somehow','HashCode contract:\n\n1\n\n2\n\n\n3','Collections',0,0,NULL,5),(2869,'x.hashcode() == y.hashcode()','x.equals(y) == true\n\nmeans what for hashcode()...','Collections',0,0,NULL,5),(2870,'x.equals(y) == false\n\nequals() and hashcode are like directions to get to a specific \nelement\n\nhashCode places all the elements in seperate but similiar buckets \nequals() gets the correct ones out.\n\nso if two elemets have different hashCodes they will be in different buckets\nanyway so hashCode is one level of precision and equals() is the next.','x.hashCode() != y.hashCode()	\n\nmeans what for equals()','Collections',0,0,NULL,5),(2871,'../..\nGenDir/genFile.txt\n','public static void main(String[] args){\n        Path p = Paths.get(\"/home/maxbisesi/Public/GenDir/genFile.txt\");\n        Path p2 = Paths.get(\"/home/maxbisesi/Public\");\n        \n        System.out.println(p.relativize(p2));\n        System.out.println(p2.relativize(p));  \n}','IO',0,0,NULL,5),(2872,'a Vector is the same as an ArrayList but Vector methods are synchronized\nfor thread safety. \n\nVector and Hashtable are the two original collections\n\nunless you really need thread safety choose ArrayList over Vector, \nthe synchronized methods give an unecssary performance hit. \n\n','Collections:\n\n	Vector\n','Collections',0,0,NULL,5),(2873,'is ordered by index position except that the elements are doubly linked to \none another. This linkage gives you new methods for adding and removing\nfrom the beginning or end.\n\nEasy choice for implementing a stack or queue. \n\nmay iterate more slowly than ArrayList but still a good choice when you need\nfast insertion and deletion.\n\nLinkedList supports peek(), poll(), offer(), Queue methods!!','Collections:\n\n	LinkedList','Collections',0,0,NULL,5),(2874,'Set','Which Interface disallows duplicates','Collections',0,0,NULL,5),(2875,'unsorted and unordered. Uses the hashcode of the object being inserted\n\nso the more effeicinet your hashcode the more effecient access youll get\n\nUse for a collection with no duplicates where you dont care about the\norder when you iterate through it.','Collections:\n	\n	HashSet','Collections',0,0,NULL,5),(2876,'\nMaintains a doubly linked list across elelemnts so the insertion order \nis maintained\n\nduplicates are still disallowed. ','Collections:\n\n	LinkedHashSet','Collections',0,0,NULL,5),(2877,'Sorted\n\nguarentees elements will be in ascending order according to natural order\n\n','Collections:\n\n	TreeSet','Collections',0,0,NULL,5),(2878,'compilation fails at the last three lines,\n\n1. multi catch syntax is | not ||\n\n2. objects declared in a try block are only available within the \ntry block so closing r is out of scope','public class Reader {\n	public void read(Path p, Charset s) {\n		try(BufferedReader r = Files.newBufferedReader(p,s)) {\n			try { r.read(); }\n			catch(IOException f) {\n				r.readLine();\n			}\n		} catch(IOException || NullPointerException e) {\n			r.close();\n		} finally {\n			r.close();\n		}\n	}\n}','IO',0,0,NULL,5),(2879,'unsorted and unordered Map. \n\nUse When you need a map and you don\'t care\nabout the order when you iterate through. \n\nThe basic map, other maps add a little more overhead. \n\nWhere keys land in the map is based on hashCode() \n\nHashMap allows one null key and multiple null values ','Collections:\n\n	HashMap','blank',0,0,NULL,5),(2880,'Hashtable is the synchronized counterpart to HashMap. \n\nWhile HashMap lets you have a null key and null values\n\nHashtable doesn\'t allow anything thats null!','Collections:\n	\n	Hashtable\n	','Collections',0,0,NULL,5),(2881,'True!\n\nHashtable doesn\'t allow anything null it will throw a npe','HashMap allows multiple null values','Collections',0,0,NULL,5),(2882,'FALSE\n\nThat would defeat the purpose of a \"key\"','HashMap allows multiple null keys','Collections',0,0,NULL,5),(2883,'FALSE\n\nunordered and unsorted','HashMap is sorted','Collections',0,0,NULL,5),(2884,'FALSE','HashMap is synchronized','Collections',0,0,NULL,5),(2885,'True!','Hashtable is synchronized ','Collections',0,0,NULL,5),(2886,'FALSE, nothing can be null in Hashtable','Hashtable allows multiple null values and one null key','blank',0,0,NULL,5),(2887,'since list is declared as anything that extends Animal you cant be sure that it\nwill be the right type to pass into the next method that taks <Animal>\n\nWill not compile','public static ArrayList<Animal> staggerSort(ArrayList<? extends Animal> list){\n        Map<String,List<Number>> byCategory = seperateToCategories(list);\n        return null;\n    }\n    \n    static Map<String,List<Number>> seperateToCategories(ArrayList<Animal> list){\n        return null;\n    }','Generics',0,0,NULL,5),(2888,'big Bucks\nsweet Cheeks\n\nbig Bucks replaced big Country in the map, LinkedHashMaps maintain insertion\norder. \n\nso that mapping was simply replaced but it kept its position','public static void main(String[] args){\n        LinkedHashMap<String,String> lhm = new LinkedHashMap<>();\n        lhm.put(\"big\",\"Country\");\n        lhm.put(\"sweet\",\"Cheeks\");\n        lhm.put(\"big\",\"Bucks\");\n        \n        for(Map.Entry<String,String> entry: lhm.entrySet()){\n            System.out.println(entry.getKey()+\" \"+entry.getValue());\n        }\n        \n    }','Collections',0,0,NULL,5),(2889,'WNC,\n\ngo() declares that it throws a checked exceptions so it has to be handled\nor thrown in main.\n\nif that would have compiled an IOException would be thrown so it would\nprint got io error done. ','class Gutsy {\n	public static void main(String[] args){\n		new Gutsy().go();\n	}\n	void go() throws IOException {\n	String row;\n	try {\n		FileReader fr = new FileReader(\"TestFile.txt\");\n		BufferedReader br = new BufferedReader(fr);\n		while((row = br.readLine() ) != null)\n			sout( row );\n	} catch(IOException e) {\n		sout(\"got io error\");\n	} finally {\n		sout( \"done\" );\n	}\n   }\n}','Exceptions',0,0,NULL,5),(2890,'-6 through 4','Given a properly prepared string[] with five elements what is the range \nof possible results that could be returned by Arrays.binarySearch() ? ','Collections',0,0,NULL,5),(2891,'sorted Map\n\nsorted by natural order or custom comparison rules.','TreeMap','blank',0,0,NULL,5),(2892,'3\nfalse\ntrue\n2','List<String> test = new ArrrayList<String>();\nString s = \"hi\";\ntest.add(\"string\");\ntest.add(s);\ntest.add(s+s);\nsout( test.size() );\nsout( test.contains(42) );\nsout( test.contains(\"hihi\") );\ntest.remove(\"hi\");\nsout( test.size() );','Collections',0,0,NULL,5),(2893,'These two are the same, the first demonstrates autoboxing. ','List myInts = new ArrayList();\n        myInts.add(4);\n        \n        myInts.add(new Integer(4));','blank',0,0,NULL,5),(2894,'NullPointerException','class Boxing2 {\n	static Integer x;\n	psvm(sa) {\n		doStuff(x);\n	}\n\n	static void doStuff(int z) {\n		int z2 = 5;\n		sout( z2 + z );\n	}\n}','General',0,0,NULL,5),(2895,'unsorted: [CZ, a, AB, CE, CZ, cz, BA, BF, ABC, CE,  CE, A, ce, A B, AA,  Z]\nsorted: [ CE,  Z, A, A B, AA, AB, ABC, BA, BF, CE, CE, CZ, CZ, a, ce, cz]\n\nspaces come first, as shown by A B and AA. Also capitals come before lowercase','public static void main(String[] dicks){\n        ArrayList<String> list = new ArrayList<>();\n        \n        list.add(\"CZ\");\n        list.add(\"a\");\n        list.add(\"AB\");\n        list.add(\"CE\");\n        list.add(\"CZ\");\n        list.add(\"cz\");\n        list.add(\"BA\");\n        list.add(\"BF\");\n        list.add(\"ABC\");\n        list.add(\"CE\");\n        list.add(\" CE\");\n        list.add(\"A\");\n        list.add(\"ce\");\n        list.add(\"A B\");\n        list.add(\"AA\");\n        list.add(\" Z\");\n        \n        System.out.println(\"unsorted: \"+list);\n        Collections.sort(list);\n        System.out.println(\"sorted: \"+list);','Collections',0,0,NULL,5),(2896,'Will not compile, Horse does not implement Comparable','public class Hello {\n    public static void main(String[] dicks){\n        List<Horse> stable = new ArrayList<>();\n        \n        for(int x =0; x < 10; x++){\n            stable.add(new Horse());\n        }\n        \n        Collections.sort(stable);\n        \n    }\n\n}\n\nclass Horse {\n    public boolean equals(Horse s){\n        return false;\n    }\n}','Collections',0,0,NULL,5),(2897,'will not compile, compareTo is public ','class Horse implements Comparable<Horse> {\n    public boolean equals(Horse s){\n        return false;\n    }\n    \n    int compareTo(Horse h){\n        \n    }\n    \n    \n}','Collections',0,0,NULL,5),(2898,'compiles fine!','public class Hello {\n    public static void main(String[] dicks){\n        List<Horse> stable = new ArrayList<>();\n        \n        for(int x =0; x < 10; x++){\n            stable.add(new Horse(\"lucky\"+x));\n        }\n        \n        Collections.sort(stable);\n        \n    }\n\n}\n\nclass Horse implements Comparable<Horse> {\n    String name;\n    \n    public Horse(String x){\n        name = x;\n    }\n    \n    public String getName(){\n        return name;\n    }\n    \n    public boolean equals(Horse s){\n        return false;\n    }\n    \n    public int compareTo(Horse h){\n        return name.compareTo(h.getName());\n        \n    }\n    \n    \n}','Collections',0,0,NULL,5),(2899,'Object','When you override equals() you must take an argument of what type ?','Collections',0,0,NULL,5),(2900,'The type your sorting.\n\n\npublic interface Comparable<T>\n\n...type T','When you override compareTo() you must take an argument of type?','Collections',0,0,NULL,5),(2901,'This is still legal but painful, genereics make this easier but it will still \ncompile','class DVDInfo implements Comparable {\n	public int comparteTo(Object o) {\n		DVDInfo d = (DVDInfo) o;\n		return title.compareTo(d.getTitle() );\n	}\n}','Collections',0,0,NULL,5),(2902,'compare()\n\ncompareTo()','Comparator has _________________\n\nComparable has _________________','Collections',0,0,NULL,5),(2903,'Comparator','Which soritng interface do you implement to create individual sorting classes\n	','Collections',0,0,NULL,5),(2904,'will not compile the method is:\n\n	int compare(T o1, T o2)','class Dicksorter implements Comparator<Dicks> {\n	public int compareTo(Dick one) {\n	}\n}','Collections',0,0,NULL,5),(2905,'compiles fine, this takes advvantage of integer comparison','class DickSorter implements Comparator<Dick> {\n	public int compare(Dick one, Dick two){\n		return one.getSize().compareTo(two.getSize());\n	}\n}','Collections',0,0,NULL,5),(2906,'Will not compile\n\ntoArray() in List interface returns an Object[]','public class Hello {\n    public static void main(String[] dicks){\n        List<Horse> stable = new ArrayList<>();\n        \n        stable.add(new Horse(\"Honey\"));\n        stable.add(new Horse(\"Mighty Mikey\"));\n        stable.add( new Horse(\"The Fastest Stud in the Mud\"));\n        stable.add( new Horse(\"Churchill\"));\n        \n        Horse[] ranch = stable.toArray();\n\n    }\n\n}','Collections',0,0,NULL,5),(2907,'ClassCastException, \"johny\" cant be turned into a horse\n\nshould be Arrays.binarySearch(stable,new Horse(\"Johny\"));','public class Hello {\n    public static void main(String[] dicks){\n        Horse[] stable = {new Horse(\"Johny\"), new Horse(\"wilfred\"), new Horse(\"Marco\"), new Horse(\"MAx\"), new Horse(\"Billy\") };\n        \n        int x = Arrays.binarySearch(stable,\"Johny\");\n        System.out.println(x);  \n\n    }\n\n}','Collections',0,0,NULL,5),(2908,'The results are undefined, the array is not sorted. ','public class Hello {\n    public static void main(String[] dicks){\n        Horse[] stable = {new Horse(\"Johny\"), new Horse(\"wilfred\"), new Horse(\"Marco\"), new Horse(\"MAx\"), new Horse(\"Billy\") };\n        \n        int x = Arrays.binarySearch(stable,new Horse(\"Johny\"));\n        System.out.println(x);  \n\n    }\n\n}    \n\nclass Horse implements Comparable<Horse> {\n    String name;\n    \n    public Horse(String x){\n        name = x;\n    }\n    \n    public String getName(){\n        return name;\n    }\n    \n    public boolean equals(Horse s){\n        return false;\n    }\n    \n    public int compareTo(Horse h){\n        return name.compareTo(h.getName());\n        \n    }\n    \n    \n    ','Collections',0,0,NULL,5),(2909,'ClassCastException Horse cannot be converted to Comparable\n\nbinarySearch uses comparable to search the Array.\n\nThis search would give inconsistant results anyways because \nthe array was not sorted first. \n\nto fix add this:\n\nclass Horse implements Comparable<Horse> {\n    String name;\n    \n    public Horse(String x){\n        name = x;\n    }\n    \n    public String getName(){\n        return name;\n    }\n    \n    public boolean equals(Horse s){\n        return false;\n    }\n    \n    public int compareTo(Horse s){\n        return name.compareTo(s.getName());\n    }\n    \n}\n\n-if an array is sorted in natrual order it must searched in natural order \n-if it is sorted using a comparator it must be searched using the same comparator.\n','public class Hello {\n    public static void main(String[] dicks){\n        Horse[] stable = {new Horse(\"Johny\"), new Horse(\"wilfred\"), new Horse(\"Marco\"), new Horse(\"MAx\"), new Horse(\"Billy\") };\n        \n        \n        int x = Arrays.binarySearch(stable,new Horse(\"Marco\"));\n        System.out.println(x);  \n\n    }\n\n}\n\nclass Horse {\n    String name;\n    \n    public Horse(String x){\n        name = x;\n    }\n    \n    public String getName(){\n        return name;\n    }\n    \n    public boolean equals(Horse s){\n        return false;\n    }\n    \n}','Collections',0,0,NULL,5),(2910,'Will not compile, if the untyped version of Comparable is used then\nthe parameter to compareTo would be Object\n\neither change to Comparable<Horse>\n\nor \n\ncomparTo(Object o) and cast.\n\notherwise, the answer would be 2 remember arrays aren\'t sorted even though\nyour using comparable the elements of an array dont get sorted so the positions are \nwhat index they were defined as !\n\nThis would give undefined results','public class Hello {\n    public static void main(String[] dicks){\n        Horse[] stable = {new Horse(\"Johny\"), new Horse(\"wilfred\"), new Horse(\"Marco\"), new Horse(\"MAx\"), new Horse(\"Billy\") };\n        int x = Arrays.binarySearch(stable,new Horse(\"Marco\"));\n        System.out.println(x);  \n    }\n}\n\nclass Horse implements Comparable{\n    String name;\n    public Horse(String x){\n        name = x;\n    }\n    public String getName(){\n        return name;\n    }\n    public boolean equals(Horse s){\n        return false;\n    }\n    public int compareTo(Horse h){\n        return name.compareTo(h.getName());  \n    }\n}\n','Collections',0,0,NULL,5),(2911,'binarySearch()\n\nreturns the int index of the element being searched.\n\nUnsuccesful searches return an int index that represents the\n insertion point. \n\nThe collection or array must be sorted before you can search it.\n\nif you attempt to search an unsorted array or collection the results of the\nsearch will be unpredictable.\n\nIf it was sorted in natural order it must searched in natural order.\n	do this by NOT sending a Comparator as an argument to the binarySearch() \n\nIf it was sorted with a comparator it must be searched using the same comparator\n\n	\n	','What method is used to search through Arrays and Collections','Collections',0,0,NULL,5),(2912,'will not compile, need to cast\n\nreturn name.compareTo(((Horse)h).getName());\n\ndoes not compile because h is an Object and Objects dont have a method\ncalled getName. \n\nyou would cast h to a horse. \n\nObject is the right argument type here though because Comparable is a raw type\nif it were Comparable<Horse> the argument would need to be Horse.','class Horse implements Comparable{\n    String name;\n    \n    public Horse(String x){\n        name = x;\n    }\n    \n    public String getName(){\n        return name;\n    }\n    \n    public boolean equals(Horse s){\n        return false;\n    }\n    \n    public int compareTo(Object h){\n        return name.compareTo(h.getName());\n  \n    }','Collections',0,0,NULL,5),(2913,'these all compile fine, \n\nPolymorphism works with Arrays. ','public class Hello {\n    public static void main(String[] dicks){\n       Animal[] beavers = new Beaver[5];\n       \n       Animal[] animals = {new Beaver(), new Beaver(), new Beaver() };\n       \n       Animal[] ans2 = new Animal[5];\n       ans2[0] = new Beaver();\n\n    }\n}\n\nclass Animal{\n    public Animal(){\n        \n    }\n    \n    public String getName(){\n        return \"d\";\n    }\n}\n\nclass Beaver extends Animal{\n    \n}','Collections',0,0,NULL,5),(2914,'2\n0','public class Hello {\n    public static void main(String[] dicks){\n       \n        String[] strings = {\"One\",\"Dice\",\"Angela\",\"Bisesi\",\"Franko\"};\n        \n        Arrays.sort(strings);\n        int x = Arrays.binarySearch(strings,\"Dice\");\n        System.out.println(x);  \n        \n        Arrays.sort(strings);\n        \n        System.out.println(Arrays.binarySearch(strings,\"Angela\"));\n    }\n\n}','Collections',0,0,NULL,5),(2915,'compare must be public, will not compile','class sortBySecondLetter implements Comparator<String> {\n    int compare(String one, String two){\n        \n    }\n}','Collections',0,0,NULL,5),(2916,'will not compile, char is a primitive so charone cannot be dereferenced here\nchange to Character.','class sortBySecondLetter implements Comparator<String> {\n    public int compare(String one, String two){\n        char charone = one.charAt(1);\n        char chartwo = two.charAt(1);\n        \n        return charone.compareTo(chartwo);\n    }\n}','Collections',0,0,NULL,5),(2917,'[Ljava.lang.String;@15db9742\n\narrays are not classes','public class Hello {\n    public static void main(String[] dicks){\n        sortBySecondLetter sbsl = new sortBySecondLetter();\n        String[] strings = {\"One\",\"Dice\",\"Angela\",\"Bisesi\",\"Franko\"};\n        \n        Arrays.sort(strings,sbsl);\n        \n        System.out.println(strings);\n    }\n\n}','Collections',0,1,NULL,5),(2918,'size 4\nidx2 three\none \nfive \nthree \nsix \ns1[1] five','String[] sa = {\"one\", \"two\", \"three\", \"four\" };\nList sList = Arrays.asList(sa);\n\nSout( \"size \" + sList.size() );\nsout( \"idx2 \" + sList.get(2) );\n\nsList.set(3,\"six\" );\nsa[1] = \"five\";\n\nfor(String s : sa ){\n	sout( s + \" \");\n}\nsout(\"\\n s1[1] \" + sList.get(1) );','Collections',0,0,NULL,5),(2919,'UnsupportedOperationException\n\nThis UnsupportedOperationException comes when you try to perform some operation on collection where its not \nallowed and in your case, When you call Arrays.asList it \ndoes not return a java.util.ArrayList. It returns a java.util.Arrays$ArrayList which is an immutable list. \nYou cannot add to it and you cannot remove from it.\n\nReturns a {@code List} of the objects in the specified array. The size of the {@code List} cannot be modified, i.e. adding and removing are unsupported, but the elements can be set. Setting an element modifies the underlying array.\n\nEDIT\n\nThe type of the resulting list is Arrays.ArrayList, which is a private class inside Arrays.class. Practically speaking,\nit is nothing but a List-view on the array that you\'ve passed with Arrays.asList. With a consequence: if you change the array, the list is changed too. And because an array is not resizeable, \nremove and add operation must be unsupported.\n','public class Hello {\n    public static void main(String[] args){\n        String[] sa = {\"one\", \"two\", \"three\", \"four\" };\n        List sList = Arrays.asList(sa);\n\n        System.out.println( \"size \" + sList.size() );\n        System.out.println( \"idx2 \" + sList.get(2) );\n\n        sList.set(3,\"six\" );\n        sa[1] = \"five\";\n\n        for(String s : sa ){\n            System.out.println( s + \" \");\n        }\n        System.out.println(\"s1[1] \" + sList.get(1) );\n        \n        sList.remove(\"five\");\n        for(String s : sa)\n            System.out.println(s+\" \");\n    }\n\n}','Collections',0,0,NULL,5),(2920,'size 4\nidx2 three\none \nfive \nthree \nsix \ns1[1] five\none \nFIVE \nthree \nSIX\n\nThis shows that Arrays and Lists coming from\nArrays.asList() are \"joined at the hip\" changes in one affect \nthe other. This is different from a \"Backed Collection\". Because \nBacked Collections dont go both ways and are only backed for a certain range.','String[] sa = {\"one\", \"two\", \"three\", \"four\" };\n        List sList = Arrays.asList(sa);\n\n        System.out.println( \"size \" + sList.size() );\n        System.out.println( \"idx2 \" + sList.get(2) );\n\n        sList.set(3,\"six\" );\n        sa[1] = \"five\";\n\n        for(String s : sa ){\n            System.out.println( s + \" \");\n        }\n        System.out.println(\"s1[1] \" + sList.get(1) );\n        \n        sList.set(1, \"FIVE\");\n	sList.set(3,\"SIX);\n        for(String s : sa)\n            System.out.println(s+\" \");','Collections',0,0,NULL,5),(2921,'unsupported operation exception, \n\nList returned by asList is fixed size can only be updated not added to or removed from','public static void main(String[] dicks){\n        String[] sa = {\"one\", \"two\", \"three\", \"four\" };\n        List sList = Arrays.asList(sa);\n\n        System.out.println( \"size \" + sList.size() );\n        System.out.println( \"idx2 \" + sList.get(2) );\n\n        sList.set(3,\"six\" );\n        sa[1] = \"five\";\n\n        for(String s : sa ){\n            System.out.println( s + \" \");\n        }\n        System.out.println(\"s1[1] \" + sList.get(1) );\n        \n        sList.set(1, \"FIVE\");\n        sList.set(3,\"SIX\");\n        sList.add(\"SEVEN\");\n        for(String s : sa)\n            System.out.println(s+\" \");','Collections',0,0,NULL,5),(2922,'will not compile, toArray( T[] a) will return an array of the type you send\nto it. so here an Object[] cannot be assigned to an Integer[].\n\nto fix:\n	change oa to ia2 which will cause toArray to return an Integer[]',' public static void main(String[] dicks){\n        List<Integer> iL = new ArrayList<Integer>();\n        for(int x=0; x<3; x++){\n                iL.add(x);\n        }\n        Object[] oa = iL.toArray();\n        Integer[] ia2 = new Integer[3];\n        ia2 = iL.toArray(oa);\n    }','Collections',0,0,NULL,5),(2923,'0\n1\n2\n3\n4\n','public static void main(String[] dicks){\n        List<Integer> iL = new ArrayList<Integer>();\n        for(int x=0; x<5; x++){\n                iL.add(x);\n        }\n        Object[] oa = iL.toArray();\n        Integer[] ia2 = new Integer[3];\n        ia2 = iL.toArray(ia2);\n        \n        for(Integer i : ia2){\n            System.out.println(i);\n        }     \n    }','Collections',0,0,NULL,5),(2924,'0\n1\n2\n3\n4\n0\n1\n2\n3\n4','public static void main(String[] dicks){\n        List<Integer> iL = new ArrayList<Integer>();\n        for(int x=0; x<5; x++){\n                iL.add(x);\n        }\n        Object[] oa = iL.toArray();\n        Integer[] ia2 = new Integer[3];\n        ia2 = iL.toArray(ia2);\n        \n        for(Integer i : ia2){\n            System.out.println(i);\n        }\n        \n        iL.add(100);\n        \n        for(Integer i : ia2)\n            System.out.println(i);\n       \n    }','Collections',0,0,NULL,5),(2925,'will not compile, \n\n.toArray() returns an Object[]',' public static void main(String[] dicks){\n        List<Integer> iL = new ArrayList<Integer>();\n        for(int x=0; x<5; x++){\n                iL.add(x);\n        }\n        Integer[] oa = iL.toArray();     \n    }','Collections',0,0,NULL,5),(2926,'unpredictable result, the array is not sorted before being searched. ','class HDTV implements Comparable<HDTV> {\n	private int size;\n	private String brand;\n        private int resolution;\n \n	public HDTV(int size, String brand, int res) {\n		this.size = size;\n		this.brand = brand;\n                this.resolution = res;\n	}\n \n	public int getSize() {\n		return size;\n	}\n        \n        public int getRes() {\n            return resolution;\n        }\n \n	public void setSize(int size) {\n		this.size = size;\n	}\n \n	public String getBrand() {\n		return brand;\n	}\n \n	public void setBrand(String brand) {\n		this.brand = brand;\n	}\n \n	@Override\n	public int compareTo(HDTV tv) {\n \n		if (this.getSize() > tv.getSize())\n			return 1;\n		else if (this.getSize() < tv.getSize())\n			return -1;\n		else\n			return 0;\n	}\n        \n        public String toString(){\n            return brand;\n        }\n}\n\npublic class Hello {\n    public static void main(String[] dicks){\n        compareTVs();\n    }\n    \n     \n    public static void compareTVs() {\n		HDTV tv1 = new HDTV(55, \"Samsung\", 6000);\n		HDTV tv2 = new HDTV(60, \"Sony\", 4500);\n                HDTV tv3 = new HDTV(70, \"MEGATV\", 10000);\n                HDTV tv4 = new HDTV(15,\"kitchenette\", 600);\n\n                HDTV[] array = {tv2, tv1, tv3, tv4 };\n                \n                System.out.println(Arrays.binarySearch(array,new HDTV(700,\"Samsung\",400)));\n                \n	}\n\n}','Collections',0,0,NULL,5),(2927,'will not compile \n\nArrayList.addAll doesn\'t work like that, it takes another collection\nthen adds all the elements from one to another. ','public static void main(String[] dicks){\n        List<HDTV> tvs = new ArrayList<>();\n        HDTV tv1 = new HDTV(55, \"Samsung\", 6000);\n        HDTV tv2 = new HDTV(60, \"Sony\", 4500);\n        HDTV tv3 = new HDTV(70, \"MEGATV\", 10000);\n        HDTV tv4 = new HDTV(15,\"kitchenette\", 600);\n        tvs.addAll(tv1,tv2,tv3,tv4);\n    }','Collections',0,0,NULL,5),(2928,'Samsung\nSony\nMEGATV\nkitchenette\n\nthis shows proper use of an iterator','public static void main(String[] dicks){\n        List<HDTV> tvs = new ArrayList<>();\n        \n        HDTV tv1 = new HDTV(55, \"Samsung\", 6000);\n        HDTV tv2 = new HDTV(60, \"Sony\", 4500);\n        HDTV tv3 = new HDTV(70, \"MEGATV\", 10000);\n        HDTV tv4 = new HDTV(15,\"kitchenette\", 600);\n        \n        tvs.add(tv1);\n        tvs.add(tv2);\n        tvs.add(tv3);\n        tvs.add(tv4);\n        \n        Iterator<HDTV> i3 = tvs.iterator();\n        \n        while(i3.hasNext()){\n            HDTV t3 = i3.next();\n            System.out.println(t3.getBrand());\n        }\n        \n        \n    }','Collections',0,0,NULL,5),(2929,'If the iterator isn\'t typed then the elements returned by Iterator will be \nObjects so to make this compile, \n\nyou would have to cast\n\n	(HDTV) i3.next();','public static void main(String[] dicks){\n        List<HDTV> tvs = new ArrayList<>();\n        \n        HDTV tv1 = new HDTV(55, \"Samsung\", 6000);\n        HDTV tv2 = new HDTV(60, \"Sony\", 4500);\n        HDTV tv3 = new HDTV(70, \"MEGATV\", 10000);\n        HDTV tv4 = new HDTV(15,\"kitchenette\", 600);\n        \n        tvs.add(tv1);\n        tvs.add(tv2);\n        tvs.add(tv3);\n        tvs.add(tv4);\n        \n        Iterator i3 = tvs.iterator();\n        \n        while(i3.hasNext()){\n            HDTV t3 = i3.next();\n            System.out.println(t3.getBrand());\n        }\n        \n        \n    }','Collections',0,0,NULL,5),(2930,'none fail both of those are fine. ','  public static void main(String[] dicks){\n        List<HDTV> tvs = new ArrayList<>();\n        \n        HDTV tv1 = new HDTV(55, \"Samsung\", 6000);\n        HDTV tv2 = new HDTV(60, \"Sony\", 4500);\n        HDTV tv3 = new HDTV(70, \"MEGATV\", 10000);\n        HDTV tv4 = new HDTV(15,\"kitchenette\", 600);\n        \n        tvs.add(tv1);\n        tvs.add(tv2);\n        tvs.add(tv3);\n        tvs.add(tv4);\n        \n        HDTV[] tv = new HDTV[5];\n        HDTV[] hv = tvs.toArray(tv); //line 1\n        Object[] tvobjs = tvs.toArray(); //line 2\n        \n   \n    }\n\nwhich line would fail if any ?','Collections',0,0,NULL,5),(2931,'true\ntrue\ntrue\ntrue\nfalse\n4\n5\n7\n9\n\nSets dont allow duplicates and the iteration order is not predictable','public static void main(String[] dicks){\n      Set s = new HashSet();\n      \n        System.out.println(s.add(4));\n        System.out.println(s.add(9));\n        System.out.println(s.add(5));\n        System.out.println(s.add(\"7\"));\n        System.out.println(s.add(4));\n        \n        for(Object o : s)\n            System.out.println(o);\n\n    }','Collections',0,0,NULL,5),(2932,'ClassCastException\n \nTreeSets are sorted and all these elements aren\'t mutually comparabble','public static void main(String[] dicks){\n      Set s = new TreeSet();\n      \n        System.out.println(s.add(4));\n        System.out.println(s.add(9));\n        System.out.println(s.add(5));\n        System.out.println(s.add(\"7\"));\n        System.out.println(s.add(4));\n        \n        for(Object o : s)\n            System.out.println(o);\n\n    }','Collections',0,0,NULL,5),(2933,'Charly,\n\nhere strings are used as keys and they override hashcode() and equals()\nso it can be used ','class Dog {\n    public String name;\n    public Dog(String n) { name = n; }\n    \n    public String toString(){\n        return name;\n    }\n}\n\npublic class Hello {\n\n    public static void main(String[] dicks){\n      Map<Object,Object> map = new HashMap<>();\n      \n      map.put(\"d1\",new Dog(\"Charly\"));\n      map.put(\"d2\", new Dog(\"dumbfuck\"));\n      \n        System.out.println(map.get(\"d1\"));\n    }\n}','Collections',0,0,NULL,5),(2934,'null \n\nthe map cannot find the values bcause the keys dont have equals or hashcode methods.','class Dog {\n    public String name;\n    public Dog(String n) { name = n; }\n    \n    public String toString(){\n        return name;\n    }\n\n    public static void main(String[] dicks){\n      Map<Object,Object> map = new HashMap<>();\n      \n      map.put(new Dog(\"Bell\"),\"Big brown lab\");\n      map.put(new Dog(\"Sable\"), \"small schiperkee\");\n      \n        System.out.println(map.get(new Dog(\"Bell\")));\n    }\n\n}\n\n','Collections',0,0,NULL,5),(2935,'null\ncatdog\nDOG','class Dog {\n    enum Pets{DOG, CAT, SNAKE};\n    public String name;\n    public Dog(String n) { name = n; }\n    \n    public String toString(){\n        return name;\n    }\n\npublic static void main(String[] dicks){\n      \n      Map<Object,Object> map = new HashMap<>();\n      \n      map.put(new Dog(\"Bell\"),\"Big brown lab\");\n      map.put(new Dog(\"Sable\"), \"small schiperkee\");\n      map.put(Pets.CAT, new Dog(\"catdog\"));\n      map.put(\"Dog\", Pets.DOG);\n      \n        System.out.println(map.get(new Dog(\"Bell\")));\n        System.out.println(map.get(Pets.CAT));\n        System.out.println(map.get(\"Dog\"));\n    }\n}','Collections',0,0,NULL,5),(2936,'both are legal, the first will be slightly better\n\nthe more unique a hashcode the faste retrieval will be. ','public int hashCode() { return name.length(); }\npublic int hashCode() { return 4; }\n \nwhich will be faster ?\n','Collections',0,0,NULL,5),(2937,'12\n34\n45\n63','TreeSet<Integer> tree = new TreeSet<Integer>();\ntree.add(12);\ntree.add(63);\ntree.add(34);\ntree.add(45);\n \nIterator<Integer> iterator = tree.iterator();\nSystem.out.print(\"Tree set data: \");\nwhile (iterator.hasNext()) {\n    System.out.print(iterator.next() + \" \");\n}','Collections',0,0,NULL,5),(2938,'[1.8, 2.3, 2.2, 4.6, 8.9]\n-5\n\nthis comparator sorts in ascending order uless they have the same integer\nvalue','public class Hello {\n    \n    \n    public static void main(String[] dicks){\n      \n      List<Double> grades = new ArrayList<>();\n      grades.addAll(Arrays.asList( new Double[]{ 1.8, 4.6, 2.3, 8.9, 2.2 } ));\n      \n      Collections.sort(grades,new CusSort());\n      \n      System.out.println(grades);\n      \n        System.out.println(Collections.binarySearch(grades,4.2,new CusSort()));\n\n    }\n}\n    \n   class CusSort implements Comparator<Double> {\n       public int compare(Double d1, Double d2){\n           return d1.intValue() == d2.intValue() ? d2.compareTo(d1) : d1.compareTo(d2);\n           \n       }\n   }','Collections',0,0,NULL,5),(2939,'{a=ant, b=buffalo, h=horse} {b=buffalo}\n{R=raccoon, a=ant, b=bat, f=fish, h=horse} {b=bat, f=fish}','public class Hello {\n    \n    \n    public static void main(String[] dicks){\n      \n     TreeMap<String, String> map = new TreeMap<>();\n     map.put(\"a\",\"ant\"); map.put(\"b\",\"buffalo\"); map.put(\"h\",\"horse\");\n     \n     SortedMap<String, String> submap;\n     submap = map.subMap(\"b\",\"g\");\n     \n        System.out.println(map+\" \"+submap);\n        \n        map.put(\"b\",\"bat\");\n        \n        submap.put(\"f\",\"fish\");\n        \n        map.put(\"R\", \"raccoon\");\n        // submap.put(\"p\",\"pig\");\n        \n        System.out.println(map+\" \"+submap);\n    }\n}','Collections',0,0,NULL,5),(2940,'IllegalArgumnetException\n\np is out of range of the submap as first established with subMap(b g);\n\n','public class Hello {\n    \n    \n    public static void main(String[] dicks){\n      \n     TreeMap<String, String> map = new TreeMap<>();\n     map.put(\"a\",\"ant\"); map.put(\"b\",\"buffalo\"); map.put(\"h\",\"horse\");\n     \n     SortedMap<String, String> submap;\n     submap = map.subMap(\"b\",\"g\");\n     \n        System.out.println(map+\" \"+submap);\n        \n        map.put(\"b\",\"bat\");\n        \n        submap.put(\"f\",\"fish\");\n        \n        map.put(\"R\", \"raccoon\");\n        submap.put(\"p\",\"pig\");\n        \n        System.out.println(map+\" \"+submap);\n    }\n}','Collections',0,0,NULL,5),(2941,'will not compile, submap returns a SortedMap.','public class Hello {\n    \n    \n    public static void main(String[] dicks){\n      \n     TreeMap<String, String> map = new TreeMap<>();\n     map.put(\"a\",\"ant\"); map.put(\"b\",\"buffalo\"); map.put(\"h\",\"horse\"); map.put(\"j\",\"jackle\");\n     \n     TreeMap<String, String> submap;\n     submap = map.subMap(\"b\",\"g\");\n     \n     System.out.println(map+\" \"+submap);\n\n    }\n}','Collections',0,0,NULL,5),(2942,'AbstractMap<k,V>\nNavigableMap<K,V>','class TreeMap<k,v> extends  _____________\n implements  ____________','Collections',0,0,NULL,5),(2943,'{Beee=9, Ant=6, muskrat=20, Dog=7}\n\nwithout a provided comparator TreeMap sorts using Animals comparable\n\nwhich is to rank by size','public class Hello {\n    \n    \n    public static void main(String[] dicks){\n      \n     TreeMap<Animal, Integer> map = new TreeMap<>();\n     \n     map.put(new Animal(5,\"Ant\"), 6); map.put(new Animal(3,\"Beee\"),9); map.put(new Animal(25,\"Dog\"),7); map.put(new Animal(20,\"muskrat\"),20);\n     \n     System.out.println(map);\n     \n \n\n    }\n}\n\nclass sortAnimalsAlphabetically implements Comparator<Animal> {\n\n    @Override\n    public int compare(Animal o1, Animal o2) {\n        return o1.getName().compareTo(o2.getName());\n    }\n    \n}\n\nclass Animal implements Comparable<Animal> {\n    private Integer size;\n    private String name;\n    \n    public Animal(int x, String y){\n        size = x;\n        name = y;\n    }\n\n    public int getSize() {\n        return size;\n    }\n\n    public String getName() {\n        return name;\n    }\n    public int compareTo(Animal o){\n        return size.compareTo(o.getSize());\n        \n    }\n    \n    public String toString(){\n        return name;\n    }\n}','Collections',0,0,NULL,5),(2944,'{Ant=6, Beee=9, Dog=7, muskrat=20}\n\nsort using comparator','public class Hello {\n    \n    \n    public static void main(String[] dicks){\n      \n     TreeMap<Animal, Integer> map = new TreeMap<>(new sortAnimalsAlphabetically());\n     \n     map.put(new Animal(5,\"Ant\"), 6); map.put(new Animal(3,\"Beee\"),9); map.put(new Animal(25,\"Dog\"),7); map.put(new Animal(20,\"muskrat\"),20);\n     \n     System.out.println(map);\n     \n \n\n    }\n}\n\nclass sortAnimalsAlphabetically implements Comparator<Animal> {\n\n    @Override\n    public int compare(Animal o1, Animal o2) {\n        return o1.getName().compareTo(o2.getName());\n    }\n    \n}\n\nclass Animal implements Comparable<Animal> {\n    private Integer size;\n    private String name;\n    \n    public Animal(int x, String y){\n        size = x;\n        name = y;\n    }\n\n    public int getSize() {\n        return size;\n    }\n\n    public String getName() {\n        return name;\n    }\n    public int compareTo(Animal o){\n        return size.compareTo(o.getSize());\n        \n    }\n    \n    public String toString(){\n        return name;\n    }\n}','Collections',0,0,NULL,5),(2945,'IllegalArgumentException key out of range\n\nyour trying to add a rhino - 50 - to the copied map when the biggest element\nin the orgiinal was a Dog at 15 !','public class Hello {\n    \n    \n    public static void main(String[] dicks){\n      \n     TreeMap<Animal, Integer> map = new TreeMap<>();\n     \n     map.put(new Animal(2,\"Ant\"), 6); map.put(new Animal(3,\"Beee\"),9); map.put(new Animal(15,\"Dog\"),7); map.put(new Animal(12,\"muskrat\"),20);\n     \n     SortedMap<Animal,Integer> copymap = map.subMap(map.firstKey(), map.lastKey());\n     \n     copymap.put(new Animal(50,\"Rhino\"), 1);\n     map.put(new Animal(30,\"Wolf\"), 4);\n     System.out.println(map);\n     \n     SortedMap<Animal,Integer> copy1map = copymap.subMap(new Animal(4,\"Worm\"), new Animal(25,\"Dolphin\"));\n     \n     System.out.println(copy1map);\n\n    }\n}\n\nclass sortAnimalsAlphabetically implements Comparator<Animal> {\n\n    @Override\n    public int compare(Animal o1, Animal o2) {\n        return o1.getName().compareTo(o2.getName());\n    }\n    \n}\n\nclass Animal implements Comparable<Animal> {\n    private Integer size;\n    private String name;\n    \n    public Animal(int x, String y){\n        size = x;\n        name = y;\n    }\n\n    public int getSize() {\n        return size;\n    }\n\n    public String getName() {\n        return name;\n    }\n    public int compareTo(Animal o){\n        return size.compareTo(o.getSize());\n        \n    }\n    \n    public String toString(){\n        return name;\n    }\n}','Collections',0,0,NULL,5),(2946,'IllegalArgumentException, fromKey out of range\n\nthe tic your trying to add is too small previously the smallest elemtn was\nan Ant at 2','public class Hello {\n    \n    \n    public static void main(String[] dicks){\n      \n     TreeMap<Animal, Integer> map = new TreeMap<>();\n     \n     map.put(new Animal(2,\"Ant\"), 6); map.put(new Animal(3,\"Beee\"),9); map.put(new Animal(15,\"Dog\"),7); map.put(new Animal(12,\"muskrat\"),20);\n     \n     SortedMap<Animal,Integer> copymap = map.subMap(map.firstKey(), map.lastKey());\n     \n     map.put(new Animal(50,\"Rhino\"), 1);\n     map.put(new Animal(30,\"Wolf\"), 4);\n     System.out.println(map);\n     \n     SortedMap<Animal,Integer> copy1map = copymap.subMap(new Animal(1,\"Tic\"), new Animal(25,\"Dolphin\"));\n     \n     //System.out.println(copy1map);\n\n    }\n}\n\nclass sortAnimalsAlphabetically implements Comparator<Animal> {\n\n    @Override\n    public int compare(Animal o1, Animal o2) {\n        return o1.getName().compareTo(o2.getName());\n    }\n    \n}\n\nclass Animal implements Comparable<Animal> {\n    private Integer size;\n    private String name;\n    \n    public Animal(int x, String y){\n        size = x;\n        name = y;\n    }\n\n    public int getSize() {\n        return size;\n    }\n\n    public String getName() {\n        return name;\n    }\n    public int compareTo(Animal o){\n        return size.compareTo(o.getSize());\n        \n    }\n    \n    public String toString(){\n        return name;\n    }\n}\n','Collections',0,0,NULL,5),(2947,'{Ant=6, Beee=9, muskrat=20, Dog=7}\n{Ant=6, Beee=9, muskrat=20}\n{Ant=6, Beee=9, muskrat=20, Dog=7, Wolf=4, Rhino=1}\n{Ant=6, Beee=9, muskrat=20, Dog=7, Wolf=4}\n\npublic SortedMap<K,V> subMap(K fromKey,\n                    K toKey)\n\nkeys range from fromKey, inclusive, to toKey, exclusive. (If fromKey and toKey are equal, the returned map is empty.)\n The returned map is backed by this map, so changes \nin the returned map are reflected in this map, and vice-versa.\n\nTHE TO KEY IS EXCLUSIVE ','public class Hello {\n    \n    \n    public static void main(String[] dicks){\n      \n     TreeMap<Animal, Integer> map = new TreeMap<>();\n     \n     map.put(new Animal(2,\"Ant\"), 6); map.put(new Animal(3,\"Beee\"),9); map.put(new Animal(15,\"Dog\"),7); map.put(new Animal(12,\"muskrat\"),20);\n     \n     SortedMap<Animal,Integer> copymap = map.subMap(map.firstKey(), map.lastKey());\n        System.out.println(map);\n        System.out.println(copymap);\n     \n     map.put(new Animal(50,\"Rhino\"), 1);\n     map.put(new Animal(30,\"Wolf\"), 4);\n     System.out.println(map);\n     \n     copymap = map.subMap(map.firstKey(), map.lastKey());\n     \n        System.out.println(copymap);\n     \n     //SortedMap<Animal,Integer> copy1map = copymap.subMap(new Animal(7,\"Snake\"), new Animal(40,\"Bear\"));\n     //System.out.println(copy1map);\n\n    }\n}','Collections',0,0,NULL,5),(2948,'{Ant=6, Beee=9, muskrat=20, Dog=7}\n{Ant=6, Beee=9, muskrat=20, Dog=7}\n\noverloaded version of submap indicates if that arg is inclusive \n\nThe map is sorted according to the natural ordering of its keys, or by a Comparator provided at map creation time\nNote that the ordering maintained by a tree map, like any sorted map, and whether or not an explicit comparator is provided, \nmust be consistent with equals if this sorted map is to correctly implement the Map interface. (See Comparable or Comparator for a precise definition of consistent with equals.) \nThis is so because the Map interface is defined in terms of the equals operation, but a sorted map performs all key comparisons using its compareTo (or compare) method, so two keys that are deemed equal by this method are, \nfrom the standpoint of the sorted map, equal.  ','public class Hello {\n  public static void main(String[] dicks){\n      \n     TreeMap<Animal, Integer> map = new TreeMap<>();\n     \n     map.put(new Animal(2,\"Ant\"), 6); map.put(new Animal(3,\"Beee\"),9); map.put(new Animal(15,\"Dog\"),7); map.put(new Animal(12,\"muskrat\"),20);\n     \n     SortedMap<Animal,Integer> copymap = map.subMap(map.firstKey(),true, map.lastKey(),true);\n        System.out.println(map);\n        System.out.println(copymap);\n    }\n}\n\nclass Animal implements Comparable<Animal>{\n    private int size;\n    private String name;\n    public Animal(int s, String n){\n        size = s;\n        name = n;\n        \n    }\n    public int getSize(){\n        return size;\n    }\n    public int compareTo(Animal a){\n        int asize = a.getSize();\n        int bsize = this.size;\n        \n        if(asize < bsize)\n            return 1;\n        else if(asize == bsize)\n            return 0;\n        else\n            return -1;\n  \n    }\n    \n    public String toString(){\n        return name;\n    }\n}','Collections',0,0,NULL,5),(2949,'{Ant=6, Beee=9, muskrat=20, Dog=7}\n{Beee=9, muskrat=20, Dog=7}','public class Hello {\n    \n    \n    public static void main(String[] dicks){\n      \n     TreeMap<Animal, Integer> map = new TreeMap<>();\n     \n     map.put(new Animal(2,\"Ant\"), 6); map.put(new Animal(3,\"Beee\"),9); map.put(new Animal(15,\"Dog\"),7); map.put(new Animal(12,\"muskrat\"),20);\n     \n     SortedMap<Animal,Integer> copymap = map.subMap(map.firstKey(),false, map.lastKey(),true);\n        System.out.println(map);\n        System.out.println(copymap);\n    }\n}','Collections',0,0,NULL,5),(2950,'{Ant=6, Beee=9, muskrat=20, Dog=7}\n{Beee=9, muskrat=20}','public class Hello {\n    \n    \n    public static void main(String[] dicks){\n      \n     TreeMap<Animal, Integer> map = new TreeMap<>();\n     \n     map.put(new Animal(2,\"Ant\"), 6); map.put(new Animal(3,\"Beee\"),9); map.put(new Animal(15,\"Dog\"),7); map.put(new Animal(12,\"muskrat\"),20);\n     \n     SortedMap<Animal,Integer> copymap = map.subMap(map.firstKey(),false, map.lastKey(),false);\n        System.out.println(map);\n        System.out.println(copymap);\n    }\n}','Collections',0,0,NULL,5),(2951,'{Ant=6, Beee=9, muskrat=20, Dog=7}\n{Ant=6, Beee=9, muskrat=20, Dog=7}\n{Ant=6, Beee=9, muskrat=20, Dog=7, Wolf=1, Giant sloth=6}\n{Ant=6, Beee=9, muskrat=20, Dog=7}\n\nIf new elements are added to the orginal map that are out of the range\nof the submap then they are not copied over to the sub.\n\nThat submap only exist within the range it was defined. ','public class Hello {\n    \n    \n    public static void main(String[] dicks){\n      \n     TreeMap<Animal, Integer> map = new TreeMap<>();\n     \n     map.put(new Animal(2,\"Ant\"), 6); map.put(new Animal(3,\"Beee\"),9); map.put(new Animal(15,\"Dog\"),7); map.put(new Animal(12,\"muskrat\"),20);\n     \n     SortedMap<Animal,Integer> copymap = map.subMap(map.firstKey(),true, map.lastKey(),true);\n     \n        System.out.println(map);\n        System.out.println(copymap);\n     map.put(new Animal(25,\"Wolf\"), 1);\n     //copymap.put(new Animal(22,\"Lynx\"), 0);\n     map.put(new Animal(33,\"Giant sloth\"), 6);\n     //copymap.put(new Animal(30,\"Comodo\"),5);\n     \n        System.out.println(map);\n        System.out.println(copymap);        \n    }\n}','Collections',0,0,NULL,5),(2952,'{Ant=6, Beee=9, muskrat=20, Dog=7}\n{Ant=6, Beee=9, muskrat=20, Dog=7}\n{Ant=6, Beee=9, Fat Cat=0, muskrat=20, Dog=7, Wolf=1, Giant sloth=6}\n{Ant=6, Beee=9, Fat Cat=0, muskrat=20, Dog=7}','public class Hello {\n    \n    \n    public static void main(String[] dicks){\n      \n     TreeMap<Animal, Integer> map = new TreeMap<>();\n     \n     map.put(new Animal(2,\"Ant\"), 6); map.put(new Animal(3,\"Beee\"),9); map.put(new Animal(15,\"Dog\"),7); map.put(new Animal(12,\"muskrat\"),20);\n     \n     SortedMap<Animal,Integer> copymap = map.subMap(map.firstKey(),true, map.lastKey(),true);\n     \n        System.out.println(map);\n        System.out.println(copymap);\n     map.put(new Animal(25,\"Wolf\"), 1);\n     copymap.put(new Animal(10,\"Fat Cat\"), 0);\n     map.put(new Animal(33,\"Giant sloth\"), 6);\n     \n        System.out.println(map);\n        System.out.println(copymap);\n    }\n}','Collections',0,0,NULL,5),(2953,'{Ant=6, Beee=9, chipmunk=4, muskrat=20, Dog=7, Wolf=1, Giant sloth=6, Leapord=2, Cave Dweller=1}\n{Ant=6, Beee=9, chipmunk=4, muskrat=20, Dog=7, Wolf=1, Giant sloth=6}','public class Hello {\n    \n    \n    public static void main(String[] dicks){\n      \n     TreeMap<Animal, Integer> map = new TreeMap<>();\n     \n     map.put(new Animal(2,\"Ant\"), 6); map.put(new Animal(3,\"Beee\"),9); map.put(new Animal(15,\"Dog\"),7); map.put(new Animal(12,\"muskrat\"),20);\n     map.put(new Animal(25,\"Wolf\"), 1); map.put(new Animal(33,\"Giant sloth\"), 6);\n     map.put(new Animal(35,\"Leapord\"),2); map.put(new Animal(9,\"chipmunk\"),4); map.put(new Animal(46,\"Cave Dweller\"),1);\n     \n        System.out.println(map);\n        \n     SortedMap<Animal,Integer> headmap = map.headMap(new Animal(35,\"Leapord\"));\n     \n        System.out.println(headmap);\n   \n    }\n}','Collections',0,0,NULL,5),(2954,'{Ant=6, Beee=9, chipmunk=4, muskrat=20, Dog=7, Wolf=1, Giant sloth=6, Leapord=2, Cave Dweller=1}\n{Ant=6, Beee=9, chipmunk=4, muskrat=20, Dog=7, Wolf=1, Giant sloth=6, Leapord=2}','public class Hello {\n    \n    \n    public static void main(String[] dicks){\n      \n     TreeMap<Animal, Integer> map = new TreeMap<>();\n     \n     map.put(new Animal(2,\"Ant\"), 6); map.put(new Animal(3,\"Beee\"),9); map.put(new Animal(15,\"Dog\"),7); map.put(new Animal(12,\"muskrat\"),20);\n     map.put(new Animal(25,\"Wolf\"), 1); map.put(new Animal(33,\"Giant sloth\"), 6);\n     map.put(new Animal(35,\"Leapord\"),2); map.put(new Animal(9,\"chipmunk\"),4); map.put(new Animal(46,\"Cave Dweller\"),1);\n     \n        System.out.println(map);\n        \n     SortedMap<Animal,Integer> headmap = map.headMap(new Animal(35,\"Leapord\"),true);\n     \n        System.out.println(headmap);\n   \n    }\n}','Collections',0,0,NULL,5),(2955,'{Ant=6, Beee=9, chipmunk=4, muskrat=20, Dog=7, Wolf=1, Giant sloth=6, Leapord=2, Cave Dweller=1}\n{Ant=6, Beee=9, chipmunk=4, muskrat=20, Dog=7, Wolf=1, Giant sloth=6, Leapord=2}','public class Hello {\n    \n    \n    public static void main(String[] dicks){\n      \n     TreeMap<Animal, Integer> map = new TreeMap<>();\n     \n     map.put(new Animal(2,\"Ant\"), 6); map.put(new Animal(3,\"Beee\"),9); map.put(new Animal(15,\"Dog\"),7); map.put(new Animal(12,\"muskrat\"),20);\n     map.put(new Animal(25,\"Wolf\"), 1); map.put(new Animal(33,\"Giant sloth\"), 6);\n     map.put(new Animal(35,\"Leapord\"),2); map.put(new Animal(9,\"chipmunk\"),4); map.put(new Animal(46,\"Cave Dweller\"),1);\n     \n        System.out.println(map);\n        \n     SortedMap<Animal,Integer> headmap = map.headMap(new Animal(40,\"Python\"),true);\n     \n        System.out.println(headmap);\n   \n    }\n}','Collections',0,0,NULL,5),(2956,'{Ant=6, Beee=9, chipmunk=4, muskrat=20, Dog=7, Wolf=1, Giant sloth=6, Leapord=2, Cave Dweller=1}\n{Ant=6, Beee=9, chipmunk=4, muskrat=20, Dog=7, Wolf=1, Giant sloth=6, Leapord=2}','public class Hello {\n    \n    \n    public static void main(String[] dicks){\n      \n     TreeMap<Animal, Integer> map = new TreeMap<>();\n     \n     map.put(new Animal(2,\"Ant\"), 6); map.put(new Animal(3,\"Beee\"),9); map.put(new Animal(15,\"Dog\"),7); map.put(new Animal(12,\"muskrat\"),20);\n     map.put(new Animal(25,\"Wolf\"), 1); map.put(new Animal(33,\"Giant sloth\"), 6);\n     map.put(new Animal(35,\"Leapord\"),2); map.put(new Animal(9,\"chipmunk\"),4); map.put(new Animal(46,\"Cave Dweller\"),1);\n     \n        System.out.println(map);\n        \n     SortedMap<Animal,Integer> headmap = map.headMap(new Animal(40,\"Python\"));\n     \n        System.out.println(headmap);\n   \n    }\n}','Collections',0,0,NULL,5),(2957,'IOException caused by flushing a closed Bufferedwriter','try{\n            bw.write(df.format(today));\n            bw.newLine();\n            bw.write(\"Flash Cards \\n\");\n            bw.newLine();\n            \n            for(Card c : cards){\n                bw.write(\"================================================\\n\");\n                bw.write(\"-\"+counter+\"-\\n\");\n                bw.write(\"================================================\\n\");\n                bw.write(c.getCard());\n                bw.newLine();\n                bw.write(\"================================================\\n\");\n                bw.write(c.getAnswer());\n                bw.newLine();\n                bw.write(\"================================================\\n\");\n                counter++;\n            }\n            \n            bw.close();\n	    bw.flush();\n            \n        } catch(IOException e){\n            System.out.println(\"Problem saving cards\");\n            e.printStackTrace(); \n        } ','Collections',0,0,NULL,5),(2958,'{Ant=6, Beee=9, chipmunk=4, muskrat=20, Dog=7, Wolf=1, Giant sloth=6, Leapord=2, Cave Dweller=1}\n{Ant=6, Beee=9, chipmunk=4, muskrat=20, Dog=7, Wolf=1, Giant sloth=6, Leapord=2}\n{Ant=6, Beee=9, chipmunk=4, muskrat=20, Dog=7, Wolf=1, Giant sloth=6}','public class Hello {\n    \n    \n    public static void main(String[] dicks){\n      \n     TreeMap<Animal, Integer> map = new TreeMap<>();\n     \n     map.put(new Animal(2,\"Ant\"), 6); map.put(new Animal(3,\"Beee\"),9); map.put(new Animal(15,\"Dog\"),7); map.put(new Animal(12,\"muskrat\"),20);\n     map.put(new Animal(25,\"Wolf\"), 1); map.put(new Animal(33,\"Giant sloth\"), 6);\n     map.put(new Animal(35,\"Leapord\"),2); map.put(new Animal(9,\"chipmunk\"),4); map.put(new Animal(46,\"Cave Dweller\"),1);\n     \n        System.out.println(map);\n        \n     SortedMap<Animal,Integer> headmap = map.headMap(new Animal(40,\"Python\"));\n     \n     System.out.println(headmap);\n        \n     NavigableMap<Animal,Integer> headmapincl = map.headMap(new Animal(34,\"Lynx\"), true);\n     SortedMap<Animal,Integer> headmap_2 = map.headMap(new Animal(30,\"Fox\"), true);\n     \n        System.out.println(headmapincl);\n        \n   \n    }\n}','Collections',0,0,NULL,5),(2959,'{Ant=6, Beee=9, chipmunk=4, muskrat=20, Dog=7, Wolf=1, Giant sloth=6, Leapord=2, Cave Dweller=1}\n{Giant sloth=6, Leapord=2, Cave Dweller=1}','public class Hello {\n    \n    \n    public static void main(String[] dicks){\n      \n     TreeMap<Animal, Integer> map = new TreeMap<>();\n     \n     map.put(new Animal(2,\"Ant\"), 6); map.put(new Animal(3,\"Beee\"),9); map.put(new Animal(15,\"Dog\"),7); map.put(new Animal(12,\"muskrat\"),20);\n     map.put(new Animal(25,\"Wolf\"), 1); map.put(new Animal(33,\"Giant sloth\"), 6);\n     map.put(new Animal(35,\"Leapord\"),2); map.put(new Animal(9,\"chipmunk\"),4); map.put(new Animal(46,\"Cave Dweller\"),1);\n     \n        System.out.println(map);\n        \n    SortedMap<Animal,Integer> tailmap = map.tailMap(new Animal(33,\"Giant Sloth\"));\n    \n        System.out.println(tailmap);\n        \n   \n    }\n}','Collections',0,0,NULL,5),(2960,'{Ant=6, Beee=9, chipmunk=4, muskrat=20, Dog=7, Wolf=1, Giant sloth=6, Leapord=2, Cave Dweller=1}\n{Leapord=2, Cave Dweller=1}','public class Hello {\n    \n    \n    public static void main(String[] dicks){\n      \n     TreeMap<Animal, Integer> map = new TreeMap<>();\n     \n     map.put(new Animal(2,\"Ant\"), 6); map.put(new Animal(3,\"Beee\"),9); map.put(new Animal(15,\"Dog\"),7); map.put(new Animal(12,\"muskrat\"),20);\n     map.put(new Animal(25,\"Wolf\"), 1); map.put(new Animal(33,\"Giant sloth\"), 6);\n     map.put(new Animal(35,\"Leapord\"),2); map.put(new Animal(9,\"chipmunk\"),4); map.put(new Animal(46,\"Cave Dweller\"),1);\n     \n        System.out.println(map);\n        \n    SortedMap<Animal,Integer> tailmap = map.tailMap(new Animal(33,\"Giant Sloth\"),false);\n    \n        System.out.println(tailmap);\n        \n   \n    }\n}','Collections',0,0,NULL,5),(2961,'will not compile,\n\npollFirstEntry(),cielingKey,higherKey(), floorKey(), pollLastEntry(),\ndescendingMap()\n\n	are all in TreeMap not interface SortedMap.',' public static void main(String[] dicks){\n      \n     TreeMap<Animal, Integer> map = new TreeMap<>();\n     \n     map.put(new Animal(2,\"Ant\"), 6); map.put(new Animal(3,\"Beee\"),9); map.put(new Animal(15,\"Dog\"),7); map.put(new Animal(12,\"muskrat\"),20);\n     map.put(new Animal(25,\"Wolf\"), 1); map.put(new Animal(33,\"Giant sloth\"), 6);\n     map.put(new Animal(35,\"Leapord\"),2); map.put(new Animal(9,\"chipmunk\"),4); map.put(new Animal(46,\"Cave Dweller\"),1);\n     \n        System.out.println(map);\n        \n     SortedMap<Animal,Integer> tailmap = map.tailMap(new Animal(33,\"Giant Sloth\"),false);\n     \n        System.out.println(tailmap.pollFirtEntry());\n    \n    }\n}','Collections',0,0,NULL,5),(2962,'{Ant=6, Beee=9, chipmunk=4, muskrat=20, Dog=7, Wolf=1, Giant sloth=6, Leapord=2, Cave Dweller=1}\nAnt=6\nCave Dweller=1\nBeee\nchipmunk\nLeapord\nGiant sloth','public class Hello {\n    \n    \n    public static void main(String[] dicks){\n      \n     TreeMap<Animal, Integer> map = new TreeMap<>();\n     \n     map.put(new Animal(2,\"Ant\"), 6); map.put(new Animal(3,\"Beee\"),9); map.put(new Animal(15,\"Dog\"),7); map.put(new Animal(12,\"muskrat\"),20);\n     map.put(new Animal(25,\"Wolf\"), 1); map.put(new Animal(33,\"Giant sloth\"), 6);\n     map.put(new Animal(35,\"Leapord\"),2); map.put(new Animal(9,\"chipmunk\"),4); map.put(new Animal(46,\"Cave Dweller\"),1);\n     \n        System.out.println(map);\n        \n     \n        System.out.println(map.pollFirstEntry());\n        System.out.println(map.pollLastEntry());\n        System.out.println(map.ceilingKey(new Animal(2,\"Ant\")));\n        System.out.println(map.higherKey(new Animal(3,\"Beee\")));\n        System.out.println(map.floorKey(new Animal(46,\"Cave Dweller\")));\n        System.out.println(map.lowerKey(new Animal(35,\"Leapord\")));\n        \n    \n    }\n}','Collections',0,0,NULL,5),(2963,'nullpointerexception, PQ does not allow null elements','\npublic class Hello {\n    public static void main(String[] dicks){\n      \n        PriorityQueue<Animal> q = new PriorityQueue<>();\n        \n        q.add(new Animal(5,\"Sheep\"));\n        q.offer(new Animal(6,\"Goat\"));\n        q.offer(new Animal(10,\"Cow\"));\n        q.offer(new Animal(12,\"Bull\"));\n        q.offer(null);\n        \n        System.out.println(q);\n        \n    \n    }\n}','Collections',0,0,NULL,5),(2964,'ConcurrentModificationExcpeiton for removing elements from the pq\nwhile iterating over it. ','public class Hello {\n    public static void main(String[] dicks){\n        \n        PriorityQueue<Animal> q = new PriorityQueue<>(5);\n        \n        q.add(new Animal(5,\"Sheep\"));\n        q.offer(new Animal(6,\"Goat\"));\n        q.offer(new Animal(10,\"Cow\"));\n        q.offer(new Animal(12,\"Bull\"));\n        q.offer(new Animal(3,\"Cat\"));\n        q.offer(new Animal(7,\"Sloth\"));\n        \n        for(Animal x : q)\n            System.out.println(x);\n        \n        System.out.println(\"__________________\");\n        \n        for(Animal x : q)\n            System.out.println(q.poll());\n        \n    \n    }\n}','Collections',0,0,NULL,5),(2965,'Cat\nSheep\nSloth\nBull\nGoat\nCow\n__________________\nCat\nSheep\nGoat\nSloth\nCow\nBull\n\nYou need to poll the items from the PriorityQueue one by one. toString doesn\'t do that.\n\nSo instead of your System.out.println(queue); do this:\n\nwhile(!queue.isEmpty()) {\n   System.out.println(queue.poll());\n}\n\nThe reason is that the PriorityQueue is never completely sorted internally, lookup how a heap works for more detail. Polling items from it fixes the heap during the calls, thus it should output the elements in sorted order.','public class Hello {\n    public static void main(String[] dicks){\n        \n        PriorityQueue<Animal> q = new PriorityQueue<>(5);\n        \n        q.add(new Animal(5,\"Sheep\"));\n        q.offer(new Animal(6,\"Goat\"));\n        q.offer(new Animal(10,\"Cow\"));\n        q.offer(new Animal(12,\"Bull\"));\n        q.offer(new Animal(3,\"Cat\"));\n        q.offer(new Animal(7,\"Sloth\"));\n        \n        for(Animal x : q)\n            System.out.println(x);\n        \n        System.out.println(\"__________________\");\n        \n        while(!q.isEmpty())\n            System.out.println(q.poll());\n        \n    \n    }\n}','Collections',0,0,NULL,5),(2966,'will not compile string cannot be converted to Animal','public class Hello {\n    public static void main(String[] dicks){\n        \n        PriorityQueue<Animal> q = new PriorityQueue<>(5);\n        \n        q.add(new Animal(5,\"Sheep\"));\n        q.offer(new Animal(6,\"Goat\"));\n        q.offer(new Animal(10,\"Cow\"));\n        q.offer(new Animal(12,\"Bull\"));\n        q.offer(new Animal(3,\"Cat\"));\n        q.offer(new Animal(7,\"Sloth\"));\n        \n        q.offer(\"Sloths\");\n        q.add(\"fake bull\");\n        \n        while(!q.isEmpty())\n            System.out.println(q.poll());\n        \n\n        \n    \n    }\n}','Collections',0,0,NULL,5),(2967,'will not compile, Collections.sort will only sort Lists','public class Hello {\n    public static void main(String[] dicks){\n        Comparator revSort = Collections.reverseOrder();\n        PriorityQueue<Animal> q = new PriorityQueue<>();\n        \n        q.add(new Animal(5,\"Sheep\"));\n        q.offer(new Animal(6,\"Goat\"));\n        q.offer(new Animal(10,\"Cow\"));\n        q.offer(new Animal(12,\"Bull\"));\n        q.offer(new Animal(3,\"Cat\"));\n        q.offer(new Animal(7,\"Sloth\"));\n        \n        PriorityQueue<Animal> q2 = new PriorityQueue<>(q);\n        \n        Collections.sort(q2,revSort);\n        \n        while(!q.isEmpty())\n            System.out.println(q.poll());\n        \n        while(!q2.isEmpty())\n            System.out.println(q2.poll());\n\n    }\n}','Collections',0,0,NULL,5),(2968,'Bull\nCow\nSloth\nGoat\nSheep\nCat','public class Hello {\n    public static void main(String[] dicks){\n        Comparator revSort = Collections.reverseOrder();\n        PriorityQueue<Animal> q = new PriorityQueue<>(revSort);\n        \n        q.add(new Animal(5,\"Sheep\"));\n        q.offer(new Animal(6,\"Goat\"));\n        q.offer(new Animal(10,\"Cow\"));\n        q.offer(new Animal(12,\"Bull\"));\n        q.offer(new Animal(3,\"Cat\"));\n        q.offer(new Animal(7,\"Sloth\"));\n        \n        while(!q.isEmpty()){\n            System.out.println(q.poll());\n        }\n        \n        \n\n    }\n}','Collections',0,0,NULL,5),(2969,'Here animal doesn\'t impleemnt equals and remove uses equals to determine the \nelement to remove','public class Hello {\n    public static void main(String[] dicks){\n        Comparator revSort = Collections.reverseOrder();\n        PriorityQueue<Animal> q = new PriorityQueue<>(revSort);\n        \n        q.add(new Animal(5,\"Sheep\"));\n        q.offer(new Animal(6,\"Goat\"));\n        q.offer(new Animal(10,\"Cow\"));\n        q.offer(new Animal(12,\"Bull\"));\n        q.offer(new Animal(3,\"Cat\"));\n        q.offer(new Animal(7,\"Sloth\"));\n        \n        System.out.println(q.remove());\n        System.out.println(q.remove(new Animal(7,\"Sloth\")));\n        \n        while(!q.isEmpty()){\n            System.out.println(q.poll());\n        }\n\n    }\n}\n\nclass Animal implements Comparable<Animal> {\n    private Integer size;\n    private String name;\n    \n    public Animal(int x, String y){\n        size = x;\n        name = y;\n    }\n\n    public int getSize() {\n        return size;\n    }\n\n    public String getName() {\n        return name;\n    }\n    public int compareTo(Animal o){\n        return size.compareTo(o.getSize());\n        \n    }\n    \n    public String toString(){\n        return name;\n    }\n}\n','Collections',0,0,NULL,5),(2970,'now with equals remove() works just fine. \n\nBull\ntrue\n\nCow\nGoat\nSheep\nCat\n\nnotice the pq is sorted with a Reverse sort comparator, so the animal class\nimplements Comparable. If it didn\'t implement Comparable it could not be used \nin the PriorityQueue. If it wasn\'t for the equals method the remove(sloth)\ncall would return false and sloth would not be removed. Thus making the \noutput:\n\n	Bull\n	false\n\n	Cow\n	Sloth\n	Goat\n	Sheep\n	Cat\n\nalso notice that it is a queue and therefore removes from the head','public class Hello {\n    public static void main(String[] dicks){\n        Comparator revSort = Collections.reverseOrder();\n        PriorityQueue<Animal> q = new PriorityQueue<>(revSort);\n        \n        q.add(new Animal(5,\"Sheep\"));\n        q.offer(new Animal(6,\"Goat\"));\n        q.offer(new Animal(10,\"Cow\"));\n        q.offer(new Animal(12,\"Bull\"));\n        q.offer(new Animal(3,\"Cat\"));\n        q.offer(new Animal(7,\"Sloth\"));\n        \n        System.out.println(q.remove());\n        System.out.println(q.remove(new Animal(7,\"Sloth\")));\n        System.out.println(\"\");\n        \n        while(!q.isEmpty()){\n            System.out.println(q.poll());\n        }\n    }\n}\n\nclass Animal implements Comparable<Animal> {\n    private Integer size;\n    private String name;\n    \n    public Animal(int x, String y){\n        size = x;\n        name = y;\n    }\n\n    public int getSize() {\n        return size;\n    }\n\n    public String getName() {\n        return name;\n    }\n    public int compareTo(Animal o){\n        return size.compareTo(o.getSize());\n        \n    }\n    \n    public String toString(){\n        return name;\n    }\n    \n    public boolean equals(Object o){\n        if((o instanceof Animal)){\n            if((((Animal)o).getSize() == this.size) && (((Animal)o).getName().equals(name) ))\n                return true;\n            return false;           \n        } \n        return false;\n    }\n}','Collections',0,0,NULL,5),(2971,'Biffy\ntwo tone\nbig slick\nfunny farm\ntwice tickled\nnull\nnull','public class Hello {\n    public static void main(String[] dicks){\n        Map<Integer,String> map = new HashMap<>();\n        \n        map.put(7,\"Biffy\");\n        map.put(5,\"two tone\");\n        map.put(9,\"big slick\");\n        map.put(1,\"funny farm\");\n        map.put(10, \"twice tickled\");\n        \n        List<Integer> list = new ArrayList<>();\n        \n        list.add(7);\n        list.add(5);\n        list.add(9);\n        list.add(1);\n        list.add(10);\n        list.add(16);\n        list.add(14);\n        \n        for(int x : list){\n            System.out.println(map.remove(x));\n        }    \n\n    }\n}','Collections',0,0,NULL,5),(2972,'sizes: 5, 7, 5\nBiffy\nset contains?: true\nsizes: 4, 7, 5\ntwo tone\nset contains?: true\nsizes: 3, 7, 5\nbig slick\nset contains?: true\nsizes: 2, 7, 5\nfunny farm\nset contains?: true\nsizes: 1, 7, 5\ntwice tickled\nset contains?: true\nsizes: 0, 7, 5\nnull\nset contains?: false\nsizes: 0, 7, 5\nnull\nset contains?: false','public class Hello {\n    public static void main(String[] dicks){\n        Map<Integer,String> map = new HashMap<>();\n        \n        map.put(7,\"Biffy\");\n        map.put(5,\"two tone\");\n        map.put(9,\"big slick\");\n        map.put(1,\"funny farm\");\n        map.put(10, \"twice tickled\");\n        \n        List<Integer> list = new ArrayList<>();\n        \n        list.add(7);\n        list.add(5);\n        list.add(9);\n        list.add(1);\n        list.add(10);\n        list.add(16);\n        list.add(14);\n        \n        Set<Integer> set = new HashSet<>();\n        \n        set.add(7);\n        set.add(5);\n        set.add(9);\n        set.add(1);\n        set.add(10);\n        \n        for(int x : list){\n            System.out.println(\"sizes: \"+map.size() +\", \"+ list.size()+\", \"+set.size());\n            System.out.println(map.remove(x));\n            System.out.println(\"set contains?: \"+set.contains(x));\n        }    \n\n    }\n}','Collections',0,0,NULL,5),(2973,'','Spaces sort before characters,\nuppercases sort before the lower,\nyour good to go','Collections',0,0,NULL,5),(2974,'true\ntrue\nfalse\ntrue\ntrue\ntrue\nfalse\n4\ntrue\nfalse\n3','public class Hello {\n    public static void main(String[] dicks){\n       HashSet<Animal> set = new HashSet<>();\n       \n       Animal cat = new Animal(3,\"Cat\");\n       Animal dog = new Animal(4,\"Dog\");\n       Animal wolf = new Animal(6,\"Wolf\");\n       Animal coyote = new Animal(5,\"Coyote\");\n       Animal cat2 = new Animal(3,\"Cat\");\n       \n        System.out.println(cat.equals(cat2));\n       \n        System.out.println(set.add(cat));\n        System.out.println(set.add(cat));\n        System.out.println(set.add(dog));\n        System.out.println(set.add(wolf));\n        System.out.println(set.add(coyote));\n        System.out.println(set.add(cat2));\n        \n       \n        System.out.println(set.size());\n        System.out.println(set.remove(cat));\n        System.out.println(set.contains(cat));\n        System.out.println(set.size());\n        \n        \n    \n    }\n}\n\n\nclass Animal {\n    private Integer size;\n    private String name;\n    \n    public Animal(int x, String y){\n        size = x;\n        name = y;\n    }\n\n    public int getSize() {\n        return size;\n    }\n\n    public String getName() {\n        return name;\n    }\n    \n    public String toString(){\n        return name;\n    }\n    \n    public boolean equals(Object o){\n        if((o instanceof Animal)){\n            if((((Animal)o).getSize() == this.size) && (((Animal)o).getName().equals(name) ))\n                return true;\n            return false;           \n        } \n        return false;\n    }\n    \n    //public int hashCode(){ return name.length() + size; }\n        \n}','Collections',0,0,NULL,5),(2975,'true\ntrue\nfalse\ntrue\ntrue\ntrue\nfalse\n4\ntrue\nfalse\n3\n\nif hashCode() is not overriden then every object will go in its own bucket\ntherefore equals will not be able to differentiate between equal objects because it will have no\nother objects to compare that object to!','public class Hello {\n    public static void main(String[] dicks){\n       HashSet<Animal> set = new HashSet<>();\n       \n       Animal cat = new Animal(3,\"Cat\");\n       Animal dog = new Animal(4,\"Dog\");\n       Animal wolf = new Animal(6,\"Wolf\");\n       Animal coyote = new Animal(5,\"Coyote\");\n       Animal cat2 = new Animal(3,\"Cat\");\n       \n        System.out.println(cat.equals(cat2));\n       \n        System.out.println(set.add(cat));\n        System.out.println(set.add(cat));\n        System.out.println(set.add(dog));\n        System.out.println(set.add(wolf));\n        System.out.println(set.add(coyote));\n        System.out.println(set.add(cat2));\n        \n       \n        System.out.println(set.size());\n        System.out.println(set.remove(cat));\n        System.out.println(set.contains(cat));\n        System.out.println(set.size());\n        \n        \n    \n    }\n}\n\n\nclass Animal {\n    private Integer size;\n    private String name;\n    \n    public Animal(int x, String y){\n        size = x;\n        name = y;\n    }\n\n    public int getSize() {\n        return size;\n    }\n\n    public String getName() {\n        return name;\n    }\n    \n    public String toString(){\n        return name;\n    }\n    \n    public boolean equals(Object o){\n        if((o instanceof Animal)){\n            if((((Animal)o).getSize() == this.size) && (((Animal)o).getName().equals(name) ))\n                return true;\n            return false;           \n        } \n        return false;\n    }\n    \n    public int hashCode(){ return name.length() + size; }\n        \n}\n','Collections',0,0,NULL,5),(2976,'false\ntrue\nfalse\ntrue\ntrue\ntrue\ntrue\n5\ntrue\nfalse\n4\n\nif equals is not overriden then only references with the same actual\nobject are considered equal','public class Hello {\n    public static void main(String[] dicks){\n       HashSet<Animal> set = new HashSet<>();\n       \n       Animal cat = new Animal(3,\"Cat\");\n       Animal dog = new Animal(4,\"Dog\");\n       Animal wolf = new Animal(6,\"Wolf\");\n       Animal coyote = new Animal(5,\"Coyote\");\n       Animal cat2 = new Animal(3,\"Cat\");\n       \n        System.out.println(cat.equals(cat2));\n       \n        System.out.println(set.add(cat));\n        System.out.println(set.add(cat));\n        System.out.println(set.add(dog));\n        System.out.println(set.add(wolf));\n        System.out.println(set.add(coyote));\n        System.out.println(set.add(cat2));\n        \n       \n        System.out.println(set.size());\n        System.out.println(set.remove(cat));\n        System.out.println(set.contains(cat));\n        System.out.println(set.size());\n        \n        \n    \n    }\n}\n\n\nclass Animal {\n    private Integer size;\n    private String name;\n    \n    public Animal(int x, String y){\n        size = x;\n        name = y;\n    }\n\n    public int getSize() {\n        return size;\n    }\n\n    public String getName() {\n        return name;\n    }\n    \n    public String toString(){\n        return name;\n    }\n    \n    /**\n    public boolean equals(Object o){\n        if((o instanceof Animal)){\n            if((((Animal)o).getSize() == this.size) && (((Animal)o).getName().equals(name) ))\n                return true;\n            return false;           \n        } \n        return false;\n    } **/\n    \n    public int hashCode(){ return name.length() + size; }\n        \n}\n','Collections',0,0,NULL,5),(2977,'nullpointerexception\n\nLinkedHashSet and HashSet allow null elements but when you call a method on a null\nyou get an exception','public class Hello {\n    public static void main(String[] dicks){\n       Animal cat = new Animal(3,\"Cat\");\n       Animal dog = new Animal(4,\"Dog\");\n       Animal wolf = new Animal(6,\"Wolf\");\n       Animal coyote = new Animal(5,\"Coyote\");\n       Animal cat2 = new Animal(3,\"Cat\");\n       \n       LinkedHashSet<Animal> lhs = new LinkedHashSet<>();\n       HashSet<Animal> hs = new HashSet<>();\n       \n       lhs.add(cat); lhs.add(dog); lhs.add(wolf); lhs.add(coyote); lhs.add(null);\n       hs.add(cat); hs.add(dog); hs.add(wolf); hs.add(coyote); hs.add(null);\n       \n       for(Animal x : lhs){\n           System.out.print(x.getName()+\" \");\n       }\n \n    }\n}','Collections',0,0,NULL,5),(2978,'true\ntrue\nfalse\nfalse\n\nSets allow null elements but they also dont allow duplicates so here \nis will not let you add ANother null','public class Hello {\n    public static void main(String[] dicks){\n       Animal cat = new Animal(3,\"Cat\");\n       Animal dog = new Animal(4,\"Dog\");\n       Animal wolf = new Animal(6,\"Wolf\");\n       Animal coyote = new Animal(5,\"Coyote\");\n       Animal cat2 = new Animal(3,\"Cat\");\n       \n       LinkedHashSet<Animal> lhs = new LinkedHashSet<>();\n       HashSet<Animal> hs = new HashSet<>();\n       \n       lhs.add(cat); lhs.add(dog); lhs.add(wolf); lhs.add(coyote);\n       hs.add(cat); hs.add(dog); hs.add(wolf); hs.add(coyote); \n       \n       System.out.println( lhs.add(null) ); \n       System.out.println( hs.add(null) );\n       \n       System.out.println( lhs.add(null) );\n       System.out.println( hs.add(null) );\n        \n\n    }\n}','Collections',0,0,NULL,5),(2979,'will not compile,\n\nHashtable is a Map !\n\nrequires two type arguments','public class Hello {\n    public static void main(String[] dicks){\n       Animal cat = new Animal(3,\"Cat\");\n       Animal dog = new Animal(4,\"Dog\");\n       Animal wolf = new Animal(6,\"Wolf\");\n       Animal coyote = new Animal(5,\"Coyote\");\n       Animal cat2 = new Animal(3,\"Cat\");\n       \n       LinkedHashSet<Animal> lhs = new LinkedHashSet<>();\n       HashSet<Animal> hs = new HashSet<>();\n       Hashtable<Animal> ht = new Hashtable<>();\n       \n       lhs.add(cat); lhs.add(dog); lhs.add(wolf); lhs.add(coyote);\n       hs.add(cat); hs.add(dog); hs.add(wolf); hs.add(coyote); \n       \n       System.out.println(lhs.add(null)); \n       System.out.println(hs.add(null));\n       \n       System.out.println(lhs.add(null));\n       System.out.println(hs.add(null));\n        \n\n    }\n}','Collections',0,0,NULL,5),(2980,'null\nnull\nnull\nnull\nnull\nCat\nCat\nDog\nDog\n\nput\n\npublic V put(K key,\n    V value)\n\nMaps the specified key to the specified value in this hashtable. \nNeither the key nor the value can be null.\n\nThe value can be retrieved by calling the get\n method with a key that is equal to the original key.\n\nTo successfully store and retrieve objects from a hashtable, \nthe objects used as keys \nmust implement the hashCode method and the equals method. \n\nto know anything about how this code works you need to know if it implements\nequals and hashCode','public class Hello {\n    public static void main(String[] dicks){\n       Animal cat = new Animal(3,\"Cat\");\n       Animal dog = new Animal(4,\"Dog\");\n       Animal wolf = new Animal(6,\"Wolf\");\n       Animal coyote = new Animal(5,\"Coyote\");\n       Animal cat2 = new Animal(3,\"Cat\");\n\n       Hashtable<Integer,Animal> ht = new Hashtable<>();\n\n        System.out.println(ht.put(1,cat));\n        System.out.println(ht.put(2,dog));\n        System.out.println(ht.put(3,wolf));\n        System.out.println(ht.put(4,coyote));\n        System.out.println(ht.put(5, cat2));\n        \n        System.out.println(ht.put(1,cat));\n        System.out.println(ht.put(1,new Animal(3,\"Barn Cat\")));\n        \n        System.out.println(ht.put(2,dog));\n        System.out.println(ht.put(2, new Animal(4,\"Fox\")));\n    }\n}','Collections',0,0,NULL,5),(2981,'null\nnull\nnull\nnull\nnull\nCat\nCat\n5\nDog\nDog','public class Hello {\n    public static void main(String[] dicks){\n       Animal cat = new Animal(3,\"Cat\");\n       Animal dog = new Animal(4,\"Dog\");\n       Animal wolf = new Animal(6,\"Wolf\");\n       Animal coyote = new Animal(5,\"Coyote\");\n       Animal cat2 = new Animal(3,\"Cat\");\n\n       Hashtable<Integer,Animal> ht = new Hashtable<>();\n\n        System.out.println(ht.put(1,cat));\n        System.out.println(ht.put(2,dog));\n        System.out.println(ht.put(3,wolf));\n        System.out.println(ht.put(4,coyote));\n        System.out.println(ht.put(5, cat2));\n        \n        System.out.println(ht.put(1,cat));\n        System.out.println(ht.put(1,new Animal(3,\"Barn Cat\")));\n        \n        System.out.println(ht.size());\n        \n        System.out.println(ht.put(2,dog));\n        System.out.println(ht.put(2, new Animal(4,\"Fox\")));\n    }\n}\n\n\nclass Animal {\n    private Integer size;\n    private String name;\n    \n    public Animal(int x, String y){\n        size = x;\n        name = y;\n    }\n\n    public int getSize() {\n        return size;\n    }\n\n    public String getName() {\n        return name;\n    }\n    \n    public String toString(){\n        return name;\n    }\n    \n    /**\n    public boolean equals(Object o){\n        if((o instanceof Animal)){\n            if((((Animal)o).getSize() == this.size) && (((Animal)o).getName().equals(name) ))\n                return true;\n            return false;           \n        } \n        return false;\n    } **/\n    \n    //public int hashCode(){ return name.length() + size; }\n        \n}\n','Collections',0,0,NULL,5),(2982,'will not compile int cannot auotbox to null\n\na primitive cannot be null','public class Hello {\n    public static void main(String[] dicks){\n        Map<String, Integer> map = new HashMap<>();\n        \n        String name = \"Max\";\n        map.put(name,10000000);\n        \n        int total = map.get(\"Max\");\n        \n        (if total == null){\n            System.out.println(\"no money in maxs account\");\n        }\n    }\n}','Collections',0,0,NULL,5),(2983,'class Foo<t> { }	// a class\nT anInstance;		//an instance variable\nFoo(T aRef) { }	// a constructor argument\nvoid bar(T aRef) { }	// a method argument\nT baz() { }		// a return type\n\nThe compiler will substitute the actual type','The generics type identifier can be used in class, method, and variable declarations....\n\n','Generics',0,0,NULL,5),(2984,'List and Set, With Maps you remove by the key which removes the element','Which Collection interfaces have a method for removing an element by the object ?','Collections',0,0,NULL,5),(2985,'Will Not compile\n\nuntyped collections store Objects so you would have to cast to a String. ','public class Hello {\n    public static void main(String[] args){\n        List myList = new ArrayList();\n        myList.add(\"Hoyt\");\n        myList.add(\"JOJO\");\n        myList.add(\"Adam\");\n        \n        String athletename = myList.get(1);\n        System.out.println(athletename+ \" \" + athletename.length());\n    }\n}','Collections',0,0,NULL,5),(2986,'Will Not compile','void takeListOfStrings(List<String> strings) {\n	strings.add(new Integer(42) ); \n}','Generics',0,0,NULL,5),(2987,'Compiles fine, you know what is coming out of a typed list returned from a method declared with that type','public List<Dog> getDogList() {\n	List<Dog> dogs = new ArrayList<>();\n	//add dogs to list\n	return dogs;\n}\n\nDog d = getDogList().get(0);','Generics',0,0,NULL,5),(2988,'Will not compile','public List getDogList() {\n	List dogs = new ArrayList();\n	dogs.add(\"Dicks\");\n	dogs.add(\"Spot\");\n	dogs.add(\"FIdo\");\n	return dogs;\n}\n\npsvm(sa){	\n	List dognames = getDogList();\n	Dog fido = dognames.get(2);\n}\n	','Generics',0,0,NULL,5),(2989,'The cast is unecessary but it wont cause any error','psvm(sa){\n	List<Integer> list = new ArrayList<>();\n	list.add(5);\n	list.add(9);\n	list.add(7);\n\n	Integer i = (Integer) list.get(0);\n}','Generics',0,0,NULL,5),(2990,'Works fine. ','public class Hello {\n    public static void main(String[] args){\n        List<Integer> myList = new ArrayList<>();\n        \n        myList.add(4);\n        myList.add(6);\n        Adder adder = new Adder();\n        int total = adder.addAll(myList);\n        \n        System.out.println(total);\n        \n    }\n}\n\nclass Adder {\n        int addAll(List list){\n            Iterator it = list.iterator();\n            int total = 0;\n            \n            while(it.hasNext()){\n                int i = ((Integer)it.next()).intValue();\n                total += i;\n            }\n            \n            return total;\n        }\n}','Generics',0,0,NULL,5),(2991,'ClassCastException','public class Hello {\n    public static void main(String[] args){\n        List myList = new ArrayList();\n        \n        myList.add(4);\n        myList.add(6);\n        myList.add(\"whoops\");\n        Adder adder = new Adder();\n        int total = adder.addAll(myList);\n        \n        System.out.println(total);\n        \n    }\n}\n\nclass Adder {\n        int addAll(List list){\n            Iterator it = list.iterator();\n            int total = 0;\n            \n            while(it.hasNext()){\n                int i = ((Integer)it.next()).intValue();\n                total += i;\n            }\n            \n            return total;\n        }\n}','Generics',0,0,NULL,5),(2992,'compiles and runs no problem','public class Hello {\n    public static void main(String[] args){\n        List<Integer> myList = new ArrayList<>();\n        \n        myList.add(4);\n        myList.add(6);\n        Inserter is = new Inserter();\n        is.insert(myList);\n        \n    }\n}\n\nclass Inserter {\n        void insert(List list){\n            list.add(new Integer(42));\n            Iterator it = list.iterator();\n            int total = 0;\n            \n            while(it.hasNext()){\n                int i = ((Integer)it.next()).intValue();\n                total += i;\n            }\n\n        }\n}','Generics',0,0,NULL,5),(2993,'ClassCastException\n\nand compiler warning for going into unsafe method','public class Hello {\n    public static void main(String[] args){\n        List<Integer> myList = new ArrayList<>();\n        \n        myList.add(4);\n        myList.add(6);\n        Inserter is = new Inserter();\n        is.insert(myList);\n        \n    }\n}\n\nclass Inserter {\n        void insert(List list){\n            list.add(\"42\");\n            Iterator it = list.iterator();\n            int total = 0;\n            \n            while(it.hasNext()){\n                int i = ((Integer)it.next()).intValue();\n                total += i;\n            }\n\n        }\n}','Generics',0,0,NULL,5),(2994,'Will not compile because of .intValue() the list declared in inserter is of type Object','public class Hello {\n    public static void main(String[] args){\n        List<Integer> myList = new ArrayList<>();\n        \n        myList.add(4);\n        myList.add(6);\n        Inserter is = new Inserter();\n        is.insert(myList);\n        \n    }\n}\n\nclass Inserter {\n        void insert(List list){\n            list.add(\"42\");\n            Iterator it = list.iterator();\n            int total = 0;\n            \n            while(it.hasNext()){\n                int i = (it.next()).intValue();\n                total += i;\n            }\n\n        }\n}','Generics',0,0,NULL,5),(2995,'comiler warning but compiles and runs just fine, in order to support legacy code this must be allowed. ','public class Hello {\n    public static void main(String[] args){\n        List<Integer> myList = new ArrayList<>();\n        \n        myList.add(4);\n        myList.add(6);\n        Inserter is = new Inserter();\n        is.insert(myList);\n        \n    }\n}\n\nclass Inserter {\n        void insert(List list){\n            list.add(\"42\");           \n        }\n}','Generics',0,0,NULL,5),(2996,'','The compiiler only issues warnings when a typed collection is going into an untyped method and that method\nADDS somethiing. ','Generics',0,0,NULL,5),(2997,'The generic types are removed by the compiler before runtime. The types are just for the compiler the JVM\nhas no idea about types. To the JVM generic code looks the same as pre generic. ','\"Type Erasure\"\n','Generics',0,0,NULL,5),(2998,'cast is required here','List myList = new ArrayList();\n        \nmyList.add(45);\n        \nint x = (Integer) myList.get(0);','Generics',0,0,NULL,5),(2999,'cast not necessary here',' List<Integer> myList = new ArrayList<>();\n        \n        myList.add(45);\n        \n        int x = myList.get(0);\n        \n        ','Generics',0,0,NULL,5),(3000,'no\nno\nyes\nyes','List<Object> myList = new ArrayList<JButton>();\nList<Number> myList = new ArrayList<Integer>();\nList<JButton> myList = new ArrayList<JButton>();\nList<String> myList = new ArrayList<String>();','Generics',0,0,NULL,5),(3001,'This is ok!\n\nunlike collection types array types can use polymorphism.\n','class Parent { }\nclass Child extends Parent { }\n\npublic class Test {\n	psvm(SA){\n		Parent[] myArray = new Child[4];\n	}\n}','Generics',0,0,NULL,5),(3002,'This not ok ','List<Object> myList = new ArrayList<JButton>();	','Generics',0,0,NULL,5),(3003,'Will not compile\n\nif the method parameter says ArrayList<Animal> then you\ncan only pass in an ArrayList of type <Animal>, \npolymorphism doesn\'t work for generic types','public class AnimalDoctor {\n	public void checkAnimals(ArrayLIst<Animal> list){\n		for(Animal a : animals){\n			a.checkup();\n		}\n	}\n}\n\npsvm(Sa){\n        List<Dog> dogs = new ArrayList<Dog>();\n        dogs.add(new Dog()); dogs.add(new Dog());\n\n        List<Cat> cats = new ArrrayLiist<Cat>();\n        cats.add(new Cat()); cats.add(new Cat());\n\n        AnimalDoctor ad = new AnimalDoctor();\n        ad.checkAnimals(dogs);\n        ad.checkAnimals(cats);\n}\n}','Generics',0,0,NULL,5),(3004,'fine','Animal[] animals = new Animal[3];\nanimals[0] = new Cat();\nanimals[1] = new Dog();','Generics',0,0,NULL,5),(3005,'fine you can add and instance of a subtype into an array or collection declared with a supertype.\n\nyou can addDogs and Cats to an Animal array or an Animal Collection. ','List<Animal> animals = new ArrayList<Animal>();\nanimals.add(new Cat());\nanimals.add(new Dog());\n','Generics',0,0,NULL,5),(3006,'ok!','public class Hello {\n    public static void main(String[] args){\n       \n      \n        \n    }\n    \n    public void foo() {\n	Dog[] dogs = { new Dog(), new Dog() };\n	addAnimal(dogs);\n    }\n    \n    public void addAnimal(Animal[] animals) {\n	animals[0] = new Dog();\n        animals[1] = new Cat();\n    }\n}','Generics',0,0,NULL,5),(3007,'ok !\n\nThe compiler thinks its ok to add a Dog to an Animal[] since a Dog can be assigned to an animal reference. B\n\nBut the compiler does not know if you passed in an array of an animal subtype. \n\nThe reason: at runtime the JVM knows the type of the array but not the type of the collection ','public class Hello {\n    public static void main(String[] args){\n \n    }\n    \n    public void foo() {\n	Cat[] cats = { new Cat(), new Cat() };\n	addAnimal(cats);\n    }\n    \n    public void addAnimal(Animal[] animals) {\n	animals[0] = new Dog();\n        animals[1] = new Cat();\n    }\n}','Generics',0,0,NULL,5),(3008,'comiles and runs just fine','public class Hello {\n    public static void main(String[] args){\n        List<Animal> animals = new ArrayList<Animal>();\n        animals.add(new Dog());\n        animals.add(new Cat());\n        \n        addAnimal(animals);\n    \n    }\n    public static void addAnimal(List<Animal> animals) {\n	animals.add(new Dog());\n    }\n}','Generics',0,0,NULL,5),(3009,'comiles fine','public class Hello {\n    public static void main(String[] args){\n        ArrayList<Animal> animals = new ArrayList<>();\n        animals.add(new Dog());\n        animals.add(new Cat());\n        \n        addAnimal(animals);\n    \n    }\n    public static void addAnimal(List<Animal> animals) {\n	animals.add(new Dog());\n    }\n}','Generics',0,0,NULL,5),(3010,'will not compile, ','public class Hello {\n    public static void main(String[] args){\n        List<Dog> animals = new ArrayList<>();\n        animals.add(new Dog());\n        \n        \n        addAnimal(animals);\n    \n    }\n    public static void addAnimal(List<Animal> animals) {\n	animals.add(new Dog());\n    }\n}','Generics',0,0,NULL,5),(3011,'will not compile because of ArrayList<Dog> cant be applied to List<Animal>','public class Hello {\n    public static void main(String[] args){\n        ArrayList<Dog> animals = new ArrayList<>();\n        animals.add(new Dog());\n        \n        \n        addAnimal(animals);\n    \n    }\n    public static void addAnimal(List<Animal> animals) {\n	animals.add(new Dog());\n    }\n}','Generics',0,0,NULL,5),(3012,'<?> wildcard\n\ntells the compiler you can take any generic subtype of the declared argument type because you won\'t\nbe putting anything in the collection. ','What mechanism is used to tell the compiler \" Hey, I\'m using the collection passed in just to invoke methods \non the elements  and I promise not to ADD anything into the collection\"','Generics',0,0,NULL,5),(3013,'wont compile \n\nadding to a collection is not compatible with ? notation','public class Hello {\n    public static void main(String[] args){\n        ArrayList<Dog> animals = new ArrayList<>();\n        animals.add(new Dog());\n        \n        \n        addAnimal(animals);\n    \n    }\n    public static void addAnimal(List<? extends Animal> animals) {\n	animals.add(new Dog());\n    }\n}','Generics',0,0,NULL,5),(3014,'compiles fine!','public class Hello {\n    public static void main(String[] args){\n        ArrayList<Dog> animals = new ArrayList<>();\n        animals.add(new Dog());\n        \n        \n        addAnimal(animals);\n    \n    }\n    public static void addAnimal(List<? extends Animal> animals) {\n	for(Animal a : animals){\n            a.makesound();\n        }\n    }\n}','Generics',0,0,NULL,5),(3015,'will not compile because of for(Animal a : animals)\n\n	needs to be... \n		for(Serializable a : animals)','public class Hello {\n    public static void main(String[] args){\n        ArrayList<Dog> animals = new ArrayList<>();\n        animals.add(new Dog());\n        \n        \n        addAnimal(animals);\n    \n    }\n    public static void addAnimal(List<? extends Serializable> animals) {\n	for(Animal a : animals){\n            a.makesound();\n        }\n    }\n}\n\nclass Dog extends Animal{}\nclass Cat extends Animal{}\nclass Animal implements Serializable{\n    public void makesound(){ System.out.println(\"SOUND\"); }\n        \n}','Generics',0,0,NULL,5),(3016,'compiles fine!','public class Hello {\n    public static void main(String[] args){\n        ArrayList<Dog> animals = new ArrayList<>();\n        animals.add(new Dog());\n        \n        \n        addAnimal(animals);\n    \n    }\n    public static void addAnimal(List<? extends Serializable> animals) {\n	for(Serializable a : animals){\n            //call method form interface\n        }\n    }\n}\n\nclass Dog extends Animal{}\nclass Cat extends Animal{}\nclass Animal implements Serializable{\n    public void makesound(){ System.out.println(\"SOUND\"); }\n        \n}','Generics',0,0,NULL,5),(3017,'<? super Dog>\n\npublic class Hello {\n    public static void main(String[] args) {     \n\n        List<Animal> animals = new ArrayList<Animal>();\n        animals.add(new Dog());\n        animals.add(new Cat());\n        \n        addAnimal(animals);\n    \n    }\n    \n    public static void addAnimal(List<? super Dog> animals) {\n	animals.add(new Dog());\n    }\n}\n\nWhile you can now accept in List types of <? super Dog> you can still only\nadd type Dog to that list. This is created because its ok to add a Dog to List<Object>\n\n\n','What can you use to type a method parameter and still add to the collection','Generics',0,0,NULL,5),(3018,'this is fine\n\n\"Hey compiler, please accept any List with a generic type that is of type Dog or a supertype of Dog. \nNothing lower in the inheritance tree can come in, but anything higher than Dog is okay\"\n\nif you pass in a List of type Animal then it\'s perfectly fine to add a Dog to it. If you pass in a list of type Dog\nits still ok to add a Dog to it. if you pass in a list of type Object its still ok. \n\nHowever that doesn\'t give you the freedom to just add anything  you can still\nonly add the type after the super','public class Hello {\n    public static void main(String[] args){\n        List<Animal> animals = new ArrayList<Animal>();\n        animals.add(new Dog());\n        animals.add(new Animal());\n        \n        addAnimal(animals);\n        \n    \n    }\n    public static void addAnimal(List<? super Dog> animals) {\n	animals.add(new Dog());\n    }\n}','Generics',0,0,NULL,5),(3019,'will not compile incompatible types ','public class Hello {\n    public static void main(String[] args){\n        List<Animal> animals = new ArrayList<Animal>();\n        animals.add(new Dog());\n        animals.add(new Animal());\n        \n        addAnimal(animals);\n        \n    \n    }\n    public static void addAnimal(List<Object> animals) {\n	animals.add(new Dog());\n    }\n}','Generics',0,0,NULL,5),(3020,'','','Generics',0,0,NULL,5),(3021,'? will mean that any type of list can be passed to this method however nothing will be allowed to be added to it\n\n<Object> will mean that only lists of type Object can be passed to this method and \nyou will be able to add pretty much anything to that list. ','whats the difference between\n\npublic void foo(List<?> list){ }\npublic void foo(List<Object> list) { }','Generics',0,0,NULL,5),(3022,'class Bar compiles fine\n\nTest is the class that fails. ','public class TestWildcards {\n	psvm(sa) {\n		List<Integer> myList = new ArrayList<Integer>();\n		Bar bar = new Bar();\n		bar.doInsert(MyList);\n	}\n}\n\nclass Bar {\n	void doInsert(List<Object> list) {\n		list.add(new Dog();	\n	}\n}\n\nwhich class fails compilation here ?','Generics',0,0,NULL,5),(3023,'Bar','public class TestWildcards {\n	psvm(sa) {\n		List<Integer> myList = new ArrayList<Integer>();\n		Bar bar = new Bar();\n		bar.doInsert(MyList);\n	}\n}\n\nclass Bar {\n	void doInsert(List<?> list) {\n		list.add(new Dog();	\n	}\n}\n\nwhich class fails compilation here ?','Generics',0,0,NULL,5),(3024,'nothing they are identicle \n\nthey both say I can refer to any type of object. but you wont be able to addd to me. \n\nthis is very differenct from List<Object> ','whats the difference between \n\nList<?>\nList<? extends Object>','Generics',0,0,NULL,5),(3025,'1 2  and 5 compile ','1 List<?> list = new ArrayList<Dog>();\n2 List<? extends Animal> alist = new ArrayList<Dog>();\n3  List<?> foo = new ArrayList<? extends Animal>();\n4 List<? extends Dog> cList = new ArrayList<Integer>();\n5 List<? super Dog> dList = new ArrayList<Animal>();\n6 List<? super Animal elist = new ArrayList<Dog>();\n\n','Generics',0,0,NULL,5),(3026,'AutoCloseable()\nyou can call close() mulitple times and nothing will happen the second time and beyond. \n\nCloseable() is not, something could go wrong the second time','Which interface close() is idempotent ?','Generics',0,0,NULL,5),(3027,'public <T> void makeArrayList(T t){ }\n\nYou have to define the type variable BEFORE the return type of the method\n\n','declare a generic method:\n\npublic <T> void makeArrayList(T t){ }\n\npublic void makeArrayList(T t) { }\n\npublic void <T> makeArrayList(T t){\n}','Generics',0,0,NULL,5),(3028,'Will not compile \n\nNon static type variable cannot be referenced from static context. \n\nWhen T is defined for a new class it is appropriate for that instance there forfore static methods of that \nclass wont really know about the individualy typed instances. \n\nSingleton with generics doesn\'t make a whole lot of sense anyway....\n\npublic class SimpleSingleton {\nprivate Map<String, Object> counter = new HashMap<String, Object>();\n\npublic <T> T getInstance(Class<T> clazz) throws IllegalAccessException, InstantiationException {\n    T singleton = (T) counter.get(clazz.getName());\n    if (singleton == null) {\n        singleton = clazz.newInstance();\n        counter.put(clazz.getName(), singleton);\n    }\n    return singleton;\n}\n\n\nalso adding a Dog to an ArrayList typed for T will not compile \n','public class Hello<T> {\n    public static void main(String[] args){\n        Printer<String> x = Printer.getInstance();\n\n    }\n    public static void addAnimal(List<T> animals) {\n	animals.add(new Dog());\n    }\n    \n    public <G> ArrayList<G> makeArrayList(G g){\n        ArrayList<G> genlist = new ArrayList();\n        genlist.add(g);\n        return genlist;\n        \n    }\n}\n\nclass Printer<T> {\n    private ArrayList<T> joblist = new ArrayList<>();\n    private static Printer instance = null;\n    \n    protected Printer(){\n        \n    }\n    \n    public static Printer getInstance(){\n        if(instance == null){\n            instance = new Printer();\n            return instance;\n        }\n        \n        return instance;\n        \n    }\n    \n    public void addJob(T t){\n        joblist.add(t);\n    }\n}','Generics',0,0,NULL,5),(3029,'NullPointerException\n\ninstance in class Printer is never intitialized','public class Hello<T> {\n    public static void main(String[] args){\n        Printer<String> x = new Printer<>();\n        String y = x.instance;\n        System.out.println(y.length());\n\n    } \n    public <G> ArrayList<G> makeArrayList(G g){\n        ArrayList<G> genlist = new ArrayList();\n        genlist.add(g);\n        return genlist;\n        \n    }\n}\n\nclass Printer<T> {\n    private ArrayList<T> joblist = new ArrayList<>();\n    T instance;\n    \n    public Printer(){\n        \n    }\n    \n    public void addJob(T t){\n        joblist.add(t);\n    }\n    \n    public T getAnewT(){\n        return instance;\n    }\n}','Generics',0,0,NULL,5),(3030,'in the overloaded constructor T should be instance, remember a Type is an Object not an reference varialb.e','class Printer<T> {\n    private ArrayList<T> joblist = new ArrayList<>();\n    private T instance;\n    \n    public Printer(){\n        \n    }\n    \n    public Printer(T b){\n        T = b;\n    }\n    \n    public void addJob(T t){\n        joblist.add(t);\n    }\n    \n    public T getAnewT(){\n        return instance;\n    }\n}','Generics',0,0,NULL,5),(3031,'a Class will be created with a type that extends number','class Printer<T extends Number> {\n    private ArrayList<T> joblist = new ArrayList<>();\n    private T instance;\n    \n    public Printer(){\n        \n    }\n    \n    public Printer(T b){\n       instance = b;\n    }\n    \n    public void addJob(T t){\n        joblist.add(t);\n    }\n    \n    public T getAnewT(){\n        return instance;\n    }\n}','Generics',0,0,NULL,5),(3032,'will not compile, a type variable is needed here not a wildcard.\n\nWildcards are never used in generic class definitions','class Printer<? extends Number> {\n    private ArrayList<T> joblist = new ArrayList<>();\n    private T instance;\n    \n    public Printer(){\n        \n    }\n    \n    public Printer(T b){\n       instance = b;\n    }\n    \n    public void addJob(T t){\n        joblist.add(t);\n    }\n    \n    public T getAnewT(){\n        return instance;\n    }\n}','Generics',0,0,NULL,5),(3033,'Does not compile,\n\nyou cant use super when defining a generic class','class Printer<T super Beagle> {\n    private ArrayList<T> joblist = new ArrayList<>();\n    private T instance;\n    \n    public Printer(){\n        \n    }\n    \n    public Printer(T b){\n       instance = b;\n    }\n    \n    public void addJob(T t){\n        joblist.add(t);\n    }\n    \n    public T getAnewT(){\n        return instance;\n    }\n}\n\nclass Animal{}\nclass Dog extends Animal{}\nclass Beagle extends Dog{}','Generics',0,0,NULL,5),(3034,'fine,\n\nyou use extends when creating a generic class to specify bounds','class Printer<T extends Animal> {\n    private ArrayList<T> joblist = new ArrayList<>();\n    private T instance;\n    \n    public Printer(){\n        \n    }\n    \n    public Printer(T b){\n       instance = b;\n    }\n    \n    public void addJob(T t){\n        joblist.add(t);\n    }\n    \n    public void makeSound() {\n        instance.makeSound();\n    }\n    \n    public T getAnewT(){\n        return instance;\n    }\n}\n\nclass Animal{public void makeSound(){\n            System.out.println(\"Sound!\");\n}\n}\nclass Dog extends Animal{}\nclass Beagle extends Dog{}','Generics',0,0,NULL,5),(3035,'will not compile type argument string is not within bound of class Printer','public class Hello<T> {\n    public static void main(String[] args){\n        \n        Printer<String> x = new Printer<>();\n\n\n    } \n    public <G> ArrayList<G> makeArrayList(G g){\n        ArrayList<G> genlist = new ArrayList();\n        genlist.add(g);\n        return genlist;\n        \n    }\n}\n\nclass Printer<T extends Animal> {\n    private ArrayList<T> joblist = new ArrayList<>();\n    private T instance;\n    \n    public Printer(){\n        \n    }\n    \n    public Printer(T b){\n       instance = b;\n    }\n    \n    public void addJob(T t){\n        joblist.add(t);\n    }\n    \n    public void makeSound() {\n        instance.makeSound();\n    }\n    \n    public T getAnewT(){\n        return instance;\n    }\n}\n\nclass Animal{public void makeSound(){\n            System.out.println(\"Sound!\");\n}\n}\nclass Dog extends Animal{}\nclass Beagle extends Dog{}','Generics',0,0,NULL,5),(3036,'will not compile because of (Dog d)','public class Hello<T> {\n    public static void main(String[] args){\n\n        ArrayList x = makeArrayList(Dog d);\n        \n        ArrayList c = new ArrayList<String>();\n\n    } \n    public <G> ArrayList<G> makeArrayList(G g){\n        ArrayList<G> genlist = new ArrayList();\n        genlist.add(g);\n        return genlist;\n        \n    }\n}','Generics',0,0,NULL,5),(3037,'compiles fine.','public class Hello<T> {\n    public static void main(String[] args){\n        \n        Dog d = new Dog();\n        \n        ArrayList x = makeArrayList(d);\n        \n        ArrayList c = new ArrayList<String>();\n\n    } \n    public static <G> ArrayList<G> makeArrayList(G g){\n        ArrayList<G> genlist = new ArrayList();\n        genlist.add(g);\n        return genlist;\n        \n    }\n}','Generics',0,0,NULL,5),(3038,'neither Dog a nor stringa will compile. The Declared type of the arraylists is non generic so they return objects\n','public class Hello<T> {\n    public static void main(String[] args){\n        \n        Dog d = new Dog();\n        \n        ArrayList x = makeArrayList(d);\n        \n        ArrayList c = new ArrayList<String>();\n        c.add(\"quick string\");\n        \n        x.add(new Dog());\n        \n        Dog a = x.get(0);\n        String stringa = c.get(0);\n \n    } \n    public static <G> ArrayList<G> makeArrayList(G g){\n        ArrayList<G> genlist = new ArrayList();\n        genlist.add(g);\n        return genlist;\n        \n    }\n}','Generics',0,0,NULL,5),(3039,'compiles fine','public class Hello<T> {\n    public static void main(String[] args){\n        \n        Dog d = new Dog();\n        \n        ArrayList<Dog> c = makeArrayList(d);\n \n    } \n    public static <G> ArrayList<G> makeArrayList(G g){\n        ArrayList<G> genlist = new ArrayList();\n        genlist.add(g);\n        return genlist;\n        \n    }\n}','Generics',0,0,NULL,5),(3040,'compiles fine','public class Hello<T> {\n    public static void main(String[] args){\n        \n        Dog d = new Dog();\n        \n        ArrayList<Dog> c = makeArrayList(d);\n        \n        c.add(new Beagle());\n \n    } \n    public static <G extends Animal> ArrayList<G> makeArrayList(G g){\n        ArrayList<G> genlist = new ArrayList();\n        genlist.add(g);\n        return genlist;\n        \n    }\n}\n\n\nclass Animal{public void makeSound(){\n            System.out.println(\"Sound!\");\n}\n}\nclass Dog extends Animal{}\nclass Beagle extends Dog{}','Generics',0,0,NULL,5),(3041,'Compilation fails ? wildcard is not valid here you need a type varialbe istead','public class Hello<T> {\n    public static void main(String[] args){\n        \n        Dog d = new Dog();\n        \n        ArrayList<Dog> c = makeArrayList(d);\n \n    } \n    public static <? extends Animal> ArrayList<?> makeArrayList(? g){\n        ArrayList<?> genlist = new ArrayList();\n        genlist.add(g);\n        return genlist;\n        \n    }\n}','Generics',0,0,NULL,5),(3042,'compiles fine, \n\nyou can define ArrayLIsts this way, you wont be able to add anything to it though','public class Hello<T> {\n    public static void main(String[] args){\n        \n        Dog d = new Dog();\n        \n        ArrayList<?> c = makeArrayList(d);\n \n    } \n    public static <G extends Animal> ArrayList<G> makeArrayList(G g){\n        ArrayList<G> genlist = new ArrayList();\n        genlist.add(g);\n        return genlist;\n        \n    }\n}','Generics',0,0,NULL,5),(3043,'compilation fails','public class Hello<T> {\n    public static void main(String[] args){\n        \n        Dog d = new Dog();\n        \n        ArrayList<?> c = makeArrayList(d);\n        c.add(new Animal());\n    } \n    public static <G extends Animal> ArrayList<G> makeArrayList(G g){\n        ArrayList<G> genlist = new ArrayList();\n        genlist.add(g);\n        return genlist;\n        \n    }\n}','Generics',0,0,NULL,5),(3044,'does not compile because of H extends Beagle\n\nshould be ? extends Beagle','public class Hello<T> {\n    public static void main(String[] args){\n        \n        Dog d = new Dog();\n        \n        ArrayList<H extends Beagle> c = makeArrayList(d);\n        \n    } \n    public static <G extends Animal> ArrayList<G> makeArrayList(G g){\n        ArrayList<G> genlist = new ArrayList();\n        genlist.add(g);\n        return genlist;\n        \n    }\n}','Generics',0,0,NULL,5),(3045,'does not compile Beagle is the lowest type and nothing extends it,\n\nthe only type that would be acceptable here is a Beagle','public class Hello<T> {\n    public static void main(String[] args){\n        \n        Dog d = new Dog();\n        \n        ArrayList<? extends Beagle> c = makeArrayList(d);\n        \n    } \n    public static <G extends Animal> ArrayList<G> makeArrayList(G g){\n        ArrayList<G> genlist = new ArrayList();\n        genlist.add(g);\n        return genlist;\n        \n    }\n}\n\n\nclass Animal{public void makeSound(){\n            System.out.println(\"Sound!\");\n}\n}\nclass Dog extends Animal{}\nclass Beagle extends Dog{}','Generics',0,0,NULL,5),(3046,'compiles fine','public class Hello<T> {\n    public static void main(String[] args){\n        \n        Dog d = new Dog();\n        \n        ArrayList<? extends Animal> c = makeArrayList(d);\n        \n    } \n    public static <G extends Animal> ArrayList<G> makeArrayList(G g){\n        ArrayList<G> genlist = new ArrayList();\n        genlist.add(g);\n        return genlist;\n        \n    }\n}\n\n\nclass Animal{public void makeSound(){\n            System.out.println(\"Sound!\");\n}\n}\nclass Dog extends Animal{}\nclass Beagle extends Dog{}','Generics',0,0,NULL,5),(3047,'\n\nPECS (short for \"Producer extends and Consumer super\") can be explained by : Get and Put Principle\nGet And Put Principle (From Java Generics and Collections)\n\nIt states,\n\n    use an extends wildcard when you only get values out of a structure\n    use a super wildcard when you only put values into a structure\n    and don’t use a wildcard when you both get and put.\n\nLet\'s understand it by example:\n\n1. For Extends Wildcard(get values i.e Producer extends)\n\nHere is a method, that takes a collection of numbers, converts each to a double, and sums them up\n\npublic static double sum(Collection<? extends Number> nums) {\n   double s = 0.0;\n   for (Number num : nums) \n      s += num.doubleValue();\n   return s;\n}\n\nLet\'s call the method :\n\nList<Integer>ints = Arrays.asList(1,2,3);\nassert sum(ints) == 6.0;\nList<Double>doubles = Arrays.asList(2.78,3.14);\nassert sum(doubles) == 5.92;\nList<Number>nums = Arrays.<Number>asList(1,2,2.78,3.14);\nassert sum(nums) == 8.92;\n\nSince, sum() method uses extends, all of the following calls are legal. The first two calls would not be legal if extends was not used.\n\nEXCEPTION : You cannot put anything into a type declared with an extends wildcard—except for the value null, which belongs to every reference type:\n\nList<Integer> ints = new ArrayList<Integer>();\nints.add(1);\nints.add(2);\nList<? extends Number> nums = ints;\nnums.add(null);  // ok\nassert nums.toString().equals(\"[1, 2, null]\");\n\n2. For Super Wildcard(put values i.e Consumer super)\n\nHere is a method, that takes a collection of numbers and an int n, and puts the first n integers, starting from zero, into the collection:\n\npublic static void count(Collection<? super Integer> ints, int n) {\n    for (int i = 0; i < n; i++) ints.add(i);\n}\n\nLet\'s call the method :\n\nList<Integer>ints = new ArrayList<Integer>();\ncount(ints, 5);\nassert ints.toString().equals(\"[0, 1, 2, 3, 4]\");\nList<Number>nums = new ArrayList<Number>();\ncount(nums, 5); nums.add(5.0);\nassert nums.toString().equals(\"[0, 1, 2, 3, 4, 5.0]\");\nList<Object>objs = new ArrayList<Object>();\ncount(objs, 5); objs.add(\"five\");\nassert objs.toString().equals(\"[0, 1, 2, 3, 4, five]\");\n\nSince, count() method uses super, all of the following calls are legal: The last two calls would not be legal if super was not used.\n\nEXCEPTION : you cannot get anything out from a type declared with a super wildcard—except for a value of type Object, which is a supertype of every reference type:\n\nList<Object> objs = Arrays.<Object>asList(1,\"two\");\nList<? super Integer> ints = objs;\nString str = \"\";\nfor (Object obj : ints) str += obj.toString();\nassert str.equals(\"1two\");\n\n3. When both Get and Put, don\'t Use wildcard\n\nWhenever you both put values into and get values out of the same structure, you should not use a wildcard.\n\npublic static double sumCount(Collection<Number> nums, int n) {\n   count(nums, n);\n   return sum(nums);\n}\n\n','PECS','Generics',0,0,NULL,5),(3048,'PECS\n\nproducers extends consumers super','public class Hello<T> {\n    \n    public static void main(String[] args){\n        \n        Dog d = new Dog();\n        \n        ArrayList<? extends Animal> c = new ArrayList<Beagle>();\n        \n        c.add(new Beagle()); // does not compile\n        c.add(new Beagle()); // does not compile\n        \n        Animal a = c.get(0);\n    } ','Generics',0,0,NULL,5),(3049,'does not compile because of Beagle a = c.get(0);','public class Hello<T> {\n    \n    public static void main(String[] args){\n        \n        Dog d = new Dog();\n        \n        ArrayList<? super Beagle> c = new ArrayList<Beagle>();\n        \n        c.add(new Beagle());\n        c.add(new Beagle()); \n        \n        Beagle a = c.get(0);\n    } ','Generics',0,0,NULL,5),(3050,'compiles fine','public class Hello<T> {\n    \n    public static void main(String[] args){\n        \n        Dog d = new Dog();\n        \n        ArrayList<Dog> c = makeArrayList(d);\n        \n        c.add(new Beagle());\n        c.add(new Beagle()); \n\n    } \n    public static <G extends Animal> ArrayList<G> makeArrayList(G g){\n        ArrayList<G> genlist = new ArrayList<>();\n        genlist.add(g);\n        return genlist;\n        \n    }\n}','Generics',0,0,NULL,5),(3051,'compiles fine','public class Hello<T> {\n    \n    public static void main(String[] args){\n        \n        Dog d = new Dog();\n        \n        ArrayList<Dog> c = makeArrayList(new Beagle());\n        \n        c.add(new Beagle());\n        c.add(new Beagle()); \n\n    } \n    public static <G extends Animal> ArrayList<G> makeArrayList(G g){\n        ArrayList<G> genlist = new ArrayList<>();\n        genlist.add(g);\n        return genlist;\n        \n    }\n}','Generics',0,0,NULL,5),(3052,'comilation fails\n\nArrayLIst<Animal> cannot be applied to ArrayList<Dog>','public class Hello<T> {\n    \n    public static void main(String[] args){\n        \n        Dog d = new Dog();\n        \n        ArrayList<Dog> c = makeArrayList(new Animal());\n        \n        c.add(new Beagle());\n        c.add(new Beagle()); \n\n    } \n    public static <G extends Animal> ArrayList<G> makeArrayList(G g){\n        ArrayList<G> genlist = new ArrayList<>();\n        genlist.add(g);\n        return genlist;\n        \n    }\n}','Generics',0,0,NULL,5),(3053,'comiles fine','\npublic class Hello<T> {\n    \n    public static void main(String[] args){\n        \n        Dog d = new Dog();\n        \n        ArrayList<?> c = makeArrayList(new Animal());\n        \n\n    } \n    public static <G extends Animal> ArrayList<G> makeArrayList(G g){\n        ArrayList<G> genlist = new ArrayList<>();\n        genlist.add(g);\n        return genlist;\n        \n    }\n}','Generics',0,0,NULL,5),(3054,'','public class Test {\n\n    public class A {}\n\n    public class B extends A {}\n\n    public class C extends B {}\n\n    public void testCoVariance(List<? extends B> myBlist) {\n        B b = new B();\n        C c = new C();\n        myBlist.add(b); // does not compile\n        myBlist.add(c); // does not compile\n        A a = myBlist.get(0); \n    }\n\n    public void testContraVariance(List<? super B> myBlist) {\n        B b = new B();\n        C c = new C();\n        myBlist.add(b);\n        myBlist.add(c);\n        A a = myBlist.get(0); // does not compile\n    }\n}','Generics',0,0,NULL,5),(3055,'\n\nJosh Bloch\'s mnemonic PECS is useful here. It stands for:\n\nProducer extends, Consumer super\n\nThis means that when a parameterized type being passed to a method will produce instances of T (they will be retrieved from it in some way), ? extends T should be used, since any instance of a subclass of T is also a T.\n\nWhen a parameterized type being passed to a method will consume instances of T (they will be passed to it to do something), ? super T should be used because an instance of T can legally be passed to any method that accepts some supertype of T. A Comparator<Number> could be used on a Collection<Integer>, for example. ? extends T would not work, because a Comparator<Integer> could not operate on a Collection<Number>.\n\nEdit: To clarify a little more on get/put (produce/consume):\n\npublic T something();\n       ^\n\nThe above is a method that produces T.\n\npublic void something(T t);\n                      ^\n\nThe above is a method that consumes T.\n\n\"Producer extends, Consumer super\" applies to how the method a parameterized object is being passed to is going to be using that object. In the case of Collections.max(), items will be retrieved from the Collection, so it is a producer. Those items will be passed as arguments to the method on Comparator, so it is a consumer.\n','PECS','Generics',0,0,NULL,5),(3056,'','/ Source \n       List<Integer> intList = Arrays.asList(1,2,3);\n       List<Double> doubleList = Arrays.asList(2.78,3.14);\n       List<Number> numList = Arrays.asList(1,2,2.78,3.14,5);\n\n       // Destination\n       List<Integer> intList2 = new ArrayList<>();\n       List<Double> doublesList2 = new ArrayList<>();\n       List<Number> numList2 = new ArrayList<>();\n\n        // Works\n        copyElements1(intList,intList2);         // from int to int\n        copyElements1(doubleList,doublesList2);  // from double to double\n\n\n     static <T> void copyElements1(Collection<T> src, Collection<T> dest) {\n        for(T n : src){\n            dest.add(n);\n         }\n      }\n\n\n     // Let\'s try to copy intList to its supertype\n     copyElements1(intList,numList2); // error, method signature just says \"T\"\n                                      // and here the compiler is given \n                                      // two types: Integer and Number, \n                                      // so which one shall it be?\n\n     // PECS to the rescue!\n     copyElements2(intList,numList2);  // possible\n\n\n\n    // copy Integer (? extends T) to its supertype (Number is super of Integer)\n    private static <T> void copyElements2(Collection<? extends T> src, \n                                          Collection<? super T> dest) {\n        for(T n : src){\n            dest.add(n);\n        }\n    }','Generics',0,0,NULL,5),(3057,'does not compile Collection<G> is given two different types here\n\nalso a and b were not initialized, that is ok to do with instance variables\nbut not locals \n\nyou could say \n\nArrayList<Animal> a = null;\nand same for b;','public class Hello<T> {\n    \n    public static void main(String[] args){\n        ArrayList<Animal> a;\n        ArrayList<Beagle> b;\n        \n        Hello<String> x = new Hello<>();\n        \n        x.copyColl(a,b);\n        \n\n    } \n    public <G> void copyColl(Collection<G> src, Collection<G> dest){\n        \n        for(G n : src)\n            dest.add(n);\n        \n    }\n}','Generics',0,0,NULL,5),(3058,'compiles fine','public class Hello<T> {\n    \n    public static void main(String[] args){\n        ArrayList<Dog> a = new ArrayList<>();\n        ArrayList<Dog> b = new ArrayList<>();\n        \n        Hello<String> x = new Hello<>();\n        \n        x.copyColl(a,b);\n        \n\n    } \n    public <G extends Animal> void copyColl(Collection<G> src, Collection<G> dest){\n        \n        for(G n : src)\n            dest.add(n);\n        \n    }\n}','Generics',0,0,NULL,5),(3059,'does not compile \n\nyou cant add to a collection declared with wildcard extends','public class Hello<T> {\n    \n    public static void main(String[] args){\n        ArrayList<Dog> a = new ArrayList<>();\n        ArrayList<Dog> b = new ArrayList<>();\n        \n        Hello<String> x = new Hello<>();\n        \n        \n        \n        x.copyColl(a,b);\n        \n\n    } \n    public <G extends Animal> void copyColl(Collection<G> src, Collection<? extends G> dest){\n        \n        for(G n : src)\n            dest.add(n);\n        \n    }\n}','Generics',0,0,NULL,5),(3060,'compiles fine','public class Hello<T> {\n    \n    public static void main(String[] args){\n        ArrayList<Dog> a = new ArrayList<>();\n        ArrayList<Dog> b = new ArrayList<>();\n        \n        Hello<String> x = new Hello<>();\n        \n        \n        \n        x.copyColl(a,b);\n        \n\n    } \n    public <G extends Animal> void copyColl(Collection<G> src, Collection<? super G> dest){\n        \n        for(G n : src)\n            dest.add(n);\n        \n    }\n}','Generics',0,0,NULL,5),(3061,'will not compiile at x.copyColl','public class Hello<T> {\n    \n    public static void main(String[] args){\n        ArrayList<Animal> a = new ArrayList<>();\n        ArrayList<Dog> b = new ArrayList<>();\n        \n        Hello<String> x = new Hello<>();\n        \n        \n        \n        x.copyColl(a,b);\n        \n\n    } \n    public <G extends Animal> void copyColl(Collection<? extends G> src, Collection<? super G> dest){\n        \n        for(G n : src)\n            dest.add(n);\n        \n    }\n}','Generics',0,0,NULL,5),(3062,'compiles fine\n\nyou can easily take a beagle and add it to an Animal array','public class Hello<T> {\n    \n    public static void main(String[] args){\n        ArrayList<Beagle> a = new ArrayList<>();\n        ArrayList<Animal> b = new ArrayList<>();\n        \n        Hello<String> x = new Hello<>();\n        \n        \n        \n        x.copyColl(a,b);\n        \n\n    } \n    public <G extends Animal> void copyColl(Collection<? extends G> src, Collection<? super G> dest){\n        \n        for(G n : src)\n            dest.add(n);\n        \n    }\n}','Generics',0,0,NULL,5),(3063,'','','blank',0,0,NULL,5),(3064,'','','blank',0,0,NULL,5),(3065,'','','blank',0,0,NULL,5),(3066,'','','blank',0,0,NULL,5),(3067,'','','blank',0,0,NULL,5),(3068,'public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs)\nthrows IOException {\n	sout( dir );\n	return FileVisitResult.CONTINUE;\n}\n\npublic FileVisitResult postVisitDirectory(Path dir, IOException e)\nthrows IOException {\n	sout( dir );\n	return FileVisitResult.CONTINUE;\n}\n\n**VisitFile is called only for Files and not directories','public class Visit extends SimpleFileVisitor<Path> {\n\n	//insert here\n\n   public static void main(String[] args) throws Exception {\n	Visit v = new Visit();\n	Files.walkFileTree(Paths.get(\"/mydir\"),v);\n   }\n}\n\nwhat inserted here will print out the provided directory and all \nsubdirectories ?\n\n\n','IO',0,0,NULL,5),(3069,'','','blank',0,0,NULL,5),(3070,'','','blank',0,0,NULL,5),(3071,'r1\nr4\npre \nb1\nb2\nr3\nr2\nhawk\n\nstatic init blocks run at class loading time. Instance init blocks run after\nthe constructors call to super()','class Bird {	\n	{ System.out.println(\"b1\"); }	\n	public Bird() { System.out.println(\"b2\"); }\n}\n\nclass Raptor extends Bird {\n	static {System.out.println(\"r1\"); }\n	public Raptor() { System.out.println(\"r2\"); }\n	{ System.out.println(\"r3\"); }\n	static { System.out.println(\"r4\"); }\n}\npublic class Hello extends Raptor {\n\n    public static void main(String[] args) {\n        System.out.println(\"pre \");\n        new Hello();\n        System.out.println(\"hawk\");\n    }\n}\n		','OOP',0,0,NULL,5),(3072,'BasicFileAttributeView baView = Files.getFileAttributeView(d,BasicFileAttributeView.class);','public static void makeFileCreatedOnMonday(Path d) throws IOException{\n        BasicFileAttributes ba = Files.readAttributes(d, BasicFileAttributes.class);\n        Calendar c = Calendar.getInstance();\n        //BasicFileAttributeView baView = Files.readAttributeView(d,BasicFileAttributes.class)\n        //BasicFileAttributeView baView = Files.getBasicAttributeView(d,BasicFileAttributes.class);\n        //BasicFileAttributeView baView = Files.getFileAttributeView(d,BasicFileAttributes.class);\n        //BasicFileAttributeView baView = Files.getFileAttributeView(d,BasicFileAttributeView.class);\n        \n	//void setTimes(FileTime lastModifiedTime,FileTime lastAccessTime,FileTime createTime)\n        \n        Date creationDate = new Date(ba.creationTime().toMillis());\n        c.setTime(creationDate);\n        \n        if(c.get(Calendar.DAY_OF_WEEK) == Calendar.MONDAY){\n            baView.setTimes(null,null,null);\n        } else {\n            //other fields are retained\n            c.set(Calendar.DAY_OF_WEEK,Calendar.MONDAY);\n            FileTime newDay = FileTime.fromMillis(c.getTimeInMillis());\n            \n            baView.setTimes(null,null,newDay);\n        }\n        \n    }\n\nHow do you create a FileAttributeView ?','Strings',0,0,NULL,5),(3073,'','','blank',0,0,NULL,5),(3074,'compiles with warnings \n\nthe problems will arrise down the road when you get that dog out of a supposedly Integer array. ','psvm(SA){\n	List<Integer> list = new ArrayLIst<>();\n	list.add(5); //autoboxing\n	foo( list );\n}\n\nstatic void foo(List alist) {\n	alist.add(new Dog(\"Charly\"));\n}','Generics',0,0,NULL,5),(3075,'','Generic type information does not exist at runtime - it is for compile-time safetly only.\nMixing generics with legacy code can create compiled code that may throw an excecption at runtime. ','Generics',0,0,NULL,5),(3076,'','polymorphic assingment rules apply everywhere an assignment can be made for generics,\n\nthe following are not allowed:\n	\n	void foo(List<Animal> alist {  }  //cannot take a List<Dog>\n\n	List<Animal> bar() {  }  // cannot return a List<Dog>','Generics',0,0,NULL,5),(3077,'compiles fine','class Animal{\n    public void makeSound() throws InterruptedException {\n            System.out.println(\"Sound!\");\n    }\n}\nclass Dog extends Animal{\n    public void makeSound() throws InterruptedException {\n        System.out.println(\"Bark!\");\n        \n    }\n}\nclass BullDog extends Dog{\n    public void makeSound() throws InterruptedException {\n        System.out.println(\"Grumble!\");\n    }\n}','Generics',0,0,NULL,5),(3078,'BullDog does not compile, Dog\'s makeSound chose not to throw the exception but then when BullDog chose \nto override it didn\'t know that Animal used to throw that exception. ','class Animal{\n    public void makeSound() throws InterruptedException {\n            System.out.println(\"Sound!\");\n    }\n}\nclass Dog extends Animal{\n    public void makeSound(){\n        System.out.println(\"Bark!\");\n        \n    }\n}\nclass BullDog extends Dog{\n    public void makeSound() throws InterruptedException {\n        System.out.println(\"Grumble!\");\n    }\n}','General',0,0,NULL,5),(3079,'does not compile because you cannot return an Animal list from a method declaring a return statemnt\nof Dog list','public class Hello<T> {\n    \n    public static void main(String[] args){\n      Hello<?> x = new Hello<>();\n      \n      List<?> readonlylist = x.dogs();\n      List<?> readonlyanimallist = x.animals();\n        \n\n    } \n    public ArrayList<Animal> animals(){\n        ArrayList<Animal> vetlist = new ArrayList<>();\n        vetlist.add(new Animal());\n        vetlist.add(new BullDog());\n        vetlist.add(new BullDog());\n        vetlist.add(new Dog());\n        vetlist.add(new Animal());\n        \n        return vetlist;\n  \n    }\n    \n    public ArrayList<Dog> dogs(){\n        ArrayList<Animal> vetlist = new ArrayList<>();\n        vetlist.add(new Dog());\n        vetlist.add(new BullDog());\n        vetlist.add(new BullDog());\n        vetlist.add(new Dog());\n        vetlist.add(new Dog());\n\n        return vetlist;\n    }','Generics',0,0,NULL,5),(3080,'','Wildcard syntax allows a generic method to accept subtypes or supertypes of the declared type\nof the method argument.\n\n	void addD(List<Dog> d) {  } //can take only <Dog>\n	\n	void addD(List<? extends Dog>) { } //take a <Dog> or <Beagle>','Generics',0,0,NULL,5),(3081,'','The wildcard keyword \'extends\' is used to mean either \" extends \" or \"implements\" \n\nso in <? extends Dog> Dog can be a class or interface. ','Generics',0,0,NULL,5),(3082,'','When using a wildcard List<? extends Dog>, the collection can be accessed but not modified','Generics',0,0,NULL,5),(3083,'','When using a wildcard List<?> any generic type can be assigned to the reference, but for access only\nno modifications.','Generics',0,0,NULL,5),(3084,'','List<Object> refers only to a List<Object>, while List<?> or List<? extends Object> can hold \nany type of object, but for access only. \n\n','Generics',0,0,NULL,5),(3085,'got it ','The generic type identifier can be used in class, method, and variable declarations:\n\n	class Foo<t> { }\n	T anInstance;\n	Foo(T aRef) { } // a constructor argument\n	void bar(T aRef) {  }	//method argument\n	T baz() { }	//return type','Generics',0,0,NULL,5),(3086,'','You can declare a generic method using a type not defined in the class:\n	\n	public <T> void makeList(T t) { }\n\n\n    This is not using T as a return type. This method has a void return type, but to use T within the argument you must declare the <T>\n	which happens before the return type. ','Generics',0,0,NULL,5),(3087,'List<List<Integer>> table = new ArrayList<>();\n\nList<List<Integer>> table = new ArrayList<List<Integer>>();\n\n	not this:\n		List<List<Integer>> superlist1 = new ArrayList<ArrayList<Integer>>();\n\n	.... incompatible types','psvm(SA){\n	for(int i = 0; i<= 10; i++) {\n		List<Integer> row = new ArrayList<>();\n		for (int j = 0; j<= 10; j++)\n		         row.add(i*j);\n		table.add(row);\n	}\n	for(List<Integer> row : table)\n		sout(row);\n}\n\ndefine table','Generics',0,0,NULL,5),(3088,'2 is true because often two dissiimilar objects can return the same hashcode value.\n\n4 is true because if the hashCode() comparison == returns true, might or might not be equal. \n\n3 is incorrect because often two dissimilar objects can return the same hashcode value. \n\n1 and 5 are a negation of the equals and hashCode() contract','Which statements are true about comparing two instances of the same class \ngiven that equals() and hashCode() have been properly overriden\n\n1 if the equals() returns true, the hashCode() comparison == might return false\n\n2 if the equals() returns false, the hashCode() comparison == might return true\n\n3 if the hashCode() comparison == returns true, the equals() method must return true\n\n4 if the hashCode() comparison == returns true, the equals() method might return true\n\n5 if the hashCode() comparison != returns true, the equals() method might return true','Generics',0,0,NULL,5),(3089,'got it\n','IF TWO OBJECTS ARE EQUAL ACCORDING TO THE EQUALS(OBJECT) METHOD, THE CALLING THE HASHCODE()\nMETHOD ON EACH OF THE TWO OBJECT MUST PRODUCE THE SAME INTEGER RESULT. ','Generics',0,0,NULL,5),(3090,'','It is not required that if two object are unequal according to the dquals method, the calling the hashCode()\non each of the two objects must produce distinct integer results. ','Generics',0,0,NULL,5),(3091,'ClassCastException','public static void before() {\n	Set set = new TreeSet();\n	set.add(\"2\");\n	set.add(3);\n	set.add(\"1);\n	Iterator it = set.iterator();\n		while(it.hasNext() )\n	sout( it.next() );\n}\n','Generics',0,0,NULL,5),(3092,'Change Herbivore interface to\n	\n	 interface Herbivore<E extends Animal> extends Hungry<E> { }','interface Hungry<E> { void munch(E x); }\ninterface Carnivore<E extends Animal> extends Hungry<E> { }\ninterface Herbivore<E extends Plant> extends Hungry<E> { }\nabstract class Plant { }\nabstract class Animal { }\nclass Grass extends Plant { }\nclass Sheep extends Animal implements Herbivore<Sheep> {\n    public void munch (Sheep x){ }\n}\nclass Wolf extends Animal implements Carnivore<Sheep> {\n    public void munch(Sheep x) { }\n}\n\nwhat can you change to make this compile','Generics',0,0,NULL,5),(3093,'Sheep does not compile,\n\n	Sheep is not abstract and does not override abstract method munch(Plant) in Hungry','interface Hungry<E> { void munch(E x); }\ninterface Carnivore<E extends Animal> extends Hungry<E> { }\ninterface Herbivore<E extends Plant> extends Hungry<E> { }\nabstract class Plant { }\nabstract class Animal { }\nclass Grass extends Plant { }\nclass Sheep extends Animal implements Herbivore<Plant> {\n    public void munch (Sheep x){ }\n}\nclass Wolf extends Animal implements Carnivore<Sheep> {\n    public void munch(Sheep x) { }\n}','Generics',0,0,NULL,5),(3094,'compiles and runs no problem','public class Hello<T> {\n  public static void main(String[] args){\n      Sheep bella = new Sheep();\n      \n      bella.munch(new Grass());\n      \n  }\n      \n}\n\ninterface Hungry<E> { void munch(E x); }\ninterface Carnivore<E extends Animal> extends Hungry<E> { }\ninterface Herbivore<E extends Plant> extends Hungry<E> { }\nabstract class Plant { }\nabstract class Animal { }\nclass Grass extends Plant { }\nclass Sheep extends Animal implements Herbivore<Plant> {\n    public void munch (Plant x){ }\n}\nclass Wolf extends Animal implements Carnivore<Sheep> {\n    public void munch(Sheep x) { }\n}','Generics',0,0,NULL,5),(3095,'The variable c of type ArrayList<? super Beagle> could possibly hold an instance of \nArrayList<Beagle>, ArrayList<Dog>, ArrayList<Animal>, or ArrayList<Object>.\n If it happened to be set to an ArrayList<Beagle>, it would violate the generic type to add a Dog to it.\n The compiler can\'t track what you actually assign to the ArrayList<? super Beagle> variable over the course of the program, \nso it assumes the worst and prevents the possible type safety violation. ','public class Hello<T> {\n\n   public static void main(String[] args){\n\n    Dog d = new Dog();\n\n    ArrayList<? super Beagle> c = makeArrayList(d);\n\n    c.add(new Beagle());\n    c.add(new Beagle());\n    c.add(new Dog());    \n  } \n\n  public static <G extends Animal> ArrayList<G> makeArrayList(G g){\n    ArrayList<G> genlist = new ArrayList<>();\n    genlist.add(g);\n    return genlist;\n\n }\n}\n\n\nclass Animal{public void makeSound(){\n        System.out.println(\"Sound!\");\n }\n}   \n class Dog extends Animal{}\nclass Beagle extends Dog{}','Generics',0,0,NULL,5),(3096,'For example, if the department of motor vehicles supplies a list of drivers to the census bureau, this seems reasonable. We think that a List<Driver> is a List<Person>, assuming that Driver is a subtype of Person. In fact, what is being passed is a copy of the registry of drivers. Otherwise, the census bureau could add new people who are not drivers into the list, corrupting the DMV\'s records.','Let\'s test your understanding of generics. Is the following code snippet legal?\n\nList<String> ls = new ArrayList<String>(); // 1\nList<Object> lo = ls; // 2 \n\nLine 1 is certainly legal. The trickier part of the question is line 2. This boils down to the question: is a List of String a List of Object. Most people instinctively answer, \"Sure!\"\n\nWell, take a look at the next few lines:\n\nlo.add(new Object()); // 3\nString s = ls.get(0); // 4: Attempts to assign an Object to a String!\n\nHere we\'ve aliased ls and lo. Accessing ls, a list of String, through the alias lo, we can insert arbitrary objects into it. As a result ls does not hold just Strings anymore, and when we try and get something out of it, we get a rude surprise.\n\nThe Java compiler will prevent this from happening of course. Line 2 will cause a compile time error.\n\nIn general, if Foo is a subtype (subclass or subinterface) of Bar, and G is some generic type declaration, it is not the case that G<Foo> is a subtype of G<Bar>. This is probably the hardest thing you need to learn about generics, because it goes against our deeply held intuitions.\n\nWe should not assume that collections don\'t change. Our instinct may lead us to think of these things as immutable.','Generics',0,0,NULL,5),(3097,'static <T> void fromArrayToCollection(T[] a, Collection<T> c) {\n    for (T o : a) {\n        c.add(o); // Correct\n    }\n}','static void fromArrayToCollection(Object[] a, Collection<?> c) {\n    for (Object o : a) { \n        c.add(o); // compile-time error\n    }\n}\n\nfix this with a generic method....','Generics',0,0,NULL,5),(3098,'','\n\nNo, a List<Dog> is not a List<Animal>. Consider what you can do with a List<Animal> - you can add any animal to it... including a cat. Now, can you logically add a cat to a litter of puppies? Absolutely not.\n\n// Illegal code - because otherwise life would be Bad\nList<Dog> dogs = new ArrayList<Dog>(); // ArrayList implements List\nList<Animal> animals = dogs; // Awooga awooga\nanimals.add(new Cat());\nDog dog = dogs.get(0); // This should be safe, right?\n\nSuddenly you have a very confused cat.\n\nNow, you can\'t add a Cat to a List<? extends Animal> because you don\'t know it\'s a List<Cat>. \nYou can retrieve a value and know that it will be an Animal, but you can\'t add arbitrary animals. \nThe reverse is true for List<? super Animal> - in that case you can add an Animal to it safely, but you don\'t know anything about what might be retrieved from it, because it could be a List<Object>.\n','Generics',0,0,NULL,5),(3099,'compiles fine...\n\nHerbivore<Plant> extends Hungry<Plant> works because the type is a parameter just like the formal \nparameters. So it is not necessary that a subinterface has the same parameters as long as its indicated that\nit does in fact take a type parameter. \n\nIn a nutshell, generics enable types (classes and interfaces) to be parameters when defining classes, interfaces and methods. Much like the more familiar formal parameters used in method declarations, type parameters provide a way for you to re-use the same code with different inputs. The difference is that the inputs to formal parameters are values, while the inputs to type parameters are types.\n\nits the same reason why List<E>, an interface, has to be the same as = new ArrayList<E> but not the \nsame as all other Lists\n\nList<String> list = new ArrayList<String>();\n	\n	ArrayList implements List just like Herbivore extends Hungry.','public class Hello<T> {\n  public static void main(String[] args){\n      Sheep bella = new Sheep();\n      \n  }\n      \n}\n\ninterface Hungry<E> { void munch(E x); }\ninterface Carnivore<E extends Animal> extends Hungry<E> { }\ninterface Herbivore<Plant> extends Hungry<Plant> { }\nabstract class Plant { }\nabstract class Animal { }\nclass Grass extends Plant { }\nclass Sheep extends Animal implements Herbivore<Grass> {\n    public void munch (Grass x){ }\n}\nclass Wolf extends Animal implements Carnivore<Sheep> {\n    public void munch(Sheep x) { }\n}','Generics',0,0,NULL,5),(3100,'','Raw Types\n\nA raw type is the name of a generic class or interface without any type arguments. For example, given the generic Box class:\n\npublic class Box<T> {\n    public void set(T t) { /* ... */ }\n    // ...\n}\n\nTo create a parameterized type of Box<T>, you supply an actual type argument for the formal type parameter T:\n\nBox<Integer> intBox = new Box<>();\n\nIf the actual type argument is omitted, you create a raw type of Box<T>:\n\nBox rawBox = new Box();\n\nTherefore, Box is the raw type of the generic type Box<T>. However, a non-generic class or interface type is not a raw type.\n\nRaw types show up in legacy code because lots of API classes (such as the Collections classes) were not generic prior to JDK 5.0. When using raw types, you essentially get pre-generics behavior — a Box gives you Objects. For backward compatibility, assigning a parameterized type to its raw type is allowed:\n\nBox<String> stringBox = new Box<>();\nBox rawBox = stringBox;               // OK\n\nBut if you assign a raw type to a parameterized type, you get a warning:\n\nBox rawBox = new Box();           // rawBox is a raw type of Box<T>\nBox<Integer> intBox = rawBox;     // warning: unchecked conversion\n\nYou also get a warning if you use a raw type to invoke generic methods defined in the corresponding generic type:\n\nBox<String> stringBox = new Box<>();\nBox rawBox = stringBox;\nrawBox.set(8);  // warning: unchecked invocation to set(T)\n\nThe warning shows that raw types bypass generic type checks, deferring the catch of unsafe code to runtime. Therefore, you should avoid using raw types.','Generics',0,0,NULL,5),(3101,'compiles fine \n\ngeneric typed objects can be assigned to raw types.','class Driver<E>{\n    \n}\nabstract class Auto{}\nclass Truck extends Auto{}\nclass Car extends Auto{}\n\npublic class Hello<T> {\n  public static void main(String[] args){\n      Driver<Truck> truckdriver = new Driver<>();\n      Driver untypeddriver = truckdriver;\n      \n      List biglist = new ArrayList<String>();\n      \n  }\n      \n}','Generics',0,0,NULL,5),(3102,'compiles fine, raw type reerences that are assinged to typed objects still take objects.','public class Hello<T> {\n  public static void main(String[] args){\n      \n      List biglist = new ArrayList<String>();\n      \n      biglist.add(8);\n      biglist.add(\"bigdick\");\n      \n  }\n      \n}','Generics',0,0,NULL,5),(3103,'compiles fine,  but you can still add anything to biglist','public class Hello<T> {\n  public static void main(String[] args){\n      Driver<Truck> truckdriver = new Driver<>();\n      Driver untypeddriver = truckdriver;\n      \n      List biglist = new ArrayList<Driver<Truck>>();\n      \n      biglist.add(8);\n      biglist.add(\"bigdick\");\n      \n  }\n      \n}','Generics',0,0,NULL,5),(3104,'fine','public class Hello {\n  public static void main(String[] args){\n      Driver<Truck> truckdriver = new Driver();\n      \n      testmethod(new Driver<Truck>());   \n  }\n  \n  public static void testmethod(Object x){\n      // do something\n  }\n      \n}','Generics',0,0,NULL,5),(3105,' You can subtype a generic class or interface by extending or implementing it. The relationship between the type parameters of one class or interface and the type parameters of another are determined by the extends and implements clauses.\n\nUsing the Collections classes as an example, ArrayList<E> implements List<E>, and List<E> extends Collection<E>. So ArrayList<String> is a subtype of List<String>, which is a subtype of Collection<String>. So long as you do not vary the type argument, the subtyping relationship is preserved between the types.\ndiagram showing a sample collections hierarchy: ArrayList<String> is a subtype of List<String>, which is a subtype of Collection<String>.\nA sample Collections hierarchy\n\nNow imagine we want to define our own list interface, PayloadList, that associates an optional value of generic type P with each element. Its declaration might look like:\n\ninterface PayloadList<E,P> extends List<E> {\n  void setPayload(int index, P val);\n  ...\n}\n\nThe following parameterizations of PayloadList are subtypes of List<String>:\n\n    PayloadList<String,String>\n    PayloadList<String,Integer>\n    PayloadList<String,Exception>\n','Generic Classes and Subtyping','Generics',0,0,NULL,5),(3106,' As you already know, it is possible to assign an object of one type to an object of another type provided that the types are compatible. For example, you can assign an Integer to an Object, since Object is one of Integer\'s supertypes:\n\nObject someObject = new Object();\nInteger someInteger = new Integer(10);\nsomeObject = someInteger;   // OK\n\nIn object-oriented terminology, this is called an \"is a\" relationship. Since an Integer is a kind of Object, the assignment is allowed. But Integer is also a kind of Number, so the following code is valid as well:\n\npublic void someMethod(Number n) { /* ... */ }\n\nsomeMethod(new Integer(10));   // OK\nsomeMethod(new Double(10.1));   // OK\n\nThe same is also true with generics. You can perform a generic type invocation, passing Number as its type argument, and any subsequent invocation of add will be allowed if the argument is compatible with Number:\n\nBox<Number> box = new Box<Number>();\nbox.add(new Integer(10));   // OK\nbox.add(new Double(10.1));  // OK\n\nNow consider the following method:\n\npublic void boxTest(Box<Number> n) { /* ... */ }\n\nWhat type of argument does it accept? By looking at its signature, you can see that it accepts a single argument whose type is Box<Number>. But what does that mean? Are you allowed to pass in Box<Integer> or Box<Double>, as you might expect? The answer is \"no\", because Box<Integer> and Box<Double> are not subtypes of Box<Number>.\n\nThis is a common misunderstanding when it comes to programming with generics, but it is an important concept to learn.\ndiagram showing that Box<Integer> is not a subtype of Box<Number>\nBox<Integer> is not a subtype of Box<Number> even though Integer is a subtype of Number.\nNote: Given two concrete types A and B (for example, Number and Integer), MyClass<A> has no relationship to MyClass<B>, regardless of whether or not A and B are related. The common parent of MyClass<A> and MyClass<B> is Object.','Generics, Inheritance, and Subtypes','Generics',0,0,NULL,5),(3107,'','List<? extends Integer> intList = new ArrayList<>();\nList<? extends Number>  numList = intList;  // OK. List<? extends Integer> is a subtype of List<? extends Number>','Generics',0,0,NULL,5),(3108,'compilation fails,\n\ninterface methods are implicityl public abstract so when you overid them like munch in Panda you have to say\npublic . ','interface Hungry<E> { void munch(E x); }\ninterface Carnivore<E extends Animal> extends Hungry<E> { }\n\ninterface Herbivore<Plant> extends Hungry<Plant> { }\n\n\ninterface Pineavore<Pine> extends Herbivore<Plant> { }\n\n\n\nclass Panda implements Herbivore<Pine>{  \n    void munch(Pine x){\n            System.out.println(\"eat pines\");\n    };\n} \nclass Chamelion implements Herbivore<Flowers>{ \n    public void munch(Flowers x){ } \n}','Generics',0,0,NULL,5),(3109,'will not compile, when you implement a generic interface, you must provide a type similarly you cannot say\nnew Thing<E>();','interface Hungry<E> { void munch(E x); }\n\nclass Driver<E> implements Hungry<T>{\n    public void munch(T food){\n        \n    }\n    \n}','Generics',0,0,NULL,5),(3110,'Panda does not compile \n\ndoes not override abstract method munch(Plant) in class Hungry.\n\n	','interface Hungry<E> { void munch(E x); }\n\ninterface Herbivore<Grass> extends Hungry<Plant> { }\n\nclass Panda implements Herbivore<Grass>{  \n        public void munch(Grass x){\n            System.out.println(\"eat pines\");\n    };\n} \n\nabstract class Animal { }\nabstract class Plant { }\nclass Grass extends Plant { }','Generics',0,0,NULL,5),(3111,'ArrayList','Which collection class allows you to grow or shrink its size and provide indexed access to its elements,\nbut whose methods are not synhcronized ?','Generics',0,0,NULL,5),(3112,'1 ArrayList<Integer> input = null;\n   List<Integer> output = null;\n\n2 List<Number> input = null;\n    List<Number> output = null\n\n3  List<Integer> input = null\n   List<Integer> output = null;\n\n\nThe return type is List so the output has to be a list it cant be arraylist. \nwhatever the input is thats what the output will be so input and output have to be the same type\nand the type has to be something that extends Number','public static <E extends Number> List<E> process(List<E> nums)\n\n// declare input and output\n\noutput = process(input);\n\n','Generics',0,0,NULL,5),(3113,'2\n2\n3 4\n\nfor the sake of the exam add and offer both add to naturally sorted collections \nso here the order becomes the natural order. \n\neven strings get sorted numerically.\n\n','public class Hello {\n  public static void main(String[] args){\n      PriorityQueue<String> pq = new PriorityQueue<String>();\n      pq.add(\"2\");\n      pq.add(\"4\");\n      System.out.println(pq.peek());\n      pq.offer(\"1\");\n      pq.add(\"3\");\n      pq.remove(\"1\");\n      System.out.println(pq.poll());\n      if(pq.remove(\"2\")) System.out.println(pq.poll());\n      System.out.println(pq.poll() + \" \" + pq.peek());\n  }\n   \n}','Generics',0,0,NULL,5),(3114,'1 2 2 4 3 5 67 7 \n1 2 2 3 4 5 67 7\n\nString only looks at the first charater so 67 is the same as 6','public class Hello {\n  public static void main(String[] args){\n      PriorityQueue<String> pq = new PriorityQueue<String>();\n      pq.add(\"2\");\n      pq.add(\"4\");\n\n      pq.offer(\"1\");\n      pq.add(\"3\");\n      \n      pq.add(\"2\");\n      pq.offer(\"5\");\n      \n      pq.add(\"67\");\n      pq.add(\"7\");\n      \n      for(String x : pq)\n          System.out.print(x+\" \");\n      \n      System.out.println(\"\");\n      \n      for(int x = 0; x <8; x++)\n          System.out.print(pq.poll()+\" \");\n\n  }\n   \n}','Generics',0,0,NULL,5),(3115,'2\n\nthe size is two when hashCode is implementd this imp. will place all turtles with size 1 in the same bucket\n\nsize() counts the buckets.\n\nif hashCode was not implemented then every entry would go into its own bucket and the size would be\n12\n\n','public class Hello {\n  public static void main(String[] args){\n      LinkedHashSet<Turtle> t = new LinkedHashSet<>();\n      t.add(new Turtle(1)); t.add( new Turtle(2)); t.add(new Turtle(1));\n      t.add(new Turtle(1)); t.add( new Turtle(2)); t.add(new Turtle(1));\n      t.add(new Turtle(1)); t.add(new Turtle(1)); t.add(new Turtle(1));\n      t.add(new Turtle(1)); t.add(new Turtle(1)); t.add(new Turtle(1));\n      \n      System.out.println(t.size());\n\n  }\n   \n}\n\ninterface Hungry<E> { void munch(E x); }\nabstract class Animal { }\nabstract class Plant { }\nclass Grass extends Plant { }\n\nclass Turtle {\n    int size;\n    public Turtle(int z){\n        size = z;\n    }\n    \n    public boolean equals(Object o){\n        return (this.size == ((Turtle)o).size);\n    }\n    \n    public int hashCode() { return size/5; }\n}','Generics',0,0,NULL,5),(3116,'classcastexception','class Grass extends Plant { }\n\npublic class Hello {\n  public static void main(String[] args){\n     TreeSet<Grass> grassset = new TreeSet<>();\n     grassset.add(new Grass());\n\n  }\n   \n}','Generics',0,0,NULL,5),(3117,'The output will contain a -1\n\n\"pen marble map key\" \n\n.binarySearch has to be invoked with the same Comparator that created it. \n	here it doesn\'t know how the array is sorted so it gives insertion point','public class GeoCache {\n	public static void main(String[ ]args) {\n		String[] s = {\"map\",\"pen\",\"marble\",\"key\"};\n		Othello o = new Othello();\n		Arrays.sort(s,o);\n		for(String s2: s) sout(s2+\" \");\n		sout( Arrays.binarySearch(s,\"map\");\n	}\n\n	static class Othello implements Comparator<String> {\n		public int compare(String a, String b) { return b.compareTo(a);l }\n	}\n}\n		','Collections',0,0,NULL,5),(3118,'One good usage of inner classes that comes into my mind is in java.util.ArrayList that hides its iterators implementations into private inner classes. You can\'t create them except by invoking iterator() or listIterator() on the list object.\n\nThis way the Iterator and ListIterator implementations for ArrayList are grouped with their related class and methods for enhanced readability (the implementations are pretty short), but hidden from others.\n\nThey can\'t be declared static as they need access to their enclosing instance object.','public class ArrayList<E> extends AbstractList<E>\n         implements List<E>, RandomAccess, Cloneable, java.io.Serializable {\n    ...\n    public Iterator<E> iterator() {\n         return new Itr();\n    }\n\n    private class Itr implements Iterator<E> {\n    ...\n    }\n\n    public ListIterator<E> listIterator() {\n         return new ListItr(0);\n    }\n\n    private class ListItr extends Itr implements ListIterator<E> {\n    ...\n    }\n}','General',0,0,NULL,5),(3119,'foo 7\n\ncompiles fine, you need the outer classes reference for a regular inner class\n\nthe inner class can be created as such from within the enclosing class. \n\ncould also be Inner a = new Inner();','public class Hello {\n    private int secretnum = 7;\n    \n  public static void main(String[] args){\n     Hello h = new Hello();\n     h.createInner();\n\n  }\n  \n  public void createInner(){\n      Hello.Inner a = new Hello.Inner();\n      a.foo(); a.seeOuter();\n  }\n  \n  \n  class Inner {\n      public void seeOuter(){\n          System.out.println(secretnum);\n      }\n      \n      void foo(){\n          System.out.println(\"Foo\");\n      }\n  }\n   \n}','Inner Classes',0,0,NULL,5),(3120,'WNC,\n\nNo static declarations are allowed in regular inner classes unless they \nare final.\n\nThe creation of a is legal though redundant, it could have been:\n\n	Inner a = new Inner();\n','public class Hello {\n    private int secretnum = 7;\n    \n  public static void main(String[] args){\n     Hello h = new Hello();\n     h.createInner();\n\n  }\n  \n  public void createInner(){\n      Hello.Inner a = new Hello.Inner();\n      a.foo(); a.seeOuter();\n  }\n  \n  \n  class Inner {\n      private static int verysecret = 8;\n      \n      public void seeOuter(){\n          System.out.println(secretnum);\n      }\n      \n      void foo(){\n          System.out.println(\"Foo\");\n      }\n  }','Inner Classes',0,0,NULL,5),(3121,'compiles fine, if an inner class is going to have static member it has to be final','public class Hello {\n    private int secretnum = 7;\n    \n  public static void main(String[] args){\n     Hello h = new Hello();\n     h.createInner();\n\n  }\n  \n  public void createInner(){\n      Hello.Inner a = new Hello.Inner();\n      a.foo(); a.seeOuter();\n  }\n  \n  \n  class Inner {\n      private static final int verysecret = 8;\n      \n      public void seeOuter(){\n          System.out.println(secretnum);\n      }\n      \n      void foo(){\n          System.out.println(\"Foo\");\n      }\n  }\n   \n}','Inner Classes',0,0,NULL,5),(3122,'apple carrot orange plum\n\nwith arraylist you can add(int index, object elemetn) to a specific index','public class sequence {\n	psvm(sa){\n		ArrayList<String> list = new ArrayList<>();\n		list.add(\"apple\");\n		list.add(\"organe\");\n		list.add(\"plum\");\n		list.add(1,\"carrot\");\n		sout( list );\n	}\n}','Collections',0,0,NULL,5),(3123,'will not compile,\n\ninner classes are the same as class instance variables so naturally you cannot access \nthem from a static context. ','public class Hello {\n    private int secretnum = 7;\n    \n    public static void main(String[] args){\n        Inner in = new Inner();\n\n    }\n  \n     class Inner {\n        private static final int verysecret = 8;\n        void foo(){\n          System.out.println(\"Foo\");\n        } \n  }\n   \n}','Inner Classes',0,0,NULL,5),(3124,'compiles fine','public class Hello {\n    private int secretnum = 7;\n    \n    public static void main(String[] args){\n        Hello h = new Hello();\n        Hello.Inner in = h.new Inner();\n\n    }\n  \n     class Inner {\n        private static final int verysecret = 8;\n        void foo(){\n          System.out.println(\"Foo\");\n        } \n  }\n   \n}','Inner Classes',0,0,NULL,5),(3125,'When instantiating from a static method You have to provide the Outer class name\n\nthe inner class is just a like an instance member. \n\nbut in the instance method its easy to create the inner class normally. \n\nits the same to create a new inner class in the static method as it is from another class.\n\n\nThis was one is also confusing because it has a mistakenly named method \nthat looks like a constructor. But its not. ','public class Hello {\n    private int secretnum = 7;\n    private static Inner inner;\n    \n    public static void main(String[] args){\n        Hello h = new Hello();\n        Hello.Inner in = h.new Inner();\n        \n        Hello.Inner in2 = h.new Inner();\n        \n        Hello.Inner in3 = new Hello().new Inner();\n        \n        inner = h.new Inner();\n        \n        //Inner a = new Inner(); this would not work\n        \n\n    }\n    \n    public void instancemaker(){\n        Inner a = new Inner();\n        System.out.println(a.verysecret);\n    }\n  \n     class Inner {\n        private static final int verysecret = 8;\n        \n        public void Inner(int x){\n            \n        }\n        void foo(){\n          System.out.println(\"Foo\");\n        } \n  }\n   \n}','Inner Classes',0,0,NULL,5),(3126,'public class Hello {\n    private int secretnum = 7;\n    public static void main(String[] args) {}\n    class Inner {  private static final int verysecret = 8; }\n}\n\nclass Dog extends Hello { class Innerdog extends Inner{ } }','public class Hello {\n    private int secretnum = 7;\n    public static void main(String[] args) {}\n    class Inner {  private static final int verysecret = 8; }\n}\n\nclass Dog extends Hello.Inner {}\n\nchange this code so it compiles, and creates a class that extends Hello.Inner','Inner Classes',0,0,NULL,5),(3127,'class Dog extends Hello{ class Inner extends Hello.Inner { } }','public class Hello {\n    private int secretnum = 7;\n    public static void main(String[] args) {}\n    class Inner {  private static final int verysecret = 8; }\n}\n\nclass Dog extends Hello{ class Inner extends Inner { } }\n\nthis is illegal what could make it legal ?','Inner Classes',0,0,NULL,5),(3128,'good example of an anonymous inner class from opennlp','public Iterator<String> iterator() {\n    return new Iterator<String>() {\n\n      private int index;\n\n      public boolean hasNext() {\n        return index < size();\n      }\n\n      public String next() {\n\n        if (hasNext()) {\n          return getToken(index++);\n        }\n        else {\n          throw new NoSuchElementException();\n        }\n      }\n\n      public void remove() {\n        throw new UnsupportedOperationException();\n      }\n\n    };\n  }','Inner Classes',0,0,NULL,5),(3129,'good example of anonymous inner class','public Iterator<String> iterator() {\n    return new Iterator<String>() {\n\n      private int index;\n\n      public boolean hasNext() {\n        return index < size();\n      }\n\n      public String next() {\n\n        if (hasNext()) {\n          return getToken(index++);\n        }\n        else {\n          throw new NoSuchElementException();\n        }\n      }\n\n      public void remove() {\n        throw new UnsupportedOperationException();\n      }\n\n    };\n  }','Inner Classes',0,0,NULL,5),(3130,'fine\ngood example of;\nStringTokenizer\nBufferedReader\n\n','public static Dictionary parseOneEntryPerLine(Reader in) throws IOException {\n    BufferedReader lineReader = new BufferedReader(in);\n\n    Dictionary dictionary = new Dictionary();\n\n    String line;\n\n    while ((line = lineReader.readLine()) != null) {\n      StringTokenizer whiteSpaceTokenizer = new StringTokenizer(line, \" \");\n\n      String[] tokens = new String[whiteSpaceTokenizer.countTokens()];\n\n      if (tokens.length > 0) {\n        int tokenIndex = 0;\n        while (whiteSpaceTokenizer.hasMoreTokens()) {\n          tokens[tokenIndex++] = whiteSpaceTokenizer.nextToken();\n        }\n\n        dictionary.put(new StringList(tokens));\n      }\n    }\n\n    return dictionary;\n  }','General',0,0,NULL,5),(3131,'will not compile \nreadLine() method throws IOException\n\nmust be caught or thrown!','public static Dictionary parseOneEntryPerLine(Reader in)  {\n    BufferedReader lineReader = new BufferedReader(in);\n\n    Dictionary dictionary = new Dictionary();\n\n    String line;\n\n    while ((line = lineReader.readLine()) != null) {\n      StringTokenizer whiteSpaceTokenizer = new StringTokenizer(line, \" \");\n\n      String[] tokens = new String[whiteSpaceTokenizer.countTokens()];\n\n      if (tokens.length > 0) {\n        int tokenIndex = 0;\n        while (whiteSpaceTokenizer.hasMoreTokens()) {\n          tokens[tokenIndex++] = whiteSpaceTokenizer.nextToken();\n        }\n\n        dictionary.put(new StringList(tokens));\n      }\n    }\n\n    return dictionary;\n  }','IO',0,0,NULL,5),(3132,'1=Bell\n3=Whistle\n5=Nic\n\ninner classes can have static members only if they are final','public class Hello {\n    private int secretnum = 7;\n    public static void main(String[] args) {\n        Map<Integer,String> hellomap = new HashMap();\n        hellomap.put(1,\"Bell\");\n        hellomap.put(3,\"Whistle\");\n        hellomap.put(5,\"Nic\");\n        \n        for(Entry<Integer,String> x : hellomap.entrySet()){\n            System.out.println(x);\n        }\n    \n    }\n    public class Inner {  private static final int verysecret = 8; }\n}','Inner Classes',0,0,NULL,5),(3133,'EvenIterator will not compile is not abstract and does not impelemnt next() in Iterator()\n\nThis shows that since DSIterator extends Iterator the first concrete class has to be the one to \nimplement the interfaces methods. ','public class Hello {\n    private final static int SIZE = 25;\n    private int[] array = new int[SIZE];\n    \n    public Hello(){\n        for(int i = 0; i<SIZE; i++){\n            array[i] = i;\n        }\n    }\n    \n    public void printEven(){\n        \n    }\n    \n    interface DSIterator extends java.util.Iterator<Integer> { }\n    \n    private class EvenIterator implements DSIterator{\n        \n    }\n    \n\n    public static void main(String[] args) {\n\n    \n    }\n\n}','General',0,0,NULL,5),(3134,'will not compile print() cannot be called from a static context.','public class Hello {\n    private final static int SIZE = 100;\n    private int[] array = new int[SIZE];\n    \n    public Hello(){\n        for(int i = 0; i<SIZE; i++){\n            array[i] = i;\n        }\n    }\n    \n    public void print(){\n        ThirdIterator it = new ThirdIterator();\n        while(it.hasNext()){\n            System.out.print(it.next() +\" \");\n        }\n        \n    }\n    \n    interface DSIterator extends java.util.Iterator<Integer> { }\n    \n    private class ThirdIterator implements DSIterator{\n        private int nextIndex = 0;\n        \n        public boolean hasNext(){\n            return (nextIndex <= SIZE - 1);\n        }\n        \n        public Integer next(){\n            Integer retValue = Integer.valueOf(array[nextIndex]);\n            \n            nextIndex += 3;\n            return retValue;\n            \n        }\n        \n    }\n    \n\n    public static void main(String[] args) {\n        print();\n    \n    }\n\n}','General',0,0,NULL,5),(3135,'0 3 6 9 12 15 18 21 24 27 30 33 36 39 42 45 48 51 54 57 60 63 66 69 72 75 78 81 84 87 90 93 96 99','public class Hello {\n    private final static int SIZE = 100;\n    private int[] array = new int[SIZE];\n    \n    public Hello(){\n        for(int i = 0; i<SIZE; i++){\n            array[i] = i;\n        }\n    }\n    \n    public void print(){\n        ThirdIterator it = new ThirdIterator();\n        while(it.hasNext()){\n            Object i = it.next();\n            //System.out.print(it.next() +\" \");\n        }\n        \n    }\n    \n    interface DSIterator extends java.util.Iterator { }\n    \n    private class ThirdIterator implements DSIterator{\n        private int nextIndex = 0;\n        \n        public boolean hasNext(){\n            return (nextIndex <= SIZE - 1);\n        }\n        \n        public Integer next(){\n            Integer retValue = Integer.valueOf(array[nextIndex]);\n            \n            nextIndex += 3;\n            return retValue;\n            \n        }\n        \n    }\n    \n\n    public static void main(String[] args) {\n        Hello h = new Hello();\n        h.print();\n    \n    }\n\n}','General',0,0,NULL,5),(3136,'if a final variable is static it has be intitialized right away.\n\nWhere a final instance varialbe must be intitialized at some point either in the constructor or upon creation.\n\n','public class Hello {\n    private final static int SIZE;\n    private int[] array;\n    \n    public Hello(int size){\n        this.SIZE = size;\n        \n        array = new int[SIZE];\n        \n        for(int i = 0; i<SIZE; i++){\n            array[i] = i;\n        }\n    }\n}','General',0,0,NULL,5),(3137,'Will not compile \n\nfinal variable SIZE is never initialized in default constructor or otherwise and this is a compilererror','public class Hello {\n    private final int SIZE;\n    private int[] array;\n    \n    public void print(){\n        ThirdIterator it = new ThirdIterator();\n        while(it.hasNext()){\n            Integer i = it.next();\n            //System.out.print(it.next() +\" \");\n        }\n        \n    }\n\n}','General',0,0,NULL,5),(3138,'final Variable SIZE in Hello is not intitialized in constructor \n\ncannot assign a value to final variable SIZE in innerclass ThirdIterator\n\nnon static third iterator class cannot be referenced from static main.\n\n','public class Hello {\n    private final int SIZE;\n    private int[] array;\n    \n    interface DSIterator extends java.util.Iterator<Integer> { }\n    \n    private class ThirdIterator implements DSIterator{\n        private int nextIndex = 0;\n        public ThirdIterator(){\n            SIZE = 100;\n            for(int ix=0; ix<SIZE; ix++){\n                array[ix] = ix;\n            }\n        }\n        \n        public boolean hasNext(){\n            return (nextIndex <= SIZE - 1);\n        }\n        \n        public Integer next(){\n            Integer retValue = Integer.valueOf(array[nextIndex]);\n            \n            nextIndex += 3;\n            return retValue;\n            \n        }\n        \n    }\n    \n    private static class EveryFourth implements DSIterator{\n        private int nextIndex = 0;\n        private static final int SIZE = 1000;\n        private int[] array = new int[SIZE];\n        \n        public EveryFourth(){\n           for(int i =0; i<100; i++){\n               array[i] = i;\n           }\n        }\n        \n        public boolean hasNext(){\n            return (nextIndex <= SIZE-1);\n        }\n        \n        public Integer next() {\n            Integer retValue = Integer.valueOf(array[nextIndex]);\n            \n            nextIndex += 4;\n            return retValue;\n        }\n    }\n    \n\n    public static void main(String[] args) {\n        EveryFourth a = new EveryFourth();\n        ThirdIterator b = new ThirdIterator();\n        \n    \n    }\n\n}\n\nThere multiple problems here','Inner Classes',0,0,NULL,5),(3139,'you cant do this either\nfinal variable SIZE is not instantiated on creation or in the \nconstructor. Even though it is in the ThirdIterator class\nconstructor. that does not work. ','public class Hello {\n    private final int SIZE;\n    private int[] array;\n    \n    public Hello(){\n        ThirdIterator x = new ThirdIterator();\n    }\n    \n    interface DSIterator extends java.util.Iterator<Integer> { }\n    \n    private class ThirdIterator implements DSIterator{\n        private int nextIndex = 0;\n        public ThirdIterator(){\n            SIZE = 100;\n            for(int ix=0; ix<SIZE; ix++){\n                array[ix] = ix;\n            }\n        }\n......\n.........','Inner Classes',0,0,NULL,5),(3140,'compiles fine','public class Hello {\n    private final int SIZE = 100;\n    private int[] array;\n\n    interface DSIterator extends java.util.Iterator<Integer> { }\n    \n    private class ThirdIterator implements DSIterator{\n        private int nextIndex = 0;\n        public ThirdIterator(){\n            for(int ix=0; ix<SIZE; ix++){\n                array[ix] = ix;\n            }\n        }  \n        public boolean hasNext(){\n            return (nextIndex <= SIZE - 1);\n        }\n        public Integer next(){\n            Integer retValue = Integer.valueOf(array[nextIndex]); \n            nextIndex += 3;\n            return retValue;    \n        }\n    }\n    private static class EveryFourth implements DSIterator{\n        private int nextIndex = 0;\n        private static final int SIZE = 1000;\n        private int[] array = new int[SIZE];\n        public EveryFourth(){\n           for(int i =0; i<100; i++){\n               array[i] = i;\n           }\n        }\n        public boolean hasNext(){\n            return (nextIndex <= SIZE-1);\n        }\n        \n        public Integer next() {\n            Integer retValue = Integer.valueOf(array[nextIndex]);\n            \n            nextIndex += 4;\n            return retValue;\n        }\n    }\n    public static void main(String[] args) {\n        EveryFourth a = new EveryFourth();\n        Hello.ThirdIterator b = new Hello().new ThirdIterator();\n    }\n\n}','Inner Classes',0,0,NULL,5),(3141,'A nested interface declared static is redundant. A nested interface is automatically static. \nstatic can be removed without and affect on semantics. Similar to public on interface methods \nor public final on interface fields. \n\nIt doen\'t change the fact that code without access to Foo wont have access to Foo.Bar interface.\n\nIt is acceptable to use if you excpect it only to be used from the enclosing class\n\npublic class Foo {\n	public interface Bar {\n		void callback();\n	}\n	public static void registerCallback(Bar bar){...}\n}\n//elsewhere\nFoo.registerCallback(new Foo.Bar() {\n	public void callback() {...}\n});','public class Hello {\n    private final int SIZE = 100;\n    private int[] array;\n\n    \n    static interface DSIterator extends java.util.Iterator<Integer> { }\n    \n    private class ThirdIterator implements DSIterator{\n        private int nextIndex = 0;\n        public ThirdIterator(){\n            for(int ix=0; ix<SIZE; ix++){\n                array[ix] = ix;\n            }\n        }\n        \n        public boolean hasNext(){\n            return (nextIndex <= SIZE - 1);\n        }\n        \n     ......','Inner Classes',0,0,NULL,5),(3142,'does not compile without outer reference for inner interface.\n\nshould be:\n\n	class Dog implements Hello.Petable {\n    \n ','public class Hello {\n    private final int SIZE = 100;\n    private int[] array;\n\n    \n    interface DSIterator extends java.util.Iterator<Integer> { }\n    \n    interface Petable {\n        void speak();\n        void wag();\n    }\n    \n    private class ThirdIterator implements DSIterator{\n        private int nextIndex = 0;\n        public ThirdIterator(){\n            for(int ix=0; ix<SIZE; ix++){\n                array[ix] = ix;\n            }\n        }\n        \n        public boolean hasNext(){\n            return (nextIndex <= SIZE - 1);\n        }\n        \n        public Integer next(){\n            Integer retValue = Integer.valueOf(array[nextIndex]);\n            \n            nextIndex += 3;\n            return retValue;\n            \n        }\n        \n    }\n    \n    private static class EveryFourth implements DSIterator{\n        private int nextIndex = 0;\n        private static final int SIZE = 1000;\n        private int[] array = new int[SIZE];\n        \n        public EveryFourth(){\n           for(int i =0; i<100; i++){\n               array[i] = i;\n           }\n        }\n        \n        public boolean hasNext(){\n            return (nextIndex <= SIZE-1);\n        }\n        \n        public Integer next() {\n            Integer retValue = Integer.valueOf(array[nextIndex]);\n            \n            nextIndex += 4;\n            return retValue;\n        }\n    }\n    \n\n    public static void main(String[] args) {\n        \n        EveryFourth a = new EveryFourth();\n        Hello.ThirdIterator b = new Hello().new ThirdIterator();\n        \n    \n    }\n\n}\n\nclass Dog implements Petable {\n    \n    public void bark(){\n        \n    }\n\n    @Override\n    public void speak() {\n        throw new UnsupportedOperationException(\"Not supported yet.\"); //To change body of generated methods, choose Tools | Templates.\n    }\n\n    @Override\n    public void wag() {\n        throw new UnsupportedOperationException(\"Not supported yet.\"); //To change body of generated methods, choose Tools | Templates.\n    }\n    \n}','Inner Classes',0,0,NULL,5),(3143,'how to instantiate an inner class object from outside the outter class instance code.','class MyOuter{\n	private int x = 7;\n\n	class MyInner{\n	public void seeOuter(){\n		sout( x );\n	}\n\n}\n\nclass OCP{\n	public static void main(SA){\n		MyOuter mo = new MyOuter();\n		MYOuter.MyInner inner = mo.new MyInner();\n		inner.seeOuter();\n	}\n}','Inner Classes',0,0,NULL,5),(3144,'one liner','psvm(SA){\n	MyOuter.MyInner inner = new MyOuter().new MyInner();\n	inner.seeOuter();\n}','Inner Classes',0,0,NULL,5),(3145,'\n	The rules for an inner class to reference itself or the outer class instance are as follows:\n\n	To reference the inner class instance itself from within the inner class code,\n		use this\n\n	toreference the \"outer this\" from within the inner class code,\n		use MyOuter.this.','class MyOuter{\n    private int x = 7;\n    public void makeInner() {\n        MyInner in = new MyInner();\n       in.seeOuter();\n   }\n\n    class MyInner {	\n           public void seeOuter {\n	sout( \"Outer x is \" + x );\n	sout(\"Inner class ref is \" + this);\n	sout( \"Outer class ref is \" + MyOuter.this );\n            }\n}\n\n      psvm(sa) {\n	MyOuter.MyInner inner = new MyOuter().new MyInner();\n	inner.seeOuter();\n     }\n}\n		','Inner Classes',0,0,NULL,5),(3146,'final\nabstract\npublic \nprivate\nprotected\nstatic\nstrictfp','what member modifiers can be applied to an inner class	','Inner Classes',0,0,NULL,5),(3147,'How to properly use a method local inner class','class MyOuter2 {\n	private String x = \"Outer2\";\n	void doStuff() {\n	        class MyInner {\n		public void seeOuter() {\n	                               sout(\" outer x is \" + x );\n		}\n	        }\n	\n	MyInner mi = new MyInner(); // THIS LINE MUST COME AFTER THE CLASS\n\n	mi.seeOuter();\n	}\n}\n\n	','Inner Classes',0,0,NULL,5),(3148,'WayInner: 7\n\nthe proper way to use a method local inner ','public class Hello {\n   \n    public static void main(String[] args) {\n        Hello h = new Hello();\n        h.methodlocal();\n    }\n    \n    public void methodlocal(){\n        \n        class WayInner {\n            private int size;\n        \n            public WayInner(int x){ size = x;}\n            public void printDetail(){\n                System.out.println(\"WayInner: \"+ size);\n            }\n        }\n        \n        WayInner a = new WayInner(7);\n        a.printDetail();\n    }\n\n}','Inner Classes',0,0,NULL,5),(3149,'will not compile in java 7. \n\nlocal varialbe cannot be accesed from within inner class. \n\nLocal varialbe exist on the stack and only exist for the lifetime of the method. \n\nwhen the method ends the local varialbes are destroyed, however the inner class object might still live on\n ','public class Hello {\n   \n    public static void main(String[] args) {\n        Hello h = new Hello();\n        h.methodlocal();\n    }\n    \n    public void methodlocal(){\n        int y = 56;\n        \n        class WayInner {\n            public int size;\n        \n            public WayInner(int x){ size = x;}\n            public void printDetail(){\n                System.out.println(\"WayInner: \"+ size);\n            }\n            \n            public void showall(){\n                System.out.println(size+\" \"+y);\n            }\n        }\n        \n        WayInner a = new WayInner(7);\n        a.printDetail();\n        a.showall();\n        \n    }\n\n}','Inner Classes',0,0,NULL,5),(3150,'will compile method local inner class can only access local variables if they are marked final.','public class Hello {\n   \n    public static void main(String[] args) {\n        Hello h = new Hello();\n        h.methodlocal();\n    }\n    \n    public void methodlocal(){\n        final int y = 56;\n        \n        class Zombie {\n            public int size;\n        \n            public Zombie(int x){ size = x;}\n            public void mone(){\n                System.out.println(\"ughhhg: \"+ size);\n            }\n            \n            public void accessTheLiving(){\n                System.out.println(\"local var: \"+y);\n            }\n            \n        }\n        \n        Zombie zom = new Zombie(7);\n        \n    }\n\n}','Inner Classes',0,0,NULL,5),(3151,'will not compile method local inner classes cannot be marked public private protected static or transient.','public class Hello {\n   \n    public static void main(String[] args) {\n        Hello h = new Hello();\n        h.methodlocal();\n    }\n    \n    public void methodlocal(){\n        final int y = 56;\n        \n        protected class Zombie {\n            public int size;\n        \n            public Zombie(int x){ size = x;}\n            public void mone(){\n                System.out.println(\"ughhhg: \"+ size);\n            }\n            \n            public void accessTheLiving(){\n                System.out.println(\"local var: \"+y);\n            }\n            \n        }\n        \n        Zombie zom = new Zombie(7);\n        \n    }\n\n}','Inner Classes',0,0,NULL,5),(3152,'will not compile ML inner class cannot be marked static. ','public class Hello {\n   \n    public static void main(String[] args) {\n        Hello h = new Hello();\n        h.methodlocal();\n    }\n    \n    public void methodlocal(){\n        final int y = 56;\n        \n        static class Zombie {\n            public int size;\n        \n            public Zombie(int x){ size = x;}\n            public void mone(){\n                System.out.println(\"ughhhg: \"+ size);\n            }\n            \n            public void accessTheLiving(){\n                System.out.println(\"local var: \"+y);\n            }\n            \n        }\n        \n        Zombie zom = new Zombie(7);\n        \n    }\n\n}','Inner Classes',0,0,NULL,5),(3153,'will not compile \n\nillegal static declaration in method local inner class. ','public class Hello {\n   \n    public static void main(String[] args) {\n        Hello h = new Hello();\n        h.methodlocal();\n    }\n    \n    public void methodlocal(){\n        final int y = 56;\n        \n        class Zombie {\n            public int size;\n        \n            public Zombie(int x){ size = x;}\n            public static void mone(){\n                System.out.println(\"ughhhg: \"+ size);\n            }\n            \n            public void accessTheLiving(){\n                System.out.println(\"local var: \"+y);\n            }\n            \n        }\n        \n        Zombie zom = new Zombie(7);\n        \n    }\n\n}','Inner Classes',0,0,NULL,5),(3154,'will not compile\n\nillegal modifier static is only allowed in constant decalartations. \n\nto compile make num final','public class Hello {\n   \n    public static void main(String[] args) {\n        Hello h = new Hello();\n        h.methodlocal();\n    }\n    \n    public void methodlocal(){\n        final int y = 56;\n        \n        \n        class Zombie {\n            public int size;\n            public static int num = 5;\n        \n            public Zombie(int x){ size = x;}\n            public void mone(){\n                System.out.println(\"ughhhg: \"+ size);\n            }\n            \n            public void accessTheLiving(){\n                System.out.println(\"local var: \"+y);\n            }\n            \n        }\n        \n        Zombie zom = new Zombie(7);\n        \n    }\n\n}','Inner Classes',0,0,NULL,5),(3155,'compiles fine.\n\nto use static in an inner class it must be marked final','public class Hello {\n   \n    public static void main(String[] args) {\n        Hello h = new Hello();\n        h.methodlocal();\n    }\n    \n    public void methodlocal(){\n        final int y = 56;\n        \n        \n        class Zombie {\n            public int size;\n            public static final int num = 5;\n        \n            public Zombie(int x){ size = x;}\n            public void mone(){\n                System.out.println(\"ughhhg: \"+ size);\n            }\n            \n            public void accessTheLiving(){\n                System.out.println(\"local var: \"+y);\n            }\n            \n        }\n        \n        Zombie zom = new Zombie(7);\n        \n    }\n\n}','Inner Classes',0,0,NULL,5),(3156,'','For inner classes \'static\' is only allowed for constant variable declarations. ','Inner Classes',0,0,NULL,5),(3157,'does not compile, \n\neven if the method is static ML innner class cannot decalre staic unless it is a static final constant. ','public class Hello {\n   \n    public static void main(String[] args) {\n        Hello h = new Hello();\n        h.methodlocal();\n    }\n    \n    public static void methodlocal(){\n        final int y = 56;\n        \n        \n        class Zombie {\n            public int size;\n            public static final int num = 5;\n        \n            public Zombie(int x){ size = x;}\n            public static final void mone(){\n                System.out.println(\"ughhhg: \"+ size);\n            }\n            \n            public void accessTheLiving(){\n                System.out.println(\"local var: \"+y);\n            }\n            \n        }\n        \n        Zombie zom = new Zombie(7);\n        \n    }\n\n}','Inner Classes',0,0,NULL,5),(3158,'does not compile\n\na MLIC declared in a static method cannot access instance varialbes of the outerclass. \n\nso\n sout(name) does not compile here. \n\nit can however access those static variables, if it was just the statics \nit would print:\n\n	Gemini\n	Gemini\n	Eunech','public class Hello {\n    private String name = \"marco\";\n    private final static String gem = \"Gemini\";\n    private static String west = \"Eunech\";\n   \n    public static void main(String[] args) {\n        Hello h = new Hello();\n        h.methodlocal();\n    }\n    \n    public static void methodlocal(){\n        final int y = 56;\n        //System.out.println(name); //wouldnt compile\n        System.out.println(gem);\n        \n        \n        class Zombie {\n            public int size;\n            public static final int num = 5;\n        \n            public Zombie(int x){ size = x; System.out.println(gem); System.out.println(west); System.out.println(name); }\n            public void mone(){\n                System.out.println(\"ughhhg: \"+ size);\n            }\n            \n            public void accessTheLiving(){\n                System.out.println(\"local var: \"+y);\n            }\n            \n        }\n        \n        Zombie zom = new Zombie(7);\n        \n    }\n\n}','Inner Classes',0,0,NULL,5),(3159,'this compiles fine \nMLIC in a instance method can access both static and instance variables','public class Hello {\n    private String name = \"marco\";\n    private final static String gem = \"Gemini\";\n    private static String west = \"Eunech\";\n   \n    public static void main(String[] args) {\n        Hello h = new Hello();\n        h.methodlocal();\n    }\n    \n    public void methodlocal(){\n        final int y = 56;\n        //System.out.println(name); //wouldnt compile\n        System.out.println(gem);\n        \n        \n        class Zombie {\n            public int size;\n            public static final int num = 5;\n        \n            public Zombie(int x){ size = x; System.out.println(gem); System.out.println(west); System.out.println(name); }\n            public void mone(){\n                System.out.println(\"ughhhg: \"+ size);\n            }\n            \n            public void accessTheLiving(){\n                System.out.println(\"local var: \"+y);\n            }\n            \n        }\n        \n        Zombie zom = new Zombie(7);\n        \n    }\n\n}','Inner Classes',0,0,NULL,5),(3160,'h.buck() will not compile because you can only call the superclasses methods on a polymorphic reference','class Horse extends Animal {\n        void buck() { }\n}\n\nclass Animal {\n        void eat() { }\n}\nclass Test {\n        public static void main(String[] atrgs) {\n	Animal h = new Horse();\n	h.eat();\n	h.buck();\n       }\n}	','Inner Classes',0,0,NULL,5),(3161,'here smalls.actFly() compiles \n\nhowever, getLoot() is defined in the anonyous subclass so polynorphically it cannot compile.\n\nThe only way to use methods declared in the anonymous subclass is to override methods of \nthe super class where overriding rules still apply. ','public class Hello {\n   \n    public static void main(String[] args) {\n        Biggie smalls = new Biggie(){\n            public void getLoot(){\n                System.out.println(\"Gimmie the loot!\");\n            }\n            \n        };\n        \n        smalls.actFly();\n        smalls.getLoot();\n        \n      \n    }\n\n}\n\nclass Biggie {\n    public void actFly(){\n        System.out.println(\"Shit so fly\");\n    }\n    public static void getPaid(){\n        System.out.println(\"Its so easy!\");\n    }\n    public int getFemaleDigits(){\n        return 5556784;\n    }\n}','Inner Classes',0,0,NULL,5),(3162,'proper override','public class Hello {\n   \n    public static void main(String[] args) {\n        Biggie smalls = new Biggie(){\n            private void getLoot(){\n                System.out.println(\"Gimmie the loot!\");\n            }\n            \n            public void actFly(){\n                System.out.println(\"Still acting fly\");\n            }\n            \n        };\n        \n        smalls.actFly();\n        smalls.actFly();\n    }\n\n}\n\nclass Biggie {\n    public void actFly(){\n        System.out.println(\"Shit so fly\");\n    }\n    public static void getPaid(){\n        System.out.println(\"Its so easy!\");\n    }\n    public int getFemaleDigits(){\n        return 5556784;\n    }\n}','Inner Classes',0,0,NULL,5),(3163,'will not compile override methods cannot return a different type unless its a subtype','public class Hello {\n   \n    public static void main(String[] args) {\n        Biggie smalls = new Biggie(){\n            private void getLoot(){\n                System.out.println(\"Gimmie the loot!\");\n            }\n            \n            public int actFly(){\n                int x = 66;\n                System.out.println(\"Still acting fly\");\n                return x;\n            }\n            \n        };\n        \n        smalls.actFly();\n        smalls.actFly();\n    }\n\n}\n\nclass Biggie {\n    public void actFly(){\n        System.out.println(\"Shit so fly\");\n    }\n    public static void getPaid(){\n        System.out.println(\"Its so easy!\");\n    }\n    public int getFemaleDigits(){\n        return 5556784;\n    }\n}','Inner Classes',0,0,NULL,5),(3164,'this will compile just fine. \n\nan override method is allowed to have less reestricted access but not more,\n\nan override method must have the same return type or it can return a subclass. ','public class Hello {\n   \n    public static void main(String[] args) {\n        Biggie smalls = new Biggie(){\n            private void getLoot(){\n                System.out.println(\"Gimmie the loot!\");\n            }\n            \n            public void actFly(){\n                System.out.println(\"Still acting fly\");\n            }\n            \n            public Integer getFemalDigits(){\n                return 5671123;\n            }  \n        };\n        \n        smalls.actFly();\n        smalls.actFly();\n    }\n\n}\n\nclass Biggie {\n    protected void actFly(){\n        System.out.println(\"Shit so fly\");\n    }\n    public static void getPaid(){\n        System.out.println(\"Its so easy!\");\n    }\n    public Number getFemaleDigits(){\n        return 5556784;\n    }\n}','Inner Classes',0,0,NULL,5),(3165,'will not compile, \n\nyou cannot override a method marked static. \n\nThe only way you could make this work is by making getPaid in the anonymous\nclass static which would \'hide\' the superclass static method not override it.\n\nunfortuanlytel you cannot put a static method in an anonymous class. \n\n\n\nOver-riding basically supports late binding . Therefore, which method will be called is decided at run time.It is for non-static methods. Hiding is for all other members (static methods , instance members, static members). It is based on the early binding . More clearly , the method or member to be called or used is decided during compile time.\n\nIn your example, the first call , Animal.testClassMethod() is a call to a static method,hence, it is pretty sure as to which method is going to be called.\n\nIn the second call,myAnimal.testInstanceMethod(), it calls a non-static method. It is what you call run-time polymorphism. It is not decided until run time which method is to be called.\n\nFor further clarification, read this.\n','public class Hello {\n   \n    public static void main(String[] args) {\n        Biggie smalls = new Biggie(){\n            private void getLoot(){\n                System.out.println(\"Gimmie the loot!\");\n            }\n            \n            public void actFly(){\n                System.out.println(\"Still acting fly\");\n            }\n            \n            public Integer getFemalDigits(){\n                return 5671123;\n            }  \n            \n            public void getPaid(){\n                System.out.println(\"Boy I get money!\");\n            }\n        };\n        \n        smalls.actFly();\n        smalls.actFly();\n    }\n\n}\n\nclass Biggie {\n    protected void actFly(){\n        System.out.println(\"Shit so fly\");\n    }\n    public static void getPaid(){\n        System.out.println(\"Its so easy!\");\n    }\n    public Number getFemaleDigits(){\n        return 5556784;\n    }\n}','Inner Classes',0,0,NULL,5),(3166,'Will not compile\n\nstatic definitions not allowed in inner classes except for constant varaible definintions. ','public class Hello {\n   \n    public static void main(String[] args) {\n        Biggie smalls = new Biggie(){\n            private void getLoot(){\n                System.out.println(\"Gimmie the loot!\");\n            }\n            \n            public void actFly(){\n                System.out.println(\"Still acting fly\");\n            }\n            \n            public Integer getFemalDigits(){\n                return 5671123;\n            }  \n            \n            public static void getPaid(){\n                System.out.println(\"Boy I get money!\");\n            }\n        };\n        \n        smalls.actFly();\n        smalls.actFly();\n    }\n\n}\n\nclass Biggie {\n    protected void actFly(){\n        System.out.println(\"Shit so fly\");\n    }\n    public static void getPaid(){\n        System.out.println(\"Its so easy!\");\n    }\n    public Number getFemaleDigits(){\n        return 5556784;\n    }\n}','Inner Classes',0,0,NULL,5),(3167,'this compiles fine,\n\n','class Biggie {\n    public static int thashitt = 568;\n    protected void actFly(){\n        System.out.println(\"Shit so fly\");\n    }\n    public static void getPaid(){\n        System.out.println(\"Its so easy!\");\n    }\n    public Number getFemaleDigits(){\n        return 5556784;\n    }\n}\n\nclass Benzino extends Biggie{\n    \n    public void printThaShitt(){\n        System.out.println(thashitt);\n    }\n    \n    public static void getPaid(){\n        System.out.println(\"It\'s somewhat difficult\");\n    }\n    \n    public Integer getFemaleDigits(){\n        return null;\n    }\n    \n}','Inner Classes',0,0,NULL,5),(3168,'Still acting fly\n5671123\nIts so easy!\n\nthe reference smalls is of type anonymous class so its methods are theoverriden methods in the anonymous \nclass\n\nwhen getPaid() is called on benz you are accessing a static method from a reference variable, so \nthe Biggie version is used because thats the type of the reference variable, \n\nstatic methods cannot be overridden but they can be hidden. ','public class Hello {\n   \n    public static void main(String[] args) {\n        Biggie smalls = new Biggie(){\n            private void getLoot(){\n                System.out.println(\"Gimmie the loot!\");\n            }\n            \n            public void actFly(){\n                System.out.println(\"Still acting fly\");\n            }\n            \n            public Integer getFemaleDigits(){\n                return 5671123;\n            }  \n\n        };\n        \n        smalls.actFly();\n        System.out.println(smalls.getFemaleDigits());\n        \n        Biggie benz = new Benzino();\n        benz.getPaid();\n    }\n\n}\n\nclass Biggie {\n    public static int thashitt = 568;\n    protected void actFly(){\n        System.out.println(\"Shit so fly\");\n    }\n    public static void getPaid(){\n        System.out.println(\"Its so easy!\");\n    }\n    public Number getFemaleDigits(){\n        return 5556784;\n    }\n}\n\nclass Benzino extends Biggie{\n    \n    public void printThaShitt(){\n        System.out.println(thashitt);\n    }\n    \n    public static void getPaid(){\n        System.out.println(\"It\'s somewhat difficult\");\n    }\n    \n    public Integer getFemaleDigits(){\n        return null;\n    }\n    \n}','Inner Classes',0,0,NULL,5),(3169,'Still acting fly\n5671123\nIt\'s somewhat difficult','public class Hello {\n   \n    public static void main(String[] args) {\n        Biggie smalls = new Biggie(){\n            private void getLoot(){\n                System.out.println(\"Gimmie the loot!\");\n            }\n            \n            public void actFly(){\n                System.out.println(\"Still acting fly\");\n            }\n            \n            public Integer getFemaleDigits(){\n                return 5671123;\n            }  \n\n        };\n        \n        smalls.actFly();\n        System.out.println(smalls.getFemaleDigits());\n        \n        Benzino benz = new Benzino();\n        benz.getPaid();\n    }\n\n}\n\nclass Biggie {\n    public static int thashitt = 568;\n    protected void actFly(){\n        System.out.println(\"Shit so fly\");\n    }\n    public static void getPaid(){\n        System.out.println(\"Its so easy!\");\n    }\n    public Number getFemaleDigits(){\n        return 5556784;\n    }\n}\n\nclass Benzino extends Biggie{\n    \n    public void printThaShitt(){\n        System.out.println(thashitt);\n    }\n    \n    public static void getPaid(){\n        System.out.println(\"It\'s somewhat difficult\");\n    }\n    \n    public Integer getFemaleDigits(){\n        return null;\n    }\n    \n}','Inner Classes',0,0,NULL,5),(3170,'p.pop(); is ok because popcorn has a pop method\n\np.sizzle();  is illegal because popcorn does not have sizzle().\n\n','class Popcorn {\n	public void pop(){\n		sout(\"popcorn\");\n	}\n}\n\nclass Food {\n	Popcorn p = new Popcorn() {\n		public void sizzle(){\n			sout(\"anonymouse sizzling popcorn\");\n		}\n\n		public void pop(){\n			sout(\"anonumous popcorn\");\n		}\n	};\n\n	public void popIt(){\n		p.pop();\n		p.sizzle();\n	}\n}','Inner Classes',0,0,NULL,5),(3171,'will not compile class Benzino does not have that method. ','public class Hello {\n   \n    public static void main(String[] args) {\n        Biggie benz = new Benzino();\n        benz.printThaShitt();\n    }\n\n}\n\nclass Biggie {\n    public static int thashitt = 568;\n    protected void actFly(){\n        System.out.println(\"Shit so fly\");\n    }\n    public static void getPaid(){\n        System.out.println(\"Its so easy!\");\n    }\n    public Number getFemaleDigits(){\n        return 5556784;\n    }\n}\n\nclass Benzino extends Biggie{\n    \n    public void printThaShitt(){\n        System.out.println(thashitt);\n        getPaid();\n        super.getPaid();\n        Biggie.getPaid();\n    }\n    \n    public static void getPaid(){\n        System.out.println(\"It\'s somewhat difficult\");\n    }\n    \n    public Integer getFemaleDigits(){\n        return null;\n    }\n    \n}','Inner Classes',0,0,NULL,5),(3172,'568\nIt\'s somewhat difficult\nIts so easy!\nIts so easy!\n\n\ngetPaid() is used plainly as is it calls Benzinos static method, \n\nall the others access the super class. \n\nStatic variables in Java are not inherited, they exist only in the class which declares them; \nhowever, they can be accessed implicitly by referring to an instance or subclass (or subclass instance) of the class which defines the \nstatic variable. \n(Static variable handling is one of the few confusing parts of the Java language, IMHO.)','public class Hello {\n   \n    public static void main(String[] args) {\n        Benzino benz = new Benzino();\n        benz.printThaShitt();\n    }\n\n}\n\nclass Biggie {\n    public static int thashitt = 568;\n    protected void actFly(){\n        System.out.println(\"Shit so fly\");\n    }\n    public static void getPaid(){\n        System.out.println(\"Its so easy!\");\n    }\n    public Number getFemaleDigits(){\n        return 5556784;\n    }\n}\n\nclass Benzino extends Biggie{\n    \n    public void printThaShitt(){\n        System.out.println(thashitt);\n        getPaid();\n        super.getPaid();\n        Biggie.getPaid();\n    }\n    \n    public static void getPaid(){\n        System.out.println(\"It\'s somewhat difficult\");\n    }\n    \n    public Integer getFemaleDigits(){\n        return null;\n    }\n    \n}\n','Inner Classes',0,0,NULL,5),(3173,'this shows that static methods can be overloaded','public class Test {\n    public static void foo() {\n        System.out.println(\"Test.foo() called \");\n    }\n    public static void foo(int a) { \n        System.out.println(\"Test.foo(int) called \");\n    }\n    public static void main(String args[])\n    { \n        Test.foo();\n        Test.foo(10);\n    }\n}','Inner Classes',0,0,NULL,5),(3174,'will not compile, you cannot overload based on static keyword alone','public class Test {\n    public static void foo() {\n        System.out.println(\"Test.foo() called \");\n    }\n    public void foo() { \n        System.out.println(\"Test.foo(int) called \");\n    }\n    public static void main(String args[]) { \n        Test.foo();\n    }\n}','Inner Classes',0,0,NULL,5),(3175,'will not compile, \n\nanonymous class of stick is not abstract and does not overrride interface\nmethods\n\n','public class Hello {\n\n   \n    public static void main(String[] args) {\n        Burnable stick = new Burnable(){\n            \n        };\n    }\n\n}\n\ninterface Burnable{\n    int people = 10;\n    void burn();\n    void shakeoff();\n    int unburn();\n    \n}','Inner Classes',0,0,NULL,5),(3176,'does not compile, \n\nanonymous subclass does not impelement all abstract methods ','public class Hello {\n\n   \n    public static void main(String[] args) {\n        Burnable stick = new Burnable(){\n            public void burn(){\n                System.out.println(\"Theres \"+people+\" people here so get the fire going\");\n            }\n            \n        };\n    }\n\n}\n\ninterface Burnable{\n    int people = 10;\n    void burn();\n    void shakeoff();\n    int unburn();\n    \n}','Inner Classes',0,0,NULL,5),(3177,'This type of anonomuous inner class implemtents an interface\n\nThis is the only time you can use new with an interface.\n\nIt compiles because all of the abstract methods are implemented\n\n','public class Hello {\n\n    public static void main(String[] args) {\n        \n        Burnable stick = new Burnable(){\n            public void burn(){\n                System.out.println(\"Theres \"+people+\" people here so get the fire going\");\n            }\n            \n            public int unburn(){\n                System.out.println(\"That\'s impossible\");\n                return 0;\n            }\n            \n            public void shakeoff(){\n                System.out.println(\"That was my shoe!\");\n            }\n            \n        };\n    }\n\n}\n\ninterface Burnable{\n    int people = 10;\n    void burn();\n    void shakeoff();\n    int unburn();\n}\n','Inner Classes',0,0,NULL,5),(3178,'will not compile interfaces are 100% abstract, they can have nothing\nconcrete','interface Burnable{\n    int people = 10;\n    void burn();\n    void shakeoff();\n    int unburn();\n    void people(){\n        System.out.println(people+\" \");\n    }\n}','Inner Classes',0,0,NULL,5),(3179,'Theres 8 people here so get the fire going','public class Hello {\n\n    public static void main(String[] args) {\n        \n        Burnable stick = new Burnable(){\n            int people = 8;\n            public void burn(){\n                System.out.println(\"Theres \"+people+\" people here so get the fire going\");\n            }\n            \n            public int unburn(){\n                System.out.println(\"That\'s impossible\");\n                return 0;\n            }\n            \n            public void shakeoff(){\n                System.out.println(\"That was my shoe!\");\n            }\n            \n        };\n        \n        stick.burn();\n    }\n\n}\n\ninterface Burnable{\n    int people = 10;\n    void burn();\n    void shakeoff();\n    int unburn();\n}\n','Inner Classes',0,0,NULL,5),(3180,'Will not compile, shakeoff() is overloaded in anonymous subclass. \n\nThe overload is legal using it outside the inner class is not\n\nthat method is an overload it is created in the anonnymous subclass and\ncant be used on the Burnable refernence','public class Hello {\n\n    public static void main(String[] args) {\n        \n        Burnable stick = new Burnable(){\n            int people = 8;\n            public void burn(){\n                System.out.println(\"Theres \"+people+\" people here so get the fire going\");\n            }\n            \n            public int unburn(){\n                System.out.println(\"That\'s impossible\");\n                return 0;\n            }\n            \n            public void shakeoff(int x){\n                System.out.println(\"That was my shoe!\"+x);\n            }\n            \n            public void shakeoff(){\n                System.out.println(\"its off\");\n            }\n            \n            \n            \n        };\n        \n        stick.burn();\n        stick.shakeoff();\n    }\n\n}\n\ninterface Burnable{\n    int people = 10;\n    void burn();\n    void shakeoff(int z);\n    int unburn();\n}','Inner Classes',0,0,NULL,5),(3181,'gimmie all the balls!','public class Hello {\n\n    public static void main(String[] args) {\n        Gym.BasketBallCourt bc = new Gym.BasketBallCourt();\n        bc.collectBalls();\n    }\n\n}\n\nclass Gym{\n    public int weights = 8000;\n    public String name = \"Max\'s gym\";\n    public int price = 50;\n    \n    public void pitch(){\n        System.out.println(\"Were the best gym\");\n    }\n    \n    static class BasketBallCourt {\n        private int courts = 2;\n        \n        public void collectBalls(){\n            System.out.println(\"gimmmie all the balls!\");\n        }\n        \n        public int Scoreboard(){\n            return 114;\n        }\n    }\n}','Inner Classes',0,0,NULL,5),(3182,'will not compile, static classes are like static members of the enclosing\nclass they cannot access instance varialbes','class Gym{\n    public int weights = 8000;\n    public String name = \"Max\'s gym\";\n    public int price = 50;\n    \n    public void pitch(){\n        System.out.println(\"Were the best gym\");\n    }\n    \n    static class BasketBallCourt {\n        private int courts = 2;\n        \n        public void collectBalls(){\n            System.out.println(\"gimmmie all the balls!\");\n        }\n        \n        public void gymPrice(){\n            System.out.println(name+\" \"+price);\n        }\n        \n        public int Scoreboard(){\n            return 114;\n        }\n    }','Inner Classes',0,0,NULL,5),(3183,'This compiles fine static inner classes can have static fields and methods\n','class Gym{\n    public int weights = 8000;\n    public String name = \"Max\'s gym\";\n    public int price = 50;\n    \n    public void pitch(){\n        System.out.println(\"Were the best gym\");\n    }\n    \n    static class BasketBallCourt {\n        private static int courts = 2;\n        \n        public void collectBalls(){\n            System.out.println(\"gimmmie all the balls!\");\n        }\n        \n        public void gymPrice(){\n            Gym g = new Gym();\n            System.out.println(g.price);\n        }\n        \n        public int Scoreboard(){\n            return 114;\n        }\n    }\n}','Inner Classes',0,0,NULL,5),(3184,'this compiles fine, shows how to properly instantiate static nested clases','public class Hello {\n\n    public static void main(String[] args) {\n        Gym.BasketBallCourt bc = new Gym.BasketBallCourt();\n        bc.collectBalls();\n    }\n\n}\n\nclass Gym{\n    public int weights = 8000;\n    public String name = \"Max\'s gym\";\n    public int price = 50;\n    \n    public void pitch(){\n        BasketBallCourt bc = new BasketBallCourt();\n        System.out.println(\"Were the best gym\");\n        System.out.println(\"Our court is huge too! \"+bc.courts());\n    }\n    \n    static class BasketBallCourt {\n        private static int courts = 2;\n        \n        public static void collectBalls(){\n            System.out.println(\"gimmmie all the balls!\");\n        }\n        public int courts(){\n            return courts;\n        }\n        \n        public void gymPrice(){\n            Gym g = new Gym();\n            System.out.println(g.price);\n        }\n        \n        public int Scoreboard(){\n            return 114;\n        }\n    }\n}','Inner Classes',0,0,NULL,5),(3185,'will not compile, that is not the right instantiation of a static nested class','public class Hello {\n\n    public static void main(String[] args) {\n        Gym.BasketBallCourt bc = new Gym.BasketBallCourt();\n        Gym g = new Gym();\n        \n        Gym.BasketBallCourt bc3 = g.new BasketBallCourt();\n        \n        g.pitch();\n        \n    }\n\n}\n\nclass Gym{\n    public int weights = 8000;\n    public String name = \"Max\'s gym\";\n    public int price = 50;\n    \n    public void pitch(){\n        BasketBallCourt bc = new BasketBallCourt();\n        System.out.println(\"Were the best gym\");\n        System.out.println(\"Our court is huge too! \"+bc.courts());\n    }\n    \n    static class BasketBallCourt {\n        private static int courts = 2;\n        \n        public static void collectBalls(){\n            System.out.println(\"gimmmie all the balls!\");\n        }\n        public int courts(){\n            return courts;\n        }\n        \n        public void gymPrice(){\n            Gym g = new Gym();\n            System.out.println(g.price);\n        }\n        \n        public int Scoreboard(){\n            return 114;\n        }\n    }\n}','Inner Classes',0,0,NULL,5),(3186,'114\ngimmie all the balls','public class Hello {\n\n    public static void main(String[] args) {\n        Gym.BasketBallCourt bc = new Gym.BasketBallCourt();\n        Gym g = new Gym();\n        \n        Gym.BasketBallCourt bc3 = new Gym.BasketBallCourt();\n        \n        bc3.Scoreboard();\n        \n        Gym.BasketBallCourt.collectBalls();\n        \n    }\n\n}\n\nclass Gym{\n    public int weights = 8000;\n    public String name = \"Max\'s gym\";\n    public int price = 50;\n    \n    public void pitch(){\n        BasketBallCourt bc = new BasketBallCourt();\n        System.out.println(\"Were the best gym\");\n        System.out.println(\"Our court is huge too! \"+bc.courts());\n    }\n    \n    static class BasketBallCourt {\n        private static int courts = 2;\n        \n        public static void collectBalls(){\n            System.out.println(\"gimmmie all the balls!\");\n        }\n        public int courts(){\n            return courts;\n        }\n        \n        public void gymPrice(){\n            Gym g = new Gym();\n            System.out.println(g.price);\n        }\n        \n        public int Scoreboard(){\n            return 114;\n        }\n    }\n}','Inner Classes',0,0,NULL,5),(3187,'114','public class Hello {\n\n    public static void main(String[] args) {\n        Gym.BasketBallCourt gbg = new Gym().new BasketBallCourt();\n        System.out.println(gbg.Scoreboard());\n        \n    }\n\n}\n\nclass Gym{\n    public int weights = 8000;\n    public String name = \"Max\'s gym\";\n    public int price = 50;\n    \n    public void pitch(){\n        BasketBallCourt bc = new BasketBallCourt();\n        System.out.println(\"Were the best gym\");\n    }\n    \n    class BasketBallCourt {\n        \n        public void collectBalls(){\n            System.out.println(\"gimmmie all the balls!\");\n        }\n        \n        public void gymPrice(){\n            Gym g = new Gym();\n            System.out.println(g.price);\n        }\n        \n        public int Scoreboard(){\n            return 114;\n        }\n    }\n}','Inner Classes',0,0,NULL,5),(3188,'does not compile because of private modifier','public class Hello {\n\n    public static void main(String[] args) {\n        Gym.BasketBallCourt gbg = new Gym().new BasketBallCourt();\n        \n    }\n\n}\n\nclass Gym{\n    public int weights = 8000;\n    public String name = \"Max\'s gym\";\n    public int price = 50;\n    \n    public void pitch(){\n        BasketBallCourt bc = new BasketBallCourt();\n        System.out.println(\"Were the best gym\");\n    }\n    \n    private class BasketBallCourt {\n        \n        public void collectBalls(){\n            System.out.println(\"gimmmie all the balls!\");\n        }\n        \n        public void gymPrice(){\n            Gym g = new Gym();\n            System.out.println(g.price);\n        }\n        \n        public int Scoreboard(){\n            return 114;\n        }\n    }\n}','Inner Classes',0,0,NULL,5),(3189,'this compiles fine','public class Hello {\n\n    public static void main(String[] args) {\n        Gym.BasketBallCourt gbg = new Gym().new BasketBallCourt();\n        \n    }\n\n}\n\nclass Gym{\n    public int weights = 8000;\n    public String name = \"Max\'s gym\";\n    public int price = 50;\n    \n    public void pitch(){\n        BasketBallCourt bc = new BasketBallCourt();\n        System.out.println(\"Were the best gym\");\n    }\n    \n    protected class BasketBallCourt {\n        \n        public void collectBalls(){\n            System.out.println(\"gimmmie all the balls!\");\n        }\n        \n        public void gymPrice(){\n            Gym g = new Gym();\n            System.out.println(g.price);\n        }\n        \n        public int Scoreboard(){\n            return 114;\n        }\n    }\n}','Inner Classes',0,0,NULL,5),(3190,'oooh ahhh\n\nsince inner classes are members of the enclsoing class just like anything else\nthey are inherited too.','public class Hello {\n\n    public static void main(String[] args) {\n        LifeTime lt = new LifeTime();\n        lt.showLifeTimesCourt();    \n    }\n\n}\n\nclass Gym{\n    public int weights = 8000;\n    public String name = \"Max\'s gym\";\n    public int price = 50;\n    \n    public void pitch(){\n        BasketBallCourt bc = new BasketBallCourt();\n        System.out.println(\"Were the best gym\");\n    }\n    \n    protected class BasketBallCourt {\n        \n        public void collectBalls(){\n            System.out.println(\"gimmmie all the balls!\");\n        }\n        \n        public void showCourt(){\n            System.out.println(\"oooh ahhh\");\n        }\n        \n        public void gymPrice(){\n            Gym g = new Gym();\n            System.out.println(g.price);\n        }\n        \n        public int Scoreboard(){\n            return 114;\n        }\n    }\n}\n\nclass LifeTime extends Gym{\n    public void showLifeTimesCourt(){\n        BasketBallCourt b = new BasketBallCourt();\n        b.showCourt();\n    }\n}','Inner Classes',0,0,NULL,5),(3191,'this compiles and runs','public class Hello {\n\n    public static void main(String[] args) {\n       LifeTime lt = new LifeTime();\n       Gym.BasketBallCourt bc = lt.new BasketBallCourt();\n       \n    }\n\n}\n\nclass Gym{\n    public int weights = 8000;\n    public String name = \"Max\'s gym\";\n    public int price = 50;\n    \n    public void pitch(){\n        BasketBallCourt bc = new BasketBallCourt();\n        System.out.println(\"Were the best gym\");\n    }\n    \n    protected class BasketBallCourt {\n        \n        public void collectBalls(){\n            System.out.println(\"gimmmie all the balls!\");\n        }\n        \n        public void showCourt(){\n            System.out.println(\"oooh ahhh\");\n        }\n        \n        public void gymPrice(){\n            Gym g = new Gym();\n            System.out.println(g.price);\n        }\n        \n        public int Scoreboard(){\n            return 114;\n        }\n    }\n}\n\nclass LifeTime extends Gym{\n    public void showLifeTimesCourt(){\n        BasketBallCourt b = new BasketBallCourt();\n        b.showCourt();\n    }\n}','Inner Classes',0,0,NULL,5),(3192,'How to access this reference of outer class','public class Hello {\n\n    public static void main(String[] args) {\n       Gym lt = new Gym();\n       Gym.BasketBallCourt bc = lt.new BasketBallCourt();\n       \n    }\n\n}\n\nclass Gym{\n    public int weights = 8000;\n    public String name = \"Max\'s gym\";\n    public int price = 50;\n    \n    public void pitch(){\n        BasketBallCourt bc = new BasketBallCourt();\n        System.out.println(\"Were the best gym\");\n    }\n    \n    protected class BasketBallCourt {\n        public String name = \"Maxs court\";\n        \n        public void collectBalls(){\n            System.out.println(\"gimmmie all the balls!\");\n        }\n        \n        public void showCourt(){\n            System.out.println(\" \"+name);\n            System.out.println(\"oooh ahhh\");\n        }\n        \n        public void gymPrice(){\n            System.out.println(\" \"+Gym.this.name);\n            System.out.println(Gym.this.price);\n        }\n        \n        public int Scoreboard(){\n            return 114;\n        }\n    }\n}','Inner Classes',0,0,NULL,5),(3193,'compiles fine','public class Hello {\n\n    public static void main(String[] args) {\n       LifeTime lt = new LifeTime();\n       Gym.BasketBallCourt bc = lt.new BasketBallCourt();\n       \n    }\n\n}\n\nclass Gym{\n    public int weights = 8000;\n    public String name = \"Max\'s gym\";\n    public int price = 50;\n    \n    public void pitch(){\n        BasketBallCourt bc = new BasketBallCourt();\n        System.out.println(\"Were the best gym\");\n    }\n    \n    protected class BasketBallCourt {\n        public String name = \"Maxs court\";\n        \n        public void collectBalls(){\n            System.out.println(\"gimmmie all the balls!\");\n        }\n        \n        public void showCourt(){\n            System.out.println(\" \"+name);\n            System.out.println(\"oooh ahhh\");\n        }\n        \n        public void gymPrice(){\n            System.out.println(\" \"+Gym.this.name);\n            System.out.println(Gym.this.price);\n        }\n        \n        public int Scoreboard(){\n            return 114;\n        }\n    }\n}\n\nclass LifeTime extends Gym{\n    public void showLifeTimesCourt(){\n        final int time = 530;\n        class SalesRep{\n            public void appointment(){\n                System.out.println(\"The time of our appointment is: \"+time);\n            }\n            \n        }\n        SalesRep sr = new SalesRep();\n        sr.appointment();\n        BasketBallCourt b = new BasketBallCourt();\n        b.showCourt();\n    }\n}','Inner Classes',0,0,NULL,5),(3194,'compilation fails, non final local variable is access from Method local inner \nclass.','package hello;\n\nimport java.awt.Container;\nimport java.awt.EventQueue;\nimport java.awt.event.ActionEvent;\nimport java.awt.event.InputEvent;\nimport java.awt.event.KeyEvent;\nimport java.io.IOException;\nimport java.io.Serializable;\nimport java.nio.file.DirectoryStream;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Hashtable;\nimport java.util.Iterator;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.NavigableMap;\nimport java.util.PriorityQueue;\nimport java.util.Set;\nimport java.util.SortedMap;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport javax.swing.AbstractAction;\nimport javax.swing.GroupLayout;\nimport javax.swing.InputMap;\nimport javax.swing.JButton;\nimport javax.swing.JComponent;\nimport javax.swing.JFrame;\nimport javax.swing.JPanel;\nimport javax.swing.KeyStroke;\n\npublic class Hello {\n\n    public static void main(String[] args) {\n       LifeTime lt = new LifeTime();\n       Gym.BasketBallCourt bc = lt.new BasketBallCourt();\n       \n    }\n\n}\n\nclass Gym{\n    public int weights = 8000;\n    public String name = \"Max\'s gym\";\n    public int price = 50;\n    \n    public void pitch(){\n        BasketBallCourt bc = new BasketBallCourt();\n        System.out.println(\"Were the best gym\");\n    }\n    \n    protected class BasketBallCourt {\n        public String name = \"Maxs court\";\n        \n        public void collectBalls(){\n            System.out.println(\"gimmmie all the balls!\");\n        }\n        \n        public void showCourt(){\n            System.out.println(\" \"+name);\n            System.out.println(\"oooh ahhh\");\n        }\n        \n        public void gymPrice(){\n            System.out.println(\" \"+Gym.this.name);\n            System.out.println(Gym.this.price);\n        }\n        \n        public int Scoreboard(){\n            return 114;\n        }\n    }\n}\n\nclass LifeTime extends Gym{\n    public void showLifeTimesCourt(){\n        int time = 530;\n        class SalesRep{\n            public void appointment(){\n                System.out.println(\"The time of our appointment is: \"+time);\n            }\n            \n        }\n        SalesRep sr = new SalesRep();\n        sr.appointment();\n        BasketBallCourt b = new BasketBallCourt();\n        b.showCourt();\n    }\n}\n\n\n','Inner Classes',0,0,NULL,5),(3195,'Method inner classes cannot be declared protected public private or static','class Gym{\n    public int weights = 8000;\n    public String name = \"Max\'s gym\";\n    public int price = 50;\n    \n    public void pitch(){\n        BasketBallCourt bc = new BasketBallCourt();\n        System.out.println(\"Were the best gym\");\n    }\n    \n    protected class BasketBallCourt {\n        public String name = \"Maxs court\";\n        \n        public void collectBalls(){\n            System.out.println(\"gimmmie all the balls!\");\n        }\n        \n        public void showCourt(){\n            System.out.println(\" \"+name);\n            System.out.println(\"oooh ahhh\");\n        }\n        \n        public void gymPrice(){\n            System.out.println(\" \"+Gym.this.name);\n            System.out.println(Gym.this.price);\n        }\n        \n        public int Scoreboard(){\n            return 114;\n        }\n    }\n}\n\nclass LifeTime extends Gym{\n    public void showLifeTimesCourt(){\n        int time = 530;\n        protected class SalesRep{\n            public void appointment(){\n                System.out.println(\"The time of our appointment is: \"+time);\n            }\n            \n        }\n        SalesRep sr = new SalesRep();\n        sr.appointment();\n        BasketBallCourt b = new BasketBallCourt();\n        b.showCourt();\n    }\n}','Inner Classes',0,0,NULL,5),(3196,'This compiles fine, you can create an anonymous inner class with a subclass\nthen assign it to a superclass reference. ','public class Hello {\n    public static void main(String[] args) {\n       Gym g = new LifeTime() {\n           public void showLifeTimeCourt(){\n               System.out.println(\"LT on meridean\");\n           }\n       };\n    }\n}\n\nclass Gym{\n    public int weights = 8000;\n    public String name = \"Max\'s gym\";\n    public int price = 50;\n    \n    public void pitch(){\n        BasketBallCourt bc = new BasketBallCourt();\n        System.out.println(\"Were the best gym\");\n    }\n    \n    static class BasketBallCourt {\n        public String name = \"Maxs court\";\n        \n        public void collectBalls(){\n            System.out.println(\"gimmmie all the balls!\");\n        }\n        \n        public void showCourt(){\n            System.out.println(\" \"+name);\n            System.out.println(\"oooh ahhh\");\n        }\n        \n        public void gymPrice(){\n\n        }\n        \n        public int Scoreboard(){\n            return 114;\n        }\n    }\n}\n\nclass LifeTime extends Gym{\n    \n    public void showLifeTimesCourt(){\n        final int time = 530;\n        BasketBallCourt bc = new BasketBallCourt();\n        bc.collectBalls();\n    }\n}','Inner Classes',0,0,NULL,5),(3197,'shark.devourSeal() does not compile. \n\nthe anonymous class is declared with a reference type of AquaticLife\nso you can only use methods of that class','public class Hello {\n    public static void main(String[] args) {\n        \n        AquaticLife shark = new Shark(){\n            String unknown = \"unknown species\";\n            public void species(){\n                System.out.println(unknown);\n            }\n        };\n        \n        shark.swim();\n        shark.devourSeal();\n  \n    }\n}\n\nclass AquaticLife{ \n    public void swim(){ \n        System.out.println(\"Bubbles\");\n    }\n     \n    public void useGills(){\n        System.out.println(\"ahhh\");\n    }\n}\n\nclass Shark extends AquaticLife{\n    public void devourSeal(){\n        System.out.println(\"chomp\");\n    }\n    \n    public void swin(){\n        System.out.println(\"Swims up to 60mph\");\n    }\n    public void electricSense(){\n        System.out.println(\"I can feel you in the water\");\n    }\n}','Inner Classes',0,0,NULL,5),(3198,'an inner class can extend the outlying classs','class AquaticLife{ \n    public void swim(){ \n        System.out.println(\"Bubbles\");\n    }\n     \n    public void useGills(){\n        System.out.println(\"ahhh\");\n    }\n    \n    class BottomFeeder extends AquaticLife {\n        public void useGills(){\n            System.out.println(\"I dont have gills\");\n        }\n    }\n}','Inner Classes',0,0,NULL,5),(3199,'It can be abstract,\n	that would mean a concrete class would have to be created in the \n	method so that would probably not be very useful\n\nIt can access private members of the enclosing class\n--------------------------------------------------------\nIt can be marked final but it doesnt\' have to be\n\na method local inner class cannot be marked public, or static','which are true about a method local inner class ?\n\nIt must be marked final\nIt can be marked abstract\nIt can be marked public \nIt can be marked static \nIt can access private members of the enclosing class','Inner Classes',0,0,NULL,5),(3200,'Compilation fails with an error at the line where the semicolon should be \nafter the inner class','public class TestObj {\n	public static void main(SA){\n		Object ob = new Object() {\n			public boolean equals(Object ob){\n				return true;\n			}\n		}\n		sout(ob.equals(\"FRED\");\n	}\n}','Inner Classes',0,0,NULL,5),(3201,'compilation fails at sout(ob.name);\n\nif the reference variable is of type Object you can only access members \ndefined class Object','public class HorseTest {\n	public static void main(SA){\n		class Horse {\n			public String name;\n			public Horse(String s) {\n				name = s;\n			}\n		}\n		Object ob = new Horse(\"Zippo\");\n		sout(ob.name);\n	}\n}','Inner Classes',0,0,NULL,5),(3202,'57 22\n\nto create an instance of an inner class you have to create it with an \nouter class reference here AbstractTest is abstract so it had to be\ninstantiated with an anonymous inner class to have a concrete reference\nto tie the new anonymous class of type Bar to. ','public abstract class AbstractTest {\n	public int getNum(){\n		return 45;\n	}\n	public abstract class Bar {\n		public int getNum(){\n			return 38;\n		}\n	}\n	public staic void main(String[] args) {\n		AbstractTest t = new AbstractTest(){\n			public int getNum() {\n				return 22;\n			}\n		};\n		AbstractTest.Bar f = t.new Bar() {\n			public int getNum(){\n				return 57;\n			}\n		};\n		sout(f.getNum() + \" \" + t.getNum() );\n	}\n}','Inner Classes',0,0,NULL,5),(3203,'Cathedral.Sanctum s = c.new Sanctum();\n\nor\n\nCathedral.Sanctum s1 = new Cathedral().new Sanctum();','public class Tour {\n	public static void main(SA){\n		Cathedral c = new Cathedral();\n		// insert code\n		s.go();\n	}\n}\n\nclass Cathedral {\n	class Sanctum {\n		void go() { sout(\"spooky\"); }\n	}\n}\n\nproperly instantiate Sanctume','Inner Classes',0,0,NULL,5),(3204,'Will not compile Hello is abstract cannot be instantiated lol ','public abstract class Hello {\n    public static void main(String[] args) {\n        new Hello().test();\n        \n    }\n    \n    void test() {\n        class Breaker{ void foo(){ System.out.println(\"Inner\"); } }\n    }\n    \n    class Breaker {\n        void foo(){\n            System.out.println(\"middle\");\n        }\n    }\n}\n\nclass Breaker{\n    void foo(){\n        System.out.println(\"Outer\");\n    }\n    \n}','Inner Classes',0,0,NULL,5),(3205,'middle\n\nThe closest scoped class is middle. The inner class is declared after the\ncall to foo() and the Outer class comes after any inner classes','public class Hello {\n    public static void main(String[] args) {\n        new Hello().test();\n        \n    }\n    \n    void test() {\n        new Breaker().foo();\n        class Breaker{ void foo(){ System.out.println(\"Inner\"); } }\n    }\n    \n    class Breaker {\n        void foo(){\n            System.out.println(\"middle\");\n        }\n    }\n}\n\nclass Breaker{\n    void foo(){\n        System.out.println(\"Outer\");\n    }\n    \n}','Inner Classes',0,0,NULL,5),(3206,'the call to blue in main fails because it is called before the anon class\nis created. \n\nanonymous class bigBlue works fine, you can define anonymous classes as\nmembers \n\nalso anon class blue forgets to end with a ; \n\nabsract classes cannnot have private abstract members, how would they\nbe instantiated ?\n\nbecaue of that BlueGill cannot properly override method numberOfFins()\n\nan overriding method can choose not to throw the same exception or can \nthrow a narrower one. \n','public class Hello {\n    public static void main(String[] args) {\n        blue.biteHook();\n        \n        BlueGill blue = new BlueGill(){\n            public void biteHook(){\n                System.out.println(\"Not This Time\");\n            }\n        }\n        \n    }\n    \n    BlueGill bigBlue = new BlueGill(){\n        public int bubble() throws IOException {\n            System.out.println(\"Big Bubbles\");\n            return 5;\n        }\n        \n    };\n}\n\nabstract class Fish {\n    public abstract void swim();\n    private abstract int numberOfFins();\n    \n}\n\nclass BlueGill extends Fish {\n    public void swim(){\n        System.out.println(\"Swims in lakes\");\n    }\n    \n    public void biteHook() throws IOException {\n        System.out.println(\"What the hell\");\n    }\n    \n    public int bubble() throws Exception{\n        System.out.println(\"bubble bubble\");\n        return 2;\n    }\n}','Inner Classes',0,0,NULL,5),(3207,'numberOfFins() in abstract class Fish does not throw SQLException\n	so the override in BlueGill cannot throw a new Exception.\n\nbiteHook is declared in BlueGill then overriden in the annon class with\nthe same exception so its ok.\n\nthen the anon class does not override the method numberOfFins which was \nnot properly overriden in the abstract class so that makes the anon class\nnot compile. If it had overriden numberOfFins() then it could have compiled\n\nstill though the NOF in BlueGill threw that SQLException so it wont ever compile..','public class Hello {\n    public static void main(String[] args) {     \n        BlueGill blue = new BlueGill(){\n            public void biteHook() throws IOException{\n                System.out.println(\"Not This Time\");\n            }\n            public void biteHook(boolean yesno) throws NullPointerException{\n                System.out.println(\"That worm looks so tasty\");\n            }\n            \n        };\n        \n    }\n}\n\nabstract class Fish {\n    public abstract void swim() throws Exception;\n    public abstract int numberOfFins();\n    public static void breathe(){\n        System.out.println(\"ahhh\");\n    }\n    \n    \n}\n\nclass BlueGill extends Fish {\n    public void swim(){\n        breathe();\n        System.out.println(\"Swims in lakes\");\n    }\n    \n    public void biteHook() throws IOException {\n        System.out.println(\"What the hell\");\n    }\n    \n    public int numberOfFins() throws SQLException {\n        return 4;\n    }\n    \n    public int bubble() throws Exception{\n        System.out.println(\"bubble bubble\");\n        return 2;\n    }\n}','Inner Classes',0,0,NULL,5),(3208,'{ Car.this.drive(); }\n\nEngine() { Car.this.drive(); }','public class  Car {\n	class Engine {\n		// insert here\n	}\n	public static void main(SA){\n		new Car().go();\n	}\n	void go() {\n		new Engine();\n	}\n	void drive() { sout(\"hi\"); }\n}\n\n// what can be given at insert here to produce \"hi\" ?\n','Inner Classes',0,0,NULL,5),(3209,'no output is produced, the inner classes are valid and the exceptions are \nthrown properly','public class City {\n	class Manhattan {\n		void doStuff() throws Exception { sout(\"x \"); }\n	}\n	class Timesquare extends Manhattan {\n		void doStuff throws Exception {  }\n	}\n\n	public static void main(Stringp]] args) throws Exception{\n		new City().go();\n	}\n	void go() throws Exception { new Timesquare().doStuff(); }\n}','Inner Classes',0,0,NULL,5),(3210,'21','public class Navel {\n	private int size = 7;\n	private static int length = 3;\n	public static void main(String[] args) {\n		new Navel().go();\n	}\n	void go(){\n		int size = 5;\n		sout( new Gazer().adder() );\n	}\n	class Gazer {\n		int adder() { return size * length; }\n	}\n}	','Inner Classes',0,0,NULL,5),(3211,'ahhh\nahhh\nSwims in a lake','public class Hello {\n    public static void main(String[] args) {     \n        BlueGill blue = new BlueGill();\n        blue.breathe();\n        blue.swim();\n        \n    }\n}\n\nabstract class Fish {\n    public abstract void swim() throws Exception;\n    public abstract int numberOfFins();\n    public static void breathe(){\n        System.out.println(\"ahhh\");\n    }   \n}\n\nclass BlueGill extends Fish {\n    public void swim(){\n        breathe();     \n        System.out.println(\"Swims in a lake\");\n    }\n    \n    public int numberOfFins(){\n        return 5;    \n    }   \n}','Inner Classes',0,0,NULL,5),(3212,'ahhh','public class Hello {\n    public static void main(String[] args) {     \n        BlueGill blue = new BlueGill();\n        \n        Fish.breathe();\n        \n    }\n}\n\nabstract class Fish {\n    public abstract void swim() throws Exception;\n    public abstract int numberOfFins();\n    public static void breathe(){\n        System.out.println(\"ahhh\");\n    }   \n}\n\nclass BlueGill extends Fish {\n    public void swim(){\n        breathe();     \n        System.out.println(\"Swims in a lake\");\n    }\n    \n    public int numberOfFins(){\n        return 5;    \n    }   \n}','Inner Classes',0,0,NULL,5),(3213,'compiles','abstract class Fish {\n    public static int species = 100;\n    public abstract void swim() throws Exception;\n    public abstract int numberOfFins();\n    public static void breathe(){\n        System.out.println(\"ahhh\");\n    }   \n}\n\nclass BlueGill extends Fish {\n    public void swim(){\n        breathe();     \n        System.out.println(species);\n        System.out.println(\"Swims in a lake\");\n    }\n    \n    public int numberOfFins(){\n        return 5;    \n    }   \n}','Inner Classes',0,0,NULL,5),(3214,'compilation fails, \nClass sorter must be delcared static to be used in static methood main. ','public class Pockets {\n	public static void main(SA){\n		String[] sa = {\"nickle\",\"button\", \"key\", \"lint\" };\n		Sorter s = new Sorter();\n		for(String s2: sa) sout( s2+\" \" );\n		Arrays.sort(sa,s);\n		sout();\n		for(String s2 : sa) sout( s2+\" \" );\n		\n	}\n	class Sorter implements Comparator<String> {	\n		public int compare(String a, String b) {\n			return b.compareTo(a);\n		}\n	}\n}','Collections',0,0,NULL,5),(3215,'ahhh\n100\nSwims in a lake','public class Hello {\n    public static void main(String[] args) {     \n        BlueGill blue = new BlueGill();\n        blue.swim();\n        \n    }\n}\nclass BlueGill extends Fish {\n    public void swim(){\n        breathe();     \n        System.out.println(species);\n        System.out.println(\"Swims in a lake\");\n    }\n    \n    public int numberOfFins(){\n        return 5;    \n    }   \n}\n\nabstract class Fish {\n    public static int species = 100;\n    public abstract void swim() throws Exception;\n    public abstract int numberOfFins();\n    public static void breathe(){\n        System.out.println(\"ahhh\");\n    }   \n}\n   ','Inner Classes',0,0,NULL,5),(3216,'will not compile, BlueGill is an inner class therefor must be declared static\nto be used in static method main. ','public class Hello {\n    public static void main(String[] args) {     \n        BlueGill blue = new BlueGill();\n        blue.swim();\n        \n    }\n class BlueGill extends Fish {\n    public void swim(){\n        breathe();     \n        System.out.println(species);\n        System.out.println(\"Swims in a lake\");\n    }\n    \n    public int numberOfFins(){\n        return 5;    \n    }   \n}\n}\n\nabstract class Fish {\n    public static int species = 100;\n    public abstract void swim() throws Exception;\n    public abstract int numberOfFins();\n    public static void breathe(){\n        System.out.println(\"ahhh\");\n    }   \n}','Inner Classes',0,0,NULL,5),(3217,'ahhh\n100\nSwims in lake','public class Hello {\n    public static void main(String[] args) {     \n        BlueGill blue = new BlueGill();\n        blue.swim();\n        \n    }\n static class BlueGill extends Fish {\n    public void swim(){\n        breathe();     \n        System.out.println(species);\n        System.out.println(\"Swims in a lake\");\n    }\n    \n    public int numberOfFins(){\n        return 5;    \n    }   \n}\n}\n\nabstract class Fish {\n    public static int species = 100;\n    public abstract void swim() throws Exception;\n    public abstract int numberOfFins();\n    public static void breathe(){\n        System.out.println(\"ahhh\");\n    }   \n}','Inner Classes',0,0,NULL,5),(3218,'Arraylist doesn\'t have a method that returns the given object. \n\nalso you cannot return null when the return type is primitive.','public class Hello {\n    public static void main(String[] args) {     \n        Locker<SchoolSupplies> locker = new Locker<>();\n        locker.stuff.add(new Book(\"AAA\"));\n        locker.stuff.add(new Book(\"BBB\"));\n        \n        System.out.println(locker.getOut(new Book(\"AAA\")));\n        \n    }\n}\n\nclass Locker<T> {\n    ArrayList<T> stuff = new ArrayList<T>();\n    public T getOut(T that){\n        return stuff.get(that);\n    }\n}\n\nabstract class SchoolSupplies{\n    public abstract void use();\n    public abstract int lend();\n    public abstract boolean isCool();\n}\n\nclass Book extends SchoolSupplies{\n    private String name;\n    Book(String n){\n        name = n;\n    }\n    public void use(){\n        System.out.println(\"Read it\");\n    }\n    \n    public int lend(){\n        System.out.println(\"I need back by 4th\");\n        return 4;\n    }\n    \n    public boolean isCool(){\n        return false;\n    }\n}\n\nclass Pen extends SchoolSupplies {\n    public void use(){\n        System.out.println(\"doodle\");\n    }\n    \n    public int lend(){\n        System.out.println(\"just have it\");\n        return null;\n    }\n    \n    public boolean isCool(){\n        return true;\n    }\n}','Inner Classes',0,0,NULL,5),(3219,'compiles with a warning','public class Hello {\n    public static void main(String[] args) {     \n\n        List<Animal> animals = new ArrayList<Animal>();\n        animals.add(new Dog());\n        animals.add(new Cat());\n        \n        addAnimal(animals);\n    \n    }\n    \n    public static void addAnimal(List animals) {\n	animals.add(new Object());\n    }\n}','Generics',0,0,NULL,5),(3220,'will not compile,\n\ndefault constructors in Dog and Cat do not give proper calls to super()\nanimal non-defautl constructor','public class Hello {\n    public static void main(String[] args) {     \n\n        Animal a = new Animal(6,\"dog\");\n        System.out.println(a.getSize());\n    \n    }\n\n}\n        \nclass Animal implements Comparable<Animal>{\n    private int size;\n    private String name;\n    public Animal(int s, String n){\n        size = s;\n        name = n;\n        \n    }\n    public int getSize(){\n        return size;\n    }\n    public int compareTo(Animal a){\n        int asize = a.getSize();\n        int bsize = this.size;\n        \n        if(asize < bsize)\n            return 1;\n        else if(asize == bsize)\n            return 0;\n        else\n            return -1;\n        \n        \n    }\n    \n    public String toString(){\n        return name;\n    }\n}\n\nclass Dog extends Animal{}\nclass Cat extends Animal{} ','General',0,0,NULL,5),(3221,'will not compile,\n\n	should be...\n		for(Shaveable s : sList){\n			...','public class Hello {\n    public static void main(String[] args) {     \n        List<Spankable> spanklist = new ArrayList<>();\n        spanklist.add(new Doll());\n        spanklist.add(new Doll());\n        \n    }\n    \n    public static void runit(List<? extends Shaveable> sList){\n        for(Spankable s : sList){\n            s.shave();\n        }\n    }\n\n}\n\ninterface Shaveable{\n    public void shave();\n}\n\ninterface Spankable extends Shaveable{\n    public void spank();\n}\n\nclass Doll implements Spankable{\n    public void spank(){\n        System.out.println(\"OW!\");\n    }\n    \n    public void shave(){\n        System.out.println(\"HMMM : O\");\n    }\n}','General',0,0,NULL,5),(3222,'compiles\n\nhmmm : O\nhmmm : O','public class Hello {\n    public static void main(String[] args) {     \n        List<Spankable> spanklist = new ArrayList<>();\n        spanklist.add(new Doll());\n        spanklist.add(new Doll());\n        \n    }\n    \n    public static void runit(List<? extends Shaveable> sList){\n        for(Shaveable s : sList){\n            s.shave();\n        }\n    }\n\n}\n\ninterface Shaveable{\n    public void shave();\n}\n\ninterface Spankable extends Shaveable{\n    public void spank();\n}\n\nclass Doll implements Spankable{\n    public void spank(){\n        System.out.println(\"OW!\");\n    }\n    \n    public void shave(){\n        System.out.println(\"HMMM : O\");\n    }\n}','General',0,0,NULL,5),(3223,'HMMM : O\nHMMM : O\n\n','public class Hello {\n    public static void main(String[] args) {     \n        List<Spankable> spanklist = new ArrayList<>();\n        spanklist.add(new Doll());\n        spanklist.add(new Doll());\n        \n        runit(spanklist);\n        \n    }\n    \n    public static void runit(List<? extends Spankable> sList){\n        for(Shaveable s : sList){\n            s.shave();\n        }\n    }\n\n}\n\ninterface Shaveable{\n    public void shave();\n}\n\ninterface Spankable extends Shaveable{\n    public void spank();\n}\n\nclass Doll implements Spankable{\n    public void spank(){\n        System.out.println(\"OW!\");\n    }\n    \n    public void shave(){\n        System.out.println(\"HMMM : O\");\n    }\n}','General',0,0,NULL,5),(3224,'HMMM : O\nHMMM : O','class Hello {\n    public static void main(String[] args) {     \n        List<Spankable> spanklist = new ArrayList<>();\n        spanklist.add(new Doll());\n        spanklist.add(new Doll());\n        \n        runit(spanklist);\n        \n    }\n    \n    public static void runit(List<? extends Shaveable> sList){\n        for(Shaveable s : sList){\n            s.shave();\n        }\n    }\n\n}\n\ninterface Shaveable{\n    public void shave();\n}\n\ninterface Spankable extends Shaveable{\n    public void spank();\n}\n\nclass Doll implements Spankable{\n    public void spank(){\n        System.out.println(\"OW!\");\n    }\n    \n    public void shave(){\n        System.out.println(\"HMMM : O\");\n    }\n}                     ','General',0,0,NULL,5),(3225,'HMMM : O\nHMMM : O','class Hello {\n    public static void main(String[] args) {     \n        List<Doll> spanklist = new ArrayList<>();\n        spanklist.add(new Doll());\n        spanklist.add(new Doll());\n        \n        runit(spanklist);\n        \n    }\n    \n    public static void runit(List<? extends Shaveable> sList){\n        for(Shaveable s : sList){\n            s.shave();\n        }\n    }\n\n}\n\ninterface Shaveable{\n    public void shave();\n}\n\ninterface Spankable extends Shaveable{\n    public void spank();\n}\n\nclass Doll implements Spankable{\n    public void spank(){\n        System.out.println(\"OW!\");\n    }\n    \n    public void shave(){\n        System.out.println(\"HMMM : O\");\n    }\n}                  ','General',0,0,NULL,5),(3226,'/tmp/google/file.txt','class Hello {\n    public static void main(String[] args) {     \n        Path p1 = Paths.get(\"/home/max/tmp\");\n        Path p2 = Paths.get(\"/tmp/google/file.txt\");\n        System.out.println(p1.resolve(p2));\n        \n    }\n\n}','General',0,0,NULL,5),(3227,'/home/max/tmp/tmp/google/file.txt','class Hello {\n    public static void main(String[] args) {     \n        Path p1 = Paths.get(\"/home/max/tmp\");\n        Path p2 = Paths.get(\"tmp/google/file.txt\");\n        System.out.println(p1.resolve(p2));\n        \n    }\n\n}','IO',0,0,NULL,5),(3228,'/home/max/tmp/google/file.txt','class Hello {\n    public static void main(String[] args) {     \n        Path p1 = Paths.get(\"/home/max/tmp\");\n        Path p2 = Paths.get(\"google/file.txt\");\n        System.out.println(p1.resolve(p2));\n        \n    }\n\n}','IO',0,0,NULL,5),(3229,'/home/max/tmp/file.txt','class Hello {\n    public static void main(String[] args) {     \n        Path p1 = Paths.get(\"/home/max/tmp\");\n        Path p2 = Paths.get(\"file.txt\");\n        System.out.println(p1.resolve(p2));\n        \n    }\n\n}','General',0,0,NULL,5),(3230,'home/max/tmp/file.txt','class Hello {\n    public static void main(String[] args) {     \n        Path p1 = Paths.get(\"home/max/tmp\");\n        Path p2 = Paths.get(\"file.txt\");\n        System.out.println(p1.resolve(p2));\n        \n    }\n\n}','General',0,0,NULL,5),(3231,'home/max/tmp/file.txt/file.txt','class Hello {\n    public static void main(String[] args) {     \n        Path p1 = Paths.get(\"home/max/tmp/file.txt\");\n        Path p2 = Paths.get(\"file.txt\");\n        System.out.println(p1.resolve(p2));\n        \n    }\n\n}','General',0,0,NULL,5),(3232,'file.txt','class Hello {\n    public static void main(String[] args) {     \n        Path p1 = Paths.get(\"\");\n        Path p2 = Paths.get(\"file.txt\");\n        System.out.println(p1.resolve(p2));\n        \n    }\n\n}','General',0,0,NULL,5),(3233,'home/max/tmp/file.txt','class Hello {\n    public static void main(String[] args) {     \n        Path p1 = Paths.get(\"home/max/tmp/file.txt\");\n        Path p2 = Paths.get(\"\");\n        System.out.println(p1.resolve(p2));\n        \n    }\n\n}','General',0,0,NULL,5),(3234,'file.txt/home/max/tmp/file.txt','class Hello {\n    public static void main(String[] args) {     \n        Path p1 = Paths.get(\"home/max/tmp/file.txt\");\n        Path p2 = Paths.get(\"file.txt\");\n        System.out.println(p2.resolve(p1));\n        \n    }\n\n}','General',0,0,NULL,5),(3235,'true\n\nHowever Animal does not have an instanceof test in its boolean so be \ncareful you could get a classcastexception','public class Hello<T> {\n    public static void main(String[] args){\n\n        ArrayList<? extends Animal> c = makeArrayList(new Animal(5));\n        \n        Animal max = new Animal(100);\n        Animal bear = new Animal(45);\n        Animal Hippo = new Animal(45);\n        \n        System.out.println(bear.equals(Hippo));    \n    } \n    public static <G extends Animal> ArrayList<G> makeArrayList(G g){\n        ArrayList<G> genlist = new ArrayList();\n        genlist.add(g);\n        return genlist;\n        \n    }\n}\n\nclass Animal{\n    private int size;\n    public Animal(int s){\n        size = s;\n    }\n    public void makeSound(){\n            System.out.println(\"Sound!\");\n            \n    }\n    \n    public int getSize(){\n        return size;\n    }\n\n    public boolean equals(Object o){\n        // equals without instanceof \n        if(((Animal)o).getSize() == this.size){\n            return true;\n        } else {\n            return false;\n        }\n        \n    }\n}\n\nclass Flower {\n    public void pretty(){\n        System.out.println(\"i look so pretty\");\n    }\n}','General',0,0,NULL,5),(3236,'ClassCastException','public class Hello<T> {\n    public static void main(String[] args){\n\n        ArrayList<? extends Animal> c = makeArrayList(new Animal(5));\n        \n        Animal max = new Animal(100);\n        Animal bear = new Animal(45);\n        Animal Hippo = new Animal(45);\n        Flower flower = new Flower();\n        \n        System.out.println(bear.equals(Hippo));  \n        System.out.println(max.equals(flower));\n    } \n    public static <G extends Animal> ArrayList<G> makeArrayList(G g){\n        ArrayList<G> genlist = new ArrayList();\n        genlist.add(g);\n        return genlist;\n        \n    }\n}\n\nclass Animal{\n    private int size;\n    public Animal(int s){\n        size = s;\n    }\n    public void makeSound(){\n            System.out.println(\"Sound!\");\n            \n    }\n    \n    public int getSize(){\n        return size;\n    }\n\n    public boolean equals(Object o){\n        // equals without instanceof \n        if(((Animal)o).getSize() == this.size){\n            return true;\n        } else {\n            return false;\n        }\n        \n    }\n}\n\nclass Flower {\n    public void pretty(){\n        System.out.println(\"i look so pretty\");\n    }\n}','General',0,0,NULL,5),(3237,'instanceMethod() in Bar\nclassMethod() in Foo\n\nBriefly, when you override a method, you still get the benefits of run-time polymorphism, and when you hide, you don\'t\n\nWhy do we get instanceMethod from Bar, but classMethod() from Foo? Aren\'t we using the same instance f to access both of these? Yes we are - but since one is overriding and the other is hiding, we see different behavior.\n\nSince instanceMethod() is (drum roll please...) an instance method, in which Bar overrides the method from Foo, at run time the JVM uses the actual class of the instance f to determine which method to run. Although f was declared as a Foo, the actual instance we created was a new Bar(). So at runtime, the JVM finds that f is a Bar instance, and so it calls instanceMethod() in Bar rather than the one in Foo. That\'s how Java normally works for instance methods.\n\nWith classMethod() though. since (ahem) it\'s a class method, the compiler and JVM don\'t expect to need an actual instance to invoke the method. And even if you provide one (which we did: the instance referred to by f) the JVM will never look at it. The compiler will only look at the declared type of the reference, and use that declared type to determine, at compile time, which method to call. Since f is declared as type Foo, the compiler looks at f.classMethod() and decides it means Foo.classMethod. It doesn\'t matter that the instance reffered to by f is actually a Bar - for static methods, the compiler only uses the declared type of the reference. That\'s what we mean when we say a static method does not have run-time polymorphism.\n\nBecause instance methods and class methods have this important difference in behavior, we use different terms - \"overriding\" for instance methods and \"hiding\" for class methods - to distinguish between the two cases. And when we say you can\'t override a static method, what that means is that even if you write code that looks like it\'s overriding a static method (like the first Foo and Bar at the top of this page) - it won\'t behave like an overridden method. ','class Foo {\n    public static void classMethod() {\n        System.out.println(\"classMethod() in Foo\");\n    }\n \n    public void instanceMethod() {\n        System.out.println(\"instanceMethod() in Foo\");\n    }\n}\n \nclass Bar extends Foo {\n    public static void classMethod() {\n        System.out.println(\"classMethod() in Bar\");\n    }\n \n    public void instanceMethod() {\n        System.out.println(\"instanceMethod() in Bar\");\n    }\n}\n  \nclass Test {\n    public static void main(String[] args) {\n        Foo f = new Bar();\n        f.instanceMethod();\n        f.classMethod();\n    }\n}','General',0,0,NULL,5),(3238,'all animals eat\nall animals eat\nall animals eat\nEat salmon\n\nIt is allowed to call a static method of the class on an instance \nvariable, but it is confusing and not recomneded. \n\nstatic variables are not overriden by subclass methods they are hidden\n\nso, at runtime there will be no polymorphism for static methods','class Bear extends Animal{\n    private static int ALLBEARSAREBIG = 100;\n    \n    public Bear(){\n        super(ALLBEARSAREBIG);\n        \n    }\n    \n    public static void eat(){\n        System.out.println(\"Eat salmon\");\n    }\n    \n}\n\nclass Animal{\n    private int size;\n    public Animal(int s){\n        size = s;\n    }\n    public static void eat(){\n        System.out.println(\"all animals eat\");\n    }\n    public void makeSound(){\n            System.out.println(\"Sound!\");\n            \n    }\n    \n    public int getSize(){\n        return size;\n    }\n\n    public boolean equals(Object o){\n        // equals without instanceof \n        if(((Animal)o).getSize() == this.size){\n            return true;\n        } else {\n            return false;\n        }\n        \n    }\n}\n\npublic class Hello<T> {\n    public static void main(String[] args){\n        Animal cat = new Animal(5);\n        Animal bear = new Bear();\n        \n        cat.eat();\n        Animal.eat();\n        bear.eat();\n        Bear.eat();\n\n    } \n }','General',0,0,NULL,5),(3239,'will not compile you cannot override a static method\n\nto fix change eat in Bear to static or do something else with the other class\nand varialbes','public class Hello<T> {\n    public static void main(String[] args){\n        Animal cat = new Animal(5);\n        Animal bear = new Bear();\n        \n        cat.eat();\n        Animal.eat();\n        bear.eat();\n        Bear.eat();\n\n    } \n }\n\nclass Animal{\n    private int size;\n    public Animal(int s){\n        size = s;\n    }\n    public static void eat(){\n        System.out.println(\"all animals eat\");\n    }\n    public void makeSound(){\n            System.out.println(\"Sound!\");\n            \n    }\n    \n    public int getSize(){\n        return size;\n    }\n\n    public boolean equals(Object o){\n        // equals without instanceof \n        if(((Animal)o).getSize() == this.size){\n            return true;\n        } else {\n            return false;\n        }\n        \n    }\n}\n\nclass Bear extends Animal{\n    private static int ALLBEARSAREBIG = 100;\n    \n    public Bear(){\n        super(ALLBEARSAREBIG);\n        \n    }\n    \n    public void eat(){\n        System.out.println(\"Eat salmon\");\n    }\n    \n}','General',0,0,NULL,5),(3240,'will not compile,\n\ncall to super in Bear defautl constructor does not fit with ANimal int constructor\n\nremeber if you provide a parameterized constructor the implicit defautl one\ngoes away','public class Hello<T> {\n    public static void main(String[] args){\n        Animal cat = new Animal(5);\n        Animal bear = new Bear();\n        \n        cat.eat();\n        Animal.eat();\n        bear.eat();\n        Bear.eat();\n\n    } \n }\n\nclass Animal{\n    private int size;\n    public Animal(int s){\n        size = s;\n    }\n    public static void eat(){\n        System.out.println(\"all animals eat\");\n    }\n    public void makeSound(){\n            System.out.println(\"Sound!\");\n            \n    }\n    \n    public int getSize(){\n        return size;\n    }\n\n    public boolean equals(Object o){\n        // equals without instanceof \n        if(((Animal)o).getSize() == this.size){\n            return true;\n        } else {\n            return false;\n        }\n        \n    }\n}\n\nclass Bear extends Animal{\n\n    \n    public Bear(){\n        \n    }\n    \n    public static void eat(){\n        System.out.println(\"Eat salmon\");\n    }\n    \n}\n\nclass Flower {\n    public void pretty(){\n        System.out.println(\"i look so pretty\");\n    }\n}','General',0,0,NULL,5),(3241,'Will not compile, reference to resolve is ambiguous. \n\nboth resolve(String) and resolve(Path) match','Path p1 = Paths.get(\"/home/maxbisesi/file.txt\");\n        System.out.println(p1.resolve(null));','IO',0,0,NULL,5),(3242,'Compiles fine! you can use the overloaded method within the inner class\n\nTheres 8 people here so get the fire going','public class Hello {\n\n    public static void main(String[] args) {\n        \n        Burnable stick = new Burnable(){\n            int people = 8;\n            public void burn(){\n                System.out.println(\"Theres \"+people+\" people here so get the fire going\");\n            }\n            \n            public int unburn(){\n                System.out.println(\"That\'s impossible\");\n                return 0;\n            }\n            \n            public void shakeoff(int x){\n                System.out.println(\"That was my shoe!\"+x);\n            }\n            \n            public void shakeoff(){\n                \n                this.shakeoff(4);\n                System.out.println(\"its off\");\n            }\n            \n            \n            \n        };\n        \n        stick.burn();\n    }\n\n}\n\ninterface Burnable{\n    int people = 10;\n    void burn();\n    void shakeoff(int z);\n    int unburn();\n}','Inner Classes',0,0,NULL,5),(3243,'','The thread is the worker and the runnable is the job to be done','Threads',0,0,NULL,5),(3244,'Thread()\nThread(Runnable target)\nThread(Runnable target, String name)\nThread(String name)','Thread Constructors','Threads',0,0,NULL,5),(3245,'after the run() is complete','When is a thread considered dead?','Threads',0,0,NULL,5),(3246,'It is not guarenteed that the threads will be started in the order that\nthey are declared. Or that they will finish and start at the same time\n\nor that a loop will complete once it has begun.','Nothing is guarenteed in threading other than Each thread will start and each thread\nwill run to completion. ','Threads',0,0,NULL,5),(3247,'','The order in which runnable threads are chosen to run is not guarenteed.','Threads',0,0,NULL,5),(3248,'Will not compile, unreported Exception InteruptedException must be caught\nor thrown. ','public class Hello {\n    public static void main(String[] dicks){\n       Thread t = new Thread(new FooRunnable());\n       t.start();\n              \n\n    }\n}\n\nclass FooRunnable implements Runnable {\n    public void run(){\n        for(int x = 1; x <= 100; x++){\n            if((x % 10) == 0){\n                System.out.println(\"next 10\");\n            }\n            System.out.println(x+\" \");\n            Thread.sleep(1000); \n            }\n            \n        }\n    }\n}','Threads',0,0,NULL,5),(3249,'','A thread gets a default priority that is the default priority of the thread of\nexecution that creates it. ','Threads',0,0,NULL,5),(3250,'default thread priority is 5','FooRunnable r = new FooRunnable();\nThread t = new Thread(r);\nt.setPriority(8);\nt.start();\n','Threads',0,0,NULL,5),(3251,'Thread.MIN_PRIORITY (1)\nThread.NORM_PRIORITY (5)\nThread.MAX_PRIORITY (10)\n','Thread class constants ','Threads',0,0,NULL,5),(3252,'will cause a thread to go from running to runnable, but it might not do\nanything at all. ','Thread.yeild()','Threads',0,0,NULL,5),(3253,'FALSE','join() is static','Threads',0,0,NULL,5),(3254,'takes the currently running thread(if this were in the main method then that\nwould be the main thread) and joins it onto the end of the thread\nreferenced by t. \n\n','Thread t = new Thread();\nt.start();\nt.join();','Threads',0,0,NULL,5),(3255,'will not compile, only methods or blocks can be synchronized not variables\nor classes','public class Hello implements Runnable{\n    private synchronized Account acct = new Account(50);\n    \n    public static void main(String[] dicks){\n       Hello h = new Hello();\n       Thread one = new Thread(h);\n       Thread two = new Thread(h);\n       one.setName(\"Max\");\n       two.setName(\"Angela\");\n       \n       one.start();\n       two.start();\n\n    }\n    \n    public void run(){\n        for(int x = 0; x < 5; x++){\n            makeWithdrawl(10);\n            if(acct.getBalance() < 0){\n                System.out.println(\"account is overdrawn\");\n            }\n        }\n    }\n    \n    private synchronized void makeWithdrawl(int amt){\n        //this operation is not atomic\n        if(acct.getBalance() >= amt){\n            System.out.println(Thread.currentThread().getName()+\" is going to withdraw\");\n            \n            try{\n                Thread.sleep(500);\n            } catch(InterruptedException e){\n                \n            }\n            \n            acct.withdraw(amt);\n            System.out.println(Thread.currentThread().getName() + \" completes the withdraw\");\n        } else {\n            System.out.println(\"insufficinet funds for: \" + Thread.currentThread().getName() );\n        }\n    }\n}','Threads',0,0,NULL,5),(3256,'','If a thread goes to sleeep it holds any locks it has','Threads',0,0,NULL,5),(3257,'will not compile, method local inner classes must be declared before they \nare used. ','private JPanel createAddFlashCardPanel() {\n        JPanel jp = new JPanel(new FlowLayout());\n        \n        \n        JTextArea ja = new JTextArea(17,78);\n        ja.setWrapStyleWord(true);\n        JScrollPane question = new JScrollPane(ja);\n        ja.setTabSize(5);\n        ja.setFont(textfont);\n        \n        \n        AbstractDocument doc = (AbstractDocument) ja.getDocument();\n        doc.addDocumentListener(new TextChanger());\n        \n        class TextChanger implements DocumentListener {\n\n        @Override\n        public void insertUpdate(DocumentEvent e) {\n            try{\n                String addedtext = doc.getText(e.getOffset(), e.getLength());\n                System.out.println(addedtext);\n            } catch(BadLocationException blexc){\n                \n            }\n        }\n        @Override\n        public void removeUpdate(DocumentEvent e) {\n            \n        }\n        @Override\n        public void changedUpdate(DocumentEvent e) {\n            \n        }\n       \n    }\n  \n    ','Threads',0,0,NULL,5),(3258,'will not compile, foundcards is defined only in the scope of the try{}\n\nto fix \n\nput it above try{ } ',' private SwingWorker<String, String> worker = new SwingWorker<String, String>() {\n        public String doInBackground() {\n            while (!searchwords.isEmpty()) {\n                String word = searchwords.poll();\n                if(word == null){\n                    continue;\n                }\n                \n                try{\n                    ArrayList<Card> foundcards = Database.searchDatabase(word);\n                } catch (IOException e){\n                    System.out.println(\"problem serarch db\");\n                }\n\n                for (Card c : foundcards) {\n\n                }\n\n            }\n        }','Threads',0,0,NULL,5),(3259,'public static int getCount() {\n	synchronized(MyClass.class) {\n		return count;\n	}\n}\n\n- there is only one copyy of static data you\'re trying to protect so you\nonly need one lock per class to synchronize static methods- a lock for the whole class.\n\nevery class loaded in java has a corresponding instance of java.lang.Class\nrepresenting that Class. It\'s that Class instance used to lock on \nstatic methods. ','public static synchronized int getCount() {\n	return count;\n}\n\nhow to could this method be re made excactly using a synchronized block ?','Threads',0,0,NULL,5),(3260,'100x A\n\n100x AA\n\n100x AAA\n\nall these threads synchronize onto the same object','public class Hello extends Thread {\n   StringBuilder sb;\n    \n    public Hello(StringBuilder stb){\n        sb = stb;\n    }\n   \n    \n    public static void main(String[] dicks){\n        StringBuilder sbmain = new StringBuilder(\"A\");  \n        Hello a = new Hello(sbmain);\n        Hello b = new Hello(sbmain);\n        Hello c = new Hello(sbmain);\n        a.start();\n        b.start();\n        c.start();\n    }\n    \n    public void run(){\n        \n        synchronized(sb){\n            for(int i = 0; i < 100; i++){\n                System.out.println(sb);\n            }\n            sb.append(\"A\");  \n        }\n    }\n}','Threads',0,0,NULL,5),(3261,'un predicatable results - without synch. you cannot be sure what thread will\nwill be executing when. ','public class Hello extends Thread {\n   StringBuilder sb;\n    \n    public Hello(StringBuilder stb){\n        sb = stb;\n    }\n   \n    public static void main(String[] dicks){\n        StringBuilder sbmain = new StringBuilder(\"A\");  \n        Hello a = new Hello(sbmain);\n        Hello b = new Hello(sbmain);\n        Hello c = new Hello(sbmain);\n        a.start();\n        b.start();\n        c.start();\n    }  \n    public void run(){\n            for(int i = 0; i < 1000; i++){\n                System.out.println(i+\" \"+sb);\n            }\n            sb.append(\"A\");   \n    }\n}','Threads',0,0,NULL,5),(3262,'got it','Threads calling non-static synchronized methods in the same class will only\nblock each other if they\'re invoked using THE SAME INSTANCE. that\'s because theyeach\nlock on this instance, and if they\'re called using two differenct instances,\nthey get two locks, which do not interfere with each other. ','Threads',0,0,NULL,5),(3263,'got it ','Threads calling static synchronized methods in the same class will always \nblock each other- they all lock on the same class instance. ','Threads',0,0,NULL,5),(3264,'','a static synchronized method and a non-static synhcronized method will not block\neach other, ever. the static method locks on a Class instance, while the non\nstatic locks on this instance. These actions do not interfere with each other.','Threads',0,0,NULL,5),(3265,'','Generally use synchronization anytime more than one thread is accessing mutable\ndata. Dont worry about local varialbes each thread gets its own copy of those\nTwo threads executing the same method at the same time will use different\ncopiies of local variables.\n	However:\n		do worry about static and non sttaic fields if they contain data that \n		can be changed. ','Threads',0,0,NULL,5),(3266,'5\n5\n5','public class Hello {\n    \n   public static void main (String [] args){\n       Thing thing = new Thing();\n       \n       new Thread(new Accessor(thing),\"Max\").start();\n       new Thread(new Accessor(thing),\"Bart\").start();\n       new Thread(new Accessor(thing),\"Thread C\").start();\n \n   }\n}\n\nclass Accessor implements Runnable{\n    private Thing thisthing;\n    \n    public Accessor(Thing x){\n        thisthing = x;\n    }\n    \n    public void run(){\n        thisthing.setNonstaticField(5);\n        System.out.println(thisthing.getNonstaticField());\n    }\n}\n\nclass Thing {\n    private static int staticField;\n    private int nonstaticField;\n    \n    public static synchronized int getStaticField(){\n        return staticField;\n    }\n    \n    public static synchronized void setStaticField(int x){\n        //use class not this\n        Thing.staticField = x;\n    }\n    \n    public synchronized int getNonstaticField(){\n        return nonstaticField;\n    }\n    \n    public synchronized void setNonstaticField(int y){\n        this.nonstaticField = y;\n    }\n}','Threads',0,0,NULL,5),(3267,'un predictable results, to make predictable\n\nput loop code inside a synhcronized block that locks onto thisthing!','public class Hello {\n    \n   public static void main (String [] args){\n       Thing thing = new Thing();\n       \n       new Thread(new Accessor(thing),\"Max\").start();\n       new Thread(new Accessor(thing),\"Bart\").start();\n       new Thread(new Accessor(thing),\"Thread C\").start();\n \n   }\n}\n\nclass Accessor implements Runnable{\n    private Thing thisthing;\n    \n    public Accessor(Thing x){\n        thisthing = x;\n    }\n    \n    public void run(){\n        for(int i = 1; i <= 10; i++){\n            thisthing.setNonstaticField(i);\n            System.out.println(thisthing.getNonstaticField());\n        }\n    }\n}\n\nclass Thing {\n    private static int staticField;\n    private int nonstaticField;\n    \n    public static synchronized int getStaticField(){\n        return staticField;\n    }\n    \n    public static synchronized void setStaticField(int x){\n        //use class not this\n        Thing.staticField = x;\n    }\n    \n    public synchronized int getNonstaticField(){\n        return nonstaticField;\n    }\n    \n    public synchronized void setNonstaticField(int y){\n        this.nonstaticField = y;\n    }\n}','Threads',0,0,NULL,5),(3268,'run:\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n','public class Hello {\n    \n   public static void main (String [] args){\n       Thing thing = new Thing();\n       \n       new Thread(new Accessor(thing),\"Max\").start();\n       new Thread(new Accessor(thing),\"Bart\").start();\n       new Thread(new Accessor(thing),\"Thread C\").start();\n \n   }\n}\n\nclass Accessor implements Runnable{\n    private Thing thisthing;\n    \n    public Accessor(Thing x){\n        thisthing = x;\n    }\n    \n    public void run(){\n        synchronized(thisthing){\n            for(int i = 1; i <= 10; i++){\n              thisthing.setNonstaticField(i);\n             System.out.println(thisthing.getNonstaticField());\n         }\n        }\n    }\n}\n\nclass Thing {\n    private static int staticField;\n    private int nonstaticField;\n    \n    public static synchronized int getStaticField(){\n        return staticField;\n    }\n    \n    public static synchronized void setStaticField(int x){\n        //use class not this\n        Thing.staticField = x;\n    }\n    \n    public synchronized int getNonstaticField(){\n        return nonstaticField;\n    }\n    \n    public synchronized void setNonstaticField(int y){\n        this.nonstaticField = y;\n    }\n}','Threads',0,0,NULL,5),(3269,'SynchronizedRGB must be used carefully to avoid being seen in an inconsistent state. Suppose, for example, a thread executes the following code:\n\nSynchronizedRGB color =\n    new SynchronizedRGB(0, 0, 0, \"Pitch Black\");\n...\nint myColorInt = color.getRGB();      //Statement 1\nString myColorName = color.getName(); //Statement 2\n\nIf another thread invokes color.set after Statement 1 but before Statement 2, the value of myColorInt won\'t match the value of myColorName. To avoid this outcome, the two statements must be bound together:\n\nsynchronized (color) {\n    int myColorInt = color.getRGB();\n    String myColorName = color.getName();\n} \n\nThis kind of inconsistency is only possible for mutable objects — it will not be an issue for the immutable version of SynchronizedRGB.','class SynchronizedRGB {\n\n    // Values must be between 0 and 255.\n    private int red;\n    private int green;\n    private int blue;\n    private String name;\n\n    private void check(int red,\n                       int green,\n                       int blue) {\n        if (red < 0 || red > 255\n            || green < 0 || green > 255\n            || blue < 0 || blue > 255) {\n            throw new IllegalArgumentException();\n        }\n    }\n\n    public SynchronizedRGB(int red,\n                           int green,\n                           int blue,\n                           String name) {\n        check(red, green, blue);\n        this.red = red;\n        this.green = green;\n        this.blue = blue;\n        this.name = name;\n    }\n\n    public void set(int red,\n                    int green,\n                    int blue,\n                    String name) {\n        check(red, green, blue);\n        synchronized (this) {\n            this.red = red;\n            this.green = green;\n            this.blue = blue;\n            this.name = name;\n        }\n    }\n\n    public synchronized int getRGB() {\n        return ((red << 16) | (green << 8) | blue);\n    }\n\n    public synchronized String getName() {\n        return name;\n    }\n\n    public synchronized void invert() {\n        red = 255 - red;\n        green = 255 - green;\n        blue = 255 - blue;\n        name = \"Inverse of \" + name;\n    }\n}','Threads',0,0,NULL,5),(3270,'run:\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n30 \n29 \n28 \n27 \n26 \n25 \n24 \n23 \n22 \n21 \n20 \n19 \n18 \n17 \n16 \n15 \n14 \n13 \n12 \n11 \n30 \n29 \n28 \n27 \n26 \n25 \n24 \n23 \n22 \n21 \n20 \n19 \n18 \n17 \n16 \n15 \n14 \n13 \n12 \n11 \n30 \n29 \n28 \n27 \n26 \n25 \n24 \n23 \n22 \n21 \n20 \n19 \n18 \n17 \n16 \n15 \n14 \n13 \n12 \n11 \n\n','public class Hello {\n    \n   public static void main (String [] args){\n       Thing thing = new Thing();\n       \n       new Thread(new Accessor(thing),\"Max\").start();\n       new Thread(new Accessor(thing),\"Bart\").start();\n       new Thread(new Accessor(thing),\"Thread C\").start();\n       new Thread(new staticAccessor(),\"stat Max\").start();\n       new Thread(new staticAccessor(),\"stat bart\").start();\n       new Thread(new staticAccessor(),\"stat c\").start();\n \n   }\n}\n\nclass Accessor implements Runnable{\n    private Thing thisthing;\n    \n    public Accessor(Thing x){\n        thisthing = x;\n    }\n    \n    public void run(){\n        synchronized(thisthing){\n            for(int i = 1; i <= 10; i++){\n              thisthing.setNonstaticField(i);\n             System.out.println(thisthing.getNonstaticField());\n         }\n        }\n    }\n}\n\nclass staticAccessor implements Runnable {\n    \n    public void run(){\n        synchronized(Thing.class){\n            for(int i = 30; i > 10; i--){\n                Thing.setStaticField(i);\n                System.out.println(Thing.getStaticField()+\" \");\n            }\n        }\n    }\n    \n}','Threads',0,0,NULL,5),(3271,'this class may deadlock','class DeadlockRisk {\n    private static class Resource {\n        public int value;\n    }\n    \n    private Resource resA = new Resource();\n    private Resource resB = new Resource();\n    \n    public int read() {\n        synchronized(resA) { // may deadlock\n            synchronized(resB) {\n                return resB.value + resA.value;\n            }\n        }\n    }\n    \n    public void write(int a, int b){\n        synchronized(resB){//may deadlock\n            synchronized(resA){\n                resA.value = a;\n                resB.value = b;\n            }\n        }\n    }\n}','Threads',0,0,NULL,5),(3272,'','wait() notify() and notifyAll() must be called from within a synhcronized\ncontext! A thread can\'t invoke a wait or notify method on an object unless it owns \nthat object\'s lock','Threads',0,0,NULL,5),(3273,'run:\nwaiting for b to complete...\nTotal is 4950\n\n','public class Hello {\n    \n   public static void main (String [] args){\n       \n       ThreadB b = new ThreadB();\n       b.start();\n       \n       synchronized(b) {\n           try {\n               System.out.println(\"waiting for b to complete...\");\n               b.wait();\n           } catch(InterruptedException e) { }\n           \n           System.out.println(\"Total is \" + b.total);\n       }\n \n   }\n  \n}\n\nclass ThreadB extends Thread {\n       int total;\n       \n       public void run() {\n           synchronized(this) {\n               for(int i = 0; i<100; i++){\n                   total += i;\n               }\n               \n               notify();\n           }\n       }\n   }','Threads',0,0,NULL,5),(3274,'will not compile non static variable this cannot be referenced from\na static context. ','public class Hello {\n    \n   public static void main (String [] args){\n       \n       ThreadB b = new ThreadB();\n       b.start();\n       \n       synchronized(this) {\n           try {\n               System.out.println(\"waiting for b to complete...\");\n               b.wait();\n           } catch(InterruptedException e) { }\n           \n           System.out.println(\"Total is \" + b.total);\n       }\n \n   }\n  \n}','Threads',0,1,NULL,5),(3275,'','use notifyAll() to signal all waiting threads,\nnotify() will only signal one unspecified thread.','Threads',0,0,NULL,5),(3276,'this programm will wait indefinately, \nbecause the calculator was never started so the threads will continuously\nwait for it. ','public class Hello {\n    \n   public static void main (String [] args){\n      \n        Calculator cal = new Calculator();\n        new Reader(cal).start();\n        new Reader(cal).start();\n        new Reader(cal).start();\n\n   }\n  \n}\n\nclass Reader extends Thread {\n    Calculator c;\n    \n    public Reader(Calculator calc) {\n        c = calc;\n    }\n    \n    public void run(){\n        synchronized(c) {\n            try {\n                System.out.println(\"Waiting for calc\");\n                    c.wait();\n            } catch(InterruptedException e){ }\n                \n            System.out.println(\"Total is: \"+ c.total);\n            \n        }\n    }\n}\n\nclass Calculator implements Runnable {\n    int total;\n    \n    public void run() {\n        synchronized(this) {\n            for(int i = 0; i < 100; i++){\n                total += i;\n            }\n            notifyAll();\n        }\n    }\n}','Threads',0,0,NULL,5),(3277,'will not compile, run() in Calculator cannot override run() in Runnable\noverriding method is static','public class Hello {\n    \n   public static void main (String [] args){\n      \n        Calculator cal = new Calculator();\n        new Reader(cal).start();\n        new Reader(cal).start();\n        new Reader(cal).start();\n        new Thread(cal).start();\n\n   }\n  \n}\n\nclass Reader extends Thread {\n    Calculator c;\n    \n    public Reader(Calculator calc) {\n        c = calc;\n    }\n    \n    public void run(){\n        synchronized(c) {\n            try {\n                System.out.println(\"Waiting for calc\");\n                    c.wait();\n            } catch(InterruptedException e){ }\n                \n            System.out.println(\"Total is: \"+ c.total);\n            \n        }\n    }\n}\n\nclass Calculator implements Runnable {\n    int total;\n    \n    public static void run() {\n        synchronized(this) {\n            for(int i = 0; i < 100; i++){\n                total += i;\n            }\n            notifyAll();\n        }\n    }\n}','Threads',0,0,NULL,5),(3278,'Will not compile Collections.asList() does not exist \n\nyour thinking of Arrays.asList();','public String getSection(){\n	String[] sections = {\"ABD\",\"AfG\",\"HTL\",\"AtL\",\"MAX\",\"AKH\",\"TYU\"};	\n     List<String> sectionList = Collections.asList(sections);\n     Collections.shuffle(sectionList);\n     String ret = sectionList.get(counter);\n	counter++;\n	return ret;\n}','Threads',0,0,NULL,5),(3279,'will not compile, \n\nList<String> coming from Arrays.asList cannot be converted to ArrayList.\n\nTherefore secionList should be a List<String>\n',' public String getSection(){\n            String[] sections = {\"ABD\",\"AfG\",\"HTL\",\"AtL\",\"MAX\",\"AKH\",\"TYU\"};\n            ArrayList sectionList = Arrays.asList(sections); \n            Collections.shuffle(sectionList);\n            String ret = sectionList.get(counter);\n            counter++;\n            return ret;\n        }','Threads',0,0,NULL,5),(3280,'It will print an undeterminable series of codes though they will be in order,\n\nthe getSection() method has a block that is synchronized on the CodeMake.class\nobject but that only protects static methods.\n\nso when one thread is synched on CodeMaker.class no other thread can execute \nthat same block of code, here it is no applicable because all the threads \nhave the same block of code. That counter is the same for all threads,\nwhile the sections array is copied across all instances. The array is \nnot mutated in any way though. ','class CodeMaker{\n    private String code = \": \";\n    private static int counter = 0;\n    private String[] sections = {\"ABD\",\"AfG\",\"HTL\",\"AtL\",\"MAX\",\"AKH\",\"TYU\"};\n    \n    \n    class SectionGenerator implements Runnable{\n        //private static int counter = 0; cannot have static members in inner class\n           \n        public String getSection(){\n            \n            synchronized(CodeMaker.class){\n                //sections.size()\n                if(counter < sections.length){\n                    String sec = sections[counter];\n                    counter++;\n                    return sec;\n                }\n            }\n            return null;\n        }\n        \n        public void run() {\n            code += getSection() + \" : \";\n        }\n\n    }\n    \n    public void coder(){\n        for(int i = 0; i < 7; i++){\n            new Thread(new SectionGenerator()).start();\n        }\n        System.out.println(\"code: \"+code);\n    }\n    \n    \n}','Threads',0,0,NULL,5),(3281,'will not compile illegal modifier static in inner class, \n\nto fix you would have to make counter final but that would defeat the\npurpose of having a counter!','class CodeMaker{\n    private String code = \": \";\n    private String[] sections = {\"ABD\",\"AfG\",\"HTL\",\"AtL\",\"MAX\",\"AKH\",\"TYU\"};\n    \n    \n    class SectionGenerator implements Runnable{\n        private static int counter = 0;\n           \n        public String getSection(){\n            \n            synchronized(CodeMaker.class){\n                //sections.size()\n                if(counter < sections.length){\n                    String sec = sections[counter];\n                    counter++;\n                    return sec;\n                }\n            }\n            return null;\n        }\n        \n        public void run() {\n            code += getSection() + \" : \";\n        }\n\n    }\n    \n    public void coder(){\n        for(int i = 0; i <= 7; i++){\n            new Thread(new SectionGenerator()).start();\n        }\n        System.out.println(\"code: \"+code);\n    }\n    \n    \n}','Threads',0,0,NULL,5),(3282,'will not compile, an array does not have a size() method \nit has a length attribute','class CodeMaker{\n    private String code = \": \";\n    private static int counter = 0;\n    private String[] sections = {\"ABD\",\"AfG\",\"HTL\",\"AtL\",\"MAX\",\"AKH\",\"TYU\"};\n    \n    \n    class SectionGenerator implements Runnable{\n           \n        public String getSection(){\n            \n            synchronized(CodeMaker.class){\n                if(counter < sections.size()){\n                    String sec = sections[counter];\n                    counter++;\n                    return sec;\n                }\n            }\n            return null;\n        }\n        \n        public void run() {\n            code += getSection() + \" : \";\n        }\n\n    }\n    \n    public void coder(){\n        for(int i = 0; i <= 7; i++){\n            new Thread(new SectionGenerator()).start();\n        }\n        System.out.println(\"code: \"+code);\n    }\n    \n    \n}','Threads',0,0,NULL,5),(3283,'code: : AfG : HTL : AtL : MAX : \ncode: : ABD : AfG : HTL : AtL : MAX : AKH : TYU : \ncode: : ABD : AfG : HTL : AtL : MAX : AKH : TYU :\ncode: : ABD : HTL : AtL : MAX : AKH : TYU : \ncode: : ABD : AfG : HTL : AtL : MAX : AKH : TYU : \n\n...results from a few different runs. Without synchronization you cannot\nbe sure what will print because one thread could come in bewteen execution\nof getSection() and disrupt the results. This however will not change the\norder in which the code are retrieved because no matter \nhow choatic the threads execute there is no code that will\ncause static int counter to decrease or increase more than one. \n','class CodeMaker{\n    private String code = \": \";\n    private static int counter = 0;\n    private String[] sections = {\"ABD\",\"AfG\",\"HTL\",\"AtL\",\"MAX\",\"AKH\",\"TYU\"};\n    \n    \n    class SectionGenerator implements Runnable{\n           \n        public String getSection(){\n            \n                if(counter < sections.length){\n                    String sec = sections[counter];\n                    counter++;\n                    return sec;\n                }\n            \n            return null;\n        }\n        \n        public void run() {\n            code += getSection() + \" : \";\n        }\n\n    }\n    \n    public void coder(){\n        for(int i = 0; i <= 7; i++){\n            new Thread(new SectionGenerator()).start();\n        }\n        System.out.println(\"code: \"+code);\n    }\n    \n    \n}','Threads',0,0,NULL,5),(3284,'This code will not print accurate results as in it will not reliably\nprint all the sections. \n\nThis is becaue the reading of a code and tacking it into the complete \ncode is not an atomic operation. \n\nto uniformly print all the codes you would do this:\n\n	class SectionGenerator implements Runnable{\n\n        public void run() {\n            synchronized(CodeMaker.class){\n            \n                if(counter < sections.length){\n                    String sec = sections[counter];\n                    counter++;\n                    code += sec + \" : \";\n                }\n\n                \n            }\n        }\n\n    }','class CodeMaker{\n    private String code = \": \";\n    private int counter = 0;\n    private static String[] sections = {\"ABD\",\"AfG\",\"HTL\",\"AtL\",\"MAX\",\"AKH\",\"TYU\"};\n    \n    \n    class SectionGenerator implements Runnable{\n           \n        public String getSection(){\n            \n            synchronized(CodeMaker.class){\n            \n                if(counter < sections.length){\n                    String sec = sections[counter];\n                    counter++;\n                    return sec;\n                }\n                \n                return null;\n                \n            }\n            \n            \n        }\n        \n        public void run() {\n            code += getSection() + \" : \";\n        }\n\n    }\n    \n    public void coder(){\n        for(int i = 0; i <= 7; i++){\n            new Thread(new SectionGenerator()).start();\n        }\n        System.out.println(\"code: \"+code);\n    }\n    \n    \n}\n\npublic class Hello {\n    \n   public static void main (String [] args){\n      new CodeMaker().coder();\n\n   }\n  \n}','Threads',0,0,NULL,5),(3285,'will print:\n\ncode: : ABD : AfG : HTL : AtL : MAX : AKH : TYU :\n\nevery time. \n\nin previous questions counter was not static, if that were the case here\nresults would not be predictable. ','class CodeMaker{\n    private String code = \": \";\n    private int counter = 0;\n    private static String[] sections = {\"ABD\",\"AfG\",\"HTL\",\"AtL\",\"MAX\",\"AKH\",\"TYU\"};\n    \n    \n    class SectionGenerator implements Runnable{\n\n        public void run() {\n            synchronized(CodeMaker.class){\n            \n                if(counter < sections.length){\n                    String sec = sections[counter];\n                    counter++;\n                    code += sec + \" : \";\n                }\n\n                \n            }\n        }\n\n    }\n    \n    public void coder(){\n        for(int i = 0; i <= 7; i++){\n            new Thread(new SectionGenerator()).start();\n        }\n        System.out.println(\"code: \"+code);\n    }\n    \n    \n}\n\npublic class Hello {\n    \n   public static void main (String [] args){\n      new CodeMaker().coder();\n\n   }\n  \n}','Threads',0,0,NULL,5),(3286,'will produce unpredictable results because counter is not static, so\nits access is not locked by synchronization onto CodeMaker.class\n','public class Hello {\n    \n   public static void main (String [] args){\n      new CodeMaker().coder();\n\n   }\n  \n}\n\nclass CodeMaker{\n    private String code = \": \";\n    private int counter = 0;\n    private static String[] sections = {\"ABD\",\"AfG\",\"HTL\",\"AtL\",\"MAX\",\"AKH\",\"TYU\"};\n    \n    \n    class SectionGenerator implements Runnable{\n\n        public void run() {\n            synchronized(CodeMaker.class){\n            \n                if(counter < sections.length){\n                    String sec = sections[counter];\n                    counter++;\n                    code += sec + \" : \";\n                }\n                \n            }\n        }\n\n    }\n    \n    public void coder(){\n        for(int i = 0; i <= 7; i++){\n            new Thread(new SectionGenerator()).start();\n        }\n        System.out.println(\"code: \"+code);\n    }\n    \n    \n}','Threads',0,0,NULL,5),(3287,'without synchronization here the results will be wildly unpredictable.','class statPrinter {\n    private int counter = 0;\n    \n    class Adder implements Runnable {\n        \n        public void run(){\n                //Thread.sleep(1000); with no try\n                counter++;\n                System.out.println(counter + \", Adder +1 \");  \n        }\n    }\n    \n    class Minuser implements Runnable {\n        public void run() {\n                counter--;\n                System.out.println(counter+\", Minuser -1 \");    \n        }\n    }\n    \n    public void test(){\n        for(int i = 0; i < 100; i++){\n            new Thread(new Adder()).start();\n            new Thread(new Minuser()).start();\n            \n        }\n    }\n}','Threads',0,0,NULL,5),(3288,'will not compile, unreported interrupt exception coming from \nThread.sleep();\n\nmust wrap in try catch or declare it to be thrown','class statPrinter {\n    private int counter = 0;\n    \n    class Adder implements Runnable {\n        \n        public void run(){\n                Thread.sleep(1000); \n                counter++;\n                System.out.println(counter + \", Adder +1 \");  \n        }\n    }\n    \n    class Minuser implements Runnable {\n        public void run() {\n                Thread.sleep(500);\n                counter--;\n                System.out.println(counter+\", Minuser -1 \");    \n        }\n    }\n    \n    public void test(){\n        for(int i = 0; i < 100; i++){\n            new Thread(new Adder()).start();\n            new Thread(new Minuser()).start();\n            \n        }\n    }\n}','Threads',0,0,NULL,5),(3289,'These results are unpredicatable, \n\nyes run() can be synched, these two methods synchronize on the current\nobject, all that means is that theyre code \n\n	counter++;\n     System.out.println(counter+\", Minuser -1 \"); \n\n	counter--;\n      System.out.println(counter+\", Minuser -1 \"); 	\n\nwill run in order completely without being interrupted by another thread.\n\nhowever that does not stop another thread from jumping the gun and being\nrun twice though!\n\n','class statPrinter {\n    private int counter = 0;\n    \n    class Adder implements Runnable {\n        \n        public synchronized void run(){\n                counter++;\n                System.out.println(counter + \", Adder +1 \");  \n        }\n    }\n    \n    class Minuser implements Runnable {\n        public synchronized void run() {\n                counter--;\n                System.out.println(counter+\", Minuser -1 \");    \n        }\n    }\n    \n    public void test(){\n        for(int i = 0; i < 100; i++){\n            new Thread(new Adder()).start();\n            new Thread(new Minuser()).start();\n            \n        }\n    }\n}','Threads',0,0,NULL,5),(3290,'this will give unpredictable results, \n\npublic void run() {\n            synchronized(this){\n                counter--;\n                System.out.println(counter+\", Minuser -1 \");   \n            }\n        }\n\nis the same as\n\npublic synchronized void run(){\n	...\n}\n\n\nthey both lock onto the current obejct, meaning no other thread can\naccess that object. The variable of concern here though is counter which\nis a variable of the statPrinter object. ','class statPrinter {\n    private int counter = 0;\n    \n    class Adder implements Runnable {\n        \n        public void run(){\n            synchronized(this){\n                counter++;\n                System.out.println(counter + \", Adder +1 \");  \n            }\n        }\n    }\n    \n    class Minuser implements Runnable {\n        public void run() {\n            synchronized(this){\n                counter--;\n                System.out.println(counter+\", Minuser -1 \");   \n            }\n        }\n    }\n    \n    public void test(){\n        for(int i = 0; i < 100; i++){\n            new Thread(new Adder()).start();\n            new Thread(new Minuser()).start();\n            \n        }\n    }\n}','Threads',0,0,NULL,5),(3291,'Will not compile you cannot intitialize an array with shorthand like that.\nBecause, at the time of creation java wants to know excactly how \nmuch memory to allocate when you jsut create the reference you basically\ncreate nothing.\n\nin the constructor you whene you initialize you have to excplicitly\ncreate the memory with the new array using new. \n\nto compile do this:\n	\n	sections = new String[]{\"ABD\",\"AfG\",\"HTL\",\"AtL\",\"MAX\",\"AKH\",\"TYU\"};','class CodeMaker{\n    private String code;\n    private int counter;\n    private static String[] sections;\n    private ArrayList<String> al;\n    \n    public CodeMaker(){\n        code = \": \";\n        counter = 0;\n        sections = {\"ABD\",\"AfG\",\"HTL\",\"AtL\",\"MAX\",\"AKH\",\"TYU\"};\n        al = new ArrayList<>();\n    }\n    \n    \n    class SectionGenerator implements Runnable{\n\n        public void run() {\n            synchronized(CodeMaker.class){\n            \n                if(counter < sections.length){\n                    String sec = sections[counter];\n                    counter++;\n                    code += sec + \" : \";\n                }\n                \n            }\n        }\n\n    }\n    \n    public void coder(){\n        for(int i = 0; i <= 10; i++){\n            new Thread(new SectionGenerator()).start();\n        }\n        System.out.println(\"code: \"+code);\n    }\n    \n    \n}','Threads',0,0,NULL,5),(3292,'will not compile, Constructors cannot be synchronized. ','class CodeMaker{\n    private String code;\n    private int counter;\n    private static String[] sections;\n    private ArrayList<String> al;\n    \n    public synchronized CodeMaker(){\n        code = \": \";\n        counter = 0;\n        sections = new String[]{\"ABD\",\"AfG\",\"HTL\",\"AtL\",\"MAX\",\"AKH\",\"TYU\"};\n        al = new ArrayList<>();\n    }\n    \n    \n    class SectionGenerator implements Runnable{\n\n        public void run() {\n            synchronized(CodeMaker.class){\n            \n                if(counter < sections.length){\n                    String sec = sections[counter];\n                    counter++;\n                    code += sec + \" : \";\n                }\n                \n            }\n        }\n\n    }\n    \n    public void coder(){\n        for(int i = 0; i <= 10; i++){\n            new Thread(new SectionGenerator()).start();\n        }\n        System.out.println(\"code: \"+code);\n    }\n    \n    \n}','Threads',0,0,NULL,5),(3293,'will not compile becaue of wait(),\n\nureported exception, interruptedexception, must be caught or thrown\n\n','class CodeMaker  extends Thread {\n    private String code;\n    private int counter;\n    private ArrayList<String> al;\n    private char[] letters = {\'A\',\'B\',\'C\',\'D\',\'E\',\'F\',\'G\',\'H\',\'I\'};\n    \n    public CodeMaker(){\n        counter = 0;\n        al = new ArrayList<>();\n    }\n\n    class SectionGenerator implements Runnable{\n        private String sec = \"\";\n        private Random ran;\n\n        public void run() {\n            //tried to use notify outside of synchronized context\n            synchronized(this){\n                int x = ran.nextInt(3);\n                int y = ran.nextInt(3);\n                int z = ran.nextInt(3);\n            \n            \n                sec += letters[x];\n                sec += letters[y];\n                sec += letters[z];\n                notifyAll();\n            }\n        }\n        \n        public synchronized String section(){\n            return sec;\n        }\n\n    }\n    \n    class NumberGenerator implements Runnable{\n        private String number = \"\";\n        private Random ran;\n        \n        public void run(){\n            //tried to use notify outside of synchronized context\n            synchronized(this){\n                int x1 = ran.nextInt(100);\n                int x2 = ran.nextInt(100);\n                int x3 = ran.nextInt(100);\n            \n                number+= x1+\".\"+x2+\".\"+x3;\n                notifyAll();\n            }\n        }\n        \n        public synchronized String Number(){\n            return number;\n        }\n    }\n    \n   public void run(){\n       \n       SectionGenerator sg1 = new SectionGenerator();\n       NumberGenerator ng1 = new NumberGenerator();\n       Thread t1 = new Thread(sg1);\n       Thread t2 = new Thread(ng1);\n       \n       t1.start();\n       t2.start();\n       \n       t1.wait();\n       code += sg1.section();\n       t2.wait();\n       code += ng1.Number();\n       \n       System.out.println(code);\n\n       \n   }\n    \n    \n}\n','Threads',0,0,NULL,5),(3294,'will not compile, not a proper override of run(),\n\noverrides cannot throw new or broader checked exceptions','class CodeMaker  extends Thread {\n    private String code;\n    private int counter;\n    private ArrayList<String> al;\n    private char[] letters = {\'A\',\'B\',\'C\',\'D\',\'E\',\'F\',\'G\',\'H\',\'I\'};\n    \n    public CodeMaker(){\n        counter = 0;\n        al = new ArrayList<>();\n    }\n\n    class SectionGenerator implements Runnable{\n        private String sec = \"\";\n        private Random ran;\n\n        public void run() {\n            //tried to use notify outside of synchronized context\n            synchronized(this){\n                int x = ran.nextInt(3);\n                int y = ran.nextInt(3);\n                int z = ran.nextInt(3);\n            \n            \n                sec += letters[x];\n                sec += letters[y];\n                sec += letters[z];\n                notifyAll();\n            }\n        }\n        \n        public synchronized String section(){\n            return sec;\n        }\n\n    }\n    \n    class NumberGenerator implements Runnable{\n        private String number = \"\";\n        private Random ran;\n        \n        public void run(){\n            //tried to use notify outside of synchronized context\n            synchronized(this){\n                int x1 = ran.nextInt(100);\n                int x2 = ran.nextInt(100);\n                int x3 = ran.nextInt(100);\n            \n                number+= x1+\".\"+x2+\".\"+x3;\n                notifyAll();\n            }\n        }\n        \n        public synchronized String Number(){\n            return number;\n        }\n    }\n    \n   public void run() throws InterruptedException {\n       \n       SectionGenerator sg1 = new SectionGenerator();\n       NumberGenerator ng1 = new NumberGenerator();\n       Thread t1 = new Thread(sg1);\n       Thread t2 = new Thread(ng1);\n       \n       t1.start();\n       t2.start();\n       \n       t1.wait();\n       code += sg1.section();\n       t2.wait();\n       code += ng1.Number();\n       \n       System.out.println(code);\n\n       \n   }\n    \n    \n}','Threads',0,0,NULL,5),(3295,'NPE, ran is nevere intitialized. ','public class Hello extends Thread {\n    public static void main(String[] args){\n        new CodeMaker().start();\n    }\n}\n\nclass CodeMaker  extends Thread {\n    private String code;\n    private int counter;\n    private ArrayList<String> al;\n    private char[] letters = {\'A\',\'B\',\'C\',\'D\',\'E\',\'F\',\'G\',\'H\',\'I\'};\n    \n    public CodeMaker(){\n        counter = 0;\n        al = new ArrayList<>();\n    }\n\n    class SectionGenerator implements Runnable{\n        private String sec = \"\";\n        private Random ran;\n\n        public void run() {\n            //tried to use notify outside of synchronized context\n            synchronized(this){\n                int x = ran.nextInt(3);\n                int y = ran.nextInt(3);\n                int z = ran.nextInt(3);\n            \n            \n                sec += letters[x];\n                sec += letters[y];\n                sec += letters[z];\n                notifyAll();\n            }\n        }\n        \n        public synchronized String section(){\n            return sec;\n        }\n\n    }\n    \n    class NumberGenerator implements Runnable{\n        private String number = \"\";\n        private Random ran;\n        \n        public void run(){\n            //tried to use notify outside of synchronized context\n            synchronized(this){\n                int x1 = ran.nextInt(100);\n                int x2 = ran.nextInt(100);\n                int x3 = ran.nextInt(100);\n            \n                number += x1+\".\"+x2+\".\"+x3;\n                notifyAll();\n            }\n        }\n        \n        public synchronized String Number(){\n            return number;\n        }\n    }\n    \n   public synchronized void run(){\n       \n       SectionGenerator sg1 = new SectionGenerator();\n       NumberGenerator ng1 = new NumberGenerator();\n       Thread t1 = new Thread(sg1);\n       Thread t2 = new Thread(ng1);\n       \n       t1.start();\n       t2.start();\n       \n       try{\n        t1.wait();\n        code += sg1.section();\n        t2.wait();\n        code += ng1.Number();\n       } catch(InterruptedException e){\n           \n       }\n       System.out.println(code);\n\n       \n   }\n    \n    \n}','Threads',0,0,NULL,5),(3296,'IllegalMonitorStateException, ','public class Hello extends Thread {\n    public static void main(String[] args){\n        new CodeMaker().start();\n    }\n}\n\nclass CodeMaker  extends Thread {\n    private String code;\n    private int counter;\n    private ArrayList<String> al;\n    private char[] letters = {\'A\',\'B\',\'C\',\'D\',\'E\',\'F\',\'G\',\'H\',\'I\'};\n    \n    public CodeMaker(){\n        counter = 0;\n        al = new ArrayList<>();\n    }\n\n    class SectionGenerator implements Runnable{\n        private String sec = \"\";\n        private Random ran = new Random();\n\n        public void run() {\n            //tried to use notify outside of synchronized context\n            synchronized(this){\n                int x = ran.nextInt(3);\n                int y = ran.nextInt(3);\n                int z = ran.nextInt(3);\n            \n            \n                sec += letters[x];\n                sec += letters[y];\n                sec += letters[z];\n                notifyAll();\n            }\n        }\n        \n        public synchronized String section(){\n            return sec;\n        }\n\n    }\n    \n    class NumberGenerator implements Runnable{\n        private String number = \"\";\n        private Random ran = new Random();\n        \n        public void run(){\n            //tried to use notify outside of synchronized context\n            synchronized(this){\n                int x1 = ran.nextInt(100);\n                int x2 = ran.nextInt(100);\n                int x3 = ran.nextInt(100);\n            \n                number += x1+\".\"+x2+\".\"+x3;\n                notifyAll();\n            }\n        }\n        \n        public synchronized String Number(){\n            return number;\n        }\n    }\n    \n   public synchronized void run(){\n       \n       SectionGenerator sg1 = new SectionGenerator();\n       NumberGenerator ng1 = new NumberGenerator();\n       Thread t1 = new Thread(sg1);\n       Thread t2 = new Thread(ng1);\n       \n       t1.start();\n       t2.start();\n       \n       try{\n        t1.wait();\n        code += sg1.section();\n        t2.wait();\n        code += ng1.Number();\n       } catch(InterruptedException e){\n           \n       }\n       System.out.println(code);\n\n       \n   }\n    \n    \n}','Threads',0,0,NULL,5),(3297,'will not compile, static classes are not allowed in inner classes,\n\nonly static final varialbe definitions is allowed.','public class Hello extends Thread {\n    public static void main(String[] args){\n        \n    }\n    \n    class Operator extends Thread {\n        Machine machine = new Machine();\n        Machine.MachineInstructions job;\n        \n        public void run(){\n            while(true){\n                String shape = getShapeFromUser();\n                job = calculateNewInstructionsFor(shape);\n                \n                machine.addJob(job);\n            }\n        }\n        \n        public Machine.MachineInstructions calculateNewInstructionsFor(String x){\n            // dah duh duu da du\n            return machine.new MachineInstructions();\n        }\n        \n        public String getShapeFromUser(){\n            System.out.println(\"What shape? square ok thanks\");\n            return \"Square\";\n        }\n        \n    }\n    \n    class Machine extends Thread {\n        List<MachineInstructions> joblist = new ArrayList<>(0);\n        \n        public void addJob(MachineInstructions job){\n            synchronized(joblist){\n                joblist.add(job);\n                joblist.notify();\n            }\n        }\n        \n        public void run(){\n            while(true) {\n                synchronized(joblist) {\n                    //wait until at least one job is available\n                    while(joblist.isEmpty()) {\n                        try{\n                            joblist.wait();\n                        } catch(InterruptedException ei){\n                            \n                        }\n                        \n                        //if we get here you know the list is\'nt empty\n                        MachineInstructions inst = joblist.remove(0);\n                        \n                    }\n                }\n            }\n        }\n        \n        \n        static class MachineInstructions {\n            \n        }\n    }\n}','Threads',0,0,NULL,5),(3298,'will not compile, non static inner classes cannot be accessed from static\nmain','public class Hello extends Thread {\n    public static void main(String[] args){\n        new Operator().start();\n        new Machine().start();\n    }\n    \n    class Operator extends Thread {\n        Machine machine = new Machine();\n        Machine.MachineInstructions job;\n        \n        public void run(){\n            while(true){\n                String shape = getShapeFromUser();\n                job = calculateNewInstructionsFor(shape);\n                \n                machine.addJob(job);\n            }\n        }\n        \n        public Machine.MachineInstructions calculateNewInstructionsFor(String x){\n            // dah duh duu da du\n            return machine.new MachineInstructions(x);\n        }\n        \n        public String getShapeFromUser(){\n            System.out.println(\"What shape? square ok thanks\");\n            return \"Square\";\n        }\n        \n    }\n    \n    class Machine extends Thread {\n        List<MachineInstructions> joblist = new ArrayList<>();\n        \n        public void addJob(MachineInstructions job){\n            synchronized(joblist){\n                joblist.add(job);\n                joblist.notify();\n            }\n        }\n        \n        public void run(){\n            while(true) {\n                synchronized(joblist) {\n                    //wait until at least one job is available\n                    while(joblist.isEmpty()) {\n                        try{\n                            joblist.wait();\n                        } catch(InterruptedException ei){\n                            \n                        }\n                        \n                        //if we get here you know the list is\'nt empty\n                        MachineInstructions inst = joblist.remove(0);\n                        \n                        \n                    }\n                }\n            }\n        }\n        \n        \n        class MachineInstructions {\n            private String shape;\n            \n            public MachinInstructions(String shape){\n                this.shape = shape;\n            }\n            public void produceShape(){\n                System.out.println(\"Here\'s your :\"+shape);\n            }\n            \n        }\n    }\n}','Threads',0,0,NULL,5);
INSERT INTO `flashcard` VALUES (3299,'will not compile non static instance variable cannot be referenced \nfrom static main','public class Hello extends Thread {\n    Operator op = new Operator();\n    Machine m = new Machine();\n    public static void main(String[] args){\n        op.start();\n        m.start();\n    }\n    \n    class Operator extends Thread {\n        Machine machine = new Machine();\n        Machine.MachineInstructions job;\n        \n        public void run(){\n            while(true){\n                String shape = getShapeFromUser();\n                job = calculateNewInstructionsFor(shape);\n                \n                machine.addJob(job);\n            }\n        }\n        \n        public Machine.MachineInstructions calculateNewInstructionsFor(String x){\n            // dah duh duu da du\n            return machine.new MachineInstructions(x);\n        }\n        \n        public String getShapeFromUser(){\n            System.out.println(\"What shape? square ok thanks\");\n            return \"Square\";\n        }\n        \n    }\n    \n    class Machine extends Thread {\n        List<MachineInstructions> joblist = new ArrayList<>();\n        \n        public void addJob(MachineInstructions job){\n            synchronized(joblist){\n                joblist.add(job);\n                joblist.notify();\n            }\n        }\n        \n        public void run(){\n            while(true) {\n                synchronized(joblist) {\n                    //wait until at least one job is available\n                    while(joblist.isEmpty()) {\n                        try{\n                            joblist.wait();\n                        } catch(InterruptedException ei){\n                            \n                        }\n                        \n                        //if we get here you know the list is\'nt empty\n                        MachineInstructions inst = joblist.remove(0);\n                        \n                        \n                    }\n                }\n            }\n        }\n        \n        \n        class MachineInstructions {\n            private String shape;\n            \n            public MachinInstructions(String shape){\n                this.shape = shape;\n            }\n            public void produceShape(){\n                System.out.println(\"Here\'s your :\"+shape);\n            }\n            \n        }\n    }\n}','Threads',0,0,NULL,5),(3300,'will not compile non static variable this cannot be reference from a static\ncontext. \n\nthe inner classes are instance classes so, even though you define \nthe variables as static they have to use this to access the inner class\n\nso it will still not compile','public class Hello extends Thread {\n    private static Operator op = new Operator();\n    private static Machine m = new Machine();\n    public static void main(String[] args){\n        op.start();\n        m.start();\n    }\n    \n    class Operator extends Thread {\n        Machine machine = new Machine();\n        Machine.MachineInstructions job;\n        \n        public void run(){\n            while(true){\n                String shape = getShapeFromUser();\n                job = calculateNewInstructionsFor(shape);\n                \n                machine.addJob(job);\n            }\n        }\n        \n        public Machine.MachineInstructions calculateNewInstructionsFor(String x){\n            // dah duh duu da du\n            return machine.new MachineInstructions(x);\n        }\n        \n        public String getShapeFromUser(){\n            System.out.println(\"What shape? square ok thanks\");\n            return \"Square\";\n        }\n        \n    }\n    \n    class Machine extends Thread {\n        List<MachineInstructions> joblist = new ArrayList<>();\n        \n        public void addJob(MachineInstructions job){\n            synchronized(joblist){\n                joblist.add(job);\n                joblist.notify();\n            }\n        }\n        \n        public void run(){\n            while(true) {\n                synchronized(joblist) {\n                    //wait until at least one job is available\n                    while(joblist.isEmpty()) {\n                        try{\n                            joblist.wait();\n                        } catch(InterruptedException ei){\n                            \n                        }\n                        \n                        //if we get here you know the list is\'nt empty\n                        MachineInstructions inst = joblist.remove(0);\n                        \n                        \n                    }\n                }\n            }\n        }\n        \n        \n        class MachineInstructions {\n            private String shape;\n            \n            public MachinInstructions(String shape){\n                this.shape = shape;\n            }\n            public void produceShape(){\n                System.out.println(\"Here\'s your :\"+shape);\n            }\n            \n        }\n    }\n}','Threads',0,0,NULL,5),(3301,'will produce: \n	What shape? square ok thanks\n	What shape? square ok thanks\n	What shape? square ok thanks\n	What shape? square ok thanks\n...ad infinum\n\nThe conintinuos loops are meant to keep checking for new shapes. \n\nnotice that one of the threads is alwasy synched in with the jobslist\n\nthey then use wait and notify to bounce back and forth.','public class Hello extends Thread {\n \n    public static void main(String[] args){\n        Hello h = new Hello();\n        h.new Operator().start();\n        h.new Machine().start();\n    }\n    \n    class Operator extends Thread {\n        Machine machine = new Machine();\n        Machine.MachineInstructions job;\n        \n        public void run(){\n            while(true){\n                String shape = getShapeFromUser();\n                job = calculateNewInstructionsFor(shape);\n                \n                machine.addJob(job);\n            }\n        }\n        \n        public Machine.MachineInstructions calculateNewInstructionsFor(String x){\n            // dah duh duu da du\n            return machine.new MachineInstructions(x);\n        }\n        \n        public String getShapeFromUser(){\n            System.out.println(\"What shape? square ok thanks\");\n            return \"Square\";\n        }\n        \n    }\n    \n    class Machine extends Thread {\n        List<MachineInstructions> joblist = new ArrayList<>();\n        \n        public void addJob(MachineInstructions job){\n            synchronized(joblist){\n                joblist.add(job);\n                joblist.notify();\n            }\n        }\n        \n        public void run(){\n            while(true) {\n                synchronized(joblist) {\n                    //wait until at least one job is available\n                    while(joblist.isEmpty()) {\n                        try{\n                            joblist.wait();\n                        } catch(InterruptedException ei){\n                            \n                        }\n                        \n                        //if we get here you know the list is\'nt empty\n                        MachineInstructions inst = joblist.remove(0);\n                        \n                        \n                    }\n                }\n            }\n        }\n        \n        \n        class MachineInstructions {\n            private String shape;\n            \n            public MachineInstructions(String shape){\n                this.shape = shape;\n            }\n            public void produceShape(){\n                System.out.println(\"Here\'s your :\"+shape);\n            }\n            \n        }\n    }\n}','Threads',0,0,NULL,5),(3302,'IllegalMonitorStateException\n\nwait in thread machine is called from outside a synchronized context\n\nyou have to synchronized on an object to wait on it. ','public class Hello extends Thread {\n \n    public static void main(String[] args){\n        Hello h = new Hello();\n        h.new Operator().start();\n        h.new Machine().start();\n    }\n    \n    class Operator extends Thread {\n        Machine machine = new Machine();\n        Machine.MachineInstructions job;\n        \n        public void run(){\n            while(true){\n                String shape = getShapeFromUser();\n                job = calculateNewInstructionsFor(shape);\n                \n                machine.addJob(job);\n            }\n        }\n        \n        public Machine.MachineInstructions calculateNewInstructionsFor(String x){\n            // dah duh duu da du\n            return machine.new MachineInstructions(x);\n        }\n        \n        public String getShapeFromUser(){\n            System.out.println(\"What shape? square ok thanks\");\n            return \"Square\";\n        }\n        \n    }\n    \n    class Machine extends Thread {\n        List<MachineInstructions> joblist = new ArrayList<>();\n        \n        public void addJob(MachineInstructions job){\n            synchronized(joblist){\n                joblist.add(job);\n                joblist.notify();\n            }\n        }\n        \n        public void run(){\n            while(true) {\n                    //wait until at least one job is available\n                    while(joblist.isEmpty()) {\n                        try{\n                            joblist.wait();\n                        } catch(InterruptedException ei){\n                            \n                        }\n                        \n                        //if we get here you know the list is\'nt empty\n                        MachineInstructions inst = joblist.remove(0);\n                        \n                        \n                    }\n            }\n        }\n        \n        \n        class MachineInstructions {\n            private String shape;\n            \n            public MachineInstructions(String shape){\n                this.shape = shape;\n            }\n            public void produceShape(){\n                System.out.println(\"Here\'s your :\"+shape);\n            }\n            \n        }\n    }\n}','Threads',0,0,NULL,5),(3303,'IllegalMonitorStateException, \n\nnotify() in addJob is called without being synched with joblist.\n\nyou have to be synched on an object to wait on it or notify it.\n\nRemember you wait and notify objects not threads. ','public class Hello extends Thread {\n \n    public static void main(String[] args){\n        Hello h = new Hello();\n        h.new Operator().start();\n        h.new Machine().start();\n    }\n    \n    class Operator extends Thread {\n        Machine machine = new Machine();\n        Machine.MachineInstructions job;\n        \n        public void run(){\n            while(true){\n                String shape = getShapeFromUser();\n                job = calculateNewInstructionsFor(shape);\n                \n                machine.addJob(job);\n            }\n        }\n        \n        public Machine.MachineInstructions calculateNewInstructionsFor(String x){\n            // dah duh duu da du\n            return machine.new MachineInstructions(x);\n        }\n        \n        public String getShapeFromUser(){\n            System.out.println(\"What shape? square ok thanks\");\n            return \"Square\";\n        }\n        \n    }\n    \n    class Machine extends Thread {\n        List<MachineInstructions> joblist = new ArrayList<>();\n        \n        public void addJob(MachineInstructions job){\n                joblist.add(job);\n                joblist.notify();\n        }\n        \n        public void run(){\n            while(true) {\n                synchronized(joblist) {\n                    //wait until at least one job is available\n                    while(joblist.isEmpty()) {\n                        try{\n                            joblist.wait();\n                        } catch(InterruptedException ei){\n                            \n                        }\n                        \n                        //if we get here you know the list is\'nt empty\n                        MachineInstructions inst = joblist.remove(0);\n                        \n                        \n                    }\n                }\n            }\n        }\n        \n        \n        class MachineInstructions {\n            private String shape;\n            \n            public MachineInstructions(String shape){\n                this.shape = shape;\n            }\n            public void produceShape(){\n                System.out.println(\"Here\'s your :\"+shape);\n            }\n            \n        }\n    }\n}','Threads',0,0,NULL,5),(3304,'Here butterfingers is unable to get his meaty claws on the same machine \nthe operator is using becasue those two are instance classes created \nin static main, joblist is an instance variable so the one they are \nusing belongs to the instance created in main. \n\nButterFinger created his own seperated machine to fuck with here, good\nso the output will be \n\nWhat shape? square ok thanks\nWhat shape? square ok thanks\nWhat shape? square ok thanks\nWhat shape? square ok thanks     for ever and ever. ','//ignore the answer try to figure out what wrong with this thin\npublic class Hello extends Thread {\n \n    public static void main(String[] args){\n        Hello h = new Hello();\n        h.new Operator().start();\n        h.new Machine().start();\n        new ButterFinger().start();\n    }\n    \n    class Operator extends Thread {\n        Machine machine = new Machine();\n        Machine.MachineInstructions job;\n        \n        public void run(){\n            while(true){\n                String shape = getShapeFromUser();\n                job = calculateNewInstructionsFor(shape);\n                \n                machine.addJob(job);\n            }\n        }\n        \n        public Machine.MachineInstructions calculateNewInstructionsFor(String x){\n            // dah duh duu da du\n            return machine.new MachineInstructions(x);\n        }\n        \n        public String getShapeFromUser(){\n            System.out.println(\"What shape? square ok thanks\");\n            return \"Square\";\n        }\n        \n    }\n    \n    class Machine extends Thread {\n        private List<MachineInstructions> joblist = new ArrayList<>();\n        \n        public void addJob(MachineInstructions job){\n            synchronized(joblist){\n                joblist.add(job);\n                joblist.notifyAll();\n            }\n        }\n        \n        public void run(){\n            while(true) {\n                synchronized(joblist) {\n                    //wait until at least one job is available\n                    while(joblist.isEmpty()) {\n                        try{\n                            joblist.wait();\n                        } catch(InterruptedException ei){\n                            \n                        }\n                        \n                        //if we get here you know the list is\'nt empty\n                        MachineInstructions inst = joblist.remove(0);\n                        \n                        \n                    }\n                }\n            }\n        }\n        \n        \n        class MachineInstructions {\n            private String shape;\n            \n            public MachineInstructions(String shape){\n                this.shape = shape;\n            }\n            public void produceShape(){\n                System.out.println(\"Here\'s your :\"+shape);\n            }\n            \n        }\n    }\n     \n}\n\nclass ButterFinger extends Thread {\n    private Hello h = new Hello();\n    private Hello.Machine machine = h.new Machine();\n    \n        public void run(){\n            while(true){\n                machine.addJob(machine.new MachineInstructions(\"Whoops I fucked up\"));\n            }\n            \n        }\n}','Threads',0,0,NULL,5),(3305,'Butterfinger now has the right machine however the main method never\nstarts him so the output is still \n\nwhat shape? square ok thanks\nWhat shape? square ok thanks\nWhat shape? square ok thanks\nWhat shape? square ok thanks    forever...\n\nno,\n\n	Operator and Machine have no way to connect. Operator has its own\n	version of machine and therefore does not connect with the machine\n	thread that was started in main. ','public class Hello extends Thread {\n    Operator op = new Operator();\n    Machine m = new Machine();\n \n    public static void main(String[] args){\n       Hello h = new Hello();\n       h.op.start();\n       h.m.start();\n    }\n    \n    class Operator extends Thread {\n        Machine machine = new Machine();\n        Machine.MachineInstructions job;\n        \n        public void run(){\n            while(true){\n                String shape = getShapeFromUser();\n                job = calculateNewInstructionsFor(shape);\n                \n                machine.addJob(job);\n            }\n        }\n        \n        public Machine.MachineInstructions calculateNewInstructionsFor(String x){\n            // dah duh duu da du\n            return machine.new MachineInstructions(x);\n        }\n        \n        public String getShapeFromUser(){\n            System.out.println(\"What shape? square ok thanks\");\n            return \"Square\";\n        }\n        \n    }\n    \n    class Machine extends Thread {\n        private List<MachineInstructions> joblist = new ArrayList<>();\n        \n        public void addJob(MachineInstructions job){\n            synchronized(joblist){\n                joblist.add(job);\n                joblist.notifyAll();\n            }\n        }\n        \n        public void run(){\n            while(true) {\n                synchronized(joblist) {\n                    //wait until at least one job is available\n                    while(joblist.isEmpty()) {\n                        try{\n                            joblist.wait();\n                        } catch(InterruptedException ei){\n                            \n                        }\n                        \n                        //if we get here you know the list is\'nt empty\n                        MachineInstructions inst = joblist.remove(0);\n                        \n                        \n                    }\n                }\n            }\n        }\n        \n        \n        class MachineInstructions {\n            private String shape;\n            \n            public MachineInstructions(String shape){\n                this.shape = shape;\n            }\n            public void produceShape(){\n                System.out.println(\"Here\'s your :\"+shape);\n            }\n            \n        }\n    }\n     \n}\n\nclass ButterFinger extends Thread {\n    private Hello h = new Hello();\n    \n        public void run(){\n            while(true){\n                h.m.addJob(h.m.new MachineInstructions(\"Whoops I fucked up\"));\n            }\n            \n        }\n}','Threads',0,0,NULL,5),(3306,'IllegalMonitorStateException\n\nyou cannot call start() on a thread more than once. ','public class Hello {\n    public static void main(String[] args){\n        CodeMaker cm = new CodeMaker();\n        \n        for(int i = 0; i<10; i++){\n            cm.start();\n        }\n        \n    }\n}\n\nclass CodeMaker  extends Thread {\n    private String code;\n    private int counter;\n    private ArrayList<String> al;\n    private char[] letters = {\'A\',\'B\',\'C\',\'D\',\'E\',\'F\',\'G\',\'H\',\'I\'};\n    \n    public CodeMaker(){\n        counter = 0;\n        al = new ArrayList<>();\n    }\n\n    class SectionGenerator implements Runnable{\n        private String sec = \"\";\n        private Random ran = new Random();\n\n        public void run() {\n            //tried to use notify outside of synchronized context\n            synchronized(this){\n                int x = ran.nextInt(3);\n                int y = ran.nextInt(3);\n                int z = ran.nextInt(3);\n            \n            \n                sec += letters[x];\n                sec += letters[y];\n                sec += letters[z];\n                notifyAll();\n            }\n        }\n        \n        public synchronized String section(){\n            return sec;\n        }\n\n    }\n    \n    class NumberGenerator implements Runnable{\n        private String number = \"\";\n        private Random ran = new Random();\n        \n        public void run(){\n            //tried to use notify outside of synchronized context\n            synchronized(this){\n                int x1 = ran.nextInt(100);\n                int x2 = ran.nextInt(100);\n                int x3 = ran.nextInt(100);\n            \n                number += x1+\".\"+x2+\".\"+x3;\n                notifyAll();\n            }\n        }\n        \n        public synchronized String Number(){\n            return number;\n        }\n    }\n    \n    \n   public synchronized void run(){\n       \n       SectionGenerator sg1 = new SectionGenerator();\n       NumberGenerator ng1 = new NumberGenerator();\n       Thread t1 = new Thread(sg1);\n       Thread t2 = new Thread(ng1);\n       \n       t1.start();\n       t2.start();\n       \n       try{\n        t1.wait();\n        code += sg1.section();\n        t2.wait();\n        code += ng1.Number();\n       } catch(InterruptedException e){\n           \n       }\n       System.out.println(code);\n   }    ','Threads',0,0,NULL,5),(3307,'','You can call start() on a Thread object only once, otherwise you get an\nIllegalThreadStateException\n\nyou can however create many threads from the same runnable','Threads',0,0,NULL,5),(3308,'New State\n\nA thread that is created but not yet started is in the new state and not yet alive','public class Hello implements Runnable {\n\n    public static void main(String[] args) {\n        Thread t = new Thread(new Hello());\n    }\n    \n    public void run() {\n        System.out.println(\"run once\");\n    }\n}\n\n\nwhat state is this thread in ?\n\n','Threads',0,0,NULL,5),(3309,' got it ? ','Once a thread is started it goes into the runnable state,\n\nThe schedular can move a thread back and forth between the runnable state and \nthe running state. \n\nA running thread may enter a blocked / waiting state by a wait, sleep, or join \ncall\n\na running thread can enter the blocked/ waiting state because it cant acquire the lock \nfor a synchroized block\n\na dead thread cannot be started again.','Threads',0,0,NULL,5),(3310,'','sleeping is used to delay execution for a period of time and .. \n\nno locks are released when a thread goes to sleep','Threads',0,0,NULL,5),(3311,'','A sleeping thread is thread is guarenteed to sleep for at least the time specified\nin the argument to sleep() but there is not guarentee is actually return to running\n\nthe sleep mehtod is static so it only affects the currently running thread. ','Threads',0,0,NULL,5),(3312,'','unless explicitly set a thread\'s priority will have the same priority as the thread\nthat created it. ','Threads',0,0,NULL,5),(3313,'','when one thread call join() on another thread, the currently running thhread\nwill wait until the thread it joins with has completed. Think of join() as saying\n\n\"Hey thread I want to join on to the end of you. let me know when you\'re done, so \nI can enter the runnable state\"','Threads',0,0,NULL,5),(3314,'','While only one thread can be accessing synchronized code of a particular\ninstance, multiple threads can still access the same object\'s unsynchronized code.\n\nWhen a thread goes to sleep its locks will be unavailable to other threads.','Threads',0,0,NULL,5),(3315,'','Object.wait() = add me to your waiting list.','Threads',0,0,NULL,5),(3316,'','notify() is used to send a signal to onne and onnly one of the threads that \nare waiting, it cannot specify which thread will be notified.','Threads',0,0,NULL,5),(3317,'','wait() notify() and notifyAll() must called from within a synchronized context\nthe synchronization must be with the object that the thread is calling one of these\nmethhods on !','Threads',0,0,NULL,5),(3318,'the third one','Runnable target = new MyRunnable();\nThread myThread = new Thread(target);\n\n\npublic class MyRunnable extends Runnable{public void run(){}}\npublic class MyRunnable implements Runnable{public void start{}}\npublic class MyRunnable implements Runnable{public void run(){}}\n','Threads',0,0,NULL,5),(3319,'0..1..2..','public class Hello extends Thread {\n    public static void main(String[] args){\n       Hello h = new Hello();\n       Thread x = new Thread(h);\n       h.start();\n        \n    }\n    \n    public void run() {\n        for(int i=0; i<3; ++i)\n            System.out.print(i+\"...\");\n    }\n}','Threads',0,0,NULL,5),(3320,'will not compile .sleep() must be enclosed in a try block to catch its\nInterruptedException','public class Hello {\n    public static void main(String[] args){\n       printAll(args);\n        \n    }\n    \n    public static void printAll(String[] lines){\n        for(int i = 0; i<lines.length; i++){\n            System.out.println(lines[i]);\n            Thread.currentThread().sleep(1000);\n        }\n    }\n}\n\nwhat is the result','Threads',0,0,NULL,5),(3321,'public synchronized int read() { return a+b; }\npublic synchronized void set(int a, int b){this.a = a; this.b = b;}\n\npublic int read(){ synchronized(this){ return a+b; } }\npublic void set(int a, int b){synchronized(this){ this.a = a; this.b = b;} }\n\n\n','you have two private variables a and b. prevent concurrent access problems using\ntheir read() and set(int a, int b){} methods.','Threads',0,0,NULL,5),(3322,'1 2 \n\nIllegalMonitorStateException is unchecked and thrown by trying to wait\nsomething yyou do not own the lock to!','public class WaitTest {\n	public static void main(String[] args){\n		sout(\"1\");\n		synchronized(args){\n			sout(\"2\");\n			try{\n				args.wait();\n			} catch(InterruptedException e) {\n			}\n		}\n		sout(\"3\");\n	}\n}\n\n1. IllegalMonitorStateException\n2. will not compile\n3. 1 2 3\n4. 1 2\n5. fails to compile because of wait() illegalMonitorstatexception','Threads',0,0,NULL,5),(3323,'After object B is notified, or after two seconds. ','the following method is called from thread A on an object B and it is properly synchronized\n\nwait(2000);\n\nafter calling the method when will thread A becoma a canidate to get another \nturn at the CPU ?\n','Threads',0,0,NULL,5),(3324,'1 4','which are true ?\n\n1 the notifyAll() must be called from a synchronized context\n2 to call wati() an object must own the lock on the thread\n3 the notify() method is defined in class java.lang.thread\n4 when a thread is waiting as a result of wait() it releases its lock\n5 notify() method causes a thread to imeediately release its lock\n6 the difference between notify() and notifyAll() is that notifyAll() notifies\nall waiting threads regardless of the object theyre waiting on','Threads',0,0,NULL,5),(3325,'synchronize both log() and getContents()\n\neven though stringbuffer is synchronized internally, append is called \nmultiple times so anythread could get in there in between calls','public class Logger {\n	private StringBuilder contents = new StringBuilder();\n	public void log(String mess){\n		contents.append(System.currentTimeMillis());\n		contents.append(\": \");\n		contents.append(Thread.currentThread().getName());\n		contents.append(mess);\n	}\n\n	public String getContents() { return contents.toString(); }\n}\n\nhow can you enxure that instances of this class can be safely used by multiple \nthreads ?\n\nreplace StringBuilder with thread-safe StringBuffer ?','Threads',0,0,NULL,5),(3326,'IllegalMonitorStateException is thrown because the main thread does not \nhave a lock on t before it decides to wait on it. ','public static synchronized void main(Stirng[] args) throws InterruptedException {\n	Thread t = new Thread();\n	t.start();\n	sout(\"X\");\n	t.wait(10000);\n	sout(\"y\");\n}','Threads',0,0,NULL,5),(3327,'MyThread foo','class MyThread extends Thread {\n	MyThread() {\n		sout(\"MyThread\");\n	}\n	public void run(){\n		sout(\"bar\");\n	}\n\n	public void run(String s){\n		sout(\"baz\");\n	}\n}\n\npublic class Test {\n	psvm(sa){\n		Thread t = new MyThread(){\n			public void run(){\n				sout(\"foo\");\n			}\n		};\n		t.start();\n	}\n}\n		','Threads',0,0,NULL,5),(3328,'will not compile unreported IOException from newWatchService() and \npath.register()','public class Hello {\n    public static void main(String[] args){\n       WatchService watchService\n          = FileSystems.getDefault().newWatchService();\n \n        Path path = Paths.get(System.getProperty(\"user.home\"));\n \n        path.register(\n          watchService, \n            StandardWatchEventKinds.ENTRY_CREATE, \n              StandardWatchEventKinds.ENTRY_DELETE, \n                StandardWatchEventKinds.ENTRY_MODIFY);\n \n        WatchKey key;\n        while ((key = watchService.take()) != null) {\n            for (WatchEvent<?> event : key.pollEvents()) {\n                System.out.println(\n                  \"Event kind:\" + event.kind() \n                    + \". File affected: \" + event.context() + \".\");\n            }\n            key.reset();\n        }\n        \n    }\n    \n    \n}','IO',0,0,NULL,5),(3329,'will not compile take() throws an InterruptedException because \nit will wait if there are no events present','public class Hello {\n    public static void main(String[] args) throws IOException{\n       WatchService watchService\n          = FileSystems.getDefault().newWatchService();\n \n        Path path = Paths.get(System.getProperty(\"user.home\"));\n \n        path.register(\n          watchService, \n            StandardWatchEventKinds.ENTRY_CREATE, \n              StandardWatchEventKinds.ENTRY_DELETE, \n                StandardWatchEventKinds.ENTRY_MODIFY);\n \n        WatchKey key;\n        while ((key = watchService.take()) != null) {\n            for (WatchEvent<?> event : key.pollEvents()) {\n                System.out.println(\n                  \"Event kind:\" + event.kind() \n                    + \". File affected: \" + event.context() + \".\");\n            }\n            key.reset();\n        }\n        \n    }\n    \n    \n}','IO',0,0,NULL,5),(3330,'compiles fine if you were to delete a file from home directory \nyou would get a notice like this: \n	\n	Event kind:ENTRY_CREATE. File affected: Untitled Document.\n\n','public class Hello {\n    public static void main(String[] args) throws IOException, InterruptedException {\n       WatchService watchService\n          = FileSystems.getDefault().newWatchService();\n \n        Path path = Paths.get(System.getProperty(\"user.home\"));\n \n        path.register(\n          watchService, \n            StandardWatchEventKinds.ENTRY_CREATE, \n              StandardWatchEventKinds.ENTRY_DELETE, \n                StandardWatchEventKinds.ENTRY_MODIFY);\n \n        WatchKey key;\n        while ((key = watchService.take()) != null) {\n            for (WatchEvent<?> event : key.pollEvents()) {\n                System.out.println(\n                  \"Event kind:\" + event.kind() \n                    + \". File affected: \" + event.context() + \".\");\n            }\n            key.reset();\n        }\n        \n    }\n    \n    \n}','IO',0,0,NULL,5),(3331,'this would run one time, if there were no WatchEvents immediately available\nit would end.\nPoll() gets events and does not wait. \n\n','public class Hello {\n    public static void main(String[] args) throws IOException {\n       WatchService watchService\n          = FileSystems.getDefault().newWatchService();\n \n        Path path = Paths.get(System.getProperty(\"user.home\"));\n \n        path.register(\n          watchService, \n            StandardWatchEventKinds.ENTRY_CREATE, \n              StandardWatchEventKinds.ENTRY_DELETE, \n                StandardWatchEventKinds.ENTRY_MODIFY);\n \n        WatchKey key;\n        while ((key = watchService.poll()) != null) {\n            for (WatchEvent<?> event : key.pollEvents()) {\n                System.out.println(\n                  \"Event kind:\" + event.kind() \n                    + \". File affected: \" + event.context() + \".\");\n            }\n            key.reset();\n        }\n        \n    }\n    \n    \n}','IO',0,0,NULL,5),(3332,'...just a good example','Path path = Paths.get(\"/home\");\nWatchService watchService = FileSystems.getDefault().newWatchService();\nWatchKey watchKey = path.register(watchService,ENTRY_CREATE,ENTRY_DELETE,ENTRY_MODIFY);\n\nprivate boolean notDone = true;\nwhile(notDone){\n    try{\n         WatchKey watchKey = watchService.poll(60,TimeUnit.SECONDS);\n         List<WatchEvent.Kind<?>> events = watchKey.pollEvents();\n         for(WatchEvent event : events){\n            ...process the events\n         }\n         if(!watchKey.reset()){\n            ...handle situation no longer valid\n         }\n     }catch(InterruptedException e){\n            Thread.currentThread().interrupt();\n     }','IO',0,0,NULL,5),(3333,'will not compile, Subleaser does not implemnet runnable!\n\nAlso the two threads synchronize on their very own messageboards so \nthey have no problem getting access to them and printing their messages.\n\nSecondly Nothing is ever printed from the MessageBoard.','public class Hello {\n    public static void main(String[] dicks){\n        Thread t1 = new Thread(new Advertiser());\n        Thread t2 = new Thread(new Subleaser());\n    }\n\n}    \n\nclass MessageBoard {\n    private StringBuilder contents = new StringBuilder();\n    \n    public synchronized void postMessage(String s){\n        contents.append(s + \" \");\n    }\n    \n    public synchronized String readBoard(){\n        return contents.toString();\n    }\n    \n    public StringBuilder takeTurnAtBoard(){\n        return contents;\n    }\n}\n\nclass Advertiser implements Runnable{\n    protected MessageBoard mb = new MessageBoard();\n    public void run(){\n        synchronized(mb){\n            mb.postMessage(\"Attention!\");\n            mb.postMessage(\"Platonics\");\n            mb.postMessage(\"Lost Dog! 1000$ reward\");\n            mb.postMessage(\"Sex Change coupon\");\n            \n            System.out.println(mb.readBoard());\n        } \n    }\n}\n\nclass Subleaser{\n    private MessageBoard mb = new MessageBoard();\n    \n    public void run(){\n        synchronized(mb){\n            mb.postMessage(\"1000 a month!\");\n            mb.postMessage(\"two br\");\n            mb.postMessage(\"no dogs allowed!\");\n        }\n    }\n}','Threads',0,0,NULL,5),(3334,'subleaser  1000 a month! two br no dogs allowed! \nadvertiser  Attention! Platonics Lost Dog! 1000$ reward Sex Change coupon \n\nadvertiser  Attention! Platonics Lost Dog! 1000$ reward Sex Change coupon \nsubleaser  1000 a month! two br no dogs allowed!\n\nthese results can be unpredictable, though the methods are synched\nnothing is stopping another thread from coming in between append calls.\n\nto make the ressults truly predictable synchronized the postmessage calls in a block\non mb','public class Hello {\n    public static void main(String[] dicks){\n        Thread t1 = new Thread(new Advertiser(),\"advertiser\");\n        Thread t2 = new Thread(new Subleaser(),\"subleaser\");\n        \n        t1.start();\n        t2.start();\n    }\n\n}    \n\nclass MessageBoard {\n    private StringBuilder contents = new StringBuilder();\n    \n    public synchronized void postMessage(String s){\n        contents.append(s);\n        contents.append(\" \");\n    }\n    \n    public synchronized String readBoard(){\n        return contents.toString();\n    }\n    \n    public StringBuilder takeTurnAtBoard(){\n        return contents;\n    }\n}\n\nclass Advertiser implements Runnable{\n    protected MessageBoard mb = new MessageBoard();\n    public void run(){\n            //Thread.getName() static method cannot be called from non static\n            mb.postMessage(Thread.currentThread().getName()+\" \");\n            mb.postMessage(\"Attention!\");\n            mb.postMessage(\"Platonics\");\n            mb.postMessage(\"Lost Dog! 1000$ reward\");\n            mb.postMessage(\"Sex Change coupon\");\n            \n            System.out.println(mb.readBoard());\n        \n    }\n}\n\nclass Subleaser implements Runnable{\n    private MessageBoard mb = new MessageBoard();\n    \n    public void run(){\n            mb.postMessage(Thread.currentThread().getName()+\" \");\n            mb.postMessage(\"1000 a month!\");\n            mb.postMessage(\"two br\");\n            mb.postMessage(\"no dogs allowed!\");\n            \n            System.out.println(mb.readBoard());\n        }\n}','IO',0,0,NULL,5),(3335,'these can be quiet unpredictable:\n\n	subleaser  two br no dogs allowed! 1200$ a month advertiser  Attention! Lost Dog! 1000$ reward Sex Change coupon \nsubleaser  two br no dogs allowed! 1200$ a month advertiser  Attention! Lost Dog! 1000$ reward Sex Change coupon \n\nBoth threads are operating on the same instance, that instances objects\nmethods are synchronized but that doesn\'t stop the other thread from coming\ninbetween calls to postMessage()','public class Hello {\n    public static void main(String[] dicks){\n        MessageBoard mb = new MessageBoard();\n        Thread t1 = new Thread(new Advertiser(mb),\"advertiser\");\n        Thread t2 = new Thread(new Subleaser(mb),\"subleaser\");\n        \n        t1.start();\n        t2.start();\n    }\n\n}    \n\nclass MessageBoard {\n    private StringBuilder contents = new StringBuilder();\n    \n    public synchronized void postMessage(String s){\n        contents.append(s);\n        contents.append(\" \");\n    }\n    \n    public synchronized String readBoard(){\n        return contents.toString();\n    }\n    \n    public StringBuilder takeTurnAtBoard(){\n        return contents;\n    }\n}\n\nclass Advertiser implements Runnable{\n    protected MessageBoard mb;\n    \n    public Advertiser(MessageBoard mb){\n        this.mb = mb;\n    }\n    public void run(){\n            //Thread.getName() static method cannot be called from non static\n            mb.postMessage(Thread.currentThread().getName()+\" \");\n            mb.postMessage(\"Attention!\");\n            mb.postMessage(\"Lost Dog! 1000$ reward\");\n            mb.postMessage(\"Sex Change coupon\");\n            \n            System.out.println(mb.readBoard());\n        \n    }\n}\n\nclass Subleaser implements Runnable{\n    private MessageBoard mb;\n    \n    public Subleaser(MessageBoard mb){\n        this.mb = mb;\n    }\n    \n    public void run(){\n            mb.postMessage(Thread.currentThread().getName()+\" \");\n            mb.postMessage(\"two br\");\n            mb.postMessage(\"no dogs allowed!\");\n            mb.postMessage(\"1200$ a month\");\n            \n            System.out.println(mb.readBoard());\n        }\n}\n','IO',0,0,NULL,5),(3336,'You can be assured that these results will be predictable,\n\nThe synchronized blocks get a hold of the lock so it is just a compettion\nof which thread will lock first. ','public class Hello {\n    public static void main(String[] dicks){\n        MessageBoard mb = new MessageBoard();\n        Thread t1 = new Thread(new Advertiser(mb),\"advertiser\");\n        Thread t2 = new Thread(new Subleaser(mb),\"subleaser\");\n        \n        t1.start();\n        t2.start();\n    }\n\n}    \n\nclass MessageBoard {\n    private StringBuilder contents = new StringBuilder();\n    \n    public synchronized void postMessage(String s){\n        contents.append(s);\n        contents.append(\" \");\n    }\n    \n    public synchronized String readBoard(){\n        return contents.toString();\n    }\n    \n    public StringBuilder takeTurnAtBoard(){\n        return contents;\n    }\n}\n\nclass Advertiser implements Runnable{\n    protected MessageBoard mb;\n    \n    public Advertiser(MessageBoard mb){\n        this.mb = mb;\n    }\n    public void run(){\n        synchronized(mb){\n            //Thread.getName() static method cannot be called from non static\n            mb.postMessage(Thread.currentThread().getName()+\" \");\n            mb.postMessage(\"Attention!\");\n            mb.postMessage(\"Lost Dog! 1000$ reward\");\n            mb.postMessage(\"Sex Change coupon\");\n            \n            System.out.println(mb.readBoard());\n        }\n    }\n}\n\nclass Subleaser implements Runnable{\n    private MessageBoard mb;\n    \n    public Subleaser(MessageBoard mb){\n        this.mb = mb;\n    }\n    \n    public void run(){\n        synchronized(mb){\n            mb.postMessage(Thread.currentThread().getName()+\" \");\n            mb.postMessage(\"two br\");\n            mb.postMessage(\"no dogs allowed!\");\n            mb.postMessage(\"1200$ a month\");\n            \n            System.out.println(mb.readBoard());\n        }\n        }\n        \n}\n','IO',0,0,NULL,5),(3337,'foo.txt ENTRY_DELETE\n\n... Watcher only watches one directory at a time, not subdirectories','public class Hello {\n    public static void main(String[] dicks) throws InterruptedException {\n        try{\n            WatchService watcher = FileSystems.getDefault().newWatchService();\n            Path home = Paths.get(\"/home/maxbisesi\");\n            home.register(watcher, StandardWatchEventKinds.ENTRY_CREATE,StandardWatchEventKinds.ENTRY_DELETE);\n            \n            WatchKey key;\n            \n            //throws interruptedException \n            while((key = watcher.take()) != null) {\n                for(WatchEvent<?> event : key.pollEvents()){\n                    System.out.println(event.context() + \" \" + event.kind());\n              }\n           }\n        } catch(IOException ei){\n            \n        }    \n    }\n\n}    \n\nI delete foo.txt out of the home directory then go into Documents and delete\nindex.html. What is the result ?','IO',0,0,NULL,5),(3338,'1. 4 4 \n2. does not compile\n3. prints nothign , but starts a new thread\n4. creates a new thread and invokes run() directlyy\n5. creates and starts a new thread. ','public class Starter implements Runnable {\n	void go(long id) {\n		sout(id);\n	}\n\n	public static void main(String[] args){\n		sout(Thread.currentThread().getId() + \" \");\n		//insert code\n	}\n	public void run() { go(Thread.currentThread().getId()); }\n}\n\n1. new Starter().run();\n2. new Starter().start();\n3. new Thread(new Starter());\n4. new Thread(new Starter()).run();\n5. new Thread(new Starter()).start();','IO',0,0,NULL,5),(3339,'will not commpile, join throws interruptedexception ','public class Hello implements Runnable {\n    public void run(){\n        System.out.println(\"r1 \");\n        System.out.println(\"r2 \");\n    }\n    public static void main(String[] args){\n        Thread t = new Thread(new Hello());\n        t.start();\n        System.out.println(\"m1 \");\n        t.join();\n        System.out.println(\"m2 \");\n    }\n}','IO',0,0,NULL,5),(3340,'could be:\n\nm1 r1 r2 m2\nr1 m1 r2 m2\nr1 r2 m1 m2\n\njoin throws interruptedexception, it causes main to join onto the end\nof the thread t and wait till its done to continue. ','public class Hello implements Runnable {\n    public void run(){\n        System.out.println(\"r1 \");\n        System.out.println(\"r2 \");\n    }\n    public static void main(String[] args){\n        Thread t = new Thread(new Hello());\n        t.start();\n        System.out.println(\"m1 \");\n        try{\n            t.join();\n        } catch(InterruptedException e){\n            \n        }\n        System.out.println(\"m2 \");\n    }\n}','IO',0,0,NULL,5),(3341,'NullpointerException,\n\nthis one is hard to spot but c is initialized in the go method, an \ninstance method. The two threads start their own new instance and go\ndirectly to the run() method, without go() c never gets initialized. \n\nfor this to work c would have to be static. \n','public class Hello implements Runnable {\n    Chicks c;\n    public void run(){\n       c.yack(Thread.currentThread().getId());\n    }\n    public static void main(String[] args){\n        new Hello().go();\n       \n    }\n    \n    void go(){\n        c = new Chicks();\n        new Thread(new Hello()).start();\n        new Thread(new Hello()).start();\n    }\n}\n\nclass Chicks {\n    synchronized void yack(long id){\n        for(int x = 1; x <3; x++){\n            System.out.println(id + \" \");\n            Thread.yield();\n        }\n    }\n}','IO',0,0,NULL,5),(3342,'8\n8\n9\n9','public class Hello implements Runnable {\n    static Chicks c;\n    public void run(){\n       c.yack(Thread.currentThread().getId());\n    }\n    public static void main(String[] args){\n        new Hello().go();\n       \n    }\n    \n    void go(){\n        c = new Chicks();\n        new Thread(new Hello()).start();\n        new Thread(new Hello()).start();\n    }\n}\n\nclass Chicks {\n    synchronized void yack(long id){\n        for(int x = 1; x <3; x++){\n            System.out.println(id + \" \");\n            Thread.yield();\n        }\n    }\n}','IO',0,0,NULL,5),(3343,'','public class Hello implements Runnable {\n    static Chicks c;\n    public void run(){\n       c.yack(Thread.currentThread().getId());\n    }\n    public static void main(String[] args){\n        new Hello().go();\n       \n    }\n    \n    void go(){\n        c = new Chicks();\n        new Thread(new Hello()).start();\n        new Thread(new Hello()).start();\n    }\n}\n\nclass Chicks {\n    static long flag = 0;\n    synchronized void yack(long id){\n        if(flag == 0) flag = id;\n        for(int x = 1; x <3; x++){\n            if(flag == id) System.out.println(\"yada yada \");\n            else System.out.println(\"ehh \");\n        }\n    }\n}','IO',0,0,NULL,5),(3344,'the output could be 8 9 8 9\n\n..it could be anything really','public class Hello implements Runnable {\n    public void run(){\n       move(Thread.currentThread().getId());\n    }\n    \n    void move(long id){\n        System.out.println(id + \" \");\n        System.out.println(id + \" \");\n    }\n    public static void main(String[] args){\n        Hello h = new Hello();\n        new Thread(h).start();\n        new Thread(new Hello()).start();\n    }\n}','IO',0,0,NULL,5),(3345,'the output could be 4 2 4 2\n\nWhile the method is synhcronized it is being invoked by two different\nobjects so they could print in any order still \n\n','public class Hello implements Runnable {\n    public void run(){\n       move(Thread.currentThread().getId());\n    }\n    \n    synchronized void move(long id){\n        System.out.println(id + \" \");\n        System.out.println(id + \" \");\n    }\n    public static void main(String[] args){\n        Hello h = new Hello();\n        new Thread(h).start();\n        new Thread(new Hello()).start();\n    }\n}','IO',0,0,NULL,5),(3346,'test','test	','IO',0,0,NULL,5),(3347,'add  and  remove','Which method from a CopyOnWriteArrayList will caue a new copy of the internal\narray to be created ?','IO',0,0,NULL,5),(3348,'2018699554\n1311053135\nlocked thread Thread1\nunable to lock thread Thread2 will re try again\nunlocked locked thread Thread1\nlocked thread Thread2\nunlocked locked thread Thread2\n\nThe two threads use two different Runnables, but they are both vying for the same\nlock. ','public class Hello {\n    public static void main(String[] args){\n        new ReentrantLockingDemo().go();\n    }\n}\n\nclass ReentrantLockingDemo {\n\n    final Lock lock = new ReentrantLock();\n\n    public void go() {\n\n        Runnable run1 = newRunable();\n        Thread t1 = new Thread(run1, \"Thread1\");\n        System.out.println(run1.hashCode());\n        t1.start();\n\n        Runnable run2 = newRunable();\n        Thread t2 = new Thread(run2, \"Thread2\");\n        System.out.println(run2.hashCode());\n        t2.start();\n\n    }\n\n    private Runnable newRunable() {\n        return new Runnable() {\n            public int hashCode() {\n                return super.hashCode();\n            }\n            public void run() {\n                do {\n                    try {\n                        if (lock.tryLock(500, TimeUnit.MILLISECONDS)) {\n                            try {\n                                System.out.println(\"locked thread \"\n                                        + Thread.currentThread().getName());\n                                Thread.sleep(1000);\n                            } finally {\n                                lock.unlock();\n                                System.out.println(\"unlocked locked thread \"\n                                        + Thread.currentThread().getName());\n                            }\n                            break;\n                        } else {\n                            System.out.println(\"unable to lock thread \"\n                                    + Thread.currentThread().getName()\n                                    + \" will re try again\");\n                        }\n                    } catch (InterruptedException e) {\n                        e.printStackTrace();\n                    }\n                } while (true);\n            }     \n        };\n    }\n\n}','IO',0,0,NULL,5),(3349,'How a join should be used and implemented. \n\n100 Rens followed by 100 stimpys','public class ThreadTest {\n	class InnerRun implements Runnable {\n		public void run() {\n			for(int x = 0; x < 100; x++){\n				try{\n					Thread.sleep(5);\n				} catch(Exception e) {}\n				sout( \"Ren\" );\n			}\n		}\n	}\n\n	class InnerRunTwo implements Runnable {\n		Thread other;\n		public InnerRunTwo(Thread x){ other = x; }\n		public void run() {\n			try{\n				other.join();\n			} catch(Exception e) { }\n			for(int x = 0; x < 100; x++){\n			   try{\n				Thread.sleep(5);\n			   } catch( Exception e) { }\n			   sout( \"stimpy\" );\n			}\n		}	\n	}\nvoid start(){\n	InnerRun ir = new InnerRun();\n	Thread t = new Thread(ir);\n	InnerRunTwo irr = new InnerRunTwo(t);\n	Thread u = new Thread(irr);\n		t.start();	\n		u.start();\n}\npsvm(SA){ ThreadTest tt = new ThreadTest(); tt.start(); }\n}','IO',0,0,NULL,5),(3350,'run:\nInstance locked by: Thread-0\n0\nInstance locked by: Thread-0\n1\nInstance locked by: Thread-0\n2\nInstance locked by: Thread-0\n3\nInstance locked by: Thread-0\n4\nInstance locked by: Thread-0\n5\nInstance locked by: Thread-0\n6\nInstance locked by: Thread-0\n7\nInstance locked by: Thread-0\n8\nInstance locked by: Thread-0\n9\nInstance locked by: Thread-0\n10\nBUILD STOPPED (total time: 10 seconds)\n','public class Hello {\n    public static void main(String[] args){\n        Data data = new Data();\n        DataThread dt = new DataThread(data);\n        Thread t1 = new Thread(dt);\n        Thread t2 = new Thread(dt);\n        Thread t3 = new Thread(dt);\n        Thread t4 = new Thread(dt);\n        Thread t5 = new Thread(dt);\n        \n        t1.start();\n        t2.start();\n        t3.start();\n        t4.start();\n        t5.start();\n        \n    }\n}\n\nclass Data {\n    public Object lock = new Object();\n    public static Object staticLock = new Object();\n    \n    public synchronized void instanceLocked(){\n        System.out.println(\"Instance locked by: \"+Thread.currentThread().getName());\n    }\n    \n    public static synchronized void classLocked(){\n        System.out.println(\"class locked by: \"+Thread.currentThread().getName());\n        while(true){\n            \n        }\n    }\n}\n\nclass DataThread implements Runnable {\n    private Data data;\n    \n    public DataThread(Data data){\n        this.data = data;\n    }\n    public void run(){\n        synchronized(data.lock){\n            \n            for(int i = 0; i<100; i++){\n                data.instanceLocked();\n                System.out.println(i);\n                \n                try{\n                    Thread.sleep(1000);\n                } catch(InterruptedException e){\n                    \n                }\n            }\n            \n        }\n    }\n    \n}','IO',0,0,NULL,5),(3351,'Gaston: Alphonse has bowed to me!\nAlphonse: Gaston started to bow to me, but saw that I was already bowing to him.\nAlphonse: Gaston has bowed back to me!\nAlphonse: Gaston has bowed to me!\nGaston: Alphonse has bowed back to me!\nAlphonse: Gaston has bowed to me!\nGaston: Alphonse has bowed back to me!\nGaston: Alphonse has bowed to me!\nAlphonse: Gaston has bowed back to me!\nAlphonse: Gaston has bowed to me!\nGaston: Alphonse has bowed back to me!\nGaston: Alphonse has bowed to me!\nAlphonse: Gaston has bowed back to me!\nAlphonse: Gaston has bowed to me!\nGaston: Alphonse has bowed back to me!\nGaston: Alphonse has bowed to me!\nAlphonse: Gaston has bowed back to me!\nAlphonse: Gaston has bowed to me!\nGaston: Alphonse has bowed back to me!\nGaston: Alphonse has bowed to me!\nAlphonse: Gaston has bowed back to me!\nGaston: Alphonse has bowed to me!\nAlphonse: Gaston has bowed back to me!\nAlphonse: Gaston has bowed to me!\nGaston: Alphonse has bowed back to me!\nAlphonse: Gaston has bowed to me!\nGaston: Alphonse has bowed back to me!\nGaston: Alphonse has bowed to me!\nAlphonse: Gaston has bowed back to me!\nAlphonse: Gaston has bowed to me!\nGaston: Alphonse has bowed back to me!\nGaston: Alphonse started to bow to me, but saw that I was already bowing to him.\nAlphonse: Gaston has bowed to me!\nGaston: Alphonse has bowed back to me!\nAlphonse: Gaston has bowed to me!\nGaston: Alphonse has bowed back to me!','public class Hello {\n    public static void main(String[] args){\n         final Safelock.Friend alphonse =\n            new Safelock.Friend(\"Alphonse\");\n        final Safelock.Friend gaston =\n            new Safelock.Friend(\"Gaston\");\n        new Thread(new Safelock.BowLoop(alphonse, gaston)).start();\n        new Thread(new Safelock.BowLoop(gaston, alphonse)).start();\n    }\n}\n\nclass Safelock {\n    static class Friend {\n        private final String name;\n        private final Lock lock = new ReentrantLock();\n\n        public Friend(String name) {\n            this.name = name;\n        }\n\n        public String getName() {\n            return this.name;\n        }\n\n        public boolean impendingBow(Friend bower) {\n            Boolean myLock = false;\n            Boolean yourLock = false;\n            try {\n                myLock = lock.tryLock();\n                yourLock = bower.lock.tryLock();\n            } finally {\n                if (! (myLock && yourLock)) {\n                    if (myLock) {\n                        lock.unlock();\n                    }\n                    if (yourLock) {\n                        bower.lock.unlock();\n                    }\n                }\n            }\n            return myLock && yourLock;\n        }\n            \n        public void bow(Friend bower) {\n            if (impendingBow(bower)) {\n                try {\n                    System.out.format(\"%s: %s has\"\n                        + \" bowed to me!%n\", \n                        this.name, bower.getName());\n                    bower.bowBack(this);\n                } finally {\n                    lock.unlock();\n                    bower.lock.unlock();\n                }\n            } else {\n                System.out.format(\"%s: %s started\"\n                    + \" to bow to me, but saw that\"\n                    + \" I was already bowing to\"\n                    + \" him.%n\",\n                    this.name, bower.getName());\n            }\n        }\n\n        public void bowBack(Friend bower) {\n            System.out.format(\"%s: %s has\" +\n                \" bowed back to me!%n\",\n                this.name, bower.getName());\n        }\n    }\n\n    static class BowLoop implements Runnable {\n        private Friend bower;\n        private Friend bowee;\n\n        public BowLoop(Friend bower, Friend bowee) {\n            this.bower = bower;\n            this.bowee = bowee;\n        }\n    \n        public void run() {\n            Random random = new Random();\n            for (;;) {\n                try {\n                    Thread.sleep(random.nextInt(10));\n                } catch (InterruptedException e) {}\n                bowee.bow(bower);\n            }\n        }\n    }\n}','IO',0,0,NULL,5),(3352,'good example of Conditions','class BoundedBuffer {\n   final Lock lock = new ReentrantLock();\n   final Condition notFull  = lock.newCondition(); \n   final Condition notEmpty = lock.newCondition(); \n\n   final Object[] items = new Object[100];\n   int putptr, takeptr, count;\n\n   public void put(Object x) throws InterruptedException {\n     lock.lock();\n     try {\n       while (count == items.length)\n         notFull.await();\n       items[putptr] = x;\n       if (++putptr == items.length) putptr = 0;\n       ++count;\n       notEmpty.signal();\n     } finally {\n       lock.unlock();\n     }\n   }\n\n   public Object take() throws InterruptedException {\n     lock.lock();\n     try {\n       while (count == 0)\n         notEmpty.await();\n       Object x = items[takeptr];\n       if (++takeptr == items.length) takeptr = 0;\n       --count;\n       notFull.signal();\n       return x;\n     } finally {\n       lock.unlock();\n     }\n   }\n }','IO',0,0,NULL,5),(3353,'Will not compile, ArrayList listData is a raw type so in the foreach loop\nyou assign them to an Integer, you would have had to cast','class DataThread implements Runnable {\n    private Data data;\n    private ArrayList listData;\n    \n    public DataThread(Data data){\n        this.data = data;\n    }\n    public void run(){\n            data.lock.lock();\n            try{\n                listData = data.produceData();\n            try{\n               data.done.await();\n            } catch(InterruptedException e){\n                \n            }\n            \n            for(Integer i : listData){\n                System.out.println(i);\n            }\n            } finally {\n                data.lock.unlock();\n            }\n    }\n    \n}','IO',0,0,NULL,5),(3354,'With ReentrantReadWriteLock you can grant write access to only one thread, but\nit is possible to allow many threads to be reading at the same time. ','public class Hello {\n    private List<Integer> integers = new ArrayList<>();\n    private ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();\n    \n    public void add(Integer i){\n        rwl.writeLock().lock();\n        try {\n            integers.add(i);\n        } finally {\n            rwl.writeLock().unlock();\n        }\n    }\n    \n    public int findMax() {\n        rwl.readLock().lock();\n        try {\n            return Collections.max(integers);\n        } finally {\n            rwl.readLock().unlock();\n        }\n    }\n    public static void main(String[] args){\n      \n    }\n\n}','IO',0,0,NULL,5),(3355,'','read-only(immutabel) objects are always thread safe. ','IO',0,0,NULL,5),(3356,'your data sets remain small and the number of read operations and traversals greatly outnumber\nmodifications to the collection. \n\nCopy on write collections work by copying their internal array of data with\nany mutating operation. This copied array will replace the original read only\narrray. \n\nThis allows it to be safely shared between multiple threads. ','Use copy on write collections when...','IO',0,0,NULL,5),(3357,'','Just because a collection is thread safe does not make the elements stored within\nthread safe','IO',0,0,NULL,5),(3358,'','The Iterator for a concurrent collection is weakly consistent; it can return elements \nfrom the point in time the Iterator was created or LATER. This means that \nwhile looping through a concurrent collection, you might observel elements that\nare being inserted by other threads. also you might see only some of the elements\nthat another thread is inserting. ','IO',0,0,NULL,5),(3359,'ConcurrentSkipListMap and ConcurrentSkipListSet \n\n-They require the use of comparable and comparotr to enable ordering. ','Which concurrent Collections are sorted ?','IO',0,0,NULL,5),(3360,'','copy on write and concurrent collections are centered on the idea of multiple\nthreads sharing data. \n\nA BlockingQueue is used to exchnage data between two or more threads while causing\nsome of the threads to wait until the point in time when the data can be \ntransfered. ','IO',0,0,NULL,5),(3361,'4\n4\n3\n6\n8\n\nto indicate that you want a pattern to be surrounded by other similar characteres\nsurround it with non word boundaries. If you did want the character to \nbee alone surround it with word boudaries.','class Hello {\n    public static void main(String[] args) {     \n        Pattern p = Pattern.compile(\"\\\\B\\\\d\\\\B\");\n        Matcher m = p.matcher(\"Th4t\'ll b3 the d4y, on th3 v3ry l6ast d8y\");\n        \n        while(m.find()){\n            System.out.println(m.group());\n        }\n        \n    }\n\n}','Strings',0,0,NULL,5),(3362,'ArrayBlockingQueue\nLinkedBlockingQueue\nLinkedBlockingQueue\nPriorityBlockingQueue\nDelayQueue\nLinkedTransferQueue\nSynchronousQueue\n','BlockingQueue implementations','Concurrency',0,0,NULL,5),(3363,'','A blocking collection, depending on the method being called, may cause a thread to block\nuntil another threads calls a corresponding method on the collection. \n\nif you attempt to reemove an element() by calling take() on any BlockingQueue\nthat is empty, the operation will block until another thread inserts an element.\n','Concurrency',0,0,NULL,5),(3364,'Returns true if object added,\n\nfalse if duplicate objects are not allowed.\n\nThrows IllegalStateException if the queue is bounded and full','BlockingQueue method:\n\nadd(E e)','Concurrency',0,0,NULL,5),(3365,'returns true if object added, false if the queue is bounded and full','BlockingQueue method:\n\noffer(E e)','Concurrency',0,0,NULL,5),(3366,'returns void.\n\nwill block until space in the queue becomes available if needed ','BlockingQueue method:\n\nput(E e)','Concurrency',0,0,NULL,5),(3367,'returns false if the object was not able to be inserted before the time idicated,\n','offer(E e, long timeout, TimeUnit unit)','Concurrency',0,0,NULL,5),(3368,'returns true if an equal object was found in the queue and removed; \notherwise returns false.','BlockingQueue method:\n\nremove(Object o)','Concurrency',0,0,NULL,5),(3369,'removes the first object in the queue and returns it. \n\nif the timeout expires before an object can be removed becaue the queue is empty\nthen a null will be returned. ','BlockingQueue method:\n\npoll(long timeout, TimeUnit unit)','Concurrency',0,0,NULL,5),(3370,'Removes and returns the first object in the queue, blocking if needed until the \nobject becomes available. \n\nonly throws InterruptedException','BlockingQueue method:\n\ntake()','Concurrency',0,0,NULL,5),(3371,'removes and returns the first object in the queue and returns null if the queue is empty\n','BlockingQueue method:\n\npoll()','Concurrency',0,0,NULL,5),(3372,'Gets the head of the queue without removing it, Throws a NoSuchElementException\nif the queue is empty. ','BlockingQueue method:\n\nelement()','Concurrency',0,0,NULL,5),(3373,'gets the head of the queue without removing it, Returns a null if the queue is \nempty. ','BlockingQueue method:\n\npeek()','Concurrency',0,0,NULL,5),(3374,'The second put(35) will block until previous values is removed by another thread.','BlockingQueue<Integer> bq = new ArrayBlockingQueue<>(1);\n\ntry{\n	bq.put(34);\n	bq.put(35);\n} catch(InterruptedException e) {}','Concurrency',0,0,NULL,5),(3375,'...is a speciel type of bounded blocking queue; it has a capacity of \nzero. The first thread to attempt either an insert or remvoe operaion\non a synchronousQueue will block until another thread performs the opposite \noperation. USe this when you need threads to meet up and exchange an object.','SynchronousQueue','Concurrency',0,0,NULL,5),(3376,'5\n9\n\nThe iterator was obtained before the 3 was added. As long as the reference to \nthe iterator is maintained it will only provide access to 5 9.\n\nIt is ConcurrentCollections that will remain weakly consistant with the changes\nmade by other threads, This is a copyonwrite array list which is thread safe but\nnot concurrent.','public class Hello {\n    public static void main(String[] args){\n       CopyOnWriteArrayList<Integer> list = new CopyOnWriteArrayList<>();\n       \n       list.add(5);\n       list.add(9);\n       Iterator<Integer> it = list.iterator();\n       \n       list.add(3);\n       \n       while(it.hasNext()){\n           System.out.println(it.next());\n       }\n    }\n}','Concurrency',0,0,NULL,5),(3377,'5\n9\n4\n\nThe iterator is obtained before the element at index 2 is removed.','public class Hello {\n    public static void main(String[] args){\n       CopyOnWriteArrayList<Integer> cowlist = new CopyOnWriteArrayList<>();\n       \n       cowlist.add(5);\n       cowlist.add(9);\n       cowlist.add(4);\n       \n       Iterator<Integer> it = cowlist.iterator();\n       \n       cowlist.remove(2);\n       \n       while(it.hasNext()){\n           System.out.println(it.next());\n       }\n       \n    }\n}','Concurrency',0,0,NULL,5),(3378,'IndexOutofBoundsException \n\nthis can be confusing here the remove(int index) is being used. \n\nto fix do this\n\ncowlist.remove(new Integer(5));','public class Hello {\n    public static void main(String[] args){\n       CopyOnWriteArrayList<Integer> cowlist = new CopyOnWriteArrayList<>();\n       \n       cowlist.add(5);\n       cowlist.add(9);\n       cowlist.add(4);\n       \n       Iterator<Integer> it = cowlist.iterator();\n       \n       cowlist.remove(5);\n       \n       while(it.hasNext()){\n           System.out.println(it.next());\n       }\n       \n    }\n}','Concurrency',0,0,NULL,5),(3379,'add and remove. These are the only methods shown that modify the list','Which methods from copyonwritearraylist will cause a new copy of the internal\narray to be created\n\nadd\nget\niterator\nremove','Concurrency',0,0,NULL,5),(3380,'only put()','ArrayBlockingQueue<Integer> abq = new ArrayBlockingQueue<>(10);\n\nwhich operation can block indefinitely\n\nabq.add(1);\nabq.offer(1);\nabq.put(1);\nabq.offer(1,5,TimeUnit.SECONDS);','Concurrency',0,0,NULL,5),(3381,'IllegalStateEXception queue is full','public class Hello implements Runnable {\n    private static ArrayBlockingQueue<Integer> abq = new ArrayBlockingQueue<>(10);\n    public static void main(String[] args){\n       Hello h = new Hello();\n       Thread t1 = new Thread(h);\n       Thread t2 = new Thread(h);\n       Thread t3 = new Thread(h);\n       Thread t4 = new Thread(h);\n       \n       t1.start();\n       t2.start();\n       t3.start();\n       t4.start();\n       \n    }\n    public void run(){\n        for(int i = 0; i<5; i++){\n            abq.add(i);\n        }\n    }\n}','Concurrency',0,0,NULL,5),(3382,'true\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\nException in thread \"Thread-2\" java.lang.IllegalStateException: Queue full\n	at java.util.AbstractQueue.add(AbstractQueue.java:98)\n	at java.util.concurrent.ArrayBlockingQueue.add(ArrayBlockingQueue.java:312)\n	at hello.Hello.run(Hello.java:27)\n	at java.lang.Thread.run(Thread.java:745)\nException in thread \"Thread-3\" java.lang.IllegalStateException: Queue full\n	at java.util.AbstractQueue.add(AbstractQueue.java:98)\n	at java.util.concurrent.ArrayBlockingQueue.add(ArrayBlockingQueue.java:312)\n	at hello.Hello.run(Hello.java:27)\n	at java.lang.Thread.run(Thread.java:745)','public class Hello implements Runnable {\n    private static ArrayBlockingQueue<Integer> abq = new ArrayBlockingQueue<>(10);\n    public static void main(String[] args){\n       Hello h = new Hello();\n       Thread t1 = new Thread(h);\n       Thread t2 = new Thread(h);\n       Thread t3 = new Thread(h);\n       Thread t4 = new Thread(h);\n       \n       t1.start();\n       t2.start();\n       t3.start();\n       t4.start();\n       \n    }\n    public void run(){\n        for(int i = 0; i<5; i++){\n            System.out.println(abq.add(i));\n        }\n    }\n}','Concurrency',0,0,NULL,5),(3383,'offer() Inserts the specified element at the tail of this queue if \nit is possible to do so immediately \nwithout exceeding the queue\'s capacity, \nreturning true upon success and false if this queue is full. \nThis method is generally preferable to method add(E), which can fail to insert an element \nonly by throwing an exception.\n\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\ntrue\nfalse\nfalse\nfalse\nfalse\nfalse\nfalse\nfalse\nfalse\nfalse\nfalse','public class Hello implements Runnable {\n    private static ArrayBlockingQueue<Integer> abq = new ArrayBlockingQueue<>(10);\n    public static void main(String[] args){\n       Hello h = new Hello();\n       Thread t1 = new Thread(h);\n       Thread t2 = new Thread(h);\n       Thread t3 = new Thread(h);\n       Thread t4 = new Thread(h);\n       \n       t1.start();\n       t2.start();\n       t3.start();\n       t4.start();\n       \n    }\n    public void run(){\n        for(int i = 0; i<5; i++){\n            System.out.println(abq.offer(i));\n        }\n    }\n}','Concurrency',0,0,NULL,5),(3384,'will not compile, .put() return void and blocks until space becomes available\n\n\'void\' is not allowed is sout();','public class Hello implements Runnable {\n    private static ArrayBlockingQueue<Integer> abq = new ArrayBlockingQueue<>(10);\n    public static void main(String[] args){\n       Hello h = new Hello();\n       Thread t1 = new Thread(h);\n       Thread t2 = new Thread(h);\n       Thread t3 = new Thread(h);\n       Thread t4 = new Thread(h);\n       \n       t1.start();\n       t2.start();\n       t3.start();\n       t4.start();\n       \n    }\n    public void run(){\n        for(int i = 0; i<5; i++){\n            System.out.println(abq.put(i));\n        }\n    }\n}','Concurrency',0,0,NULL,5),(3385,'Will not compile,\n\nput will block, therefore it may throw an interruptedException\n\nsurround with try catch','public class Hello implements Runnable {\n    private static ArrayBlockingQueue<Integer> abq = new ArrayBlockingQueue<>(10);\n    public static void main(String[] args){\n       Hello h = new Hello();\n       Thread t1 = new Thread(h);\n       Thread t2 = new Thread(h);\n       Thread t3 = new Thread(h);\n       Thread t4 = new Thread(h);\n       \n       t1.start();\n       t2.start();\n       t3.start();\n       t4.start();\n       \n    }\n    public void run(){\n        for(int i = 0; i<5; i++){\n            abq.put(i);\n        }\n    }\n}','Concurrency',0,0,NULL,5),(3386,'will run indefinitely, put will block until space becomes available, here \nit will never become available because there is no code removing objects','public class Hello implements Runnable {\n    private static ArrayBlockingQueue<Integer> abq = new ArrayBlockingQueue<>(10);\n    public static void main(String[] args){\n       Hello h = new Hello();\n       Thread t1 = new Thread(h);\n       Thread t2 = new Thread(h);\n       Thread t3 = new Thread(h);\n       Thread t4 = new Thread(h);\n       \n       t1.start();\n       t2.start();\n       t3.start();\n       t4.start();\n       \n    }\n    public void run(){\n        for(int i = 0; i<5; i++){\n            try{\n                abq.put(i);\n            } catch(InterruptedException e){}\n        }\n    }\n}','Concurrency',0,0,NULL,5),(3387,'peek() returns the head without removing it. returns null if empty\nThread-0removed element: 0\nThread-0removed element: 0\nThread-0removed element: 0\nThread-0removed element: 0\nThread-0removed element: 0\nThread-2removed element: 0\nThread-2removed element: 0\nThread-2removed element: 0\nThread-2removed element: 0\nThread-2removed element: 0\nThread-3removed element: 0\nThread-3removed element: 0\nThread-3removed element: 0\nThread-3removed element: 0\nThread-3removed element: 0\nThread-1removed element: 0\nThread-1removed element: 0\nThread-1removed element: 0\nThread-1removed element: 0\nThread-1removed element: 0\n','public class Hello implements Runnable {\n    private static ArrayBlockingQueue<Integer> abq = new ArrayBlockingQueue<>(10);\n    public static void main(String[] args){\n        for(int i = 0; i<10; i++)\n                abq.add(i);\n  \n       Hello h = new Hello();\n       Thread t1 = new Thread(h);\n       Thread t2 = new Thread(h);\n       Thread t3 = new Thread(h);\n       Thread t4 = new Thread(h);\n       \n       t1.start();\n       t2.start();\n       t3.start();\n       t4.start();\n       \n    }\n    public void run(){\n        for(int i = 0; i<5; i++){\n            System.out.println(Thread.currentThread().getName()+\"removed element: \"+abq.peek());\n        }\n        \n    }\n}','Concurrency',0,0,NULL,5),(3388,'','ArrayBlockingQueue<E>\n\nA bounded blocking queue backed by an array. \nThis queue orders elements FIFO (first-in-first-out). \nThe head of the queue is that element that has been on the queue the longest time. \nThe tail of the queue is that element that has been on the queue the shortest time. \nNew elements are inserted at the tail of the queue, and the queue retrieval operations obtain elements at the head of the queue.\n\nThis is a classic \"bounded buffer\", in which a fixed-sized array holds elements inserted by producers and extracted by consumers. \nOnce created, the capacity cannot be changed. Attempts to put an element into a full queue will result in the operation blocking; \nattempts to take an element from an empty queue will similarly block. ','Concurrency',0,0,NULL,5),(3389,'PutThread:Put One\nTakerThread:Retrieve using take\nTakerThread:take() returned One\nPutThread:Returned from put\n\nSyncQueue is used to make two threads meet up and hand off an object. \n\nBoth insertion and removal operations will block until the other thread\ndoes the inverse thus making the threads meet and exchange. ','public class Hello {\n    public static void main(String[] args){\n        SynchronousQueue<String> sq = new SynchronousQueue<String>();\n        Thread putThread = new Thread(new PutRunnable<String>(sq, \"One\"), \"PutThread\");\n        putThread.start();\n        Thread takerThread = new Thread(new TakerRunnable<String>(sq), \"TakerThread\");\n        takerThread.start();\n\n    }\n}\n\n class PutRunnable<T> implements Runnable {\n    private T value;\n    private SynchronousQueue<T> syncQ;\n    PutRunnable(SynchronousQueue<T> syncQ, T value) {\n        this.syncQ = syncQ;\n        this.value = value;\n    }\n    public void run() {\n        try {\n            PrintUtils.print(\"Put \" + value);\n            syncQ.put(value);\n            PrintUtils.print(\"Returned from put\");\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n \n}\nclass TakerRunnable<T> implements Runnable {\n    private T value;\n    private SynchronousQueue<T> syncQ;\n    TakerRunnable(SynchronousQueue<T> syncQ) {\n        this.syncQ = syncQ;\n    }\n    public void run() {\n        try {\n            PrintUtils.print(\"Retrieve using take\");\n            value = syncQ.take();\n            PrintUtils.print(\"take() returned \" + value);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n    public T getValue() {\n        return value;\n    }\n}\n\nclass PrintUtils {\n    public static void print(String s) {\n        System.out.println(Thread.currentThread().getName() + \":\" + s);\n    }\n}','Concurrency',0,0,NULL,5),(3390,'LinkedTranserQueue implements the BlockingQueue, TransferQueue, and Queue interfaces\n\nit is used here to demonstrate all the inserting and removing methods.','public class Hello {\n    \n    private static TransferQueue<Integer> tq = new LinkedTransferQueue<>();\n\n    public static void main(String[] args){\n        boolean b1 = tq.add(1); // true if added, IllegalStateException if full\n        \n        try{\n            //both of these throw interruptedExceptions because they block and wait\n            \n            tq.put(2);  //blocks if bounded or full\n        \n            tq.transfer(88); //blocks until element is consumed\n            \n        } catch(InterruptedException e){ }\n        \n        tq.tryTransfer(7); // returns true if consumed by the awaiting thread, or false without adding if there was no awaiting consumer.\n            // does not block therefore does not throw interruptedException\n        \n        try {\n            \n            //will wait the given time, blocking, then will return if not consumed\n            boolean b7 = tq.tryTransfer(99,10,TimeUnit.SECONDS);\n            \n        } catch(InterruptedException e){ }\n\n    }\n    \n    public static void methodsToRetrieve(){\n        Integer i1 = tq.element(); // gets without removing, throws NoSuchElementException if empty\n        \n        Integer i2 = tq.peek(); // gets without removing, null if empty\n        \n        Integer i3 = tq.poll(); //returns and removes the head, null if empty\n        \n        try{\n            Integer i4 = tq.poll(10,TimeUnit.MILLISECONDS); // removes the head, waits the specified time beffore returning null if empty\n        } catch(InterruptedException e) { }\n        \n        Integer i5 = tq.remove(); // removes the head of the queue throws NoSuchElementException if empty\n                \n        try{\n            Integer i6 = tq.take(); //removes the head blocks until an element is ready,\n        } catch(InterruptedException e) { }\n                \n    }','Concurrency',0,0,NULL,5),(3391,'will not compile, LinkedTransferQueue is not bounded and cannot be supplied with\na size argument','public class Hello {\n    \n    private static TransferQueue<Integer> tq = new LinkedTransferQueue<>(45);\n\n    public static void main(String[] args){\n        boolean b1 = tq.add(1); // true if added, IllegalStateException if full\n        \n        try{\n            //both of these throw interruptedExceptions because they block and wait\n            \n            tq.put(2);  //blocks if bounded or full\n        \n            tq.transfer(88); //blocks until element is consumed\n            \n        } catch(InterruptedException e){ }\n        \n        tq.tryTransfer(7); // returns true if consumed by the awaiting thread, or false without adding if there was no awaiting consumer.\n            // does not block therefore does not throw interruptedException\n        \n        try {\n            \n            //will wait the given time, blocking, then will return if not consumed\n            boolean b7 = tq.tryTransfer(99,10,TimeUnit.SECONDS);\n            \n        } catch(InterruptedException e){ }\n\n    }\n    \n    public static void methodsToRetrieve(){\n        Integer i1 = tq.element(); // gets without removing, throws NoSuchElementException if empty\n        \n        Integer i2 = tq.peek(); // gets without removing, null if empty\n        \n        Integer i3 = tq.poll(); //returns and removes the head, null if empty\n        \n        try{\n            Integer i4 = tq.poll(10,TimeUnit.MILLISECONDS); // removes the head, waits the specified time beffore returning null if empty\n        } catch(InterruptedException e) { }\n        \n        Integer i5 = tq.remove(); // removes the head of the queue throws NoSuchElementException if empty\n                \n        try{\n            Integer i6 = tq.take(); //removes the head blocks until an element is ready,\n        } catch(InterruptedException e) { }\n                \n    }','Concurrency',0,0,NULL,5),(3392,'will not compile, put and transfer block and wait, therefore they throw \nInterruptedExceptions','public class Hello {\n    \n    private static TransferQueue<Integer> tq = new LinkedTransferQueue<>();\n\n    public static void main(String[] args){\n        boolean b1 = tq.add(1); // true if added, IllegalStateException if full\n            \n        tq.put(2);  //blocks if bounded or full\n        \n        tq.transfer(88); //blocks until element is consumed\n        \n        tq.tryTransfer(7); // returns true if consumed by the awaiting thread, or false without adding if there was no awaiting consumer.\n            // does not block therefore does not throw interruptedException\n        \n        try {\n            \n            //will wait the given time, blocking, then will return if not consumed\n            boolean b7 = tq.tryTransfer(99,10,TimeUnit.SECONDS);\n            \n        } catch(InterruptedException e){ }\n\n    }\n    \n    public static void methodsToRetrieve(){\n        Integer i1 = tq.element(); // gets without removing, throws NoSuchElementException if empty\n        \n        Integer i2 = tq.peek(); // gets without removing, null if empty\n        \n        Integer i3 = tq.poll(); //returns and removes the head, null if empty\n        \n        try{\n            Integer i4 = tq.poll(10,TimeUnit.MILLISECONDS); // removes the head, waits the specified time beffore returning null if empty\n        } catch(InterruptedException e) { }\n        \n        Integer i5 = tq.remove(); // removes the head of the queue throws NoSuchElementException if empty\n                \n        try{\n            Integer i6 = tq.take(); //removes the head blocks until an element is ready,\n        } catch(InterruptedException e) { }\n                \n    }','Concurrency',0,0,NULL,5),(3393,'This shows the proper use of take() which will block until a book is available,\noffer is also properlyy used becaue it will only add if the queue is not full\nif it is it simply doesn\'t add it and doesn\'t throw an exception or anything.\n\nThis ones good try Topics of Destruction. Enjoy!\nMike chekced out Topics of Destruction\nThis ones good try War what is it good for. Enjoy!\nMax chekced out War what is it good for\nThis ones good try LOTR. Enjoy!\nPriebe chekced out LOTR\nThis ones good try Manson, the secret life. Enjoy!\nDom chekced out Manson, the secret life\nMike: Im done with Topics of Destruction here take it back!\nThis ones good try Topics of Destruction. Enjoy!\nMike chekced out Topics of Destruction\nPriebe: Im done with LOTR here take it back!\nThis ones good try LOTR. Enjoy!\nPriebe chekced out LOTR\nDom: Im done with Manson, the secret life here take it back!\nThis ones good try Manson, the secret life. Enjoy!\nDom chekced out Manson, the secret life\nMike: Im done with Topics of Destruction here take it back!\nThis ones good try Topics of Destruction. Enjoy!\nMike chekced out Topics of Destruction\nMax: Im done with War what is it good for here take it back!\nThis ones good try War what is it good for. Enjoy!\nMax chekced out War what is it good for\nPriebe: Im done with LOTR here take it back!\nThis ones good try LOTR. Enjoy!\nPriebe chekced out LOTR\nMike: Im done with Topics of Destruction here take it back!\nThis ones good try Topics of Destruction. Enjoy!\nMike chekced out Topics of Destruction\nPriebe: Im done with LOTR here take it back!\nThis ones good try LOTR. Enjoy!\nPriebe chekced out LOTR','public class Hello {\n    \n    public static void main(String[] args){\n        Library library = new Library();\n        \n        new Thread(library).start();\n        \n        new Thread(new Renter(library,\"Mike\")).start();\n        new Thread(new Renter(library,\"Max\")).start();\n        new Thread(new Renter(library,\"Priebe\")).start();\n        new Thread(new Renter(library,\"Dom\")).start();\n    }\n}\n\nclass Library implements Runnable{\n    private TransferQueue<Book> shelves = new LinkedTransferQueue<>();\n    \n    public Library() {\n        shelves.add(new Book(\"Topics of Destruction\"));\n        shelves.add(new Book(\"War what is it good for\"));\n        shelves.add(new Book(\"LOTR\"));\n        shelves.add(new Book(\"Manson, the secret life\"));\n    }\n    \n    public void run(){\n        while(true){ }\n    }\n    \n    public Book lend(){\n        \n        try {\n            Book book = shelves.take();\n            System.out.println(\"This ones good try \"+book.getName()+\". Enjoy!\");\n            return book;\n        } catch(InterruptedException e){ }\n        \n        return new Book(\"Free Library Pamphlet on plagarism\");\n    }\n    \n    public void accept(Book book){\n        shelves.offer(book);\n       \n    }\n}\n\nclass Renter implements Runnable {\n    private Library lib;\n    private String name;\n    public Renter(Library lib,String x){\n        name = x;\n        this.lib = lib;\n    }\n    public void run(){\n        while(true){\n            Book book = lib.lend();\n            System.out.println(name+\" chekced out \"+book.getName());\n            try{\n                Thread.sleep(ThreadLocalRandom.current().nextInt(1000,5000));\n            } catch(InterruptedException e) { }\n            \n            System.out.println(name+\": Im done with \"+book.getName()+\" here take it back!\");\n            lib.accept(book);\n        }\n    }\n}\n\n\nclass Book{\n    private String name;\n    public Book(String x ){\n        name = x;\n    }\n    \n    public String getName(){\n        return name;\n    }\n    \n}','Concurrency',0,0,NULL,5),(3394,'element() throws NoSuchElementException,\n\n','public class Hello {\n    \n    public static void main(String[] args){\n        Library library = new Library();\n        \n        new Thread(library).start();\n        \n        new Thread(new Renter(library,\"Mike\")).start();\n        new Thread(new Renter(library,\"Max\")).start();\n        new Thread(new Renter(library,\"Priebe\")).start();\n        new Thread(new Renter(library,\"Dom\")).start();\n    }\n}\n\nclass Library implements Runnable{\n    private TransferQueue<Book> shelves = new LinkedTransferQueue<>();\n    \n    public Library() {\n        shelves.add(new Book(\"Capulets and Montagues, the unknown link\"));\n        shelves.add(new Book(\"War What is it Good For\"));\n        shelves.add(new Book(\"Virtuous Villians\"));\n        shelves.add(new Book(\"Love in the Water\"));\n    }\n    \n    public void run(){\n        while(true){ }\n    }\n    \n    public Book lend(){\n        \n        try {\n            Book book = shelves.element();\n            System.out.println(\"This ones good try \"+book.getName()+\". Enjoy!\");\n            return book;\n        } catch(NoSuchElementException e){System.out.println(\"I\'m sorry sir we dont have that book right now\"); }\n        \n        return new Book(\"Free Library Pamphlet on plagarism\");\n    }\n    \n    public void accept(Book book){\n        shelves.offer(book);\n       \n    }\n}\n\nclass Renter implements Runnable {\n    private Library lib;\n    private String name;\n    public Renter(Library lib,String x){\n        name = x;\n        this.lib = lib;\n    }\n    public void run(){\n        while(true){\n            Book book = lib.lend();\n            System.out.println(name+\" chekced out \"+book.getName());\n            try{\n                Thread.sleep(ThreadLocalRandom.current().nextInt(1000,5000));\n            } catch(InterruptedException e) { }\n            \n            System.out.println(name+\": Im done with \"+book.getName()+\" here take it back!\");\n            lib.accept(book);\n        }\n    }\n}\n\nclass Book{\n    private String name;\n    public Book(String x ){\n        name = x;\n    }\n    \n    public String getName(){\n        return name;\n    }\n    \n}','Concurrency',0,0,NULL,5),(3395,'The same book keeps getting checked out because peek()\nreturns but does not remove the element\n\nThis ones good try Capulets and Montagues, the unknown link. Enjoy!\nMike chekced out Capulets and Montagues, the unknown link\nThis ones good try Capulets and Montagues, the unknown link. Enjoy!\nMax chekced out Capulets and Montagues, the unknown link\nThis ones good try Capulets and Montagues, the unknown link. Enjoy!\nPriebe chekced out Capulets and Montagues, the unknown link\nThis ones good try Capulets and Montagues, the unknown link. Enjoy!\nDom chekced out Capulets and Montagues, the unknown link\nDom: Im done with Capulets and Montagues, the unknown link here take it back!\nThis ones good try Capulets and Montagues, the unknown link. Enjoy!\nDom chekced out Capulets and Montagues, the unknown link\nMike: Im done with Capulets and Montagues, the unknown link here take it back!\nThis ones good try Capulets and Montagues, the unknown link. Enjoy!\nMike chekced out Capulets and Montagues, the unknown link\nPriebe: Im done with Capulets and Montagues, the unknown link here take it back!\nThis ones good try Capulets and Montagues, the unknown link. Enjoy!\nPriebe chekced out Capulets and Montagues, the unknown link\nMax: Im done with Capulets and Montagues, the unknown link here take it back!\nThis ones good try Capulets and Montagues, the unknown link. Enjoy!\nMax chekced out Capulets and Montagues, the unknown link\nDom: Im done with Capulets and Montagues, the unknown link here take it back!','public class Hello {\n    \n    public static void main(String[] args){\n        Library library = new Library();\n        \n        new Thread(library).start();\n        \n        new Thread(new Renter(library,\"Mike\")).start();\n        new Thread(new Renter(library,\"Max\")).start();\n        new Thread(new Renter(library,\"Priebe\")).start();\n        new Thread(new Renter(library,\"Dom\")).start();\n    }\n}\n\nclass Library implements Runnable{\n    private TransferQueue<Book> shelves = new LinkedTransferQueue<>();\n    \n    public Library() {\n        shelves.add(new Book(\"Capulets and Montagues, the unknown link\"));\n        shelves.add(new Book(\"War What is it Good For\"));\n        shelves.add(new Book(\"Virtuous Villians\"));\n        shelves.add(new Book(\"Love in the Water\"));\n    }\n    \n    public void run(){\n        while(true){ }\n    }\n    \n    public Book lend(){\n\n            Book book = shelves.peek();\n            System.out.println(\"This ones good try \"+book.getName()+\". Enjoy!\");\n        \n            if(book == null){\n                return new Book(\"Free Library Pamphlet on plagarism\");\n            } else {\n                return book;\n            }\n    }\n    \n    public void accept(Book book){\n        shelves.offer(book);\n       \n    }\n}\n\nclass Renter implements Runnable {\n    private Library lib;\n    private String name;\n    public Renter(Library lib,String x){\n        name = x;\n        this.lib = lib;\n    }\n    public void run(){\n        while(true){\n            Book book = lib.lend();\n            System.out.println(name+\" chekced out \"+book.getName());\n            try{\n                Thread.sleep(ThreadLocalRandom.current().nextInt(1000,5000));\n            } catch(InterruptedException e) { }\n            \n            System.out.println(name+\": Im done with \"+book.getName()+\" here take it back!\");\n            lib.accept(book);\n        }\n    }\n}\n\nclass Book{\n    private String name;\n    public Book(String x ){\n        name = x;\n    }\n    \n    public String getName(){\n        return name;\n    }\n    \n}','Concurrency',0,0,NULL,5),(3396,'does not compile, \n\nput() will block if there is no space available therefor it throws an\n\nInterruptedException','public class Hello {\n    \n    public static void main(String[] args){\n        Library library = new Library();\n        \n        new Thread(library).start();\n        \n        new Thread(new Renter(library,\"Mike\")).start();\n        new Thread(new Renter(library,\"Max\")).start();\n        new Thread(new Renter(library,\"Priebe\")).start();\n        new Thread(new Renter(library,\"Dom\")).start();\n    }\n}\n\nclass Library implements Runnable{\n    private TransferQueue<Book> shelves = new LinkedTransferQueue<>();\n    \n    public Library() {\n        shelves.add(new Book(\"Capulets and Montagues, the unknown link\"));\n        shelves.add(new Book(\"War What is it Good For\"));\n        shelves.add(new Book(\"Virtuous Villians\"));\n        shelves.add(new Book(\"Love in the Water\"));\n    }\n    \n    public void run(){\n        while(true){ }\n    }\n    \n    public Book lend(){\n\n            Book book = shelves.poll();\n            System.out.println(\"This ones good try \"+book.getName()+\". Enjoy!\");\n        \n            if(book == null){\n                return new Book(\"Free Library Pamphlet on plagarism\");\n            } else {\n                return book;\n            }\n    }\n    \n    public void accept(Book book){\n        shelves.put(book);\n       \n    }\n}\n\nclass Renter implements Runnable {\n    private Library lib;\n    private String name;\n    public Renter(Library lib,String x){\n        name = x;\n        this.lib = lib;\n    }\n    public void run(){\n        while(true){\n            Book book = lib.lend();\n            System.out.println(name+\" chekced out \"+book.getName());\n            try{\n                Thread.sleep(ThreadLocalRandom.current().nextInt(1000,5000));\n            } catch(InterruptedException e) { }\n            \n            System.out.println(name+\": Im done with \"+book.getName()+\" here take it back!\");\n            lib.accept(book);\n        }\n    }\n}\n\nclass Book{\n    private String name;\n    public Book(String x ){\n        name = x;\n    }\n    \n    public String getName(){\n        return name;\n    }\n    \n}','Concurrency',0,0,NULL,5),(3397,'take()','Which BlockingCollection method will block if needed until an object becomes\navailabel','Concurrency',0,0,NULL,5),(3398,'element()','Which BlockingCollection method throws nosuchelementexception','Concurrency',0,0,NULL,5),(3399,'add()','Which BlockingQueue method throws an illegalstateexception if the queueu is bounded and full ? ','Concurrency',0,0,NULL,5),(3400,'offer() and offer(e, long timeout, timeunit)','Whic BlockingQueue method returns true if it was added and false if \nthe queueu was full but also provides a timeout overloaded option','Concurrency',0,0,NULL,5),(3401,'','','blank',0,0,NULL,5),(3402,'String43\nString7\n43\n7\n53\n2','	String a = \"String\";\n        int b = 4;\n        int c = 3;\n        System.out.println(a+b+c);\n        System.out.println(a+(b+c));\n        System.out.println(\"\" + b + 3);\n        System.out.println(b+3);\n        System.out.println(++b + \"\" + c--);\n        System.out.println(c);','Strings',0,0,NULL,5),(3403,'','','blank',0,0,NULL,5),(3404,'Cached thread pools will create new threads as needed and reuse threads that \nhave become free. Thread that have been idle for 60 seconds are removed.\n\nCan create more threads than system can handle so watch out. ','ExecutorService ex = Executors.newCachedThreadPool();','Executors',0,0,NULL,5),(3405,'constructed with an int argument that specifies the number of threads to use\nto execute the tasks. Most common. Prevents system from being overloaded\nwith too many threads. \n\nBase number of threads on some kind of system resource. \n\nuse java.lang.Runtime\n\nRuntime rt = Runtime.getRuntime();\nint cpus = rt.availabeProcessors();','ExecutorService ex = Executors.newFixedThreadPool(4);\n','Executors',0,0,NULL,5),(3406,'ThreadPoolExecutor tpe = (ThreadPoolExecutor) Executors.newFixedThreadPool(4);\ntpe.setCorePoolSize(8);\ntpe.setMaximumPoolSize(8);','How to adust the thread count of a pool at runtime\n\n','Executors',0,0,NULL,5),(3407,'        ExecutorService ex = Executors.newSingleThreadExecutor(); \n\nwil not compile, it is singlethreadexecutor not singlethreadPool\n\n**Also you shutdown the ExecutorService not the Future!','public class Hello {\n    public static void main(String[] args){\n        ExecutorService ex = Executors.newSingleThreadPool();\n\n        Future<Integer> futint = ex.submit(new FileCounter());\n        \n        System.out.println(\"Do other things while the files are getting counted\");\n        \n        try{\n            int count = futint.get();\n            System.out.println(count);\n            futint.shutdown();\n        }catch(ExecutionException | InterruptedException e){\n            \n        }\n        \n    }\n    \n    \n}\n\nclass FileCounter implements Callable<Integer>{\n    private int fileCount = 0;\n    public Integer call() throws IOException{\n        fileCount = count(Paths.get(\"/home/maxbisesi/Documents\"));\n        return fileCount; \n    }\n    \n    public Integer count(Path d) throws IOException {\n        int count = 0;\n	try(DirectoryStream<Path> stream = Files.newDirectoryStream(d)){\n		for(Path path: stream){\n			count++;\n		}\n	}\n        return count;\n    }\n}','Executors',0,0,NULL,5),(3408,'','Scheduled Thread pool:\n	scheduled after a delay or at repeating intervals\n\npublic class Hello {\n    \n    public static void main(String[] args){\n     ScheduledExecutorService ftses = Executors.newScheduledThreadPool(4);\n     \n     ftses.schedule(r, 5, TimeUnit.SECONDS); //run once after a delay\n     \n     ftses.scheduleAtFixedRate(r, 2,5,TimeUnit.SECONDS); //begin after 2 sec delay and begin again every 5\n     \n     ftses.scheduleWithFixedDelay(r, 2, 5, TimeUnit.SECONDS); //begin after 2 sec delay and again 5 seconds after the last exection\n}','Executors',0,0,NULL,5),(3409,'Callable and Runnable','an ExecutorService can take what two kinds of objects ?','Executors',0,0,NULL,5),(3410,'being able to return a result','What is the primary benifit of using a Callable ?','Executors',0,0,NULL,5),(3411,'InterruptedException and ExecutionException','submitting a Callable to an ExecutorService returns a Future reference.\n\nwhat are two possible exceptions that could result ?','Executors',0,0,NULL,5),(3412,'raised when an exception was thrown during the execution of the callable\'s\ncall()','ExecutionException','Executors',0,0,NULL,5),(3413,'When a callable task is submitted to an executor the task will go run,\ncalling for its return value will block until it is done so otherwise go on \nwith your program until you are ready to use that result. In this code the rest\nof main is executed only after the future is returned.\nrunning...1\nrunning...2\nrunning...3\nrunning...4\nrunning...5\nrunning...6\nrunning...7\nrunning...8\nrunning...9\nrunning...10\nRan: 10\nmain: 0\nmain: 1\nmain: 2\nmain: 3\nmain: 4\nmain: 5\nmain: 6\nmain: 7\nmain: 8\nmain: 9\n','public class Hello {\n    \n    public static void main(String[] args){\n        Callable<Integer> c = new LoopCounter();\n        \n        ExecutorService ex = Executors.newCachedThreadPool();\n        \n        Future<Integer> f = ex.submit(c); //finishes in the future\n        \n        try{\n            Integer v = f.get(); // will block until done\n            System.out.println(\"Ran: \" + v);\n        } catch(InterruptedException | ExecutionException iex){\n            System.out.println(\"Failed\");\n        }\n        \n        for(int i = 0; i<10; i++){\n            System.out.println(\"main: \"+ i);\n        }\n    }\n}\n\nclass LoopCounter implements Callable<Integer> {\n    \n    public Integer call(){\n        int count = ThreadLocalRandom.current().nextInt(1,11);\n        for(int i = 1; i <= count; i++){\n                System.out.println(\"running...\" + i);\n        }\n        return count;\n    }\n}','Executors',0,0,NULL,5),(3414,'got it ','Using Executors takes away the need for synchronization, waiting, joining and \nnotifying','Executors',0,0,NULL,5),(3415,'The program will complete normally, without shutdown() it would continue to run,\nit is best to shutdown an executor service in order to free up threads.','public class Hello {\n    \n    public static void main(String[] args){\n        Callable<Integer> c = new LoopCounter();\n        \n        ExecutorService ex = Executors.newCachedThreadPool();\n        \n        Future<Integer> f = ex.submit(c); //finishes in the future\n        \n        try{\n            Integer v = f.get(); // will block until done\n            System.out.println(\"Ran: \" + v);\n        } catch(InterruptedException | ExecutionException iex){\n            System.out.println(\"Failed\");\n        }\n        \n        for(int i = 0; i<10; i++){\n            System.out.println(\"main: \"+ i);\n        }\n        \n        ex.shutdown();\n    }\n}\n\nclass LoopCounter implements Callable<Integer> {\n    \n    public Integer call(){\n        int count = ThreadLocalRandom.current().nextInt(1,11);\n        for(int i = 1; i <= count; i++){\n                System.out.println(\"running...\" + i);\n        }\n        return count;\n    }\n}','Executors',0,0,NULL,5),(3416,'','ExecutorService ex = ...\n//......\n\nex.shutdown(); // no more new tasks but finish existing tasks\n\ntry{\n	boolean term = ex.awaitTermination(2,TimeUnit.SECONDS);\n		//wait two seconds for running tasks to finsish\n} catch(InterruptedException ex) {\n	//did not wait full two seconds\n} finally {\n   if(!ex.isTerminated()) // are all tasks done ?\n   {\n	List<Runnable> unfinished = ex.shutdownNow();\n		// a collection of unfished tasks\n   }\n}','Executors',0,0,NULL,5),(3417,'breaks a big task down into smaller parts\n\n','class RandomInitRA extends RecursiveAction {\n    private static final int THRESHOLD = 10000;\n    private int[] data;\n    private int start;\n    private int end;\n    \n    public RandomInitRA(int[] data, int start, int end) {\n        this.data = data;\n        this.start = start;\n        this.end = end;\n    }\n    \n    protected void compute() {\n        if(end - start <= THRESHOLD) {\n            // if this is a manageable amount of work do the task\n            for(int i = start; i<end; i++){\n                data[i] = ThreadLocalRandom.current().nextInt();\n            }\n        } else { //task too big\n            int halfway = ((end - start) / 2) + start;\n            RandomInitRA a1 = new RandomInitRA(data,start,halfway);\n            a1.fork();\n            RandomInitRA a2 = new RandomInitRA(data,halfway,end);\n            a2.compute();\n            a1.join();\n        }\n    }\n}','Executors',0,0,NULL,5),(3418,'use invokeAll instead of the fork join compute, \nRecursiveAction does not reutrn a value so you should not excpect a value\nfrom invoke all. ','class RandomInitRA extends RecursiveAction {\n    private static final int THRESHOLD = 10000;\n    private int[] data;\n    private int start;\n    private int end;\n    \n    public RandomInitRA(int[] data, int start, int end) {\n        this.data = data;\n        this.start = start;\n        this.end = end;\n    }\n    \n    protected void compute() {\n        if(end - start <= THRESHOLD) {\n            // if this is a manageable amount of work do the task\n            for(int i = start; i<end; i++){\n                data[i] = ThreadLocalRandom.current().nextInt();\n            }\n        } else { //task too big\n            int halfway = ((end - start) / 2) + start;\n            RandomInitRA a1 = new RandomInitRA(data,start,halfway);\n            RandomInitRA a2 = new RandomInitRA(data,halfway,end);\n            invokeAll(a1,a2);\n        }\n    }\n}','Executors',0,0,NULL,5),(3419,'will not compile, return type of compute from RecursiveAction is void as\nRAs do not return values. ','class RandomInitRA extends RecursiveAction {\n    private static final int THRESHOLD = 10000;\n    private int[] data;\n    private int start;\n    private int end;\n    \n    public RandomInitRA(int[] data, int start, int end) {\n        this.data = data;\n        this.start = start;\n        this.end = end;\n    }\n    \n    protected int compute() {\n        if(end - start <= THRESHOLD) {\n            // if this is a manageable amount of work do the task\n            for(int i = start; i<end; i++){\n                data[i] = ThreadLocalRandom.current().nextInt();\n            }\n        } else { //task too big\n            int halfway = ((end - start) / 2) + start;\n            RandomInitRA a1 = new RandomInitRA(data,start,halfway);\n            RandomInitRA a2 = new RandomInitRA(data,halfway,end);\n            invokeAll(a1,a2);\n        }\n    }\n}','Executors',0,0,NULL,5),(3420,'int[] data = new int[10_000_000];\nForkJoinPool fjpool = new ForkJoinPool();\nRandomInitRA ra = new RandomInitRA(data,0,data.length);\n        \nfjpool.invoke(ra);','public class Hello{\n    public static void main(String[]  args){\n        \n        \n        \n    }\n}\n \nclass RandomInitRA extends RecursiveAction {\n    private static final int THRESHOLD = 10000;\n    private int[] data;\n    private int start;\n    private int end;\n    \n    public RandomInitRA(int[] data, int start, int end) {\n        this.data = data;\n        this.start = start;\n        this.end = end;\n    }\n    \n    protected void compute() {\n        if(end - start <= THRESHOLD) {\n            // if this is a manageable amount of work do the task\n            for(int i = start; i<end; i++){\n                data[i] = ThreadLocalRandom.current().nextInt();\n            }\n        } else { //task too big\n            int halfway = ((end - start) / 2) + start;\n            RandomInitRA a1 = new RandomInitRA(data,start,halfway);\n            RandomInitRA a2 = new RandomInitRA(data,halfway,end);\n            invokeAll(a1,a2);\n        }\n    }\n}\n\n//given that the task of this RA is to fill a big array with random numbers\n// how would you start it in main given int[] data = new int[10_000_000];','Executors',0,0,NULL,5),(3421,'the forkjoinpool method is invoke() not invokeAll()\n\nit should be:\n\n	fjpool.invoke(ra);\n\nThere is an invokeAll() but it takes a collection of callable and returns \na list of futures. \n\nnotice too that it doesn\'t return a value, technically it is of type Void, and\nnull is the only valid type for Void','public class Hello{\n    public static void main(String[]  args){\n        int[] data = new int[10_000_000];\n        ForkJoinPool fjpool = new ForkJoinPool();\n        RandomInitRA ra = new RandomInitRA(data,0,data.length);\n        \n        fjpool.invokeAll(ra);\n    }\n}\n \nclass RandomInitRA extends RecursiveAction {\n    private static final int THRESHOLD = 10000;\n    private int[] data;\n    private int start;\n    private int end;\n    \n    public RandomInitRA(int[] data, int start, int end) {\n        this.data = data;\n        this.start = start;\n        this.end = end;\n    }\n    \n    protected void compute() {\n        if(end - start <= THRESHOLD) {\n            // if this is a manageable amount of work do the task\n            for(int i = start; i<end; i++){\n                data[i] = ThreadLocalRandom.current().nextInt();\n            }\n        } else { //task too big\n            int halfway = ((end - start) / 2) + start;\n            RandomInitRA a1 = new RandomInitRA(data,start,halfway);\n            RandomInitRA a2 = new RandomInitRA(data,halfway,end);\n            invokeAll(a1,a2);\n        }\n    }\n}','Executors',0,0,NULL,5),(3422,'RecursiveAction RecursiveTask','Two subclasses of ForkJoinTask<V>','Executors',0,0,NULL,5),(3423,'this will compile \n\nan overriden method CAN have less restrive access, but not more restrictive.\n\ncompute() is protected in abstract class','class RandomInitRA extends RecursiveAction {\n    private static final int THRESHOLD = 10000;\n    private int[] data;\n    private int start;\n    private int end;\n    \n    public RandomInitRA(int[] data, int start, int end) {\n        this.data = data;\n        this.start = start;\n        this.end = end;\n    }\n    \n    public void compute() {\n        if(end - start <= THRESHOLD) {\n            // if this is a manageable amount of work do the task\n            for(int i = start; i<end; i++){\n                data[i] = ThreadLocalRandom.current().nextInt();\n            }\n        } else { //task too big\n            int halfway = ((end - start) / 2) + start;\n            RandomInitRA a1 = new RandomInitRA(data,start,halfway);\n            RandomInitRA a2 = new RandomInitRA(data,halfway,end);\n            invokeAll(a1,a2);\n        }\n    }\n}','Executors',0,0,NULL,5),(3424,'','','Executors',0,0,NULL,5),(3425,'will not compile an overriden method CAN have more restrictive access but not \nless. private is less than public.','class RandomInitRA extends RecursiveAction {\n    private static final int THRESHOLD = 10000;\n    private int[] data;\n    private int start;\n    private int end;\n    \n    public RandomInitRA(int[] data, int start, int end) {\n        this.data = data;\n        this.start = start;\n        this.end = end;\n    }\n    \n    private void compute() {\n        if(end - start <= THRESHOLD) {\n            // if this is a manageable amount of work do the task\n            for(int i = start; i<end; i++){\n                data[i] = ThreadLocalRandom.current().nextInt();\n            }\n        } else { //task too big\n            int halfway = ((end - start) / 2) + start;\n            RandomInitRA a1 = new RandomInitRA(data,start,halfway);\n            RandomInitRA a2 = new RandomInitRA(data,halfway,end);\n            invokeAll(a1,a2);\n        }\n    }\n}','Executors',0,0,NULL,5),(3426,'will not compile, an overriden method cannot have more restrictive access\ndefault is more restrictive than protected.','class RandomInitRA extends RecursiveAction {\n    private static final int THRESHOLD = 10000;\n    private int[] data;\n    private int start;\n    private int end;\n    \n    public RandomInitRA(int[] data, int start, int end) {\n        this.data = data;\n        this.start = start;\n        this.end = end;\n    }\n    \n    void compute() {\n        if(end - start <= THRESHOLD) {\n            // if this is a manageable amount of work do the task\n            for(int i = start; i<end; i++){\n                data[i] = ThreadLocalRandom.current().nextInt();\n            }\n        } else { //task too big\n            int halfway = ((end - start) / 2) + start;\n            RandomInitRA a1 = new RandomInitRA(data,start,halfway);\n            RandomInitRA a2 = new RandomInitRA(data,halfway,end);\n            invokeAll(a1,a2);\n        }\n    }\n}','Executors',0,0,NULL,5),(3427,'RecursiveTask<V> returns a value\n\nfor this particular example you should initialize the array with random \nnumber using RandomInitRecursiveAction that doesn\'t return a result. \n\npublic static void main(String[] args) {\n        int[] bigdata = new int[20000];\n        ForkJoinPool fj = new ForkJoinPool();\n        FindMaxPosition fmp = new FindMaxPosition(bigdata,0,bigdata.length);\n        Integer i = fj.invoke(fmp);\n        \n    }','class FindMaxPosition extends RecursiveTask<Integer> {\n     private static final int THRESHOLD = 10000;\n    private int[] data;\n    private int start;\n    private int end;\n    \n    public FindMaxPosition(int[] data, int start, int end) {\n        this.data = data;\n        this.start = start;\n        this.end = end;\n    }\n    \n    public Integer compute() {\n        if (end - start <= THRESHOLD){\n            int position = 0;\n            for(int i = start; i < end; i++){\n                 if(data[i] > data[position]) {\n                     position = i;\n                 }\n            }\n            \n            return position;\n        } else { //task is too big, split it\n            int halfway = ((end - start) / 2) + start;\n            FindMaxPosition p1 = new FindMaxPosition(data,start,halfway);\n            p1.fork();\n            FindMaxPosition p2 = new FindMaxPosition(data,start,halfway);\n            int pos2 = p2.compute();\n            int pos1 = p1.join();\n            \n            //these forked tasks found the greatest value in their subsections now compare the two results \n            \n            if(data[pos1] > data[pos2]) {\n                return pos1;\n            } else if(data[pos1] < data[pos2]){\n                return pos2;\n            } else {\n                return pos1 < pos2 ? pos1 : pos2;\n            }\n        }\n        \n    }\n}','Executors',0,0,NULL,5),(3428,'This will create an array of 10000000 elements then, find the biggest value in it\n','public class Hello{\n    public static void main(String[]  args){\n        int[] data = new int[10_000_000];\n        ForkJoinPool fjpool = new ForkJoinPool();\n        RandomInitRA ra = new RandomInitRA(data,0,data.length);\n        fjpool.invoke(ra);\n        \n        FindMaxPosition task = new FindMaxPosition(data,0,data.length);\n        Integer position = fjpool.invoke(task);\n        System.out.println(\"Bigggest value:;\"+ data[position]);\n    }\n}\n\nclass FindMaxPosition extends RecursiveTask<Integer> {\n     private static final int THRESHOLD = 10000;\n    private int[] data;\n    private int start;\n    private int end;\n    \n    public FindMaxPosition(int[] data, int start, int end) {\n        this.data = data;\n        this.start = start;\n        this.end = end;\n    }\n    \n    public Integer compute() {\n        if (end - start <= THRESHOLD){\n            int position = 0;\n            for(int i = start; i < end; i++){\n                 if(data[i] > data[position]) {\n                     position = i;\n                 }\n            }\n            \n            return position;\n        } else { //task is too big, split it\n            int halfway = ((end - start) / 2) + start;\n            FindMaxPosition p1 = new FindMaxPosition(data,start,halfway);\n            p1.fork();\n            FindMaxPosition p2 = new FindMaxPosition(data,start,halfway);\n            int pos2 = p2.compute();\n            int pos1 = p1.join();\n            \n            //these forked tasks found the greatest value in their subsections now compare the two results \n            \n            if(data[pos1] > data[pos2]) {\n                return pos1;\n            } else if(data[pos1] < data[pos2]){\n                return pos2;\n            } else {\n                return pos1 < pos2 ? pos1 : pos2;\n            }\n        }\n        \n    }\n}\n \nclass RandomInitRA extends RecursiveAction {\n    private static final int THRESHOLD = 10000;\n    private int[] data;\n    private int start;\n    private int end;\n    \n    public RandomInitRA(int[] data, int start, int end) {\n        this.data = data;\n        this.start = start;\n        this.end = end;\n    }\n    \n    protected void compute() {\n        if(end - start <= THRESHOLD) {\n            // if this is a manageable amount of work do the task\n            for(int i = start; i<end; i++){\n                data[i] = ThreadLocalRandom.current().nextInt();\n            }\n        } else { //task too big\n            int halfway = ((end - start) / 2) + start;\n            RandomInitRA a1 = new RandomInitRA(data,start,halfway);\n            RandomInitRA a2 = new RandomInitRA(data,halfway,end);\n            invokeAll(a1,a2);\n        }\n    }\n}','Executors',0,0,NULL,5),(3429,'ages.remove(\"John\",23);\n\npublic boolean remove(Object key,\n             Object value)\n\nRemoves the entry for a key only if currently mapped to a given value. This is equivalent to\n\n   if (map.containsKey(key) && map.get(key).equals(value)) {\n       map.remove(key);\n       return true;\n   } else return false;\n\nexcept that the action is performed ATOMICALLY.\n\nThere is another remove method that comes from the map Interface...\nthat is the standard remove function.\n\npublic V remove(Object key)\n\nRemoves the key (and its corresponding value) from this map. This method does nothing if the key is not in the map.\n\nSpecified by:\n    remove in interface Map<K,V>\nOverrides:\n    remove in class AbstractMap<K,V>\nParameters:\n    key - the key that needs to be removed\nReturns:\n    the previous value associated with key, or null if there was no mapping for key','ConcurrentMap<String,Integer> ages = new ConcurrentHashMap<>();\nages.put(\"John\",23);\n\nWhich method would delete Joh from the map only if his value was still equal \nto 23','Concurrency',0,0,NULL,5),(3430,'i.addAndGet(9);\ni.getAndAdd(9);','AtomicInteger i = new AtomicInteger();\ntwo methods to atomically increment by 9?','Concurrency',0,0,NULL,5),(3431,'only one thread at a time can access the write lock where multiple threads\ncan access the readLock','class LeaderBoard {\n    private ReadWriteLock rwl = new ReentrantReadWriteLock();\n    private List<Integer> highScores = new ArrayList<Integer>();\n    public void addScore(Integer score){\n        Lock lock = rwl.writeLock();\n        lock.lock();\n        \n        try{\n            if(highScores.size() < 10) {\n                highScores.add(score);\n            } else if(highScores.get(highScores.size() - 1) < score) {\n                highScores.set(highScores.size() - 1, score);\n            } else {\n                return;\n            }\n            \n            Collections.sort(highScores,Collections.reverseOrder());\n        } finally{\n            lock.unlock();\n        }\n    }\n    \n    public List getHighScores(){\n        Lock lock = rwl.readLock();\n        lock.lock();\n        try{\n            return Collections.unmodifiableList(highScores);\n        } finally {\n            lock.unlock();\n        }\n    }\n}','Concurrency',0,0,NULL,5),(3432,'IllegalMonitorStateExcetion rwl.writeLock() was not locked before it was unloked\n','public class Hello {\n\n    public static void main(String[] args) {\n       LeaderBoard lb = new LeaderBoard();\n       lb.addScore(56);\n    }\n    \n}\n\nclass LeaderBoard {\n    private ReadWriteLock rwl = new ReentrantReadWriteLock();\n    private List<Integer> highScores = new ArrayList<Integer>();\n    public void addScore(Integer score){\n        Lock lock = rwl.writeLock();\n        \n        try{\n            if(highScores.size() < 10) {\n                highScores.add(score);\n            } else if(highScores.get(highScores.size() - 1) < score) {\n                highScores.set(highScores.size() - 1, score);\n            } else {\n                return;\n            }\n            \n            Collections.sort(highScores,Collections.reverseOrder());\n        } finally{\n            lock.unlock();\n        }\n    }\n    \n    public List getHighScores(){\n        Lock lock = rwl.readLock();\n        lock.lock();\n        try{\n            return Collections.unmodifiableList(highScores);\n        } finally {\n            lock.unlock();\n        }\n    }\n}','Concurrency',0,0,NULL,5),(3433,'compiles fine, The writeLock is locked but never unlocked,that will not throw\nan exception.','public class Hello {\n\n    public static void main(String[] args) {\n       LeaderBoard lb = new LeaderBoard();\n       lb.addScore(5);\n    }\n    \n}\n\nclass LeaderBoard {\n    private ReadWriteLock rwl = new ReentrantReadWriteLock();\n    private List<Integer> highScores = new ArrayList<Integer>();\n    public void addScore(Integer score){\n        Lock lock = rwl.writeLock();\n        lock.lock();\n        try{\n            if(highScores.size() < 10) {\n                highScores.add(score);\n            } else if(highScores.get(highScores.size() - 1) < score) {\n                highScores.set(highScores.size() - 1, score);\n            } else {\n                return;\n            }\n            \n            Collections.sort(highScores,Collections.reverseOrder());\n        } finally{\n\n        }\n    }\n    \n    public List getHighScores(){\n        Lock lock = rwl.readLock();\n        lock.lock();\n        try{\n            return Collections.unmodifiableList(highScores);\n        } finally {\n            lock.unlock();\n        }\n    }\n}','Concurrency',0,0,NULL,5),(3434,'Thread-0 []\nThread-2 []\nThread-1 []\n... and will keep running\n\nsince the readlock is never unlocked() in getHighScores() the three threads will\nacquire the read lock but never release it. \n\nThat will prevent any of them from getting the write lock. RRWL allows multiple\nthreads to read at the same time but will wait for an exclusive lock before\nallowing threads to write to it. meaning no other thread can be reading while\nanother thread is writing to the locked object!','public class Hello {\n\n    public static void main(String[] args) {\n       LeaderBoard lb = new LeaderBoard();\n       Player a = new Player(lb);\n       Player b = new Player(lb);\n       Player c = new Player(lb);\n       \n       a.start();\n       b.start();\n       c.start();\n    }\n    \n}\n\nclass LeaderBoard {\n    private ReadWriteLock rwl = new ReentrantReadWriteLock();\n    private List<Integer> highScores = new ArrayList<Integer>();\n    public void addScore(Integer score){\n        Lock lock = rwl.writeLock();\n        lock.lock();\n        try{\n            if(highScores.size() < 10) {\n                highScores.add(score);\n            } else if(highScores.get(highScores.size() - 1) < score) {\n                highScores.set(highScores.size() - 1, score);\n            } else {\n                return;\n            }\n            \n            Collections.sort(highScores,Collections.reverseOrder());\n        } finally{\n            lock.unlock();\n        }\n    }\n    \n    public List getHighScores(){\n        Lock lock = rwl.readLock();\n        lock.lock();\n        try{\n            return Collections.unmodifiableList(highScores);\n        } finally {\n\n        }\n    }\n}\n\nclass Player extends Thread {\n    private LeaderBoard lb;\n    public Player(LeaderBoard x){\n        lb = x;\n        \n    }\n    public void run(){\n        System.out.println(Thread.currentThread().getName()+\" \"+lb.getHighScores());\n        for(int i = 0; i<3; i++){\n            postHighScore();\n        }    \n    }\n    \n    public void postHighScore(){\n        lb.addScore(ThreadLocalRandom.current().nextInt());\n    }\n}\n','Concurrency',0,0,NULL,5),(3435,'\n\nFirst, InputStreamReader can handle all input streams, not just files. Other examples are network connections, classpath resources and ZIP files.\n\nSecond, FileReader does not allow you to specify an encoding and instead uses the plaform default encoding, which makes it pretty much useless as using it will result in corrupted data when the code is run on systems with different platform default encodings.\n\nIn short, forget that FileReader exists.\n','I can\'t seem to determine any difference between InputStreamReader and FileReader besides the way the two are initialized. \nIs there any benefit to using one or the other? \nMost other articles cover FileInputStream vs InputStreamReader, but I am contrasting with FileReader instead. \nSeems to me they both have the same purpose.','General',0,0,NULL,5),(3436,'-This is impossible to do.\n The reason to not include it, is the wide range of input types it supports. One example is streams. These don\'t store the results after they have been passed on,\n so they don\'t support resetting.\n So the elegant way is to create a new Scanner. \n If you give it many custom settings, create a factory method.\n\n-There is no \"counter\" in the Scanner object. \n Instead think of it as more like a conveyor belt. \n The belt has no knowledge or care about what\'s on it. \n It just keeps spitting things out at you while there are items left on it. \n And once you take them, they\'re gone from it for good.\n','while (scanNumOfLines.hasNextLine())    \n    {\n    NumOfLines ++;\n    scanNumOfLines.nextLine();\n    }\n    System.out.println(\"NumOfLines = \"+NumOfLines);\n\nSo it counts fine, but I want to re-use the scanner for another purpose, but the nextLine has moved to the last line of the file, and I want to reset it back to the first line.\n\n(Instead, I had to use another scanner for the other purpose, and to me this seems less elegant than it should be.)\n\nI\'m sure there must be a scanner method that resets the counter to zero?','General',0,0,NULL,5),(3437,'- \n\nAs a formal method parameter is a local variable, you can access them from inner anonymous classes only if they are declared as final.\n\nThis saves you from declaring another local final variable in the method body:\n\n void m(final int param) {\n        new Thread(new Runnable() {\n            public void run() {\n                System.err.println(param);\n            }\n        }).start();\n    }\n\n\n\n\n- final is used here to ensure the two indexes i and j won\'t accidentally be reset by the method. It\'s a handy way to protect against an insidious bug that erroneously changes the value of your parameters. \nGenerally speaking, short methods are a better way to protect from this class of errors,\nbut final parameters can be a useful addition to your coding style.\nNote that final parameters are not considered part of the method signature, and are ignored by the compiler when resolving method calls. Parameters can be declared final (or not) with no influence on how the method is overriden.\n\n-Might be better to use objects rather than primitives for this example, as primitive changes will always only be visible inside the method. \nAnd in the case of objects, you can still change them. You just can\'t point at a new object. In fact now I think about it, final doesn\'t really change anything \ncompared to leaving it out, other than saving a variable declaration with AICs and having the compiler point out accidental modifications of parameters that \nyou didn\'t want to modify for some reason.\n\n\n\nThe final prevents you from assining a new value to the variable, and this can be helpful in catching typos. \nStylistically you might like to keep the parameters received unchanged and assign only to local variables, \nso final would help to enforce that style.\n\npublic int example(final int basicRate){\n    int discountRate;\n\n    discountRate = basicRate - 10;\n    // ... lots of code here \n    if ( isGoldCustomer ) {\n        basicRate--;  // typo, we intended to say discountRate--, final catches this\n    }\n    // ... more code here\n\n    return discountRate;\n}\n\n','What difference that final makes between the code below. Is there any advantage in declaring the arguments as final.\n\npublic String changeTimezone( Timestamp stamp, Timezone fTz, Timezone toTz){  \n    return ....\n}\n\npublic String changeTimezone(final Timestamp stamp, final Timezone fTz, \n        final Timezone toTz){\n    return ....\n}\n\n','General',0,0,NULL,5),(3438,'compiles fine','abstract class A {\n    public abstract void foo(final String s);\n}\n\nclass B extends A {\n    public void foo(String x){\n        System.out.println(x);\n    }\n}','General',0,0,NULL,5),(3439,'only the first,\n\nthe only argument constructor for cachedthreadpool takes a threadfactory.\n\na fixed thread pool has to have a size.','Executor ex = Executors.newFixedThreadPool(9);\nExecutor ex2 = Executors.newFixedThreadPool();\nExecutor ex3 = Executor.newFixedThreadPool(9);\nExecutor ex4 = Executors.newCachedThreadPool(7);\n\nwhich can compile ?','Executors',0,0,NULL,5),(3440,'will not compile, unreported exception ExecutionException thrown by .get()','private Integer executeTask (ExecutorService service, Callable<Integer> task){\n        try{\n            Future<Integer> future = service.submit(task);\n            return future.get();\n        } catch(InterruptedException e){\n            return null;\n        }\n    }','Executors',0,0,NULL,5),(3441,'will not compile, unreported Exeption InterruptedException thrown by .get()\n\nshould be :\n\n	catch(ExecutionException | InterruptedException e){\n            return null;\n        }','private Integer executeTask (ExecutorService service, Callable<Integer> task){\n        try{\n            Future<Integer> future = service.submit(task);\n            return future.get();\n        } catch(ExecutionException e){\n            return null;\n        }\n    }','Executors',0,0,NULL,5),(3442,'will execute the submitted task\n\nfuture.get() will block until the activity is done.',' private Integer executeTask (ExecutorService service, Callable<Integer> task){\n        try{\n            Future<Integer> future = service.submit(task);\n            return future.get();\n        } catch(InterruptedException | ExecutionException e){\n            return null;\n        }\n    }','Executors',0,0,NULL,5),(3443,'try{\n	Future<Integer> future = service.submit(task);\n	return future.get();\n} catch(InterruptedException | ExecutionException e){\n   	return null;\n}\n\nor ...\n\ntry{\n	Future<Integer> future = service.submit(task);\n	return future.get();\n} catch(Exception e){\n   	return null;\n}\n\n.get() will block until a result is available',' private Integer executeTask (ExecutorService service, Callable<Integer> task){\n        // insert code \n    }\n\nwhat code could you insert here to execute the task using the service','Executors',0,0,NULL,5),(3444,'FALSE, A Callable<E> can do that a runnable cannot do either of those things.','A runnable can return a result and throw an exception','Executors',0,1,NULL,5),(3445,'1 and 5\n\nWhen creating multiple forkjointask instances all tasks except one shuld be forked\nfirst so that they can be picked up by other forkjoin worker threads.\nThe final task should then be executed within the same thread by calling compute()\nbefore calling join on all the forked threads to await their results. \n\ncallin methods in the wrong order will not cause compiler error so care must be taken','With RecursiveTask subclasses which are true ?\n\n1.fork() and join() should be called on the same task.\n2.fork() and compute() should be called on the same task.\n3.compute() and join() should be called on the same task.\n4.compute() should be called before fork()\n5.fork() should be called before compute()\n6.join() should be called after fork() but before compute()','Concurrency',0,0,NULL,5),(3446,'55','public class Hello {\n\n    public static void main(String[] args) {\n        Fibonacci fibonacci = new Fibonacci(10);\n        ForkJoinPool pool = new ForkJoinPool();\n        System.out.println(pool.invoke(fibonacci));\n    }\n}\n\nclass Fibonacci extends RecursiveTask<Long> {\n    final long n;\n    \n    Fibonacci(long n) {\n        this.n = n;\n    }\n    \n    public Long compute() {\n        if (n<=10) {\n            return do_fibonacci(n);\n        }\n        ForkJoinTask<Long> subTask = new Fibonacci(n-1).fork();\n        return new Fibonacci(n-2).compute() + subTask.join();\n    }\n    \n    static long do_fibonacci(long n) {\n        if ( n<=1 ) return n;\n        return do_fibonacci(n-1) + do_fibonacci(n-2);\n    }\n}','Concurrency',0,0,NULL,5),(3447,'55, join() returns the result of the forked procedure. \n\nfork() and join() should be called on the same, Task','public class Hello {\n\n    public static void main(String[] args) {\n        Fibonacci fibonacci = new Fibonacci(10);\n        ForkJoinPool pool = new ForkJoinPool();\n        System.out.println(pool.invoke(fibonacci));\n    }\n}\n\nclass Fibonacci extends RecursiveTask<Long> {\n    final long n;\n    \n    Fibonacci(long n) {\n        this.n = n;\n    }\n    \n    public Long compute() {\n        if (n<=10) {\n            return do_fibonacci(n);\n        }\n        //ForkJoinTask<Long> subTask = new Fibonacci(n-1).fork();\n        //return new Fibonacci(n-2).compute() + subTask.join();\n        //same as ...\n        ForkJoinTask<Long> f1 = new Fibonacci(n-1);\n        Fibonacci f2 = new Fibonacci(n-2);\n        f1.fork();\n        Long l1 = f2.compute();\n        Long l2 = f1.join();\n        return l1+l2;\n    }\n    \n    static long do_fibonacci(long n) {\n        if ( n<=1 ) return n;\n        return do_fibonacci(n-1) + do_fibonacci(n-2);\n    }\n}','Concurrency',0,0,NULL,5),(3448,'Polymorphism bites you in the ass here again,\nclass Fibonacci has a compute method not FJT','class Fibonacci extends RecursiveTask<Long> {\n    final long n;\n    \n    Fibonacci(long n) {\n        this.n = n;\n    }\n    \n    public Long compute() {\n        if (n<=10) {\n            return do_fibonacci(n);\n        }\n        //ForkJoinTask<Long> subTask = new Fibonacci(n-1).fork();\n        //return new Fibonacci(n-2).compute() + subTask.join();\n        //same as ...\n        ForkJoinTask<Long> f1 = new Fibonacci(n-1);\n        ForkJoinTask<Long> f2 = new Fibonacci(n-2);\n        f1.fork();\n        Long l1 = f2.compute();\n        Long l2 = f1.join();\n        return l1+l2;\n    }\n    \n    static long do_fibonacci(long n) {\n        if ( n<=1 ) return n;\n        return do_fibonacci(n-1) + do_fibonacci(n-2);\n    }\n}','Concurrency',0,0,NULL,5),(3449,'type fibonacci does not take parameters','public class Hello {\n\n    public static void main(String[] args) {\n        Fibonacci fibonacci = new Fibonacci(10);\n        ForkJoinPool pool = new ForkJoinPool();\n        System.out.println(pool.invoke(fibonacci));\n    }\n}\n\nclass Fibonacci extends RecursiveTask<Long> {\n    final long n;\n    \n    Fibonacci(long n) {\n        this.n = n;\n    }\n    \n    public Long compute() {\n        if (n<=10) {\n            return do_fibonacci(n);\n        }\n        //ForkJoinTask<Long> subTask = new Fibonacci(n-1).fork();\n        //return new Fibonacci(n-2).compute() + subTask.join();\n        //same as ...\n        ForkJoinTask<Long> f1 = new Fibonacci(n-1);\n        Fibonacci<Long> f2 = new Fibonacci(n-2);\n        f1.fork();\n        Long l1 = f2.compute();\n        Long l2 = f1.join();\n        return l1+l2;\n    }\n    \n    static long do_fibonacci(long n) {\n        if ( n<=1 ) return n;\n        return do_fibonacci(n-1) + do_fibonacci(n-2);\n    }\n}','General',0,0,NULL,5),(3450,'this program will never complete subtask is never forked so using join() will \nnever be able to return a result and it will block forever. \n\nto fix \n\nsubtask.fork();\n\n	ForkJoinTask<Long> subTask = new Fibonacci(n-1).fork();\n        ret = new Fibonacci(n-2).compute() + subTask.join();\n        result[(int)n] = new Long(ret);\n        return ret;','public class Hello {\n\n    public static void main(String[] args) {\n         Fibonacci fibonacci = new Fibonacci(15);\n         ForkJoinPool pool = new ForkJoinPool();\n         System.out.println(pool.invoke(fibonacci));\n    }\n}\n\n\nclass Fibonacci extends RecursiveTask<Long> {\n    final long n;\n    public static Long[] result = new Long[2];\n    public static int max_num = 1;\n    \n    public static void set_max(int num) {\n        result[0] = new Long(1);\n        result[1] = new Long(1);\n        if ( num > max_num ) {\n            Long[] new_result = new Long[num+1];\n            \n            for (int i=0; i<=max_num; i++) {\n                new_result[i] = result[i];\n            }\n            \n            result = new_result;\n            \n            for (int i=max_num+1; i<=num; i++) {\n                result[i] = new Long(0);\n            }\n            max_num = num;            \n        }\n    }\n    \n    Fibonacci(long n) {\n        this.n = n;\n        if ( n > 1 )\n            set_max((int)n);\n    }\n        \n    public Long compute() {\n        Long ret;\n        if ( result[(int)n].longValue() != 0 ) {\n            return result[(int)n];\n        }\n        if (n<=10) {\n            return do_fibonacci(n);\n        }\n        ForkJoinTask<Long> subTask = new Fibonacci(n-1);\n        ret = new Fibonacci(n-2).compute() + subTask.join();\n        result[(int)n] = new Long(ret);\n        return ret;\n    }\n    \n    static long do_fibonacci(long n) {\n        long ret;\n        if (result[(int)n].longValue() != 0) {\n            ret = result[(int)n].longValue();\n        } else {\n            long ret_n_1 = do_fibonacci(n-1);\n            long ret_n_2 = do_fibonacci(n-2);\n            ret = ret_n_1 + ret_n_2;\n            result[(int)n] = new Long(ret);\n        }\n        return ret;\n    }\n}','General',0,0,NULL,5),(3451,'will wait forever a subtask has to be fork()ed before it can rejoin the \nmain task. ','public class Hello {\n\n    public static void main(String[] args) {\n         Fibonacci fibonacci = new Fibonacci(15);\n         ForkJoinPool pool = new ForkJoinPool();\n         System.out.println(pool.invoke(fibonacci));\n    }\n}\n\n\nclass Fibonacci extends RecursiveTask<Long> {\n    final long n;\n    public static Long[] result = new Long[2];\n    public static int max_num = 1;\n    \n    public static void set_max(int num) {\n        result[0] = new Long(1);\n        result[1] = new Long(1);\n        if ( num > max_num ) {\n            Long[] new_result = new Long[num+1];\n            \n            for (int i=0; i<=max_num; i++) {\n                new_result[i] = result[i];\n            }\n            \n            result = new_result;\n            \n            for (int i=max_num+1; i<=num; i++) {\n                result[i] = new Long(0);\n            }\n            max_num = num;            \n        }\n    }\n    \n    Fibonacci(long n) {\n        this.n = n;\n        if ( n > 1 )\n            set_max((int)n);\n    }\n        \n    public Long compute() {\n        Long ret;\n        if ( result[(int)n].longValue() != 0 ) {\n            return result[(int)n];\n        }\n        if (n<=10) {\n            return do_fibonacci(n);\n        }\n        ForkJoinTask<Long> subTask = new Fibonacci(n-1);\n        ret = new Fibonacci(n-2).compute() + subTask.join();\n        subTask.fork();\n        result[(int)n] = new Long(ret);\n        return ret;\n    }\n    \n    static long do_fibonacci(long n) {\n        long ret;\n        if (result[(int)n].longValue() != 0) {\n            ret = result[(int)n].longValue();\n        } else {\n            long ret_n_1 = do_fibonacci(n-1);\n            long ret_n_2 = do_fibonacci(n-2);\n            ret = ret_n_1 + ret_n_2;\n            result[(int)n] = new Long(ret);\n        }\n        return ret;\n    }\n}','General',0,0,NULL,5),(3452,'This is the same behavior of your typical ReadWriteLock usage case if there\n is available data for reading. If no data exists, then a reader becomes a\n \"writer\" (in the lock sense) and waits until some data is available. The \ncycle repeats until some available data is returned (or until an interrupt \noccurs).\n\nSince you\'re using a ReadWriteLock, it means you\'re expecting a much \ngreater number of reads than writes and so you chose a lock that minimizes \ncontention between reader threads (the readLock).\n\nThe method waitForData() turns readers into \"writers\" because they lock on\n the writeLock instead, resulting in an increased contention between all\n threads (readers and writers). However, since writes are assumed to be \nmuch rarer than reads, a situation where data keeps toggling fast \nbetween \"available\" and \"unavailable\" is not expected. In other words, \nassuming writes are rare:\n\n    If there is no available data for reading, then virtually all readers\n will typically block in the method waitForData() after some time, and\n will all be notified at the same time when some new data is written.\n\n    If there is some available data for reading, then all readers will\n simply read it without creating any contention among the threads when \nlocking the readLock.\n','private final ReentrantReadWriteLock    rwl         = new ReentrantReadWriteLock();\nprotected final Lock                    readLock    = rwl.readLock();\nprotected final Lock                    writeLock   = rwl.writeLock();\nprotected final Condition               hasData     = writeLock.newCondition();\n\n\npublic void write() {\n\n    writeLock.lock();\n    try {\n        // write data\n        // ...\n        if (something_written) {\n            hasData.signalAll();\n        }\n    }\n    finally {\n        writeLock.unlock();\n    }\n}\n\n// replace Object by something else\npublic Object read() throws InterruptedException {\n\n    Object data = tryRead();\n\n    while (data == null) {\n        waitForData();\n        data = tryRead();\n    }\n\n    return data;\n}\n\n// replace Object by something else\nprivate Object tryRead() {\n\n    readLock.lock();\n    try {\n        Object data = null;\n        // read data\n        // ...\n        // if there no data available, return null\n        return data;\n    }\n    finally {\n        readLock.unlock();\n    }\n}\n\nprivate void waitForData() throws InterruptedException {\n\n    writeLock.lock();\n    try {\n        boolean data_available = // check data\n        while (!data_available) {\n            hasData.await(1000L, TimeUnit.MILLISECONDS);\n            data_available = // check data\n        }\n    }\n    finally {\n        writeLock.unlock();\n    }\n}\n','Concurrency',0,0,NULL,5),(3453,'What this does is force your reader thread to sleep until some data is written by the writer thread .','private final ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();\nprotected final Lock readLock = rwl.readLock();\nprotected final Lock writeLock = rwl.writeLock();\nprotected final Condition hasData = writeLock.newCondition();\nprivate HashMap myData = new HashMap(); //example structure to read and write\n\nprivate final ReentrantLock dataArrivalLock = new ReentrantLock();\nprivate final Condition dataArrivalSignal = dataArrivalLock.newCondition();\n\nYour writer method pattern :\n\ntry {\n   writeLock.lock();    \n\n   //...\n   myData.put(\"foo\",\"ffoo\"); //write something !!\n   if( something_written ) {\n      hasData.signalAll();\n   }\n\n}\nfinally {\n   writeLock.unlock();\n}\n  try {\n                //signal other threads that data has been put in\n                dataArrivalLock.lock();\n                dataArrivalSignal.signalAll();\n\n            } finally {\n                dataArrivalLock.unlock();\n            }\n\nYour reader method pattern\n\ntry {\n            boolean gotData = false;\n            while (!gotData) {\n                try {\n                    readLock.lock();\n                    if (myData.size() > 0) {\n                        gotData = true;\n                        //retrieve the data that is written by writer thred!!\n                        myData.get(\"foo\");\n                    }\n                } finally {\n                    readLock.unlock();\n                }\n                if(!gotData) {\n //sleep the reader thread for x milliseconds. x depends on your application requirement\n                  //   Thread.sleep(250);\n                    try {\n                        //instead of Thread.sleep(), use the dataArrivalLock signal to wakeup\n                        dataArrivalLock.lock();\n                        dataArrivalSignal.await();\n                        //based on how the application works a timed wait might be better !!\n                        //dataArrivalSignal.await(250);\n                    } finally {\n                        dataArrivalLock.unlock();\n                    }\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        } ','Concurrency',0,0,NULL,5),(3454,'Read lock does not support Conditions so calling newCondition() will cause \nan UnsupportedOperationException','class CarRadio extends Thread {\n    \n    public void run(){\n      while(true){  \n        Song nextSong = DJ.spinNextTrack();\n        play(nextSong);\n        try{ Thread.sleep(2000); } catch(InterruptedException e) { }\n      }\n    }\n    public void play(Song song){\n        System.out.println(\"CarRadio: \"+song.getClip());\n    }\n    \n}\n\nclass DJ {\n    private final static LinkedList<Song> queue = new LinkedList<>();\n    private final static ReentrantReadWriteLock queueLock = new ReentrantReadWriteLock();\n    private final static Lock readLock = queueLock.readLock();\n    private final static Lock writeLock = queueLock.writeLock();\n    private final static Condition newSong = writeLock.newCondition();\n    private final static Condition readSong = readLock.newCondition();\n    private final static DJ INSTANCE = new DJ();\n    \n    private DJ(){\n\n    }\n    \n    public static DJ callDJ(){\n        return INSTANCE;\n    }\n\n    public static Song spinNextTrack(){\n        readLock.lock();\n        try{\n            if(queue.isEmpty()){\n                try { newSong.await(); }catch(InterruptedException e) { }\n            }\n            return queue.poll(); \n        } finally {\n            readLock.unlock();\n        }      \n    }\n\n    public static void addToQueue(Song song){\n        writeLock.lock();\n        try{\n            //this lock blocks until acquired\n            //queueLock.writeLock().lock();\n            queue.add(song);\n            newSong.signalAll();\n        } finally{\n            writeLock.unlock();\n        }\n    }\n}\n\nclass ConstantPop extends Thread {\n    private String[] sounds = {\" Lah \", \" La La \", \" Naaahh \", \" YOLO \" };\n    private static int songCounter = 0;\n    \n    public void run(){\n        while(true){\n            Song hotNewSong = studio();\n            DJ.addToQueue(hotNewSong);\n            try { Thread.sleep(2000); } catch(InterruptedException e) { }  \n        }\n    }\n    private Song studio(){\n        StringBuilder sb = new StringBuilder();\n        for(int i = 0; i<=3; i++){\n            sb.append(sounds[ThreadLocalRandom.current().nextInt(0,3)]);\n        }\n        songCounter++;\n        return new Song(\"PopSong.\"+songCounter,sb.toString());\n    }\n}','Concurrency',0,0,NULL,5),(3455,'Copy on write, because they mkae a new copy of the collection for each write.','Which Collection from java.util.concurrent is best when there are more reads\nthan writes','Concurrency',0,0,NULL,5),(3456,'putIfAbsent(K key, V value)\n\nremove(Object key, Object value)\n\nreplace(K key, V value)\n\nreplace(K key, V oldValue, V newValue)','ConcurrentSkipListMap and concurrentMap atomic methods','Concurrency',0,0,NULL,5),(3457,'a concrete class with static methods is used to create instances of objects \nthat implement an interface.','Factory patter:','Concurrency',0,0,NULL,5),(3458,'Factory,\n\nfactory is used to create instances of classes that implement an interface.\nCan be used at runtime to decide which object to create at runtime','what pattern ?\n\npublic interface Vehicle {\n	public void start();\n	public void stop();\n}\n\npublic class Car implements Vehicle {\n	public void start() { }\n	public void stop() { }\n}\n\npublic class CarManufacturer {\n	public static Vehicle getVehicle(String type) {\n		//create an instance of the type passed in\n	}\n}\n\nclass MyClass {\n	psmv(sa) {\n		Vehicle ferrari = CarManufacturer.getVehicle(\"Ferrari\");\n	\n		ferrari.start();\n	}\n}','Concurrency',0,0,NULL,5),(3459,'','for jdbc 3.0 drivers and earlier you are responsible for loading the class\nusing static forName(). Later driver classes are loaded automatically.','Concurrency',0,0,NULL,5),(3460,'10001\nGeorgi\nFacello\n10002\nBezalel\nSimmel\n10003\nParto\nBamford\n10004\nChirstian\nKoblick\n10005\nKyoichi\nMaliniak\n10006\nAnneke\nPreusig\n10007\nTzvetan\nZielinski\n10008\nSaniya\nKalloufi\n10009\nSumant\nPeac\n10010\nDuangkaew\nPiveteau','public class Hello {\n    public static void main(String[] args){\n        try {\n            Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\");\n            Statement st = conn.createStatement();\n            String query = \"Select * From employees limit 10\";\n            ResultSet rs = st.executeQuery(query);\n            while(rs.next()){\n                System.out.println(rs.getInt(\"emp_no\"));\n                System.out.println(rs.getString(\"first_name\"));\n                System.out.println(rs.getString(\"last_name\"));\n            } \n            \n        } catch(SQLException e){ }\n        \n    }\n}\n','Concurrency',0,0,NULL,5),(3461,'will not compile, executeUPdate returns an int of updated rows.','public class Hello {\n    public static void main(String[] args){\n        try {\n            Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\");\n            Statement st = conn.createStatement();\n            String update = \"update employee set emp_no = 11111 where first_name = Georgi\";\n            ResultSet rs = st.executeUpdate(update);\n            while(rs.next()){\n                System.out.println(rs.getInt(\"emp_no\"));\n                System.out.println(rs.getString(\"first_name\"));\n                System.out.println(rs.getString(\"last_name\"));\n            } \n            \n        } catch(SQLException e){ }\n        \n    }\n}','Concurrency',0,0,NULL,5),(3462,'execute(String sql) \n\nthe return value is true if the result is a result set and false if the \nquery is an update count or no results. \n\n','what jdbc method would you use when you are unsure of the result of a query\nor update','Concurrency',0,0,NULL,5),(3463,'false \n\nexecute returns true if it returns a result set and false for an update count','public class Hello {\n    public static void main(String[] args){\n        try {\n            Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\");\n            Statement st = conn.createStatement();\n            String update = \"Update employees Set first_name = \'Big John\' where first_name = \'Georgi\'\";\n            boolean b = st.execute(update);\n            System.out.println(b);\n        } catch(SQLException e){System.out.println(\"something went wrong\"); }\n        \n    }\n}','Concurrency',0,0,NULL,5),(3464,'if getUpdateCount() returns -1 then there were no results.','public class Hello {\n    public static void main(String[] args){\n        try {\n            Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\");\n            Statement st = conn.createStatement();\n            String update = \"Update employees Set first_name = \'Big John\' where first_name = \'Georgi\'\";\n            boolean b = st.execute(update);\n            if(b){\n                //ResultSet res = update.getResultSet();\n                ResultSet res = st.getResultSet();\n            } else {\n                int numrows = st.getUpdateCount();\n                if(numrows == -1){\n                    System.out.println(\"No Results\");\n                }\n            }\n        } catch(SQLException e){System.out.println(\"something went wrong\"); }\n        \n    }\n}','Concurrency',0,0,NULL,5),(3465,'will not compiles, getResultSet is from a statement object','public class Hello {\n    public static void main(String[] args){\n        try {\n            Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\");\n            Statement st = conn.createStatement();\n            String update = \"Update employees Set first_name = \'Big John\' where first_name = \'Georgi\'\";\n            boolean b = st.execute(update);\n            if(b){\n                ResultSet res = update.getResultSet();\n            } else {\n                int numrows = st.getUpdateCount();\n                if(numrows == -1){\n                    System.out.println(\"No Results\");\n                }\n            }\n        } catch(SQLException e){System.out.println(\"something went wrong\"); }\n        \n    }\n}','Concurrency',0,0,NULL,5),(3466,'something went wrong\n\nyou have to always call next() before processing a rown from a result set \nthe cursors starts out as before the first row.\n\nIt is a sqlexception to try to get a row when it is before the first row.','public class Hello {\n    public static void main(String[] args){\n        try {\n            Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\");\n            Statement st = conn.createStatement();\n            String update = \"Select first_name from employees\";\n            boolean b = st.execute(update);\n            if(b){\n                //ResultSet res = update.getResultSet();\n                ResultSet res = st.getResultSet();\n                System.out.println(res.getString(\"first_name\"));\n            } else {\n                int numrows = st.getUpdateCount();\n                if(numrows == -1){\n                    System.out.println(\"No Results\");\n                }\n            }\n            \n            \n        } catch(SQLException e){System.out.println(\"something went wrong\"); }\n        \n    }\n}','Concurrency',0,0,NULL,5),(3467,'Big John','public class Hello {\n    public static void main(String[] args){\n        try {\n            Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\");\n            Statement st = conn.createStatement();\n            String update = \"Select first_name from employees\";\n            boolean b = st.execute(update);\n            if(b){\n                //ResultSet res = update.getResultSet();\n                ResultSet res = st.getResultSet();\n                res.next();\n                System.out.println(res.getString(\"first_name\"));\n            } else {\n                int numrows = st.getUpdateCount();\n                if(numrows == -1){\n                    System.out.println(\"No Results\");\n                }\n            }\n            \n            \n        } catch(SQLException e){System.out.println(\"something went wrong\"); }\n        \n    }\n}\n','Concurrency',0,0,NULL,5),(3468,'SQLException invalid value for getInt()\n\nyour sql query only selected the firstnames, there are no other coluns to get\ninfo from. ','ublic class Hello {\n    public static void main(String[] args){\n        try {\n            Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\");\n            Statement st = conn.createStatement();\n            String update = \"Select first_name from employees\";\n            boolean b = st.execute(update);\n            if(b){\n                ResultSet res = st.getResultSet();\n                res.next();\n                System.out.println(res.getInt(1));\n                System.out.println(res.getDate(2));\n                System.out.println(res.getString(3));\n                \n            } else {\n                int numrows = st.getUpdateCount();\n                if(numrows == -1){\n                    System.out.println(\"No Results\");\n                }\n            }\n            \n            \n        } catch(SQLException e){System.out.println(e); }\n        \n    }\n}','JDBC',0,0,NULL,5),(3469,'run:\n10001\n1953-09-02\nBig John\nBUILD SUCCESSFUL (total time: 1 second)\n','public class Hello {\n    public static void main(String[] args){\n        try {\n            Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\");\n            Statement st = conn.createStatement();\n            String update = \"Select * from employees\";\n            boolean b = st.execute(update);\n            if(b){\n                ResultSet res = st.getResultSet();\n                res.next();\n                System.out.println(res.getInt(1));\n                System.out.println(res.getDate(2));\n                System.out.println(res.getString(3));\n                \n            } else {\n                int numrows = st.getUpdateCount();\n                if(numrows == -1){\n                    System.out.println(\"No Results\");\n                }\n            }\n            \n            \n        } catch(SQLException e){System.out.println(e); }\n        \n    }\n}','JDBC',0,0,NULL,5),(3470,'sql exception index out of range,\n\nindexs range from 1 to the size','public class Hello {\n    public static void main(String[] args){\n        try {\n            Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\");\n            Statement st = conn.createStatement();\n            String update = \"Select * from employees\";\n            boolean b = st.execute(update);\n            if(b){\n                ResultSet res = st.getResultSet();\n                res.next();\n                System.out.println(res.getInt(0));\n                System.out.println(res.getDate(1));\n                System.out.println(res.getString(2));\n                \n            } else {\n                int numrows = st.getUpdateCount();\n                if(numrows == -1){\n                    System.out.println(\"No Results\");\n                }\n            }\n            \n            \n        } catch(SQLException e){System.out.println(e); }\n        \n    }\n}','JDBC',0,0,NULL,5),(3471,'sqlexception, next() was not called before processing a result set','public class Hello {\n    public static void main(String[] args){\n        try {\n            Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\");\n            Statement st = conn.createStatement();\n            String update = \"Select * from employees\";\n            boolean b = st.execute(update);\n            if(b){\n                ResultSet res = st.getResultSet();\n                System.out.println(res.getInt(1));\n                System.out.println(res.getDate(2));\n                System.out.println(res.getString(3));\n                \n            } else {\n                int numrows = st.getUpdateCount();\n                if(numrows == -1){\n                    System.out.println(\"No Results\");\n                }\n            }\n            \n            \n        } catch(SQLException e){System.out.println(e); }\n        \n    }\n}\n','JDBC',0,0,NULL,5),(3472,'sql Date stores in the form yyyy mm dd','java.sql.Date extends java.util.Date\n\nwhats the main difference\n\njava.sql.Date pubDate = rs.getDate(\"PubDate\");','JDBC',0,0,NULL,5),(3473,'\"hh:mm:ss\"','java.sql.Time time = rs.getTime(\"FinishTime\");\n\nwhat form does this kind of Time take ?','JDBC',0,0,NULL,5),(3474,'','use getObject for a general purpose get()\n\njdbc will return a wrapper for the appropriate sql type.\n\nso a sql int would return integer\n\nObject o = rs.getObject(\"AuthorID\");\nif( o instanceof Integer){\n	//do\n}','JDBC',0,0,NULL,5),(3475,'String query = \"  \";\nResultSet res = stmt.executeQuery(query);\nReslutSetMetaData rsmd = rs.getMetaData();\nrs.next();\nint colCount = rsmd.getColumnCount();','How can you figure out the number of columns in a ResultSet ?','JDBC',0,0,NULL,5),(3476,'employees\nemp_no\n11\nemployees\nbirth_date\n10\nemployees\nfirst_name\n14\nemployees\nlast_name\n16\nemployees\ngender\n1\nemployees\nhire_date\n10','public class Hello {\n    public static void main(String[] args){\n        try {\n            Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\");\n            Statement st = conn.createStatement();\n            String q = \"Select * from employees\";\n            \n            ResultSet rs = st.executeQuery(q);\n            ResultSetMetaData rmd = rs.getMetaData();\n            int cols = rmd.getColumnCount();\n            \n            for(int i = 1; i <= cols; i++){\n                System.out.println(rmd.getTableName(i));\n                System.out.println(rmd.getColumnName(i));\n                System.out.println(rmd.getColumnDisplaySize(i));\n            } \n        } catch(SQLException e){System.out.println(e); }\n        \n    }\n}','JDBC',0,0,NULL,5),(3477,'First entry:\nMicheal Boyd\nLast entry:\nKenroku Malabarba\nrow: 20\nKyoichi Maliniak\nrow: 30\nGuoxiang Nooteboom','public class Hello {\n    public static void main(String[] args){\n        try {\n            Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\");\n            Statement st = conn.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE,ResultSet.CONCUR_READ_ONLY);\n            String q = \"Select * From employees limit 100\";\n            ResultSet rs = st.executeQuery(q);\n            \n            rs.first();\n            System.out.println(\"First entry:\");\n            System.out.println(rs.getString(\"first_name\") + \" \" +rs.getString(\"last_name\"));\n            \n            rs.last();\n            System.out.println(\"Last entry:\");\n            System.out.println(rs.getString(\"first_name\") + \" \" +rs.getString(\"last_name\"));\n            \n            rs.absolute(20);\n            System.out.println(\"row: \"+ rs.getRow());\n            System.out.println(rs.getString(\"first_name\") + \" \" +rs.getString(\"last_name\"));\n            \n            rs.relative(10);\n            System.out.println(\"row: \"+ rs.getRow());\n            System.out.println(rs.getString(\"first_name\") + \" \" +rs.getString(\"last_name\"));  \n        } catch(SQLException e){System.out.println(e); }\n        \n    }\n}','JDBC',0,0,NULL,5),(3478,'true','Once created you cannot change the concurrency or Cursor type of an existing\nstatement object.','JDBC',0,0,NULL,5),(3479,'','if cursor or concurrency settings are not supported then the driver will show\na warning and silently revert to default settings. ','JDBC',0,0,NULL,5),(3480,'what is b? :8\n','public class Hello {\n    public static void main(String[] args){\n       int a = 8;\n        System.out.println(\"what is b? :\"+a++);\n    }\n}','JDBC',0,0,NULL,5),(3481,'method local inner classes cannot access non final local variables,\n\nalso method local classes are just like local variables they cannot be \n	static private public protected or anything else','public class Hello {\n   \n    public static void main(String[] args) {\n        Hello h = new Hello();\n        h.methodlocal();\n    }\n    \n    public void methodlocal(){\n        int y = 56;\n        \n        private class Zombie {\n            public int size;\n        \n            public Zombie(int x){ size = x;}\n            public void mone(){\n                System.out.println(\"ughhhg: \"+ size);\n            }\n            \n            public void accessTheLiving(){\n                System.out.println(\"local var: \"+y);\n            }\n            \n        }\n        \n        Zombie zom = new Zombie(7);\n        \n    }\n\n}','JDBC',0,0,NULL,5),(3482,'compiles fine','public class Hello {\n    public static void main(String[] args){\n        List<Animal> animals = new ArrayList<Animal>();\n        animals.add(new Dog());\n        animals.add(new Animal());\n    }\n    public static void addAnimal(List<Object> animals) {\n	animals.add(new Dog());\n    }\n}\n\nclass Dog extends Animal {}\nclass Animal { }','JDBC',0,0,NULL,5),(3483,'will not compile, \n\nfirst you cant add to a collection defined with ? extends. \n\nsecond, since dest is defined with ? super it is saying that that collection\ncan be of any type of super class of G,thouhg you can still add only G. \n\nTherefore the iterator will return objects not Gs.\n\nYou are taking from dest and adding to src. dest is the producer and src is the\nconsumer. Producers extend Consumers Super. ITs backward here. ','public class Hello<T> {\n    \n    public static void main(String[] args){\n        ArrayList<Beagle> a = new ArrayList<>();\n        ArrayList<Animal> b = new ArrayList<>();\n        \n        Hello<String> x = new Hello<>();\n        \n        \n        \n        x.copyColl(a,b);\n        \n\n    } \n    public <G extends Being> void copyColl(Collection<? extends G> src, Collection<? super G> dest){\n        \n        for(G n : dest)\n            src.add(n);\n        \n    }\n}\n\nclass Beagle extends Animal { }\nclass Animal extends Being {} \nclass Being { }','Collections',0,0,NULL,5),(3484,'will not compile redwolf does not extend beagle','public class Hello<T> {\n    \n    public static void main(String[] args){\n        ArrayList<RedWolf> a = new ArrayList<>();\n        ArrayList<Animal> b = new ArrayList<>();\n        \n        Hello<String> x = new Hello<>();\n        \n        \n        \n        x.copyColl(a,b);\n        \n\n    } \n    public <G extends Beagle> void copyColl(Collection<? extends G> src, Collection<? super G> dest){\n        \n        for(G g : src)\n            dest.add(g);\n        \n    }\n}\n\n\nclass GoodBeagles extends Beagle { }\nclass Beagle extends Animal { }\nclass Animal extends Being {} \nclass Being { }\nclass Wolf { } \nclass RedWolf{ }','Collections',0,0,NULL,5),(3485,'shows the number of rows ','public class Hello {\n    public static void main(String[] dicks){\n         try {\n            Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\");\n            Statement st = conn.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_UPDATABLE);\n            String q = \"Select * from employees\";\n            ResultSet rs = st.executeQuery(q);\n            \n            if(rs.last()){\n               int rowCount = rs.getRow();\n               rs.beforeFirst();\n                System.out.println(rowCount);\n            }\n            \n            \n        } catch(SQLException e){System.out.println(e); }\n    }\n}','Collections',0,0,NULL,5),(3486,'91\n\nif absolute takes a - number it starts from the last row and works backward. \n\nreturns false if the cursor is beyond the lst row or beffore the first','public class Hello {\n    public static void main(String[] dicks){\n         try {\n            Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\");\n            Statement st = conn.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_UPDATABLE);\n            String q = \"Select * from employees limit 100\";\n            ResultSet rs = st.executeQuery(q);\n            rs.absolute(-10);\n             System.out.println(rs.getRow()); \n        } catch(SQLException e){System.out.println(e); }\n    }\n}','Collections',0,0,NULL,5),(3487,'Sachin Tsukuda','public class Hello extends Thread {\n    public static void main(String[] args){\n        try(Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees\", \"root\", \"Basketball12\")){\n            String getAllEmployeeNames = \"select first_name,last_name from employees\";\n            Statement st1 = conn.createStatement();\n            \n            ResultSet empnames = st1.executeQuery(getAllEmployeeNames);\n            \n            empnames.last();\n            \n            System.out.println(empnames.getString(\"first_name\")+\" \"+empnames.getString(\"last_name\"));\n            \n        }catch(SQLException e){\n            System.out.println(e);\n        }\n    }\n}','JDBC',0,0,NULL,5),(3488,'0','public class Hello {\n    public static void main(String[] dicks){\n         try {\n            Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\");\n            Statement st = conn.createStatement(ResultSet.TYPE_FORWARD_ONLY,ResultSet.CONCUR_UPDATABLE);\n            String q = \"Select * from employees limit 100\";\n            ResultSet rs = st.executeQuery(q);\n            System.out.println(rs.getRow()); \n        } catch(SQLException e){System.out.println(e); }\n    }\n}','JDBC',0,0,NULL,5),(3489,'also 0','public class Hello {\n    public static void main(String[] dicks){\n         try {\n            Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\");\n            Statement st = conn.createStatement(ResultSet.TYPE_FORWARD_ONLY,ResultSet.CONCUR_UPDATABLE);\n            String q = \"Select * from employees limit 100\";\n            ResultSet rs = st.executeQuery(q);\n            rs.afterLast();\n            System.out.println(rs.getRow()); \n        } catch(SQLException e){System.out.println(e); }\n    }\n}','JDBC',0,0,NULL,5),(3490,'run:\n0\njava.sql.SQLException: No operations allowed after statement closed.\nBUILD SUCCESSFUL (total time: 0 seconds)\n\nit is not an exception to call getRow after the last row or before the first.\nit will simply give zero. \n','public class Hello {\n    public static void main(String[] dicks){\n         try {\n            Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\");\n            Statement st = conn.createStatement(ResultSet.TYPE_FORWARD_ONLY,ResultSet.CONCUR_UPDATABLE);\n            String q = \"Select * from employees limit 100\";\n            String q2 = \"Select * from salaries limit 100\";\n            ResultSet rs = st.executeQuery(q);\n            rs.afterLast();\n            System.out.println(rs.getRow()); \n            conn.close();\n            rs = st.executeQuery(q2);\n            while(rs.next()){\n                System.out.println(rs.getInt(\"salary\"));\n            }\n        } catch(SQLException e){System.out.println(e); }\n    }\n}','JDBC',0,0,NULL,5),(3491,'0','public class Hello {\n    public static void main(String[] dicks){\n         try(Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\");\n            Statement st = conn.createStatement(ResultSet.TYPE_FORWARD_ONLY,ResultSet.CONCUR_UPDATABLE);) {\n            String q = \"Select * from employees limit 100\";\n            String q2 = \"Select * from salaries limit 100\";\n            ResultSet rs = st.executeQuery(q);\n            rs.afterLast();\n            System.out.println(rs.getRow()); \n        } catch(SQLException e){System.out.println(e); }\n    }\n}','JDBC',0,0,NULL,5),(3492,'Class.forName(\"org.abc.mmmysql.Driver\");','String url = \"   \";\nString user = \"  \";\nString pwd = \"    \";\n\n// insert here\nConnection conn = DriverManaget.getConnection(url,user,pwd);\n\nwhat would you use to load a JDBC 3.0 driver class','JDBC',0,0,NULL,5),(3493,'Must include a MEAT-INF file, this allows the driver to autoload.\n\nMust provide implementations of Driver, Connection, Statement, ResultSet\ninterfaces\n\nMust support transactions\n\n','What does it take for a driver to be jdbc 4.0 compliant ?	','JDBC',0,0,NULL,5),(3494,'3\n4\n6','What three are availabe through an instance of DatabaseMetaData ?\n\n1 number of columns returned\n2 number of rows returned\n3 name of jdbc driver\n4 default transaciton isolation level\n5 last query used\n6 names of stored procedures\n7 current Savepoint name','JDBC',0,0,NULL,5),(3495,'SQLException, next() wass not called the cursors starts of pointing to BEFORE\nthe first row. ','try {\n	Statement st = conn.createStatement();\n	String query = \"Select * From Author Where LastName Like \'Rand%\'\";\n	Resultset rs = st.executeQuery(query);\n	if(rs == null) {\n		sout( \"no results\" );\n	} else {\n		sout(rs.getString(\"FirstName\");\n	}\n} catch(SQLException se) {\n	sout(\"SQLException\");\n}','JDBC',0,0,NULL,5),(3496,'SQLException\n\nexecuteQuery cannot be used to execute update insrt delete or ddl statements \nor it will throw a sqlexception. \n','public class Hello {\n    public static void main(String[] dicks){\n         try(Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employee?useSSL=false\", \"root\", \"Basketball12\")){\n             String query = \"Update employees set first_name = \'Hefty\' where emp_no = 10001\"; \n             Statement st = conn.createStatement();\n             st.executeQuery(query);\n         } catch(SQLException e){\n             System.out.println(\"SQLException\");\n         }\n    }\n \n}','JDBC',0,0,NULL,5),(3497,'SQLException\n\ntrying to access a closed ResultSet. ','try {\n	ResultSet rs = null;\n	try (Statement st = conn.createStatement()) {\n		String query = \"Select * From Customer\";\n		rs = st.executeQuery(query);\n	} catch(SQLException se) {\n		sout(\"Illegal query\");	\n	}\n\n	while (rs.next()) {\n		//process customers \n	}\n} catch(SQLException e) {\n	sout(\"SQLException\");\n}','JDBC',0,0,NULL,5),(3498,'these would all produce their indicated rsults, update will produce and update count\neven if no rows are affected','Statement st = conn.createStatement();\nResultSet rs;\nString query = \"<QUERY HERE>\";\nst.execute(query);\nif ((Rs = st.getResultSet()) != null) {\n	sout(\"Results\");\n}\nif (st.getUpdateCount() > -1) {\n	sout(\"update\");\n}\n\nSelect * from customer\ninsert into ...\nupdate...\ndelete...','JDBC',0,0,NULL,5),(3499,'exception\n\nparameters are numbered starting from 1 not 0.','String q = \"update customer set Last_name = ? Where Customer_id = ?\";\ntry {\n	PreparedStatement pt = conn.prepareStatement(q);\n	pt.setString(0,\"Smith\");\n	pt.setString(1,\"5001\");\n	int result = pt.executeUpdate();\n	if(result != 1) sout(\"error\");\n} catch(SQLException e) {\n	sout(\"Exception\");\n}','JDBC',0,0,NULL,5),(3500,'yes yes sqlexception everything is smooth on the first iteration, but \nthe second the preparedstatement index paramenters will be 3 and 4 when there\nare only two parameters, this will cause the exc.','try {\n	String[] searchPair = {\"%a%\", \"%b%\",\"%c%\",\"%d%\" };\n	String query = \"Sleect ... ? ... ?\";\n	PreparedStatement pt = conn.PrepareStatement(query);\n	for(int i = 0; i < searchPair.length; i+=2) {\n		pt.setString(i+1, searchPAir[i]);\n		pt.setString(i+2, searchPair[i++]);\n		ResultSet rs = pt.executeQuery();\n		while(rs.next()) {\n			sout(\"yes\");\n		}\n	}\n} catch(Sqlexcepiton ee) {\n	sout	(\"SQLException\");\n}\n			','JDBC',0,0,NULL,5),(3501,'Collections of type ? can be assigned to by any type of list but cannot be\nadded to. ','public class Hello {\n    public static void main(String[] dicks){\n         List<?> list = new ArrayList<Dog>();\n         list.add(new Dog());\n         list.add(new Dog());\n         list.add(new Dog());\n    }\n \n}\n\nclass Dog {\n    \n}','Collections',0,0,NULL,5),(3502,'will not compile, object cannot be converted to Dog.\nThe objects comming out of a List<?> are Objects.','public class Hello {\n    public static void main(String[] dicks){\n         List<Dog> Doglist = new ArrayList<Dog>();\n         Doglist.add(new Dog(\"Charly\"));\n         Doglist.add(new Dog(\"Baily\"));\n         Doglist.add(new Dog(\"Wiley\"));\n         \n         List<?> unmodifiableDogList = Doglist;\n         \n         for(Dog d : unmodifiableDogList){\n             System.out.println(d.getName());\n         }\n    }\n \n}\n\nclass Dog {\n    private String name;\n    public Dog(String s ){\n        name = s;\n    }\n    \n    public String getName(){\n        return name;\n    }\n    \n}','Collections',0,0,NULL,5),(3503,'althought the base type here is ArrayList Doglist is defined as a list \nso it cannot be assigned to an ArrayList ','public class Hello {\n    public static void main(String[] dicks){\n         List<Dog> Doglist = new ArrayList<Dog>();\n         Doglist.add(new Dog(\"Charly\"));\n         Doglist.add(new Dog(\"Baily\"));\n         Doglist.add(new Dog(\"Wiley\"));\n         \n         ArrayList<?> unmodifiableDogList = Doglist;\n         \n         for(Object d : unmodifiableDogList){\n             System.out.println(d.getName());\n         }\n    }\n \n}\n\nclass Dog {\n    private String name;\n    public Dog(String s ){\n        name = s;\n    }\n    \n    public String getName(){\n        return name;\n    }\n    \n}','Collections',0,0,NULL,5),(3504,'compiles fine the reference type is still defined as a raw type','public class Hello<T> {\n    public static void main(String[] args){\n        \n        Dog d = new Dog();\n        \n        ArrayList x = makeArrayList(d);\n        \n        ArrayList c = new ArrayList<String>();\n        c.add(new Dog());\n        c.add(90);\n\n    } \n    public static <G> ArrayList<G> makeArrayList(G g){\n        ArrayList<G> genlist = new ArrayList();\n        genlist.add(g);\n        return genlist;\n        \n    }\n}\n\nclass Dog {\n    \n}','Collections',0,0,NULL,5),(3505,'will not compile, all those methods throw IOExceptions','public class Hello {\n    public static void main(String[] args){\n       File file1 = new File(\"~/Public/TestDir/file1\");\n       File file2 = new File(\"~/Public/TestDir/file2\");\n       File dir = new File(\"~/Public/TestDir\");\n       \n       if(dir.exists() && dir.isDirectory()){\n           file1.createNewFile();\n           file2.createNewFile();\n       } else {\n           dir.mkdir();\n           file1.createNewFile();\n           file2.createNewFile();\n       }\n    } \n}','IO',0,0,NULL,5),(3506,'fine','public class Hello<T> {\n    \n    public static void main(String[] args){\n        \n        Dog d = new Dog();\n        \n        ArrayList<? extends Dog> c = new ArrayList<Beagle>();\n        Animal a = c.get(0);\n    } \n}\n\nclass Animal{}\nclass Dog extends Animal { }\nclass Beagle extends Dog { }','Generics',0,0,NULL,5),(3507,'will not compile wrong number of type arguments, \nthis is a generic method, \n\nit should be <? extends Animal>','public class Hello<T> {\n    \n    public static void main(String[] args){\n        ArrayList<Animal> a;\n        ArrayList<Beagle> b;\n        \n        Hello<String> x = new Hello<>();\n        \n        x.copyColl(a,b);\n        \n\n    } \n    public <G> void copyColl(Collection<G extends Animal> src, Collection<G> dest){\n        \n        for(G n : src)\n            dest.add(n);\n        \n    }\n}\n\nclass Animal{}\nclass Dog extends Animal { }\nclass Beagle extends Dog { }','Generics',0,0,NULL,5),(3508,'in java 7 and beyond the compiler can infer the type from the return type !','public class Hello<T> {\n    \n    public static void main(String[] args) {\n        Cat cat = parse(\"cat\");\n        Dog dog = parse(\"dog\");\n        System.out.println(\"the cat object is a \" + cat);\n        System.out.println(\"the dog object is a \" + dog);\n    }\n\n    private static class Dog {\n        public String toString() { return \"dog\"; }\n    }\n\n    private static class Cat {\n        public String toString() { return \"cat\"; }\n    }\n\n    private static Object untypedParse(String stringToParse) {\n        if(stringToParse.equals(\"dog\")) {\n            return new Dog();\n        } else if(stringToParse.equals(\"cat\")) {\n            return new Cat();\n        } else {\n            throw new RuntimeException(\"not expected\");\n        }\n    }\n\n    public static <T> T parse(String stringToParse) {\n        return (T)untypedParse(stringToParse);\n    }\n\n}','Generics',0,0,NULL,5),(3509,'First it should be: public static <T> T fromXML<T>(String xml)\n\nIn Java, generics are compile-time only data, which are lost at run time. \nSo, if you called a method like that, the JVM would have no way of knowing what T.class was. \nThe normal way to get around this is to pass a class instance object as a parameter to the method, \nlike this:\n\npublic static <T> T fromXml(Class<T> clazz, String xml) {\n  try {\n    JAXBContext context = JAXBContext.newInstance(clazz);\n    Unmarshaller um = context.createUnmarshaller();\n    return (T)um.unmarshal(new StringReader(xml));\n  } catch (JAXBException je) {\n    throw new RuntimeException(\"Error interpreting XML response\", je);\n  }\n}\n\nfromXml(SomeSubObject.class, \"<xml/>\");\n\n','//How to fix this\npublic static T fromXml<T>(String xml) {\n  try {\n    JAXBContext context = JAXBContext.newInstance(T.class);\n    Unmarshaller um = context.createUnmarshaller();\n    return (T)um.unmarshal(new StringReader(xml));\n  } catch (JAXBException je) {\n    throw new RuntimeException(\"Error interpreting XML response\", je);\n  }\n}\n\n//Also the call doesn\'t work...\nfromXml<SomeSubObject>(\"<xml/>\");','Generics',0,0,NULL,5),(3510,'java.sql.SQLException: Parameter index out of range (4 > number of parameters, which is 3).','public class Hello<T> {\n    \n    public static void main(String[] args){\n        try (Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\")){\n            String prepInsert = \"Insert into employees values(?,\'1962-11-07\',?,?,\'F\',\'1962-11-07\')\";\n            PreparedStatement ps = conn.prepareStatement(prepInsert,ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_UPDATABLE);\n            ps.setInt(1,555);\n            ps.setString(3,\"Angela\");\n            ps.setString(4,\"Horton\");\n            \n            int rowsupdated = ps.executeUpdate();\n            \n            System.out.println(rowsupdated);\n\n        }catch(Exception e){\n            System.out.println(e);\n            \n        }\n        \n    }\n}','JDBC',0,0,NULL,5),(3511,'1\n1\n\nyou can use a prepared statement multiple times','public class Hello<T> {\n    \n    public static void main(String[] args){\n        try (Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\")){\n            String prepInsert = \"Insert into employees values(?,\'1962-11-07\',?,?,\'F\',\'1962-11-07\')\";\n            PreparedStatement ps = conn.prepareStatement(prepInsert,ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_UPDATABLE);\n            ps.setInt(1,556);\n            ps.setString(2,\"Angela\");\n            ps.setString(3,\"Horton2\");\n            \n            int rowsupdated = ps.executeUpdate();\n            System.out.println(rowsupdated);\n            \n            ps.setInt(1,666);\n            ps.setString(2,\"MAX\");\n            ps.setString(3,\"AMILLION\");\n            \n            rowsupdated = ps.executeUpdate();\n            \n            System.out.println(rowsupdated);\n\n        }catch(Exception e){\n            System.out.println(e);\n            \n        }\n        \n    }\n}','JDBC',0,0,NULL,5),(3512,'Angela 555','public class Hello<T> {\n    \n    public static void main(String[] args){\n        try (Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\")){\n            String prepInsert = \"Select * from employees where first_name = ? OR last_name = ?\";\n            PreparedStatement ps = conn.prepareStatement(prepInsert,ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_UPDATABLE);\n            ps.setString(1,\"Georgi\");\n            ps.setString(2,\"Horton\");\n            \n            ResultSet rs = ps.executeQuery();\n            \n            while(rs.next()){\n                System.out.println(rs.getString(\"first_name\")+\" \"+rs.getString(\"emp_no\"));\n            }\n        }catch(Exception e){\n            System.out.println(e);           \n        }\n    }\n}','JDBC',0,0,NULL,5),(3513,'com.mysql.jdbc.exceptions.jdbc4.MySQLSyntaxErrorException: You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near \'? OR last_name = ?\' at line 1\n\npreparedstatement execute query does not take a String parameter, it already\nknows the query to execute. ','public class Hello<T> {\n    \n    public static void main(String[] args){\n        try (Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\")){\n            String prepInsert = \"Select * from employees where first_name = ? OR last_name = ?\";\n            PreparedStatement ps = conn.prepareStatement(prepInsert,ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_UPDATABLE);\n            ps.setString(1,\"Georgi\");\n            ps.setString(2,\"Horton\");\n            \n            ResultSet rs = ps.executeQuery(prepInsert);\n            \n            while(rs.next()){\n                System.out.println(rs.getString(\"first_name\")+\" \"+rs.getString(\"emp_no\"));\n            }\n        }catch(Exception e){\n            System.out.println(e);           \n        }\n    }\n}','JDBC',0,0,NULL,5),(3514,'calls the stored proceudre getBooksInDateRange','int customerID = 5001;\njava.sql.Date fromDate = ...;\njava.sql.Date toDate = ...;\nString getBooksInDateRange = \"{call getBooksDateRange(?,?,?)}\";\n\nCallableStatement cstmt = conn.prepareCall(getBooksInDateRange,ResultSet.TYPE_SCROLL_INSESNSITIVE,ResultSet.CONCUR_UPDATABLE);\n\ncstmt.setInt(1,customerID);\ncstmt.setDate(2,fromDate);\ncstmt.setDate(3,toDate);\nResultSet rs = cstmt.executeQuery();\n\n\n','JDBC',0,0,NULL,5),(3515,'to use a stored procedure you have to register the out parameter \nfirst. As shown here. ','int customerID = 5001;\njava.sql.Date fromDate = ...;\njava.sql.Date toDate = ...;\nString getBooksInDateRange = \"{? =call customerTotal (?)}\";\n\nCallableStatement cstmt = conn.prepareCall(getBooksInDateRange,ResultSet.TYPE_SCROLL_INSESNSITIVE,ResultSet.CONCUR_UPDATABLE);\n\ncstmt.registerOutParameter(1,java.sql.Types.DOUBLE);\n\ncstmt.setInt(2,customerID);\n\ncstmt.execute(); // not returning a resultset\n\nint total = cstmt.getDouble(1);\n','JDBC',0,0,NULL,5),(3516,'sqlexception execute doesn\'t take a parameter','int customerID = 5001;\njava.sql.Date fromDate = ...;\njava.sql.Date toDate = ...;\nString getBooksInDateRange = \"{? =call customerTotal (?)}\";\n\nCallableStatement cstmt = conn.prepareCall(getBooksInDateRange,ResultSet.TYPE_SCROLL_INSESNSITIVE,ResultSet.CONCUR_UPDATABLE);\n\ncstmt.registerOutParameter(1,java.sql.Types.DOUBLE);\n\ncstmt.setInt(2,customerID);\n\ncstmt.execute(getBookInDateRange); // not returning a resultset\n\nint total = cstmt.getDouble(1);\n                                  ','JDBC',0,0,NULL,5),(3517,'registers an INOUT parameter','int customerID = 5001;\nint numberOfOrders;\nCallableStatement ct = conn.prepareCall(\"{call customerOrderCount (?) }\");\nct.setInt(1,customerID);\nct.registerOutParameter(1.java.sql.Types.INTEGER);  // the out\n\nct.execute();\n\nint numberoforders = ct.getInt(1);','JDBC',0,0,NULL,5),(3518,'storedprocedures is code thta you dont have insight to and if you invoke executeQuery()\non a procedure that doesn\'t return a result set you get a sqlException\n\nso its best to use execute()','int customerID = 5001;\nint numberOfOrders;\nCallableStatement ct = conn.prepareCall(\"{call customerOrderCount (?) }\");\nct.setInt(1,customerID);\nct.registerOutParameter(1.java.sql.Types.INTEGER);  // the out\n\nct.executeQuery();\n\nint numberoforders = ct.getInt(1);','JDBC',0,0,NULL,5),(3519,'','int customerID = 5001;\nint numberOfOrders;\nCallableStatement ct = conn.prepareCall(\"{call customerOrderCount (?) }\");\nct.setInt(1,customerID);\nct.registerOutParameter(1.java.sql.Types.INTEGER);  // the out\n\nct.execute();\n\nint numberoforders = ct.getInt(1);\n\nif(ct.getMoreResults()) // returns true if there is a resultset to get. ','JDBC',0,0,NULL,5),(3520,'','RowSetFactory rsf = RowSetProvider.newFactory();\nJdbcRowSet jrs = rsf.createJdbcRowSet();\n// Provider returns a facotry that will create Rowset objects from\n// the reference implementation\n\n//with the factory it is easy to swap out the implementation\n\nRowSetFactorys rsf2 = RowSetProvider.newFactory(\"com.example.MyRowSetProvider\",null);\nJdbcRowSet jrs = rsf.createJdbcRowSet();','JDBC',0,0,NULL,5),(3521,'prints the first 100 employees\' full names\n\nyou construct a JdbcRowSet from a RowSetProvider.newFactory().createJdbcRowSet();\n\ninstead of statement conncection and resultSet you use RowSet commands\nto set the uname, pw and url. \n\nthen simply execute it. ','public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n        try(JdbcRowSet jrs = RowSetProvider.newFactory().createJdbcRowSet()){\n            String query = \"Select * from employees limit 100\";\n            jrs.setCommand(query);\n            jrs.setUrl(url);\n            jrs.setUsername(user);\n            jrs.setPassword(pw);\n            jrs.execute();\n            while(jrs.next()){\n                System.out.println(jrs.getString(\"first_name\") + \" \" + jrs.getString(\"last_name\"));\n            }    \n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n}','JDBC',0,0,NULL,5),(3522,'will not compile the proper way to create a JdbcRowSet is\n\n	JdbcRowSet jrs = RowSetProvider.newFactory().createJdbcRowSet()','public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n        try(JdbcRowSet jrs = RowSetProvider.createJdbcRowSet()){\n            String query = \"Select * from employees limit 100\";\n            jrs.setCommand(query);\n            jrs.setUrl(url);\n            jrs.setUsername(user);\n            jrs.setPassword(pw);\n            jrs.execute();\n            while(jrs.next()){\n                System.out.println(jrs.getString(\"first_name\") + \" \" + jrs.getString(\"last_name\"));\n            }    \n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n}','JDBC',0,0,NULL,5),(3523,'Will not compil creating a JdbcRowSet throws an sql exception so it is usually\ncreated in a try() - catch block, \n\nNot to mention every other of those commands throws an sqlexception','public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n            JdbcRowSet jrs = RowSetProvider.newFactory().createJdbcRowSet();\n            String query = \"Select * from employees limit 100\";\n            jrs.setCommand(query);\n            jrs.setUrl(url);\n            jrs.setUsername(user);\n            jrs.setPassword(pw);\n            jrs.execute();\n            while(jrs.next()){\n                System.out.println(jrs.getString(\"first_name\") + \" \" + jrs.getString(\"last_name\"));\n            }    \n    }\n}','JDBC',0,0,NULL,5),(3524,'NullPointerException, the username and password and url were not set, \n\nIT could Also throw an sqlexception for this,\n\nexecute fills the rowset with data. Just alswyas make sure that data is set.','public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n        try(JdbcRowSet jrs = RowSetProvider.newFactory().createJdbcRowSet()){\n            String query = \"Select * from employee limit 100\";\n            jrs.setCommand(query);\n            jrs.execute();\n            while(jrs.next()){\n                System.out.println(jrs.getString(\"first_name\") + \" \" + jrs.getString(\"last_name\"));\n            }    \n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n}','JDBC',0,0,NULL,5),(3525,'RowSet extends Result set so it is a result set\n\nseting the type still uses the resultset types. ','public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n        try(JdbcRowSet jrs = RowSetProvider.newFactory().createJdbcRowSet()){\n            String query = \"Select * from employees limit 100\";\n            jrs.setCommand(query);\n            jrs.setUrl(url);\n            jrs.setUsername(user);\n            jrs.setPassword(pw);\n            jrs.setType(ResultSet.TYPE_SCROLL_INSENSITIVE);\n            jrs.execute();\n            while(jrs.next()){\n                System.out.println(jrs.getString(\"first_name\") + \" \" + jrs.getString(\"last_name\"));\n            }    \n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n}','JDBC',0,0,NULL,5),(3526,'will not compile,\n\nResultSet.TYPE_SCROLL_INSENSITIVE\n\nThose fields are inherited from ResultSet. \n\nFields inherited from interface java.sql.ResultSet\nCONCUR_READ_ONLY, \nCONCUR_UPDATABLE, \nTYPE_FORWARD_ONLY, \nTYPE_SCROLL_INSENSITIVE, \nTYPE_SCROLL_SENSITIVE','public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n        try(JdbcRowSet jrs = RowSetProvider.newFactory().createJdbcRowSet()){\n            String query = \"Select * from employees limit 100\";\n            jrs.setCommand(query);\n            jrs.setUrl(url);\n            jrs.setUsername(user);\n            jrs.setPassword(pw);\n            jrs.setType(RowSet.TYPE_SCROLL_INSENSITIVE);\n            jrs.execute();\n            while(jrs.next()){\n                System.out.println(jrs.getString(\"first_name\") + \" \" + jrs.getString(\"last_name\"));\n            }    \n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n}','JDBC',0,0,NULL,5),(3527,'SQLException, you cannot Update insert or delete with execute() on a RowSet.\n\nto update the data you just update the data on your JdbcRowSet.\n\nthere are no executeQuery() or executeUpdate methods for RowSets. ','public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n        try(JdbcRowSet jrs = RowSetProvider.newFactory().createJdbcRowSet()){\n            String query = \"Update employees set first_name = \'Mike\' where emp_no = 789\";\n            jrs.setCommand(query);\n            jrs.setUrl(url);\n            jrs.setUsername(user);\n            jrs.setPassword(pw);\n            jrs.setType(ResultSet.TYPE_SCROLL_INSENSITIVE);\n            jrs.execute();\n            while(jrs.next()){\n                System.out.println(jrs.getString(\"first_name\") + \" \" + jrs.getString(\"last_name\"));\n            }    \n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n}','JDBC',0,0,NULL,5),(3528,'will not compile there is no executeUpdate() for RowSets,\nbecause you do not update insert or delete in this way. You use the update api.\n\nThis would be a sql exception anyway because you cannot perform update \ninsert or deletes with a sql command and a jdbc rowset.','public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n        try(JdbcRowSet jrs = RowSetProvider.newFactory().createJdbcRowSet()){\n            String query = \"Update employees set first_name = \'Mike\' where emp_no = 789\";\n            jrs.setCommand(query);\n            jrs.setUrl(url);\n            jrs.setUsername(user);\n            jrs.setPassword(pw);\n            jrs.setType(ResultSet.TYPE_SCROLL_INSENSITIVE);\n            jrs.executeUpdate();\n            while(jrs.next()){\n                System.out.println(jrs.getString(\"first_name\") + \" \" + jrs.getString(\"last_name\"));\n            }    \n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n}','JDBC',0,0,NULL,5),(3529,'will not compiles there is no executeQuery() with Jdbcrowsets. The Command is \nexecute()','public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n        try(JdbcRowSet jrs = RowSetProvider.newFactory().createJdbcRowSet()){\n            String query = \"Select * from employees limit 100\";\n            jrs.setCommand(query);\n            jrs.setUrl(url);\n            jrs.setUsername(user);\n            jrs.setPassword(pw);\n            jrs.setType(ResultSet.TYPE_SCROLL_INSENSITIVE);\n            jrs.executeQuery();\n            while(jrs.next()){\n                System.out.println(jrs.getString(\"first_name\") + \" \" + jrs.getString(\"last_name\"));\n            }    \n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n}','JDBC',0,0,NULL,5),(3530,'first set the user pw and url with:\n\n	       jrs.setUrl(url);\n            jrs.setUsername(user);\n            jrs.setPassword(pw);\n\nthen set the command: \n		String query = \"Select * from employees limit 100\";\n            jrs.setCommand(query);\n\nthen use the only command to execute:\n\nexecute()','How do you execute a query with a JdbcRowSet object ? ','JDBC',0,0,NULL,5),(3531,'NullpointerExeption you never set the command, could be an sqlException too\n\ndont forget to:\n\nsetCommand(query);','public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n        try(JdbcRowSet jrs = RowSetProvider.newFactory().createJdbcRowSet()){\n            String query = \"Select * from employees limit 100\";\n            jrs.setUrl(url);\n            jrs.setUsername(user);\n            jrs.setPassword(pw);\n            jrs.setType(ResultSet.TYPE_SCROLL_INSENSITIVE);\n            jrs.execute();\n            while(jrs.next()){\n                System.out.println(jrs.getString(\"first_name\") + \" \" + jrs.getString(\"last_name\"));\n            }    \n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n}','JDBC',0,0,NULL,5),(3532,'will not copile the method is setCommand not setQuery','public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n        try(JdbcRowSet jrs = RowSetProvider.newFactory().createJdbcRowSet()){\n            String query = \"Select * from employees limit 100\";\n            jrs.setQuery(query);\n            jrs.setUrl(url);\n            jrs.setUsername(user);\n            jrs.setPassword(pw);\n            jrs.execute();\n            while(jrs.next()){\n                System.out.println(jrs.getString(\"first_name\") + \" \" + jrs.getString(\"last_name\"));\n            }    \n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n}','JDBC',0,0,NULL,5),(3533,'','You can update data in the database with a resultset but thats not on the \nexam so DONT WORRY ABOUT IT. \n\nyou can do the same with RowSet and that IS on the exam so thats what you shuld focus on','JDBC',0,0,NULL,5),(3534,'change the last employees first name to \'Big Max\'','public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n        try(JdbcRowSet jrs = RowSetProvider.newFactory().createJdbcRowSet()){\n            String query = \"Select * from employees limit 100\";\n            jrs.setCommand(query);\n            jrs.setUrl(url);\n            jrs.setUsername(user);\n            jrs.setPassword(pw);\n            jrs.execute();\n            while(jrs.next()){\n                System.out.println(jrs.getString(\"first_name\") + \" \" + jrs.getString(\"last_name\"));\n            }\n            jrs.last();\n            jrs.updateString(\"first_name\",\"Big Max\");\n            jrs.updateRow();\n            \n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n}','JDBC',0,0,NULL,5),(3535,'This will print nothing, the cursor is already at the last poisiton so\nthere is not next for jrs to go to to fix add \n\n	jrs.first()\n\njust before the while loop.','public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n        try(JdbcRowSet jrs = RowSetProvider.newFactory().createJdbcRowSet()){\n            String query = \"Select * from employees limit 100\";\n            jrs.setCommand(query);\n            jrs.setUrl(url);\n            jrs.setUsername(user);\n            jrs.setPassword(pw);\n            jrs.execute();\n            \n            jrs.last();\n            jrs.updateString(\"first_name\",\"Big Max\");\n            jrs.updateRow();\n\n            while(jrs.next()){\n                System.out.println(jrs.getString(\"first_name\") + \" \" + jrs.getString(\"last_name\"));\n            }\n            \n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n}','JDBC',0,0,NULL,5),(3536,'will show the updated rows ','public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n        try(JdbcRowSet jrs = RowSetProvider.newFactory().createJdbcRowSet()){\n            String query = \"Select * from employees limit 100\";\n            jrs.setCommand(query);\n            jrs.setUrl(url);\n            jrs.setUsername(user);\n            jrs.setPassword(pw);\n            jrs.execute();\n            \n            jrs.last();\n            jrs.updateString(\"first_name\",\"Big Max\");\n            jrs.updateRow();\n            jrs.first();\n            while(jrs.next()){\n                System.out.println(jrs.getString(\"first_name\") + \" \" + jrs.getString(\"last_name\"));\n            }\n            \n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n}','JDBC',0,0,NULL,5),(3537,'will update the first row of the RowSet and write teh changes to the database\n\nprints: Big Max Big Dick Bisesi','public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n        try(JdbcRowSet jrs = RowSetProvider.newFactory().createJdbcRowSet()){\n            String query = \"Select * from employees limit 100\";\n            jrs.setCommand(query);\n            jrs.setUrl(url);\n            jrs.setUsername(user);\n            jrs.setPassword(pw);\n            jrs.execute();\n            jrs.first();\n            jrs.updateString(\"first_name\",\"Big Max\");\n            jrs.updateString(\"last_name\",\"Big Dick Bisesi\");\n            jrs.updateRow();\n            System.out.println(jrs.getString(\"first_name\") + \" \" + jrs.getString(\"last_name\"));\n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n}','JDBC',0,0,NULL,5),(3538,'SQLException: Invalid State\n\nexecute() was never used.','public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n        try(JdbcRowSet jrs = RowSetProvider.newFactory().createJdbcRowSet()){\n            String query = \"Select * from employees limit 100\";\n            jrs.setCommand(query);\n            jrs.setUrl(url);\n            jrs.setUsername(user);\n            jrs.setPassword(pw);\n            jrs.first();\n            jrs.updateString(\"first_name\",\"Big Max\");\n            jrs.updateString(\"last_name\",\"Big Dick Bisesi\");\n            jrs.updateRow();\n            System.out.println(jrs.getString(\"first_name\") + \" \" + jrs.getString(\"last_name\"));\n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n}','JDBC',0,0,NULL,5),(3539,'NullPointerException the cursor is before the first row','public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n        try(JdbcRowSet jrs = RowSetProvider.newFactory().createJdbcRowSet()){\n            String query = \"Select * from employees limit 100\";\n            jrs.setCommand(query);\n            jrs.setUrl(url);\n            jrs.setUsername(user);\n            jrs.setPassword(pw);\n            jrs.execute();\n            jrs.beforeFirst();\n            jrs.updateString(\"first_name\",\"Big Max\");\n            jrs.updateString(\"last_name\",\"Big Dick Bisesi\");\n            jrs.updateRow();\n            System.out.println(jrs.getString(\"first_name\") + \" \" + jrs.getString(\"last_name\"));\n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n}','JDBC',0,0,NULL,5),(3540,'NPE moving to absolute(0) moves to before the first row. \n\nmoving abosolute(-n) starts at the last row and moves the cursor backward','public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n        try(JdbcRowSet jrs = RowSetProvider.newFactory().createJdbcRowSet()){\n            String query = \"Select * from employees limit 100\";\n            jrs.setCommand(query);\n            jrs.setUrl(url);\n            jrs.setUsername(user);\n            jrs.setPassword(pw);\n            jrs.execute();\n            jrs.absolute(0);\n            jrs.updateString(\"first_name\",\"Big Max\");\n            jrs.updateString(\"last_name\",\"Big Dick Bisesi\");\n            jrs.updateRow();\n            System.out.println(jrs.getString(\"first_name\") + \" \" + jrs.getString(\"last_name\"));\n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n}','JDBC',0,0,NULL,5),(3541,'changes the fifth row in the rowset.\n\nAngela Bit Butt Horton','public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n        try(JdbcRowSet jrs = RowSetProvider.newFactory().createJdbcRowSet()){\n            String query = \"Select * from employees limit 100\";\n            jrs.setCommand(query);\n            jrs.setUrl(url);\n            jrs.setUsername(user);\n            jrs.setPassword(pw);\n            jrs.execute();\n            jrs.absolute(5);\n            jrs.updateString(\"first_name\",\"Angela\");\n            jrs.updateString(\"last_name\",\"Big Butt Horton\");\n            jrs.updateRow();\n            System.out.println(jrs.getString(\"first_name\") + \" \" + jrs.getString(\"last_name\"));\n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n}','JDBC',0,0,NULL,5),(3542,'jrs.moveToInsertRow();\njrs.updateString(\"first_name\",\"Jonny\");\njrs.udateString...\njrs.updateInt...\njrs.insertRow();\njrs.moveToCurrentRow();','How to insert a new row into a RowSet ?','JDBC',0,0,NULL,5),(3543,'sqlexception: invalid state there is no rowset to perforem these changes on \nbecause execute() wasn\'t called.','public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n        try(JdbcRowSet jrs = RowSetProvider.newFactory().createJdbcRowSet()){\n            String query = \"Select * from employees limit 100\";\n            jrs.setCommand(query);\n            jrs.setUrl(url);\n            jrs.setUsername(user);\n            jrs.setPassword(pw);\n            \n            jrs.moveToInsertRow();\n            jrs.updateInt(\"emp_no\",12345);\n            jrs.updateString(\"firs_name\",\"Blue\");\n            jrs.updateString(\"last_name\",\"Bella\");\n            jrs.insertRow();\n            \n            //System.out.println(jrs.getString(\"first_name\") + \" \" + jrs.getString(\"last_name\"));\n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n}','JDBC',0,0,NULL,5),(3544,'Blue Bella this prints the values just inserted in the insert row.','public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n        try(JdbcRowSet jrs = RowSetProvider.newFactory().createJdbcRowSet()){\n            String query = \"Select * from employees limit 100\";\n            jrs.setCommand(query);\n            jrs.setUrl(url);\n            jrs.setUsername(user);\n            jrs.setPassword(pw);\n            \n            jrs.execute();\n            \n            jrs.moveToInsertRow();\n            jrs.updateInt(\"emp_no\", 789);\n            jrs.updateString(\"first_name\",\"Blue\");\n            jrs.updateString(\"last_name\",\"Bella\");\n            jrs.insertRow();\n            \n            System.out.println(jrs.getString(\"first_name\") + \" \" + jrs.getString(\"last_name\"));\n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n}','JDBC',0,0,NULL,5),(3545,'null null','public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n        try(JdbcRowSet jrs = RowSetProvider.newFactory().createJdbcRowSet()){\n            String query = \"Select * from employees limit 100\";\n            jrs.setCommand(query);\n            jrs.setUrl(url);\n            jrs.setUsername(user);\n            jrs.setPassword(pw);\n            jrs.execute();\n            jrs.moveToInsertRow();\n            System.out.println(jrs.getString(\"first_name\") + \" \" + jrs.getString(\"last_name\"));\n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n}','JDBC',0,0,NULL,5),(3546,'NPE setURL was left out ','public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n        try(JdbcRowSet jrs = RowSetProvider.newFactory().createJdbcRowSet()){\n            String query = \"Select * from employees limit 100\";\n            jrs.setCommand(query);\n            jrs.setUsername(user);\n            jrs.setPassword(pw);\n            jrs.execute();\n            jrs.moveToInsertRow();\n            System.out.println(jrs.getString(\"first_name\") + \" \" + jrs.getString(\"last_name\"));\n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n}','JDBC',0,0,NULL,5),(3547,'will not compile non static variable cannot be referenced from static context','public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n        try(JdbcRowSet jrs = RowSetProvider.newFactory().createJdbcRowSet()){\n            String query = \"Select * from employees limit 100\";\n            jrs.setCommand(query);\n            jrs.setUrl(url);\n            jrs.setUsername(user);\n            jrs.setPassword(pw);\n            jrs.execute();\n            \n            jrs.addRowSetListener(new MyRowSetListener());\n            \n            jrs.moveToInsertRow();\n            jrs.updateInt(\"emp_no\",3);\n            jrs.updateString(\"first_name\",\"Micheal\");\n            jrs.updateString(\"last_name\",\"Boyd\");\n            jrs.insertRow();\n            \n            jrs.moveToCurrentRow();\n            \n            while(jrs.next()){\n                System.out.println(jrs.getString(\"first_name\") + \" \" + jrs.getString(\"last_name\"));\n            }\n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n    \n    class MyRowSetListener implements RowSetListener {\n        \n        public void rowChanged(RowSetEvent event) {\n            if(event.getSource() instanceof RowSet) {\n                try{\n                    ((RowSet) event.getSource()).execute();\n                    //re excute the query every time the rowset is updchanged to update it\n                } catch(SQLException e){\n                    \n                }\n                \n            }\n        }\n        \n        public void cursorMoved(RowSetEvent e) { }\n        public void rowSetChanged(RowSetEvent e){ }\n    }\n}','JDBC',0,0,NULL,5),(3548,'create a rowsetlistener','\npublic class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n        try(JdbcRowSet jrs = RowSetProvider.newFactory().createJdbcRowSet()){\n            String query = \"Select * from employees limit 100\";\n            jrs.setCommand(query);\n            jrs.setUrl(url);\n            jrs.setUsername(user);\n            jrs.setPassword(pw);\n            jrs.execute();\n            \n            jrs.addRowSetListener(new MyRowSetListener());\n            \n            jrs.moveToInsertRow();\n            jrs.updateInt(\"emp_no\",3);\n            jrs.updateString(\"first_name\",\"Micheal\");\n            jrs.updateString(\"last_name\",\"Boyd\");\n            jrs.insertRow();\n            \n            jrs.moveToCurrentRow();\n            \n            while(jrs.next()){\n                System.out.println(jrs.getString(\"first_name\") + \" \" + jrs.getString(\"last_name\"));\n            }\n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n    \n    static class MyRowSetListener implements RowSetListener {\n        \n        public void rowChanged(RowSetEvent event) {\n            if(event.getSource() instanceof RowSet) {\n                try{\n                    ((RowSet) event.getSource()).execute();\n                    //re excute the query every time the rowset is updchanged to update it\n                } catch(SQLException e){\n                    \n                }\n                \n            }\n        }\n        \n        public void cursorMoved(RowSetEvent e) { }\n        public void rowSetChanged(RowSetEvent e){ }\n    }\n}','JDBC',0,0,NULL,5),(3549,'got it','a JdbcRowSet is connected which means its update are actively written to\nthe db, a CachedRowSet and all the rest are disconnected which means they\ncan connect to get the data disconnect change the data then re connect to \nupdate their changes, thats what a cache is.','JDBC',0,0,NULL,5),(3550,'CachedRowSet cs = RowSetProvider.newFactory().createCachedRowSet();','how do you create a CachedRowSet','JDBC',0,0,NULL,5),(3551,'will not compile thats not how you create a RowSet. you should add \n\n	createJdbcRowSet();','\npublic class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n        try(JdbcRowSet jrs = RowSetProvider.newFactory().createJdbcRowSet()){\n            String query = \"Select * from employees limit 100\";\n            jrs.setCommand(query);\n            jrs.setUrl(url);\n            jrs.setUsername(user);\n            jrs.setPassword(pw);\n            jrs.execute();\n            \n            jrs.addRowSetListener(new MyRowSetListener());\n            \n            jrs.moveToInsertRow();\n            jrs.updateInt(\"emp_no\",3);\n            jrs.updateString(\"first_name\",\"Micheal\");\n            jrs.updateString(\"last_name\",\"Boyd\");\n            jrs.insertRow();\n            \n            jrs.moveToCurrentRow();\n            \n            while(jrs.next()){\n                System.out.println(jrs.getString(\"first_name\") + \" \" + jrs.getString(\"last_name\"));\n            }\n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n    \n    static class MyRowSetListener implements RowSetListener {\n        \n        public void rowChanged(RowSetEvent event) {\n            if(event.getSource() instanceof RowSet) {\n                try{\n                    ((RowSet) event.getSource()).execute();\n                    //re excute the query every time the rowset is updchanged to update it\n                } catch(SQLException e){\n                    \n                }\n                \n            }\n        }\n        \n        public void cursorMoved(RowSetEvent e) { }\n        public void rowSetChanged(RowSetEvent e){ }\n    }\n}','JDBC',0,0,NULL,5),(3552,'acceptChanges();','When your done changing CachedRowSet what do you call?','JDBC',0,0,NULL,5),(3553,'Connection conn = DriverManager..\nconn.setAutoCommit(false); // begin transaction','how do you begin a transaction in jdbc ?','JDBC',0,0,NULL,5),(3554,'you exlicityly commmit the current transaction\n\nyou excplicityl roll back the current transaction\n\nthere is a failure that forces automatic rollback.','A jdbc transaction includes all of the sQL queries you execute until either ...?','JDBC',0,0,NULL,5),(3555,'start a transacation by setting autoCommit(false), then make sure you commit()\nit otherwise everything you just did will be automatically rolledback. \n\nAs soon you commit() another transaction is started.\n\nThere can only be one transaction at a time. ','public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n       try(Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\")){\n           conn.setAutoCommit(false);\n           Statement stmt = conn.createStatement();\n           stmt.execute(\"Insert into employees values (601,\'Dixon\',\'Ramey\')\");\n           stmt.execute(\"Insert into employees values (602,\'Alex\',\'Ramey\')\");\n           stmt.execute(\"Insert into employees values (603,\'Kevin\',\'Ramey\')\");\n           \n           conn.commit();\n           \n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n    \n}','JDBC',0,0,NULL,5),(3556,'will not compile, Connection is scoped only within that try block because it is\nin a try with resources, conn in the catch is out of scope. ','public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n       try(Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\")){\n           conn.setAutoCommit(false);\n           Statement stmt = conn.createStatement();\n           stmt.execute(\"Insert into employees values (601,\'Dixon\',\'Ramey\')\");\n           stmt.execute(\"Insert into employees values (602,\'Alex\',\'Ramey\')\");\n           stmt.execute(\"Insert into employees values (603,\'Kevin\',\'Ramey\')\");\n           \n           conn.commit();\n           \n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n            \n            conn.rollback();\n        }\n    }\n    \n}','JDBC',0,0,NULL,5),(3557,'WNC DriverManager.getConnection throws a sqlexception ','public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\");\n  \n        try{   \n        \n            conn.setAutoCommit(false);\n           Statement stmt = conn.createStatement();\n           stmt.execute(\"Insert into employees values (601,\'Dixon\',\'Ramey\')\");\n           stmt.execute(\"Insert into employees values (602,\'Alex\',\'Ramey\')\");\n           stmt.execute(\"Insert into employees values (603,\'Kevin\',\'Ramey\')\");\n           \n           conn.commit();\n           \n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n            \n            conn.rollback();\n        }\n    }\n    \n}','JDBC',0,0,NULL,5),(3558,'if the insertions go as planned then commit the transaction otherwise try again\n','public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n       try(Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\")){\n           conn.setAutoCommit(false);\n           Statement stmt = conn.createStatement();\n           int updatecount = 0;\n           \n           updatecount += stmt.executeUpdate(\"Insert into employees values (701,\'Dixon\',\'Ramey\')\");\n           updatecount += stmt.executeUpdate(\"Insert into employees values (702,\'Alex\',\'Ramey\')\");\n           updatecount += stmt.executeUpdate(\"Insert into employees values (703,\'Kevin\',\'Ramey\')\");\n           \n           if(updatecount == 3){\n               System.out.println(\"Transaction complete\");\n                conn.commit();\n           } else {\n               System.out.println(\"Something didn\'t go through\");\n               conn.rollback();\n           }\n\n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n    \n}','JDBC',0,0,NULL,5),(3559,'sqlexception transaction has not been started. setAutoCommit(false) to start one','public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n       try(Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\")){\n           Statement stmt = conn.createStatement();\n           int updatecount = 0;\n           \n           updatecount += stmt.executeUpdate(\"Insert into employees values (701,\'Dixon\',\'Ramey\')\");\n           updatecount += stmt.executeUpdate(\"Insert into employees values (702,\'Alex\',\'Ramey\')\");\n           updatecount += stmt.executeUpdate(\"Insert into employees values (703,\'Kevin\',\'Ramey\')\");\n           \n           if(updatecount == 3){\n               System.out.println(\"Transaction complete\");\n                conn.commit();\n           } else {\n               System.out.println(\"Something didn\'t go through\");\n               conn.rollback();\n           }\n\n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n    \n}','JDBC',0,0,NULL,5),(3560,'setting autocommit to true will committ any current transaction and turn auto commit back on','public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n       try(Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\")){\n           conn.setAutoCommit(false);\n           Statement stmt = conn.createStatement();\n           int updatecount = 0;\n           \n           updatecount += stmt.executeUpdate(\"Insert into employees values (706,\'Dixon\',\'Ramey\')\");\n           updatecount += stmt.executeUpdate(\"Insert into employees values (707,\'Alex\',\'Ramey\')\");\n           updatecount += stmt.executeUpdate(\"Insert into employees values (708,\'Kevin\',\'Ramey\')\");\n           \n           if(updatecount == 3){\n               System.out.println(\"Transaction complete\");\n                conn.setAutoCommit(true);\n           } else {\n               System.out.println(\"Something didn\'t go through\");\n               conn.rollback();\n           }\n\n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n    \n}','JDBC',0,0,NULL,5),(3561,'FALSE ! Connection objects','JDBC:\n\nYou call setAutoCommit(false) on Statement ojbects ','JDBC',0,0,NULL,5),(3562,'','a savepoint represents a point in the transaction that you can rollback to.\nit is created from a connection object.','JDBC',0,0,NULL,5),(3563,'how to use a savepoint','public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n       try(Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\")){\n           conn.setAutoCommit(false);//start a transaction\n           Statement stmt = conn.createStatement();\n           int updatecount = 0;\n           \n           updatecount += stmt.executeUpdate(\"Insert into employees values (710,\'steve\',\'davidson\')\");\n           updatecount += stmt.executeUpdate(\"Insert into employees values (711,\'Alex\',\'The great\')\");\n           updatecount += stmt.executeUpdate(\"Insert into employees values (713,\'baily\',\'Ramey\')\");\n           Savepoint sp1 = conn.setSavepoint();\n           \n           stmt.executeUpdate(\"Insert into employees values(801,\'Whitey\',\'Ford\')\");\n           \n           conn.rollback();\n\n           ResultSet rs = stmt.executeQuery(\"select * from employees where first_name = \\\'Whitey\\\'\");\n           \n           while(rs.next()){\n               System.out.println(rs.getInt(\"emp_no\"));\n           }\n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n    \n}','JDBC',0,0,NULL,5),(3564,'Prepared and Callable statement setXXX() methods number parameters from \n1 not 0. ','public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n       try(Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\")){\n          String call = \"{CALL REMOVEBOOKS(?,?)}\";\n          String titleToRemove = null;\n          int maxBooks = 0;\n          CallableStatement cstmt = conn.prepareCall(call);\n          String titles = \"%Hero%\";\n          int numBooksRemoved;\n          cstmt.setInt(0,maxBooks);\n          cstmt.setString(1,titleToRemove);\n          cstmt.registerOutParameter(0,java.sql.Types.INTEGER);\n          cstmt.execute();\n          numBooksRemoved = cstmt.getInt(0); \n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n    \n}','JDBC',0,0,NULL,5),(3565,'executeQuery() for callable and preparedstatements must not have the query passed\nin as a parameter. \n\nAlso the indexes are numbered incorectly','public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n       try(Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\")){\n          String call = \"{CALL REMOVEBOOKS(?,?)}\";\n          String titleToRemove = null;\n          int maxBooks = 0;\n          CallableStatement cstmt = conn.prepareCall(call);\n          String titles = \"%Hero%\";\n          int numBooksRemoved;\n          cstmt.setInt(0,maxBooks);\n          cstmt.setString(1,titleToRemove);\n          cstmt.registerOutParameter(0,java.sql.Types.INTEGER);\n          cstmt.executeQuery(query);\n          numBooksRemoved = cstmt.getInt(0); \n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n    \n}','JDBC',0,0,NULL,5),(3566,'sqlexception executeQuery() for callable and prepared statements must not have\nthe query passed in as a parameter ','public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n       try(Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\")){\n          String call = \"{CALL REMOVEBOOKS(?,?)}\";\n          String titleToRemove = null;\n          String query = \"select * from Books\";\n          int maxBooks = 0;\n          CallableStatement cstmt = conn.prepareCall(call);\n          String titles = \"%Hero%\";\n          int numBooksRemoved;\n          cstmt.setInt(1,maxBooks);\n          cstmt.setString(2,titleToRemove);\n          cstmt.registerOutParameter(1,java.sql.Types.INTEGER);\n          cstmt.executeQuery(query);\n          numBooksRemoved = cstmt.getInt(1);\n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n    \n}','JDBC',0,0,NULL,5),(3567,'sqlexception for registering the out parameter after the execute call.','public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n       try(Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\")){\n          String call = \"{CALL REMOVEBOOKS(?,?)}\";\n          String titleToRemove = null;\n          String query = \"select * from Books\";\n          int maxBooks = 0;\n          CallableStatement cstmt = conn.prepareCall(call);\n          String titles = \"%Hero%\";\n          int numBooksRemoved;\n          cstmt.setInt(1,maxBooks);\n          cstmt.setString(2,titleToRemove);\n          cstmt.execute();\n          cstmt.registerOutParameter(1,java.sql.Types.INTEGER);\n          numBooksRemoved = cstmt.getInt(1);\n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n    \n}','JDBC',0,0,NULL,5),(3568,'this stored proceudre does not return a resultset, so while it will compile\nbcasue executeQuery() will return a ResultSet to rs. cstmt.getInt(1); will throw\na sql exception.','public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n       try(Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\")){\n          String call = \"{CALL REMOVEBOOKS(?,?)}\";\n          String titleToRemove = null;\n          String query = \"select * from Books\";\n          int maxBooks = 0;\n          CallableStatement cstmt = conn.prepareCall(call);\n          String titles = \"%Hero%\";\n          int numBooksRemoved;\n          cstmt.setInt(1,maxBooks);\n          cstmt.setString(2,titleToRemove);\n          cstmt.registerOutParameter(1,java.sql.Types.INTEGER);\n          ResultSet rs = cstmt.executeQuery();\n          rs.next();\n          numBooksRemoved = cstmt.getInt(1);\n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }\n    \n}','JDBC',0,0,NULL,5),(3569,'this is the way to use a CallableStatement.','public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n        \n       try(Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\")){\n          String call = \"{CALL REMOVEBOOKS(?,?)}\";\n          String titleToRemove = null;\n          String query = \"select * from Books\";\n          int maxBooks = 0;\n          CallableStatement cstmt = conn.prepareCall(call);\n          String titles = \"%Hero%\";\n          int numBooksRemoved;\n          cstmt.setInt(1,maxBooks);\n          cstmt.setString(2,titleToRemove);\n          cstmt.registerOutParameter(1,java.sql.Types.INTEGER);\n          cstmt.execute();\n          numBooksRemoved = cstmt.getInt(1);\n        } catch(SQLException e){\n            System.out.println(\"whoops\");\n            System.out.println(e);\n        }\n    }  \n}','JDBC',0,0,NULL,5),(3570,'Will not compile RowSetFactory does not implement autocloseable','try(RowSetFactory rsf = RowSetProvider.newFactory()) {\nRowSet rws = rsf.createRowSet();','JDBC',0,0,NULL,5),(3571,'this database will be unchanged. the error here is that acceptChanges() was\nnever called to reconcile the changes made with the in memory version and the\nactual db.\n\nthe database being offline anytime after the execute() is invoked in irrelevent\n','String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n       //try(Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\")){\n        \n        try(CachedRowSet crs = RowSetProvider.newFactory().createCachedRowSet()) {\n            String query = \"Select * From employee\";\n            crs.setCommand(query);\n            crs.setUrl(url);\n            crs.setUsername(user);\n            crs.setPassword(pw);\n            crs.execute();\n            crs.last();\n            crs.updateString(\"last_name\", \"Sullivan\");\n            //database goes offline\n            crs.moveToInsertRow();\n            crs.updateInt(\"ID\",101);\n            crs.updateString(\"first_name\",\"Billy\");\n            crs.updateString(\"last_name\",\"Blue\");\n            crs.insertRow();\n            crs.moveToCurrentRow();\n            crs.absolute(10);\n            crs.deleteRow();\n            //db backonline\n        } catch(SQLException e){\n            System.out.println(e);\n        }','JDBC',0,0,NULL,5),(3572,'crs.insertRow();\n\nalso crs.acceptChanges()','public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n       //try(Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\")){\n        \n        try(CachedRowSet crs = RowSetProvider.newFactory().createCachedRowSet()) {\n            String query = \"Select * From employee\";\n            crs.setCommand(query);\n            crs.setUrl(url);\n            crs.setUsername(user);\n            crs.setPassword(pw);\n            crs.execute();\n            crs.last();\n            crs.updateString(\"last_name\", \"Sullivan\");\n            //database goes offline\n            crs.moveToInsertRow();\n            crs.updateInt(\"ID\",101);\n            crs.updateString(\"first_name\",\"Billy\");\n            crs.updateString(\"last_name\",\"Blue\");\n            crs.moveToCurrentRow();\n            crs.absolute(10);\n            crs.deleteRow();\n            //db backonline\n        } catch(SQLException e){\n            System.out.println(e);\n        }\n    }  \n}\nwhats missing here ?','JDBC',0,0,NULL,5),(3573,'crs.execute() is missing','public class Hello {\n    public static void main(String[] args){\n        String url = \"jdbc:mysql://localhost/employees?useSSL=false\";\n        String user = \"root\";\n        String pw = \"Basketball12\";\n       //try(Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\")){\n        \n        try(CachedRowSet crs = RowSetProvider.newFactory().createCachedRowSet()) {\n            String query = \"Select * From employee\";\n            crs.setCommand(query);\n            crs.setUrl(url);\n            crs.setUsername(user);\n            crs.setPassword(pw);\n            crs.last();\n            crs.updateString(\"last_name\", \"Sullivan\");\n            //database goes offline\n            crs.moveToInsertRow();\n            crs.updateInt(\"ID\",101);\n            crs.updateString(\"first_name\",\"Billy\");\n            crs.updateString(\"last_name\",\"Blue\");\n            crs.insertRow();\n            crs.moveToCurrentRow();\n            crs.absolute(10);\n            crs.deleteRow();\n            //db backonline\n        } catch(SQLException e){\n            System.out.println(e);\n        }\n    }  \n}','JDBC',0,0,NULL,5),(3574,'the first two updates are executed, but then a sqlexception is thrown because \na transaction was never started to rollback.\n\nyou would have had to setAutoCommit(false) to start a transaction.\n\nThe first two were automatically commited. ','public class Hello {\n    public static void main(String[] args){\n        \n        boolean businessrule = true;\n       try(Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\")){\n            String query = \"Inser into ...\";\n            String query2 = \"Updat table...\";\n            \n            Statement st = conn.createStatement();\n            \n            st.executeUpdate(query);\n            st.executeUpdate(query2);\n            \n            if(businessrule){\n                conn.rollback();\n            }\n        } catch(SQLException e){\n            System.out.println(e);\n        }\n    }  \n}','JDBC',0,0,NULL,5),(3575,'if the business rule remains false then both updates will be comitted.\nsince autocommit is false.','public class Hello {\n    public static void main(String[] args){\n        \n        boolean businessrule = false;\n       try(Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\")){\n            conn.setAutoCommit(false);\n            String query = \"Inser into ...\";\n            String query2 = \"Updat table...\";\n            \n            Statement st = conn.createStatement();\n            \n            st.executeUpdate(query);\n            st.executeUpdate(query2);\n            \n            if(businessrule){\n                conn.rollback();\n            } else {\n                conn.commit();\n            }\n        } catch(SQLException e){\n            System.out.println(e);\n        }\n    }  \n}','JDBC',0,0,NULL,5),(3576,'no rows are added at all, the rollback() rolls back to the savepoint but erasing the\nsecond update, but because there is no commit() at all the first update will also be \nrolledback when the try block closes for good becaus autocommitmode was set\nto false. ','public class Hello {\n    public static void main(String[] args){\n\n       try(Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\")){\n            conn.setAutoCommit(false);\n            String query = \"Inser into ...\";\n            String query2 = \"Updat table...\";\n            Statement st = conn.createStatement();\n            \n            st.executeUpdate(query);\n            \n            Savepoint sp1 = conn.setSavepoint();\n            \n            st.executeUpdate(query2);\n            \n            conn.rollback();\n           \n        } catch(SQLException e){\n            System.out.println(e);\n        }\n    }  \n}','JDBC',0,0,NULL,5),(3577,'First entry:\nMicheal Boyd\nLast entry:\nKenroku Malabarba\nrow: 20\nKyoichi Maliniak\nrow: 30\nGuoxiang Nooteboom\nupdate executed\njava.sql.SQLException: Operation not allowed after ResultSet closed\n\nAfter re executing a statement, all ResultSets tied to that statemnt are \nautomatically closed','public class Hello {\n    public static void main(String[] args){\n        try {\n            Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\");\n            Statement st = conn.createStatement();\n            String q = \"Select * From employees limit 100\";\n            ResultSet rs = st.executeQuery(q);\n            \n            rs.first();\n            System.out.println(\"First entry:\");\n            System.out.println(rs.getString(\"first_name\") + \" \" +rs.getString(\"last_name\"));\n            \n            rs.last();\n            System.out.println(\"Last entry:\");\n            System.out.println(rs.getString(\"first_name\") + \" \" +rs.getString(\"last_name\"));\n            \n            rs.absolute(20);\n            System.out.println(\"row: \"+ rs.getRow());\n            System.out.println(rs.getString(\"first_name\") + \" \" +rs.getString(\"last_name\"));\n            \n            rs.relative(10);\n            System.out.println(\"row: \"+ rs.getRow());\n            System.out.println(rs.getString(\"first_name\") + \" \" +rs.getString(\"last_name\")); \n            \n            String update = \"insert into employees values(09,\'Broden\',\'Chapman\')\";\n            boolean results = st.execute(update);\n            \n            if(!results){\n                System.out.println(\"update executed\");\n            }\n            \n            rs.last();\n            System.out.println(\"new entry row: \"+ rs.getRow());\n            System.out.println(rs.getString(\"first_name\") + \" \" +rs.getString(\"last_name\")); \n\n        } catch(SQLException e){System.out.println(e); }\n        \n    }\n}','JDBC',0,0,NULL,5),(3578,'Will not compile, this is not the right syntax for multi - catch\nshould be \n\n	} catch(SQLException | IOException e){  ... }','public class Hello {\n    public static void main(String[] args){\n        try {\n            Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\");\n            Statement st = conn.createStatement();\n            String q = \"Select * From employees limit 100\";\n            getDBfile();\n            ResultSet rs = st.executeQuery(q);\n            \n            rs.first();\n            System.out.println(\"First entry:\");\n            System.out.println(rs.getString(\"first_name\") + \" \" +rs.getString(\"last_name\"));\n            \n            rs.last();\n            System.out.println(\"Last entry:\");\n            System.out.println(rs.getString(\"first_name\") + \" \" +rs.getString(\"last_name\"));\n            \n            rs.absolute(20);\n            System.out.println(\"row: \"+ rs.getRow());\n            System.out.println(rs.getString(\"first_name\") + \" \" +rs.getString(\"last_name\"));\n            \n            rs.relative(10);\n            System.out.println(\"row: \"+ rs.getRow());\n            System.out.println(rs.getString(\"first_name\") + \" \" +rs.getString(\"last_name\")); \n            \n            String update = \"insert into employees values(09,\'Broden\',\'Chapman\')\";\n            boolean results = st.execute(update);\n            \n            if(!results){\n                System.out.println(\"update executed\");\n            }\n            \n            rs.last();\n            System.out.println(\"new entry row: \"+ rs.getRow());\n            System.out.println(rs.getString(\"first_name\") + \" \" +rs.getString(\"last_name\")); \n\n        } catch(SQLException e | IOException e){System.out.println(e); }\n        \n    }\n    \n    public static void getDBfile() throws IOException { }  \n}','General',0,0,NULL,5),(3579,'First entry:\nHired today: Fri Jul 28 11:29:33 EDT 2017\nMicheal Boyd\nLast entry:\nTuval Kalloufi\nrow: 20\nChirstian Koblick\nrow: 30\nBerni Genin\nupdate executed\njava.sql.SQLException: Operation not allowed after ResultSet closed','public class Hello {\n    public static void main(String[] args){\n        try {\n            Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\");\n            PreparedStatement pst = conn.prepareStatement(\"Select * From employees limit 100\");\n            ResultSet rs = pst.executeQuery();\n            \n            java.util.Date d = new java.util.Date();\n\n            rs.first();\n            System.out.println(\"First entry:\");\n            System.out.println(\"Hired today: \"+d);\n            System.out.println(rs.getString(\"first_name\") + \" \" +rs.getString(\"last_name\"));\n            \n            rs.last();\n            System.out.println(\"Last entry:\");\n            System.out.println(rs.getString(\"first_name\") + \" \" +rs.getString(\"last_name\"));\n            \n            rs.absolute(20);\n            System.out.println(\"row: \"+ rs.getRow());\n            System.out.println(rs.getString(\"first_name\") + \" \" +rs.getString(\"last_name\"));\n            \n            rs.relative(10);\n            System.out.println(\"row: \"+ rs.getRow());\n            System.out.println(rs.getString(\"first_name\") + \" \" +rs.getString(\"last_name\")); \n            \n            String update = \"insert into employees values(11,\'Broden\',\'Chapman\')\";\n            boolean results = pst.execute(update);\n            \n            if(!results){\n                System.out.println(\"update executed\");\n            }\n            \n            rs.last();\n            System.out.println(\"new entry row: \"+ rs.getRow());\n            System.out.println(rs.getString(\"first_name\") + \" \" +rs.getString(\"last_name\")); \n\n        } catch(SQLException e){System.out.println(e); }\n        \n    }\n}','JDBC',0,0,NULL,5),(3580,'public long getTime()\n\nReturns the number of milliseconds \nsince January 1, 1970, 00:00:00 GMT represented by this Date object.','public static void main(sa) {\n	//most useless method\n	Date d = new Date();\n	sout( d.getTime() + \" \" );\n}\n\nwhat does this show ?','Strings',0,0,NULL,5),(3581,'WNC, the correct way to create a Calendar is \n\n	Calendar c = Calendar.getInstance();','public class Hello {\n    public static void main(String[] args){\n        try {\n            Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\");\n            PreparedStatement pst = conn.prepareStatement(\"Select * From employees limit 100\");\n            ResultSet rs = pst.executeQuery();\n            \n            Date d = new Date();\n            //Calendar c = Calendar.getInstance();\n            Calendar c = new Calendar();\n            c.setTime(d);\n\n            rs.first();\n            System.out.println(\"First entry:\");\n            System.out.println(\"Hired today: \"+d);\n            System.out.println(\"Start first upcoming monday: \"+firstNextMonday(d));\n            System.out.println(rs.getString(\"first_name\") + \" \" +rs.getString(\"last_name\"));\n            \n            c.add(Calendar.MONTH,-1);\n            Date monthago = c.getTime();\n            rs.last();\n            System.out.println(\"Last entry:\");\n            System.out.println(\"Hired a month ago: \"+monthago);\n            System.out.println(rs.getString(\"first_name\") + \" \" +rs.getString(\"last_name\"));\n            ','Strings',0,0,NULL,5),(3582,'WNC, the corrct ways to create a Calendar is \n\n	Calendar c = Calendar.getInstance();\n\nif that was corrected then this program would print:\n\n	First entry:\n	Hired today: Mon Aug 07 16:39:34 EDT 2017\n\nand keep running forever...\n\n	you were using accesing a static field at c.DAY_OF_WEEK\n	\n	it should be:\n\n	while(c.get(Calendar.DAY_OF_WEEK) != c.MONDAY){\n            //c.add(1,DAY_OF_WEEK);\n            c.add(c.DAY_OF_WEEK,1);\n        }\n\nif today was monday it would print the excact time and day of right now','public class Hello {\n    public static void main(String[] args){\n        try {\n            Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\");\n            PreparedStatement pst = conn.prepareStatement(\"Select * From employees limit 100\");\n            ResultSet rs = pst.executeQuery();\n            \n            Date d = new Date();\n            Calendar c = new Calendar();\n            c.setTime(d);\n\n            rs.first();\n            System.out.println(\"First entry:\");\n            System.out.println(\"Hired today: \"+d);\n            System.out.println(\"Start first upcoming monday: \"+firstNextMonday(d));\n            System.out.println(rs.getString(\"first_name\") + \" \" +rs.getString(\"last_name\"));\n            \n            c.add(Calendar.MONTH,-1);\n            Date monthago = c.getTime();\n            rs.last();\n            System.out.println(\"Last entry:\");\n            System.out.println(\"Hired a month ago: \"+monthago);\n            System.out.println(rs.getString(\"first_name\") + \" \" +rs.getString(\"last_name\"));\n        } catch(SQLException e){ }\n        \n    }\n    \n    public static Date firstNextMonday(Date d){\n        Calendar c = Calendar.getInstance();\n        c.setTime(d);\n        \n        while(c.DAY_OF_WEEK != c.MONDAY){\n            //c.add(1,DAY_OF_WEEK);\n            c.add(c.DAY_OF_WEEK,1);\n        }\n        \n        return c.getTime();\n        \n    }\n}','Strings',0,0,NULL,5),(3583,'java.sql.SQLException: No value specified for parameter 1','public class Hello {\n    public static void main(String[] args){\n        try {\n            Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\");\n            PreparedStatement pst = conn.prepareStatement(\"Select * From employees where first_name = ?\");\n            ResultSet rs = pst.executeQuery();\n            \n            Date d = new Date();\n            Calendar c = Calendar.getInstance();\n            c.setTime(d);\n            \n            DateFormat dateformat = DateFormat.getInstance();\n\n            rs.first();\n            System.out.println(\"First entry:\");\n            System.out.println(\"Hired today: \"+d);\n            System.out.println(\"Start first upcoming monday: \"+firstNextMonday(d));\n            System.out.println(rs.getString(\"first_name\") + \" \" +rs.getString(\"last_name\"));\n            \n            c.add(Calendar.MONTH,-1);\n            Date monthago = c.getTime();\n            rs.last();\n            System.out.println(\"Last entry:\");\n            System.out.println(\"Hired a month ago: \"+monthago);\n            System.out.println(rs.getString(\"first_name\") + \" \" +rs.getString(\"last_name\"));\n            \n            c.setTime(d);\n            c.add(Calendar.YEAR,-1);\n            c.add(Calendar.MONTH, -6);\n            Date yearandahalf = c.getTime();\n            rs.absolute(20);\n            System.out.println(\"row: \"+ rs.getRow());\n            System.out.println(\"Hired a year and a half ago\"+yearandahalf);\n            System.out.println(rs.getString(\"first_name\") + \" \" +rs.getString(\"last_name\"));\n	} catch(SQLException e) { }\n   }\n}','Strings',0,0,NULL,5),(3584,'7/28/17 12:39 PM','public static void main(String[] args){\n        Date d = new Date();\n        DateFormat df = DateFormat.getInstance();\n        \n        System.out.println(df.format(d));\n        \n    }','Strings',0,0,NULL,5),(3585,'Jul 28, 2017','public static void main(String[] args){\n\n        Date d = new Date();\n        DateFormat df = DateFormat.getDateInstance();\n        \n        System.out.println(df.format(d));\n        \n    }','Strings',0,0,NULL,5),(3586,' public static void main(String[] args){\n        Date d = new Date();\n        DateFormat df = DateFormat.getDateInstance(DateFormat.SHORT);\n        \n        System.out.println(df.format(d));\n        \n    }','What dateformat is this\n\n7/28/17','Strings',0,0,NULL,5),(3587,'will not compile, ParseException must be caught or thrown','public static void main(String[] args){\n        Date d = new Date();\n        DateFormat df = DateFormat.getDateInstance(DateFormat.SHORT);\n        \n        String s = df.format(d);\n        \n        Date d2 = df.parse(s);\n    }','Strings',0,0,NULL,5),(3588,'parsedFri Jul 28 00:00:00 EDT 2017','public static void main(String[] args){\n        Date d = new Date();\n        DateFormat df = DateFormat.getDateInstance(DateFormat.SHORT);\n        \n        String s = df.format(d);\n        \n        try{\n            Date d2 = df.parse(s);\n            System.out.println(\"parsed \"+d2);\n        } catch( ParseException e){\n            \n        }\n    }','Strings',0,0,NULL,5),(3589,'WNC dateformat is abstract cannot be instantiated ','public static void main(String[] args){\n        Date d = new Date();\n        DateFormat df = new DateFormat(DateFormat.SHORT);\n        \n        String s = df.format(d);\n        \n        try{\n            Date d2 = df.parse(s);\n            System.out.println(\"parsed \"+d2);\n        } catch( ParseException e){\n            \n        }\n    }','Strings',0,0,NULL,5),(3590,'The regular DF constructor doesn\'t take a style or Locale.\n\nGet a default date/time \nformatter that uses the SHORT style for both the date and the time.\n\nwith statements preparedstatements callablestatements:\n\n	executeQuery() returns a ResultSet\n	executeUpdate() returns an int\n	execute()  returns a boolean','try {\n            Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/employees?useSSL=false\", \"root\", \"Basketball12\");\n            PreparedStatement pst = conn.prepareStatement(\"Select * From employees limit 100\");\n            ResultSet rs = pst.executeQuery();\n            \n            Date d = new Date();\n            Calendar c = Calendar.getInstance();\n            c.setTime(d);\n            \n            DateFormat dateformat = DateFormat.getInstance();\n            Locale italian = new Locale(\"it\");\n            DateFormat italianformat = DateFormat.getInstance(DateFormat.FULL,italian);\n} catch(SQLException e){ }','Strings',0,0,NULL,5),(3591,'WNC you can only set a DateFormat and NumberFormat can only set\n local at the time of instantiation. There is not method to change locale\nafterward.','public class Hello {\n    public static void main(String[] args){\n        DateFormat df = DateFormat.getDateInstance(DateFormat.FULL,Locale.KOREA);\n        Date now = new Date();\n        \n        System.out.println(df.format(now));\n        \n        df.setLocale(Locale.US);\n        \n        System.out.println(df.format(now));\n    }\n}','Strings',0,0,NULL,5),(3592,'Brazil\nDenmark\nItaly\nBrasil\nDanmark\nItalia','public class Hello {\n    public static void main(String[] args){\n        Locale loc1 = new Locale(\"pt\",\"BR\");\n        Locale loc2 = new Locale(\"da\",\"DK\");\n        Locale loc3 = new Locale(\"it\", \"IT\");\n        \n        System.out.println(loc1.getDisplayCountry());\n        System.out.println(loc2.getDisplayCountry());\n        System.out.println(loc3.getDisplayCountry());\n        \n        //display the countrys name in that language\n        \n        System.out.println(loc1.getDisplayCountry(loc1));\n        System.out.println(loc2.getDisplayCountry(loc2));\n        System.out.println(loc3.getDisplayCountry(loc3));\n    }\n}','Strings',1,0,NULL,5),(3593,'3\n123.435','public class Hello {\n    public static void main(String[] args){\n        float f1 = 123.43535353f;\n        NumberFormat nf = NumberFormat.getInstance();\n        System.out.println(nf.getMaximumFractionDigits());\n        \n        System.out.println(nf.format(f1));\n        \n    }\n}','Strings',0,0,NULL,5),(3594,'3\n123.435\n123.43536','public class Hello {\n    public static void main(String[] args){\n        float f1 = 123.43535353f;\n        NumberFormat nf = NumberFormat.getInstance();\n        System.out.println(nf.getMaximumFractionDigits());\n        \n        System.out.println(nf.format(f1));\n        \n        nf.setMaximumFractionDigits(5);\n        \n        System.out.println(nf.format(f1));\n        \n    }\n}','Strings',0,0,NULL,5),(3595,'345.3435\n345','public class Hello {\n    public static void main(String[] args){\n        float f1 = 123.43535353f;\n        NumberFormat nf = NumberFormat.getInstance();\n        \n        try{\n            System.out.println(nf.parse(\"345.3435\"));\n            nf.setParseIntegerOnly(true);\n            System.out.println(nf.parse(\"345.3435\"));\n        } catch(ParseException e){\n            \n        }\n    }\n}','Strings',0,0,NULL,5),(3596,'123.435\n123.435\n$123.44\n?123\n\ncould vary from maching to machine','public class Hello {\n    public static void main(String[] args){\n        float f1 = 123.43535353f;\n        NumberFormat nf = NumberFormat.getInstance();\n        NumberFormat nf2 = NumberFormat.getInstance(Locale.KOREA);\n        NumberFormat nf3 = NumberFormat.getCurrencyInstance();\n        NumberFormat nf4 = NumberFormat.getCurrencyInstance(Locale.KOREA);\n        \n        System.out.println(nf.format(f1));\n        System.out.println(nf2.format(f1));\n        System.out.println(nf3.format(f1));\n        System.out.println(nf4.format(f1));\n\n    }\n}','Strings',0,0,NULL,5),(3597,'0\n7\n17','public class Hello {\n    public static void main(String[] args){\n        Pattern p = Pattern.compile(\"ab\");\n        Matcher m = p.matcher(\"abakdnfab kekrls ab\");\n        \n        while(m.find()){\n            System.out.println(m.start());\n        }\n        \n    }\n}','Strings',0,0,NULL,5),(3598,'13\n14\n30\n31\n58\n59\n\n\\\\d looks for digits','public class Hello {\n    public static void main(String[] args){\n        Pattern p = Pattern.compile(\"\\\\d\");\n        Matcher m = p.matcher(\"The silly Dog89 ran for miles.56 Like a silly little puppy45\");\n        \n        while(m.find()){\n            System.out.println(m.start());\n        }\n        \n    }\n}','Strings',0,0,NULL,5),(3599,'\\\\d looks for digits, \\\\D looks for nondigitis\nfirst:\n22\n23\n\nsecond:\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n24\n25\n26\n27\n28\n29\n30','first:\n    public static void main(String[] args){\n        Pattern p = Pattern.compile(\"\\\\d\");\n        Matcher m = p.matcher(\"The silly Dog ran for 89 miles.\");\n        \n        while(m.find()){\n            System.out.println(m.start());\n        }\n        \n    }\nsecond:\n	public static void main(String[] args){\n        Pattern p = Pattern.compile(\"\\\\D\");\n        Matcher m = p.matcher(\"The silly Dog ran for 89 miles.\");\n        \n        while(m.find()){\n            System.out.println(m.start());\n        }\n        \n    }\n','Strings',0,0,NULL,5),(3600,'a whitespace character \\t \\n \\f \\r','regex metacharacter:\n\n\\s','Strings',0,0,NULL,5),(3601,'non white space','regex metacharacter:\n\n\\S','Strings',0,0,NULL,5),(3602,'a-z A-Z digits or _','regex metacharacter:\n\n\\w word character\n\nmeaning what ?','Strings',0,0,NULL,5),(3603,'everything besides a-z A-Z _ or digits','regex metacharacter:\n\n\\W non word character\n\nmeaning what ?','Strings',0,0,NULL,5),(3604,'3\n9\n13\n17\n21\n24\n\nwhitespace characters','public static void main(String[] args){\n        Pattern p = Pattern.compile(\"\\\\s\");\n        Matcher m = p.matcher(\"The silly Dog ran for 89 miles.\");\n        \n        while(m.find()){\n            System.out.println(m.start());\n        }\n        \n    }','Strings',0,0,NULL,5),(3605,'all the non white spaces:\n0\n1\n2\n4\n5\n6\n7\n8\n10\n11\n12\n14\n15\n16\n18\n19\n20\n22\n23\n25\n26\n27\n28\n29\n30','public static void main(String[] args){\n        Pattern p = Pattern.compile(\"\\\\S\");\n        Matcher m = p.matcher(\"The silly Dog ran for 89 miles.\");\n        \n        while(m.find()){\n            System.out.println(m.start());\n        }\n        \n    }','Strings',0,0,NULL,5),(3606,'0   all the word characters similiar to \\\\S\n1\n2\n4\n5\n6\n7\n8\n10\n11\n12\n14\n15\n16\n18\n19\n20\n22\n23\n25\n26\n27\n28\n29','public static void main(String[] args){\n        Pattern p = Pattern.compile(\"\\\\w\");\n        Matcher m = p.matcher(\"The silly Dog ran for 89 miles.\");\n        \n        while(m.find()){\n            System.out.println(m.start());\n        }\n        \n    }','Strings',0,0,NULL,5),(3607,'3  //non word character similar to \\\\S numbers are word characters\n9\n13\n17\n21\n24\n30','public static void main(String[] args){\n        Pattern p = Pattern.compile(\"\\\\W\");\n        Matcher m = p.matcher(\"The silly Dog ran for 89 miles.\");\n        \n        while(m.find()){\n            System.out.println(m.start());\n        }\n        \n    }','Strings',0,0,NULL,5),(3608,'a word boundary, anytime there is a word character and a non word right next to\neach other.\nThere are invisible non word characters at the end and beginning of a string.\n\n0\n3\n4\n9\n10\n13\n14\n17\n18\n21\n22\n24\n25\n30','public class Hello {\n    public static void main(String[] args){\n        Pattern p = Pattern.compile(\"\\\\b\");\n        Matcher m = p.matcher(\"The silly Dog ran for 89 miles.\");\n        \n        while(m.find()){\n            System.out.println(m.start());\n        }\n        \n    }\n}','Strings',0,0,NULL,5),(3609,'//non word boundary each of these is a case where there IS NO word boundary\nor two word characters are beside each other or two non words are beside each other\nreturns the position of the second character.\n\n1 \n2\n5\n6\n7\n8\n11\n12\n15\n16\n19\n20\n23\n26\n27\n28\n29\n31','public class Hello {\n    public static void main(String[] args){\n        Pattern p = Pattern.compile(\"\\\\B\");\n        Matcher m = p.matcher(\"The silly Dog ran for 89 miles.\");\n        \n        while(m.find()){\n            System.out.println(m.start());\n        }\n        \n    }\n}','Strings',0,0,NULL,5),(3610,'4\n5\n11\n19\n26\n29','public static void main(String[] args){\n        Pattern p = Pattern.compile(\"[soi]\");\n        Matcher m = p.matcher(\"The silly Dog ran for 89 miles.\");\n        \n        while(m.find()){\n            System.out.println(m.start());\n        }\n        \n    }','Strings',0,0,NULL,5),(3611,'1\n2\n4\n5\n6\n7\n8\n11\n12\n14\n15\n16\n18\n19\n20\n25\n26\n27\n28\n29','public class Hello {\n    public static void main(String[] args){\n        Pattern p = Pattern.compile(\"[a-z]\");\n        Matcher m = p.matcher(\"The silly Dog ran for 89 miles.\");\n        \n        while(m.find()){\n            System.out.println(m.start());\n        }\n        \n    }\n}\n','Strings',0,0,NULL,5),(3612,'15','public class Hello {\n    public static void main(String[] args){\n        Pattern p = Pattern.compile(\"[a-cA-C]\");\n        Matcher m = p.matcher(\"The silly Dog ran for 89 miles.\");\n        \n        while(m.find()){\n            System.out.println(m.start());\n        }\n        \n    }\n}','Strings',0,0,NULL,5),(3613,'// the mistake here is that ? gives you \"ZERO OR ONE\" so if there is no a \nthere that still mathces!\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58','public class Hello {\n    public static void main(String[] args){\n        Pattern p = Pattern.compile(\"a?\");\n        Matcher m = p.matcher(\"The silly Dog ran for at least 89 miles.I am tired he said\");\n        \n        while(m.find()){\n            System.out.println(m.group());\n        }\n        \n    }\n}','Strings',0,0,NULL,5),(3614,'public class Hello {\n    public static void main(String[] args){\n        Pattern p = Pattern.compile(\" a.\");\n        Matcher m = p.matcher(\"The silly Dog ran for at least 89 miles.I am tired he said\");\n        \n        while(m.find()){\n            System.out.println(m.start());\n            System.out.println(m.group());\n        }\n        \n    }\n}\n\n21\n at\n41\n am','creaet a regex that finds a word composed of an \'a\' with any character next to it','Strings',0,0,NULL,5),(3615,'Without the space at the beginning of the pattern you allow a then any character\nto but up against any other character if you wanted it to just be individual\nwords then you could add a space at the beginning or a whitespce character.\n15\nan\n22\nat\n27\nas\n42\nam\n55\nai','public class Hello {\n    public static void main(String[] args){\n        Pattern p = Pattern.compile(\"a.\");\n        Matcher m = p.matcher(\"The silly Dog ran for at least 89 miles.I am tired he said\");\n        \n        while(m.find()){\n            System.out.println(m.start());\n            System.out.println(m.group());\n        }\n        \n    }\n}\n\n','Strings',0,0,NULL,5),(3616,'21\n at\n41\n am','public class Hello {\n    public static void main(String[] args){\n        Pattern p = Pattern.compile(\"\\\\sa.\");\n        Matcher m = p.matcher(\"The silly Dog ran for at least 89 miles.I am tired he said\");\n        \n        while(m.find()){\n            System.out.println(m.start());\n            System.out.println(m.group());\n        }\n        \n    }\n}','Strings',0,0,NULL,5),(3617,'49\n first ','public class Hello {\n    public static void main(String[] args){\n        //five letter words\n        Pattern p = Pattern.compile(\"\\\\s.....\\\\s\");\n        Matcher m = p.matcher(\"A regular expression, specified as a string, must first be compiled into an instance of this class\");\n        \n        while(m.find()){\n            System.out.println(m.start());\n            System.out.println(m.group());\n        }\n        \n    }\n}','Strings',0,0,NULL,5),(3618,'/home/maxbisesi/Documents/allfiles\n\nNone of these methods throw an IOE','public class Hello {\n    public static void main(String[] dicks){\n      Path src = Paths.get(\"/home/maxbisesi/Documents/allfiles/copy.txt\");\n      Path srcParent = src.getParent();\n      System.out.println(srcParent);\n      \n    }\n\n}','IO',0,1,NULL,5),(3619,'0\nyyxxxyxx\n8\n\n* is greedy so it reads then entire source then works backward, until it finds\nthe rightmost match. ',' public static void main(String[] args){\n        //five letter words\n        Pattern p = Pattern.compile(\".*xx\");\n        Matcher m = p.matcher(\"yyxxxyxx\");\n        \n        while(m.find()){\n            System.out.println(m.start());\n            System.out.println(m.group());\n		  System.out.println(m.end());\n        }\n        \n      \n    }','Strings',0,0,NULL,5),(3620,'0\nyyxxxy\n6\n\ngreedy reads the whole source data first','public static void main(String[] args){\n        //five letter words\n        Pattern p = Pattern.compile(\".*y\");\n        Matcher m = p.matcher(\"yyxxxyxx\");\n        \n        while(m.find()){\n            System.out.println(m.start());\n            System.out.println(m.group());\n            System.out.println(m.end());\n        }\n        \n      \n    }','Strings',0,0,NULL,5),(3621,'This pattern says its looking for zero or more digits, \nso at the positions other than 2 5 and 11 it does find 0 digits\n\n0:__\n1:__\n2:_4_\n3:__\n4:__\n5:_89_\n7:__\n8:__\n9:__\n10:__\n11:_90_\n13:__\n14:__\n\n',' public static void main(String[] args){\n        //five letter words\n        Pattern p = Pattern.compile(\"\\\\d*\");\n        Matcher m = p.matcher(\"yy4xx89xxye90g\");\n        \n        while(m.find()){\n            System.out.println(m.start()+\":_\"+m.group()+\"_\");\n        }\n        \n      \n    }','Strings',0,0,NULL,5),(3622,'Greedy will allow zero length matches, proven by the start and end indexs being \nthe same.\n\n0:_a_:1\n1:__:1\n2:_a_:3\n3:_a_:4\n4:__:4\n5:__:5\n6:__:6\n7:_a_:8\n8:_a_:9\n9:_a_:10\n10:__:10\n11:__:11\n12:_a_:13\n13:_a_:14\n14:_a_:15\n15:__:15','public static void main(String[] args){\n        //five letter words\n        Pattern p = Pattern.compile(\"a?\");\n        Matcher m = p.matcher(\"abaabbbaaabbaaa\");\n        \n        while(m.find()){\n            System.out.println(m.start()+\":_\"+m.group()+\"_:\"+m.end());\n        }\n        \n      \n    }','Strings',0,0,NULL,5),(3623,'hello\nmy\ndarling','public class Hello {\n    public static void main(String[] args){\n        String[] tokens = \"hello my darling\".split(\" \");\n        \n        for(String s : tokens){\n            System.out.println(s);\n        }\n    }\n\n}','Strings',0,0,NULL,5),(3624,'hello\nmy\ndarling','public static void main(String[] args){\n        String[] tokens = \"hello5my5darling\".split(\"\\\\d\");\n        \n        for(String s : tokens){\n            System.out.println(s);\n        }\n    }','Strings',0,0,NULL,5),(3625,'b\ni\ng\ni\nb\nh\nj\nv\nu\n \nl\no\nu\nf\n \nk\nv\nc\ni\ny','public static void main(String[] args){\n        String[] tokens = \"bigibhjvu louf kvciy\".split(\"\");\n        \n        for(String s : tokens){\n            System.out.println(s);\n        }\n    }','Strings',0,0,NULL,5),(3626,'whitespace','what is scanners default delemiter','Strings',0,0,NULL,5),(3627,'01234456','public static void main(String[] args){\n        Pattern p = Pattern.compile(\"\\\\d*\");\n        Matcher m = p.matcher(\"ab34ef\");\n        while(m.find()){\n            System.out.print(m.start() + m.group());\n        }\n    }','Strings',0,0,NULL,5),(3628,'0123445687891234514','public static void main(String[] args){\n        Pattern p = Pattern.compile(\"\\\\d*\");\n        Matcher m = p.matcher(\"ab34ef8hk12345\");\n        while(m.find()){\n            System.out.print(m.start() + m.group());\n        }\n    }','Strings',0,0,NULL,5),(3629,'\n\n\n\n\n\n\n\n\n\n\nException in thread \"main\" java.util.MissingResourceException: \nCan\'t find bundle for base name NickNames, locale en_US\n\n\n\n\n\n\n\n\n\n\n\n','public class Hello {\n    public static void main(String[] args){\n        ResourceBundle rb = ResourceBundle.getBundle(\"NickNames\");\n        System.out.println(rb.getString(\"Max Bisesi\"));\n        \n    }\n}\n\nclass NickNames extends ListResourceBundle {\n    protected Object[][] getContents(){\n        return new Object[][]{{\"hello\",\"from java\"},{\"Max Bisesi\",\"Big Bad Max\"},{\"Garret Gieske\", \"gieske\"}};\n    }\n}','Locale',0,0,NULL,5),(3630,'en_US\nde_DE','public static void main(String[] args){\n       Locale initial = Locale.getDefault();\n        System.out.println(initial);\n        \n        Locale.setDefault(Locale.GERMANY);\n        System.out.println(Locale.getDefault());\n        \n    }','Locale',0,0,NULL,5),(3631,'ResourceBundle.getBundle(basename);\nResourceBundle.getBundle(basename, locale);\n\nfirst uses default locale','two ways to get a ResourceBundle: ?','Locale',0,0,NULL,5),(3632,'got it !','Java chooses the most specific resource bundle it can while while giving\npreference to java ListResourceBundle','Locale',0,0,NULL,5),(3633,'RB_fr_CA.java // a java class mathcing excactly\nRB_fr_CA.properties // then it looks for exectaly matching property files\n\nRB_fr.java\nRB_fr.properites // if it cant find both it will look for the Language\n\n\nRB_en_US.java\nRB_en_US.poperties   // use the default locale instead\n\nRB_en.java\nRB_en.properties   //just llook for the default language\n\nRB.java\nRB.properties    //try default Bundle name','request french canadian resource bundle\n\nLocale loc = new Locale(\"fr\",\"CA\");\nResourceBundle rb = ResourceBundle.getBundle(\"RB\",loc);\n\nhow will java search for that bundle ?','Locale',0,0,NULL,5),(3634,'missingresourceexception','What happens if java cant find a resourceBundle','Locale',0,0,NULL,5),(3635,'Take a ride in the lift','ResourceBundles can inherit properties from parents\n\nRB_en.properties\n	ride.in=Take a ride in\n\nRB_en_US.properties\n	elevator=elevator\n\nRB_en_UK.properties\n	elevator=lift\n\nLocale locale = new Locale(\"en\",\"UK\");\nResourceBundle rb = ResourceBundle.getBundle(\"RB\",locale);\nsout(rb.getString(\"ride.in\") + rb.getString(\"elevator\"));','Locale',0,0,NULL,5),(3636,'MissingResourceException','public static void main(String[] args){\n      ResourceBundle rb = ResourceBundle.getBundle(\"Flag\",new Locale(\"en_CA\"));\n        System.out.println(rb.getString(\"key\"));\n        \n    }\n\nthere are no resourcebundles loaded','Locale',0,0,NULL,5),(3637,'Flag_en_CA.properties\nFlag_en.java\nFlag_en.properties\nFlag.properties','public static void main(String[] args){\n      ResourceBundle rb = ResourceBundle.getBundle(\"Flag\",new Locale(\"en_CA\"));\n        System.out.println(rb.getString(\"key\"));\n        \n    }\n\ndefault locale is Italian if there is only one resource bundle on the classpath\nhow will java search for that bundle based on the above ?','Locale',0,0,NULL,5),(3638,'Flag_en.properties\n\nFlag_fr_CA.properties the language does not match\n\nFlag_CA.properties, CA is not a valid lang code','public static void main(String[] args){\n      ResourceBundle rb = ResourceBundle.getBundle(\"Flag\",new Locale(\"en_CA\"));\n        System.out.println(rb.getString(\"key\"));\n        \n    }\n\nwhich will be chosen ?\n\nFlag_fr_CA.properties\nFlag_en.properties\nFlag_CA.properties ','Locale',0,0,NULL,5),(3639,'1 \n3 \n6 \n8 \n9 \n11 \n\n\\\\b says that the number reported is the end of a boundary between a wordcharacter\nand a non word character,\n\nbetween 0 and 1 is a boundary between a word and a non word.\n\nimagine the end and beginning of a string is an invisible non word.\nposition 0 was not returned here because ^ is non word and that against the \ninvisble non word is not a boundary','public static void main(String[] args){\n      Pattern p = Pattern.compile(\"\\\\b\");\n      Matcher m = p.matcher(\"^23 *$76 bc\");\n      while(m.find()){\n          System.out.println(m.start()+\" \");\n      }\n        \n    }','Locale',0,0,NULL,5),(3640,'1\n3\n4\n6','  public static void main(String[] args){\n      Pattern p = Pattern.compile(\"\\\\b\");\n      Matcher m = p.matcher(\"#ab de#\");\n      while(m.find()){\n          System.out.println(m.start()+\" \");\n      }\n        \n    }','Locale',0,0,NULL,5),(3641,'0 \n2 \n5 \n7\n\nif there is a non word boundary between the last character and \nthe invible end of string non word boundary then start will give \nthe very last character index, where normally it would give the second \nindex of the two characters creating the non word boudary. ',' public static void main(String[] args){\n      Pattern p = Pattern.compile(\"\\\\B\");\n      Matcher m = p.matcher(\"#ab de#\");\n      while(m.find()){\n          System.out.println(m.start()+\" \");\n      }\n        \n    }','Strings',0,0,NULL,5),(3642,'0 \n4 \n8 \n9','public static void main(String[] args){\n      Pattern p = Pattern.compile(\"\\\\b\");\n      Matcher m = p.matcher(\"abci####r\");\n      while(m.find()){\n          System.out.println(m.start()+\" \");\n      }\n        \n    }','Locale',0,0,NULL,5),(3643,'something like this ^^rt##r\n\nthe output is determined by the difference between a boundary adn a word boundary\n\n','when searched using \\\\b what string would give the result: 2467 ?','Strings',0,0,NULL,5),(3644,'^^^^^^^\n\nimagine Strings contain non word characters at the beginning and end of\neach string. Here, \\\\B is saying that there is NOT a word boundary between\nthe imaginary non word character that represents the beginning of the string\nand the first ^ symbol because they are both non words.\n\nThen there is NOT a word boundary between the first and subsequent ^ symbols\nbecause they are all non words. ','when searched with \\\\B what string could give 1234567 ? ','Locale',0,0,NULL,5),(3645,'..\n. a.\n. b .\n. c.\n.d .\n.e.\n\nif the first character in the String is a delimter the first array\nelement will be an empty token','public static void main(String[] args){\n        String[] chunks = \"1 a2 b 3 c4d 5e\".split(\"\\\\d\");\n        \n        for(String s : chunks){\n            System.out.println(\".\"+s+\".\");\n        }\n        \n    }','Locale',0,0,NULL,5),(3646,'got it ','if the first character in the String is a delimter the first array\nelement will be an empty token','Locale',0,0,NULL,5),(3647,'Changed line5 to new Locale(\"en\",\"UK\")','Train_en_US.properties: train=subway\nTrain_en_UK.properties: train=undergroudn\nTrain_en_.properties: ride = ride;\n\npublic class Choochoo {\n	public static void main(String[] args) {\n		Locale.setDefault(new Locale(\"en\",\"US\"));\n		ResourceBundle rb = \n	ResourceBundle.getBundle(\"Train\",new Locale(\"en\",\"US\"));\n		sout( rb.getString(\"ride\")+\" \"+rb.getString(\"train\"));\n	}\n}\n\nwhich change can you make independently to change the output to \"ride underground\"\n\nchange line 1 to Locale.setDefault(new Locale(\"en\",\"UK));\nAdd train=underground to Train_en.porperties\nchange line5 to new Locale(\"en\",\"UK\"));\nDelete Train_en_US.properties','Locale',0,0,NULL,5),(3648,'go it ','when using StringBuilder if you append past the current capacity it\ncan be automatically increased.\n\nif you insert past it you will receive an exception','Locale',0,0,NULL,5),(3649,'0  \n9 abcdef789','public static void main(String[] args){\n        StringBuilder sb = new StringBuilder(8);\n        System.out.println(sb.length() + \" \" + sb + \" \");\n        sb.insert(0,\"abcdef\");\n        sb.append(\"789\");\n        System.out.println(sb.length() + \" \" + sb);   \n    }','Locale',0,0,NULL,5),(3650,'0  \n10 abcdefghij\n\nthe string builders capacity has been increased automatically','public static void main(String[] args){\n        StringBuilder sb = new StringBuilder(8);\n        System.out.println(sb.length() + \" \" + sb + \" \");\n        sb.insert(0,\"abcdefghij\");\n        System.out.println(sb.length() + \" \" + sb);   \n    }','General',0,0,NULL,5),(3651,'will not compile, there is no method getInteger();','public class Hello {\n    public static void main(String[] args){\n        ResourceBundle rb = ResourceBundle.getBundle(\"NickNames\",Locale.getDefault());\n        Object ob = rb.getInteger(\"123\");\n        \n    }\n}\n\nclass NickNames extends ListResourceBundle {\n    protected Object[][] getContents(){\n        return new Object[][]{{\"hello\",\"from java\"},{\"Max Bisesi\",\"Big Bad Max\"},{\"Garret Gieske\", \"gieske\"},{\"123\",678}};\n    }\n}','General',0,0,NULL,5),(3652,'ClassCastException\n\nyoou can either use getString to get a string or getObject to get anything else\nbut you cannot use getString to get an object','public class Hello {\n    public static void main(String[] args){\n        ResourceBundle rb = ResourceBundle.getBundle(\"Hello.NickNames\",Locale.getDefault());\n        Object ob = rb.getString(\"123\");\n        \n    }\n}\n\nclass NickNames extends ListResourceBundle {\n    protected Object[][] getContents(){\n        return new Object[][]{{\"hello\",\"from java\"},{\"Max Bisesi\",\"Big Bad Max\"},{\"Garret Gieske\", \"gieske\"},{\"123\",678}};\n    }\n}','General',0,0,NULL,5),(3653,'abcd abc false\nabcd abcd true\n\nstring objects are immutable references are mutable\n\nSo here, when the s1+=\"d\" executes. The String \"abc\" was once referenced\nby s1 but it not longer is. Now it is referenced by s2. a New String object\nis created abcd and s1 is reassinged to reference that.','public static void main(Sa) {\n	String s1 = \"abc\";\n	String s2 = s1;\n	s1 += \"d\";\n	sout(s1+\" \"+s2+\" \"+ (s1==s2));\n	\n	StringBuffer sb1 = new StringBuffer(\"abc\");\n	StringBuffer sb2 = sb1;\n	sb1.append(\"d\");\n	sout(sb1+ \" \" + sb2 + \" \" + (sb1==sb2));\n}','General',0,0,NULL,5),(3654,' maxy  denny \n\nstrings are immutable, when s.trim() is executed a new String is created\nand a reference to it is returned then immediately lost. s and x remain\npointing to the strings \" maxy \" and \" denny \".\n','public class Hello {\n    public static void main(String[] args){\n       String s = \" maxy \";\n       String x = \" denny \";\n       s.trim();\n       x.trim();\n       String y = s+x;\n       \n        System.out.println(y);\n    }\n}','General',0,0,NULL,5),(3655,'987.12346 // rounds doesn\'t truncate\n987.123456 // setMaxFracDigs applies to formating but not parsing','String s = \"987.123456\";\ndouble d = 987.123456d;\nNumberFormat nf = NumberFormat.getInstance();\nnf.setMaximumFractionDigits(5);\nsout(nf.format(d) + \" \");\ntry {\n	sout(nf.parse(s));\n} catch(ParseException e){ }','General',0,0,NULL,5),(3656,'3\n\n\\\\d looks for digits\n\n+ says one or more ','public static void main(String[] args){\n        Pattern p = Pattern.compile(\"\\\\d+\");\n        Matcher m = p.matcher(\"ab2c4d67\");\n        int count = 0;\n        while(m.find()){\n            count++;\n        }\n        System.out.println(count);\n    }','Strings',0,0,NULL,5),(3657,'this one is confusing but remember + is greedy\n\nits not a series of word characters in this case the whole damn thing is \none word character',' public static void main(String[] args){\n        Pattern p = Pattern.compile(\"\\\\w+\");\n        Matcher m = p.matcher(\"ab2c4d67\");\n        int count = 0;\n        while(m.find()){\n            count++;\n        }\n        System.out.println(count);\n    }','Strings',0,0,NULL,5),(3658,'1\n\nthe whole string is one long non whitespace character and + is greedy\nso it took the whole thing','public static void main(String[] args){\n        Pattern p = Pattern.compile(\"\\\\S+\");\n        Matcher m = p.matcher(\"ab2c4d67\");\n        int count = 0;\n        while(m.find()){\n            count++;\n        }\n        System.out.println(count);\n    }','Strings',0,0,NULL,5),(3659,'1\n\n+ is greedy so this whole number is one big digit, greedy took the whole \nthing',' public static void main(String[] args){\n        Pattern p = Pattern.compile(\"\\\\d+\");\n        Matcher m = p.matcher(\"78254467\");\n        int count = 0;\n        while(m.find()){\n            count++;\n        }\n        System.out.println(count);\n    }','Strings',0,0,NULL,5),(3660,'1\n\nthe whole string is one big non word character so the greedy + took the whole\nthing','public static void main(String[] args){\n        Pattern p = Pattern.compile(\"\\\\W+\");\n        Matcher m = p.matcher(\"$%^&*\");\n        int count = 0;\n        while(m.find()){\n            count++;\n        }\n        System.out.println(count);\n    }','Strings',0,0,NULL,5),(3661,'1 2 followed by an exception','psvm(Sa){\n	String input = \"1 2 a 3 45 6\";	\n	Scanner sc = new Scanner(input);\n	int x = 0;\n	do {\n		x = sc.nextInt();\n		sout(x);	\n	} while(x!=0);\n}','General',0,0,NULL,5),(3662,' When the syntax is \"glob\" then the String representation of the path is matched using a limited pattern language that resembles regular expressions but with a simpler syntax. For example:\n\n    *.java 	Matches a path that represents a file name ending in .java\n    *.* 	Matches file names containing a dot\n    *.{java,class} 	Matches file names ending with .java or .class\n    foo.? 	Matches file names starting with foo. and a single character extension\n    /home/*/* 	Matches /home/gus/data on UNIX platforms\n    /home/** 	Matches /home/gus and /home/gus/data on UNIX platforms\n    C:\\\\* 	Matches C:\\foo and C:\\bar on the Windows platform (note that the backslash is escaped; as a string literal in the Java Language the pattern would be \"C:\\\\\\\\*\")\n\nThe following rules are used to interpret glob patterns:\n\n    The * character matches zero or more characters of a name component without crossing directory boundaries.\n\n    The ** characters matches zero or more characters crossing directory boundaries.\n\n    The ? character matches exactly one character of a name component.\n\n    The backslash character (\\) is used to escape characters that would otherwise be interpreted as special characters. The expression \\\\ matches a single backslash and \"\\{\" matches a left brace for example.\n\n    The [ ] characters are a bracket expression that match a single character of a name component out of a set of characters. For example, [abc] matches \"a\", \"b\", or \"c\". The hyphen (-) may be used to specify a range so [a-z] specifies a range that matches from \"a\" to \"z\" (inclusive). These forms can be mixed so [abce-g] matches \"a\", \"b\", \"c\", \"e\", \"f\" or \"g\". If the character after the [ is a ! then it is used for negation so [!a-c] matches any character except \"a\", \"b\", or \"c\".\n\n    Within a bracket expression the *, ? and \\ characters match themselves. The (-) character matches itself if it is the first character within the brackets, or the first character after the ! if negating.\n\n    The { } characters are a group of subpatterns, where the group matches if any subpattern in the group matches. The \",\" character is used to separate the subpatterns. Groups cannot be nested.\n\n    Leading period/dot characters in file name are treated as regular characters in match operations. For example, the \"*\" glob pattern matches file name \".login\". The Files.isHidden(java.nio.file.Path) method may be used to test whether a file is considered hidden.\n\n    All other characters match themselves in an implementation dependent manner. This includes characters representing any name-separators.\n\n    The matching of root components is highly implementation-dependent and is not specified.\n\nWhen the syntax is \"regex\" then the pattern component is a regular expression as defined by the Pattern class.\n\nFor both the glob and regex syntaxes, the matching details, such as whether the matching is case sensitive, are implementation-dependent and therefore not specified.','Glob rules','Strings',0,0,NULL,5),(3663,'Exception in thread \"main\" java.lang.IllegalArgumentException\n\ngetPathMatcher() argument must take the form:\n\n	syntax:pattern\n\nspecify glob or regex ','public class Hello {\n    public static void main(String[] args) {\n        PathMatcher matcher = FileSystems.getDefault().getPathMatcher(\"*\");\n        Path p1 = Paths.get(\"One.java\");\n        \n        System.out.println(matcher.matches(p1));\n\n    }\n\n}','Strings',0,0,NULL,5),(3664,'false, \nthe space after \'glob:\' matters. \n\nto give expected behavior take that space away.','public class Hello {\n    public static void main(String[] args) {\n        PathMatcher matcher = FileSystems.getDefault().getPathMatcher(\"glob: *\");\n        Path p1 = Paths.get(\"One.java\");\n        \n        System.out.println(matcher.matches(p1));\n\n    }\n\n}','Strings',0,0,NULL,5),(3665,'true,\n\nin glob * means any string inside directory bounds','public class Hello {\n    public static void main(String[] args) {\n        PathMatcher matcher = FileSystems.getDefault().getPathMatcher(\"glob:*\");\n        Path p1 = Paths.get(\"One.java\");\n        \n        System.out.println(matcher.matches(p1));\n\n    }\n\n}','Strings',0,0,NULL,5),(3666,'p1 could be:\n\"glob:*\" \"glob:**\" \"glob:*.{java,class}\" \"glob:One.????\"\n\n ','public class Hello {\n    public static void main(String[] args) {\n        PathMatcher matcher = FileSystems.getDefault().getPathMatcher(\"glob:\");\n        Path p1 = Paths.get(\"One.java\");\n        Path p2 = Paths.get(\"/home/Files/two.txt\");\n        Path p3 = Paths.get(\"/home/Pictures/amy1.pic\");\n        \n        System.out.println(matcher.matches(p1));\n        System.out.println(matcher.matches(p2));\n        System.out.println(matcher.matches(p3));\n\n    }\n\n}\ncreate a glob to match each of these paths','Strings',1,0,NULL,5),(3667,'true\ntrue\ntrue\n\nin a bracketed expression * ? and / match themselves\n\n* matches anything within a directory boundary','public class Hello {\n    public static void main(String[] args) {\n        PathMatcher matcher = FileSystems.getDefault().getPathMatcher(\"glob:*{*txt,*pic,/dir}\");\n        Path p1 = Paths.get(\"files.*txt\");\n        Path p2 = Paths.get(\"pictures.*pic\");\n        Path p3 = Paths.get(\"home/dir\");\n        \n        System.out.println(matcher.matches(p1));\n        System.out.println(matcher.matches(p2));\n        System.out.println(matcher.matches(p3));\n    }\n\n}','Strings',0,0,NULL,5),(3668,'false \nfalse\ntrue\n\n* doesn\'t work accross directory bounds ','public class Hello {\n    public static void main(String[] args) {\n        PathMatcher matcher = FileSystems.getDefault().getPathMatcher(\"glob:*{*txt,*pic,/dir}\");\n        Path p1 = Paths.get(\"home/files.*txt\");\n        Path p2 = Paths.get(\"documents/pictures.*pic\");\n        Path p3 = Paths.get(\"home/dir\");\n        \n        System.out.println(matcher.matches(p1));\n        System.out.println(matcher.matches(p2));\n        System.out.println(matcher.matches(p3));\n    }\n\n}','Strings',0,0,NULL,5),(3669,'will not compile the proper syntax is:\n\n	FileSystems.getDefault().getPathMatcher()','public class Hello {\n    public static void main(String[] args) {\n        PathMatcher matcher = FileSystems.getPathMatcher(\"glob:*{*txt,*pic,/dir}\");\n        Path p1 = Paths.get(\"home/files.*txt\");\n        Path p2 = Paths.get(\"documents/pictures.*pic\");\n        Path p3 = Paths.get(\"home/dir\");\n        \n        System.out.println(matcher.matches(p1));\n        System.out.println(matcher.matches(p2));\n        System.out.println(matcher.matches(p3));\n    }\n\n}','Strings',0,0,NULL,5),(3670,'you can also do this to use regex instead of glob.\n\nhere they would all say \'true\'','public class Hello {\n    public static void main(String[] args) {\n        PathMatcher matcher = FileSystems.getDefault().getPathMatcher(\"regex:.*\");\n        Path p1 = Paths.get(\"home/files.*txt\");\n        Path p2 = Paths.get(\"documents/pictures.*pic\");\n        Path p3 = Paths.get(\"home/dir\");\n        \n        System.out.println(matcher.matches(p1));\n        System.out.println(matcher.matches(p2));\n        System.out.println(matcher.matches(p3));\n    }\n\n}','Strings',0,0,NULL,5),(3671,'will not compile, \n\nGazer is declared after it is used in a method,thats not allowed move it to before','public class Hello {\n	private int size = 7;\n	private static int length = 3;\n	public static void main(String[] args) {\n		new Hello().go();\n	}\n	void go(){\n		int size = 5;\n                 System.out.println(new Gazer().adder());\n                 \n                 class Gazer {\n                     private int size = 6;\n                      int adder() { return size * length; }\n                }\n	}\n	\n}','Strings',0,0,NULL,5),(3672,'WNC,  \n\nlocal variable size is accessed from within inner class needs to be final,\n\n\n	','public class Hello {\n	private int size = 7;\n	private static int length = 3;\n	public static void main(String[] args) {\n		new Hello().go();\n	}\n	void go(){\n		int size = 5;\n                class Gazer {\n                      int adder() { return size * length; }\n                }\n                 System.out.println(new Gazer().adder());\n	}\n}','Strings',0,0,NULL,5),(3673,'21\n\nnothing wrong here, instances can access statics just not the other way around!','public class Hello {\n	private int size = 7;\n	private static int length = 3;\n	public static void main(String[] args) {\n		new Hello().go();\n	}\n	void go(){\n                class Gazer {\n                      int adder() { return size * length; }\n                }\n                 System.out.println(new Gazer().adder());\n	}\n}','Inner Classes',0,0,NULL,5),(3674,'WNC\n\nsuper to bound a named type parameter (e.g. <S super T>) as opposed to a wildcard (e.g. <? super T>) is ILLEGAL simply because even if it\'s allowed, it wouldn\'t do what you\'d hoped it would do, because since Object is the ultimate super of all reference types, and everything is an Object, in effect there is no bound.\n\nIn your specific example, since any array of reference type is an Object[] (by Java array covariance), it can therefore be used as an argument to <S super T> S[] toArray(S[] a) (if such bound is legal) at compile-time, and it wouldn\'t prevent ArrayStoreException at run-time.\n\nWhat you\'re trying to propose is that given:\n\nList<Integer> integerList;\n\nand given this hypothetical super bound on toArray:\n\n<S super T> S[] toArray(S[] a) // hypothetical! currently illegal in Java\n\nthe compiler should only allow the following to compile:\n\nintegerList.toArray(new Integer[0]) // works fine!\nintegerList.toArray(new Number[0])  // works fine!\nintegerList.toArray(new Object[0])  // works fine!\n\nand no other array type arguments (since Integer only has those 3 types as super). That is, you\'re trying to prevent this from compiling:\n\nintegerList.toArray(new String[0])  // trying to prevent this from compiling\n\nbecause, by your argument, String is not a super of Integer. However, Object is a super of Integer, and a String[] is an Object[], so the compiler still would let the above compile, even if hypothetically you can do <S super T>!\n\nSo the following would still compile (just as the way they are right now), and ArrayStoreException at run-time could not be prevented by any compile-time checking using generic type bounds:\n\nintegerList.toArray(new String[0])  // compiles fine!\n// throws ArrayStoreException at run-time\n\nGenerics and arrays don\'t mix, and this is one of the many places where it shows.\nA non-array example\n\nAgain, let\'s say that you have this generic method declaration:\n\n<T super Integer> void add(T number) // hypothetical! currently illegal in Java\n\nAnd you have these variable declarations:\n\nInteger anInteger\nNumber aNumber\nObject anObject\nString aString\n\nYour intention with <T super Integer> (if it\'s legal) is that it should allow add(anInteger), and add(aNumber), and of course add(anObject), but NOT add(aString). Well, String is an Object, so add(aString) would still compile anyway.','public class Hello<T> {\n    \n    public static void main(String[] args){\n        \n        Dog d = new Dog();\n        \n        ArrayList<?> c = makeArrayList(new Animal());\n        \n\n    } \n    public static <G super Dog> ArrayList<G> makeArrayList(G g){\n        ArrayList<G> genlist = new ArrayList<>();\n        genlist.add(g);\n        return genlist;\n        \n    }\n}\n\nclass Animal{}\nclass Dog extends Animal{}','Generics',0,0,NULL,5),(3675,'try{\n\n}catch(Exception1 | Exception2 e) {\n\n	e = new Exception1();\n}\n\nTHIS WOULD FAIL COMPILATION\n\n','When using multi-catch, the catch block parameter is final and cannot \nhave a new value assigned to it in the catch block.\n\ntry{\n\n} catch(SQLException | IOException e){\n	\n	e = new IOException();\n}\n\n// this shows why thats illegal, your not sure which exception type \nwill come through.\n//updated 2','Exceptions',0,0,NULL,5),(3676,'javac -source 1.3 OldCode.java\n\njavac -source 1.4 NewCode.java','To compile old code that may use \'assert\' as an identifier, \nadd 1.3. This will tell the compiler to treat the word \'assert\' as an identifier.\n\n1.4 will use \'assert\' as a keyword	','Exceptions',0,0,NULL,5),(3677,'java -da com.maxbisesi.Test\n\njava -disableassertions com.maxbisesi.Test','Disable assertions at runtime		','Exceptions',0,0,NULL,5),(3678,'This is a bad idea...\n\npublic void doStuff(){\n	assert (modifyThings());\n	//continue\n}\n\npublic boolean modifyThings() {\n	y = x++;\n	return true;\n}','Dont use assert expressions that can cause side effects...','Exceptions',0,0,NULL,5),(3679,'Fails compilation','You cant use the variable name multiple times in a multi-catch. \nThe following wont compile...\n\ncatch(Exception1 e1 | Exception2 e2){\n\n}','Exceptions',0,0,NULL,5),(3680,'the following are equivalent:\n\ncatch(SQLException | IOException e)\n\ncatch(IOException | SQLException e)','With Multi catch order does NOT matter...		','Exceptions',0,0,NULL,5),(3681,'The following will not compile...\n\ncatch(FileNotFoundException | IOException e)\n\nsince FILNOTFOUND is a subclass of IOException we could have just\nwrtten that in the first place..\n\ncatch(IOException)','With Multi-Catch you have to make sure a given excpetion can only\nmatch one type...\n\ncatch(IOException | SQLException e)\n\nthese two are different types.','Exceptions',0,0,NULL,5),(3682,'This is legal but it is not good practice. It is illegal to reasign the value\nof a multi-catch parameter. \n\ntry {\n	\n} catch(SQLException | IOException e){\n\n	e = new IOException();\n}\n\n^^WILL NOT COMPILE\n','Legal or illegal...\n\ntry {\n	//do something\n} catch(IOException e){\n	\n	e = new IOException();\n}','Exceptions',0,0,NULL,5),(3683,'Will not compile, it is legal to reassign the parameter here. But it is illegal\nto throw e. The method declares that it throws SQL and IO so throwing a \ngeneral exception is unreported. \n\nif the signature was throws Exception then everything would be fine\n\nException as a genreal','public void couldthrow() throws SQLException, IOException { }\n\npublic void rethrow() throws SQLException, IOException {\n	try{\n		couldthrow();\n	} catch(Exception e){ \n		e = new IOException();\n		throw e;\n	}\n}	','Exceptions',0,0,NULL,5),(3684,'Illegal, regular trys have to have a catch or a finally\n\ntry-with can be used by themselves','legal or illegal\n\ntry {\n\n}','Exceptions',0,0,NULL,5),(3685,'does not compile. \nto be declared in a try with the method has to implement auto closeable or\ncloseable','try(String s = \"hi\") {}','Exceptions',0,0,NULL,5),(3686,'will not compile,\nThe declared resources use a commma , not a semi colon ;\n\nshould be:\n\ntry(Resource r = new Resource(); ...','Path p = Paths.get(\"/home/maxbisesi\");\n      try(BufferedReader br = new BufferedReader(new FileReader(p.toFile())), BufferedWriter bw = new BufferedWriter(new FileWriter(p.toFile()))){\n          \n      } catch(IOException e){\n          \n      }','Exceptions',0,0,NULL,5),(3687,'ok, AutoCloseable interface allows throwing any Exception','Class A implements AutoCloseable { \n	public void close() throws Exception {}\n}	','Exceptions',0,0,NULL,5),(3688,'ok sublcasses or implenting methods can throw a subclass of excpetion\nor none at all.\n\nAutoCloseable\'s  close throws an Exception','class B implements AutoCloseable { public void close() {}}\nclass C implements AutoCloseable { public void close() throws IOException {}}','Exceptions',0,0,NULL,5),(3689,'ILLEGAL- Closeable only allows IOExceptions or subclasses','class D implements Closeable { public void close() throws Exception{}}','Exceptions',0,0,NULL,5),(3690,'ok Closeable allows throwing IOExceptions\n\nvoid close() throws IOException','class E implements Closeable { public void close() throws IOException {}}','Collections',0,0,NULL,5),(3691,'you can call close() multiple times all day and nothing will happen the second time and beyond. \nwill not blow up. ','idempotent','Exceptions',0,0,NULL,5),(3692,'nothing bad will happen if you call close() more than one time. ','AutoCloseable\'s close() is idempotent	','Exceptions',0,0,NULL,5),(3693,'might blow up if called more than once','Closeable\'s close() is not idempotent','Exceptions',0,0,NULL,5),(3694,'B\nA\ncatch\n\nResources are closed in reverse order from what they are declared.','class A implements AutoCloseable {\n	public void close() {\n		sout(\"A\");\n	}\n}\n\nclass B implements AutoCloseable {\n	public void close() {\n		sout(\"B\");\n	}\n}\n\nclass C {\n	psvm(sa){\n		try(A a = new A(); B b = new B()){\n			throw new RuntimeException();\n		} catch(EXception e) {\n			sout(\"catch\");\n		}\n	}\n}\n\nwhat does it print?','Exceptions',0,0,NULL,5),(3695,'Try\nsuppressed: java.io.IOException: Closing\n\nafter the exception in the try block gets thrown on line 4, the try with \nresources still calls close() and the catch block catches one \nof the exceptions.\n\nJava adds any excpeittions thrown by close() methods to a suppressed array in the main excpetion. \n\nif no other exception happens in the try block the exceptioon thrown in\nclose() gets treated as the main excpetion  for the catch block. ','public class Suppressed {\n	psvm(sa) {\n		try(One one = new One()) {\n			throw new exception(\"try\");\n		} catch (Exception e) {\n			sout(e.getMessage());\n			\n			for(Throwable t : e.getSuppressed()){\n				sout(\"suppressed:\" + t);\n		}	}\n	}\n}\n\nclass One implements AutoCloseable {\n	public void close() throws IOException {\n		throw new IOException(\"Closing\");\n	}\n}','Exceptions',0,0,NULL,5),(3696,'got it ','If the catch or Finally block throws an exception NO SUPPRESSION HAPPENS\nthe last exception thrown gets sent to the caller rather than the one from the \ntry- just like before try with resources','Exceptions',0,0,NULL,5),(3697,'Closing - 2\nsuppressed: java.io.IOException: Closing - 1\n\nresources close in the opposite order they are declared','class Bad implements AutoCloseable {\n	String name;\n	Bad(String n) { name = n; }\n	public void close() throws IOException {\n		throw new IOException(\"Closing -\" +name);\n	}\n}\n\npublic class Suppressed {\n	public static void main(SA) {\n		try(Bad b1 = new Bad(\"1\"); Bad b2 = new Bad(\"2\")) {\n			\n		} catch(Exception e) {\n			sout(e.getMessage());\n			for(Throwable t : e.getSuppressed()) {\n				sout(\"suppressed:\" + t);\n			}\n		}\n	}\n}','Exceptions',0,0,NULL,5),(3698,'Since all file IO on the exam is related to characters, if you see a Stream\nlike DataOutputStream the the question is probably about serialization\nor something unrelated to the actual IO objective','Stream classes are used to read and write bytes, and Readers and Writers\nare used to read write Characters....','IO',0,0,NULL,5),(3699,'// first time\nfalse\ntrue \ntrue\n\n//second time\ntrue\nfalse\ntrue\n\nexists returns false the first time becasue the file was created as an object\nbut not yet as a physical file. ','psvm(SA) {\n	try {\n		boolean newFile = false;\n		File file = new File(\"fiileWrite1.txt\");\n		sout(file.exists());\n		newFile = file.createNewFile());\n		sout(newFile);\n		sout(file.exists());\n	} catch (IOException e) {}\n}	','IO',0,0,NULL,5),(3700,'This method returns true if it can find the actual file\n\nfalse\ntrue\n\n	the first time it is run','public static void main(String[] args){\n        File newFile = new File(\"/home/maxbisesi/Public/textFile5.txt\");\n        try{\n            System.out.println(newFile.exists());\n            newFile.createNewFile();\n            System.out.println(newFile.exists());\n        } catch(IOException e){\n            \n        }   \n    }','IO',0,0,NULL,5),(3701,'true if the named file does not exist and was successfully created; false if the named file already exists\n','File method: \ntry {\n	createNewFile();\n} catch(IOException e) { } ','IO',0,0,NULL,5),(3702,'File(File parent, String child)\nCreates a new File instance from a parent abstract pathname and a child pathname string.\n\nFile(String pathname)\nCreates a new File instance by converting the given pathname string into an abstract pathname.\n\nFile(String parent, String child)\nCreates a new File instance from a parent pathname string and a child pathname string.','File class Constructors	','IO',0,0,NULL,5),(3703,'createNewFile()\ndelete()\nexists()\nisDirectory()\nisfile()\nlist()\nmkdir()\nrenameTo()','File class key methods ','IO',0,0,NULL,5),(3704,'FileWriter(File file)\n\nFileWriter(String filename)','FileWriter class Constructors	','IO',0,0,NULL,5),(3705,'close()\nflush()\nwrite()','FileWriter class key methods 	','IO',0,0,NULL,5),(3706,'BufferedWriter(Writer out)','BufferedWriter class constructors	','IO',0,0,NULL,5),(3707,'close() \nflush()\nnewLine()\nwrite()','BufferedWriter key methods	','IO',0,0,NULL,5),(3708,'PrintWriter(File file)\nCreates a new PrintWriter, without automatic line flushing, with the specified file.\n\nPrintWriter(File file, String csn)\nCreates a new PrintWriter, without automatic line flushing, with the specified file and charset.\n\nPrintWriter(OutputStream out)\nCreates a new PrintWriter, without automatic line flushing, from an existing OutputStream.\n\nPrintWriter(OutputStream out, boolean autoFlush)\nCreates a new PrintWriter from an existing OutputStream.\n\nPrintWriter(String fileName)\nCreates a new PrintWriter, without automatic line flushing, with the specified file name.\n\nPrintWriter(String fileName, String csn)\nCreates a new PrintWriter, without automatic line flushing, with the specified file name and charset.\n\nPrintWriter(Writer out)\nCreates a new PrintWriter, without automatic line flushing.\n\nPrintWriter(Writer out, boolean autoFlush)\nCreates a new PrintWriter.','PrintWriter constructors','IO',0,0,NULL,5),(3709,'read()','FileReader key methods 	','IO',0,0,NULL,5),(3710,'Reader','BufferedReader constructors	','IO',0,0,NULL,5),(3711,'read()\nreadLine()','BufferedReader key methods','IO',0,0,NULL,5),(3712,'filewrite2.txt would contain the text:\n\nhello\nworld','File file = new file(\"filewriter2.txt\");\nFileWriter fw = new fileWriter(file);\n\nPrintWriter pw = new PrintWriter (fw);\n\npw.println(\"hello\");\npw.println(\"world\"));','IO',0,0,NULL,5),(3713,'','File file = new File(\"filewrite2.txt\");\nFileReader fr = new FileReader(file);\nBufferedReader br = new BufferedReader(fr);\n\nString data = br.readLine();','IO',0,0,NULL,5),(3714,'got it ','File file = new File(\"foo\");\n\nif \"foo\" does not exist no actual file is created.\n\nif \"foo\" does exists, the new File object refers to the existing file. ','IO',0,0,NULL,5),(3715,'io','readers dont have flush methods','IO',0,0,NULL,5),(3716,'a char[]','Console.readPassword() returns...','IO',0,0,NULL,5),(3717,'Returns the path element corresponding to the specified index.\n\nthe 0th element is the one closest to the root.','Path Method:\n\nPath getName(int index)','IO',0,0,NULL,5),(3718,'returns the filename or the last element of the sequence of name elements\n\nor..\n\nReturns the name of the file or directory denoted by this path as a Path object. The file name is the farthest element from the root in the directory hierarchy.','Path Method:\n\nString getFileName()','IO',0,0,NULL,5),(3719,'4','public class Hello {\n    public static void main(String[] dicks) throws IOException{\n      Path src = Paths.get(\"/home/maxbisesi/Documents/copy.txt\");\n\n      System.out.println(src.getNameCount());\n      \n    }\n\n}','IO',0,0,NULL,5),(3720,'\n/home/maxbisesi/Documents','\npublic class Hello {\n    public static void main(String[] dicks) throws IOException{\n      Path src = Paths.get(\"/home/maxbisesi/Documents/copy.txt\");\n      Path srcParent = src.getParent();\n      System.out.println(srcParent);\n      \n    }\n\n}','IO',0,0,NULL,5),(3721,'retunrs the root of thsi path, or null if this path does not have a root.','Path Method:\n\nPath getRoot()		','IO',0,0,NULL,5),(3722,'returns a ssubsequence of this path NOT INCLUDING ROOT. \n\nbeginning INCLUSIVE\n\nending EXCLUSIVE','Path Method:\n\nPath subpath(int beginindex, int endIndex)','IO',0,0,NULL,5),(3723,'that means it can be iterated through in a for loop!','Path extends from Iterable<Path>	','IO',0,0,NULL,5),(3724,'tmp/dir1/dir2/dir3/file.txt','int spaces = 1;\nPath myPath = Paths.get(\"tmp\", \"dir1\", \"dir2\", \"dir3\", \"file.txt\");\n\nfor(Path subpath : myPath){\n	sout( subpath + \"//\" );\n}','IO',0,0,NULL,5),(3725,'returns a path that is this path with redundant name elements eliminated\n\n. can be ignored\n\n.. followed by a directory can be removed as redundant','Path method:\n\nPath normalize()	','IO',0,0,NULL,5),(3726,'/a/b/c','Paths.get(\"/a/./b/./c\").normalize();\n','IO',0,0,NULL,5),(3727,'.classpath','Paths.get(\".classpath\").normalize();','IO',0,0,NULL,5),(3728,'/a/b','Paths.get(\"/a/b/c/..\").normalize()','IO',0,0,NULL,5),(3729,'../a/b/c\n\nThe two dots do say go up one directory, but since there is\'nt a directory\nbefore it Path cant simplify it.','Paths.get(\"../a/b/c\").normalize()','IO',0,0,NULL,5),(3730,'/home/java/models/Model.pdf\n\npath1.resolve(path2) should be read as \"resolve path2 within path1s directory\n','Path dir = Paths.get(\"/home/java\");\nPath file = Paths.get(\"models/Model.pdf\");\nPath result = dir.resolve(file);\n\nsout( result );\n	','IO',0,0,NULL,5),(3731,'/google\n\nResolve the given path against this path.\n\nIf the other parameter is an absolute path then this method trivially returns other.\n If other is an empty path then this method trivially returns this path.\n Otherwise this method considers this path to be a directory and resolves\n the given path against this path. In the simplest case, the given path does not have a root component, \nin which case this method joins the given path to this path \nand returns a resulting path that ends with the given path.','class Hello {\n    public static void main(String[] args) {     \n        Path p1 = Paths.get(\"/home/max/tmp\");\n        Path p2 = Paths.get(\"/google\");\n        System.out.println(p1.resolve(p2));\n        \n    }\n\n}','IO',0,0,NULL,5),(3732,'/home/java/dir\n/home/java/Model.pdf\n/dir/Model.pdf\n/home/java\n/home/java\nModel.pdf/dir\n\nThe first three do what you would exprect. They add the paramenter\nto resolve to the provided path object. The fourth and fifth try to resolve\nan absolute path within the context of something else. The problem is \nthat an aboluste path doesnt\'t depend on other directories it is absolute.\n','Path absolute = Paths.get(\"/home/java\");\nPath relative = Paths.get(\"dir\");\nPath file = Paths.get(\"Model.pdf\");\n\nsout( absolute.resolve(relative) );\nsout( asolute.resolve(file) );\nsout( relative.resolve(file) );\nsout( relative.resolve(absolute) ); // BAD\nsout( file.resolve(absolute) ); //BAD\nsout( file.resolve(relative) ); //BAD','IO',0,0,NULL,5),(3733,'Thhe compilere cannot decide here so it will not compile','Be carefule with questions that come in two flavors. one with a Path parameter\nand the other with a String parameter such as resolve()...\n\nPath path = Paths.get(\"/usr/bin/zip\");\npath.resolve(null);','IO',0,0,NULL,5),(3734,'resolve()','Which Path method is used to combine two paths and set one in another?','IO',0,0,NULL,5),(3735,'relativize()','Which Path method is used to describe how to gret from one path to \nthe other	','IO',0,0,NULL,5),(3736,'country/Swift.mp3\n\n\njava recognized that the /home/java part is the same and returned a path of\njust the remainder.\n\npath1.relativize(path2) should be read as \"give me a path shows how to get from\npath1 to path2\"','Path dir = Paths.get(\"/home/java\");\nPath music = Paths.get(\"/home/java/country/Swift.mp3\");\nPath mp3 = dir.reltivize(music);\n\nsout( mp3 );','IO',0,0,NULL,5),(3737,'.relativize()','\"give me a path shows how to get from\npath1 to path2\"','IO',0,0,NULL,5),(3738,'temp/music.mp3\n\n../..\n\n../../usr/local\n\nmusic.pdf\n\nExcpetion in main thread IllegalArgumentExcpetion\n\n	','Path absolute1 = Paths.get(\"/home/java\");\nPath absolute2 = Paths.get(\"/usr/local\");\nPath absolute3 = Paths.get(\"/home/java/temp/music.mp3\");\nPath relative1 = Paths.get(\"temp\");\nPath relative2 = Paths.get(\"temp/music.pdf\");\n\nsout( absolute1.relativize(absolute3) );\nsout( absolute3.relativize(absolute1) );\nsout( absolute1.relativize(absolute2) );\nsout( relative1.relativize(relative2) );\nsout( absolute1.relativize(relative1) ); //BAD','IO',0,0,NULL,5),(3739,'Path relativize(Path other)\n\nConstructs a relative path between this path and a given path.\n\nRelativization is the inverse of resolution. This method attempts to construct a relative path that when resolved against this path, yields a path that locates the same file as the given path. For example, on UNIX, if this path is \"/a/b\" and the given path is \"/a/b/c/d\" then the resulting relative path would be \"c/d\". Where this path and the given path do not have a root component, then a relative path can be constructed. A relative path cannot be constructed if only one of the paths have a root component. Where both paths have a root component then it is implementation dependent if a relative path can be constructed. If this path and the given path are equal then an empty path is returned.\n\nFor any two normalized paths p and q, where q does not have a root component,\n\n    p.relativize(p.resolve(q)).equals(q) \n\nWhen symbolic links are supported, then whether the resulting path, when resolved against this path, yields a path that can be used to locate the same file as other is implementation dependent. For example, if this path is \"/a/b\" and the given path is \"/a/x\" then the resulting relative path may be \"../x\". If \"b\" is a symbolic link then is implementation dependent if \"a/b/../x\" would locate the same file as \"/a/x\".\n\nParameters:\n    other - the path to relativize against this path\nReturns:\n    the resulting relative path, or an empty path if both paths are equal\nThrows:\n    IllegalArgumentException - if other is not a Path that can be relativized against this path','relativeize()','IO',0,0,NULL,5),(3740,'If this program is run from the root, it is the one in /tmp/file1.txt\n\nif it is run from /tmp it is the one in /tmp/tmp/file1.txt\n\nif the program is run from anywhere else the path refers to a file that doesn\nnot exist. ','When creating a Path you can seperate out folder and filename as much\nor as little as you want. When you don\'t begin with a root the Path\nis considered a relative path, which means Java looks from the current\ndirectory.\n\nPath p6 = Paths.get(\"tmp\", \"file1.txt\"); // relative path\n\n/ (root)\n	| - - tmp\n		| - file1.txt\n		| - tmp\n			| - file1.txt\n','IO',0,0,NULL,5),(3741,'got it ','With IO a file doesn\'t exists just because you create a File object.\nIt is the same with Path objects\n\nPath path = Paths.get(\"fileWrite1.txt\");\nsout(Files.exists(path)); // false\nFiles.createFile(path); \nsout(Files.exists(path)); // true','IO',0,0,NULL,5),(3742,'Path path1 = Paths.get(\"/java/source\");\nPath path2 = Paths.get(\"/java/source/directory\");\nPath file = Paths.get(\"/java/source/directory/Program.java\");\nFiles.createDirectory(path1);\nFiles.createDirectory(path2);\nFiles.createFile(file);\n\n// all at once\n\nFiles.createDirectories(path2);\nFile.createFile(file);','create directories one at a time or all at once	......\n\nTHE directory must exist by the time the file is created','IO',0,0,NULL,5),(3743,'13570164000000','Date januaryFirst = new GregorianCalendar(20q3, Calendar.January, 1).getTime();\n\nFile file = new File(\"c:/temp/file\");\nfile.createNewFile();\nfile.setLastModified(januaryFirst.getTime());\nfile.setLastModified(januaryFirst.getTime());\nsout(file.lastModified());\nfile.delete();','IO',0,0,NULL,5),(3744,'2013-01-01T05','Path path = Paths.get(\"c:/temp/file2\");\nDate januaryFirst = new GregorianCalendar(2013,Calendar.JANUARY, 1).getTime();\nFiles.createFile(path);\nFileTime fileTime = FileTime.fromMillis(januaryFirst.getTime());\nFiles.setLastModifiedTime(path,fileTime);\nsout(Files.getLastModifiedTime(path));\nFiles.delete((path);','IO',0,0,NULL,5),(3745,'\nfile.lastModified();\n\nFiles.getLastModifiedTime(path);','How would you get the last modified date/time of a Path and a File?\n\nFile file = new file(\"test\");\nPath path = Paths.get(\"test\");','IO',0,0,NULL,5),(3746,'A C D E F \n\nin an undeterminable order, although thread angela uses the max reference\n.Sleep is static and therefore she puts herself to sleep. This is why\nreferences shouldn\'t be used for static methods. \n\nmax trys to synchronize on angela but he does not own the lock so he therefore\ncannot and throws an IllegalMonitorStateException. \n\n... ','public class Hello {\n    static Thread max ,angela;\n    public static void main(String[] args){\n        angela = new Thread() {\n            public void run(){\n                System.out.println(\"A\");\n                try {\n                    max.sleep(1000);\n                } catch(Exception e){\n                    System.out.println(\"B\");\n                }\n                System.out.println(\"C\");\n                \n            }\n        };\n        \n        max = new Thread() {\n            public void run(){\n                System.out.println(\"D\");\n                try {\n                    angela.wait(); \n                } catch(Exception e){\n                    System.out.println(\"E\");\n                }\n                \n                System.out.println(\"F\");\n            }\n        };\n        \n        max.start();\n        angela.start();   \n    }\n} ','IO',0,0,NULL,5),(3747,'file.canRead();\n\nFiles.isReadable(path);','How would you get theread permision set of a Path and a File?\n\nFile file = new file(\"test\");\nPath path = Paths.get(\"test\");','IO',0,0,NULL,5),(3748,'file.canWrite();\nfile.canExecute();\n\nFiles.isWritable(path);\nFiles.isExecutable(path);','How would you get write and or execute permision set of a Path and a File?\n\nFile file = new file(\"test\");\nPath path = Paths.get(\"test\");','IO',0,0,NULL,5),(3749,'file.setLastModifed(timeinMillis);\n\nFileTime ft = FileTime.fromMillis(timeInMillis);\nFiles.setLastModifiedTime(path,ft);','How do you set the last modified time of a path and file?\n\nFile file = new file(\"test\");\nPath path = Paths.get(\"test\");','IO',0,0,NULL,5),(3750,'basic.creationTime();\nbasic.lastAccessTime();\nbasick.lastModifiedTime();\n\nbasic.isDirectory();\n\n','BasicFileAttributes basic = Files.readAttributes(path, BasicFileAttributes.class);\n\nhow would you list the creation time, last access time, and last Modified time?	\n','IO',0,0,NULL,5),(3751,'1. BasicFileAttributes is PLURAL, BasicFileAttributeVIew is SINGULAR\n\n2. BasicFIleAttributeView basView = Files.getFileAttributeView(   );   \n\n	BasicFileAtttributes bas = FIles.readAttributes(   );\n\n3. You can ONLY update attributes in BasicFileAttributeView, \n	\n	VIEW IS FOR UPDATING','Three big things about BasicFileAttributes and BasicFileAttributeView...','IO',0,0,NULL,5),(3752,'PosixFileAttributes pox = Files.readAttributes(path, PosixFileAttributes.class);\n','How would you construct a PosixFileAttribute object?	','IO',0,0,NULL,5),(3753,'Path path = Paths.get(\"/tmp/file2\");\nFiles.createFile(path);\nPosixFileAttributes ps = Files.readAttributes(path, PosixFileAttributes.class);\n\nSet<PosixFilePermission> perms = PosixFilePermission.fromString(\"rw-r--r--\");\n\nFiles.setPosixFilePermissions(path,perms);\n\nsout( ps.permissions() );\n\nTHe output would be:\n\n[OWNER_WRITE, GROUP_READ, OTHERS_READ, OWNER_READ ]','How would you set a Unix File\'s permissions in Java?	','IO',0,0,NULL,5),(3754,'BasicFileAttributes basic = Files.readAttributes(path1, BasicFileAttribute.class );\n\nFileTime at = basic.lastAccessTime();\nFileTime update = basic.lastModifiedTime();\nFileTime now = FileTime.fromMillis(System.currentTimeMiilis() );\n\nPath file = Paths.get(\"/temp/file.txt\");\nFiles.createFile(file);\n\nBasicFileAttributeView view = Files.getBasicFileAttributeView(file, BasicFileAttributeView.class);\n\nview.setTimes(update, at, now);','How to take modified times from one file\nand write new BasicFileAttributes\' last modified times\nlast access time and creation time to another file ... ?','IO',0,0,NULL,5),(3755,'... interface\n\nmethods:\n\nString 	name()\nReturns the name of the attribute view.\n\nBasicFileAttributes 	readAttributes()\nReads the basic file attributes as a bulk operation.\n\nvoid 	setTimes(FileTime lastModifiedTime, FileTime lastAccessTime, FileTime createTime)\n\nUpdates any or all of the file\'s last modified time, last access time, and create time attributes.','BasicFileAttributeView is a...\n\nClass\n\nInterface\n\nAbstract class     ?','IO',0,0,NULL,5),(3756,'FileTime 	creationTime()\nReturns the creation time.\n\nObject 	fileKey()\nReturns an object that uniquely identifies the given file, or null if a file key is not available.\n\nboolean 	isDirectory()\nTells whether the file is a directory.\n\nboolean 	isOther()\nTells whether the file is something other than a regular file, directory, or symbolic link.\n\nboolean 	isRegularFile()\nTells whether the file is a regular file with opaque content.\n\nboolean 	isSymbolicLink()\nTells whether the file is a symbolic link.\n\nFileTime 	lastAccessTime()\nReturns the time of last access.\n\nFileTime 	lastModifiedTime()\nReturns the time of last modification.\n\nlong 	size()\nReturns the size of the file (in bytes).','interface BasicFileAttributes methods.... ','IO',0,0,NULL,5),(3757,'GroupPrincipal 	group()\nReturns the group owner of the file.\n\nUserPrincipal 	owner()\nReturns the owner of the file.\n\nSet<PosixFilePermission> 	permissions()\nReturns the permissions of the file.','interface PosixFileAttributes methods','IO',0,0,NULL,5),(3758,'String 	name()\nReturns the name of the attribute view.\n\nPosixFileAttributes 	readAttributes()\nReads the basic file attributes as a bulk operation.\n\nvoid 	setGroup(GroupPrincipal group)\nUpdates the file group-owner.\n\nvoid 	setPermissions(Set<PosixFilePermission> perms)\nUpdates the file permissions.','interface PosixFileAttributeView methods ...','IO',0,0,NULL,5),(3759,'DosFileAttributeView has methods...\n\nsetArchive()\nsetHidden()\nsetReadOnly()\nsetSystem()\n\nfor Windows specific files ','With DosFileAttributeView you can set what new and different file types ?','IO',0,0,NULL,5),(3760,'String 	name()\nReturns the name of the attribute view.\n\nDosFileAttributes 	readAttributes()\nReads the basic file attributes as a bulk operation.\n\nvoid 	setArchive(boolean value)\nUpdates the value of the archive attribute.\n\nvoid 	setHidden(boolean value)\nUpdates the value of the hidden attribute.\n\nvoid 	setReadOnly(boolean value)\nUpdates the value of the read-only attribute.\n\nvoid 	setSystem(boolean value)\nUpdates the value of the system attribute.','interface DosFileAttributeView methods...','IO',0,0,NULL,5),(3761,'DosFileAttributes dos = Files.readAttributes(path, DosFileAttributes.class);\n\nsout( dos.isHidden() );\nsout( dos.isReadOnly() );\n\nFiles.setAttribute(path, \"dos:hidden\", true);\nFiles.setAttribute(path, \"dos:readonly\", true);\n\n','read a DosFileAttributes then declare if it is hidden and readonly \nthen set them so without using a DosFileAttributeView...','IO',0,0,NULL,5),(3762,'\n    setAttribute\n\n    public static Path setAttribute(Path path,\n                    String attribute,\n                    Object value,\n                    LinkOption... options)\n                             throws IOException\n\n    Sets the value of a file attribute.\n\n    The attribute parameter identifies the attribute to be set and takes the form:\n\n        [view-name:]attribute-name \n\n    where square brackets [...] delineate an optional component and the character \':\' stands for itself.\n\n    view-name is the name of a FileAttributeView that identifies a set of file attributes. If not specified then it defaults to \"basic\", the name of the file attribute view that identifies the basic set of file attributes common to many file systems. attribute-name is the name of the attribute within the set.\n\n    The options array may be used to indicate how symbolic links are handled for the case that the file is a symbolic link. By default, symbolic links are followed and the file attribute of the final target of the link is set. If the option NOFOLLOW_LINKS is present then symbolic links are not followed.\n\n    Usage Example: Suppose we want to set the DOS \"hidden\" attribute:\n\n        Path path = ...\n        Files.setAttribute(path, \"dos:hidden\", true);\n     \n\n    Parameters:\n        path - the path to the file\n        attribute - the attribute to set\n        value - the attribute value\n        options - options indicating how symbolic links are handled\n    Returns:\n        the path parameter\n    Throws:\n        UnsupportedOperationException - if the attribute view is not available\n        IllegalArgumentException - if the attribute name is not specified, or is not recognized, or the attribute value is of the correct type but has an inappropriate value\n        ClassCastException - if the attribute value is not of the expected type or is a collection containing elements that are not of the expected type\n        IOException - if an I/O error occurs\n        SecurityException - In the case of the default provider, and a security manager is installed, its checkWrite method denies write access to the file. If this method is invoked to set security sensitive attributes then the security manager may be invoked to check for additional permissions.\n\n','You dont always need a XXXFileAttributeView object in order to change\na files attributes, you can just as easily do so with \"Files\" ...\n	','IO',0,0,NULL,5),(3763,'Files.setPosixFilePermissions\n\npublic static Path setPosixFilePermissions(Path path,\n                           Set<PosixFilePermission> perms)\n                                    throws IOException\n\nSets a file\'s POSIX permissions.\n\nThe path parameter is associated with a FileSystem that supports the PosixFileAttributeView. This attribute view provides access to file attributes commonly associated \nwith files on file systems used by operating systems that implement the Portable \nOperating System Interface (POSIX) family of standards.\n\nParameters:\n    path - A file reference that locates the file\n    perms - The new set of permissions\nThrows:\n    UnsupportedOperationException - if the associated file system does not support the PosixFileAttributeView\n    ClassCastException - if the sets contains elements that are not of type PosixFilePermission\n    IOException - if an I/O error occurs\n    SecurityException - In the case of the default provider, and a security manager is installed, it denies RuntimePermission(\"accessUserInformation\") or its checkWrite method denies write access to the file.','You dont need PosixFileAttributeView to set a file permissions either...','IO',0,0,NULL,5),(3764,'PosixFileAttributes pos = Files.readAttributes(path, PosixFileAttributes.class);\nSet<PosixFilePermissions> perms = PosixFilePermissions.fromString(\"rw-r--r--:);\n\nFiles.setPosixFilePermissions(path,perms);\n\nsout(pos.group());\nsout(pos.permissions());','How to set a linux files permisions from a string ?\n	','IO',0,0,NULL,5),(3765,'DirectoryStream<T> \n\nT is the element returned by the iterator. \n\nTHis allows for the convieninet use of a for - each loop to go through a dir.\n\nThe elements returned by the iterator are in no specific order.\n\n List<Path> listSourceFiles(Path dir) throws IOException {\n       List<Path> result = new ArrayList<>();\n       try (DirectoryStream<Path> stream = Files.newDirectoryStream(dir, \"*.{c,h,cpp,hpp,java}\")) {\n           for (Path entry: stream) {\n               result.add(entry);\n           }\n       } catch (DirectoryIteratorException ex) {\n           // I/O error encounted during the iteration, the cause is an IOException\n           throw ex.getCause();\n       }\n       return result;\n   }\n ','What interface is used to recursively loop through a directory ?	','IO',0,0,NULL,5),(3766,'\n    Files.newDirectoryStream\n\n    public static DirectoryStream<Path> newDirectoryStream(Path dir)\n                                                    throws IOException\n\n    Opens a directory, returning a DirectoryStream to iterate over all entries in the directory. The elements returned by the directory stream\'s iterator are of type Path, each one representing an entry in the directory. The Path objects are obtained as if by resolving the name of the directory entry against dir.\n\n    When not using the try-with-resources construct, then directory stream\'s close method should be invoked after iteration is completed so as to free any resources held for the open directory.\n\n    When an implementation supports operations on entries in the directory that execute in a race-free manner then the returned directory stream is a SecureDirectoryStream.\n\n    Parameters:\n        dir - the path to the directory\n    Returns:\n        a new and open DirectoryStream object\n    Throws:\n        NotDirectoryException - if the file could not otherwise be opened because it is not a directory (optional specific exception)\n        IOException - if an I/O error occurs\n        SecurityException - In the case of the default provider, and a security manager is installed, the checkRead method is invoked to check read access to the directory.\n\n','how do you create a new DirectoryStream<T>','IO',0,0,NULL,5),(3767,'Path\n\nThe directory Stream interface is generic, but thats misleading since the \nonly way create a new DirectoryStream is by using File.newDirectoryStream\nwhich returns a Path.','What type of object are returned by directorystreams iterator ? ','IO',0,0,NULL,5),(3768,'use \nFiles.newDirectoryStream(Path dir, String glob);\n\nthis lets you add a glob in that will compare the string representations \nof their file names agains the given glob.\n\nthis lets you filter your results...\n\n Path dir = ...\n     try (DirectoryStream<Path> stream = Files.newDirectoryStream(dir, \"*.java\")) {\n         :\n     }','How would you filter the object returned by a directory Stream ?	','IO',0,0,NULL,5),(3769,'Nothing will not compile, must catch IOException for DirectoryStream','What will be returned by this code...\n\n	Path dir = Paths.get(\"/home/maxbisesi/Documents\");\n        \n	try(DirectoryStream<Path> ds = Files.newDirectoryStream(dir,\"[vx]*\")){\n            sout( );\n        } ','IO',0,0,NULL,5),(3770,'only 1','How many directories at a time can DirectoryStream look at ?','IO',0,0,NULL,5),(3771,'or ...\nDirectoryStream streams one directory','Think, DirectorySteam acts like ls in bash.','IO',0,0,NULL,5),(3772,'public static Path walkFileTree(Path start,\n                FileVisitor<? super Path> visitor)\n                         throws IOException\n\nWalks a file tree.\n\nThis method works as if invoking it were equivalent to evaluating the expression:\n\n     walkFileTree(start, EnumSet.noneOf(FileVisitOption.class), Integer.MAX_VALUE, visitor)\n     \n\nIn other words, it does not follow symbolic links, and visits all levels of the file tree.\n\nParameters:\n    start - the starting file\n    visitor - the file visitor to invoke for each file\nReturns:\n    the starting file\nThrows:\n    SecurityException - If the security manager denies access to the starting file. In the case of the default provider, the checkRead method is invoked to check read access to the directory.\n    IOException - if an I/O error is thrown by a visitor method','What \"Files\" method do you use along with FileVisitor?','IO',0,0,NULL,5),(3773,'FileVisitResult','FileVisitor methods return what ?','IO',0,0,NULL,5),(3774,'CONTINUE\nSKIP_SIBLINGS = continue without visiting the siblings of this file or directory\n\nSKIP_SUBTREE = continue without visiting the entries in this directory\n\nTERMINATE','Enum FileVisitResult elements','IO',0,0,NULL,5),(3775,'SimpleFileVisitor sf = new SimpleFileVisitor() will not compile','SimpleFileVisitor has a protected constructor so It can only be extended','IO',0,0,NULL,5),(3776,'DirectoryStream throws an IOException. Therefore anytime you use \nDirectoryStream you must catch an IOException\n\ntry(DirectoryStream stream = Files.newDirectoryStream(dir)){\n	sout(\"throw excpetion\");\n	//do stuff\n} catch(IOException e) { \n	log(e);\n}','try(DirectoryStream stream = Files.newDirectoryStream(dir)){\n	sout(\"throw excpetion\");\n	//do stuff\n}\n\nWhats wrong here ?','IO',0,0,NULL,5),(3777,'If DirectroyStream is not typed it will give Object elements. Therefore\nto use an untyped DirectoryStream you would have to use...\n	\n	for(Object file : stream) {\n	\n	}\n\n... but thats usually not what you want so always do this>>>\n\n	try(DirectoryStream<Path> Stream = Files.newDirectoryStream(dir)){\n\n	} catch(IOExcetpion e) {\n\n	}','try(DirectoryStream stream = Files.newDirectoryStream(dir)){\n\n	for(Path file : stream){\n		sout(file.getFileName());\n	}\n} catch(IOException e ){\n\n}\n\nWhats wrong here ??','IO',0,0,NULL,5),(3778,'All character stream classes are descended from Reader and Writer. \nAs with byte streams, there are character stream classes that specialize in file I/O: FileReader and FileWriter. \nThe CopyCharacters example illustrates these classes.\n\nclose() throws IOException here too','\npublic class CopyCharacters {\n    public static void main(String[] args) throws IOException {\n\n        FileReader inputStream = null;\n        FileWriter outputStream = null;\n\n        try {\n            inputStream = new FileReader(\"xanadu.txt\");\n            outputStream = new FileWriter(\"characteroutput.txt\");\n\n            int c;\n            while ((c = inputStream.read()) != -1) {\n                outputStream.write(c);\n            }\n        } finally {\n            if (inputStream != null) {\n                inputStream.close();\n            }\n            if (outputStream != null) {\n                outputStream.close();\n            }\n        }\n    }\n}\n','IO',0,0,NULL,5),(3779,'wrap them in Try Block, they all throw IOExceptions ','What has to be done with pretty much ALL IO classes ?','IO',0,0,NULL,5),(3780,'public String readLine()\n                throws IOException\n\nReads a line of text. A line is considered to be terminated by any one of a line feed (\'\\n\'), a carriage return (\'\\r\'), or a carriage return followed immediately by a linefeed.\n\nReturns:\n    A String containing the contents of the line, not including any line-termination characters, or null if the end of the stream has been reached\nThrows:\n    IOException - If an I/O error occurs\n\n\nOther IO classes have read methods that only read in a single character\nBufferedReader has this too. But this method really helps!','What method does BufferedReader have that makes it valuable	','IO',0,0,NULL,5),(3781,'PrintWriter','Which IO class swallows exceptions and does not throw them but \nsaid exceptions can be checked using checkerror()','IO',0,0,NULL,5),(3782,'wont compile you cant construct a FileWriter from a Path not to mention there is an unreported IOException','Path file = Paths.get(\"/home/dick/bigorsmall.txt\");\nBufferedWriter bw = new BufferedWriter(new FileWriter(file));\n\nbw.write(\"this ones pretty big \");','IO',0,0,NULL,5),(3783,'Copy the file from the source to target and return the target.\n\nthrows FileAlreadyExistsException if target fiile already exists, and no\nREPLACE_EXSISTING copy Option is specified. ','Files method:\n\nPath copy(Path src, Path targ, CopyOption...options)','IO',1,0,NULL,5),(3784,'Moves the file from src to target return target. \n\nthrows:\n\n FileAlreadyExistsException - if the target file exists but cannot be replaced because the REPLACE_EXISTING option is not specified (optional specific exception)\n   \n DirectoryNotEmptyException - the REPLACE_EXISTING option is specified but the file cannot be replaced because it is a non-empty directory (optional specific exception)','Files method:\n\nPath move(Path src, Path target, CopyOption options)','IO',0,0,NULL,5),(3785,'false \ntrue\n\nin glob * means match any character excpet a directory boundary\n\n** mathces any character across directory boundaries. \n\nnotice that PathMatcher(\"syntax:pattern\") can take a glob or a regex but you\nmust specify\n\nedit:\nwas previously:\nDefault().getPathMatcher(\"glob: *.txt\");\n\nthere cant be a space after the : or that will mathch...\n\n	Path path = Paths.get(\"one.txt\");\n        PathMatcher matcher = FileSystems.getDefault().getPathMatcher(\"glob: *.txt\");\n        System.out.println(matcher.matches(path));\n\nwould give false unless the space was removed. | Path p1 = Paths.get(\"/home/One.txt\");\nPath p2 = Paths.get(\"One.txt\");\nPathMatcher matcher = FileSystems.getDefault().getPathMatcher(\"glob: *.txt\");\n\nsout( matcher.matches(p1) );\nsout( matcher.matches(p2) );','Path p1 = Paths.get(\"/home/One.txt\");\nPath p2 = Paths.get(\"One.txt\");\nPathMatcher matcher = FileSystems.getDefault().getPathMatcher(\"glob:*.txt\");\n\nsout( matcher.matches(p1) );\nsout( matcher.matches(p2) );','IO',0,0,NULL,5),(3786,'* matches any character inside a directory boundary\n** matches any character inside a directory boundary\n\n','in Glob what does * mean ? what about ** ?','IO',0,0,NULL,5),(3787,'? matches any single character. ','GLOB\n\nwhat does \"?\" mean ?','IO',0,0,NULL,5),(3788,'true\ntrue\nfalse','public class Hello {\n    public static void main(String[] args) {\n        PathMatcher matcher = FileSystems.getDefault().getPathMatcher(\"glob:**{.pic,.txt}\");\n        Path p1 = Paths.get(\"home/files.txt\");\n        Path p2 = Paths.get(\"documents/pictures/smile.pic\");\n        Path p3 = Paths.get(\"home/dir\");\n        \n        System.out.println(matcher.matches(p1));\n        System.out.println(matcher.matches(p2));\n        System.out.println(matcher.matches(p3));\n    }\n\n}','IO',0,0,NULL,5),(3789,'true\ntrue\nfalse','public void matches(Path path, String glob){\n	PathMatcher matcher = FileSystems.getDefault().getPathMatcher(glob);\n	sout( matcher.matches(path) );\n}\n\nPath p1 = Paths.get(\"Bert-book\");\nPath p2 = Paths.get(\"Kathy-horse\");\nmatches(p1, \"glob:{Bert*,Kathy*}\");\nmatches(p2, \"glob: {Bert, Kathy}*\");\nmatches(p1, \"glob:{Bert,Kathy}\");','IO',0,0,NULL,5),(3790,'wrong, visitFileFailed takes an IOExcpeption as a parameter\nas well as postVisitDirectory','FileVisitor\n\npublic FileVisitResult visitFileFailed(path file, BasicFileAttributes attrs) {\n\n	// do something\n	return FileVisitResult.CONTINUE;\n	\n}\n','IO',0,0,NULL,5),(3791,'right, ','FileVisitor: \n\npublic FileVisitResult preVisitDirectory(path file, BasicFileAttributes attrs) {\n\n	// do something\n	return FileVisitResult.CONTINUE;\n	\n}','IO',0,0,NULL,5),(3792,'right','FileVisitor:\n\npublic FileVisitResult visitFileFailed(path file, IOException e) {\n\n	// do something\n	return FileVisitResult.CONTINUE;\n	\n}','IO',0,0,NULL,5),(3793,'right','FileVisitor:\n\npublic FileVisitResult postVisitDirectory(path file, IOException e) {\n\n	// do something\n	return FileVisitResult.CONTINUE;\n	\n}','IO',0,0,NULL,5),(3794,'9/8/01 7:46 PM \n\nremember that strings are imutable, so even though you called \nreplaceAll on that string you didn\'t assing it to a new sString therefore it\nwas lost.\n\nshould be:\n	String newDate = todayFile.replaceAll(\" \",\"-\");','Date today = new Date();\n\nDateFormat df = DateFormat.getInstance();\n\nString todayFile = df.format(today);\n\nsout(todayFile);	// this gives 9/8/01 7:46 PM\n\ntodayFile.replaceAll(\" \",\"-\");\n\nsout( todayFile );\n\nwhat prints now ?','Strings',0,0,NULL,5),(3795,'wont compile, FileWriter doesn\'t have a Path constructor,\n\nchange p1 to p1.toFile();\n\nFileWriter(File file)\nConstructs a FileWriter object given a File object.\n\nFileWriter(File file, boolean append)\nConstructs a FileWriter object given a File object.\n\nFileWriter(FileDescriptor fd)\nConstructs a FileWriter object associated with a file descriptor.\n\nFileWriter(String fileName)\nConstructs a FileWriter object given a file name.\n\nFileWriter(String fileName, boolean append)\nConstructs a FileWriter object given a file name with a boolean indicating whether or not to append the data written.','Path p1 = Paths.get(todayFile+\".txt\");\nSystem.out.println(p1);\n        \nBufferedWriter bw = new BufferedWriter(new FileWriter(p1));','IO',0,0,NULL,5),(3796,'4 3 \n\ntwo rules apply to the first doX, you cannot widen and then box in\none step, and var-args are always chosen last. So you cannot widen shorts\nto ints or longs then box them to Integer or Long but you can box short\nto Short then widen that to Number, that takes priority over var args.\n\nthe second doX simmply boxs int to Integer.\n\n\n\n    Assignment contexts allow the use of one of the following:\n\n        an identity conversion (§5.1.1)\n\n        a widening primitive conversion (§5.1.2)\n\n        a widening reference conversion (§5.1.5)\n\n        a boxing conversion (§5.1.7) optionally followed by a widening reference conversion\n\n        an unboxing conversion (§5.1.8) optionally followed by a widening primitive conversion.\n\n\n','class Eggs {\n	int doX(Long x, Long y){ return 1; }\n	int doX(long...){ return 2; }\n	int doX(Integer x, Integery){ return 3; }\n	int doX(Number n, Number m){ return 4; }\n	public static void main(SA){\n		new Eggs().go();\n	}\n	void go(){\n		short s = 7;\n		sout(doX(s,s) + \" \");\n		sout(doX(7,7));\n	}\n}','General',0,0,NULL,5),(3797,'the first is the directory to start walking at in the form of a Path\n\nthe second is an object of the class that extends SimpleFileVisitor<Path>','What is the first and second argument to Files.walkFileTree()','IO',0,0,NULL,5),(3798,'visitFileFailed and postVisitDirectory','Which Two FileVisitor methods take IOExceptions as parameters	?','IO',0,0,NULL,5),(3799,'preVisitDirectory and visitFile','Which two FileVisitor methods take BasicFileAttributes as parameters ?','IO',0,0,NULL,5),(3800,'now the output is:\n	pre: /home\n	file: /home/a.txt\n	pre: /home/child\n	pre: /home/emptyChild\n	post: /home/emptyChild\n	post: /home\n\npostVisitDirectory is never called if the subtree of the directory is skipped','/home\n	- a.txt\n	- emptyChild	\n	- child\n		- b.txt\n		- grandchild\n			- c.txt\n\npublic class PrintDirs extends SimpleFileVisitor<Path> {\n	public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) {\n		sout( \"pre\" + dir);\n		String name = dir.getFileName().toString();\n		\n		if (name.equals(\"child\"))\n			return FileVisitResult.SKIP_SUBTREE;\n		return FileVisitResult.CONTINUE;\n\n	}\n}\n			\n			\n		\n	','IO',0,0,NULL,5),(3801,'','postVisitDirectory is never called if the subtree of the directory is skipped','IO',0,0,NULL,5),(3802,'assuming child is encountered beffore emptyChild, the output is: \n\npre: /home\nfile: /home/a.txt\npre: /home/child\nfile: /home/child/b.txt\npre: /home/child/grandchild\npost: /home/child\npre: /home/emptyChild\npost: /home\n\nyou skip the grandchld subtree so you dont see the postVisitDirectory call\n\nchild is a sibling but it was encountered before emptychild so it was not skipped','/home\n	- a.txt\n	- emptyChild	\n	- child\n		b.txt\n		grandchild\n		c.txt\n\n\" assume you have FileVisitor method from previous flashcards where the\npre post and file are printed before printing the path of that dir or file \"\n\npublic FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) {\n	sout( \"pre: \" + dir);\n	String name = dir.getFileName().toString();\n	\n	if (name.equals(\"grandchild\"))\n		return FileVisitResult.SKIP_SUBTREE;\n	if ( name.equals(\"emptychild\")\n		return FileVisitResult.SKIP_SIBLINGS;\n	return FileVisitResult.CONTINUE;','IO',0,0,NULL,5),(3803,'true \nfalse\nfalse\nfalse\n\n{A*,b} means A followed by anything or the single character b\n\n/**/ means one or more directories with any name\n\n\\\\* the actuall asterix character \\ escapes the * the second \\ espaces the first \\ ','public void matches(Path path, String glob){\n	PathMatcher matcher = FileSystems.getDefault().getPathMatcher(glob);\n	sout( matcher.matches(path) );\n}\n\nPath p1 = Paths.get(\"0*b/test/1\");\nPath p2 = Paths.get(\"9\\\\*b/test/1\");\nPath p3 = Paths.get(\"01b/test/1\");\nPath p4 = Paths.get(\"0*b/1\");\n\nString glob = \"[0-9]\\\\*{A*,b}/**/1\");\n\nmatches(p1,glob);\nmatches(p2,glob);\nmatches(p3,glob);\nmatches(p4,glob);\n','IO',0,0,NULL,5),(3804,'IOException','What exception if any do FileVisitor methods throw ?','IO',0,0,NULL,5),(3805,'glob: **\n\nregex: .*','glob vs regex: \n\nZero or more of any character, including directory bounndary','IO',0,0,NULL,5),(3806,'zero or or more of any character including directory boundary','regex:\n\n.*','IO',0,0,NULL,5),(3807,'glob: *\n\nregex: no syntax required','glob vs regex:\n\nZero or more of any character, not a directory boundary','IO',0,0,NULL,5),(3808,'glob: ?\n\nregex: .','Glob vs regex:\n\nexcactly one character','IO',0,0,NULL,5),(3809,'glob:\n	{cat, dog}*\n\nregex:\n\n	(cat|dog).*','glob vs regex:\n\nBegins with cat or dog','IO',0,0,NULL,5),(3810,'regex','(cat|dog).*\n\nglob or regex ?','IO',0,0,NULL,5),(3811,'FileSystems.getDefault().getPathMatcher();','You are creating a PathMatcher\n\nPathMatcher matcher = ________._________().__________();','IO',0,0,NULL,5),(3812,'FileSystems.getDefault().newWatchService();','You are creating a WatchService:\n\nWatchService watcher = _____________.__________()._________()','IO',0,0,NULL,5),(3813,'WatchKey\ntry {\n	WatchKey key;\n	try {\n	key = watcher.take();\n              } catch(interuptedException x) {\n		return;\n	}\n	for(WatchEvent<?> event : key.pollEvents()){\n	//do stuff\n	}','What do you get from a WatchService to indicate a deletion creation or modification','IO',0,0,NULL,5),(3814,'take() will wait and block forever until an event takes place. Will throw\nInteruptedException if interuped without taking an event. \n\npoll() returns null if an event is not imediately available. ','What are two ways to get a WatchKey ? \nand whats the difference between them ? ','IO',0,0,NULL,5),(3815,'does not compile countGold() cannot be called from a static context','public class Frodo etends Hobbit {\n	public static void main(SA) { \n		int mygold = 7;\n		sout(countGold(mygold,6));\n	}\n}\nclass Hobbit {\n	int countGold(int x, int y) { return x + y; }\n}','IO',0,0,NULL,5),(3816,'1) If two objects are equal, then they must have the same hash code.\n2) If two objects have the same hash code, they may or may not be equal. \n3) If two objects are not equal, they must NOT have the same hashcode\n','The contract between equals() and hashCode() is:','OOP',0,0,NULL,5),(3817,'shows all files and directories in /home/maxbisesi\n\nsqlexception if the path is not a valid path',' public static void main(String[] args){\n       Path dir = Paths.get(\"/home/maxbisesi\");\n       try(DirectoryStream<Path> stream = Files.newDirectoryStream(dir,\"*\");){\n            for(Path path : stream){\n               System.out.println(path);\n            }\n        } catch(IOException e){\n            System.out.println(\"SQLException\");\n            System.out.println(e);\n        }\n   }','IO',0,0,NULL,5),(3818,'x.a() thread1 x.a() in thread2\nx.b() thread1 x.b() in thread2\nx.b() thread1 y.b() in thread2\n\nthe same instance method of the same instance is blocked while a static\nmethod accross all methods is blocked. ','public class Hello {\n    synchronized void a() { actBusy(); }\n    static synchronized void b() { actBusy(); }\n    static void actBusy() {\n        try {\n            Thread.sleep(1000);\n            \n        } catch( InterruptedException e){}\n            \n        \n    }\n    public static void main(String[] args) {\n        final Hello x = new Hello();\n        final Hello y = new Hello();\n        \n        Runnable runnable = new Runnable() {\n            public void run() {\n                int option = (int) (Math.random() * 4);\n                switch(option) {\n                    case 0: x.a(); break;\n                    case 1: x.b(); break;\n                    case 2: y.a(); break;\n                    case 3: y.b(); break;\n                }\n            }\n        };\n        \n        Thread t1 = new Thread(runnable);\n        Thread t2 = new Thread(runnable);\n        \n        t1.start();\n        t2.start();\n    \n    }\n\n}  \n\nwhich methods could never be running at the same time ?','Threads',0,0,NULL,5),(3819,'got it ','Method forwarding relies on Has-a relationships','OOP',0,0,NULL,5),(3820,'method forwarding\n\nan object composition principle that calles methods on an instance variable of an object','class Animal implements Burriable {\n    private Integer size;\n    private String name;\n    \n    public Animal(int x, String y){\n        size = x;\n        name = y;\n    }\n    public Animal(){\n        size = 0;\n        name = \"\";\n    }\n\n    public int getSize() {\n        return size;\n    }\n\n    public String getName() {\n        return name;\n    }\n    \n    public void bury(){\n        System.out.println(\"just toss him in there...\");\n    }\n    public void digUp(){\n        System.out.println(\"Hang on this ones still kickin !\");\n    }\n    public void pray(){\n        System.out.println(\"...Lord forgive us for what we have done, hes only been gone for \"+YEARSDEAD+\" years.\");\n    }\n}\n\nclass Dog implements Burriable{\n    private Animal animal;\n    public Dog(Animal a){\n        animal = a;\n    }\n    \n    public void bury(){\n        animal.bury();\n    }\n    public void digUp(){\n        animal.digUp();\n    }\n    public void pray(){\n        animal.pray();\n    }\n    \n    public String yelpForHelp(){\n        return \"ar ar arrr....\";\n    }\n}\n\ninterface Burriable {\n    int YEARSDEAD = 1;\n    void bury();\n    void digUp();\n    void pray();\n}\n\nwhat OOP principle is this ?','OOP',0,0,NULL,5),(3821,'The singleton pattern is identifiable bby the static variable for the single instance and the accessor returning it. ','public class F {\n	private static final F f = new F();\n	public static F c(){\n		return f;\n	}\n\n	public void update(F a) { }\n	\n	public void delete(F a) { }\n\n}\nwhat design pattern is this ? ','OOP',0,0,NULL,5),(3822,'object composition, you can tell because of the method forwarding. \nSingleton is tempting but the getInstance method here returns a NEW instance\ninstead a single private static one like it should to be singleton. ','public class E {\n	private D d;\n	public void m() {\n		d.m();\n	}\n\n		public static E getInstance() {\n			return new E();\n		}\n}\n\nclass D {\n	public void m() { }\n}\n\nwhat design pattern principle is this ?\n','OOP',0,0,NULL,5),(3823,'Factory,\n\nClass A is the object we are creating using the factory method. class G\nis the abstract superclass for the factory. Not shown is a class implementing \nclass G that actually creates the object. ','class A {}\n\nabstract class G {\n	A m() { return n(); }\n	abstract A n();\n}\n\nwhat principle is demostrated','OOP',0,0,NULL,5),(3824,'Reuse The DAO pattern centralize logic for the data access code making reuse\neasier and allowing you to switch out implementations. ','which is a benefit of the DAO pattern ?	','OOP',0,0,NULL,5),(3825,'regular files, hidden files, and subdirectories','public void print(Path d) throws IOException {\n	try(DirectoryStream<Path> stream = Files.newDirectoryStream(d)){\n		for(Path path: stream){\n			sout( path.getFileName() );\n		}\n	}\n}\n\nwhat files will this display ? ','IO',0,0,NULL,5),(3826,'The first time the file will be created and copied normally the second time you\nwill get a file already exists excpeiotn','public class Hello {\n    public static void main(String[] dicks) throws IOException{\n      Path src = Paths.get(\"/home/maxbisesi/Documents/copy.txt\");\n      Files.createFile(src);\n      \n      Files.copy(src, Paths.get(\"/home/maxbisesi/Documents/newcopy.txt\"));\n      \n    }\n\n}\n\nwhat happens if this is ran twice and all preivous files dont exist before','IO',0,0,NULL,5),(3827,'Compilation fails, to compile would have to be \n\n	Object item = list.get(0);','public class Hello {\n    public static void main(String[] dicks){\n        ArrayList list = new ArrayList();\n        \n        list.add(\"java\");\n        list.add(\"sucks\");\n        \n        String item = list.get(0);\n\n    }\n\n}','Collections',0,0,NULL,5),(3828,'Will not compile, there is no scope there \n\nif(true){\n	int b = 1;\n} \n	this would though !','if(true)\n       int b = 1;\n        ','General',0,0,NULL,5),(3829,'CooLooLCuuL\n\n* is the greedy quantifier, it takes as much as it can. ','public class Hello {\n    public static void main(String[] dicks){\n        Pattern p = Pattern.compile(\"C.*L\");\n        Matcher m = p.matcher(\"CooLooLCuuLooC\");\n        \n        while(m.find())\n            System.out.println(m.group());\n\n    }\n\n}','Strings',0,0,NULL,5),(3830,'False it gets the same priority as the thread that created it ','If a thread\'s priority is not specified explicitly then it gets\nNORM_PRIORITY\n\nT or F ','Threads',0,0,NULL,5),(3831,'Will not compile, method eat in class animal cannot be applied to given types','public class Hello {\n    public static void main(String[] dicks){\n        Animal ah2 = new Horse();\n        ah2.eat(\"carrots\");\n    }\n\n}\n\nclass Animal{\n    public void eat(){ }\n}\n\nclass Horse extends Animal {\n    public void eat() { }\n    public void eat(String s ){ } \n}\n    ','General',0,0,NULL,5),(3832,'Horse','public class Hello {\n    public static void main(String[] dicks){\n        Animal ah2 = new Horse();\n        ah2.eat();\n    }\n\n}\n\nclass Animal{\n    public void eat(){ System.out.println(\"Animal\"); }\n}\n\nclass Horse extends Animal {\n    public void eat(){ System.out.println(\"Horse\");} \n}\n\n','General',0,0,NULL,5),(3833,'will not compile overriden method \ncannot throw new or broader checked exceptions','public class Hello {\n    public static void main(String[] dicks){\n        Animal ah2 = new Horse();\n        ah2.eat();\n    }\n\n}\n\nclass Animal{\n    public void eat(){ System.out.println(\"Animal\"); }\n}\n\nclass Horse extends Animal {\n    public void eat() throws IOException{ System.out.println(\"Horse\");} \n}','General',0,0,NULL,5),(3834,'Animal\n\neat in horse is an overload, it still inherits Animals eat()','public class Hello {\n    public static void main(String[] dicks){\n        Animal ah2 = new Horse();\n        ah2.eat();\n    }\n\n}\n\nclass Animal{\n    public void eat(){ System.out.println(\"Animal\"); }\n}\n\nclass Horse extends Animal {\n    public void eat(int x) throws IOException{ System.out.println(\"Horse\");} \n}','General',0,0,NULL,5),(3835,'SQLException\n	Statement objects do not support multiple open ResultSets.\n	\n	Only a single ResultSet can be opened from the same statement object\n\n	*if the same statement object is executed more than once the previous\n	ResultSet is closed automatically\n		\n		... and attempting to access a closed RS is a SQLException','//assume valid Connection cn, and good database connection\n\nString query = \"Select * from Answer\";\ntry(Statement stmt = cn.createStatement()){\n	ResultSet rs1 = stmt.executeQuery(query);\n	stmt.executeQuery(\"select * from Question\");\n	while(rs1.next(){\n		sout(rs1.getInt(\"fk_question_num\");\n	}\n} catch(SQLException e){\n	\n}','JDBC',0,0,NULL,5),(3836,'','','blank',0,0,NULL,5),(3837,'SQLException , attempting to execute a query without setting a parameter\nresults in an SQLException\n\n	should be>>>\n		\n		pstmt.setString(1,\"dick\");\n\nIndexing starts at 1','try(Connection conn = DriverManager.getConnection(url,user,pw)){\n	String pQuery = \"Select unitPrice From Book Where Title Like ?\";\n\n	PreparedStatement pstmt = conn.prepareStatement(pQuery);\n\n	ResultSet rs = pstmt.executeQuery();\n} catch(SQLException sq) {\n}\n','JDBC',0,0,NULL,5),(3838,'compiles and runs just fine ','public class Hello {\n    public static void main(String[] dicks){\n        try{\n            couldthrow();\n        } catch(IOException | SQLException e){\n            \n        }\n        \n    }\n    \n    public static void couldthrow() throws IOException, SQLException{\n        \n    }\n\n}','Exceptions',0,0,NULL,5),(3839,'instanceof test','public boolean equals(Object o) { \n	if(((Moof)o).getMoofValue() == this.moofValue {\n		return true;\n	} else {\n		return false;\n	}\n}\n\nwhats missing here','Collections',0,0,NULL,5),(3840,'got it','equals() hashCode() and toString() are all PUBLIC','Collections',0,0,NULL,5),(3841,'for any reference value x, x.equals(x) should be true. ','equals() Contract\n\nreflexive	','Collections',0,0,NULL,5),(3842,'for any reference values x and y, \n\nx.equals(y) shoud be true if and only if \ny.equals(x) returns true. ','equals() contract,\n\nsymmetric','Collections',0,0,NULL,5),(3843,'reflxive, x.equals(x) is always true\n\nsymetric, x.equals(y) and y.equals(x)\n\ntransitive, if x.equals(y) and y.equals(z) then x.equals(z)\n\nconsistent, x.equals(y) is true no matter how many times you call it\n\nif x is non null, x.equals(null) is always false','what are the four tenants of the equals contract ?','Collections',0,0,NULL,5),(3844,'MUST also be equal.','if two objects are considered equal, their hashcodes...','Collections',0,0,NULL,5),(3845,'Yes just inefficient, all objects will go in the same bucket. The Collection\nwill search through a single big bucket using equal() to find the instance\nits looking for. In that case you defeat the purpose of using a hashed collection. ','Is it still legal to have a hashcode that always returns the same number ?','Collections',0,0,NULL,5),(3846,'When it is invoked on the same object more than once during an execution\nof a java application the hashcode() method must consistently return the \nsame integer \n\nIf two objects are equal according to the equals method, then calling hashchode)( \non each of the objects must produce the same integer\n\nunequal objects can still produce the same hashcodes \n\n*That means that equals and hashCode must work with same attributes somehow','HashCode contract:\n\n1\n\n2\n\n\n3','Collections',0,0,NULL,5),(3847,'x.hashcode() == y.hashcode()','x.equals(y) == true\n\nmeans what for hashcode()...','Collections',0,0,NULL,5),(3848,'x.equals(y) == false\n\nequals() and hashcode are like directions to get to a specific \nelement\n\nhashCode places all the elements in seperate but similiar buckets \nequals() gets the correct ones out.\n\nso if two elemets have different hashCodes they will be in different buckets\nanyway so hashCode is one level of precision and equals() is the next.','x.hashCode() != y.hashCode()	\n\nmeans what for equals()','Collections',0,0,NULL,5),(3849,'../..\nGenDir/genFile.txt\n','public static void main(String[] args){\n        Path p = Paths.get(\"/home/maxbisesi/Public/GenDir/genFile.txt\");\n        Path p2 = Paths.get(\"/home/maxbisesi/Public\");\n        \n        System.out.println(p.relativize(p2));\n        System.out.println(p2.relativize(p));  \n}','IO',0,0,NULL,5),(3850,'a Vector is the same as an ArrayList but Vector methods are synchronized\nfor thread safety. \n\nVector and Hashtable are the two original collections\n\nunless you really need thread safety choose ArrayList over Vector, \nthe synchronized methods give an unecssary performance hit. \n\n','Collections:\n\n	Vector\n','Collections',0,0,NULL,5),(3851,'is ordered by index position except that the elements are doubly linked to \none another. This linkage gives you new methods for adding and removing\nfrom the beginning or end.\n\nEasy choice for implementing a stack or queue. \n\nmay iterate more slowly than ArrayList but still a good choice when you need\nfast insertion and deletion.\n\nLinkedList supports peek(), poll(), offer(), Queue methods!!','Collections:\n\n	LinkedList','Collections',0,0,NULL,5),(3852,'Set','Which Interface disallows duplicates','Collections',0,0,NULL,5),(3853,'unsorted and unordered. Uses the hashcode of the object being inserted\n\nso the more effeicinet your hashcode the more effecient access youll get\n\nUse for a collection with no duplicates where you dont care about the\norder when you iterate through it.','Collections:\n	\n	HashSet','Collections',0,0,NULL,5),(3854,'\nMaintains a doubly linked list across elelemnts so the insertion order \nis maintained\n\nduplicates are still disallowed. ','Collections:\n\n	LinkedHashSet','Collections',0,0,NULL,5),(3855,'Sorted\n\nguarentees elements will be in ascending order according to natural order\n\n','Collections:\n\n	TreeSet','Collections',0,0,NULL,5),(3856,'compilation fails at the last three lines,\n\n1. multi catch syntax is | not ||\n\n2. objects declared in a try block are only available within the \ntry block so closing r is out of scope','public class Reader {\n	public void read(Path p, Charset s) {\n		try(BufferedReader r = Files.newBufferedReader(p,s)) {\n			try { r.read(); }\n			catch(IOException f) {\n				r.readLine();\n			}\n		} catch(IOException || NullPointerException e) {\n			r.close();\n		} finally {\n			r.close();\n		}\n	}\n}','IO',0,0,NULL,5),(3857,'unsorted and unordered Map. \n\nUse When you need a map and you don\'t care\nabout the order when you iterate through. \n\nThe basic map, other maps add a little more overhead. \n\nWhere keys land in the map is based on hashCode() \n\nHashMap allows one null key and multiple null values ','Collections:\n\n	HashMap','blank',0,0,NULL,5),(3858,'Hashtable is the synchronized counterpart to HashMap. \n\nWhile HashMap lets you have a null key and null values\n\nHashtable doesn\'t allow anything thats null!','Collections:\n	\n	Hashtable\n	','Collections',0,0,NULL,5),(3859,'True!\n\nHashtable doesn\'t allow anything null it will throw a npe','HashMap allows multiple null values','Collections',0,0,NULL,5),(3860,'FALSE\n\nThat would defeat the purpose of a \"key\"','HashMap allows multiple null keys','Collections',0,0,NULL,5),(3861,'FALSE\n\nunordered and unsorted','HashMap is sorted','Collections',0,0,NULL,5),(3862,'FALSE','HashMap is synchronized','Collections',0,0,NULL,5),(3863,'True!','Hashtable is synchronized ','Collections',0,0,NULL,5),(3864,'FALSE, nothing can be null in Hashtable','Hashtable allows multiple null values and one null key','blank',0,0,NULL,5),(3865,'since list is declared as anything that extends Animal you cant be sure that it\nwill be the right type to pass into the next method that taks <Animal>\n\nWill not compile','public static ArrayList<Animal> staggerSort(ArrayList<? extends Animal> list){\n        Map<String,List<Number>> byCategory = seperateToCategories(list);\n        return null;\n    }\n    \n    static Map<String,List<Number>> seperateToCategories(ArrayList<Animal> list){\n        return null;\n    }','Generics',0,0,NULL,5),(3866,'big Bucks\nsweet Cheeks\n\nbig Bucks replaced big Country in the map, LinkedHashMaps maintain insertion\norder. \n\nso that mapping was simply replaced but it kept its position','public static void main(String[] args){\n        LinkedHashMap<String,String> lhm = new LinkedHashMap<>();\n        lhm.put(\"big\",\"Country\");\n        lhm.put(\"sweet\",\"Cheeks\");\n        lhm.put(\"big\",\"Bucks\");\n        \n        for(Map.Entry<String,String> entry: lhm.entrySet()){\n            System.out.println(entry.getKey()+\" \"+entry.getValue());\n        }\n        \n    }','Collections',0,0,NULL,5),(3867,'WNC,\n\ngo() declares that it throws a checked exceptions so it has to be handled\nor thrown in main.\n\nif that would have compiled an IOException would be thrown so it would\nprint got io error done. ','class Gutsy {\n	public static void main(String[] args){\n		new Gutsy().go();\n	}\n	void go() throws IOException {\n	String row;\n	try {\n		FileReader fr = new FileReader(\"TestFile.txt\");\n		BufferedReader br = new BufferedReader(fr);\n		while((row = br.readLine() ) != null)\n			sout( row );\n	} catch(IOException e) {\n		sout(\"got io error\");\n	} finally {\n		sout( \"done\" );\n	}\n   }\n}','Exceptions',0,0,NULL,5),(3868,'-6 through 4','Given a properly prepared string[] with five elements what is the range \nof possible results that could be returned by Arrays.binarySearch() ? ','Collections',0,0,NULL,5),(3869,'sorted Map\n\nsorted by natural order or custom comparison rules.','TreeMap','blank',0,0,NULL,5),(3870,'3\nfalse\ntrue\n2','List<String> test = new ArrrayList<String>();\nString s = \"hi\";\ntest.add(\"string\");\ntest.add(s);\ntest.add(s+s);\nsout( test.size() );\nsout( test.contains(42) );\nsout( test.contains(\"hihi\") );\ntest.remove(\"hi\");\nsout( test.size() );','Collections',0,0,NULL,5),(3871,'These two are the same, the first demonstrates autoboxing. ','List myInts = new ArrayList();\n        myInts.add(4);\n        \n        myInts.add(new Integer(4));','blank',0,0,NULL,5),(3872,'NullPointerException','class Boxing2 {\n	static Integer x;\n	psvm(sa) {\n		doStuff(x);\n	}\n\n	static void doStuff(int z) {\n		int z2 = 5;\n		sout( z2 + z );\n	}\n}','General',0,0,NULL,5),(3873,'unsorted: [CZ, a, AB, CE, CZ, cz, BA, BF, ABC, CE,  CE, A, ce, A B, AA,  Z]\nsorted: [ CE,  Z, A, A B, AA, AB, ABC, BA, BF, CE, CE, CZ, CZ, a, ce, cz]\n\nspaces come first, as shown by A B and AA. Also capitals come before lowercase','public static void main(String[] dicks){\n        ArrayList<String> list = new ArrayList<>();\n        \n        list.add(\"CZ\");\n        list.add(\"a\");\n        list.add(\"AB\");\n        list.add(\"CE\");\n        list.add(\"CZ\");\n        list.add(\"cz\");\n        list.add(\"BA\");\n        list.add(\"BF\");\n        list.add(\"ABC\");\n        list.add(\"CE\");\n        list.add(\" CE\");\n        list.add(\"A\");\n        list.add(\"ce\");\n        list.add(\"A B\");\n        list.add(\"AA\");\n        list.add(\" Z\");\n        \n        System.out.println(\"unsorted: \"+list);\n        Collections.sort(list);\n        System.out.println(\"sorted: \"+list);','Collections',0,0,NULL,5),(3874,'Will not compile, Horse does not implement Comparable','public class Hello {\n    public static void main(String[] dicks){\n        List<Horse> stable = new ArrayList<>();\n        \n        for(int x =0; x < 10; x++){\n            stable.add(new Horse());\n        }\n        \n        Collections.sort(stable);\n        \n    }\n\n}\n\nclass Horse {\n    public boolean equals(Horse s){\n        return false;\n    }\n}','Collections',0,0,NULL,5),(3875,'will not compile, compareTo is public ','class Horse implements Comparable<Horse> {\n    public boolean equals(Horse s){\n        return false;\n    }\n    \n    int compareTo(Horse h){\n        \n    }\n    \n    \n}','Collections',0,0,NULL,5),(3876,'compiles fine!','public class Hello {\n    public static void main(String[] dicks){\n        List<Horse> stable = new ArrayList<>();\n        \n        for(int x =0; x < 10; x++){\n            stable.add(new Horse(\"lucky\"+x));\n        }\n        \n        Collections.sort(stable);\n        \n    }\n\n}\n\nclass Horse implements Comparable<Horse> {\n    String name;\n    \n    public Horse(String x){\n        name = x;\n    }\n    \n    public String getName(){\n        return name;\n    }\n    \n    public boolean equals(Horse s){\n        return false;\n    }\n    \n    public int compareTo(Horse h){\n        return name.compareTo(h.getName());\n        \n    }\n    \n    \n}','Collections',0,0,NULL,5),(3877,'Object','When you override equals() you must take an argument of what type ?','Collections',0,0,NULL,5),(3878,'The type your sorting.\n\n\npublic interface Comparable<T>\n\n...type T','When you override compareTo() you must take an argument of type?','Collections',0,0,NULL,5),(3879,'This is still legal but painful, genereics make this easier but it will still \ncompile','class DVDInfo implements Comparable {\n	public int comparteTo(Object o) {\n		DVDInfo d = (DVDInfo) o;\n		return title.compareTo(d.getTitle() );\n	}\n}','Collections',0,0,NULL,5),(3880,'compare()\n\ncompareTo()','Comparator has _________________\n\nComparable has _________________','Collections',0,0,NULL,5),(3881,'Comparator','Which soritng interface do you implement to create individual sorting classes\n	','Collections',0,0,NULL,5),(3882,'will not compile the method is:\n\n	int compare(T o1, T o2)','class Dicksorter implements Comparator<Dicks> {\n	public int compareTo(Dick one) {\n	}\n}','Collections',0,0,NULL,5),(3883,'compiles fine, this takes advvantage of integer comparison','class DickSorter implements Comparator<Dick> {\n	public int compare(Dick one, Dick two){\n		return one.getSize().compareTo(two.getSize());\n	}\n}','Collections',0,0,NULL,5),(3884,'Will not compile\n\ntoArray() in List interface returns an Object[]','public class Hello {\n    public static void main(String[] dicks){\n        List<Horse> stable = new ArrayList<>();\n        \n        stable.add(new Horse(\"Honey\"));\n        stable.add(new Horse(\"Mighty Mikey\"));\n        stable.add( new Horse(\"The Fastest Stud in the Mud\"));\n        stable.add( new Horse(\"Churchill\"));\n        \n        Horse[] ranch = stable.toArray();\n\n    }\n\n}','Collections',0,0,NULL,5),(3885,'ClassCastException, \"johny\" cant be turned into a horse\n\nshould be Arrays.binarySearch(stable,new Horse(\"Johny\"));','public class Hello {\n    public static void main(String[] dicks){\n        Horse[] stable = {new Horse(\"Johny\"), new Horse(\"wilfred\"), new Horse(\"Marco\"), new Horse(\"MAx\"), new Horse(\"Billy\") };\n        \n        int x = Arrays.binarySearch(stable,\"Johny\");\n        System.out.println(x);  \n\n    }\n\n}','Collections',0,0,NULL,5),(3886,'The results are undefined, the array is not sorted. ','public class Hello {\n    public static void main(String[] dicks){\n        Horse[] stable = {new Horse(\"Johny\"), new Horse(\"wilfred\"), new Horse(\"Marco\"), new Horse(\"MAx\"), new Horse(\"Billy\") };\n        \n        int x = Arrays.binarySearch(stable,new Horse(\"Johny\"));\n        System.out.println(x);  \n\n    }\n\n}    \n\nclass Horse implements Comparable<Horse> {\n    String name;\n    \n    public Horse(String x){\n        name = x;\n    }\n    \n    public String getName(){\n        return name;\n    }\n    \n    public boolean equals(Horse s){\n        return false;\n    }\n    \n    public int compareTo(Horse h){\n        return name.compareTo(h.getName());\n        \n    }\n    \n    \n    ','Collections',0,0,NULL,5),(3887,'ClassCastException Horse cannot be converted to Comparable\n\nbinarySearch uses comparable to search the Array.\n\nThis search would give inconsistant results anyways because \nthe array was not sorted first. \n\nto fix add this:\n\nclass Horse implements Comparable<Horse> {\n    String name;\n    \n    public Horse(String x){\n        name = x;\n    }\n    \n    public String getName(){\n        return name;\n    }\n    \n    public boolean equals(Horse s){\n        return false;\n    }\n    \n    public int compareTo(Horse s){\n        return name.compareTo(s.getName());\n    }\n    \n}\n\n-if an array is sorted in natrual order it must searched in natural order \n-if it is sorted using a comparator it must be searched using the same comparator.\n','public class Hello {\n    public static void main(String[] dicks){\n        Horse[] stable = {new Horse(\"Johny\"), new Horse(\"wilfred\"), new Horse(\"Marco\"), new Horse(\"MAx\"), new Horse(\"Billy\") };\n        \n        \n        int x = Arrays.binarySearch(stable,new Horse(\"Marco\"));\n        System.out.println(x);  \n\n    }\n\n}\n\nclass Horse {\n    String name;\n    \n    public Horse(String x){\n        name = x;\n    }\n    \n    public String getName(){\n        return name;\n    }\n    \n    public boolean equals(Horse s){\n        return false;\n    }\n    \n}','Collections',0,0,NULL,5),(3888,'Will not compile, if the untyped version of Comparable is used then\nthe parameter to compareTo would be Object\n\neither change to Comparable<Horse>\n\nor \n\ncomparTo(Object o) and cast.\n\notherwise, the answer would be 2 remember arrays aren\'t sorted even though\nyour using comparable the elements of an array dont get sorted so the positions are \nwhat index they were defined as !\n\nThis would give undefined results','public class Hello {\n    public static void main(String[] dicks){\n        Horse[] stable = {new Horse(\"Johny\"), new Horse(\"wilfred\"), new Horse(\"Marco\"), new Horse(\"MAx\"), new Horse(\"Billy\") };\n        int x = Arrays.binarySearch(stable,new Horse(\"Marco\"));\n        System.out.println(x);  \n    }\n}\n\nclass Horse implements Comparable{\n    String name;\n    public Horse(String x){\n        name = x;\n    }\n    public String getName(){\n        return name;\n    }\n    public boolean equals(Horse s){\n        return false;\n    }\n    public int compareTo(Horse h){\n        return name.compareTo(h.getName());  \n    }\n}\n','Collections',0,0,NULL,5),(3889,'binarySearch()\n\nreturns the int index of the element being searched.\n\nUnsuccesful searches return an int index that represents the\n insertion point. \n\nThe collection or array must be sorted before you can search it.\n\nif you attempt to search an unsorted array or collection the results of the\nsearch will be unpredictable.\n\nIf it was sorted in natural order it must searched in natural order.\n	do this by NOT sending a Comparator as an argument to the binarySearch() \n\nIf it was sorted with a comparator it must be searched using the same comparator\n\n	\n	','What method is used to search through Arrays and Collections','Collections',0,0,NULL,5),(3890,'will not compile, need to cast\n\nreturn name.compareTo(((Horse)h).getName());\n\ndoes not compile because h is an Object and Objects dont have a method\ncalled getName. \n\nyou would cast h to a horse. \n\nObject is the right argument type here though because Comparable is a raw type\nif it were Comparable<Horse> the argument would need to be Horse.','class Horse implements Comparable{\n    String name;\n    \n    public Horse(String x){\n        name = x;\n    }\n    \n    public String getName(){\n        return name;\n    }\n    \n    public boolean equals(Horse s){\n        return false;\n    }\n    \n    public int compareTo(Object h){\n        return name.compareTo(h.getName());\n  \n    }','Collections',0,0,NULL,5),(3891,'these all compile fine, \n\nPolymorphism works with Arrays. ','public class Hello {\n    public static void main(String[] dicks){\n       Animal[] beavers = new Beaver[5];\n       \n       Animal[] animals = {new Beaver(), new Beaver(), new Beaver() };\n       \n       Animal[] ans2 = new Animal[5];\n       ans2[0] = new Beaver();\n\n    }\n}\n\nclass Animal{\n    public Animal(){\n        \n    }\n    \n    public String getName(){\n        return \"d\";\n    }\n}\n\nclass Beaver extends Animal{\n    \n}','Collections',0,0,NULL,5),(3892,'2\n0','public class Hello {\n    public static void main(String[] dicks){\n       \n        String[] strings = {\"One\",\"Dice\",\"Angela\",\"Bisesi\",\"Franko\"};\n        \n        Arrays.sort(strings);\n        int x = Arrays.binarySearch(strings,\"Dice\");\n        System.out.println(x);  \n        \n        Arrays.sort(strings);\n        \n        System.out.println(Arrays.binarySearch(strings,\"Angela\"));\n    }\n\n}','Collections',0,0,NULL,5),(3893,'compare must be public, will not compile','class sortBySecondLetter implements Comparator<String> {\n    int compare(String one, String two){\n        \n    }\n}','Collections',0,0,NULL,5),(3894,'will not compile, char is a primitive so charone cannot be dereferenced here\nchange to Character.','class sortBySecondLetter implements Comparator<String> {\n    public int compare(String one, String two){\n        char charone = one.charAt(1);\n        char chartwo = two.charAt(1);\n        \n        return charone.compareTo(chartwo);\n    }\n}','Collections',0,0,NULL,5),(3895,'[Ljava.lang.String;@15db9742\n\narrays are not classes','public class Hello {\n    public static void main(String[] dicks){\n        sortBySecondLetter sbsl = new sortBySecondLetter();\n        String[] strings = {\"One\",\"Dice\",\"Angela\",\"Bisesi\",\"Franko\"};\n        \n        Arrays.sort(strings,sbsl);\n        \n        System.out.println(strings);\n    }\n\n}','Collections',0,0,NULL,5),(3896,'size 4\nidx2 three\none \nfive \nthree \nsix \ns1[1] five','String[] sa = {\"one\", \"two\", \"three\", \"four\" };\nList sList = Arrays.asList(sa);\n\nSout( \"size \" + sList.size() );\nsout( \"idx2 \" + sList.get(2) );\n\nsList.set(3,\"six\" );\nsa[1] = \"five\";\n\nfor(String s : sa ){\n	sout( s + \" \");\n}\nsout(\"\\n s1[1] \" + sList.get(1) );','Collections',0,0,NULL,5),(3897,'UnsupportedOperationException\n\nThis UnsupportedOperationException comes when you try to perform some operation on collection where its not \nallowed and in your case, When you call Arrays.asList it \ndoes not return a java.util.ArrayList. It returns a java.util.Arrays$ArrayList which is an immutable list. \nYou cannot add to it and you cannot remove from it.\n\nReturns a {@code List} of the objects in the specified array. The size of the {@code List} cannot be modified, i.e. adding and removing are unsupported, but the elements can be set. Setting an element modifies the underlying array.\n\nEDIT\n\nThe type of the resulting list is Arrays.ArrayList, which is a private class inside Arrays.class. Practically speaking,\nit is nothing but a List-view on the array that you\'ve passed with Arrays.asList. With a consequence: if you change the array, the list is changed too. And because an array is not resizeable, \nremove and add operation must be unsupported.\n','public class Hello {\n    public static void main(String[] args){\n        String[] sa = {\"one\", \"two\", \"three\", \"four\" };\n        List sList = Arrays.asList(sa);\n\n        System.out.println( \"size \" + sList.size() );\n        System.out.println( \"idx2 \" + sList.get(2) );\n\n        sList.set(3,\"six\" );\n        sa[1] = \"five\";\n\n        for(String s : sa ){\n            System.out.println( s + \" \");\n        }\n        System.out.println(\"s1[1] \" + sList.get(1) );\n        \n        sList.remove(\"five\");\n        for(String s : sa)\n            System.out.println(s+\" \");\n    }\n\n}','Collections',0,0,NULL,5),(3898,'size 4\nidx2 three\none \nfive \nthree \nsix \ns1[1] five\none \nFIVE \nthree \nSIX\n\nThis shows that Arrays and Lists coming from\nArrays.asList() are \"joined at the hip\" changes in one affect \nthe other. This is different from a \"Backed Collection\". Because \nBacked Collections dont go both ways and are only backed for a certain range.','String[] sa = {\"one\", \"two\", \"three\", \"four\" };\n        List sList = Arrays.asList(sa);\n\n        System.out.println( \"size \" + sList.size() );\n        System.out.println( \"idx2 \" + sList.get(2) );\n\n        sList.set(3,\"six\" );\n        sa[1] = \"five\";\n\n        for(String s : sa ){\n            System.out.println( s + \" \");\n        }\n        System.out.println(\"s1[1] \" + sList.get(1) );\n        \n        sList.set(1, \"FIVE\");\n	sList.set(3,\"SIX);\n        for(String s : sa)\n            System.out.println(s+\" \");','Collections',0,0,NULL,5),(3899,'unsupported operation exception, \n\nList returned by asList is fixed size can only be updated not added to or removed from','public static void main(String[] dicks){\n        String[] sa = {\"one\", \"two\", \"three\", \"four\" };\n        List sList = Arrays.asList(sa);\n\n        System.out.println( \"size \" + sList.size() );\n        System.out.println( \"idx2 \" + sList.get(2) );\n\n        sList.set(3,\"six\" );\n        sa[1] = \"five\";\n\n        for(String s : sa ){\n            System.out.println( s + \" \");\n        }\n        System.out.println(\"s1[1] \" + sList.get(1) );\n        \n        sList.set(1, \"FIVE\");\n        sList.set(3,\"SIX\");\n        sList.add(\"SEVEN\");\n        for(String s : sa)\n            System.out.println(s+\" \");','Collections',0,0,NULL,5),(3900,'will not compile, toArray( T[] a) will return an array of the type you send\nto it. so here an Object[] cannot be assigned to an Integer[].\n\nto fix:\n	change oa to ia2 which will cause toArray to return an Integer[]',' public static void main(String[] dicks){\n        List<Integer> iL = new ArrayList<Integer>();\n        for(int x=0; x<3; x++){\n                iL.add(x);\n        }\n        Object[] oa = iL.toArray();\n        Integer[] ia2 = new Integer[3];\n        ia2 = iL.toArray(oa);\n    }','Collections',0,0,NULL,5),(3901,'0\n1\n2\n3\n4\n','public static void main(String[] dicks){\n        List<Integer> iL = new ArrayList<Integer>();\n        for(int x=0; x<5; x++){\n                iL.add(x);\n        }\n        Object[] oa = iL.toArray();\n        Integer[] ia2 = new Integer[3];\n        ia2 = iL.toArray(ia2);\n        \n        for(Integer i : ia2){\n            System.out.println(i);\n        }     \n    }','Collections',0,0,NULL,5),(3902,'0\n1\n2\n3\n4\n0\n1\n2\n3\n4','public static void main(String[] dicks){\n        List<Integer> iL = new ArrayList<Integer>();\n        for(int x=0; x<5; x++){\n                iL.add(x);\n        }\n        Object[] oa = iL.toArray();\n        Integer[] ia2 = new Integer[3];\n        ia2 = iL.toArray(ia2);\n        \n        for(Integer i : ia2){\n            System.out.println(i);\n        }\n        \n        iL.add(100);\n        \n        for(Integer i : ia2)\n            System.out.println(i);\n       \n    }','Collections',0,0,NULL,5),(3903,'will not compile, \n\n.toArray() returns an Object[]',' public static void main(String[] dicks){\n        List<Integer> iL = new ArrayList<Integer>();\n        for(int x=0; x<5; x++){\n                iL.add(x);\n        }\n        Integer[] oa = iL.toArray();     \n    }','Collections',0,0,NULL,5),(3904,'unpredictable result, the array is not sorted before being searched. ','class HDTV implements Comparable<HDTV> {\n	private int size;\n	private String brand;\n        private int resolution;\n \n	public HDTV(int size, String brand, int res) {\n		this.size = size;\n		this.brand = brand;\n                this.resolution = res;\n	}\n \n	public int getSize() {\n		return size;\n	}\n        \n        public int getRes() {\n            return resolution;\n        }\n \n	public void setSize(int size) {\n		this.size = size;\n	}\n \n	public String getBrand() {\n		return brand;\n	}\n \n	public void setBrand(String brand) {\n		this.brand = brand;\n	}\n \n	@Override\n	public int compareTo(HDTV tv) {\n \n		if (this.getSize() > tv.getSize())\n			return 1;\n		else if (this.getSize() < tv.getSize())\n			return -1;\n		else\n			return 0;\n	}\n        \n        public String toString(){\n            return brand;\n        }\n}\n\npublic class Hello {\n    public static void main(String[] dicks){\n        compareTVs();\n    }\n    \n     \n    public static void compareTVs() {\n		HDTV tv1 = new HDTV(55, \"Samsung\", 6000);\n		HDTV tv2 = new HDTV(60, \"Sony\", 4500);\n                HDTV tv3 = new HDTV(70, \"MEGATV\", 10000);\n                HDTV tv4 = new HDTV(15,\"kitchenette\", 600);\n\n                HDTV[] array = {tv2, tv1, tv3, tv4 };\n                \n                System.out.println(Arrays.binarySearch(array,new HDTV(700,\"Samsung\",400)));\n                \n	}\n\n}','Collections',0,0,NULL,5),(3905,'will not compile \n\nArrayList.addAll doesn\'t work like that, it takes another collection\nthen adds all the elements from one to another. ','public static void main(String[] dicks){\n        List<HDTV> tvs = new ArrayList<>();\n        HDTV tv1 = new HDTV(55, \"Samsung\", 6000);\n        HDTV tv2 = new HDTV(60, \"Sony\", 4500);\n        HDTV tv3 = new HDTV(70, \"MEGATV\", 10000);\n        HDTV tv4 = new HDTV(15,\"kitchenette\", 600);\n        tvs.addAll(tv1,tv2,tv3,tv4);\n    }','Collections',0,0,NULL,5),(3906,'Samsung\nSony\nMEGATV\nkitchenette\n\nthis shows proper use of an iterator','public static void main(String[] dicks){\n        List<HDTV> tvs = new ArrayList<>();\n        \n        HDTV tv1 = new HDTV(55, \"Samsung\", 6000);\n        HDTV tv2 = new HDTV(60, \"Sony\", 4500);\n        HDTV tv3 = new HDTV(70, \"MEGATV\", 10000);\n        HDTV tv4 = new HDTV(15,\"kitchenette\", 600);\n        \n        tvs.add(tv1);\n        tvs.add(tv2);\n        tvs.add(tv3);\n        tvs.add(tv4);\n        \n        Iterator<HDTV> i3 = tvs.iterator();\n        \n        while(i3.hasNext()){\n            HDTV t3 = i3.next();\n            System.out.println(t3.getBrand());\n        }\n        \n        \n    }','Collections',0,0,NULL,5),(3907,'If the iterator isn\'t typed then the elements returned by Iterator will be \nObjects so to make this compile, \n\nyou would have to cast\n\n	(HDTV) i3.next();','public static void main(String[] dicks){\n        List<HDTV> tvs = new ArrayList<>();\n        \n        HDTV tv1 = new HDTV(55, \"Samsung\", 6000);\n        HDTV tv2 = new HDTV(60, \"Sony\", 4500);\n        HDTV tv3 = new HDTV(70, \"MEGATV\", 10000);\n        HDTV tv4 = new HDTV(15,\"kitchenette\", 600);\n        \n        tvs.add(tv1);\n        tvs.add(tv2);\n        tvs.add(tv3);\n        tvs.add(tv4);\n        \n        Iterator i3 = tvs.iterator();\n        \n        while(i3.hasNext()){\n            HDTV t3 = i3.next();\n            System.out.println(t3.getBrand());\n        }\n        \n        \n    }','Collections',0,0,NULL,5),(3908,'none fail both of those are fine. ','  public static void main(String[] dicks){\n        List<HDTV> tvs = new ArrayList<>();\n        \n        HDTV tv1 = new HDTV(55, \"Samsung\", 6000);\n        HDTV tv2 = new HDTV(60, \"Sony\", 4500);\n        HDTV tv3 = new HDTV(70, \"MEGATV\", 10000);\n        HDTV tv4 = new HDTV(15,\"kitchenette\", 600);\n        \n        tvs.add(tv1);\n        tvs.add(tv2);\n        tvs.add(tv3);\n        tvs.add(tv4);\n        \n        HDTV[] tv = new HDTV[5];\n        HDTV[] hv = tvs.toArray(tv); //line 1\n        Object[] tvobjs = tvs.toArray(); //line 2\n        \n   \n    }\n\nwhich line would fail if any ?','Collections',0,0,NULL,5),(3909,'true\ntrue\ntrue\ntrue\nfalse\n4\n5\n7\n9\n\nSets dont allow duplicates and the iteration order is not predictable','public static void main(String[] dicks){\n      Set s = new HashSet();\n      \n        System.out.println(s.add(4));\n        System.out.println(s.add(9));\n        System.out.println(s.add(5));\n        System.out.println(s.add(\"7\"));\n        System.out.println(s.add(4));\n        \n        for(Object o : s)\n            System.out.println(o);\n\n    }','Collections',0,0,NULL,5),(3910,'ClassCastException\n \nTreeSets are sorted and all these elements aren\'t mutually comparabble','public static void main(String[] dicks){\n      Set s = new TreeSet();\n      \n        System.out.println(s.add(4));\n        System.out.println(s.add(9));\n        System.out.println(s.add(5));\n        System.out.println(s.add(\"7\"));\n        System.out.println(s.add(4));\n        \n        for(Object o : s)\n            System.out.println(o);\n\n    }','Collections',0,0,NULL,5),(3911,'Charly,\n\nhere strings are used as keys and they override hashcode() and equals()\nso it can be used ','class Dog {\n    public String name;\n    public Dog(String n) { name = n; }\n    \n    public String toString(){\n        return name;\n    }\n}\n\npublic class Hello {\n\n    public static void main(String[] dicks){\n      Map<Object,Object> map = new HashMap<>();\n      \n      map.put(\"d1\",new Dog(\"Charly\"));\n      map.put(\"d2\", new Dog(\"dumbfuck\"));\n      \n        System.out.println(map.get(\"d1\"));\n    }\n}','Collections',0,0,NULL,5),(3912,'null \n\nthe map cannot find the values bcause the keys dont have equals or hashcode methods.','class Dog {\n    public String name;\n    public Dog(String n) { name = n; }\n    \n    public String toString(){\n        return name;\n    }\n\n    public static void main(String[] dicks){\n      Map<Object,Object> map = new HashMap<>();\n      \n      map.put(new Dog(\"Bell\"),\"Big brown lab\");\n      map.put(new Dog(\"Sable\"), \"small schiperkee\");\n      \n        System.out.println(map.get(new Dog(\"Bell\")));\n    }\n\n}\n\n','Collections',0,0,NULL,5),(3913,'null\ncatdog\nDOG','class Dog {\n    enum Pets{DOG, CAT, SNAKE};\n    public String name;\n    public Dog(String n) { name = n; }\n    \n    public String toString(){\n        return name;\n    }\n\npublic static void main(String[] dicks){\n      \n      Map<Object,Object> map = new HashMap<>();\n      \n      map.put(new Dog(\"Bell\"),\"Big brown lab\");\n      map.put(new Dog(\"Sable\"), \"small schiperkee\");\n      map.put(Pets.CAT, new Dog(\"catdog\"));\n      map.put(\"Dog\", Pets.DOG);\n      \n        System.out.println(map.get(new Dog(\"Bell\")));\n        System.out.println(map.get(Pets.CAT));\n        System.out.println(map.get(\"Dog\"));\n    }\n}','Collections',0,0,NULL,5),(3914,'both are legal, the first will be slightly better\n\nthe more unique a hashcode the faste retrieval will be. ','public int hashCode() { return name.length(); }\npublic int hashCode() { return 4; }\n \nwhich will be faster ?\n','Collections',0,0,NULL,5),(3915,'12\n34\n45\n63','TreeSet<Integer> tree = new TreeSet<Integer>();\ntree.add(12);\ntree.add(63);\ntree.add(34);\ntree.add(45);\n \nIterator<Integer> iterator = tree.iterator();\nSystem.out.print(\"Tree set data: \");\nwhile (iterator.hasNext()) {\n    System.out.print(iterator.next() + \" \");\n}','Collections',0,0,NULL,5),(3916,'[1.8, 2.3, 2.2, 4.6, 8.9]\n-5\n\nthis comparator sorts in ascending order uless they have the same integer\nvalue','public class Hello {\n    \n    \n    public static void main(String[] dicks){\n      \n      List<Double> grades = new ArrayList<>();\n      grades.addAll(Arrays.asList( new Double[]{ 1.8, 4.6, 2.3, 8.9, 2.2 } ));\n      \n      Collections.sort(grades,new CusSort());\n      \n      System.out.println(grades);\n      \n        System.out.println(Collections.binarySearch(grades,4.2,new CusSort()));\n\n    }\n}\n    \n   class CusSort implements Comparator<Double> {\n       public int compare(Double d1, Double d2){\n           return d1.intValue() == d2.intValue() ? d2.compareTo(d1) : d1.compareTo(d2);\n           \n       }\n   }','Collections',0,0,NULL,5),(3917,'{a=ant, b=buffalo, h=horse} {b=buffalo}\n{R=raccoon, a=ant, b=bat, f=fish, h=horse} {b=bat, f=fish}','public class Hello {\n    \n    \n    public static void main(String[] dicks){\n      \n     TreeMap<String, String> map = new TreeMap<>();\n     map.put(\"a\",\"ant\"); map.put(\"b\",\"buffalo\"); map.put(\"h\",\"horse\");\n     \n     SortedMap<String, String> submap;\n     submap = map.subMap(\"b\",\"g\");\n     \n        System.out.println(map+\" \"+submap);\n        \n        map.put(\"b\",\"bat\");\n        \n        submap.put(\"f\",\"fish\");\n        \n        map.put(\"R\", \"raccoon\");\n        // submap.put(\"p\",\"pig\");\n        \n        System.out.println(map+\" \"+submap);\n    }\n}','Collections',0,0,NULL,5),(3918,'IllegalArgumnetException\n\np is out of range of the submap as first established with subMap(b g);\n\n','public class Hello {\n    \n    \n    public static void main(String[] dicks){\n      \n     TreeMap<String, String> map = new TreeMap<>();\n     map.put(\"a\",\"ant\"); map.put(\"b\",\"buffalo\"); map.put(\"h\",\"horse\");\n     \n     SortedMap<String, String> submap;\n     submap = map.subMap(\"b\",\"g\");\n     \n        System.out.println(map+\" \"+submap);\n        \n        map.put(\"b\",\"bat\");\n        \n        submap.put(\"f\",\"fish\");\n        \n        map.put(\"R\", \"raccoon\");\n        submap.put(\"p\",\"pig\");\n        \n        System.out.println(map+\" \"+submap);\n    }\n}','Collections',0,0,NULL,5),(3919,'will not compile, submap returns a SortedMap.','public class Hello {\n    \n    \n    public static void main(String[] dicks){\n      \n     TreeMap<String, String> map = new TreeMap<>();\n     map.put(\"a\",\"ant\"); map.put(\"b\",\"buffalo\"); map.put(\"h\",\"horse\"); map.put(\"j\",\"jackle\");\n     \n     TreeMap<String, String> submap;\n     submap = map.subMap(\"b\",\"g\");\n     \n     System.out.println(map+\" \"+submap);\n\n    }\n}','Collections',1,0,NULL,5),(3920,'AbstractMap<k,V>\nNavigableMap<K,V>','class TreeMap<k,v> extends  _____________\n implements  ____________','Collections',0,0,NULL,5),(3921,'{Beee=9, Ant=6, muskrat=20, Dog=7}\n\nwithout a provided comparator TreeMap sorts using Animals comparable\n\nwhich is to rank by size','public class Hello {\n    \n    \n    public static void main(String[] dicks){\n      \n     TreeMap<Animal, Integer> map = new TreeMap<>();\n     \n     map.put(new Animal(5,\"Ant\"), 6); map.put(new Animal(3,\"Beee\"),9); map.put(new Animal(25,\"Dog\"),7); map.put(new Animal(20,\"muskrat\"),20);\n     \n     System.out.println(map);\n     \n \n\n    }\n}\n\nclass sortAnimalsAlphabetically implements Comparator<Animal> {\n\n    @Override\n    public int compare(Animal o1, Animal o2) {\n        return o1.getName().compareTo(o2.getName());\n    }\n    \n}\n\nclass Animal implements Comparable<Animal> {\n    private Integer size;\n    private String name;\n    \n    public Animal(int x, String y){\n        size = x;\n        name = y;\n    }\n\n    public int getSize() {\n        return size;\n    }\n\n    public String getName() {\n        return name;\n    }\n    public int compareTo(Animal o){\n        return size.compareTo(o.getSize());\n        \n    }\n    \n    public String toString(){\n        return name;\n    }\n}','Collections',0,0,NULL,5),(3922,'{Ant=6, Beee=9, Dog=7, muskrat=20}\n\nsort using comparator','public class Hello {\n    \n    \n    public static void main(String[] dicks){\n      \n     TreeMap<Animal, Integer> map = new TreeMap<>(new sortAnimalsAlphabetically());\n     \n     map.put(new Animal(5,\"Ant\"), 6); map.put(new Animal(3,\"Beee\"),9); map.put(new Animal(25,\"Dog\"),7); map.put(new Animal(20,\"muskrat\"),20);\n     \n     System.out.println(map);\n     \n \n\n    }\n}\n\nclass sortAnimalsAlphabetically implements Comparator<Animal> {\n\n    @Override\n    public int compare(Animal o1, Animal o2) {\n        return o1.getName().compareTo(o2.getName());\n    }\n    \n}\n\nclass Animal implements Comparable<Animal> {\n    private Integer size;\n    private String name;\n    \n    public Animal(int x, String y){\n        size = x;\n        name = y;\n    }\n\n    public int getSize() {\n        return size;\n    }\n\n    public String getName() {\n        return name;\n    }\n    public int compareTo(Animal o){\n        return size.compareTo(o.getSize());\n        \n    }\n    \n    public String toString(){\n        return name;\n    }\n}','Collections',0,0,NULL,5),(3923,'IllegalArgumentException key out of range\n\nyour trying to add a rhino - 50 - to the copied map when the biggest element\nin the orgiinal was a Dog at 15 !','public class Hello {\n    \n    \n    public static void main(String[] dicks){\n      \n     TreeMap<Animal, Integer> map = new TreeMap<>();\n     \n     map.put(new Animal(2,\"Ant\"), 6); map.put(new Animal(3,\"Beee\"),9); map.put(new Animal(15,\"Dog\"),7); map.put(new Animal(12,\"muskrat\"),20);\n     \n     SortedMap<Animal,Integer> copymap = map.subMap(map.firstKey(), map.lastKey());\n     \n     copymap.put(new Animal(50,\"Rhino\"), 1);\n     map.put(new Animal(30,\"Wolf\"), 4);\n     System.out.println(map);\n     \n     SortedMap<Animal,Integer> copy1map = copymap.subMap(new Animal(4,\"Worm\"), new Animal(25,\"Dolphin\"));\n     \n     System.out.println(copy1map);\n\n    }\n}\n\nclass sortAnimalsAlphabetically implements Comparator<Animal> {\n\n    @Override\n    public int compare(Animal o1, Animal o2) {\n        return o1.getName().compareTo(o2.getName());\n    }\n    \n}\n\nclass Animal implements Comparable<Animal> {\n    private Integer size;\n    private String name;\n    \n    public Animal(int x, String y){\n        size = x;\n        name = y;\n    }\n\n    public int getSize() {\n        return size;\n    }\n\n    public String getName() {\n        return name;\n    }\n    public int compareTo(Animal o){\n        return size.compareTo(o.getSize());\n        \n    }\n    \n    public String toString(){\n        return name;\n    }\n}','Collections',0,0,NULL,5),(3924,'IllegalArgumentException, fromKey out of range\n\nthe tic your trying to add is too small previously the smallest elemtn was\nan Ant at 2','public class Hello {\n    \n    \n    public static void main(String[] dicks){\n      \n     TreeMap<Animal, Integer> map = new TreeMap<>();\n     \n     map.put(new Animal(2,\"Ant\"), 6); map.put(new Animal(3,\"Beee\"),9); map.put(new Animal(15,\"Dog\"),7); map.put(new Animal(12,\"muskrat\"),20);\n     \n     SortedMap<Animal,Integer> copymap = map.subMap(map.firstKey(), map.lastKey());\n     \n     map.put(new Animal(50,\"Rhino\"), 1);\n     map.put(new Animal(30,\"Wolf\"), 4);\n     System.out.println(map);\n     \n     SortedMap<Animal,Integer> copy1map = copymap.subMap(new Animal(1,\"Tic\"), new Animal(25,\"Dolphin\"));\n     \n     //System.out.println(copy1map);\n\n    }\n}\n\nclass sortAnimalsAlphabetically implements Comparator<Animal> {\n\n    @Override\n    public int compare(Animal o1, Animal o2) {\n        return o1.getName().compareTo(o2.getName());\n    }\n    \n}\n\nclass Animal implements Comparable<Animal> {\n    private Integer size;\n    private String name;\n    \n    public Animal(int x, String y){\n        size = x;\n        name = y;\n    }\n\n    public int getSize() {\n        return size;\n    }\n\n    public String getName() {\n        return name;\n    }\n    public int compareTo(Animal o){\n        return size.compareTo(o.getSize());\n        \n    }\n    \n    public String toString(){\n        return name;\n    }\n}\n','Collections',0,0,NULL,5),(3925,'{Ant=6, Beee=9, muskrat=20, Dog=7}\n{Ant=6, Beee=9, muskrat=20}\n{Ant=6, Beee=9, muskrat=20, Dog=7, Wolf=4, Rhino=1}\n{Ant=6, Beee=9, muskrat=20, Dog=7, Wolf=4}\n\npublic SortedMap<K,V> subMap(K fromKey,\n                    K toKey)\n\nkeys range from fromKey, inclusive, to toKey, exclusive. (If fromKey and toKey are equal, the returned map is empty.)\n The returned map is backed by this map, so changes \nin the returned map are reflected in this map, and vice-versa.\n\nTHE TO KEY IS EXCLUSIVE ','public class Hello {\n    \n    \n    public static void main(String[] dicks){\n      \n     TreeMap<Animal, Integer> map = new TreeMap<>();\n     \n     map.put(new Animal(2,\"Ant\"), 6); map.put(new Animal(3,\"Beee\"),9); map.put(new Animal(15,\"Dog\"),7); map.put(new Animal(12,\"muskrat\"),20);\n     \n     SortedMap<Animal,Integer> copymap = map.subMap(map.firstKey(), map.lastKey());\n        System.out.println(map);\n        System.out.println(copymap);\n     \n     map.put(new Animal(50,\"Rhino\"), 1);\n     map.put(new Animal(30,\"Wolf\"), 4);\n     System.out.println(map);\n     \n     copymap = map.subMap(map.firstKey(), map.lastKey());\n     \n        System.out.println(copymap);\n     \n     //SortedMap<Animal,Integer> copy1map = copymap.subMap(new Animal(7,\"Snake\"), new Animal(40,\"Bear\"));\n     //System.out.println(copy1map);\n\n    }\n}','Collections',0,0,NULL,5),(3926,'{Ant=6, Beee=9, muskrat=20, Dog=7}\n{Ant=6, Beee=9, muskrat=20, Dog=7}\n\noverloaded version of submap indicates if that arg is inclusive \n\nThe map is sorted according to the natural ordering of its keys, or by a Comparator provided at map creation time\nNote that the ordering maintained by a tree map, like any sorted map, and whether or not an explicit comparator is provided, \nmust be consistent with equals if this sorted map is to correctly implement the Map interface. (See Comparable or Comparator for a precise definition of consistent with equals.) \nThis is so because the Map interface is defined in terms of the equals operation, but a sorted map performs all key comparisons using its compareTo (or compare) method, so two keys that are deemed equal by this method are, \nfrom the standpoint of the sorted map, equal.  ','public class Hello {\n  public static void main(String[] dicks){\n      \n     TreeMap<Animal, Integer> map = new TreeMap<>();\n     \n     map.put(new Animal(2,\"Ant\"), 6); map.put(new Animal(3,\"Beee\"),9); map.put(new Animal(15,\"Dog\"),7); map.put(new Animal(12,\"muskrat\"),20);\n     \n     SortedMap<Animal,Integer> copymap = map.subMap(map.firstKey(),true, map.lastKey(),true);\n        System.out.println(map);\n        System.out.println(copymap);\n    }\n}\n\nclass Animal implements Comparable<Animal>{\n    private int size;\n    private String name;\n    public Animal(int s, String n){\n        size = s;\n        name = n;\n        \n    }\n    public int getSize(){\n        return size;\n    }\n    public int compareTo(Animal a){\n        int asize = a.getSize();\n        int bsize = this.size;\n        \n        if(asize < bsize)\n            return 1;\n        else if(asize == bsize)\n            return 0;\n        else\n            return -1;\n  \n    }\n    \n    public String toString(){\n        return name;\n    }\n}','Collections',0,0,NULL,5),(3927,'{Ant=6, Beee=9, muskrat=20, Dog=7}\n{Beee=9, muskrat=20, Dog=7}','public class Hello {\n    \n    \n    public static void main(String[] dicks){\n      \n     TreeMap<Animal, Integer> map = new TreeMap<>();\n     \n     map.put(new Animal(2,\"Ant\"), 6); map.put(new Animal(3,\"Beee\"),9); map.put(new Animal(15,\"Dog\"),7); map.put(new Animal(12,\"muskrat\"),20);\n     \n     SortedMap<Animal,Integer> copymap = map.subMap(map.firstKey(),false, map.lastKey(),true);\n        System.out.println(map);\n        System.out.println(copymap);\n    }\n}','Collections',0,0,NULL,5),(3928,'{Ant=6, Beee=9, muskrat=20, Dog=7}\n{Beee=9, muskrat=20}','public class Hello {\n    \n    \n    public static void main(String[] dicks){\n      \n     TreeMap<Animal, Integer> map = new TreeMap<>();\n     \n     map.put(new Animal(2,\"Ant\"), 6); map.put(new Animal(3,\"Beee\"),9); map.put(new Animal(15,\"Dog\"),7); map.put(new Animal(12,\"muskrat\"),20);\n     \n     SortedMap<Animal,Integer> copymap = map.subMap(map.firstKey(),false, map.lastKey(),false);\n        System.out.println(map);\n        System.out.println(copymap);\n    }\n}','Collections',0,0,NULL,5),(3929,'try{\n\n}catch(Exception1 | Exception2 e) {\n\n	e = new Exception1();\n}\n\nTHIS WOULD FAIL COMPILATION\n\n','When using multi-catch, the catch block parameter is final and cannot \nhave a new value assigned to it in the catch block.\n\ntry{\n\n} catch(SQLException | IOException e){\n	\n	e = new IOException();\n}\n\n// this shows why thats illegal, your not sure which exception type \nwill come through.\n//updated 2','Exceptions',0,0,NULL,5),(3930,'javac -source 1.3 OldCode.java\n\njavac -source 1.4 NewCode.java','To compile old code that may use \'assert\' as an identifier, \nadd 1.3. This will tell the compiler to treat the word \'assert\' as an identifier.\n\n1.4 will use \'assert\' as a keyword	','Exceptions',0,0,NULL,5),(3931,'java -da com.maxbisesi.Test\n\njava -disableassertions com.maxbisesi.Test','Disable assertions at runtime		','Exceptions',0,0,NULL,5),(3932,'This is a bad idea...\n\npublic void doStuff(){\n	assert (modifyThings());\n	//continue\n}\n\npublic boolean modifyThings() {\n	y = x++;\n	return true;\n}','Dont use assert expressions that can cause side effects...','Exceptions',0,0,NULL,5),(3933,'Fails compilation','You cant use the variable name multiple times in a multi-catch. \nThe following wont compile...\n\ncatch(Exception1 e1 | Exception2 e2){\n\n}','Exceptions',0,0,NULL,5),(3934,'the following are equivalent:\n\ncatch(SQLException | IOException e)\n\ncatch(IOException | SQLException e)','With Multi catch order does NOT matter...		','Exceptions',0,0,NULL,5),(3935,'The following will not compile...\n\ncatch(FileNotFoundException | IOException e)\n\nsince FILNOTFOUND is a subclass of IOException we could have just\nwrtten that in the first place..\n\ncatch(IOException)','With Multi-Catch you have to make sure a given excpetion can only\nmatch one type...\n\ncatch(IOException | SQLException e)\n\nthese two are different types.','Exceptions',0,0,NULL,5),(3936,'This is legal but it is not good practice. It is illegal to reasign the value\nof a multi-catch parameter. \n\ntry {\n	\n} catch(SQLException | IOException e){\n\n	e = new IOException();\n}\n\n^^WILL NOT COMPILE\n','Legal or illegal...\n\ntry {\n	//do something\n} catch(IOException e){\n	\n	e = new IOException();\n}','Exceptions',0,0,NULL,5),(3937,'Will not compile, it is legal to reassign the parameter here. But it is illegal\nto throw e. The method declares that it throws SQL and IO so throwing a \ngeneral exception is unreported. \n\nif the signature was throws Exception then everything would be fine\n\nException as a genreal','public void couldthrow() throws SQLException, IOException { }\n\npublic void rethrow() throws SQLException, IOException {\n	try{\n		couldthrow();\n	} catch(Exception e){ \n		e = new IOException();\n		throw e;\n	}\n}	','Exceptions',0,0,NULL,5),(3938,'Illegal, regular trys have to have a catch or a finally\n\ntry-with can be used by themselves','legal or illegal\n\ntry {\n\n}','Exceptions',0,0,NULL,5),(3939,'does not compile. \nto be declared in a try with the method has to implement auto closeable or\ncloseable','try(String s = \"hi\") {}','Exceptions',0,0,NULL,5),(3940,'will not compile,\nThe declared resources use a commma , not a semi colon ;\n\nshould be:\n\ntry(Resource r = new Resource(); ...','Path p = Paths.get(\"/home/maxbisesi\");\n      try(BufferedReader br = new BufferedReader(new FileReader(p.toFile())), BufferedWriter bw = new BufferedWriter(new FileWriter(p.toFile()))){\n          \n      } catch(IOException e){\n          \n      }','Exceptions',0,0,NULL,5),(3941,'ok, AutoCloseable interface allows throwing any Exception','Class A implements AutoCloseable { \n	public void close() throws Exception {}\n}	','Exceptions',0,0,NULL,5),(3942,'ok sublcasses or implenting methods can throw a subclass of excpetion\nor none at all.\n\nAutoCloseable\'s  close throws an Exception','class B implements AutoCloseable { public void close() {}}\nclass C implements AutoCloseable { public void close() throws IOException {}}','Exceptions',0,0,NULL,5),(3943,'ILLEGAL- Closeable only allows IOExceptions or subclasses','class D implements Closeable { public void close() throws Exception{}}','Exceptions',0,0,NULL,5),(3944,'ok Closeable allows throwing IOExceptions\n\nvoid close() throws IOException','class E implements Closeable { public void close() throws IOException {}}','Collections',0,0,NULL,5),(3945,'you can call close() multiple times all day and nothing will happen the second time and beyond. \nwill not blow up. ','idempotent','Exceptions',0,0,NULL,5),(3946,'nothing bad will happen if you call close() more than one time. ','AutoCloseable\'s close() is idempotent	','Exceptions',0,0,NULL,5),(3947,'might blow up if called more than once','Closeable\'s close() is not idempotent','Exceptions',0,0,NULL,5),(3948,'B\nA\ncatch\n\nResources are closed in reverse order from what they are declared.','class A implements AutoCloseable {\n	public void close() {\n		sout(\"A\");\n	}\n}\n\nclass B implements AutoCloseable {\n	public void close() {\n		sout(\"B\");\n	}\n}\n\nclass C {\n	psvm(sa){\n		try(A a = new A(); B b = new B()){\n			throw new RuntimeException();\n		} catch(EXception e) {\n			sout(\"catch\");\n		}\n	}\n}\n\nwhat does it print?','Exceptions',0,0,NULL,5),(3949,'Try\nsuppressed: java.io.IOException: Closing\n\nafter the exception in the try block gets thrown on line 4, the try with \nresources still calls close() and the catch block catches one \nof the exceptions.\n\nJava adds any excpeittions thrown by close() methods to a suppressed array in the main excpetion. \n\nif no other exception happens in the try block the exceptioon thrown in\nclose() gets treated as the main excpetion  for the catch block. ','public class Suppressed {\n	psvm(sa) {\n		try(One one = new One()) {\n			throw new exception(\"try\");\n		} catch (Exception e) {\n			sout(e.getMessage());\n			\n			for(Throwable t : e.getSuppressed()){\n				sout(\"suppressed:\" + t);\n		}	}\n	}\n}\n\nclass One implements AutoCloseable {\n	public void close() throws IOException {\n		throw new IOException(\"Closing\");\n	}\n}','Exceptions',0,0,NULL,5),(3950,'got it ','If the catch or Finally block throws an exception NO SUPPRESSION HAPPENS\nthe last exception thrown gets sent to the caller rather than the one from the \ntry- just like before try with resources','Exceptions',0,0,NULL,5),(3951,'Closing - 2\nsuppressed: java.io.IOException: Closing - 1\n\nresources close in the opposite order they are declared','class Bad implements AutoCloseable {\n	String name;\n	Bad(String n) { name = n; }\n	public void close() throws IOException {\n		throw new IOException(\"Closing -\" +name);\n	}\n}\n\npublic class Suppressed {\n	public static void main(SA) {\n		try(Bad b1 = new Bad(\"1\"); Bad b2 = new Bad(\"2\")) {\n			\n		} catch(Exception e) {\n			sout(e.getMessage());\n			for(Throwable t : e.getSuppressed()) {\n				sout(\"suppressed:\" + t);\n			}\n		}\n	}\n}','Exceptions',0,0,NULL,5),(3952,'Since all file IO on the exam is related to characters, if you see a Stream\nlike DataOutputStream the the question is probably about serialization\nor something unrelated to the actual IO objective','Stream classes are used to read and write bytes, and Readers and Writers\nare used to read write Characters....','IO',0,0,NULL,5),(3953,'// first time\nfalse\ntrue \ntrue\n\n//second time\ntrue\nfalse\ntrue\n\nexists returns false the first time becasue the file was created as an object\nbut not yet as a physical file. ','psvm(SA) {\n	try {\n		boolean newFile = false;\n		File file = new File(\"fiileWrite1.txt\");\n		sout(file.exists());\n		newFile = file.createNewFile());\n		sout(newFile);\n		sout(file.exists());\n	} catch (IOException e) {}\n}	','IO',0,0,NULL,5),(3954,'This method returns true if it can find the actual file\n\nfalse\ntrue\n\n	the first time it is run','public static void main(String[] args){\n        File newFile = new File(\"/home/maxbisesi/Public/textFile5.txt\");\n        try{\n            System.out.println(newFile.exists());\n            newFile.createNewFile();\n            System.out.println(newFile.exists());\n        } catch(IOException e){\n            \n        }   \n    }','IO',0,0,NULL,5),(3955,'true if the named file does not exist and was successfully created; false if the named file already exists\n','File method: \ntry {\n	createNewFile();\n} catch(IOException e) { } ','IO',0,0,NULL,5),(3956,'File(File parent, String child)\nCreates a new File instance from a parent abstract pathname and a child pathname string.\n\nFile(String pathname)\nCreates a new File instance by converting the given pathname string into an abstract pathname.\n\nFile(String parent, String child)\nCreates a new File instance from a parent pathname string and a child pathname string.','File class Constructors	','IO',0,0,NULL,5),(3957,'createNewFile()\ndelete()\nexists()\nisDirectory()\nisfile()\nlist()\nmkdir()\nrenameTo()','File class key methods ','IO',0,0,NULL,5),(3958,'FileWriter(File file)\n\nFileWriter(String filename)','FileWriter class Constructors	','IO',0,0,NULL,5),(3959,'close()\nflush()\nwrite()','FileWriter class key methods 	','IO',0,0,NULL,5),(3960,'BufferedWriter(Writer out)','BufferedWriter class constructors	','IO',0,0,NULL,5),(3961,'close() \nflush()\nnewLine()\nwrite()','BufferedWriter key methods	','IO',0,0,NULL,5),(3962,'PrintWriter(File file)\nCreates a new PrintWriter, without automatic line flushing, with the specified file.\n\nPrintWriter(File file, String csn)\nCreates a new PrintWriter, without automatic line flushing, with the specified file and charset.\n\nPrintWriter(OutputStream out)\nCreates a new PrintWriter, without automatic line flushing, from an existing OutputStream.\n\nPrintWriter(OutputStream out, boolean autoFlush)\nCreates a new PrintWriter from an existing OutputStream.\n\nPrintWriter(String fileName)\nCreates a new PrintWriter, without automatic line flushing, with the specified file name.\n\nPrintWriter(String fileName, String csn)\nCreates a new PrintWriter, without automatic line flushing, with the specified file name and charset.\n\nPrintWriter(Writer out)\nCreates a new PrintWriter, without automatic line flushing.\n\nPrintWriter(Writer out, boolean autoFlush)\nCreates a new PrintWriter.','PrintWriter constructors','IO',0,0,NULL,5),(3963,'read()','FileReader key methods 	','IO',0,0,NULL,5),(3964,'Reader','BufferedReader constructors	','IO',0,1,NULL,5),(3965,'read()\nreadLine()','BufferedReader key methods','IO',0,0,NULL,5),(3966,'filewrite2.txt would contain the text:\n\nhello\nworld','File file = new file(\"filewriter2.txt\");\nFileWriter fw = new fileWriter(file);\n\nPrintWriter pw = new PrintWriter (fw);\n\npw.println(\"hello\");\npw.println(\"world\"));','IO',0,0,NULL,5),(3967,'','File file = new File(\"filewrite2.txt\");\nFileReader fr = new FileReader(file);\nBufferedReader br = new BufferedReader(fr);\n\nString data = br.readLine();','IO',0,0,NULL,5),(3968,'got it ','File file = new File(\"foo\");\n\nif \"foo\" does not exist no actual file is created.\n\nif \"foo\" does exists, the new File object refers to the existing file. ','IO',0,0,NULL,5),(3969,'io','readers dont have flush methods','IO',0,0,NULL,5),(3970,'a char[]','Console.readPassword() returns...','IO',0,0,NULL,5),(3971,'Returns the path element corresponding to the specified index.\n\nthe 0th element is the one closest to the root.','Path Method:\n\nPath getName(int index)','IO',0,0,NULL,5),(3972,'returns the filename or the last element of the sequence of name elements\n\nor..\n\nReturns the name of the file or directory denoted by this path as a Path object. The file name is the farthest element from the root in the directory hierarchy.','Path Method:\n\nString getFileName()','IO',0,0,NULL,5),(3973,'4','public class Hello {\n    public static void main(String[] dicks) throws IOException{\n      Path src = Paths.get(\"/home/maxbisesi/Documents/copy.txt\");\n\n      System.out.println(src.getNameCount());\n      \n    }\n\n}','IO',0,0,NULL,5),(3974,'\n/home/maxbisesi/Documents','\npublic class Hello {\n    public static void main(String[] dicks) throws IOException{\n      Path src = Paths.get(\"/home/maxbisesi/Documents/copy.txt\");\n      Path srcParent = src.getParent();\n      System.out.println(srcParent);\n      \n    }\n\n}','IO',0,0,NULL,5),(3975,'retunrs the root of thsi path, or null if this path does not have a root.','Path Method:\n\nPath getRoot()		','IO',0,0,NULL,5),(3976,'returns a ssubsequence of this path NOT INCLUDING ROOT. \n\nbeginning INCLUSIVE\n\nending EXCLUSIVE','Path Method:\n\nPath subpath(int beginindex, int endIndex)','IO',0,0,NULL,5),(3977,'that means it can be iterated through in a for loop!','Path extends from Iterable<Path>	','IO',0,0,NULL,5),(3978,'tmp/dir1/dir2/dir3/file.txt','int spaces = 1;\nPath myPath = Paths.get(\"tmp\", \"dir1\", \"dir2\", \"dir3\", \"file.txt\");\n\nfor(Path subpath : myPath){\n	sout( subpath + \"//\" );\n}','IO',0,0,NULL,5),(3979,'returns a path that is this path with redundant name elements eliminated\n\n. can be ignored\n\n.. followed by a directory can be removed as redundant','Path method:\n\nPath normalize()	','IO',0,0,NULL,5),(3980,'/a/b/c','Paths.get(\"/a/./b/./c\").normalize();\n','IO',0,0,NULL,5),(3981,'.classpath','Paths.get(\".classpath\").normalize();','IO',0,0,NULL,5),(3982,'/a/b','Paths.get(\"/a/b/c/..\").normalize()','IO',0,0,NULL,5),(3983,'../a/b/c\n\nThe two dots do say go up one directory, but since there is\'nt a directory\nbefore it Path cant simplify it.','Paths.get(\"../a/b/c\").normalize()','IO',0,0,NULL,5),(3984,'/home/java/models/Model.pdf\n\npath1.resolve(path2) should be read as \"resolve path2 within path1s directory\n','Path dir = Paths.get(\"/home/java\");\nPath file = Paths.get(\"models/Model.pdf\");\nPath result = dir.resolve(file);\n\nsout( result );\n	','IO',0,0,NULL,5),(3985,'/google\n\nResolve the given path against this path.\n\nIf the other parameter is an absolute path then this method trivially returns other.\n If other is an empty path then this method trivially returns this path.\n Otherwise this method considers this path to be a directory and resolves\n the given path against this path. In the simplest case, the given path does not have a root component, \nin which case this method joins the given path to this path \nand returns a resulting path that ends with the given path.','class Hello {\n    public static void main(String[] args) {     \n        Path p1 = Paths.get(\"/home/max/tmp\");\n        Path p2 = Paths.get(\"/google\");\n        System.out.println(p1.resolve(p2));\n        \n    }\n\n}','IO',0,0,NULL,5),(3986,'/home/java/dir\n/home/java/Model.pdf\n/dir/Model.pdf\n/home/java\n/home/java\nModel.pdf/dir\n\nThe first three do what you would exprect. They add the paramenter\nto resolve to the provided path object. The fourth and fifth try to resolve\nan absolute path within the context of something else. The problem is \nthat an aboluste path doesnt\'t depend on other directories it is absolute.\n','Path absolute = Paths.get(\"/home/java\");\nPath relative = Paths.get(\"dir\");\nPath file = Paths.get(\"Model.pdf\");\n\nsout( absolute.resolve(relative) );\nsout( asolute.resolve(file) );\nsout( relative.resolve(file) );\nsout( relative.resolve(absolute) ); // BAD\nsout( file.resolve(absolute) ); //BAD\nsout( file.resolve(relative) ); //BAD','IO',0,0,NULL,5),(3987,'Thhe compilere cannot decide here so it will not compile','Be carefule with questions that come in two flavors. one with a Path parameter\nand the other with a String parameter such as resolve()...\n\nPath path = Paths.get(\"/usr/bin/zip\");\npath.resolve(null);','IO',0,0,NULL,5),(3988,'resolve()','Which Path method is used to combine two paths and set one in another?','IO',0,0,NULL,5),(3989,'relativize()','Which Path method is used to describe how to gret from one path to \nthe other	','IO',0,0,NULL,5),(3990,'country/Swift.mp3\n\n\njava recognized that the /home/java part is the same and returned a path of\njust the remainder.\n\npath1.relativize(path2) should be read as \"give me a path shows how to get from\npath1 to path2\"','Path dir = Paths.get(\"/home/java\");\nPath music = Paths.get(\"/home/java/country/Swift.mp3\");\nPath mp3 = dir.reltivize(music);\n\nsout( mp3 );','IO',0,0,NULL,5),(3991,'.relativize()','\"give me a path shows how to get from\npath1 to path2\"','IO',0,0,NULL,5),(3992,'temp/music.mp3\n\n../..\n\n../../usr/local\n\nmusic.pdf\n\nExcpetion in main thread IllegalArgumentExcpetion\n\n	','Path absolute1 = Paths.get(\"/home/java\");\nPath absolute2 = Paths.get(\"/usr/local\");\nPath absolute3 = Paths.get(\"/home/java/temp/music.mp3\");\nPath relative1 = Paths.get(\"temp\");\nPath relative2 = Paths.get(\"temp/music.pdf\");\n\nsout( absolute1.relativize(absolute3) );\nsout( absolute3.relativize(absolute1) );\nsout( absolute1.relativize(absolute2) );\nsout( relative1.relativize(relative2) );\nsout( absolute1.relativize(relative1) ); //BAD','IO',0,0,NULL,5),(3993,'Path relativize(Path other)\n\nConstructs a relative path between this path and a given path.\n\nRelativization is the inverse of resolution. This method attempts to construct a relative path that when resolved against this path, yields a path that locates the same file as the given path. For example, on UNIX, if this path is \"/a/b\" and the given path is \"/a/b/c/d\" then the resulting relative path would be \"c/d\". Where this path and the given path do not have a root component, then a relative path can be constructed. A relative path cannot be constructed if only one of the paths have a root component. Where both paths have a root component then it is implementation dependent if a relative path can be constructed. If this path and the given path are equal then an empty path is returned.\n\nFor any two normalized paths p and q, where q does not have a root component,\n\n    p.relativize(p.resolve(q)).equals(q) \n\nWhen symbolic links are supported, then whether the resulting path, when resolved against this path, yields a path that can be used to locate the same file as other is implementation dependent. For example, if this path is \"/a/b\" and the given path is \"/a/x\" then the resulting relative path may be \"../x\". If \"b\" is a symbolic link then is implementation dependent if \"a/b/../x\" would locate the same file as \"/a/x\".\n\nParameters:\n    other - the path to relativize against this path\nReturns:\n    the resulting relative path, or an empty path if both paths are equal\nThrows:\n    IllegalArgumentException - if other is not a Path that can be relativized against this path','relativeize()','IO',0,0,NULL,5),(3994,'If this program is run from the root, it is the one in /tmp/file1.txt\n\nif it is run from /tmp it is the one in /tmp/tmp/file1.txt\n\nif the program is run from anywhere else the path refers to a file that doesn\nnot exist. ','When creating a Path you can seperate out folder and filename as much\nor as little as you want. When you don\'t begin with a root the Path\nis considered a relative path, which means Java looks from the current\ndirectory.\n\nPath p6 = Paths.get(\"tmp\", \"file1.txt\"); // relative path\n\n/ (root)\n	| - - tmp\n		| - file1.txt\n		| - tmp\n			| - file1.txt\n','IO',0,0,NULL,5),(3995,'got it ','With IO a file doesn\'t exists just because you create a File object.\nIt is the same with Path objects\n\nPath path = Paths.get(\"fileWrite1.txt\");\nsout(Files.exists(path)); // false\nFiles.createFile(path); \nsout(Files.exists(path)); // true','IO',0,0,NULL,5),(3996,'Path path1 = Paths.get(\"/java/source\");\nPath path2 = Paths.get(\"/java/source/directory\");\nPath file = Paths.get(\"/java/source/directory/Program.java\");\nFiles.createDirectory(path1);\nFiles.createDirectory(path2);\nFiles.createFile(file);\n\n// all at once\n\nFiles.createDirectories(path2);\nFile.createFile(file);','create directories one at a time or all at once	......\n\nTHE directory must exist by the time the file is created','IO',0,0,NULL,5),(3997,'13570164000000','Date januaryFirst = new GregorianCalendar(20q3, Calendar.January, 1).getTime();\n\nFile file = new File(\"c:/temp/file\");\nfile.createNewFile();\nfile.setLastModified(januaryFirst.getTime());\nfile.setLastModified(januaryFirst.getTime());\nsout(file.lastModified());\nfile.delete();','IO',0,0,NULL,5),(3998,'2013-01-01T05','Path path = Paths.get(\"c:/temp/file2\");\nDate januaryFirst = new GregorianCalendar(2013,Calendar.JANUARY, 1).getTime();\nFiles.createFile(path);\nFileTime fileTime = FileTime.fromMillis(januaryFirst.getTime());\nFiles.setLastModifiedTime(path,fileTime);\nsout(Files.getLastModifiedTime(path));\nFiles.delete((path);','IO',0,0,NULL,5),(3999,'\nfile.lastModified();\n\nFiles.getLastModifiedTime(path);','How would you get the last modified date/time of a Path and a File?\n\nFile file = new file(\"test\");\nPath path = Paths.get(\"test\");','IO',0,0,NULL,5),(4000,'A C D E F \n\nin an undeterminable order, although thread angela uses the max reference\n.Sleep is static and therefore she puts herself to sleep. This is why\nreferences shouldn\'t be used for static methods. \n\nmax trys to synchronize on angela but he does not own the lock so he therefore\ncannot and throws an IllegalMonitorStateException. \n\n... ','public class Hello {\n    static Thread max ,angela;\n    public static void main(String[] args){\n        angela = new Thread() {\n            public void run(){\n                System.out.println(\"A\");\n                try {\n                    max.sleep(1000);\n                } catch(Exception e){\n                    System.out.println(\"B\");\n                }\n                System.out.println(\"C\");\n                \n            }\n        };\n        \n        max = new Thread() {\n            public void run(){\n                System.out.println(\"D\");\n                try {\n                    angela.wait(); \n                } catch(Exception e){\n                    System.out.println(\"E\");\n                }\n                \n                System.out.println(\"F\");\n            }\n        };\n        \n        max.start();\n        angela.start();   \n    }\n} ','IO',0,0,NULL,5),(4001,'file.canRead();\n\nFiles.isReadable(path);','How would you get theread permision set of a Path and a File?\n\nFile file = new file(\"test\");\nPath path = Paths.get(\"test\");','IO',0,0,NULL,5),(4002,'file.canWrite();\nfile.canExecute();\n\nFiles.isWritable(path);\nFiles.isExecutable(path);','How would you get write and or execute permision set of a Path and a File?\n\nFile file = new file(\"test\");\nPath path = Paths.get(\"test\");','IO',0,0,NULL,5),(4003,'file.setLastModifed(timeinMillis);\n\nFileTime ft = FileTime.fromMillis(timeInMillis);\nFiles.setLastModifiedTime(path,ft);','How do you set the last modified time of a path and file?\n\nFile file = new file(\"test\");\nPath path = Paths.get(\"test\");','IO',0,0,NULL,5),(4004,'basic.creationTime();\nbasic.lastAccessTime();\nbasick.lastModifiedTime();\n\nbasic.isDirectory();\n\n','BasicFileAttributes basic = Files.readAttributes(path, BasicFileAttributes.class);\n\nhow would you list the creation time, last access time, and last Modified time?	\n','IO',0,0,NULL,5),(4005,'1. BasicFileAttributes is PLURAL, BasicFileAttributeVIew is SINGULAR\n\n2. BasicFIleAttributeView basView = Files.getFileAttributeView(   );   \n\n	BasicFileAtttributes bas = FIles.readAttributes(   );\n\n3. You can ONLY update attributes in BasicFileAttributeView, \n	\n	VIEW IS FOR UPDATING','Three big things about BasicFileAttributes and BasicFileAttributeView...','IO',0,0,NULL,5),(4006,'PosixFileAttributes pox = Files.readAttributes(path, PosixFileAttributes.class);\n','How would you construct a PosixFileAttribute object?	','IO',0,0,NULL,5),(4007,'Path path = Paths.get(\"/tmp/file2\");\nFiles.createFile(path);\nPosixFileAttributes ps = Files.readAttributes(path, PosixFileAttributes.class);\n\nSet<PosixFilePermission> perms = PosixFilePermission.fromString(\"rw-r--r--\");\n\nFiles.setPosixFilePermissions(path,perms);\n\nsout( ps.permissions() );\n\nTHe output would be:\n\n[OWNER_WRITE, GROUP_READ, OTHERS_READ, OWNER_READ ]','How would you set a Unix File\'s permissions in Java?	','IO',0,0,NULL,5),(4008,'BasicFileAttributes basic = Files.readAttributes(path1, BasicFileAttribute.class );\n\nFileTime at = basic.lastAccessTime();\nFileTime update = basic.lastModifiedTime();\nFileTime now = FileTime.fromMillis(System.currentTimeMiilis() );\n\nPath file = Paths.get(\"/temp/file.txt\");\nFiles.createFile(file);\n\nBasicFileAttributeView view = Files.getBasicFileAttributeView(file, BasicFileAttributeView.class);\n\nview.setTimes(update, at, now);','How to take modified times from one file\nand write new BasicFileAttributes\' last modified times\nlast access time and creation time to another file ... ?','IO',0,0,NULL,5),(4009,'... interface\n\nmethods:\n\nString 	name()\nReturns the name of the attribute view.\n\nBasicFileAttributes 	readAttributes()\nReads the basic file attributes as a bulk operation.\n\nvoid 	setTimes(FileTime lastModifiedTime, FileTime lastAccessTime, FileTime createTime)\n\nUpdates any or all of the file\'s last modified time, last access time, and create time attributes.','BasicFileAttributeView is a...\n\nClass\n\nInterface\n\nAbstract class     ?','IO',0,0,NULL,5),(4010,'FileTime 	creationTime()\nReturns the creation time.\n\nObject 	fileKey()\nReturns an object that uniquely identifies the given file, or null if a file key is not available.\n\nboolean 	isDirectory()\nTells whether the file is a directory.\n\nboolean 	isOther()\nTells whether the file is something other than a regular file, directory, or symbolic link.\n\nboolean 	isRegularFile()\nTells whether the file is a regular file with opaque content.\n\nboolean 	isSymbolicLink()\nTells whether the file is a symbolic link.\n\nFileTime 	lastAccessTime()\nReturns the time of last access.\n\nFileTime 	lastModifiedTime()\nReturns the time of last modification.\n\nlong 	size()\nReturns the size of the file (in bytes).','interface BasicFileAttributes methods.... ','IO',0,0,NULL,5),(4011,'GroupPrincipal 	group()\nReturns the group owner of the file.\n\nUserPrincipal 	owner()\nReturns the owner of the file.\n\nSet<PosixFilePermission> 	permissions()\nReturns the permissions of the file.','interface PosixFileAttributes methods','IO',0,0,NULL,5),(4012,'String 	name()\nReturns the name of the attribute view.\n\nPosixFileAttributes 	readAttributes()\nReads the basic file attributes as a bulk operation.\n\nvoid 	setGroup(GroupPrincipal group)\nUpdates the file group-owner.\n\nvoid 	setPermissions(Set<PosixFilePermission> perms)\nUpdates the file permissions.','interface PosixFileAttributeView methods ...','IO',0,0,NULL,5),(4013,'DosFileAttributeView has methods...\n\nsetArchive()\nsetHidden()\nsetReadOnly()\nsetSystem()\n\nfor Windows specific files ','With DosFileAttributeView you can set what new and different file types ?','IO',0,0,NULL,5),(4014,'String 	name()\nReturns the name of the attribute view.\n\nDosFileAttributes 	readAttributes()\nReads the basic file attributes as a bulk operation.\n\nvoid 	setArchive(boolean value)\nUpdates the value of the archive attribute.\n\nvoid 	setHidden(boolean value)\nUpdates the value of the hidden attribute.\n\nvoid 	setReadOnly(boolean value)\nUpdates the value of the read-only attribute.\n\nvoid 	setSystem(boolean value)\nUpdates the value of the system attribute.','interface DosFileAttributeView methods...','IO',0,0,NULL,5),(4015,'DosFileAttributes dos = Files.readAttributes(path, DosFileAttributes.class);\n\nsout( dos.isHidden() );\nsout( dos.isReadOnly() );\n\nFiles.setAttribute(path, \"dos:hidden\", true);\nFiles.setAttribute(path, \"dos:readonly\", true);\n\n','read a DosFileAttributes then declare if it is hidden and readonly \nthen set them so without using a DosFileAttributeView...','IO',0,0,NULL,5),(4016,'\n    setAttribute\n\n    public static Path setAttribute(Path path,\n                    String attribute,\n                    Object value,\n                    LinkOption... options)\n                             throws IOException\n\n    Sets the value of a file attribute.\n\n    The attribute parameter identifies the attribute to be set and takes the form:\n\n        [view-name:]attribute-name \n\n    where square brackets [...] delineate an optional component and the character \':\' stands for itself.\n\n    view-name is the name of a FileAttributeView that identifies a set of file attributes. If not specified then it defaults to \"basic\", the name of the file attribute view that identifies the basic set of file attributes common to many file systems. attribute-name is the name of the attribute within the set.\n\n    The options array may be used to indicate how symbolic links are handled for the case that the file is a symbolic link. By default, symbolic links are followed and the file attribute of the final target of the link is set. If the option NOFOLLOW_LINKS is present then symbolic links are not followed.\n\n    Usage Example: Suppose we want to set the DOS \"hidden\" attribute:\n\n        Path path = ...\n        Files.setAttribute(path, \"dos:hidden\", true);\n     \n\n    Parameters:\n        path - the path to the file\n        attribute - the attribute to set\n        value - the attribute value\n        options - options indicating how symbolic links are handled\n    Returns:\n        the path parameter\n    Throws:\n        UnsupportedOperationException - if the attribute view is not available\n        IllegalArgumentException - if the attribute name is not specified, or is not recognized, or the attribute value is of the correct type but has an inappropriate value\n        ClassCastException - if the attribute value is not of the expected type or is a collection containing elements that are not of the expected type\n        IOException - if an I/O error occurs\n        SecurityException - In the case of the default provider, and a security manager is installed, its checkWrite method denies write access to the file. If this method is invoked to set security sensitive attributes then the security manager may be invoked to check for additional permissions.\n\n','You dont always need a XXXFileAttributeView object in order to change\na files attributes, you can just as easily do so with \"Files\" ...\n	','IO',0,0,NULL,5),(4017,'Files.setPosixFilePermissions\n\npublic static Path setPosixFilePermissions(Path path,\n                           Set<PosixFilePermission> perms)\n                                    throws IOException\n\nSets a file\'s POSIX permissions.\n\nThe path parameter is associated with a FileSystem that supports the PosixFileAttributeView. This attribute view provides access to file attributes commonly associated \nwith files on file systems used by operating systems that implement the Portable \nOperating System Interface (POSIX) family of standards.\n\nParameters:\n    path - A file reference that locates the file\n    perms - The new set of permissions\nThrows:\n    UnsupportedOperationException - if the associated file system does not support the PosixFileAttributeView\n    ClassCastException - if the sets contains elements that are not of type PosixFilePermission\n    IOException - if an I/O error occurs\n    SecurityException - In the case of the default provider, and a security manager is installed, it denies RuntimePermission(\"accessUserInformation\") or its checkWrite method denies write access to the file.','You dont need PosixFileAttributeView to set a file permissions either...','IO',0,0,NULL,5),(4018,'PosixFileAttributes pos = Files.readAttributes(path, PosixFileAttributes.class);\nSet<PosixFilePermissions> perms = PosixFilePermissions.fromString(\"rw-r--r--:);\n\nFiles.setPosixFilePermissions(path,perms);\n\nsout(pos.group());\nsout(pos.permissions());','How to set a linux files permisions from a string ?\n	','IO',0,0,NULL,5),(4019,'DirectoryStream<T> \n\nT is the element returned by the iterator. \n\nTHis allows for the convieninet use of a for - each loop to go through a dir.\n\nThe elements returned by the iterator are in no specific order.\n\n List<Path> listSourceFiles(Path dir) throws IOException {\n       List<Path> result = new ArrayList<>();\n       try (DirectoryStream<Path> stream = Files.newDirectoryStream(dir, \"*.{c,h,cpp,hpp,java}\")) {\n           for (Path entry: stream) {\n               result.add(entry);\n           }\n       } catch (DirectoryIteratorException ex) {\n           // I/O error encounted during the iteration, the cause is an IOException\n           throw ex.getCause();\n       }\n       return result;\n   }\n ','What interface is used to recursively loop through a directory ?	','IO',0,0,NULL,5),(4020,'\n    Files.newDirectoryStream\n\n    public static DirectoryStream<Path> newDirectoryStream(Path dir)\n                                                    throws IOException\n\n    Opens a directory, returning a DirectoryStream to iterate over all entries in the directory. The elements returned by the directory stream\'s iterator are of type Path, each one representing an entry in the directory. The Path objects are obtained as if by resolving the name of the directory entry against dir.\n\n    When not using the try-with-resources construct, then directory stream\'s close method should be invoked after iteration is completed so as to free any resources held for the open directory.\n\n    When an implementation supports operations on entries in the directory that execute in a race-free manner then the returned directory stream is a SecureDirectoryStream.\n\n    Parameters:\n        dir - the path to the directory\n    Returns:\n        a new and open DirectoryStream object\n    Throws:\n        NotDirectoryException - if the file could not otherwise be opened because it is not a directory (optional specific exception)\n        IOException - if an I/O error occurs\n        SecurityException - In the case of the default provider, and a security manager is installed, the checkRead method is invoked to check read access to the directory.\n\n','how do you create a new DirectoryStream<T>','IO',0,0,NULL,5),(4021,'Path\n\nThe directory Stream interface is generic, but thats misleading since the \nonly way create a new DirectoryStream is by using File.newDirectoryStream\nwhich returns a Path.','What type of object are returned by directorystreams iterator ? ','IO',0,0,NULL,5),(4022,'use \nFiles.newDirectoryStream(Path dir, String glob);\n\nthis lets you add a glob in that will compare the string representations \nof their file names agains the given glob.\n\nthis lets you filter your results...\n\n Path dir = ...\n     try (DirectoryStream<Path> stream = Files.newDirectoryStream(dir, \"*.java\")) {\n         :\n     }','How would you filter the object returned by a directory Stream ?	','IO',0,0,NULL,5),(4023,'Nothing will not compile, must catch IOException for DirectoryStream','What will be returned by this code...\n\n	Path dir = Paths.get(\"/home/maxbisesi/Documents\");\n        \n	try(DirectoryStream<Path> ds = Files.newDirectoryStream(dir,\"[vx]*\")){\n            sout( );\n        } ','IO',0,0,NULL,5),(4024,'only 1','How many directories at a time can DirectoryStream look at ?','IO',0,0,NULL,5),(4025,'or ...\nDirectoryStream streams one directory','Think, DirectorySteam acts like ls in bash.','IO',0,0,NULL,5),(4026,'public static Path walkFileTree(Path start,\n                FileVisitor<? super Path> visitor)\n                         throws IOException\n\nWalks a file tree.\n\nThis method works as if invoking it were equivalent to evaluating the expression:\n\n     walkFileTree(start, EnumSet.noneOf(FileVisitOption.class), Integer.MAX_VALUE, visitor)\n     \n\nIn other words, it does not follow symbolic links, and visits all levels of the file tree.\n\nParameters:\n    start - the starting file\n    visitor - the file visitor to invoke for each file\nReturns:\n    the starting file\nThrows:\n    SecurityException - If the security manager denies access to the starting file. In the case of the default provider, the checkRead method is invoked to check read access to the directory.\n    IOException - if an I/O error is thrown by a visitor method','What \"Files\" method do you use along with FileVisitor?','IO',0,0,NULL,5),(4027,'FileVisitResult','FileVisitor methods return what ?','IO',0,0,NULL,5),(4028,'CONTINUE\nSKIP_SIBLINGS = continue without visiting the siblings of this file or directory\n\nSKIP_SUBTREE = continue without visiting the entries in this directory\n\nTERMINATE','Enum FileVisitResult elements','IO',0,0,NULL,5),(4029,'SimpleFileVisitor sf = new SimpleFileVisitor() will not compile','SimpleFileVisitor has a protected constructor so It can only be extended','IO',0,0,NULL,5),(4030,'DirectoryStream throws an IOException. Therefore anytime you use \nDirectoryStream you must catch an IOException\n\ntry(DirectoryStream stream = Files.newDirectoryStream(dir)){\n	sout(\"throw excpetion\");\n	//do stuff\n} catch(IOException e) { \n	log(e);\n}','try(DirectoryStream stream = Files.newDirectoryStream(dir)){\n	sout(\"throw excpetion\");\n	//do stuff\n}\n\nWhats wrong here ?','IO',0,0,NULL,5),(4031,'If DirectroyStream is not typed it will give Object elements. Therefore\nto use an untyped DirectoryStream you would have to use...\n	\n	for(Object file : stream) {\n	\n	}\n\n... but thats usually not what you want so always do this>>>\n\n	try(DirectoryStream<Path> Stream = Files.newDirectoryStream(dir)){\n\n	} catch(IOExcetpion e) {\n\n	}','try(DirectoryStream stream = Files.newDirectoryStream(dir)){\n\n	for(Path file : stream){\n		sout(file.getFileName());\n	}\n} catch(IOException e ){\n\n}\n\nWhats wrong here ??','IO',0,0,NULL,5),(4032,'All character stream classes are descended from Reader and Writer. \nAs with byte streams, there are character stream classes that specialize in file I/O: FileReader and FileWriter. \nThe CopyCharacters example illustrates these classes.\n\nclose() throws IOException here too','\npublic class CopyCharacters {\n    public static void main(String[] args) throws IOException {\n\n        FileReader inputStream = null;\n        FileWriter outputStream = null;\n\n        try {\n            inputStream = new FileReader(\"xanadu.txt\");\n            outputStream = new FileWriter(\"characteroutput.txt\");\n\n            int c;\n            while ((c = inputStream.read()) != -1) {\n                outputStream.write(c);\n            }\n        } finally {\n            if (inputStream != null) {\n                inputStream.close();\n            }\n            if (outputStream != null) {\n                outputStream.close();\n            }\n        }\n    }\n}\n','IO',0,0,NULL,5),(4033,'wrap them in Try Block, they all throw IOExceptions ','What has to be done with pretty much ALL IO classes ?','IO',0,0,NULL,5),(4034,'public String readLine()\n                throws IOException\n\nReads a line of text. A line is considered to be terminated by any one of a line feed (\'\\n\'), a carriage return (\'\\r\'), or a carriage return followed immediately by a linefeed.\n\nReturns:\n    A String containing the contents of the line, not including any line-termination characters, or null if the end of the stream has been reached\nThrows:\n    IOException - If an I/O error occurs\n\n\nOther IO classes have read methods that only read in a single character\nBufferedReader has this too. But this method really helps!','What method does BufferedReader have that makes it valuable	','IO',0,0,NULL,5),(4035,'PrintWriter','Which IO class swallows exceptions and does not throw them but \nsaid exceptions can be checked using checkerror()','IO',0,0,NULL,5),(4036,'wont compile you cant construct a FileWriter from a Path not to mention there is an unreported IOException','Path file = Paths.get(\"/home/dick/bigorsmall.txt\");\nBufferedWriter bw = new BufferedWriter(new FileWriter(file));\n\nbw.write(\"this ones pretty big \");','IO',0,0,NULL,5),(4037,'Copy the file from the source to target and return the target.\n\nthrows FileAlreadyExistsException if target fiile already exists, and no\nREPLACE_EXSISTING copy Option is specified. ','Files method:\n\nPath copy(Path src, Path targ, CopyOption...options)','IO',0,0,NULL,5),(4038,'Moves the file from src to target return target. \n\nthrows:\n\n FileAlreadyExistsException - if the target file exists but cannot be replaced because the REPLACE_EXISTING option is not specified (optional specific exception)\n   \n DirectoryNotEmptyException - the REPLACE_EXISTING option is specified but the file cannot be replaced because it is a non-empty directory (optional specific exception)','Files method:\n\nPath move(Path src, Path target, CopyOption options)','IO',0,0,NULL,5),(4039,'false \ntrue\n\nin glob * means match any character excpet a directory boundary\n\n** mathces any character across directory boundaries. \n\nnotice that PathMatcher(\"syntax:pattern\") can take a glob or a regex but you\nmust specify\n\nedit:\nwas previously:\nDefault().getPathMatcher(\"glob: *.txt\");\n\nthere cant be a space after the : or that will mathch...\n\n	Path path = Paths.get(\"one.txt\");\n        PathMatcher matcher = FileSystems.getDefault().getPathMatcher(\"glob: *.txt\");\n        System.out.println(matcher.matches(path));\n\nwould give false unless the space was removed. | Path p1 = Paths.get(\"/home/One.txt\");\nPath p2 = Paths.get(\"One.txt\");\nPathMatcher matcher = FileSystems.getDefault().getPathMatcher(\"glob: *.txt\");\n\nsout( matcher.matches(p1) );\nsout( matcher.matches(p2) );','Path p1 = Paths.get(\"/home/One.txt\");\nPath p2 = Paths.get(\"One.txt\");\nPathMatcher matcher = FileSystems.getDefault().getPathMatcher(\"glob:*.txt\");\n\nsout( matcher.matches(p1) );\nsout( matcher.matches(p2) );','IO',0,0,NULL,5),(4040,'* matches any character inside a directory boundary\n** matches any character inside a directory boundary\n\n','in Glob what does * mean ? what about ** ?','IO',0,0,NULL,5),(4041,'? matches any single character. ','GLOB\n\nwhat does \"?\" mean ?','IO',0,0,NULL,5),(4042,'true\ntrue\nfalse','public class Hello {\n    public static void main(String[] args) {\n        PathMatcher matcher = FileSystems.getDefault().getPathMatcher(\"glob:**{.pic,.txt}\");\n        Path p1 = Paths.get(\"home/files.txt\");\n        Path p2 = Paths.get(\"documents/pictures/smile.pic\");\n        Path p3 = Paths.get(\"home/dir\");\n        \n        System.out.println(matcher.matches(p1));\n        System.out.println(matcher.matches(p2));\n        System.out.println(matcher.matches(p3));\n    }\n\n}','IO',0,0,NULL,5),(4043,'true\ntrue\nfalse','public void matches(Path path, String glob){\n	PathMatcher matcher = FileSystems.getDefault().getPathMatcher(glob);\n	sout( matcher.matches(path) );\n}\n\nPath p1 = Paths.get(\"Bert-book\");\nPath p2 = Paths.get(\"Kathy-horse\");\nmatches(p1, \"glob:{Bert*,Kathy*}\");\nmatches(p2, \"glob: {Bert, Kathy}*\");\nmatches(p1, \"glob:{Bert,Kathy}\");','IO',0,0,NULL,5),(4044,'wrong, visitFileFailed takes an IOExcpeption as a parameter\nas well as postVisitDirectory','FileVisitor\n\npublic FileVisitResult visitFileFailed(path file, BasicFileAttributes attrs) {\n\n	// do something\n	return FileVisitResult.CONTINUE;\n	\n}\n','IO',0,0,NULL,5),(4045,'right, ','FileVisitor: \n\npublic FileVisitResult preVisitDirectory(path file, BasicFileAttributes attrs) {\n\n	// do something\n	return FileVisitResult.CONTINUE;\n	\n}','IO',0,0,NULL,5),(4046,'right','FileVisitor:\n\npublic FileVisitResult visitFileFailed(path file, IOException e) {\n\n	// do something\n	return FileVisitResult.CONTINUE;\n	\n}','IO',0,0,NULL,5),(4047,'right','FileVisitor:\n\npublic FileVisitResult postVisitDirectory(path file, IOException e) {\n\n	// do something\n	return FileVisitResult.CONTINUE;\n	\n}','IO',0,0,NULL,5),(4048,'9/8/01 7:46 PM \n\nremember that strings are imutable, so even though you called \nreplaceAll on that string you didn\'t assing it to a new sString therefore it\nwas lost.\n\nshould be:\n	String newDate = todayFile.replaceAll(\" \",\"-\");','Date today = new Date();\n\nDateFormat df = DateFormat.getInstance();\n\nString todayFile = df.format(today);\n\nsout(todayFile);	// this gives 9/8/01 7:46 PM\n\ntodayFile.replaceAll(\" \",\"-\");\n\nsout( todayFile );\n\nwhat prints now ?','Strings',0,0,NULL,5),(4049,'wont compile, FileWriter doesn\'t have a Path constructor,\n\nchange p1 to p1.toFile();\n\nFileWriter(File file)\nConstructs a FileWriter object given a File object.\n\nFileWriter(File file, boolean append)\nConstructs a FileWriter object given a File object.\n\nFileWriter(FileDescriptor fd)\nConstructs a FileWriter object associated with a file descriptor.\n\nFileWriter(String fileName)\nConstructs a FileWriter object given a file name.\n\nFileWriter(String fileName, boolean append)\nConstructs a FileWriter object given a file name with a boolean indicating whether or not to append the data written.','Path p1 = Paths.get(todayFile+\".txt\");\nSystem.out.println(p1);\n        \nBufferedWriter bw = new BufferedWriter(new FileWriter(p1));','IO',0,0,NULL,5),(4050,'4 3 \n\ntwo rules apply to the first doX, you cannot widen and then box in\none step, and var-args are always chosen last. So you cannot widen shorts\nto ints or longs then box them to Integer or Long but you can box short\nto Short then widen that to Number, that takes priority over var args.\n\nthe second doX simmply boxs int to Integer.\n\n\n\n    Assignment contexts allow the use of one of the following:\n\n        an identity conversion (§5.1.1)\n\n        a widening primitive conversion (§5.1.2)\n\n        a widening reference conversion (§5.1.5)\n\n        a boxing conversion (§5.1.7) optionally followed by a widening reference conversion\n\n        an unboxing conversion (§5.1.8) optionally followed by a widening primitive conversion.\n\n\n','class Eggs {\n	int doX(Long x, Long y){ return 1; }\n	int doX(long...){ return 2; }\n	int doX(Integer x, Integery){ return 3; }\n	int doX(Number n, Number m){ return 4; }\n	public static void main(SA){\n		new Eggs().go();\n	}\n	void go(){\n		short s = 7;\n		sout(doX(s,s) + \" \");\n		sout(doX(7,7));\n	}\n}','General',0,0,NULL,5),(4051,'the first is the directory to start walking at in the form of a Path\n\nthe second is an object of the class that extends SimpleFileVisitor<Path>','What is the first and second argument to Files.walkFileTree()','IO',0,0,NULL,5),(4052,'visitFileFailed and postVisitDirectory','Which Two FileVisitor methods take IOExceptions as parameters	?','IO',0,0,NULL,5),(4053,'preVisitDirectory and visitFile','Which two FileVisitor methods take BasicFileAttributes as parameters ?','IO',0,0,NULL,5),(4054,'now the output is:\n	pre: /home\n	file: /home/a.txt\n	pre: /home/child\n	pre: /home/emptyChild\n	post: /home/emptyChild\n	post: /home\n\npostVisitDirectory is never called if the subtree of the directory is skipped','/home\n	- a.txt\n	- emptyChild	\n	- child\n		- b.txt\n		- grandchild\n			- c.txt\n\npublic class PrintDirs extends SimpleFileVisitor<Path> {\n	public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) {\n		sout( \"pre\" + dir);\n		String name = dir.getFileName().toString();\n		\n		if (name.equals(\"child\"))\n			return FileVisitResult.SKIP_SUBTREE;\n		return FileVisitResult.CONTINUE;\n\n	}\n}\n			\n			\n		\n	','IO',0,0,NULL,5),(4055,'','postVisitDirectory is never called if the subtree of the directory is skipped','IO',0,0,NULL,5),(4056,'assuming child is encountered beffore emptyChild, the output is: \n\npre: /home\nfile: /home/a.txt\npre: /home/child\nfile: /home/child/b.txt\npre: /home/child/grandchild\npost: /home/child\npre: /home/emptyChild\npost: /home\n\nyou skip the grandchld subtree so you dont see the postVisitDirectory call\n\nchild is a sibling but it was encountered before emptychild so it was not skipped','/home\n	- a.txt\n	- emptyChild	\n	- child\n		b.txt\n		grandchild\n		c.txt\n\n\" assume you have FileVisitor method from previous flashcards where the\npre post and file are printed before printing the path of that dir or file \"\n\npublic FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) {\n	sout( \"pre: \" + dir);\n	String name = dir.getFileName().toString();\n	\n	if (name.equals(\"grandchild\"))\n		return FileVisitResult.SKIP_SUBTREE;\n	if ( name.equals(\"emptychild\")\n		return FileVisitResult.SKIP_SIBLINGS;\n	return FileVisitResult.CONTINUE;','IO',0,0,NULL,5),(4057,'true \nfalse\nfalse\nfalse\n\n{A*,b} means A followed by anything or the single character b\n\n/**/ means one or more directories with any name\n\n\\\\* the actuall asterix character \\ escapes the * the second \\ espaces the first \\ ','public void matches(Path path, String glob){\n	PathMatcher matcher = FileSystems.getDefault().getPathMatcher(glob);\n	sout( matcher.matches(path) );\n}\n\nPath p1 = Paths.get(\"0*b/test/1\");\nPath p2 = Paths.get(\"9\\\\*b/test/1\");\nPath p3 = Paths.get(\"01b/test/1\");\nPath p4 = Paths.get(\"0*b/1\");\n\nString glob = \"[0-9]\\\\*{A*,b}/**/1\");\n\nmatches(p1,glob);\nmatches(p2,glob);\nmatches(p3,glob);\nmatches(p4,glob);\n','IO',0,0,NULL,5),(4058,'IOException','What exception if any do FileVisitor methods throw ?','IO',0,0,NULL,5),(4059,'glob: **\n\nregex: .*','glob vs regex: \n\nZero or more of any character, including directory bounndary','IO',0,0,NULL,5),(4060,'zero or or more of any character including directory boundary','regex:\n\n.*','IO',0,0,NULL,5),(4061,'glob: *\n\nregex: no syntax required','glob vs regex:\n\nZero or more of any character, not a directory boundary','IO',0,0,NULL,5),(4062,'glob: ?\n\nregex: .','Glob vs regex:\n\nexcactly one character','IO',0,0,NULL,5),(4063,'glob:\n	{cat, dog}*\n\nregex:\n\n	(cat|dog).*','glob vs regex:\n\nBegins with cat or dog','IO',0,0,NULL,5),(4064,'regex','(cat|dog).*\n\nglob or regex ?','IO',0,0,NULL,5),(4065,'FileSystems.getDefault().getPathMatcher();','You are creating a PathMatcher\n\nPathMatcher matcher = ________._________().__________();','IO',0,0,NULL,5),(4066,'FileSystems.getDefault().newWatchService();','You are creating a WatchService:\n\nWatchService watcher = _____________.__________()._________()','IO',0,0,NULL,5),(4067,'WatchKey\ntry {\n	WatchKey key;\n	try {\n	key = watcher.take();\n              } catch(interuptedException x) {\n		return;\n	}\n	for(WatchEvent<?> event : key.pollEvents()){\n	//do stuff\n	}','What do you get from a WatchService to indicate a deletion creation or modification','IO',0,0,NULL,5),(4068,'take() will wait and block forever until an event takes place. Will throw\nInteruptedException if interuped without taking an event. \n\npoll() returns null if an event is not imediately available. ','What are two ways to get a WatchKey ? \nand whats the difference between them ? ','IO',0,0,NULL,5),(4069,'does not compile countGold() cannot be called from a static context','public class Frodo etends Hobbit {\n	public static void main(SA) { \n		int mygold = 7;\n		sout(countGold(mygold,6));\n	}\n}\nclass Hobbit {\n	int countGold(int x, int y) { return x + y; }\n}','IO',0,0,NULL,5),(4070,'1) If two objects are equal, then they must have the same hash code.\n2) If two objects have the same hash code, they may or may not be equal. \n3) If two objects are not equal, they must NOT have the same hashcode\n','The contract between equals() and hashCode() is:','OOP',0,0,NULL,5),(4071,'shows all files and directories in /home/maxbisesi\n\nsqlexception if the path is not a valid path',' public static void main(String[] args){\n       Path dir = Paths.get(\"/home/maxbisesi\");\n       try(DirectoryStream<Path> stream = Files.newDirectoryStream(dir,\"*\");){\n            for(Path path : stream){\n               System.out.println(path);\n            }\n        } catch(IOException e){\n            System.out.println(\"SQLException\");\n            System.out.println(e);\n        }\n   }','IO',0,0,NULL,5),(4072,'x.a() thread1 x.a() in thread2\nx.b() thread1 x.b() in thread2\nx.b() thread1 y.b() in thread2\n\nthe same instance method of the same instance is blocked while a static\nmethod accross all methods is blocked. ','public class Hello {\n    synchronized void a() { actBusy(); }\n    static synchronized void b() { actBusy(); }\n    static void actBusy() {\n        try {\n            Thread.sleep(1000);\n            \n        } catch( InterruptedException e){}\n            \n        \n    }\n    public static void main(String[] args) {\n        final Hello x = new Hello();\n        final Hello y = new Hello();\n        \n        Runnable runnable = new Runnable() {\n            public void run() {\n                int option = (int) (Math.random() * 4);\n                switch(option) {\n                    case 0: x.a(); break;\n                    case 1: x.b(); break;\n                    case 2: y.a(); break;\n                    case 3: y.b(); break;\n                }\n            }\n        };\n        \n        Thread t1 = new Thread(runnable);\n        Thread t2 = new Thread(runnable);\n        \n        t1.start();\n        t2.start();\n    \n    }\n\n}  \n\nwhich methods could never be running at the same time ?','Threads',0,0,NULL,5),(4073,'got it ','Method forwarding relies on Has-a relationships','OOP',0,0,NULL,5),(4074,'method forwarding\n\nan object composition principle that calles methods on an instance variable of an object','class Animal implements Burriable {\n    private Integer size;\n    private String name;\n    \n    public Animal(int x, String y){\n        size = x;\n        name = y;\n    }\n    public Animal(){\n        size = 0;\n        name = \"\";\n    }\n\n    public int getSize() {\n        return size;\n    }\n\n    public String getName() {\n        return name;\n    }\n    \n    public void bury(){\n        System.out.println(\"just toss him in there...\");\n    }\n    public void digUp(){\n        System.out.println(\"Hang on this ones still kickin !\");\n    }\n    public void pray(){\n        System.out.println(\"...Lord forgive us for what we have done, hes only been gone for \"+YEARSDEAD+\" years.\");\n    }\n}\n\nclass Dog implements Burriable{\n    private Animal animal;\n    public Dog(Animal a){\n        animal = a;\n    }\n    \n    public void bury(){\n        animal.bury();\n    }\n    public void digUp(){\n        animal.digUp();\n    }\n    public void pray(){\n        animal.pray();\n    }\n    \n    public String yelpForHelp(){\n        return \"ar ar arrr....\";\n    }\n}\n\ninterface Burriable {\n    int YEARSDEAD = 1;\n    void bury();\n    void digUp();\n    void pray();\n}\n\nwhat OOP principle is this ?','OOP',0,0,NULL,5),(4075,'The singleton pattern is identifiable bby the static variable for the single instance and the accessor returning it. ','public class F {\n	private static final F f = new F();\n	public static F c(){\n		return f;\n	}\n\n	public void update(F a) { }\n	\n	public void delete(F a) { }\n\n}\nwhat design pattern is this ? ','OOP',0,1,NULL,5),(4076,'object composition, you can tell because of the method forwarding. \nSingleton is tempting but the getInstance method here returns a NEW instance\ninstead a single private static one like it should to be singleton. ','public class E {\n	private D d;\n	public void m() {\n		d.m();\n	}\n\n		public static E getInstance() {\n			return new E();\n		}\n}\n\nclass D {\n	public void m() { }\n}\n\nwhat design pattern principle is this ?\n','OOP',0,0,NULL,5),(4077,'Factory,\n\nClass A is the object we are creating using the factory method. class G\nis the abstract superclass for the factory. Not shown is a class implementing \nclass G that actually creates the object. ','class A {}\n\nabstract class G {\n	A m() { return n(); }\n	abstract A n();\n}\n\nwhat principle is demostrated','OOP',0,0,NULL,5),(4078,'Reuse The DAO pattern centralize logic for the data access code making reuse\neasier and allowing you to switch out implementations. ','which is a benefit of the DAO pattern ?	','OOP',0,0,NULL,5),(4079,'regular files, hidden files, and subdirectories','public void print(Path d) throws IOException {\n	try(DirectoryStream<Path> stream = Files.newDirectoryStream(d)){\n		for(Path path: stream){\n			sout( path.getFileName() );\n		}\n	}\n}\n\nwhat files will this display ? ','IO',0,0,NULL,5),(4080,'The first time the file will be created and copied normally the second time you\nwill get a file already exists excpeiotn','public class Hello {\n    public static void main(String[] dicks) throws IOException{\n      Path src = Paths.get(\"/home/maxbisesi/Documents/copy.txt\");\n      Files.createFile(src);\n      \n      Files.copy(src, Paths.get(\"/home/maxbisesi/Documents/newcopy.txt\"));\n      \n    }\n\n}\n\nwhat happens if this is ran twice and all preivous files dont exist before','IO',0,0,NULL,5),(4081,'Compilation fails, to compile would have to be \n\n	Object item = list.get(0);','public class Hello {\n    public static void main(String[] dicks){\n        ArrayList list = new ArrayList();\n        \n        list.add(\"java\");\n        list.add(\"sucks\");\n        \n        String item = list.get(0);\n\n    }\n\n}','Collections',0,0,NULL,5),(4082,'Will not compile, there is no scope there \n\nif(true){\n	int b = 1;\n} \n	this would though !','if(true)\n       int b = 1;\n        ','General',0,0,NULL,5),(4083,'CooLooLCuuL\n\n* is the greedy quantifier, it takes as much as it can. ','public class Hello {\n    public static void main(String[] dicks){\n        Pattern p = Pattern.compile(\"C.*L\");\n        Matcher m = p.matcher(\"CooLooLCuuLooC\");\n        \n        while(m.find())\n            System.out.println(m.group());\n\n    }\n\n}','Strings',0,0,NULL,5),(4084,'False it gets the same priority as the thread that created it ','If a thread\'s priority is not specified explicitly then it gets\nNORM_PRIORITY\n\nT or F ','Threads',0,0,NULL,5),(4085,'Will not compile, method eat in class animal cannot be applied to given types','public class Hello {\n    public static void main(String[] dicks){\n        Animal ah2 = new Horse();\n        ah2.eat(\"carrots\");\n    }\n\n}\n\nclass Animal{\n    public void eat(){ }\n}\n\nclass Horse extends Animal {\n    public void eat() { }\n    public void eat(String s ){ } \n}\n    ','General',0,0,NULL,5),(4086,'Horse','public class Hello {\n    public static void main(String[] dicks){\n        Animal ah2 = new Horse();\n        ah2.eat();\n    }\n\n}\n\nclass Animal{\n    public void eat(){ System.out.println(\"Animal\"); }\n}\n\nclass Horse extends Animal {\n    public void eat(){ System.out.println(\"Horse\");} \n}\n\n','General',0,0,NULL,5),(4087,'will not compile overriden method \ncannot throw new or broader checked exceptions','public class Hello {\n    public static void main(String[] dicks){\n        Animal ah2 = new Horse();\n        ah2.eat();\n    }\n\n}\n\nclass Animal{\n    public void eat(){ System.out.println(\"Animal\"); }\n}\n\nclass Horse extends Animal {\n    public void eat() throws IOException{ System.out.println(\"Horse\");} \n}','General',0,0,NULL,5),(4088,'Animal\n\neat in horse is an overload, it still inherits Animals eat()','public class Hello {\n    public static void main(String[] dicks){\n        Animal ah2 = new Horse();\n        ah2.eat();\n    }\n\n}\n\nclass Animal{\n    public void eat(){ System.out.println(\"Animal\"); }\n}\n\nclass Horse extends Animal {\n    public void eat(int x) throws IOException{ System.out.println(\"Horse\");} \n}','General',0,0,NULL,5),(4089,'SQLException\n	Statement objects do not support multiple open ResultSets.\n	\n	Only a single ResultSet can be opened from the same statement object\n\n	*if the same statement object is executed more than once the previous\n	ResultSet is closed automatically\n		\n		... and attempting to access a closed RS is a SQLException','//assume valid Connection cn, and good database connection\n\nString query = \"Select * from Answer\";\ntry(Statement stmt = cn.createStatement()){\n	ResultSet rs1 = stmt.executeQuery(query);\n	stmt.executeQuery(\"select * from Question\");\n	while(rs1.next(){\n		sout(rs1.getInt(\"fk_question_num\");\n	}\n} catch(SQLException e){\n	\n}','JDBC',0,0,NULL,5),(4090,'','','blank',0,0,NULL,5),(4091,'SQLException , attempting to execute a query without setting a parameter\nresults in an SQLException\n\n	should be>>>\n		\n		pstmt.setString(1,\"dick\");\n\nIndexing starts at 1','try(Connection conn = DriverManager.getConnection(url,user,pw)){\n	String pQuery = \"Select unitPrice From Book Where Title Like ?\";\n\n	PreparedStatement pstmt = conn.prepareStatement(pQuery);\n\n	ResultSet rs = pstmt.executeQuery();\n} catch(SQLException sq) {\n}\n','JDBC',0,0,NULL,5),(4093,'asdf','adsf','Exceptions',0,0,NULL,5),(4094,'d','d','d',0,0,NULL,5),(4095,'d','d','d',0,0,NULL,7),(4096,'help','help','HELP!!!',0,0,NULL,9),(4097,'d','d','d',0,0,NULL,5),(4098,'qa','qa','qa',0,0,NULL,21),(4099,'1','1','qa',0,0,NULL,21),(4100,'2','2','qa',0,0,NULL,21),(4101,'4','3','qa',0,0,NULL,21),(4102,'7','7','qa',0,0,NULL,21),(4103,'6767','676','qa',0,0,NULL,21),(4104,'qa','qa','qa',0,0,NULL,21),(4105,'qa','qa','qa',0,0,NULL,21),(4107,'d','d','d',0,0,NULL,5),(4108,'er','er','er',0,0,NULL,21),(4113,'hg','hg','hg',0,0,NULL,23),(4114,'yy','y','y',0,0,NULL,21),(4115,'q','q','yq',0,0,NULL,21),(4116,'qqq','qqq','yqqqq',0,0,NULL,21),(4117,'qqq','qqq','yqqqqqqq',0,0,NULL,21),(4118,'adfs','adf','yqqqqqqq',0,0,NULL,21),(4119,'asdf','asdf','yqqqqqqq',0,0,NULL,21),(4120,'asdf','asdf','yqqqqqqq',0,0,NULL,21),(4121,'asdf','asdf','yqqqqqqq',0,0,NULL,21),(4122,'asdf','asdf','yqqqqqqq',0,0,NULL,21),(4123,'asdf','asdf','yqqqqqqq',0,0,NULL,21),(4124,'asdf','asdf','yqqqqqqq',0,0,NULL,21),(4125,'asdf','asdf','yqqqqqqq',0,0,NULL,21),(4126,'asdf','asdf','yqqqqqqq',0,0,NULL,21),(4127,'asdf','asdf','yqqqqqqq',0,0,NULL,21),(4133,'Notice that EntityManagerFactory emf is never initialized, yet calls to it are made. This demonstrates the technique of injection.\n\nThis only works becuase that instance is marked with the @PersistanceUnit anotation. \n\nSimilar to how javaEE container manages the lifecycle of java components such as servlets, javaEE containers also initialize certain variables while the component is coming to life, provided they are marked with annotations.','@Stateful\npublic class ModelEJB {\n    @PersistenceUnit\n   private EntityManagerFactory emf;\n    \n    public void putUserMessage(String messageString) throws MessageException {\n        this.deleteMessage();\n        try {\n            String decodedMessage = URLDecoder.decode(messageString, \"UTF-8\");\n            Message message = new Message(\"1\", \"(\" + messageString + \")\" + \" in a database\");\n            EntityManager em = emf.createEntityManager();\n            em.persist(message);\n        } catch (UnsupportedEncodingException uee ) {\n            throw new MessageException(\"something odd about that message...\" + messageString);\n        }\n    }','EE/Beans',0,1,NULL,5),(4134,'Notice the process of injection here, helloEJB is not intitialized but rather marked with @EJB annotation.','public class WriteServlet extends HttpServlet {\n    @EJB\n    private ModelEJB helloEJB;\n    \n    protected void doPost(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        String message = request.getParameter(PUT_MESSAGE);\n        if (\"\".equals(message)) {\n            helloEJB.deleteMessage();\n        } else {\n            try {\n                helloEJB.putUserMessage(message);\n            } catch (MessageException nme) {\n                throw new ServletException(nme);\n            }    \n        } \n        response.sendRedirect(\"./DisplayServlet\"); \n    }\n    \n}','EE/Beans',0,1,NULL,5),(4135,'','JSPs are Java Servlets: the java EE server compiles JSPs dynamically into servlets at runtime. THus, Java Servlets form the underpinnings of this second kind of web component in the Java platform. ','EE/Servlets',0,0,NULL,5),(4136,'host header carries the hostname of the web server to which the client is sending the request\n\naccept header contains a listing of MIME types that describe the kinds of response body informaiton the client will be able to deal with and the response the server will send back\n\nThe user-agent header indentifies the HTTP client\n\naccpet-encoding and accept language headers are used to inform the server what kind of language formats the client will be able to accept in a response.','HTTP Request\n\nHeaders\nGET /myphotos.html HTTP/1.1\nhost: photoserver.com\naccept: text/html, application/xml\nuser-agent: Mozilla/5.0\naccpt-encoding: gzip\naccept-language: en-US\n\nbody\n\n<empty>','EE/Http',0,0,NULL,5),(4137,'A java object that processes the server side of HTTP interactions. ','Servlet','EE/Servlets',0,0,NULL,5),(4138,'javax.servlet.http.HttpServlet\njavax.servlet.http.HttpServletRequest\njavax.servlet.htttp.HttpServletResponse','Three important Classes in the servlet API','EE/Servlets',0,0,NULL,5),(4139,'Handles al HTTP requests','public void service(HttpServletRequest req, HttpServletResponse resp)','EE/Servlets',0,0,NULL,5),(4140,'doGet \ndoPost\nservice\ndoHead\ndoOptions\ndoPut\ndoTrace','Name all the Http request methods of the Servlet class','EE/Servlets',0,0,NULL,5),(4141,'public Enumeration getHeaderName()\npublic String getHeader(String name)\npublic InputStream getInputStream()\npublic Reader getReader()','HttpServletRequest object contains a variety of methods for reading HTTP request headers and for reading the HTTp request body content, if there is any. The key methods are ?','EE/Servlets',0,0,NULL,5),(4142,'public void setHeader(String name, String value)\npublic OutputStream getOutputStream() \npublic Writer getWriter()','HttpServletResponse methods for setting response headers and body: ','EE/Servlets',0,0,NULL,5),(4143,'process an incoming request','Skeleton for processing incoming http requests:\n\npublic class TemplateServlet extends HttpServlet {\n	\n	protected void service(HttpServletRequest request, HttpServletResponse res){\n		\n		for(Enumeration e = request.getHeaderNames(); e.hasMoreElements; ) {\n			String nextRequestHeaderNae = (String) e.nextElement();\n			String nextRequestHeaderValue = request.getHeader(nextRequestHEaderName);\n			\n			//examine request\n		}\n\n		//read request body\n		InputStream is = request.getInputStream();\n		Reader reader = request.getReader();\n		\n		//Gather Data to send back\n		\n		//set response header\n		response.setHeader(myResponseHEaderName, myResponseHEaderValue);\n		\n		PrintWriter writer = response.getWriter();  //or\n		OutputStream output = response.getOutputStream();\n	}\n}','EE/Servlets',0,0,NULL,5),(4144,'The ServletContext of a web application is an object that represents to all the servlets inside the webp application the container in which it runs. ','javax.servlet.ServletContext','EE/Servlets',0,0,NULL,5),(4145,'','If a servlet does not override an Http request method, the servlet will not respond to those types of requests. ','EE/Servlets',0,0,NULL,5),(4146,'','','EE/Servlets',0,0,NULL,5),(4147,'larger chunks of data uploaded as multipart data over HTTP will likely arrive in a number of parts. This is dependnt on a number of factors, including the client, the size of the file, and the network, and the java EE server. \n\nIterate over the javax.servlet.http.Part object to get the parts\n\nobtain the photo data from the HttpServletRequest object by means of its InputStream, collecting the data in a byte array. ','if (request.getContentType() != null && request.getContentType().startsWith(\"multipart/form-data\")) {\n            this.uploadPhoto(request, pa);\n        }\n\n\nByteArrayOutputStream baos = new ByteArrayOutputStream();\n        String filename = null;\n        for (Part p: request.getParts()) {\n            this.copyBytes(p.getInputStream(), baos);\n            filename = p.getSubmittedFileName();\n        }\n        if (!\"\".equals(filename)) {\n            String photoName = filename.substring(0, filename.lastIndexOf(\".\"));\n            pa.addPhoto(photoName, baos.toByteArray());\n        }','EE/Servlets',0,0,NULL,5),(4148,'All three servlets( RemovePhotoServlet, DisplayAlbumServlet, and DisplayPhotoServlet) share on PhotoAlbum Servlet, which is passed around in and stored in session object so that they can all share one object.  ','//Photo Album object\npublic static PhotoAlbum getPhotoAlbum(HttpSession session) {\n        if (session.getAttribute(ATTRIBUTE_NAME) == null) {\n            PhotoAlbum pa = new PhotoAlbum();\n            session.setAttribute(ATTRIBUTE_NAME, pa);\n        }\n        return (PhotoAlbum) session.getAttribute(ATTRIBUTE_NAME);\n    }\n\n\n//Display servlet\nHttpSession session = request.getSession();\n        PhotoAlbum pa = PhotoAlbum.getPhotoAlbum(session);\n        if (request.getContentType() != null && request.getContentType().startsWith(\"multipart/form-data\")) {\n            this.uploadPhoto(request, pa);\n        }','EE/Servlets',0,0,NULL,5),(4149,'public void init(ServletConfig config) throws ServletException','What method is called by the Java EE web container created a servlet instance ?','EE/Servlets',0,0,NULL,5),(4150,'ServletConfig, gives the servlet a view of configurations. If there is an error in the init method. The Servlet will not come into service. ','What object is passed to the Servlet\'s init() method ?','EE/Servlets',0,0,NULL,5),(4151,'That Servlet will implement any and all HttpRequests, and the servlets doXXX methods will not be called. ','What happens if the service() method is implemented','EE/Servlets',0,0,NULL,5),(4152,'Before being garbage collected, the container calls the servlet\'s \'public void destroy()\' \n\nonce destroy is called that servlet has served its purpose, the same instance can never be reused. ','What happens when a web container decides that is has finished using an instance of a java servlet ?','EE/Servlets',0,0,NULL,5),(4153,'That number varies depending on the web container, whatever the scheme: \n\n-each java servlet instance may handle simultaneous requests from multiple clients\n\n- Each Java Servlet may be instantiated multiple times by the web container. \n\n... so program with concurrent requests in mind. ','How many instances of a servlet will be instantiated ?','EE/Servlets',0,0,NULL,5),(4154,'public Object getAttribute(String name)\npublic Enumeration<String> getAttributeNames()\npublic void removeAttribute(String name)\npublic void setAttribute(String name, Object value)','API for manipulating application data on the ServletContext: ','EE/Servlets',0,0,NULL,5),(4155,'javax.servlet.http.HttpSession\n\nrepresents a series of interactions with a single web application with a single client. \n\nthis is the object to use if you want to program to a particular client. ','If you run the photo application from two seperate browsers, when you upload a photo in one browser and then refresh the display of the application in the other browser, both browsers would display the same photos. \n\nThis is where the HttpSession object comes into play. ','EE/Servlets',0,0,NULL,5),(4156,'public int getMaxInactiveInterval()\npublic void setMaxInactiveInterval(int interval)','what methods are used to control the session timeout ? ','EE/Servlets',0,0,NULL,5),(4157,'public void invalidate()','how do you kill an HttpSession ?','EE/Servlets',0,0,NULL,5),(4158,'JSESSIONID:  in a technique called URL rewriting, any links the web app returns to the client have the session id added in as query string, under the name JSESSIONID. \n\nThis relies on the stateful nature of the underlying SSL protocol. ','The Web container primarily relies on cookies to maintain session information, but if cookies are disabled how can the container still maintain a session ?','EE/Servlets',0,0,NULL,5),(4159,'You ask the web resource represented by the request dispatcher to write the response for you, this means you must not have already written the response yourself. \n\nYou must not try to write to the response after you have already forwarded. ','public void forward(ServletRequest request, ServletResponse response)','EE/Servlets',0,0,NULL,5),(4160,'you want the resource represented by the request dispatcher to fill in some gaps in the response for you. \n\nThis method will include the reponse you have already written some to. ','public void include(ServletRequest request, ServletResponse resp)','EE/Servlets',0,0,NULL,5),(4161,'test ','String indexString = request.getParameter(\"photo\");        \n        int index = (new Integer(indexString.trim())).intValue();\n        HttpSession session = request.getSession();\n        PhotoAlbum myPhotos = PhotoAlbum.getPhotoAlbum(session);\n        myPhotos.removePhoto(index);\n        request.getRequestDispatcher(\"DisplayAlbumServlet\").forward(request, response);','servlets',0,0,NULL,5),(4162,'... an IllegalStateException. \n\nUncommitted output in the response buffer is automatically cleared before the forward. ','RequestDispatcher.forward: \n\nforward should be called before the response has been committed to the client (before response body output has been flushed). If the response already has been committed, this method throws ...','EE/Servlets',0,0,NULL,5),(4163,'You will get an IllegalStateException\n\njava.lang.IllegalStateException: Cannot forward after response has been committed\n\nto fix this do this; \n\nprotected void doPost() {\n    if (someCondition) {\n        sendRedirect();\n        return;\n    }\n    forward();\n}','protected void doPost() {\n    if (someCondition) {\n        sendRedirect();\n    }\n    forward(); \n}\n\nsomeCondition is true.','EE/Servlets',0,0,NULL,5),(4164,'DispatcherType.FORWARD','What is the DispatcherType of a RequestDispatcher after calling its forward() method ?','EE/Servlets',0,0,NULL,5),(4165,'DispatcherType.REQUEST','What is the initial DispatcherType of a Request ?','EE/Servlets',0,0,NULL,5),(4166,'Gets the dispatcher type of this request.\n\nThe dispatcher type of a request is used by the container to select the filters that need to be applied to the request: Only filters with matching dispatcher type and url patterns will be applied.\n\nAllowing a filter that has been configured for multiple dispatcher types to query a request for its dispatcher type allows the filter to process the request differently depending on its dispatcher type.\n\nThe initial dispatcher type of a request is defined as DispatcherType.REQUEST. The dispatcher type of a request dispatched via RequestDispatcher.forward(ServletRequest, ServletResponse) or RequestDispatcher.include(ServletRequest, ServletResponse) is given as DispatcherType.FORWARD or DispatcherType.INCLUDE, respectively, while the dispatcher type of an asynchronous request dispatched via one of the AsyncContext.dispatch() methods is given as DispatcherType.ASYNC. Finally, the dispatcher type of a request dispatched to an error page by the container\'s error handling mechanism is given as DispatcherType.ERROR.','interface javax.servlet.ServletRequest\n\nServletRequest.getDispatcherType\n\nsubinterface:\n\nHttpServletRequest\n\n\nServletRequest.getDispatcherType()\n\n','EE/Servlets',0,0,NULL,5),(4167,'Includes the content of a resource (servlet, JSP page, HTML file) in the response. In essence, this method enables programmatic server-side includes.\n\nThe ServletResponse object has its path elements and parameters remain unchanged from the caller\'s. The included servlet cannot change the response status code or set headers; any attempt to make a change is ignored.\n\nThe request and response parameters must be either the same objects as were passed to the calling servlet\'s service method or be subclasses of the ServletRequestWrapper or ServletResponseWrapper classes that wrap them.\n\nThis method sets the dispatcher type of the given request to DispatcherType.INCLUDE.','interface javax.servlet.RequestDispatcher\n\nRequestDispatcher.include()','EE/Servlets',0,0,NULL,5),(4168,'Nothing .include() does not throw an IllegalStateExcpetion, it only throws a servlet exception or IOexception. ','What can cause RequestDispatcher.include() to throw an illegalstateexpetion ?','EE/Servlets',0,0,NULL,5),(4169,'Because, the RequestDispatcher.include() method calls response.flushBuffer() method and this flushBuffer() method sets the \'committed\' flag for that response object. And hence the exception is thrown in such a scenario as we know that any forward() call on a \'committed\' response results in an IllegalStateException. Read more in this article - Why and when an IllegalStateException is thrown?\n\nThus we can conclude that RequestDispatcher.forward() method should typically be used only in the scenarios where the servlet calling this method is not supposed to do anything for building the response. All the response building task should be delegated to the servlet to which the request is forwarded. Any modification to the response object (header or body or both) will simply cause the RequestDispatcher.forward() method to throw an IllegalStateException for the simple reason that the forward() method is not capable to form a data pipeline among multiple servlets. How can we have moduler Response-Writers in Servlets? How can we form the response object by using multiple servlets?',' Calling include() before forward() throws IllegalStateException - why?','EE/Servlets',0,0,NULL,5),(4170,'javax.servlet.jsp.JspWriter','<% \n        Date now = new Date();\n        SimpleDateFormat sdf = new SimpleDateFormat(\"EEEEEEEE\");\n        String today = sdf.format(now);\n        out.println(today.trim());\n    %>\n\nwhat\'s the type of out ?','EE/JSPs',0,0,NULL,5),(4171,'<%@ directive_name attribute-1=\"value1\" ... %>','JSP Directives dictate properties global to the JSP they take the form : ','EE/JSPs',0,0,NULL,5),(4172,'page, include, taglib','Three JSP directives','EE/JSPs',0,0,NULL,5),(4173,'This directive governs general properties of the JSP, such as characterizing its output, buffering properties, and using imports for java scirplets','JSP page directive','EE/JSPs',0,0,NULL,5),(4174,'Allows this jsp to include the content of another file, useful for including a standard header in your jsp','JSP include directive','EE/JSPs',0,0,NULL,5),(4175,'declares that this jsp will use tags from a speciel tag library. ','jsp taglib directive','EE/JSPs',0,0,NULL,5),(4176,'<@page isThreadSafe=\"false\"%>','The default threading model for jsps is that they are expected to handle mutliple requests concurrently.\nHowever it can be useful to be able to create jsps that you know will only ever be called by one thread at a time. In such cases, jsp implemetnations may choose make any concurrent requests form a line and invoke only the jsp one thread at a time, or it may choose to instantiate multiple instances of the same JSP, each handling only one request at a time. For this use: \n	\n	','EE/JSPs',0,0,NULL,5),(4177,'public class ClockBean implements Serializable {\n    String dateFromat = \"EEEEEEEE\";\n    \n    public void setDateFormat(String dateFormat){\n        this.dateFromat = dateFormat;\n    }\n    \n    public long getCurrentTimeSinceEpoch(){\n        return System.currentTimeMillis();\n    }\n    \n    public String getReadableDate() {\n        Date now = new Date();\n        SimpleDateFormat sdf = new SimpleDateFormat(this.dateFromat);\n        String today = sdf.format(now);\n        return today;\n    }\n}','<%@page contentType=\"text/html\" pageEncoding=\"UTF-8\"%>\n<!DOCTYPE html>\n<html>\n    <head>\n        <title>JSP Clock</title>\n    </head>\n    <body>\n        <jsp:useBean id=\"mybean\" class=\"Model.ClockBean\"/>\n        \n        <div align=\'center\'>\n            <br/>\n            Hello there !\n            <br/><br/>\n            It\'s been <jsp:getProperty name=\"mybean\" property=\"currentTimeSinceEpoch\"/> milliseconds\n            since midnight, January 1st 1970 \n            <br/><br/>\n            In other words, its \n            <jsp:getProperty name=\"mybean\" property=\"readableDate\"/>\n            <br/><br/>\n            <jsp:setProperty name=\"mybean\" property=\"dateFormat\" value=\"MMMMMMMM\"/>\n            or in other words it the month of <jsp:getProperty name=\"mybean\" property=\"readableDate\"/>\n            in\n            <jsp:setProperty name=\"mybean\" property=\"dateFormat\" value=\"YYYY\" />\n            <jsp:getProperty name=\"mybean\" property=\"readableDate\"/>\n        </div>\n    </body>\n</html>\n','EE/Beans',0,0,NULL,5),(4178,'El can be used instead of <jsp:getProperty /> ','<html>\n    <jsp:useBean id=\"weekBean\" class=\"Model.MyWeek\"/>\n    <jsp:setProperty name=\"weekBean\" property=\"name\" value=\"Danny\"></jsp:setProperty>\n    <head>\n        <meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\">\n        <title>Week Example</title>\n    </head>\n    <body><div align=\'center\'>\n        \n        <h2>${weekBean.description}</h2>\n        There are of course <jsp:getProperty name=\"weekBean\" property=\"numberDays\"/> days in the week<p>\n        <jsp:getProperty name=\"weekBean\" property=\"name\"/> works on\n        <c:forEach var=\"day\" items=\"${weekBean.workingDays}\">\n            ${day},\n        </c:forEach>\n            leaving ${weekBean.numberDays - weekBean.numberWorkingDays} days to enjoy other things in life.<p>\n        <c:set var=\"numberDaysOff\" scope=\"session\" value=\"${weekBean.numberDays - weekBean.numberWorkingDays}\"/>\n        That means ${weekBean.name} is working ${100 * weekBean.numberWorkingDays / weekBean.numberDays}% of the time\n        <p>\n        <c:if test=\"${weekBean.numberWorkingDays > (weekBean.numberDays - weekBean.numberWorkingDays)}\" >\n            This is far from ideal :(\n            <p>\n        </c:if> \n        <c:if test=\"${weekBean.weekendOff && !((weekBean.numberDays - weekBean.numberWorkingDays) == 0)}\" >\n            But at least ${weekBean.name} gets some time off and it is at the weekend\n        </c:if> \n    </div></body>  \n</html>','EE/EL',0,0,NULL,5),(4179,'all properties are private and the class uses getters/setters\na public no-arg constructor\nimplements serializable\n','What does it take for a class to be a JavaBean ?','EE/EL',0,0,NULL,5),(4180,'Runtime expression value, means the attribute can be set by a scriptlet or a EL.','<rtexprvalue>true</rtexprvalue>','EE/Tags',0,0,NULL,5),(4181,'Use a jsp action to set the value of a bean to a jsp implicit object using a scriplet','public class PhotoAlbum {\n    public static String ATTRIBUTE_NAME = \"Photo_Album\";\n    private List<byte[]> photoDataList = new ArrayList<byte[]> ();\n    private List<String> names = new ArrayList<String>();\n        \n    public PhotoAlbum() {\n    }\n    \n    public void setSession(HttpSession session) {\n        session.setAttribute(ATTRIBUTE_NAME, this);\n    }\n\n\n<jsp:setProperty name=\"photoAlbum\" property=\"session\" value=\"<%=session%>\"/>','EE/Tags',0,0,NULL,5),(4182,'<c:forEach is a standard tag whose end attribute accesses the photoAlbum bean using EL,\nthis creates a series of links that send a get request to removePhoto servlet setting the photo number as an attribute. ','<c:forEach var=\"i\" begin=\"1\" end=\"${photoAlbum.photoCount}\">\n        <td align=\'center\'>\n              <a href=\'RemovePhotoServlet?photo=${i-1}\'>remove</a>\n         </td>    \n</c:forEach> ','EE/Tags',0,0,NULL,5),(4183,'route requests for the jsf pages(indicated by *.xhtml) to the FacesServlet class that is part of the JSF API','   <servlet>\n        <servlet-name>Faces Servlet</servlet-name>\n        <servlet-class>javax.faces.webapp.FacesServlet</servlet-class>\n        <load-on-startup>1</load-on-startup>\n    </servlet>\n    <servlet-mapping>\n        <servlet-name>Faces Servlet</servlet-name>\n        <url-pattern>*.xhtml</url-pattern>\n    </servlet-mapping>','EE/ServerFaces',0,0,NULL,5),(4184,'result will show Hello to you, #{myHelloBean.name}! \nwithout the annotation in myBean or a mapping in the web.xml jsf cannot be interpreted by the FacesServlet.','web.xml:\n------------\n<web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\"\n	 xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n	 xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd\"\n	 version=\"3.1\">\n    <context-param>\n        <param-name>javax.faces.PROJECT_STAGE</param-name>\n        <param-value>Development</param-value>\n    </context-param>\n        <session-timeout>\n            30\n        </session-timeout>\n    </session-config>\n    <welcome-file-list>\n        <welcome-file>index.jsp</welcome-file>\n    </welcome-file-list>\n</web-app>\n\nbody of jsf\n---------------\n<body>\n        <div align=\"center\">\n            <br></br>\n            <h:form >\n                <h:inputText value=\"#{myHelloBean.name}\"/>\n            </h:form>\n            <br></br>\n            Hello to you, #{myHelloBean.name} !\n        </div>\n    </body>','EE/ServerFaces',0,0,NULL,5),(4185,'result will show what you type in the input box, there is no need to import the bean or anything. The input textbox will appear with the value \'dear reader\'. ',' simple jsf\n----------------------- \n\n<body>\n        <div align=\"center\">\n            <br></br>\n            <h:form >\n                <h:inputText value=\"#{HelloBean.name}\"/>\n            </h:form>\n            <br></br>\n            Hello to you, #{HelloBean.name} !\n        </div>\n    </body>\n\nBean\n-------------\n@Named(value = \"HelloBean\")\n@RequestScoped\npublic class HelloBean {\n    private String name = \"dear reader\";\n    \n    public void setName(String name) {\n        this.name = name;\n    }\n    \n    public String getName() {\n        return this.name;\n    }  \n}\n','EE/ServerFaces',0,0,NULL,5),(4186,' Specifies that a bean is request scoped.\n\nThe request scope is active:\n\n    during the service() method of any servlet in the web application, during the doFilter() method of any servlet filter and when the container calls any ServletRequestListener or AsyncListener,\n    during any Java EE web service invocation,\n    during any remote method invocation of any EJB, during any asynchronous method invocation of any EJB, during any call to an EJB timeout method and during message delivery to any EJB message-driven bean, and\n    during any message delivery to a MessageListener for a JMS topic or queue obtained from the Java EE component environment.\n\nThe request context is destroyed:\n\n    at the end of the servlet request, after the service() method, all doFilter() methods, and all requestDestroyed() and onComplete() notifications return,\n    after the web service invocation completes,\n    after the EJB remote method invocation, asynchronous method invocation, timeout or message delivery completes, or\n    after the message delivery to the MessageListener completes.\n','@RequestScoped','EE/Anotations',0,0,NULL,5),(4187,'JSPs are part of the java technology family and are compiled into servlets and may call beans,\n\nJSF is a framework for building user interfaces and application that includes apis for representing ui components, \n\nYou can use JSF tags in a jsp.\n\n\nJSP is a specialized kind of servlet.\n\nJSF is a set of tags you can use with JSP.\n\nFrom the browser client prespective jsp and jsf look the same. A jsp is converted into a servlet and only has minimal behavior. \n\nA jsf is more suited for a richer environment, it is converted into a component tree by the FacesServlet, follows component lifecycle defined by spec. ','What\'s the difference between JSPs and JSFs ?','EE/JSF',0,0,NULL,5),(4188,'','\n\nThere are also situations where you can favor JSP over JSF. The application nature should be the deciding factor to choose the technology.\n\nIf you have a rich GUI interaction and lot of Java scripting needed then favor JSF. Basically if your GUI app architecture is like Component oriented & even driven like Swing then JSF is the best.\n\nIf the application is just a plain form submitting, not much of GUI interaction needed, then JSP could do well if learning a new tech is an overhead and also complex framework is unnecessary.\n','EE/JSF',0,0,NULL,5),(4189,'','\n\n    Servlets :\n\n    The Java Servlet API enables Java developers to write server-side code for delivering dynamic Web content. Like other proprietary Web server APIs, the Java Servlet API offered improved performance over CGI; however, it has some key additional advantages. Because servlets were coded in Java, they provides an object-oriented (OO) design approach and, more important, are able to run on any platform. Thus, the same code was portable to any host that supported Java. Servlets greatly contributed to the popularity of Java, as it became a widely used technology for server-side Web application development.\n\n    JSP :\n\n    JSP is built on top of servlets and provides a simpler, page-based solution to generating large amounts of dynamic HTML content for Web user interfaces. JavaServer Pages enables Web developers and designers to simply edit HTML pages with special tags for the dynamic, Java portions. JavaServer Pages works by having a special servlet known as a JSP container, which is installed on a Web server and handles all JSP page view requests. The JSP container translates a requested JSP into servlet code that is then compiled and immediately executed. Subsequent requests to the same page simply invoke the runtime servlet for the page. If a change is made to the JSP on the server, a request to view it triggers another translation, compilation, and restart of the runtime servlet.\n\n    JSF :\n\n    JavaServer Faces is a standard Java framework for building user interfaces for Web applications. Most important, it simplifies the development of the user interface, which is often one of the more difficult and tedious parts of Web application development.\n    Although it is possible to build user interfaces by using foundational Java Web technologies(such as Java servlets and JavaServer Pages) without a comprehensive framework designedfor enterprise Web application development, these core technologies can often lead to avariety of development and maintenance problems. More important, by the time the developers achieve a production-quality solution, the same set of problems solved by JSF will have been solved in a nonstandard manner. JavaServer Faces is designed to simplify the development of user interfaces for Java Web applications in the following ways:\n    • It provides a component-centric, client-independent development approach to building Web user interfaces, thus improving developer productivity and ease of use.\n    • It simplifies the access and management of application data from the Web user interface.\n    • It automatically manages the user interface state between multiple requests and multiple clients in a simple and unobtrusive manner.\n    • It supplies a development framework that is friendly to a diverse developer audience with different skill sets.\n    • It describes a standard set of architectural patterns for a web application.\n','EE/JSF',0,0,NULL,5),(4190,'This bean is session scoped and managed, so if you access an application using this bean from a different browser then any changes saved in the first will not be visible to you. \n\nSince it is managed you don\'t need to instantiate it with \'useBean\'\n\nwithout the @Named(\"partyBean\") you would get this \n\n/partyplanner.xhtml @14,58 value=\"#{partyBean.name}\": Target Unreachable, identifier \'partyBean\' resolved to null\n\nsince the container was not notified of this bean\'s existance. \n\n','bean\n---------------\n@Named(\"partyBean\")\n@SessionScoped\npublic class PartyBean implements Serializable {\n    private String name;\n    private boolean parentsAllowed;\n    private List<Guest>items;\n    private String imageUri;\n    \n    public PartyBean() {\n        this.reset();\n    }\n    \n    public String getImageUri() {\n        return this.imageUri;\n    }\n}\n\nserver face:\n---------------------\n<h:form>\n                <label style=\"font-weight:bold\"> Party Pieces </label> <br/><br/>\n                <label>Choose a title: </label>\n                <h:inputText value =\"#{partyBean.name}\" ></h:inputText><br/>\n                <label>Choose a picture: </label>\n                <h:selectOneMenu value=\"#{partyBean.imageUri}\">\n                    <f:selectItem itemValue=\"party1.jpg\" itemLabel=\"Hats\" />\n                    <f:selectItem itemValue=\"party2.jpg\" itemLabel=\"Balloons\" />	   							\n                </h:selectOneMenu><br/>\n                <label>Are parents allowed ? </label>    \n                <h:selectBooleanCheckbox value=\"#{partyBean.parentsAllowed}\" ></h:selectBooleanCheckbox><br/>\n                <h:commandButton value=\"Submit picture and parent choices\" action=\"partyplanner\" /><br/>\n                <h:commandButton value=\"Reset to default\" action=\"#{partyBean.reset}\" /><br/><br/>\n            </h:form>\n\nWhat is the scope of this bean ? ','EE/JSF',0,0,NULL,5),(4191,'Target Unreachable, identifier \'BigBean\' resolved to null','@SessionScoped\npublic Class BigBean implements Serializable {\n   private String name;\n   public BigBean(){ }\n    private getName(){\n      return name;\n   }\n   private setName(String name){\n      this.name = name;\n   }\n}\n\n<h:form>\n       <label style=\"font-weight:bold\"> Party Pieces </label> <br/><br/>\n         <label>Choose a title: </label>\n       <h:inputText value =\"#{BigBean.name}\" ></h:inputText><br/>\n</h:form>\n\nwhat happens when you press enter ? ','EE/JSF',0,0,NULL,5),(4192,'Annotate it with @Named(\" bean-name \")\n\n@ManagedBean was used in older jsf applications ','How do you make a managed bean available for use by nae within a javaserver faces page ?','EE/JSF',0,0,NULL,5),(4193,'Bean scope annotation \n\na managed bean is instantiated once for every request/response interaction, created as the http request arrives and destroyed once the response leaves. \n\na good usecase would be a bean that backs a javaserver face page that gathers contact information then submits it to a DB once the user presses the submit button. ','@RequestScoped','EE/JSF',0,0,NULL,5),(4194,'This bean has the same lifecycle as the HttpSession, \n\nThe bean is created once for each new HttpSession that is created and destroyed when the httpsession to whic hthe java ee webcontainer is associated either times out or is invalidated. \n\neach use of the application will have a unique instance of the bean backing thier jsf.\n\nUseful when you want to associate the application state with a particular user that survives as long as teh user is stil acitve in the application. ','@SessionScoped\n\nbean annotation','EE/JSF',0,0,NULL,5),(4195,'The simplest of all, this bean is created once prior to any users accessing the application and destroyed prior to shutting down the application, This makes this bean a kind of global object that all users have access to, shared for the lifetime of the application. \n\nUseful for application data that is globabl to the application: for instance a chat transcipt, a log of all users, or a history ','@ApplicationScoped \n\nbean annotation','EE/JSF',0,0,NULL,5),(4196,'a type of scope that is instantiated for evey new HTtpSession and can be destroyed by the developer or when the session ends. \n\nUseful when you want a predefined set of interactions with a web application, perhaps the sequence of chats. \n\nTo end a conversation scoped bean use dependcy injection:\n\n@Name(value=\"HelloBean\")\n@RequestScoped\npublic class ConversationBean {\n   @Inject\n    Conversation conversation;\n\n    public void finishINteractions() {\n       conversation.end();\n   }\n\n  ...\n}','@ConversationScoped\n\nbean annotation','EE/JSF',0,0,NULL,5),(4197,'javax.enterprise.context.Conversation\n\na new one is instantiated. ','@Name(value=\"HelloBean\")\n@RequestScoped\npublic class ConversationBean {\n   @Inject\n    Conversation conversation;\n\n    public void finishINteractions() {\n       conversation.end();\n   }\n\n  ...\n}\n\nwhat happens the next a jsf page tries to use this managed bean after its conversation has ended ? ','EE/JSF',0,0,NULL,5),(4198,'contained with the session scop, like conversation scope. \n\nScope is new during a preset sequence of interactions with the web application from a given user. \n\nbut instead of being explicitly managed by API calls from the developer, the boundaries of flow scope are managed by a mechanism in JSF called faces flow ','@FlowScoped\n\nbean annotation\n','EE/JSF',0,0,NULL,5),(4199,'view scope extends request scope by starting while a page is being executed and remains active while the client continues to interact with that same page. Scope becomes inactive once the clinet navigates to a different page. \n\nUseful when coding pages that you expect to post back to themselves. ','@ViewScoped','EE/JSF',0,0,NULL,5),(4200,'\"My scope depends on where i am used. \" \n\nThe lifecycle and cardinality are governed by the componenet that uses it. \n\nuseful for working in components that act in more than one scope, if you have a component that makes currency conversions, you may wish to use this from a javabean that is request scope converting currencies on a single web page, or you may use it from a session-scoped bean that represents a shopping cart for international customers. \n','@Dependent','EE/JSF',0,0,NULL,5),(4201,'<f:validateBean>\n<f:validateRegex>','Which tags can be used to validate Beans?','EE/JSF',0,0,NULL,5),(4202,'validate length','<h:form>\n   <h:inputText id=\"username_component\" validatorMessage=\"Username must between 4 and 10 characters\"/>\n<f:validateLength minimun=\"4\" maximum=\"10/>\n</h:form>','EE/JSF',0,0,NULL,5),(4203,'Checks a value against an implementation of the beans binding api:\njavax.faces.validator.BeanValidator\n','<f:validateBean>','EE/JSF',0,0,NULL,5),(4204,'Checks a value against a regulare expression. Either in the form of a regex expression String: <f:validateRegex patter=\"/[0-9a--zA-Z]\"/>\nor as an implementations of the javax.faces.validator.RegexValidator class: \n\n<f:validateRegex binding=\"myRegexValidator\">','<f:validateRegex>','EE/JSF',0,0,NULL,5),(4205,'@FacesValidator(\"sharkValidator\")\npublic class MyValidator implements Validator {\n	public void validate(FacesContext context, UIComponent component, Object Value) throws ValidatroException {\n\n	//check value\n	// throw exception if it does not pass the check\n}\n\n*how do the parameters get passed here ? ','<f:validator validatorId=\"sharkValidator\">','EE/JSF',0,0,NULL,5),(4206,'for use with command buttons and links this tag resisters teh given implementation of javax.faces.event.ActionListener which is then notified when teh components state changes. \n\n<f:actionListener type=\"classname\" >\n<f:actionListener binding=\"expression evaluating listener instance\">','<f:actionListener>','EE/JSF',0,0,NULL,5),(4207,'For use with all input components and list, this tag registers the given implementation of javax.faces.event.ValueChangeListener, which is then notified when the component\'s state changes. \n\ntype=\"class\"\n\nbinding = \"expression\"','<f:valueChangeListener>','EE/JSF',0,0,NULL,5),(4208,'for use with command buttons and links this tag lets you directlt set the balue of a property on a mangaed bean. \n\n<f:setPropertyActionListener target=\"#{Bean.name}\" value=\"#{namelist.currentname}\">','<f:setPropertyActionListener>\n\nfor use with command buttons and links this tag lets you directlt set the balue of a property on a mangaed bean. ','EE/JSF',0,0,NULL,5),(4209,'<f:convertNumber> Converts a Double or Long object to and from a variety of formats, including standard currency formats and numbers specifying ranges for the nnumber of integer and fractional part digits \n\njavax.faces.convert.NumberConverter','two prebuilt most common data conversion tags in the <f: core library ?','EE/JSF',0,0,NULL,5),(4210,'Converts a Date object to and from a variety of human readable date formats suitable for a variety of locales and teim zones, \n\njavax.faces.convert.DateTimeConverter\n\nlike validators these converters are added as subelemetns to input elements. ','<f:convertDateTime>','EE/JSF',0,0,NULL,5),(4211,'javax.faces.converter.Converter interface. \n\nNest <f:converter converterID=\"converter-name\"> within a component. \n\nimplement the converter interface and two method: \n\npublic String getAsString(FacesContext con, UIComponent com, Object value)\npublic Object getAsObject(FacesContext con, UICommponent, String value)\n\nthen name your converter class to be hooked to the tag with the annotation:\n@FacesConverter(\" name \")','What is used to define your own jsf converter ?','EE/JSF',0,0,NULL,5),(4212,'<c:catch> \ncatches any throwables within this tag uses the name of the var attribute to hold it\n\n<c:choose> \nDefines a set of mutually exclusive choices, used in conjunction with the <c:when> <c:otherwise> tags like a switch statement\n\n<c:if>\n\n<c:foreach>\n\n<c:set> set a page variable by name\n\n<c:when> simple conditional tag\n','JSTL Core tags can also be used in JSF page:','EE/JSF',0,0,NULL,5),(4213,'2 \n\nSessionScoped beans are created once for every new client. ','@Named(value = \"photoBook\")\n@SessionScoped\npublic class PhotoBook implements Serializable { \n    private List<Photo> photos = new ArrayList<>();\n    private Photo currentPhoto = null;\n       \n    public PhotoBook() {\n        \n    }\n    \n    public void setCurrentPhoto(Photo p) {\n        System.out.println(\"setcurrent \" + p);\n        this.currentPhoto = p;\n    }\n    \n    public Photo getCurrentPhoto() {\n        return this.currentPhoto;\n    }\n}\n\nSay two clients access this application from two seperate locations. How many instances will be created ?','EE/Beans',0,0,NULL,5),(4214,'@FacesValidator(\"imageUploadValidator\")\npublic class ImageUploadValidator implements Validator {\n\n    @Override\n    public void validate(FacesContext context, UIComponent component, Object value) throws ValidatorException {\n        Part file = (Part) value;\n        if (!file.getContentType().equals(\"application/octet-stream\")\n                && !file.getContentType().equals(\"image/jpeg\")) {\n            throw new ValidatorException(new FacesMessage(\"The file you tried to upload is not an image file. Please try again.\"));\n        }\n    }\n    \n    \n    \n}','What annotation is needed for a class to be used as a validator in: \n\n<f:validator validatorId=\"imageUploadValidator\" /> ?\n\nWhat interface needs to be implemented ?\n\nWhat method overriden if any, and if so what is its signature ?','EE/Validators',0,0,NULL,5),(4215,'\n\n    CDI beans are classes that CDI can instantiate, manage, and inject automatically to satisfy the dependencies of other objects. Almost any Java class can be managed and injected by CDI.\n\nFor example, PrintServlet got dependency on a Message instance and have it injected automatically by the CDI runtime.\n\nPrintServlet.java\n\n@WebServlet(\"/printservlet\")\npublic class PrintServlet extends HttpServlet {\n    @Inject private Message message;\n\n    @Override\n    public void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        response.getWriter().print(message.get());\n    }\n}\n\nMessage.java (This class is a CDI bean)\n\n@RequestScoped\npublic class Message {\n    @Override\n    public String get() {\n        return \"Hello World!\";\n    }\n}','What\'s a CDI Bean ?','EE/Beans',0,0,NULL,5),(4216,'f:ajax listener is always invoked before any action listener so it is first, and actionListeners are always invoked before action method. \n\n\n    Bean#ajaxListener()\n    Bean#actionListener()\n    ActionListenerType#processAction()\n    Bean#actionListenerBinding()\n    Bean#setProperty()\n    Bean#action()\n \n\n','<h:commandButton value=\"submit\" actionListener=\"#{bean.actionListener}\" action=\"#{bean.action}\">\n    <f:actionListener type=\"com.example.ActionListenerType\" />\n    <f:actionListener binding=\"#{bean.actionListenerBinding()}\" />\n    <f:setPropertyActionListener target=\"#{bean.property}\" value=\"some\" />\n    <f:ajax listener=\"#{bean.ajaxListener}\" />\n</h:commandButton>\n\nWill invoke these methods in what order ? ','EE/JSF',0,0,NULL,5),(4217,'Method Binding: \n\nPass the name of the managed bean method to the actionListener on the UI component\n\nAction Listener:\n\nimplement action listener interface and pass the implementation class name to the action listener attribute of the UI component\n\n','When a user interacts with a component the JSF can be handle the event in two ways : \n','EE/JSF',0,0,NULL,5),(4218,'ManagedBean is deprecated...\n\nThe core difference is, @ManagedBean is managed by JSF framework and is only via @ManagedProperty available to another JSF managed beans. @Named is managed by application server (the container) via CDI framework and is via @Inject available to any kind of a container managed artifact like @WebListener, @WebFilter, @WebServlet, @Path, @Stateless, etc and even a JSF @ManagedBean. From the other side on, @ManagedProperty does not work inside a @Named or any other container managed artifact. It works really only inside @ManagedBean.\n\nAnother difference is that CDI actually injects proxies delegating to the current instance in the target scope on a per-request/thread basis (like as how EJBs are been injected). This mechanism allows injecting a bean of a narrower scope in a bean of a broader scope, which isn\'t possible with JSF @ManagedProperty. JSF \"injects\" here the physical instance directly by invoking a setter (that\'s also exactly why a setter is required, while that is not required with @Inject).\n\nWhile not directly a disadvantage — there are other ways — the scope of @ManagedBean is simply limited. From the other perspective, if you don\'t want to expose \"too much\" for @Inject, you can also just keep your managed beans @ManagedBean. It\'s like protected versus public. But that doesn\'t really count.\n\nAt least, in JSF 2.0/2.1, the major disadvantage of managing JSF backing beans by CDI is that there\'s no CDI equivalent of @ViewScoped. The @ConversationScoped comes close, but still requires manually starting and stopping and it appends an ugly cid request parameter to outcome URLs. MyFaces CODI makes it easier by fully transparently bridging JSF\'s javax.faces.bean.ViewScoped to CDI so you can just do @Named @ViewScoped, however that appends an ugly windowId request parameter to outcome URLs, also on plain vanilla page-to-page navigation. OmniFaces solves this all with a true CDI @ViewScoped which really ties the bean\'s scope to JSF view state instead of to an arbitrary request parameter.\n\nJSF 2.2 (which is released 3 years after this question/answer) offers a new fully CDI compatible @ViewScoped annotation out the box in flavor of javax.faces.view.ViewScoped. JSF 2.2 even comes along with a CDI-only @FlowScoped which doesn\'t have a @ManagedBean equivalent, hereby pushing JSF users towards CDI. The expectation is that @ManagedBean and friends will be deprecated as per Java EE 8. If you\'re currently still using @ManagedBean, it\'s therefore strongly recommend to switch to CDI to be prepared for future upgrade paths. CDI is readily available in Java EE Web Profile compatible containers, such as WildFly, TomEE and GlassFish. For Tomcat, you have to install it separately, exactly as you already did for JSF. See also How to install CDI in Tomcat?','What\'s the difference between @Named and @ManagedBean when marking a bean ?','EE/JSF',0,0,NULL,5),(4219,'@ManagedBean is deprecated it was originally used to manage beans only by the JSF framework where @Named Beans are managed by CDI','what\'s the difference between @ManagedBean and @Named','EE/JSF',0,0,NULL,5),(4220,'hardcode the name of the page to navigate to, if the method passed to action attribute returns a string that will be the page to navigate to, if it returns null or void the current page will remain and the view scope will remain alive. \n\nA return value of an empty string or the same view ID will also return to the same page, but recreate the view scope and thus destroy any currently active view scoped beans and, if applicable, recreate them. \n\nThe action method can be any valid MethodExpression, also the ones which uses EL 2.2 arguments such as below:\n\n<h:commandXxx value=\"submit\" action=\"#{bean.edit(item)}\" />\n\nWith this method:\n\npublic void edit(Item item) {\n    // ...\n}\n\nNote that when your action method solely returns a string, then you can also just specify exactly that string in the action attribute. Thus, this is totally clumsy:\n\n<h:commandLink value=\"Go to next page\" action=\"#{bean.goToNextpage}\" />\n\nWith this senseless method returning a hardcoded string:\n\npublic String goToNextpage() {\n    return \"nextpage\";\n}\n\nInstead, just put that hardcoded string directly in the attribute:\n\n<h:commandLink value=\"Go to next page\" action=\"nextpage\" />','How can you navigate with action attribute of commandButton','EE/JSF',0,0,NULL,5),(4221,'/index.xhtml @20,54 value=\"#{User.UserStatement}\": The class \'Beans.User\' does not have the property \'UserStatement\'.','<h:body>\n        <h:form>\n            <h:outputLabel for=\"username\" value=\"User Name\"/>\n            <h:inputText id=\"username\" value=\"#{User.name}\"/>\n            <h:outputLabel for=\"userprofile\" value=\"Profile\"/>\n            <h:inputText value=\"#{User.profile}\"/>\n            <h:outputLabel for=\"userssn\" value=\"Social Security Number\"/>\n            <h:inputText id=\"userssn\" value=\"#{User.ssn}\"/>\n            <h:outputLabel for=\"userbalance\" value=\"Balance\"/>\n            <h:inputText id=\"userbalance\" value=\"#{User.balance}\"/>\n            <h:commandButton id=\"createuser\" value=\"Add User\" action=\"#{User.showUser}\"/>\n        </h:form>\n        <h:outputText value=\"#{User.UserStatement}\"/>\n    </h:body>\n\n\n@Named(value=\"User\")\n@RequestScoped\npublic class User implements Serializable{\n    private String name;\n    private String profile;\n    private String ssn;\n    private Integer balance;\n    private String statement;\n    \n    public User(){\n        \n    }\n    \n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public String getProfile() {\n        return profile;\n    }\n\n    public void setProfile(String profile) {\n        this.profile = profile;\n    }\n\n    public String getSsn() {\n        return ssn;\n    }\n\n    public void setSsn(String ssn) {\n        this.ssn = ssn;\n    }\n\n    public Integer getBalance() {\n        return balance;\n    }\n\n    public void setBalance(Integer balance) {\n        this.balance = balance;\n    }\n    \n    public String getUserStatement(){\n        return this.statement;\n    }\n    \n    public String showUser(){\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"The user is created is named\");\n        sb.append(this.name);\n        sb.append(\"Their ssn is:\");\n        sb.append(this.ssn);\n        this.statement = sb.toString();\n        return null;\n    }\n   \n}','EE/JSF',0,0,NULL,5),(4222,'So the for attribute must point to the id of the input component the label is intented to label. The label has the following SEO and usability advantages:\n\n    It tells in text about the associated input element.\n    It focuses and activates the associated input element when being focused/clicked itself.\n\nAs JSF is in the context of this question merely a HTML code generator, exactly the same applies to JSF components generating that HTML as well.\n\n<h:outputLabel for=\"email\">Email address</h:outputLabel>\n<h:inputText id=\"email\" />\n\nSearchbots will find the label and index the associated input element as such. Screenreaders as used by visually disabled people will find the label and tell its contents by sound. Endusers can click the label to see the associated input getting focused. Checkboxes/radiobuttons will be selected when clicking the label. File inputs will open the browse dialog when clicking the label. Etcetera.\n\nNoted should be that relatively a lot of low-quality JSF tutorials are abusing the <h:outputLabel> with the sole purpose to print out some Hello World text like so:\n\n<h:outputLabel value=\"#{bean.message}\" />\n\nThis particular use case is thus wrong. Instead, a <h:outputText> should have been used:\n\n<h:outputText value=\"#{bean.message}\" />\n\nOr even just EL in template text:\n\n#{bean.message}','<h:outputLabel for=\" ...','EE/JSF',0,0,NULL,5),(4223,'<h:commandLink/>','Which jsf component will generate a <a> tag ?','EE/JSF',0,0,NULL,5),(4224,'','Abusing an @ApplicationScoped bean for session/view/request scoped data would make it to be shared among all users, so anyone else can see each other\'s data which is just plain wrong. Abusing a @SessionScoped bean for view/request scoped data would make it to be shared among all tabs/windows in a single browser session, so the enduser may experience inconsitenties when interacting with every view after switching between tabs which is bad for user experience. Abusing a @RequestScoped bean for view scoped data would make view scoped data to be reinitialized to default on every single (ajax) postback, causing possibly non-working forms (see also points 4 and 5 here). Abusing a @ViewScoped bean for request, session or application scoped data, and abusing a @SessionScoped bean for application scoped data doesn\'t affect the client, but it unnecessarily occupies server memory and is plain inefficient.','EE/Beans',0,0,NULL,5),(4225,'','Which scope to choose depends solely on the data (the state) the bean holds and represents. Use @RequestScoped for simple and non-ajax forms/presentations. Use @ViewScoped for rich ajax-enabled dynamic views (ajaxbased validation, rendering, dialogs, etc). Use @FlowScoped for the \"wizard\" (\"questionnaire\") pattern of collecting input data spread over multiple pages. Use @SessionScoped for client specific data, such as the logged-in user and user preferences (language, etc). Use @ApplicationScoped for application wide data/constants, such as dropdown lists which are the same for everyone, or managed beans without any instance variables and having only methods.','EE/Beans',0,0,NULL,5),(4226,'','Note that the scope should rather not be chosen based on performance implications, unless you really have a low memory footprint and want to go completely stateless; you\'d need to use exclusively @RequestScoped beans and fiddle with request parameters to maintain the client\'s state. Also note that when you have a single JSF page with differently scoped data, then it\'s perfectly valid to put them in separate backing beans in a scope matching the data\'s scope. The beans can just access each other via @ManagedProperty in case of JSF managed beans or @Inject in case of CDI managed beans.','EE/Beans',0,0,NULL,5),(4227,'','The JSF @NoneScoped and CDI @Dependent basically lives as long as a single EL-evaluation on the bean. Imagine a login form with two input fields referring a bean property and a command button referring a bean action, thus with in total three EL expressions, then effectively three instances will be created. One with the username set, one with the password set and one on which the action is invoked. You normally want to use this scope only on beans which should live as long as the bean where it\'s being injected. So if a @NoneScoped or @Dependent is injected in a @SessionScoped, then it will live as long as the @SessionScoped bean.','EE/Beans',0,0,NULL,5),(4228,'The userlist face displays the name of the user just entered, if a user is not first entered then nothing is displayed...','userbean\n--------------------\n@Named(value=\"User\")\n@RequestScoped\npublic class User implements Serializable{\n    private String name;\n    private String profile;\n    private String ssn;\n    private Integer balance;\n    private String statement;\n    \n    public User(){\n        \n    }\n    \n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public String getProfile() {\n        return profile;\n    }\n\n    public void setProfile(String profile) {\n        this.profile = profile;\n    }\n\n    public String getSsn() {\n        return ssn;\n    }\n\n    public void setSsn(String ssn) {\n        this.ssn = ssn;\n    }\n\n    public Integer getBalance() {\n        return balance;\n    }\n\n    public void setBalance(Integer balance) {\n        this.balance = balance;\n    }\n    \n    public String getUserStatement(){\n        return this.statement;\n    }\n    \n    public String showUser(){\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"The user is created is named\");\n        sb.append(this.name);\n        sb.append(\"Their ssn is:\");\n        sb.append(this.ssn);\n        this.statement = sb.toString();\n        return null;\n    }\n   \n}\n\nindex\n------------\n<h:body>\n        <h:form>\n            <h:outputLabel for=\"username\" value=\"User Name\"/>\n            <h:inputText id=\"username\" value=\"#{User.name}\"/>\n            <h:outputLabel for=\"userprofile\" value=\"Profile\"/>\n            <h:inputText value=\"#{User.profile}\"/>\n            <h:outputLabel for=\"userssn\" value=\"Social Security Number\"/>\n            <h:inputText id=\"userssn\" value=\"#{User.ssn}\"/>\n            <h:outputLabel for=\"userbalance\" value=\"Balance\"/>\n            <h:inputText id=\"userbalance\" value=\"#{User.balance}\"/>\n            <h:commandButton id=\"createuser\" value=\"Add User\" action=\"#{User.showUser}\"/>\n            <h:commandButton id=\"userlist\" action=\"UserList\" value=\"User List\"/>\n        </h:form>\n        <h:outputText value=\"#{User.userStatement}\"/>\n    </h:body>\n\nuserlist face\n----------------\n<h:head>\n        <title>TODO supply a title</title>\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"/>\n    </h:head>\n    <h:body>\n        #{User.name}\n    </h:body>\n\n\nthe user adds a user then clicks the userlist button what happens ?','EE/JSF',0,0,NULL,5),(4229,'Upon pressing the save user button, the current page is reloaded and therefore the view scoped bean is destroyed, therefore there is no current bean and you get: \n\n/index.xhtml @11,62 value=\"#{User.name}\": Target Unreachable, identifier \'User\' resolved to null','UserBean\n--------------\n@Named(value=\"User\")\n@ViewScoped\npublic class User implements Serializable{\n    private String name;\n    private String profile;\n    private String ssn;\n    private Integer balance;\n    private String statement;\n    \n    public User(){\n        \n    }\n    \n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public String getProfile() {\n        return profile;\n    }\n\n    public void setProfile(String profile) {\n        this.profile = profile;\n    }\n\n    public String getSsn() {\n        return ssn;\n    }\n\n    public void setSsn(String ssn) {\n        this.ssn = ssn;\n    }\n\n    public Integer getBalance() {\n        return balance;\n    }\n\n    public void setBalance(Integer balance) {\n        this.balance = balance;\n    }\n    \n    public String getUserStatement(){\n        return this.statement;\n    }\n    \n    public String showUser(){\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"The user is created is named\");\n        sb.append(this.name);\n        sb.append(\"Their ssn is:\");\n        sb.append(this.ssn);\n        this.statement = sb.toString();\n        return null;\n    }\n   \n}\n\nindex.xhtml\n------------------\n<h:form>\n            <h:outputLabel for=\"username\" value=\"User Name\"/>\n            <h:inputText id=\"username\" value=\"#{User.name}\"/>\n            <h:outputLabel for=\"userprofile\" value=\"Profile\"/>\n            <h:inputText value=\"#{User.profile}\"/>\n            <h:outputLabel for=\"userssn\" value=\"Social Security Number\"/>\n            <h:inputText id=\"userssn\" value=\"#{User.ssn}\"/>\n            <h:outputLabel for=\"userbalance\" value=\"Balance\"/>\n            <h:inputText id=\"userbalance\" value=\"#{User.balance}\"/>\n            <h:commandButton id=\"createuser\" value=\"Add User\" action=\"#{User.showUser}\"/>\n            <h:commandButton id=\"userlist\" action=\"UserList\" value=\"User List\"/>\n        </h:form>\n        <h:outputText value=\"#{User.userStatement}\"/>\n\nUser list face\n-----------------\n<h:head>\n        <title>TODO supply a title</title>\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"/>\n    </h:head>\n    <h:body>\n        #{User.name}\n    </h:body>\n\na user types in their information, adds a user, then navigates to the USer list face. What happens ?','EE/JSF',0,0,NULL,5),(4230,'ActionEvent, BehaviorEvent, ValueChangeEvent','What are the three subclasses of javax.faces.event.FacesEvent','EE/JSF',0,0,NULL,5),(4231,'@FacesValidator(\"imageUploadValidator\")\npublic class ImageUploadValidator implements Validator {\n\n    @Override\n    public void validate(FacesContext context, UIComponent component, Object value) throws ValidatorException {\n        Part file = (Part) value;\n        if (!file.getContentType().equals(\"application/octet-stream\")\n                && !file.getContentType().equals(\"image/jpeg\")) {\n            throw new ValidatorException(new FacesMessage(\"The file you tried to upload is          not an image file. Please try again.\"));\n        }\n    }\n    \n    \n    \n}','Implement a validator that','EE/JSF',0,0,NULL,5),(4232,'Yes, though the abstract method in Validator interface declares that it throws a ValidatorException the overriding method can declare that it does not throw any exception and still compile, but this is bad practice, for the Validator to work it must be able to throw a ValidatorException when a value is invalid.','public class UserValidator implements Validator {\n    \n    public void validate(FacesContext context,UIComponent component,Object value) {\n        \n    }\n    \n}\n\n... will this compile ?','EE/JSF',0,0,NULL,5),(4233,'NumberFormatException, there is a space before the 10, that won\'t work. ','<f:validateLength minimum=\"5\" maximum=\" 10\"/>','EE/JSF',0,0,NULL,5),(4234,'<h:inputText value=\"#{User.profile}\" required=\"true\" requiredMessage=\"Don\'t forget their profile!\"/>','How can you make an input required and present a message if the requirment is not filled. ','EE/JSF',0,0,NULL,5),(4235,'','JSP Core tags\n------------------------\ncatch:	\nCatches any Throwable that occurs in its body and optionally exposes it.\n\nchoose:	\nSimple conditional tag that establishes a context for mutually exclusive conditional operations, marked by <when> and <otherwise>\n\nif	\nSimple conditional tag, which evalutes its body if the supplied condition is true and optionally exposes a Boolean scripting variable representing the evaluation of this condition\n\nimport	\nRetrieves an absolute or relative URL and exposes its contents to either the page, a String in \'var\', or a Reader in \'varReader\'.\n\nforEach	\nThe basic iteration tag, accepting many different collection types and supporting subsetting and other functionality\n\nforTokens\n	Iterates over tokens, separated by the supplied delimeters\nout	Like <%= ... >, but for expressions.\notherwise	Subtag of <choose> that follows <when> tags and runs only if all of the prior conditions evaluated to \'false\'\n\nparam	\nAdds a parameter to a containing \'import\' tag\'s URL.\n\nredirect	\nRedirects to a new URL.\n\nremove	\nRemoves a scoped variable (from a particular scope, if specified).\n\nset	\nSets the result of an expression evaluation in a \'scope\'\n\nurl	\nCreates a URL with optional query parameters.\n\nwhen	\nSubtag of <choose> that includes its body if its condition evalutes to \'true\' ','EE/JSPs',0,0,NULL,5),(4236,'','','EE/JSPs',0,0,NULL,5),(4237,'<jsp:useBean id=\"game\" scope=\"session\" class=\"Beans.TicTacToeGame\" \n\n... or ..\n\nbeanName=\"TicTacToe\"/>\n\nif you use class you have to include the package or you can use the beans name according to @Named.','@Named(\"TicTacToe\")\n@SessionScoped\npublic class TicTacToeGame implements Serializable{\n    private List<String> squares;\n    \n    public TicTacToeGame(){\n        for(int i =0; i<9; i++){\n            squares.add(\"_\");\n        }\n    }   \n}\n\n...create the use bean tag for this bean','EE/JSPs',0,0,NULL,5),(4238,'Will not compile, cannot specify both class name and bean name. ','<jsp:useBean id=\"game\" scope=\"session\" class=\"Beans.TicTacToeGame\" beanName=\"TicTacToe\"/>','EE/JSPs',0,0,NULL,5),(4239,'Node Ruby JAva PHP Clojure Go Scala Python','What are the eight officially supported languages on the Heroku Platform? ','SalesforcePD1',0,3,NULL,5),(4240,'Bidirectional Sync allowing data to be written into SFDC\nReal Time Sync between salesforce and postgres','What are two features of Heroku Connect ?','SalesforcePD1',1,2,NULL,5),(4241,'Full Sandbox\nPartial Sandbox','A Developer needs to test an invoicing system integration. After reviewing the numbers of transaction required for the test, the developer estimates that the test data will total about 2GB of data storage. Production data is not required for integration testing. Which two environments meet the requirements for testing? Choose 2 answers','SalesforcePD1',0,3,NULL,5),(4242,'<Apex:stylesheet> tag\ninline css\na static resource','Which three options allow a developer to use stylesheets? ','SalesforcePD1',0,2,NULL,5),(4243,'','The system saves the records that fired the before trigger after the trigger finishes execution. You can modify the records in the trigger without explicitly calling a DML insert or update operation. If you perform DML statements on those records, you get an error.','SalesforcePD1',0,2,NULL,5),(4244,'','Trigger context variables ...\n\nTrigger.XXX ...\n\nisExecuting: 	Returns true if the current context for the Apex code is a trigger, not a Visualforce page, a Web service, or an executeanonymous() API call.\n\nisInsert:	Returns true if this trigger was fired due to an insert operation, from the Salesforce user interface, Apex, or the API.\n\nisUpdate: Returns true if this trigger was fired due to an update operation, from the Salesforce user interface, Apex, or the API.\n\nisDelete: 	Returns true if this trigger was fired due to a delete operation, from the Salesforce user interface, Apex, or the API.\n\nisBefore: 	Returns true if this trigger was fired before any record was saved.\n\nisAfter: 	Returns true if this trigger was fired after all records were saved.\n\nisUndelete 	Returns true if this trigger was fired after a record is recovered from the Recycle Bin (that is, after an undelete operation from the Salesforce user interface, Apex, or the API.)\n\nnew 	Returns a list of the new versions of the sObject records.\n\nThis sObject list is only available in insert, update, and undelete triggers, and the records can only be modified in before triggers.\n\nnewMap 	A map of IDs to the new versions of the sObject records.\n\nThis map is only available in before update, after insert, after update, and after undelete triggers.\n\nold 	Returns a list of the old versions of the sObject records.\n\nThis sObject list is only available in update and delete triggers.\noldMap 	A map of IDs to the old versions of the sObject records.\n\nThis map is only available in update and delete triggers.\nsize 	The total number of records in a trigger invocation, both old and new.','SalesforcePD1',0,1,NULL,5),(4245,'That\'s how sandeep does it','trigger MaintenanceRequest on Case (before update, after update) {\n    // call MaintenanceRequestHelper.updateWorkOrders  \n    if(Trigger.isBefore){\n        \n    }else if(Trigger.isAfter){\n        //Create new routine maintenanc request for each new closed request\n        MaintenanceRequestHelper.updateWorkOrders(Trigger.newMap,Trigger.oldMap);\n    }\n}\n\n\npublic class MaintenanceRequestHelper {\n    \n    public static void updateWorkOrders(Map<Id,Case>newmap, Map<Id,Case> oldmap){\n        List<Case> maintenanceRequestInserts = new List<Case>();\n        for(Case tmpCase : newmap.values()){\n            if(tmpCase.Status == \'Closed\' && (tmpCase.Type == \'Repair\' || tmpCase.Type == \'Routine Maintenance\')\n               && oldmap.get(tmpCase.Id).Status != \'Closed\'){\n                   Case maintenance = new Case(Type = \'Routine Maintenance\',\n                       						   Equipment__c = tmpCase.Equipment__c,\n                                               Vehicle__c = tmpCase.Vehicle__c,\n                                               Subject = \'Not null\',\n                                               Date_Reported__c = Date.today()\n                                              );\n                   maintenanceRequestInserts.add(maintenance);\n               }\n        }\n        insert maintenanceRequestInserts;\n    }        \n    \n}','SalesforcePD1',0,1,NULL,5),(4246,'','Future methods must be static methods, and can only return a void type. The specified parameters must be primitive data types, arrays of primitive data types, or collections of primitive data types. Notably, future methods can’t take standard or custom objects as arguments. A common pattern is to pass the method a List of record IDs that you want to process asynchronously.','SalesforcePD1',0,1,NULL,5),(4247,'','The reason why objects can’t be passed as arguments to future methods is because the object can change between the time you call the method and the time that it actually executes. Remember, future methods are executed when system resources become available. In this case, the future method may have an old object value when it actually executes, which can cause all sorts of bad things to happen.','SalesforcePD1',0,1,NULL,5),(4248,'To make a Web service callout to an external service or API, you create an Apex class with a future method that is marked with (callout=true). ',' @future(callout=true)\n    public static void sendSMSAsync(String fromNbr, String toNbr, String m) {\n        String results = sendSMS(fromNbr, toNbr, m);\n        System.debug(results);\n    }','SalesforcePD1',0,1,NULL,5),(4249,'Send a request','Http http = new Http();\nHttpRequest request = new HttpRequest();\nrequest.setEndpoint(\'https://th-apex-http-callout.herokuapp.com/animals\');\nrequest.setMethod(\'GET\');\nHttpResponse response = http.send(request);\n// If the request is successful, parse the JSON response.\nif (response.getStatusCode() == 200) {\n    // Deserialize the JSON string into collections of primitive data types.\n    Map<String, Object> results = (Map<String, Object>) JSON.deserializeUntyped(response.getBody());\n    // Cast the values in the \'animals\' key as a list\n    List<Object> animals = (List<Object>) results.get(\'animals\');\n    System.debug(\'Received the following animals:\');\n    for (Object animal: animals) {\n        System.debug(animal);\n    }\n}','SalesforcePD1',0,1,NULL,5),(4250,'response.getBody();','What method would you use to get the content of an HttpResponse ?','SalesforcePD1',0,1,NULL,5),(4251,'Authorize the URL in \'Remote Site Settings\'','Before permorming a REST callout you must ...','SalesforcePD1',0,3,NULL,5),(4252,'This is good but in superbadge example, the fields are not the same in Salesforce as they are in JSON. \n\nThere for you need to parse manually based on the text. \n','			JSONParser parser = JSON.createParser(response.getBody());\n            \n            while(parser.nextToken() != null){\n                if(parser.getCurrentToken() == JSONToken.START_ARRAY){\n                    while(parser.nextToken() != null){\n                        if(parser.getCurrentToken() == JSONToken.START_OBJECT){\n                            Product2 prod = (Product2)parser.readValueAs(Product2.class);\n                            System.debug(prod.Name);\n                            System.debug(prod.Id);\n                        }\n                    }\n                }\n                \n            }','SalesforcePD1',0,1,NULL,5),(4253,'IN :List<String> works too !','List<Product2> currentProducts = [Select ID, Name, Cost__c, Current_Inventory__c,\n                  Lifespan_Months__c, Maintenance_Cycle__c,    Replacement_Part__c,\n                  Warehouse_SKU__c From Product2\n                  Where Name IN :prods];','SalesforcePD1',0,2,NULL,5),(4254,'to check','Database.SaveResult[] srlist = Database.update(currentProducts,false);\n            \n            for(Database.SaveResult sr : srlist){\n                if(sr.isSuccess()){\n                    System.debug(\'successfully updated: \'+sr.getId());\n                } else {\n                    for(Database.Error err : sr.getErrors()){\n                        System.debug(\'The following error has occurred.\');                   \n	            		System.debug(err.getStatusCode() + \': \' + err.getMessage());\n                        System.debug(\'Account fields that affected this error: \' + err.getFields());\n                    }\n                }\n            }','SalesforcePD1',0,1,NULL,5),(4255,'WNC, Defining type for global methods must be defined as global. ','public class WarehouseSyncSchedule implements Schedulable {\n  // implement scheduled code here\n    global void execute(SchedulableContext context){\n        \n    }\n  \n}','SalesforcePD1',0,1,NULL,5),(4256,'','The parameter of this method is a SchedulableContext object. After a class has been scheduled, a CronTrigger object is created that represents the scheduled job. It provides a getTriggerId method that returns the ID of a CronTrigger API object.','SalesforcePD1',0,3,NULL,5),(4257,'this is a lot easier!','You can also schedule a class using the user interface.\n\n    From Setup, enter Apex in the Quick Find box, then select Apex Classes.\n    Click Schedule Apex.\n    For the job name, enter something like Daily Oppty Reminder.\n    Click the lookup button next to Apex class and enter * for the search term to get a list of all classes that can be scheduled. In the search results, click the name of your scheduled class.\n    Select Weekly or Monthly for the frequency and set the frequency desired.\n    Select the start and end dates, and a preferred start time.\n    Click Save.\n','SalesforcePD1',0,1,NULL,5),(4258,'Use Test.getStandardPriceBookId() to get the standard pricebookID','While writing a test class that covers an OpportunityLineItem trigger, a Developer is unable to create a standard Pricebook since one already exist in the org. how should the developer overcome this problem?','SalesforcePD1',0,2,NULL,5),(4259,'8','Integer x;\nfor(x=0; x<10; x+=2){\n   if(x==8)\n      break;\n   if(x==10)\n      break;\n}\nSystem.debug(x)\nwhat will debug display ?','SalesforcePD1',0,1,NULL,5),(4260,'','How should a devleloper prevent a recursive trigger ?','SalesforcePD1',0,0,NULL,5),(4261,'Developer console\nsetup menu\ntooling api','What are three ways for a developer to run tests in an org ?','SalesforcePD1',0,3,NULL,5),(4262,'Trigger.isExecuting == \'True\'; ','A developer created a helper class with a method that can be called from Visualforce pages, web services, triggers, and anonymous code. When the method is called from a trigger, the developer needs to execute code that should not be called when ran from anywhere else. \n\nHow can the developer determine if the code is being ran in a trigger context ?','SalesforcePD1',0,2,NULL,5),(4263,'Roll up summaries can be used on formulas fields, but if the formula contains an #Error result it may affect the summary value. \n\nRoll up summary fields do not cause validation rules on the parent object unless that object is edited seperately','What are two considerations when deciding wether to use a roll up summary field ? ','SalesforcePD1',0,2,NULL,5),(4264,'accountListHelper.js','a developer created a lightning component named accountList.cmp that displays a list of accounts. Client side logic that is executed when a user hovers over an account should be stored in which bundle member ?','SalesforcePD1',0,1,NULL,5),(4265,'Limits, startTest, stopTest','What can a developer use to determine if an Apex class exceeds any governor limits in a test class during bulk execution ?','SalesforcePD1',1,1,NULL,5),(4266,'Test for both positive cases( when a trigger should fire) and negative cases( when a trigger must not fire). Add assertions in your code to make sure you don\'t get a false positive. ','Whats the best practice when writing a test for a trigger ?','SalesforcePD1/Testing',0,1,NULL,5),(4267,'\n    Unit tests must cover at least 75% of your Apex code, and all of those tests must complete successfully.\n    Note the following.\n        When deploying Apex to a production organization, each unit test in your organization namespace is executed by default.\n        Calls to System.debug are not counted as part of Apex code coverage.\n        Test methods and test classes are not counted as part of Apex code coverage.\n        While only 75% of your Apex code must be covered by tests, don’t focus on the percentage of code that is covered. Instead, make sure that every use case of your application is covered, including positive and negative cases, as well as bulk and single records. This approach ensures that 75% or more of your code is covered by unit tests.\n    Every trigger must have some test coverage.\n    All classes and triggers must compile successfully.\n','Before you can deploy your code or package it for the Salesforce AppExchange, the following must be true...','SalesforcePD1/Testing',0,1,NULL,5),(4268,'Positive Case\nNegative Case\nBulk Action( 1-200 records)\nSingle Action( just one record)\nRestricted User\n','What five cases should you test in Salesforce ?','SalesforcePD1/Testing',0,1,NULL,5),(4269,'To facilitate the development of robust, error-free code, Apex supports the creation and execution of unit tests. Unit tests are class methods that verify whether a particular piece of code is working properly. Unit test methods take no arguments, commit no data to the database, send no emails, and are flagged with the testMethod keyword or the @isTest annotation in the method definition. Also, test methods must be defined in test classes, that is, classes annotated with @isTest.\n\n@isTest\n\n	private class myClass {\n\n	     static testMethod void myTest() {\n\n	        // code_block\n\n	    }\n\n	}\n\n--------------------------------------------------------\ntestmethod keyword is now deprecated, use @isTest\n@isTest\n\n	private class myClass {\n\n	     @isTest static void myTest() {\n\n	        // code_block\n\n	    }\n\n	}\n','What is a unit test ?','SalesforcePD1/Testing',0,1,NULL,5),(4270,'Classes and methods defined as @isTest can be either private or public. The access level of test classes methods doesn’t matter. This means you don’t need to add an access modifier when defining a test class or test methods. The default access level in Apex is private. The testing framework can always find the test methods and execute them, regardless of their access level.','What access level should test methods have ?','SalesforcePD1/Testing',0,1,NULL,5),(4271,'Classes defined as @isTest must be top-level classes and can\'t be interfaces or enums.\n\nMethods of a test class can only be called from a running test, that is, a test method or code invoked by a test method, and can\'t be called by a non-test request. \n\n@isTest\n	class TVRemoteControlTest {\n	    @isTest static void testVolumeIncrease() {\n	        TVRemoteControl rc = new TVRemoteControl(10);\n	        Integer newVolume = rc.increaseVolume(15);\n	        System.assertEquals(25, newVolume);\n	    }\n	     \n	    @isTest static void testVolumeDecrease() {\n	        TVRemoteControl rc = new TVRemoteControl(20)\n	        Integer newVolume = rc.decreaseVolume(15);\n	        System.assertEquals(5, newVolume);       \n	    }\n	         \n	    @isTest static void testVolumeIncreaseOverMax() {\n	        TVRemoteControl rc = new TVRemoteControl(10);\n	        Integer newVolume = rc.increaseVolume(100);\n	        System.assertEquals(50, newVolume);       \n	    }\n	     \n	    @isTest static void testVolumeDecreaseUnderMin() {\n	        TVRemoteControl rc = new TVRemoteControl(10);\n	        Integer newVolume = rc.decreaseVolume(100);\n	        System.assertEquals(0, newVolume);       \n	    }\n	     \n	    @isTest static void testGetMenuOptions() {\n	        // Static method call. No need to create a class instance.\n	        String menu = TVRemoteControl.getMenuOptions();\n	        System.assertNotEquals(null, menu);\n	        System.assertNotEquals(\'\', menu);\n	    }\n	}','public class TVRemoteControl {\n	    // Volume to be modified\n	    Integer volume;\n	    // Constant for maximum volume value\n	    static final Integer MAX_VOLUME = 50;   \n	     \n	    // Constructor\n	    public TVRemoteControl(Integer v) {\n	        // Set initial value for volume\n	        volume = v;\n	    }\n	         \n	    public Integer increaseVolume(Integer amount) {\n	        volume += amount;\n	        if (volume > MAX_VOLUME) {\n	            volume = MAX_VOLUME;\n	        }\n	        return volume;\n	    }\n	     \n	    public Integer decreaseVolume(Integer amount) {\n	        volume -= amount;\n	        if (volume < 0) {\n	            volume = 0;\n	        } \n	        return volume;\n	    }   \n	     \n	    public static String getMenuOptions() {\n	        return \'AUDIO SETTINGS - VIDEO SETTINGS\';\n	    }\n	        \n	}\n\nwrite a test class that completely covers all these methods and checks boundary conditions.','SalesforcePD1/Testing',0,1,NULL,5),(4272,'\n    Starting with Salesforce API 28.0, test methods can no longer reside in non-test classes and must be part of classes annotated with isTest. See the TestVisible annotation to learn how you can access private class members from a test class.\n    Test methods can’t be used to test Web service callouts. Instead, use mock callouts. See Test Web Service Callouts and Testing HTTP Callouts.\n    You can’t send email messages from a test method.\n    Since test methods don’t commit data created in the test, you don’t have to delete test data upon completion.\n    If a test class contains a static member variable, and the variable’s value is changed in a testSetup or test method, the new value isn’t preserved. Other test methods in this class get the original value of the static member variable. This behavior also applies when the static member variable is defined in another class and accessed in test methods.\n    For some sObjects that have fields with unique constraints, inserting duplicate sObject records results in an error. For example, inserting CollaborationGroup sObjects with the same names results in an error because CollaborationGroup records must have unique names.\n    Tracked changes for a record (FeedTrackedChange records) in Chatter feeds aren\'t available when test methods modify the associated record. FeedTrackedChange records require the change to the parent record they\'re associated with to be committed to the database before they\'re created. Since test methods don\'t commit data, they don\'t result in the creation of FeedTrackedChange records. Similarly, field history tracking records (such as AccountHistory) can\'t be created in test methods because they require other sObject records to be committed first (for example, Account).\n','Unit test considerations ...','SalesforcePD1/Testing',0,1,NULL,5),(4273,'Use the @TestVisible annotation:\n\npublic class VisibleSampleClass {\n  @TestVisible private static Integer routeCode = 405;\n  @TestVisible private String recordType;\n\n  //private inner class\n   @TestVisible class Employee {\n        String phone;\n        String name;\n      ...\n    }\n\n   @TestVisible private String privatemethod(){\n    }\n}','public class MaintenanceRequestHelper {\n    private String maintenanceCode;\n    \npublic static void updateWorkOrders(Map<Id,Case>newmap, Map<Id,Case> oldmap){\n        List<Case> maintenanceRequestInserts = new List<Case>();\n       // and so on \n      ... \n    }\n}\n\nsay I want to access this private member in a test class to test it. How can I do that since it is marked private? \n ','SalesforcePD1/Testing',0,1,NULL,5),(4274,'from ADG','Apex test data is transient and isn’t committed to the database.\n\nThis means that after a test method finishes execution, the data inserted by the test doesn’t persist in the database. As a result, there is no need to delete any test data at the conclusion of a test. Likewise, all the changes to existing records, such as updates or deletions, don’t persist. This transient behavior of test data makes the management of data easier as you don’t have to perform any test data cleanup. At the same time, if your tests access organization data, this prevents accidental deletions or modifications to existing records.\n\nBy default, existing organization data isn’t visible to test methods, with the exception of certain setup objects. You should create test data for your test methods whenever possible. However, test code saved against Salesforce API version 23.0 or earlier has access to all data in the organization','SalesforcePD1/Testing',0,1,NULL,5),(4275,'\n    User\n    Profile\n    Organization\n    AsyncApexJob\n    CronTrigger\n    RecordType\n    ApexClass\n    ApexTrigger\n    ApexComponent\n    ApexPage\n','Starting with Apex code saved using Salesforce API version 24.0 and later, test methods don’t have access by default to pre-existing data in the organization, such as standard objects, custom objects, and custom settings data, and can only access data that they create. However, objects that are used to manage your organization or metadata objects can still be accessed in your tests such as:','SalesforcePD1/Testing',0,1,NULL,5),(4276,'use @IsTest(SeeAllData=true)','How can you see preexisting data such as standard objects and custom settings data ?','SalesforcePD1/Testing',0,1,NULL,5),(4277,'','This access restriction to test data applies to all code running in test context. For example, if a test method causes a trigger to execute and the test can’t access organization data, the trigger won’t be able to either.','SalesforcePD1/Testing',0,1,NULL,5),(4278,'thats a whoppa','If a test makes a Visualforce request, the executing test stays in test context but runs in a different thread, so test data isolation is no longer enforced. In this case, the test will be able to access all data in the organization after initiating the Visualforce request. However, if the Visualforce request performs a callback, such as a JavaScript remoting call, any data inserted by the callback won\'t be visible to the test.','SalesforcePD1/Testing',0,1,NULL,5),(4279,'','For Apex saved using Salesforce API version 27.0 and earlier, the VLOOKUP validation rule function always looks up data in the organization, in addition to test data, when fired by a running Apex test. Starting with version 28.0, the VLOOKUP validation rule function no longer accesses organization data from a running Apex test and looks up only data created by the test, unless the test class or method is annotated with IsTest(SeeAllData=true).','SalesforcePD1/Testing',0,1,NULL,5),(4280,'','Records that are created only after related records are committed to the database, like tracked changes in Chatter. Tracked changes for a record (FeedTrackedChange records) in Chatter feeds aren\'t available when test methods modify the associated record. FeedTrackedChange records require the change to the parent record they\'re associated with to be committed to the database before they\'re created. Since test methods don\'t commit data, they don\'t result in the creation of FeedTrackedChange records. Similarly, field history tracking records (such as AccountHistory) can\'t be created in test methods because they require other sObject records to be committed first (for example, Account).','SalesforcePD1/Testing',0,1,NULL,5),(4281,'','// All test methods in this class can access all data.\n	@isTest(SeeAllData=true)\n	public class TestDataAccessClass {\n	 \n	    // This test accesses an existing account.\n	    // It also creates and accesses a new test account.\n	    static testmethod void myTestMethod1() {\n	        // Query an existing account in the organization.\n	        Account a = [SELECT Id, Name FROM Account WHERE Name=\'Acme\'    LIMIT 1];\n	        System.assert(a != null);\n	         \n	        // Create a test account based on the queried account.\n	        Account testAccount = a.clone();\n	        testAccount.Name = \'Acme Test\';\n	        insert testAccount;\n	         \n	        // Query the test account that was inserted.\n	        Account testAccount2 = [SELECT Id, Name FROM Account\n	                                WHERE Name=\'Acme Test\' LIMIT 1];\n	        System.assert(testAccount2 != null);\n	    }\n	        \n	     \n	    // Like the previous method, this test method can also access all data\n	    // because the containing class is annotated with @isTest(SeeAllData=true).\n	    @isTest static void myTestMethod2() {\n	        // Can access all data in the organization.\n	   }\n	   \n	}','SalesforcePD1/Testing',0,1,NULL,5),(4282,'true','You can use @isTest(SeeAllData=true) annotation on just a test method ?','SalesforcePD1/Testing',0,1,NULL,5),(4283,'yes','Without the SeeAllData annotation, can a test method access the user object ?','SalesforcePD1/Testing',0,1,NULL,5),(4284,'YES!','Can profiles be accessed without SeeAllData ?','SalesforcePD1/Testing',0,1,NULL,5),(4285,'If a test class is defined with the @isTest(SeeAllData=true) annotation, the annotation applies to all its test methods whether the test methods are defined with the @isTest annotation or the (deprecated) testMethod keyword.\n\nThe @isTest(SeeAllData=true) annotation is used to open up data access when applied at the class or method level. However, if the containing class has been annotated with @isTest(SeeAllData=true), annotating a method with @isTest(SeeAllData=false) is ignored for that method. In this case, that method still has access to all the data in the organization. Annotating a method with @isTest(SeeAllData=true) overrides, for that method, an @isTest(SeeAllData=false) annotation on the class.\n\n@isTest(SeeAllData=true) and @isTest(isParallel=true) annotations cannot be used together on the same Apex method. ','important considerations for SeeAllData','SalesforcePD1/Testing',0,1,NULL,5),(4286,'use loadData\n\nadd the data in a csv file,\ncreate a static resource for the file\nthen use the loadData() with the resource name:\n\nList<Account> accounts = Test.loadData(Account.sObjectType, \'myresource\');','How can you easily create a lot of test Data ?','SalesforcePD1/Testing',0,1,NULL,5),(4287,'Public test utility classes are defined with the isTest annotation, and as such, are excluded from the organization code size limit and execute in test context. They can be called by test methods but not by non-test code.\n\nThe methods in the public test utility class are defined the same way methods are in non-test classes. They can take parameters and can return a value. The methods should be declared as public or global to be visible to other test classes. These common methods can be called by any test method in your Apex classes to set up test data before running the test. While you can create public methods for test data creation in a regular Apex class, without the isTest annotation, you don’t get the benefit of excluding this code from the organization code size limit.','Common test utility classes are public test classes that contain reusable code for test data creation.','SalesforcePD1/Testing',0,1,NULL,5),(4288,'Utility class used to supply test data','@isTest\npublic class TestDataFactory {\n    public static List<Account> createAccountsWithOpps(Integer numAccts, Integer numOppsPerAcct) {\n        List<Account> accts = new List<Account>();\n        \n        for(Integer i=0;i<numAccts;i++) {\n            Account a = new Account(Name=\'TestAccount\' + i);\n            accts.add(a);\n        }\n        insert accts;\n        \n        List<Opportunity> opps = new List<Opportunity>();\n        for (Integer j=0;j<numAccts;j++) {\n            Account acct = accts[j];\n            // For each account just inserted, add opportunities\n            for (Integer k=0;k<numOppsPerAcct;k++) {\n                opps.add(new Opportunity(Name=acct.Name + \' Opportunity \' + k,\n                                       StageName=\'Prospecting\',\n                                       CloseDate=System.today().addMonths(1),\n                                       AccountId=acct.Id));\n            }\n        }\n        // Insert all opportunities for all accounts.\n        insert opps;\n        \n        return accts;\n    }\n}','SalesforcePD1/Testing',0,1,NULL,5),(4289,'If a test class contains a test setup method, the testing framework executes the test setup method first, before any test method in the class. Records that are created in a test setup method are available to all test methods in the test class and are rolled back at the end of test class execution. If a test method changes those records, such as record field updates or record deletions, those changes are rolled back after each test method finishes execution. The next executing test method gets access to the original unmodified state of those records.\n','Test setup methods can reduce test execution times especially when you’re working with many records. Test setup methods enable you to create common test data easily and efficiently. By setting up records once for the class, you don’t need to re-create records for each test method. Also, because the rollback of records that are created during test setup happens at the end of the execution of the entire class, the number of records that are rolled back is reduced. As a result, system resources are used more efficiently compared to creating those records and having them rolled back for each test method. ','SalesforcePD1/Testing',0,1,NULL,5),(4290,'@testsetup static void setup(){ \n\n}\n\ntest setup methods are defined in a test class, take no arguments, and return no value. ','write a test setup method...','SalesforcePD1/Testing',0,1,NULL,5),(4291,'\nchanges to test data made in one test method are not visible in the next test method. ','@isTest\n	private class CommonTestSetup {\n	 \n	    @testSetup static void setup() {\n	        // Create common test accounts\n	        List<Account> testAccts = new List<Account>();\n	        for(Integer i=0;i<2;i++) {\n	            testAccts.add(new Account(Name = \'TestAcct\'+i));\n	        }\n	        insert testAccts;       \n	    }\n	     \n	    @isTest static void testMethod1() {\n	        // Get the first test account by using a SOQL query\n	        Account acct = [SELECT Id FROM Account WHERE Name=\'TestAcct0\' LIMIT 1];\n	        // Modify first account\n	        acct.Phone = \'555-1212\';\n	        // This update is local to this test method only.\n	        update acct;\n	         \n	        // Delete second account\n	        Account acct2 = [SELECT Id FROM Account WHERE Name=\'TestAcct1\' LIMIT 1];\n	        // This deletion is local to this test method only.\n	        delete acct2;\n	         \n	        // Perform some testing\n	    }\n	 \n	    @isTest static void testMethod2() {\n\n	        // The changes made by testMethod1() are rolled back and\n	        // are not visible to this test method.       \n	        // Get the first account by using a SOQL query\n	        Account acct = [SELECT Phone FROM Account WHERE Name=\'TestAcct0\' LIMIT 1];\n	        // Verify that test account created by test setup method is unaltered.\n	        System.assertEquals(null, acct.Phone);\n\n	         \n\n	        // Get the second account by using a SOQL quer\n	        Account acct2 = [SELECT Id FROM Account WHERE Name=\'TestAcct1\' LIMIT 1];\n	        // Verify test account created by test setup method is unaltered.\n	        System.assertNotEquals(null, acct2);\n	         \n	        // Perform some testing\n	    }\n	}','SalesforcePD1/Testing',0,1,NULL,5),(4292,'Test setup methods are only supported for classes with default isolation level. They are not supported in classes or methods that have SeeAllData=true','@isTest(SeeAllData=true)\nprivate class CommonTestSetup {\n	 \n	    @testSetup static void setup() {\n	        // Create common test accounts\n	        List<Account> testAccts = new List<Account>();\n	        for(Integer i=0;i<2;i++) {\n	            testAccts.add(new Account(Name = \'TestAcct\'+i));\n	        }\n	        insert testAccts;       \n	    }\n	     \n	    @isTest static void testMethod1() {\n	        // Get the first test account by using a SOQL query\n	        Account acct = [SELECT Id FROM Account WHERE Name=\'TestAcct0\' LIMIT 1];\n	        // Modify first account\n	        acct.Phone = \'555-1212\';\n	        // This update is local to this test method only.\n	        update acct;\n	         \n	        // Delete second account\n	        Account acct2 = [SELECT Id FROM Account WHERE Name=\'TestAcct1\' LIMIT 1];\n	        // This deletion is local to this test method only.\n	        delete acct2;\n	         \n	        // Perform some testing\n	    }\n}','SalesforcePD1/Testing',0,1,NULL,5),(4293,'The entire class fails and no further tests are executed in the class','What happens if a fatal error occurs during a test setup method, such as an exception from a DML operation','SalesforcePD1/Testing',0,1,NULL,5),(4294,'','If a test setup method calls a non-test method of another class, no code coverage is calculated for the non-test method.','SalesforcePD1/Testing',0,1,NULL,5),(4295,'Use runAs, Normally tests run in System.context but using runAs you can set the context to a certain user. \n\nrunAs doesn\'t enfore user permissions or field-level permission only record sharing. \n\nYou can only use runAs in test methods the original system context is re instated after all runAs methods are complete. \n\nrunAs counts toward your DML limit. \n\n... in a test method: \n\n          System.runAs(u) {\n	              // The following code runs as user \'u\'\n	              System.debug(\'Current User: \' + UserInfo.getUserName());\n	              System.debug(\'Current Profile: \' + UserInfo.getProfileId());\n	          }','What do you do if you want to write tests based on a users record sharing ?','SalesforcePD1/Testing',0,1,NULL,5),(4296,'','You can use more than one runAs in a test method: \n\nProfile p = [Select Id From Profile Where Name = \'Standar User\'];\nUser u1 = new User(Name, City, ...., ProfileId = p.id, ...);\n\nSystem.runAs(u1){\n\n   System.debug(UserInfo.getUserName());\n   System.debug(UserInfo.getProfileId());\n\n   User u2 = [Select Id,Name From User Where UserName = \'...\'];\n   System.runAs(us){\n         System.debug(UserInfo.getUserName());\n         System.debug(UserInfo.getProfileId());\n   }\n}\n','SalesforcePD1/Testing',0,1,NULL,5),(4297,'','You can also use the runAs method to perform mixed DML operations in your test by enclosing the DML operations within the runAs block. In this way, you bypass the mixed DML error that is otherwise returned when inserting or updating setup objects together with other sObjects. See sObjects That Cannot Be Used Together in DML Operations.\n\nThere is another overload of the runAs method (runAs(System.Version)) that takes a package version as an argument. This method causes the code of a specific version of a managed package to be used. For information on using the runAs method and specifying a package version context, see Testing Behavior in Package Versions.','SalesforcePD1/Testing',0,1,NULL,5),(4298,'Limits','What do you use to check governor limits ?','SalesforcePD1/Testing',0,1,NULL,5),(4299,'StartTest StopTest','How can you avoid hitting governor limits in a test ? ','SalesforcePD1/Testing',0,1,NULL,5),(4300,'','Testing Best Practices: \n\nIf code uses conditional logic (including ternary operators), execute each branch.\nMake calls to methods using both valid and invalid inputs.\nComplete successfully without throwing any exceptions, unless those errors are expected and caught in a try…catch block.\nAlways handle all exceptions that are caught, instead of merely catching the exceptions.\nUse System.assert methods to prove that code behaves properly.\nUse the runAs method to test your application in different user contexts.\nExercise bulk trigger functionality—use at least 20 records in your tests.\nUse the ORDER BY keywords to ensure that the records are returned in the expected order.\nNot assume that record IDs are in sequential order.\n\nRecord IDs are not created in ascending order unless you insert multiple records with the same request. For example, if you create an account A, and receive the ID 001D000000IEEmT, then create account B, the ID of account B may, or may not be sequentially higher.\nSet up test data:\n\n    Create the necessary data in test classes, so the tests do not have to rely on data in a particular organization.\n    Create all test data before calling the Test.startTest method.\n    Since tests don\'t commit, you don\'t have to delete any data.\n\nWrite comments stating not only what is supposed to be tested, but the assumptions the tester made about the data, the expected outcome, and so on.\nTest the classes in your application individually. Never test your entire application in a single test.','SalesforcePD1/Testing',0,1,NULL,5),(4301,'!\nIsTest methods must be declared as static','@isTest\n    public void TestClosedRequestGenerateNew(){\n        \n    }','SalesforcePD1/Testing',0,1,NULL,5),(4302,'100% of tests must execute without failure\n75% code coverage','What are two testing considerations when deploying from sandbox to production ?','SalesforcePD1',0,1,NULL,5),(4303,'set up a trace flag for the user, and define a debug log level and time period of the trace.','How can a developer set up a debug log on a specific user ?','SalesforcePD1',0,3,NULL,5),(4304,'DML exception, \n\nsince this is a before trigger you cannot update the leads in trigger.new','A lead object has a custom field Prior_Email__c and the following trigger defined to update this field anytime the email field is changed: \n\ntrigger test on lead(before update){\nfor(lead ld : trigger.new){\n  if(ld.email != OldMap.get(ld.id).email){\n      ld.Prior_Email__c = OldMap.get(ld.id).email;\n      update ld;\n   }\n}\n}\nwhats the result ?','SalesforcePD1',0,1,NULL,5),(4305,'Have each class implement an interface that defines a method getTextSummary() that returns the summary ','a developer created a lightning component to display a short text summary and wants to use it with multiple apex classes. How should they design the classes ?','SalesforcePD1',0,3,NULL,5),(4306,'Throwing a custom exception in the unit test','a developer wants to write a unit test for an apex class that calculates a person\'s age based on birth date what should the unit test include ?','SalesforcePD1',0,2,NULL,5),(4307,'Create one profile, one permission set, and two profiles ','A developer has created a visualforce page and an apex controlerT that uses the with sharing keyword. The page will be used by Sales Managers and should display only accounts owned by Sales Representatives that report directly to the Sales Manager. The organization wide defaults for Accounts is set to private. \n\nWhat additional set of steps should the developer take ?','SalesforcePD1',0,1,NULL,5),(4308,'to store and run data using SQL','When would the use Heroku postgres be apporpriate ?','SalesforcePD1',0,2,NULL,5),(4309,'Schema.describesObjects(new String[]{myObject})[0].fields.getMap();\ngetGlobalDescribe().get(myObject).getDescribe().fields.getMap();','A developer needs to display all the available fields for an object. \n\nwhat are two ways the developer can retrieve these fields if myObject is the object name ?','SalesforcePD1',0,2,NULL,5),(4310,'the type must implement equals and hashcode','How can a custom type be identified as unique when added to a Set ?','SalesforcePD1',0,1,NULL,5),(4311,'Is a lightweight linux container used in a collection to run heroku applications\nHas ephimeral filesystems and is rebooted every 24 hours','Which two are true regarding a dyno','SalesforcePD1',0,1,NULL,5),(4312,'Create a process builder to create a new case ','A sales manager wants to make sure that whenever a sales opportunity is changed to \'closed won\', a new case will be created for the support team to gather the necessary info from the user.','SalesforcePD1',0,1,NULL,5),(4313,'@TestSetup','A developer is creating a test class and needs to insert records to test functionality.\nWhich method annotation should be used to create test records for every method in the class. ','SalesforcePD1',0,1,NULL,5),(4314,'use transient variables.\nuse an SOQL for loop instead of assinging a large query result to a list and looping through the list:\n\nfor(Case ca : [Select Id, Name From Case WHere ...]){\n\n}\n\ninstead of \n\nList<Case> ca = [Select...\n\nfor(Case c : ca)\n\n','A developer discovers Apex HEAP limit errors in a trigger, which two methods should he use to counteract this ?','SalesforcePD1',0,2,NULL,5),(4315,'Install an app from the app exchange to generate documents\ncreate visualforce page with custom styling','A developer is asked to create a pdf quote document formatted using the company\'s branding guidlines, and automatically save it to the record. Which two ways should the developer create this opportunity ?','SalesforcePD1',0,2,NULL,5),(4316,'2,150','List<Account> acc = [Select Id from account limit 10 ];\nDelete acc;\nDatabase.emptyRecycleBin(acc);\n\nSystem.debug(Limits.getDMLStatements()+ \", \" + Limits.getDMLLimitStatements());\n\nwhat is the results','SalesforcePD1',0,1,NULL,5),(4317,'Use the get sObject Type on each generic sObject to retrieve the sObject Token.\n\nUPDATED','A method is passed a list of generic sObjects as a parameter\n\nWhat should the developer do to determine which object type to cast each object ? ','SalesforcePD1',0,0,NULL,5),(4318,'Use the token version of an sObject field when determining the sObject Type or field type to use. \n\nsObject s = new Account();\nSystem.assert(s.getsObjectType() == Account.sObjectType)\n\n//get the sobject describe result\nSchema.DescribesObjectResult dsr = Account.sObject.getDescribe();\n\nTo access the token for an sObject, use one of the following methods:\n\n    Access the sObjectType member variable on an sObject type, such as Account.\n    Call the getSObjectType method on an sObject describe result, an sObject variable, a list, or a map.\n\n\n	Schema.sObjectType t = Account.sObjectType;\n\nThe following also returns a token for the Account sObject:\n\n	Account a = new Account();\n\n	Schema.sObjectType t = a.getSObjectType();','What can sObject tokens be used for ?','SalesforcePD1',0,1,NULL,5),(4319,'.sObjectType is a member variable on all objects \n\nsObject a = [Select Id From Account Limit 1];\n\nSystem.assertEquals(a.getsObjectType(), Account.sObjectType)\n\nor \n\nList<sObject> soblist = new Account[]{}\n\nSystem.assertEquals(soblist.getsObjectType(), Account.sObjectType);\n\n','How can you determine the type of an sobject or list of salesforce objects ?','SalesforcePD1',0,1,NULL,5),(4320,'Use a static boolean variable to deteremine if the trigger has already ran. \n\nPublic class TrggrUtility{\n\n   public static boolean RunOnce = False;\n\n}\n\nIf(!TrggrUtility.RunOnce) \n{\n   // do... call method\n   TrggrUtility.RunOnce = true;\n\n}else{\n\n  // exit trigger or code section\n\n}','A trigger is firing more than once, what can be done about this ?','SalesforcePD1',0,2,NULL,5),(4321,'an in-memory key-value data store run by Heroku\nIs provisioned and managed as an add on','Heroku Redis ?','SalesforcePD1',0,0,NULL,5),(4322,'Use an IDE to deploy code directly into the production org using Metadata API\nPackage the code as an unmanaged package and install it in the production org.','What are two ways a developer can deploy code from a developer org to an unrelated production org ?','SalesforcePD1',1,0,NULL,5),(4323,'Select Name, Max(Created By) From Account Group By Name;','Use SOQL to return Accounts grouped by name:','SalesforcePD1',0,0,NULL,5),(4324,'Wrong,  Malformed Query Exception Field must be grouped or aggregated: Type \n\nIf the list of fields in a select clause include an aggregated function, you must include all non - aggregated fields in the Group By Clause','Select Type,Name,Max(CreatedDate) From Account Group By Name Limit 5;','SalesforcePD1',0,0,NULL,5),(4325,'Well you could use \n   Select LeadSource From Lead;\n\nThen write code to iterated through the results and increment counters for each looop.\n\nor you could use the group by function: \n\nSelect LeadSource, COUNT(Name)\nFrom Lead\nGroup By LeadSource;','How could you write code to determine how many leads are associated with each LeadSource ?','SalesforcePD1',0,1,NULL,5),(4326,'LeadSource                                 COUNT(Name)\n-------------------------------------------------------------------\nWeb                    9\nPhone                              8\nStore Inquiry                    9','Select LeadSource,COUNT(Name) From Lead Group By LeadSource','SalesforcePD1',0,0,NULL,5),(4327,'No you could use agg functions as powerful calculators: \n\nSelect Avg(amount) From Opportunity\n\nwould yield: \n\n185806.4516129032','Do you have to use Group by with aggregate functions ?','SalesforcePD1',0,0,NULL,5),(4328,'Select Name, Avg(Amount) From Opportunity Group By Name','Display the average amount for each opportunity by name','SalesforcePD1',0,1,NULL,5),(4329,'You cannot use the limit clause in a query that selects only an aggregated field\n\nmalformed query exception\n\n[object Object]: Non-grouped query that uses overall aggregate functions cannot also use LIMIT\n','Select Max(CreatedDate)\nFrom Account Limit 1;','SalesforcePD1',0,0,NULL,5),(4330,'Burlington Textiles                 2019-01-02T19:14:03.000+0000\n\nYou can use limit with an aggregate IF you include a GROUP BY','Select Name, MAX(CreatedDate)\nFrom Account Group By Name Limit 1','SalesforcePD1',0,2,NULL,5),(4331,'COUNT() \n\nSelect COUNT()\nFrom Account\nWhere name like \'A%\'','Which aggregate function returns the number of rows matching the query criteria ?','SalesforcePD1',0,2,NULL,5),(4332,'Select COUNT_DISTINCT(Name)\nFrom Account','What can be used to return the number of all distininct non-null fields values','SalesforcePD1',0,1,NULL,5),(4333,'Malformed Query Exception ','Select Count_Distinct(Name)\nFrom Account\nLimit 1','SalesforcePD1',0,1,NULL,5),(4334,'Grouped Field should not be aggregated','Select Type, Count_Distinct(Name)\nFrom Account\nGroup By Name\nLimit 1','SalesforcePD1',0,0,NULL,5),(4335,'Malformed Query exception\nField must be grouped or aggregated: Name','Select Name, Type, Count_Distinct(Name)\nFrom Account\nGroup By Type\nLimit 1','SalesforcePD1',0,1,NULL,5),(4336,'returns the Maximum value of field','SELECT Name, MAX(BudgetedCost)\nFROM Campaign\nGROUP BY Name','SalesforcePD1',0,1,NULL,5),(4337,'Including null\n\nSelect LeadSource\nFrom Lead\nGroup By LeadSource','How can you return the set of distinct field values from a table ?','SalesforcePD1',0,1,NULL,5),(4338,'The previous version values of the records firing the trigger','What does the context variable Trigger.old represent in a update operation ?','SalesforcePD1',0,0,NULL,5),(4339,'The save method from the controller extension','<apex:page standardcontroller=\"Account\" extension=\"myExtension\">\r\n   <apex:inputField value=\"{!account.name}\"/>\r\n   <apex:commandButton value=\"Save\" action=\"{!save}\"/>\r\n</apex:page>\r\n\r\nThe controller extension as a public method named save()\r\nwhich method or method will the vf page call ?','SalesforcePD1',0,0,NULL,5),(4340,'Any apex class that contains a constructor that takes an argument of type standard controller, or the name of the custom controller that you want to extend.   \r\n\r\n\r\npublic customcont(ApexPage.StandardController stdcon) {\r\n\r\n}','Define a controller extension','SalesforcePD1',0,0,NULL,5),(4341,'\"Motely Food crew\"','<apex:page standardController=\"Account\" extensions=\"ExtClass1,ExtClass2\" showHeader=\"false\" >\r\n    <apex:outputText value=\"{!foo}\"></apex:outputText>\r\n</apex:page>\r\n\r\npublic class ExtClass1 {\r\n    \r\n    public ExtClass1(ApexPages.StandardController stdcont){\r\n        \r\n    }\r\n    \r\n    public String getFoo(){\r\n        return \'Motely Foo crew\';\r\n    }\r\n\r\n}\r\n\r\npublic class ExtClass2 {\r\n    public ExtClass2(ApexPages.StandardController stdcont){\r\n        \r\n    }\r\n    \r\n    public String getFoo(){\r\n        return \'You a foo\';\r\n    }\r\n\r\n}\r\n\r\nWhat is displayed ?','SalesforcePD1',0,0,NULL,5),(4342,'','Method overrides in controller extensions are defined by whichever methods are in the left-most extension or the one that is defined first when there are multiple.The first in the comma seperated list of extensions. ','SalesforcePD1',0,2,NULL,5),(4343,'Use the with sharing keywords \r\n\r\nLike other Apex classes, controller extensions run in system mode. Consequently, the current user\'s credentials are not used to execute controller logic, and the user\'s permissions and field-level security do not apply. However, if a controller extension extends a standard controller, the logic from the standard controller does not execute in system mode. Instead, it executes in user mode, in which the permissions, field-level security, and sharing rules of the current user apply.\r\n\r\nYou can choose whether a controller extension respects a user\'s organization-wide defaults, role hierarchy, and sharing rules by using the with sharing keywords in the class definition. For information, see “Using the with sharing, without sharing, and inherited sharing Keywords”','You want a controller extension to respect the users role hierarchy, sharing rules, and Organization wide defaults. How can you do this ?','SalesforcePD1',0,0,NULL,5),(4344,'False, standard controllers operate in User mode. Controller extensions operate in System mode though like other apex classes and therefore do not respect sharing rules, role hierarchy or owd','A standard controller operates in System mode.','SalesforcePD1',0,0,NULL,5),(4345,'Developer edition\r\nSandbox','Which two org types can a developer create new apex classes ?','SalesforcePD1',1,0,NULL,5),(4346,'The unit test relies on existing data in the database. ','A developer has a unit test that is failing, they copy the code in the failing method and execute it in the execute anonymous window and it succeeds. \r\n\r\nWhy is this so ?','SalesforcePD1',0,2,NULL,5),(4347,'1','Integer index = 1;\r\nInteger counter = 2;\r\ndo {\r\n   System.debug(index);\r\n    index++;\r\n    counter++;\r\n}while(index == 20 && counter == 21);','SalesforcePD1',0,1,NULL,5),(4348,'Is a distributed commit-log for communication between services\r\nIs a messaging backbone for building distributed applications','Which two are true regarding apache kafka and heroku ?','SalesforcePD1',0,2,NULL,5),(4349,'Process builder with an auto launched flow','Universal Containers wants to automate the Sales operations process for closed won opportunities. When an opportunity is marked as closed won UC wants to update the Account to mark it as a Customer. In addition UC wants all opportunity Line Items from a close won opportuinity to be automatically added as assets. \r\n\r\nWhat is appropriate for automating this process ?','SalesforcePD1',0,1,NULL,5),(4350,'SOQL query Row limit exception due to the number of Contacts\r\nSOQL query Row limit exception due to the number of Accounts ','List<Account> acc = [Select Id,Name, (Select Id,Name from Contancts) From Account];\r\n\r\nWhich two exceptions might occur ?','SalesforcePD1',0,2,NULL,5),(4351,'Create a rollup-summary field on the quote object that performs a SUM on the Quote-line item field, filtered for only Discounted items. ','When viewing a quote a sales representative wants to easily see how many discounted line items are included in the quote line items.','SalesforcePD1',0,1,NULL,5),(4352,'51;1;null','Integer a = 0;\r\nInteger b;\r\na = a++;\r\na++;\r\nInteger c = a *5;\r\nString s = String.valueOf(c) + a;\r\nSystem.debug(s + \";\" + a +\";\"+b); ','SalesforcePD1',0,0,NULL,5),(4353,'String.enforceSecurityChecks()\r\nString.escapeSingleQuotes()','Which queries can a developer use in a visualforce page to protect against SQL injection ? \r\n\r\nHow can a developer parse user input strings to avoid sql injection? ','SalesforcePD1',0,0,NULL,5),(4354,'map<String,String>','What is the return type when ApexPages.currentPage().getParameter() is used to get the URL Parameters from a visualforce page controller ?','SalesforcePD1',0,1,NULL,5),(4355,'Lightning components render on the client providing performance benifits \r\nLightning components are built using web standards ensuring cross browser compatiibility','What are two benifits when using the Lightning Component Framework ? ','SalesforcePD1',0,2,NULL,5),(4356,'Workbench','Which tool can deploy destructive changes to apex classes in production environment','SalesforcePD1',1,0,NULL,5),(4357,'SOSL search thtat includes ALL ROWS','A developer needs to search for a phone number that could be on mulltiple object types, which tool should they use for this ?','SalesforcePD1',0,1,NULL,5),(4358,'The detail inherits the security and sharing of its master.','What is the key difference between Master-detail and lookup relationships ?','SalesforcePD1',0,0,NULL,5),(4359,'','By default, records can’t be reparented in master-detail relationships. Administrators can, however, allow child records in master-detail relationships on custom objects to be reparented to different parent records by selecting the Allow reparenting option in the master-detail relationship definition.','SalesforcePD1',0,2,NULL,5),(4360,'','Standard objects can\'t be on the detail side of a custom object in a master-detail relationship.','SalesforcePD1',0,0,NULL,5),(4361,'','You can\'t create a master-detail relationship if the custom object already contains data. You can, however, create the relationship as a lookup and then convert it to master-detail if the lookup field in all records contains a value.','SalesforcePD1',0,1,NULL,5),(4362,'','Roll-up summary fields work as in two-object master-detail relationships. A master can roll up fields on detail records; however, it can\'t directly roll up fields on subdetail records. To achieve this, the detail record must have a roll-up summary field for the field on the subdetail record, allowing the master to roll up from the detail\'s roll-up summary field.','SalesforcePD1',0,0,NULL,5),(4363,'','You can’t delete a custom object if it is on the master side of a master-detail relationship. If you delete a custom object that is on the detail side of a master-detail relationship, the relationship is converted to a lookup relationship.\r\nDeleting a detail record moves it to the Recycle Bin and leaves the master record intact; deleting a master record also deletes related detail and subdetail records. Undeleting a detail record restores it, and undeleting a master record also undeletes related detail and subdetail records. However, if you delete a detail record and later, separately, delete its master record, you cannot undelete the detail record, as it no longer has a master record to relate to.','SalesforcePD1',0,0,NULL,5),(4364,'','Sharing access to a junction object record is determined by a user\'s sharing access to both associated master records and the Sharing Setting option on the relationship field. See Custom Object Security. For example, if the sharing setting on both parents is Read/Write, then the user must have Read/Write access to both parents in order to have Read/Write access to the junction object. If, on the other hand, the sharing setting on both masters is Read-Only, a user with Read-Only rights on the master records would have Read/Write access to the junction object.','SalesforcePD1',0,0,NULL,5),(4365,'','In a many-to-many relationship, a user can\'t delete a parent record if there are more than 200 junction object records associated with it and if the junction object has a roll-up summary field that rolls up to the other parent. To delete this object, manually delete junction object records until the count is fewer than 200.','SalesforcePD1',0,1,NULL,5),(4366,'The junction object inherits the owner value from its associated primary object. \r\n\r\nThe second M-D relationship you create becomes the secondary relationship, if you delete the primary or convert it to a lookup the secondary becomes the primary.','When a junction object is created which parent becomes the Owner field ?','SalesforcePD1',1,1,NULL,5),(4367,'','Roll-up summary fields that summarize data from the junction object can be created on both master objects.\n\nFormula fields and validation rules on the junction object can reference fields on both master objects.\n\nYou can define Apex triggers on both master objects and the junction object.\n\nA junction object can\'t be on the master side of another master-detail relationship.\n\nYou can\'t create a many-to-many self relationship, that is, the two master-detail relationships on the junction object can\'t have the same master object.','SalesforcePD1',0,1,NULL,5),(4368,'Clear the value of this field This is the default. Clearing the field is a good choice when the field does not have to contain a value from the associated lookup record.\r\n\r\nDon’t allow deletion of the lookup record that’s part of a lookup relationship This option restricts the lookup record from being deleted if you have any dependencies, such as a workflow rule, built on the relationship.\r\n\r\nDelete this record also Available only if a custom object contains the lookup relationship, not if it’s contained by a standard object. However, the lookup object can be either standard or custom. Choose when the lookup field and its associated record are tightly coupled and you want to completely delete related data.','If the lookup field is optional you can specify one of three behaviors if the lookup record is deleted: ','SalesforcePD1',1,0,NULL,5),(4369,'Custom field on the custom Wizard__c object \r\nStandard account lookup on the contact object\r\n','Name two correct examples of a model in Salesforces MVC architecture\r\n\r\nCustom field on the custom Wizard__c object \r\nStandard account lookup on the contact object\r\nstandard lightning component\r\nWorkflow rule on the contact object','SalesforcePD1',0,0,NULL,5),(4370,'apex','UC has an integration with its accounting system that  creates tens of thousads of orders in a nightly batch. They want to try to match fields on leads and opps with existing emails. They are concerned with performance wth such a large data volume. \r\n\r\nWhat tool should they use  ?','SalesforcePD1',0,0,NULL,5),(4371,'a String','a user selects a value from a multi-select picklist. How is this value represented in apex ?','SalesforcePD1',0,1,NULL,5),(4372,'Debug menu -> change log levels','How are debug levels adjusted in the debug log ?','SalesforcePD1',0,0,NULL,5),(4373,'Checkboxes map to booleans\r\nNumber maps to Integers \r\nText Area types map to a list of strings ','which three declaritve fields are correctly mapped to variable types in apex ? ','SalesforcePD1',1,0,NULL,5),(4374,'Custom exceptions must extend the base exception class\r\nCustom exception class names must end with the word \'exception\'','Two considerations for Custom apex exception classes','SalesforcePD1',0,1,NULL,5),(4375,'When unit tests are run on an organization','When are code coverage calculations calculated ','SalesforcePD1',0,0,NULL,5),(4376,'a lookup relationship to the movie object and a lookup relationship to the actor object\r\n\r\nSharing access to a junction object record is determined by a user\'s sharing access to both associated master records and the Sharing Setting option on the relationship field\r\n\r\nBecause both relationships are lookups the sharing and security of the junction object can be independent or that on the its parents.','A developer is tasked with creating a schema to track movies actors and contracts. A single movie can have many contracts and a single actor can have many contracts. Each contract is owned and actively managed by a single user. \r\n\r\nwhich schema should be created for users to actively manage the contracts they own; without requiring access to the movie or actor records. \r\n\r\n1.a lookup relationship to the movie object and a master detail relationship to the actor object.\r\n\r\n2. a M-D relationship to the movie object and a lookup relationship to the actor object.\r\n\r\n3. a lookup relationship to the movie object and a lookup relationship to the actor object','SalesforcePD1',0,0,NULL,5),(4377,'Initialized only when  class is loaded \nAllowed only for outer classes\nexcluded from the view state of a visualforce page. ','What are three charecteristics of static methods ? ','SalesforcePD1',0,0,NULL,5),(4378,'statics can only be used in top-level classes\r\nInner is a reserved word.','public class ExtClass2 {\r\n    public ExtClass2(ApexPages.StandardController stdcont){\r\n        \r\n    }\r\n    \r\n    public String getFoo(){\r\n        return \'You a foo\';\r\n    }\r\n    \r\n    public class Inner{\r\n        public static void eatFoo(){\r\n            System.debug(\'foooood\');\r\n        }\r\n    }\r\n\r\n}','SalesforcePD1',1,0,NULL,5),(4379,'Use the onChange event to update the list of accounts in the controller and then re render the pageBlockTable. ','a developer created a visualforce page with a custom controller to show a list of accounts. The page uses <apex:selectList> component, with variable call seelection to show values from Accounts.type. The page uses an apex:pageBlockTable to display the list of accounts. \r\n\r\nWhen a user selects a type from the drop down only Accounts of thta type are shown on the page. ','SalesforcePD1',1,0,NULL,5),(4380,'If there are existing records with a null value in the lookup field an error will occur.\r\nThe OWD changes to controlled by parent. ','What are two considerations when converting a lookup to a master detail ?','SalesforcePD1',0,1,NULL,5),(4381,'Unit tests that require 75% code coverage. ','What requirment prevents poorly written applications from being deployed to production ?','SalesforcePD1',0,0,NULL,5),(4382,'the standardController atttribute must be set set on the object. ',' a developer wants to override a button using visualforce on an object.\r\n\r\nWhat is the requirement.','SalesforcePD1',0,0,NULL,5),(4383,'Use Process Builder to post to chatter based on meeting the required criteria. ','What shoud a developer use to post a message to chatter when a Status__c field is set to \"approved\"','SalesforcePD1',0,1,NULL,5),(4384,'Controller extension','What type of controller should a developer use to include a list of related records on a visualforce page without needing additional code coverage? ','SalesforcePD1',0,0,NULL,5),(4385,'To prevent an import from creating duplicate records using upsert\r\nto Create a salesforce record in a development environment with the same id as in another environment. ','What are two uses of externel IDs ?','SalesforcePD1',0,2,NULL,5),(4386,'The opportunity. ','A lead record that has a single CampaignMember object is converted into a new contact, account, and opportunity. \r\n\r\nWhich object will the campaingmember reference using a lookup after conversion','SalesforcePD1',1,0,NULL,5),(4387,'use {!contanct.Account.Name} merge field syntax ','A visualforce page uses the contact stard controller. \r\n\r\nHow can a developer display the name from the parent account on the page ?','SalesforcePD1',0,0,NULL,5),(4388,'Formula field\nTODAY() - DATEVALUE(LastModifiedDate)','US requires sales reps to update cases at least once every three days. AS a developer display a field that shows the number of days since the last update. ','SalesforcePD1',0,0,NULL,5),(4389,'defaultFieldValues\r\n\r\nvar createAcountContactEvent = $A.get(\"e.force:createRecord\");\r\ncreateAcountContactEvent.setParams({\r\n    \"entityApiName\": \"Contact\",\r\n    \"defaultFieldValues\": {\r\n        \'Phone\' : \'415-240-6590\',\r\n        \'AccountId\' : \'001xxxxxxxxxxxxxxx\'\r\n    }\r\n});\r\ncreateAcountContactEvent.fire();','What attribute is used to set pre exsisting field values when using the e.force:createRecord event ','SalesforcePD1',1,0,NULL,5),(4390,'If the field is hidden in the page layout the new field value is still saved with the new record. ','what happens if you pre populate a field yet it is hidden on the create record page when e.force:createRecord event is fired.','SalesforcePD1',0,1,NULL,5),(4391,'false,\r\n\r\nIf the current user doesn’t have create access to the field, due to field-level security, attempts to save the new record result in an error.\r\n\r\nError messages can’t reference fields the current user doesn’t have access to. This constraint means the user won’t know why the error occurred or how to resolve the issue. Firing the force:createRecord event tells the app to use the standard create record page. You can’t catch errors that occur there, or alter the create page interface or behavior, for example, to show an improved error message. For this reason, it’s essential to perform access checks in your own code, before firing the event.\r\n\r\nYou can’t prepopulate system-maintained fields, such as Id or record modification time stamps. Default values for these fields are silently ignored.\r\n\r\nPrepopulating rich text fields is unsupported. It might work for simple values, but the internal format of rich text fields is undocumented, so setting complex values that include formatting is problematic. Use at your own risk.','using e.force:createRecord runs in system mode so it ignores users access to fields ','SalesforcePD1',0,0,NULL,5),(4392,'force:appHostable','What interface is needed for a lightning component to be a tab.','',0,0,NULL,5),(4393,'are used to update or validate record values before they’re saved to the database.','Before triggers:','SalesforcePD1',1,0,NULL,5),(4394,'are used to access field values that are set by the system (such as a record\'s Id or LastModifiedDate field), and to affect changes in other records, such as logging into an audit table or firing asynchronous events with a queue. The records that fire the after trigger are read-only.','After triggers:','SalesforcePD1',0,0,NULL,5),(4395,'upsert triggers fire both before and after insert or before and after update triggers as appropriate.\n\nThey fire whatever trigger they are so if an upsert is an update it fires an update trigger and so on. ','Since an upsert operations can be either an update or an insert, which triggers do they fire ?','SalesforcePD1',0,1,NULL,5),(4396,'If there are existing records with a nulll value in the lookup field an error will occur.\r\n\r\nOWD changes to controlled by partent on the child object. ','What are two considerations when converting a lookup to a master detail ? ','SalesforcePD1',0,0,NULL,5),(4397,'const variable are immutable','// call constructor, new object, assign it to bike \r\nconst bike = new Bike(); \r\n//Change internal state by calling a function \r\nbike.changeGear(\"front\", \"Up\"); \r\n// add a new member to bike that did not exist before \r\nbike.type = \"Penny Farthing\"; \r\n// check for success \r\nconsole.log(bike.calculateGearRatio()); // 4.0909... \r\nconsole.log(bike.type); // \"Penny Farthing\" \r\n// attempt to point bike to new instance of Bike \r\nbike = new Bike(1,2); // error','Salesforce/Javascript',0,0,NULL,5),(4398,'immutable','//primitive assignments\r\nvar myBike = \"Mountain Bike\";\r\nlet currentGear = 5;\r\nconst numberOfGears = 12;\r\n//reassignment\r\nmyBike = \"Penny Farthing\"; // this works\r\ncurrentGear = 1; // so does this\r\nnumberOfGears = 1; // error','Salesforce/Javascript',0,0,NULL,5),(4399,'','Implicit type coercion:\r\n\r\nlet num1 = 9 * \"3\";\r\nconsole.log(num1); // 27 (a number)\r\nlet num2 = 9 + \"3\";\r\nconsole.log(num2); // \"93\" (a string)','Salesforce/Javascript',0,0,NULL,5),(4400,'For Boolean comparison the best practice is to use === and !==. With these operators, primitive types are only equivalent when both type and value match, and object comparisons are only true when the their respective pointers are pointing to the same memory address. Trying the same comparisons as above: \r\n\r\nfalse === \"\"; // false\r\nfalse === \"0\"; // false\r\n\"\" === \"0\"; // false\r\n[0] === 0; // false','Many instances of implicit type coercion are confusing. For instance Boolean comparisons. The ==  and != comparison operator common to C-family languages will attempt to convert anything to Boolean. There are deterministic rules, but they are too complex to be practical. Here are some fun examples.\r\n\r\nfalse == \"\"; // true\r\nfalse == \"0\"; // true\r\n\"\" == \"0\"; // false\r\n[0] == 0; // true','Salesforce/Javascript',0,0,NULL,5),(4401,'\r\n    false (of course)\r\n    0 (the number zero)\r\n    \"\" or \'\' (an empty string)\r\n    null\r\n    undefined\r\n    NaN (the result of failed mathematical operations)\r\n','What are the falsey values ? ','Salesforce/Javascript',0,0,NULL,5),(4402,'','const myRecord = response.getReturnValue();\r\nif (myRecord) {\r\n  //now process the record\r\n}\r\n\r\n\r\na widely accepted best practice in Javascript..','Salesforce/Javascript',0,0,NULL,5),(4403,'Truthy vs Falsey','When should you use implicit type coericion ?','Salesforce/Javascript',0,0,NULL,5),(4404,'This component can update automatically as a user types into the input field. ','<aura:component implements=\"flexipage:availableForAllPageTypes\">\r\n  <aura:attribute name=\"text\" type=\"String\"/>\r\n  <lightning:card title=\"Basic DOM Example\" iconName=\"utility:hierarchy\">\r\n    <div class=\"slds-card__body slds-card__body-inner\">\r\n      <p>\r\n        <lightning:formattedText value=\"{!v.text}\"/>\r\n      </p>\r\n      <p>\r\n        <lightning:input aura:id=\"inputText\" type=\"text\" value=\"{!v.text}\"/>\r\n      </p>\r\n    </div>\r\n  </lightning:card>\r\n</aura:component>','Salesforce/Javascript',0,0,NULL,5),(4405,'<aura:attribute name=\"show\" type=\"Boolean\" default=\"true\"/>\r\n<aura:if isTrue=\"{!v.show}\">\r\n  <p>Peek-a-boo!</p>\r\n  <aura:set attribute=\"else\">\r\n    <p>I’m hiding!</p>\r\n  </aura:set>\r\n</aura:if>','How do you conditionally render parts of the DOM','Salesforce/Javascript',0,0,NULL,5),(4406,'$A.createComponent()','What do you use to dynamically render components using Lightning ?','Salesforce/Javascript',0,0,NULL,5),(4407,'const bike = {\r\n  gears: 10,\r\n  currentGear: 3,\r\n  changeGear: function(direction, changeBy) {\r\n    if (direction === \'up\') {\r\n      this.currentGear += changeBy;\r\n    } else {\r\n      this.currentGear -= changeBy;\r\n    }\r\n  }\r\n}\r\nconsole.log(bike.gears); // 10\r\nconsole.log(bike.currentGear); //3\r\nbike.changeGear(\'up\', 1);\r\nconsole.log(bike.currentGear); //4','Syntactically speaking, there are are several ways to create an object in JavaScript. But no matter how you create an object, it’s actually abstracting an underlying API called Object.create().  \r\n\r\nIn some instances there’s good reason to use Object.create() directly\r\n\r\nThe most common way however is to use object literal notation. \r\n\r\nDo you know what that looks like ? ','SalesforcePD1/Javascript',0,0,NULL,5),(4408,'The use of the new keyword, without new this. would not refer to the currently being created object. It would refer to something else. ','An alternative to object literal notation is using constructors. The advantage of using a constroctur is that you can repeatedly create objects that have the same properties. A Java Script constructor is just a function: \r\n\r\nfunction Bike(gears, startGear) {\r\n  this.gears = gears;\r\n  this.currentGear = startGear;\r\n}\r\nBike.prototype.changeGear = function(direction,changeBy){\r\n  if(direction === \'up\') {\r\n    this.currentGear += changeBy;\r\n  } else {\r\n    this.currentGear += changeBy;\r\n  }\r\n}\r\nconst bike = new Bike(10, 3);\r\nconsole.log(bike.gears); // 10\r\nconsole.log(bike.currentGear); //3\r\nbike.changeGear(\'up\', 1);\r\nconsole.log(bike.currentGear); //4\r\n\r\nWhat makes the Bike() method a constructor.','SalesforcePD1/Javascript',0,0,NULL,5),(4409,'False, passed by value: \r\n\r\nThere are six primitive types in JavaScript: string, number, Boolean, null, undefined, and symbol. When a variable is a primitive type, it’s passed by value when assigned. That is to say, each time a primitive is assigned, a copy of the value is made and assigned to the new variable. ','Primitives are passed by reference.','SalesforcePD1/Javascript',0,0,NULL,5),(4410,'','Arrays can be created as properties of an object, Arrays can be created with Array() function or with its own literal notation:\r\n\r\nconst bike = {\r\n  frontGearIndex: 0,\r\n  rearGearIndex: 0,\r\n  transmission: {\r\n    frontGearTeeth: [30,45],\r\n    rearGearTeeth: [11,13,15,17,19,21,24,28,32,36]\r\n  },\r\n  calculateGearRatio: function() {\r\n    let front = this.transmission.frontGearTeeth[this.frontGearIndex],\r\n        rear = this.transmission.rearGearTeeth[this.rearGearIndex];\r\n    return (front / rear);\r\n  },\r\n  changeGear: function(frontOrRear, newValue) {\r\n    if (frontOrRear === \'front\') {\r\n      this.frontGearIndex = newValue;\r\n    } else {\r\n      this.rearGearIndex = newValue;\r\n    }\r\n  }\r\n};','SalesforcePD1/Javascript',0,0,NULL,5),(4411,'You can use dot notation: \r\n\r\nbike.frontGearIndex\r\nbike.transmission.frontGearTeeth\r\nbike.calculateGearRatio()\r\n\r\n...here there are sctrict rules about how the name is spelled and capitalized or you can you use bracket notation which will allow you to access the properties dynamically such as maybe in a loop: \r\n\r\nbike[\"frontGearIndex\"]\r\nbike[\"transmission\"][\"frontGearTeeth\"]\r\nbike[\"calculateGearRatio\"]()','const bike = {\r\n  frontGearIndex: 0,\r\n  rearGearIndex: 0,\r\n  transmission: {\r\n    frontGearTeeth: [30,45],\r\n    rearGearTeeth: [11,13,15,17,19,21,24,28,32,36]\r\n  },\r\n  calculateGearRatio: function() {\r\n    let front = this.transmission.frontGearTeeth[this.frontGearIndex],\r\n        rear = this.transmission.rearGearTeeth[this.rearGearIndex];\r\n    return (front / rear);\r\n  },\r\n  changeGear: function(frontOrRear, newValue) {\r\n    if (frontOrRear === \'front\') {\r\n      this.frontGearIndex = newValue;\r\n    } else {\r\n      this.rearGearIndex = newValue;\r\n    }\r\n  }\r\n};\r\n\r\nIn the object shown how wouold you access its properties ? ','SalesforcePD1/Javascript',0,0,NULL,5),(4412,'changeGear: function(frontOrRear, upOrDown) {\r\n  let shiftFunction = frontOrRear + upOrDown;\r\n  this[shiftFunction]();\r\n},\r\nfrontUp: function(){\r\n  this.frontGearIndex += 1;\r\n},\r\nfrontDown: function(){\r\n  this.frontGearIndex -= 1;\r\n},\r\nrearUp: function(){\r\n  this.rearGearIndex += 1;\r\n},\r\nrearDown: function(){\r\n  this.rearGearIndex -= 1;\r\n}\r\n\r\n\r\nconsole.log(bike.calculateGearRatio()); // 2.727272727\r\n//Calls the frontUp() function\r\nbike.changeGear(\"front\", \"Up\");\r\nconsole.log(bike.calculateGearRatio()); // 4.090909091\r\n//calls the rearUp() function\r\nbike.changeGear(\"rear\", \"Up\");\r\nconsole.log(bike.calculateGearRatio()); // 3.461538461','Take the Bike object from before... \r\n\r\nWhile it requires more typing, bracket notation has two benefits. You can name your property or function anything you want, and because it’s a string, you can pass a property or function name through a variable and then call it.\r\n\r\nLet\'s see this at work by reimagning the changeGear function. We now use four functions to define shifting the front and rear gears either up or down. In the changeGear function, we construct the name of the function to call based on String parameters and then call it. \r\n\r\n','SalesforcePD1/Javascript',0,0,NULL,5),(4413,'true\r\nundefined','const bike = {\r\n  frontGearIndex: 0,\r\n  rearGearIndex: 0,\r\n  transmission: {\r\n    frontGearTeeth: [30,45],\r\n    rearGearTeeth: [11,13,15,17,19,21,24,28,32,36]\r\n  },\r\n  calculateGearRatio: function() {\r\n    let front = this.transmission.frontGearTeeth[this.frontGearIndex],\r\n        rear = this.transmission.rearGearTeeth[this.rearGearIndex];\r\n    return (front / rear);\r\n  },\r\n  changeGear: function(frontOrRear, newValue) {\r\n    if (frontOrRear === \'front\') {\r\n      this.frontGearIndex = newValue;\r\n    } else {\r\n      this.rearGearIndex = newValue;\r\n    }\r\n  }\r\n};\r\n\r\n------------------------------------------------------------\r\nbike.isTandem = true;\r\nbike.popAWheelie = function() {\r\n…\r\n};\r\n\r\n------------------------------------------------------------\r\n\r\nconst bike1 = new Bike();\r\nconst bike2 = new Bike();\r\nbike1.isTandem = true;\r\nconsole.log(bike1.isTandem); \r\nconsole.log(bike2.isTandem); \r\n\r\n','SalesforcePD1/Javascript',0,0,NULL,5),(4414,'his way every object created from Bike, inherits the changeGear function. \r\n\r\nThere is also multilevel inheritance with prototypes. It is referred to as the prototype chain. Implementing a prototype chain using constructor functions is complex, and requires a fair amount of boilerplate code. It’s also beyond the scope of this module. What you need to know is that in order to address prototype chain complexity, ECMA put a standard in place for a more straightforward syntax to implement inheritance: the class syntax. ','Despite not having classes as defined by classical languages, JavaScript still has an inheritance model, called prototype inheritance. \r\n\r\nA prototype is, in fact, another object. It sits in memory, and defines properties or functions that other objects inherit if they share the same prototype. \r\n\r\nTraditionally in JavaScript objects share the same prototype by sharing the same constructor function. Remember the Bike constructor. We assign the changeGear function to something called prototype. \r\n\r\nfunction Bike(gears, startGear) {\r\n  this.gears = gears;\r\n  this.currentGear = startGear;\r\n}\r\nBike.prototype.changeGear = function(direction, changeBy) {\r\n  if (direction === \'up\') {\r\n    this.currentGear += changeBy;\r\n  } else {\r\n    this.currentGear -= changeBy;\r\n  }\r\n}','SalesforcePD1/Javascript',0,0,NULL,5),(4415,'Every rendered component is itself a javascript object. All objects inherit from an aura:component prototype. You can also use the extends attribute in your custom component to create subcomponents. In this way the framework abstracts the creation of the prototype chain between components. \r\n\r\n<!--Component c:bike-->\r\n<aura:component extensible=\"true\">\r\n  ...\r\n</aura:component>\r\n<!--Component c:mountainBike-->\r\n<aura:component extends=\"c:bike\">\r\n  ...\r\n</aura:component>','How are javascript objects used in Lightning ? ','SalesforcePD1/Javascript',0,0,NULL,5),(4416,'E A and C ','Considering the following JavaScript object: let bike = {gears: 10}. Which are valid ways to access its property? \r\n\r\nbike.gears \r\n\r\nbike[gears]\r\n\r\nbike[\"gears\"]\r\n\r\nA and B\r\n\r\nB and C','SalesforcePD1/Javascript',0,0,NULL,5),(4417,'','To reiterate, DOM events and other events related to the browser environment are not actually part of the core JavaScript language, rather they are APIs that are implemented for JavaScript in the browser. \r\n\r\nWhen an event is emitted, a message is created in the engine. It is these messages that are placed in the event queue we talked about earlier. ','SalesforcePD1/Javascript',0,0,NULL,5),(4418,'Once the stack is free, the event handler is invoked. This creates what’s referred to as a frame on the call stack. Each time one function invokes another, a new frame is added to the stack, and when complete, it is popped off the stack, until finally the frame for the actual event handler is popped, the stack is empty, and we start all over again.','Javascript is single threaded ','SalesforcePD1/Javascript',0,0,NULL,5),(4419,'','In JavaScript functions are essentially special objects. As objects, they are first-class members of JavaScript. They can be assigned as the values of variables, passed into other functions as parameters, and returned from functions. \r\n\r\nThere are two essential phases in the life of a function: definition and invocation.  \r\n\r\nWhen function is declared, its definition is loaded into memory. A pointer is then assigned to it in the form of a variable name, parameter name, or an object property. It should be no surprise, however, that there are several different syntaxes to do this. ','SalesforcePD1/Javascript',0,0,NULL,5),(4420,'In this code sample, function is followed by the name of the function, with parameters enclosed in the parentheses. \r\n\r\nThis works fine, but there’s some implicit stuff happening. First of all, the function name becomes the variable name. It also implicitly assigns the variable to the enclosing context. Finally, you can call this function before it is declared, such as below where calculateGearRatio is invoked the line before the declaration. \r\n\r\n\r\n// call function\r\nlet gearRatio = calculateGearRatio(42, 30);\r\n// function is declared after the line it is called\r\n// this is allowed in function declaration\r\nfunction calculateGearRatio(driverGear, drivenGear){\r\n  return (driverGear / drivenGear);\r\n}\r\nconsole.log(gearRatio); // 1.4','// declare function\r\nfunction calculateGearRatio(driverGear, drivenGear){\r\n  return (driverGear / drivenGear);\r\n}\r\n// call function\r\nlet gearRatio = calculateGearRatio(42, 30);\r\nconsole.log(gearRatio); // 1.4','SalesforcePD1/Javascript',0,0,NULL,5),(4421,'const calculateration = function(numberto, numberfrom) {\r\n   return numberto / numberfrom;\r\n}\r\n\r\ncalculateratio(6,7);','Write a function expression','SalesforcePD1/Javascript',0,0,NULL,5),(4422,'expression and no function expressions are not hoisted. ','const calculateGearRatio = function(driverGear, drivenGear){\r\n  return (driverGear / drivenGear);\r\n}\r\n// the rest works the same\r\nlet gearRatio = calculateGearRatio(42, 30);\r\nconsole.log(gearRatio); // 1.4\r\n\r\nis this function expression or a declaration ? Will you be able to call this before it is declared ','SalesforcePD1/Javascript',0,0,NULL,5),(4423,'They are not hoisted, so they have to be declared before they care invoked. ','What\'s the problem with function expressions ?','SalesforcePD1/Javascript',0,0,NULL,5),(4424,'function expressions are used to assign functions as properties of objects. ','Bike.prototype.changeGear = function(direction, changeBy) {\r\n  if (direction === \'up\') {\r\n    this.currentGear += changeBy;\r\n  } else {\r\n    this.currentGear -= changeBy;\r\n  }\r\n}','SalesforcePD1/Javascript',0,0,NULL,5),(4425,'factory function','// when invoked, this function will assign a function\r\nfunction gearFactory(){\r\n  return function(driverGear, drivenGear){\r\n    return (driverGear / drivenGear);\r\n  }\r\n}\r\n// calculateGearRatio can now be invoked as a function\r\nconst calculateGearRatio = gearFactory();\r\n// and all the rest','SalesforcePD1/Javascript',0,0,NULL,5),(4426,'You can iterate through an array and create a new array by deriving values from the first: \r\n\r\nlet myArray = [1, 5, 11, 17];\r\nlet newArray = myArray.map( function(item){ return item / 2 } );\r\nconsole.log(newArray); // [0.5, 2.5, 5.5, 8.5]','How do you use the Array.map function ? ','SalesforcePD1/Javascript',0,0,NULL,5),(4427,'In this snippet, myArray.map takes in a single parameter: a function that is executed once per item in myArray. \r\n\r\nThis function is never reused. It is declared as an argument (with no name...thus “anonymous”) passed into the function, and is executed in the internals of the implementation of the map function. Anonymous functions (also called lambdas in some languages) are commonplace in JavaScript. ','let myArray = [1, 5, 11, 17];\r\nlet newArray = myArray.map( function(item){ return item / 2 } );\r\nconsole.log(newArray); // [0.5, 2.5, 5.5, 8.5]','SalesforcePD1/Javascript',0,1,NULL,5),(4428,'Once you’ve declared your function, you’ll probably want to get around to invoking it. When a function is invoked, a few things happen. \r\n\r\nRemember, the first thing is a new frame is pushed onto the stack. Then an object containing its variables and arguments is created in memory. The this pointer is then bound to the object along with a few other special objects. Values passed into arguments are then assigned, and finally the runtime begins to execute the statements in the body of the function.','What happens when you invoke a function ?','SalesforcePD1/Javascript',0,0,NULL,5),(4429,'given \r\n\r\n\r\nlet bike = {\r\n  ...,\r\n  calculateGearRatio: function() {\r\n    let front = this.transmission.frontGearTeeth[this.frontGearIndex],\r\n    rear = this.transmission.rearGearTeeth[this.rearGearIndex];\r\n    return (front / rear);\r\n  },\r\n  ...\r\n}\r\n\r\n// invoke function and assign value to ratioResult\r\nlet ratioResult = bike.calculateGearRatio();\r\n// assign calculateGearRatio function to a new pointer\r\nconst ratioFunction = bike.calculateGearRatio;\r\n\r\nthe first example calls the calculateGearRatio function, the second copys the function to another variable. ','When working with js functions what determines whether you are invoking or assigning a function ? \r\n\r\n','SalesforcePD1/Javascript',0,1,NULL,5),(4430,'If function uses this, the context of this could change. ','What\'s the difficulty with copying a function to another variable and passing into another function ? ','SalesforcePD1/Javascript',0,0,NULL,5),(4431,'They cannot be removed. \r\n\r\nbutton.removeEventListener(\"click\", handleClick);\r\n\r\ncan be done after button.addEventListener(\"click\", handleClick) \r\n\r\nbut not after \r\n\r\nbutton.addEventListener(\"click\", function(event){\r\n  //...anonymous function body...\r\n});','var handleClick = function(event) {\r\n  console.log(event.type);  // click\r\n  console.log(event.currentTarget); // the thing you clicked\r\n  console.log(event.screenX); // screen X coordinate\r\n  console.log(event.screenY); // screen Y coordinate\r\n}\r\n\r\n<button id=”clicker”>\r\n\r\nlet button = document.getElementById(\"clicker\");\r\nbutton.addEventListener(\"click\", handleClick);\r\n\r\n... Can also be done this way: \r\n\r\nbutton.addEventListener(\"click\", function(event){\r\n  //...anonymous function body...\r\n});\r\n\r\nWhat\'s the difficulty with assigning an event handler via anonymous functions ? \r\n','SalesforcePD1/Javascript',0,1,NULL,5),(4432,'While this looks like statically assigning an event handler, it really isn’t. Under the covers, the Lightning component framework turns this markup into instructions in JavaScript. \r\n\r\nLightning Component event handler functions also have a different signature. The function is passed three arguments that point to the component itself, the event that fired the function, and the helper object. From there the event handler goes to work. ','<lightning:select onchange=\"{!c.handleSelectChange}\" value=\"{!v.currentFrontGear}\" label=\"Front\">\r\n  <aura:iteration items=\"{!v.frontGears}\" var=\"item\">\r\n    <option value=\"{!item.index}\">{!item.value}</option>\r\n  </aura:iteration>\r\n</lightning:select>','SalesforcePD1/Javascript',0,0,NULL,5),(4433,'To access reusable code, the helper parameter points to the the component’s helper object. Helper functions can contain whatever parameters you need them to according to the logic you are trying to implement. \r\n\r\nOne important point to bear in mind is that all instances of a component share a single helper object. So don’t try to track state in the helper unless you intend for that state to be shared across all instances of your component. You can see an example component that demonstrates that here. ','What\'s tricky with helper functions in lightning','SalesforcePD1/Javascript',0,0,NULL,5),(4434,'aura:method \r\n\r\n<aura:method name=\"reload\" action=\"{!c.handleInit}\" access=\"public\" description=\"Allow explicit reload from other components\"/>','How do you surface a lightning component function to the outside world ? ','SalesforcePD1/Javascript',0,0,NULL,5),(4435,'The function is invoked ','When defining a function with a function declaration, which of the following does not happen implicitly?\r\n\r\na variable is created \r\n\r\nthe function is assigned to the variable \r\n\r\nthe function is attached to the current scope \r\n\r\nthe function is invoked','SalesforcePD1/Javascript',0,0,NULL,5),(4436,'To get a reference to a component event in JavaScript, use cmp.getEvent(\"evtName\") where evtName matches the name attribute in <aura:registerEvent>.','How do you fire a lightning event ?','Salesforce/LightningEvents',0,0,NULL,5),(4437,'','It\'s a good practice to handle low-level events, such as a click, in your event handler and refire them as higher-level events, such as an approvalChange event or whatever is appropriate for your business logic.','Salesforce/LightningEvents',0,0,NULL,5),(4438,'afterRender: function(cmp, helper) {\r\n	    this.superAfterRender();\r\n	    $A.get(\"e.myns:mycmp\").fire();\r\n	}','Don\'t Fire an Event in a Renderer\r\n\r\nFiring an event in a renderer can cause an infinite rendering loop.','Salesforce/LightningEvents',0,0,NULL,5),(4439,'use this to set the value of an attribute inherited from a component or event','<aura:set> ?','Salesforce/LightningComponents',0,0,NULL,5),(4440,'','<force:recordData>\r\ntargetRecord is populated with the current record, containing the fields relevant to the requested layoutType or the fields listed in the fields attribute. targetFields is populated with a simplified view of the loaded record. For example, for the Name field, v.targetRecord.fields.Name.value is equivalent to v.targetFields.Name.','Salesforce/LightningComponents',0,0,NULL,5),(4441,'should be v.selectedBoatId','<aura:attribute name=\"BoatTypeId\" type=\"String\"/>\r\n    <aura:attribute name=\"Boats\" type=\"Boat__c[]\"/>\r\n    <aura:attribute name=\"selectedBoatId\" type=\"String\"/>\r\n    \r\n    <lightning:layout multipleRows=\"true\" horizontalAlign=\"center\" verticalAlign=\"center\">\r\n            <aura:iteration var=\"boat\" items=\"{!v.Boats}\">\r\n                <lightning:layoutItem flexibility=\"grow\" class=\"slds-m-right_small\">\r\n                    <c:BoatTile boat=\"{!boat}\" selected=\"{!boat.Id == selectedBoatId ? true : false}\"/>\r\n                </lightning:layoutItem>\r\n            </aura:iteration> \r\n\r\nwhat\'s wrong here ?','Salesforce/LightningComponents',0,0,NULL,5),(4442,'application:\r\n   \r\n   $A.get(\"e.namespace:myAppevent\");\r\n    myAppevent.setParams({ \"myparam\" : value });\r\n    myAppevent.fire();\r\n\r\ncomponent event: \r\n<aura:registerEvent name=\"myAppEvent\" type=\"c:myAppEvent\" />\r\n   component.getEvent(\"myAppEvent\");\r\n  myAppEvent.setParam(\"param\", value);\r\n\r\n\r\nuse set param syntax on component events, where name and value are seperated with a comma, use JSON format for application events. Name Attribute doesn\'t matter for application events because they are gotten through namespace and therefore use the event type name. \r\n\r\n','In Javascript how do you get an application event ? a component event ? ','Salesforce/LightningEvents',0,0,NULL,5),(4443,'<aura:handler name=\"BoatHAndler\" event=\"c:TypeName\" action=\"{!c.method}\" />','write a handler ','Salesforce/LightningEvents',0,0,NULL,5),(4444,'({\r\n  recordUpdated : function(component, event, helper) {\r\n\r\n    var changeType = event.getParams().changeType;\r\n\r\n    if (changeType === \"ERROR\") { /* handle error; do this first! */ }\r\n    else if (changeType === \"LOADED\") { /* handle record load */ }\r\n    else if (changeType === \"REMOVED\") { /* handle record removal */ }\r\n    else if (changeType === \"CHANGED\") { \r\n      /* handle record change; reloadRecord will cause you to lose your current record, including any changes you’ve made */ \r\n      component.find(\"forceRecord\").reloadRecord();}\r\n    }\r\n})','When loading a record in edit mode, the record is not automatically updated to prevent edits currently in progress from being overwritten. To update the record, use the reloadRecord method in the action handler.\r\n\r\n<force:recordData aura:id=\"forceRecord\"\r\n	    recordId=\"{!v.recordId}\"\r\n	    layoutType=\"FULL\"\r\n	    targetRecord=\"{!v._record}\"\r\n	    targetFields=\"{!v.simpleRecord}\"\r\n	    targetError=\"{!v._error}\"\r\n	    mode=”EDIT”\r\n	    recordUpdated=\"{!c.recordUpdated}\" />\r\n\r\nwhat do you do ?','Salesforce/LightningEvents',0,0,NULL,5),(4445,'1233\r\n\r\nvar is function scoped, you might have thought that the second log outside the for loop would give an error since it is referencing the i inside a for loop. However var does not recognize block level scopes so the var in the for loop is automatically hoisted to the top of the function and therefore the second console.log acceses the value three. ','function countToThree(){\r\n   for(var i = 0; i < 3; i++){\r\n     console.log(i);\r\n   }\r\n\r\n   console.log(i);\r\n{','Salesforce/Javascript',0,0,NULL,5),(4446,'error\r\n\r\nlet is block scoped','for(let j = 0; j < 3; j++){\r\n   console.log(j);\r\n}\r\n\r\nconsole.log(j);','Salesforce/Javascript',0,0,NULL,5),(4447,'error','function countwithlet() {\r\nfor(let j= 0; j < 3; j++){\r\n   console.log(j);\r\n}\r\n\r\nconsole.log(j);\r\n}','Salesforce/Javascript',0,0,NULL,5),(4448,'','As we explored, JavaScript revolves around objects. Objects are where state is tracked. When a function is invoked, there is always an object container around that function. This object container is its context and the this keyword points to that context. So context is not set when a function is declared, but rather where the function is invoked. ','Salesforce/Javascript',0,0,NULL,5),(4449,'2,\r\n\r\nnewincrement will be executed in the global context, previously the increment function was executed within the context of that wrapping object. \r\n\r\nSo be careful of using this where it could be executed incorrectly. ','var obj = {\r\n  aValue: 0,\r\n  increment: function(incrementBy) {\r\n    this.aValue = this.aValue + incrementBy;\r\n  }\r\n}\r\n\r\nobj.increment(2);\r\nconsole.log(obj.aValue); // 2\r\n\r\nObjects are where state is tracked. When a function is invoked there is always an object container around that object, so this refers not to where the function is declared but where it is invoked. \r\n\r\nSo given to a new variable, increment method would not work as expected: \r\n\r\nvar newincrement = obj.increment;\r\n\r\nnewincrement(2);\r\n\r\nconsole.log(obj.aValue); \r\n\r\nwhat is the value of obj.aValue ? ','Salesforce/Javascript',0,0,NULL,5),(4450,'When JavaScript is executed without any containing object that you write as a developer, it runs in a global object. For this reason, functions invoked there are said to be running in the global context, which means that accessing this will point there. ','the Global object','Salesforce/Javascript',0,0,NULL,5),(4451,'Window','What is the global object in a browser ? ','Salesforce/Javascript',0,0,NULL,5),(4452,'true','in Browser dev tools console: \r\n\r\nthis === window','Salesforce/Javascript',0,0,NULL,5),(4453,'','const Bike = function(frontIndex, rearIndex){\r\n  this.frontGearIndex = frontIndex || 0;\r\n  this.rearGearIndex = rearIndex || 0;\r\n  ...\r\n}\r\n...\r\nBike.prototype.calculateGearRatio = function(){\r\n  let front = this.transmission.frontGearTeeth[this.frontGearIndex],\r\n  rear = this.transmission.rearGearTeeth[this.rearGearIndex];\r\n  if (front && rear) {\r\n    return (front / rear) ;\r\n  } else {\r\n    return 0;\r\n  }\r\n};\r\n\r\n\r\nconst bike = new Bike(1,2);\r\nconsole.log(bike.frontGearIndex); // 1\r\nconsole.log(bike.rearGearIndex); // 2','Salesforce/Javascript',0,0,NULL,5),(4454,'3','const Bike = function(frontIndex, rearIndex){\r\n  this.frontGearIndex = frontIndex || 0;\r\n  this.rearGearIndex = rearIndex || 0;\r\n  ...\r\n}\r\n...\r\nBike.prototype.calculateGearRatio = function(){\r\n  let front = this.transmission.frontGearTeeth[this.frontGearIndex],\r\n  rear = this.transmission.rearGearTeeth[this.rearGearIndex];\r\n  if (front && rear) {\r\n    return (front / rear) ;\r\n  } else {\r\n    return 0;\r\n  }\r\n};\r\n\r\nconst bike = new Bike(1,2);\r\nconsole.log(bike.frontGearIndex); // 1\r\nconsole.log(bike.rearGearIndex); // 2\r\n\r\nlet gearRatio = bike.calculateGearRatio();\r\nconsole.log(gearRatio); \r\n\r\nwhat does this print ?','Salesforce/Javascript',0,0,NULL,5),(4455,'error \r\nerror\r\n\r\nfunctions are objects, so here without the new keyword you are merely assigning the Bike function to the bike variable, therefore the this references inside Bike assign frontGearIndex and rearGearIndex to the global object and not the the bike variable. \r\n\r\nThats why this gives an error but this wouldnt\':\r\n\r\nwindow.frontGearIndex','const Bike = function(frontIndex, rearIndex){\r\n  this.frontGearIndex = frontIndex || 0;\r\n  this.rearGearIndex = rearIndex || 0;\r\n  ...\r\n}\r\n...\r\nBike.prototype.calculateGearRatio = function(){\r\n  let front = this.transmission.frontGearTeeth[this.frontGearIndex],\r\n  rear = this.transmission.rearGearTeeth[this.rearGearIndex];\r\n  if (front && rear) {\r\n    return (front / rear) ;\r\n  } else {\r\n    return 0;\r\n  }\r\n};\r\n\r\nconst bike = Bike(1,2);\r\nconsole.log(bike.frontGearIndex); \r\nconsole.log(bike.rearGearIndex); \r\n\r\n','Salesforce/Javascript',0,0,NULL,5),(4456,'','The class syntax in JavaScript forces you to invoke a constructor with the new keyword, so you can’t misdirect your context.','Salesforce/Javascript',0,0,NULL,5),(4457,'','When a function is declared, it holds a reference to any variables or arguments declared within it,  it holds a reference to any variables in the scope contained within. ','Salesforce/Javascript',0,0,NULL,5),(4458,'','When a function is declared, it holds a reference to any variables or arguments declared within it, and any variables it references in the scope that it is contained within. This combination of its variables and arguments along with local variables and arguments from its containing scope is called a closure. ','Salesforce/Javascript',0,0,NULL,5),(4459,'Sup, Max!','const greetingmaker = function(greet) {\r\n  return function(who){\r\n     return greet + \", \" + who + \"! \";\r\n  }\r\n}\r\n\r\nvar greetmax = greetingmaker(\"Sup\");\r\n\r\nconsole.log(greetmax(\"Max\"));','Salesforce/Javascript',0,0,NULL,5),(4460,'public global private','Possible aura:attribute access values','Salesforce/Javascript',0,0,NULL,5),(4461,'set disableCategories attribute... \r\n\r\nFORMAT_FONT: Font family and size menus. The font menu provides the following font selection: Arial, Courier, Garamond, Salesforce Sans, Tahoma, Times New Roman, and Verdana. The font selection defaults to Salesforce Sans with a size of 12px. Supported font sizes are: 8, 9, 10, 11, 12, 14, 16, 18, 20, 22, 24, 26, 28, 36, 48, and 72. When you copy and paste text in the editor, the font is preserved only if the font is available in the font menu.\r\nFORMAT_TEXT: Bold, Italic, Underline, and Strikethrough buttons.\r\nFORMAT_BODY: Bulleted List, Numbered List, Indent, and Outdent buttons.\r\nALIGN_TEXT: Left Align Text, Center Align Text, and Right Align Text buttons.\r\nINSERT_CONTENT: Image button. The Image button displays if you include the lighting:insertImageButton component in lightning:inputRichText.\r\nREMOVE_FORMATTING: Remove formatting button, which stands alone at the end of the toolbar.\r\n\r\n  <lightning:inputRichText\r\n                value=\"{!v.myVal}\"\"\r\n                disableCategories=\"FORMAT_TEXT\">\r\n            </lightning:inputRichText>','How do you disable categories from a <lightning:inputRichText /> ?','Salesforce/LightningComponents',0,0,NULL,5),(4462,'the callback passed to getNewRecord must be wrapped in $A.getCallback() to ensure correct access. \r\nThe callback passed to getNewRecord() must be wrapped in $A.getCallback() to ensure correct access context when the callback is invoked. If the callback is passed in without being wrapped in $A.getCallback(), any attempt to access private attributes of your component results in access check failures.','doInit: function(component, event, helper) {\r\n	        // Prepare a new record from template\r\n	        component.find(\"contactRecordCreator\").getNewRecord(\r\n	            \"Contact\", // sObject type (objectApiName)\r\n	            null,      // recordTypeId\r\n	            false,     // skip cache?\r\n	            function() {\r\n	                var rec = component.get(\"v.newContact\");\r\n                var error = component.get(\"v.newContactError\");\r\n	                if(error || (rec === null)) {\r\n	                    console.log(\"Error initializing record template: \" + error);\r\n	                    return;\r\n	                }\r\n	                console.log(\"Record template initialized: \" + rec.apiName);\r\n	            })\r\n	        );\r\n\r\nthis is called for a force:recordData component, what\'s missing here','Salesforce/LightningComponents',0,0,NULL,5),(4463,'anytime you are accessing the component outside the normal rendering cycle, such as in a settimeout() call. You don\'t need to do this when your code is executing as a part of the callstack like when passing a callback to a server call, an exception is when you are passing a callback to the getNewRecord method of LDS. \r\n\r\n\r\nwindow.setTimeout(\r\n  $A.getCallback(function(){\r\n    cmp.setVisible(true);\r\n  }, 500\r\n); \r\n\r\n\r\nthis sets your component to visible after a five second delay, this puts it outside thre normal callstack. ','When must $A.getCallback() be used ?','Salesforce/LightningComponents',0,0,NULL,5),(4464,'EC2 service\r\nlaunch an instance\r\nchoose OS(AMI)\r\nAmazon linux 2\r\nset ssh port 22\r\ncopy ip address for use with ssh\r\nafter creating instance download PEM key file.\r\nchmod 0400 PEMfile.pem(otherwise you get unprotected key error from ssh)\r\nssh -i PEMFile.pem ec2-user@*ip*\r\n\r\nthen you\'re in like flyn','How do you create then ssh into an ec2 instance ? ','AWS/EC2',0,0,NULL,5),(4465,'future methods must be declared static\r\nfuture method don\'t support return types\r\nfuture methods can only take primitive parameters or collection of primitives\r\n','public class FuturuePractice {\r\n    \r\n    @future\r\n    public List<String> getAlotOfString(List<Account> accs){\r\n        List<String> accname = new List<String>();\r\n        \r\n        List<Contact> con = [Select Id,Name From Contact Where AccountId In :accs];\r\n    }\r\n\r\n}\r\n\r\nwhat\'s wrong here ?','Salesforce/Future',0,0,NULL,5),(4466,'This almost acheived 100% code coverage, the only line it didn\'t test was the line that increments an AccountId contact count where one already exists, this is because you only added on contact in your testsetup method.\r\n\r\nYou can test both scenarios by adding multipe contacts under that one account','@isTest\r\npublic class AccountProcessorTest {\r\n    @TestSetup\r\n    static void setupAccounts(){\r\n        Account a = new Account(Name=\'FutureTest\',Number_of_Contacts__c=0.0);\r\n        insert a;\r\n        Contact c = new Contact(LastName=\'TESTER\',AccountId=a.ID);\r\n        insert c;\r\n    }\r\n	\r\n    @IsTest\r\n    static void testConCount(){\r\n        List<Account> acs = [Select Id From Account Where Name=\'FutureTest\' LIMIT 1];\r\n        List<Id> accids = new List<Id>();\r\n        accids.add(acs[0].Id);\r\n        Test.startTest();\r\n        	AccountProcessor.countContacts(accids);\r\n        Test.stopTest();\r\n        List<Account> acAfter = [Select Id,Number_of_Contacts__c From Account Where Name=\'FutureTest\'];\r\n        System.assertEquals(acAfter[0].Number_of_Contacts__c,1);\r\n    }\r\n}\r\n\r\n=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=\r\n\r\npublic class AccountProcessor {\r\n    \r\n    @future\r\n    public static void countContacts(List<ID> accIds){\r\n        List<Contact> cons = [Select Id,Name,AccountId From Contact Where AccountId IN :accIds];\r\n        Map<Id,Integer> acConCount = new Map<Id,Integer>();\r\n        \r\n        for(Contact c : cons){\r\n            if(acConCount.containsKey(c.AccountId)){\r\n                acConCount.put(c.AccountId,acConCount.get(c.AccountId)+1);\r\n            }else{\r\n                acConCount.put(c.AccountId,1);\r\n            }\r\n        }\r\n        \r\n        List<Account> acs = [Select Id,Name,Number_of_Contacts__c From Account Where Id IN :accIDs];\r\n        for(Account a : acs){\r\n            a.Number_of_Contacts__c = acConCount.get(a.Id);\r\n        }\r\n        update acs;\r\n        \r\n    }\r\n\r\n}','SalesforcePD1/Testing',0,0,NULL,5),(4467,'CDEFGHIJKLM\r\nABCDEFGHIJKLM\r\nDEF\r\nBCDEFG\r\nstring index out of bounds exception','String str = \"ABCDEFGHIJKLM\";\r\n\r\nwhat do each of the following return ?\r\n\r\nString st2 = str.substring(2);\r\nString st3 = str.substring(0);\r\nString st4 = str.substring(3,6);\r\nString st5 = str.substring(1,7);\r\nString st6 = str.substring(4,15);','Java/interviews',0,3,NULL,5),(4468,'        String result = str;\n        \n        if(str.length() >= 3){\n            int midx = str.length()/2;\n            result = str.substring(midx-1,midx+2);\n        }\n        \n        return result;','    public static String middleThree(String str) {\n\n                /**\n            Given a string of odd length, return the middle 3 characters from the string, \n            so the string <b>\"Monitor\"</b> yields <b>\"nit\"</b>. \n            If the string length is less than 3, return the string as is. <br> <br>\n\n            <b>EXPECTATIONS:</b><br>\n            middleThree(\"bunny\") <b>---></b> \"unn\" <br>\n            middleThree(\"peter\") <b>---></b> \"ete\" <br>\n            middleThree(\"Jamaica\") <b>---></b>\"mai\" <br>\n             */\n                \n            String result = str;\n            if(str.length() <= 3){\n                return result;\n            }\n\n            if((str.length() % 2) != 0){\n                int x = (str.length() - 1)/2;\n                x--;\n                int y = x + 3;\n                result = result.substring(x,y);\n            }\n            return result;\n    }','Java/interviews',0,0,NULL,5),(4469,'got it','In Integer division 5 / 2 = 2\r\n\r\nthe decimals are truncated. \r\n\r\nSo with the middle three problem you can find the middle three digits of any String by doing this: \r\n\r\npublic static String middleThree(String str) {\r\n  \r\n   String result = str;\r\n   \r\n   if(str.length() >= 3) {\r\n     int mid = str.length()/2;     //integer division\r\n     result = str.substring((mid - 1), mid + 2));\r\n  }\r\n\r\n  return result;\r\n}','Java/interviews',0,3,NULL,5),(4470,'-1','String ttbg = \"too good to be true\";\r\nsout( ttbg.indexOf(\"BIG BOOTS\"));','Java/interviews',0,2,NULL,5),(4471,'int i = 0;\r\nwhile(true){\r\n   int found = String.indexOf(\"Category:\",i);\r\n   if( found == -1) break;\r\n   int start = found + 9;\r\n   int end = str.indexOf(\" \",start);\r\n   sout( str.substring(start, end) );\r\n   i = end + 1;\r\n}','Write an algorithim to print out all occurances of a category, print the name after the colon in \"category:\" in  a long message. ','Java/Interviews',0,0,NULL,5),(4472,'String s = \"ABCDEFGHIJKLMNOP\";\r\n        for(int i = (s.length() - 1); i>=0; i--){\r\n            System.out.println(s.charAt(i));\r\n        }','String s = \"ABCDEFGHIJKLMNOP\";\r\n\r\nprint these letters backward','Java/Interviews',0,0,NULL,5),(4473,'for(int i =0; i<=100; i++){\r\n            if(i % 2 == 0){\r\n                System.out.println(i);\r\n            }\r\n        }\r\n\r\n...or\r\n\r\nfor(int i =0; i<=100; i+=2){\r\n sout( i );\r\n}','print all even numbers from 0 to 100','Java/Interviews',0,0,NULL,5),(4474,'It is a functional interface, found in java.util.function, the JDK defines several of this type of interface. They are so simple that it may not be worth it to define in your application. \r\n\r\nPredicate has one method; \r\n\r\n    boolean test(T t);\r\n\r\nYou can use this however you want. ','What is the Predicate<T> interface used for ? ','Java/Interviews',0,0,NULL,5),(4475,'Predicat<T> are good interfaces to use with lambdas','interface Predicate<Person> {\r\n    boolean test(Person t);\r\n}\r\n\r\npublic static void printPersonsWithPredicate(\r\n    List<Person> roster, Predicate<Person> tester) {\r\n    for (Person p : roster) {\r\n        if (tester.test(p)) {\r\n            p.printPerson();\r\n        }\r\n    }\r\n}\r\n\r\nprintPersonsWithPredicate(\r\n    roster,\r\n    p -> p.getGender() == Person.Sex.MALE\r\n        && p.getAge() >= 18\r\n        && p.getAge() <= 25\r\n);','Java/Interviews',0,0,NULL,5),(4476,'processPersons(\r\n     roster,\r\n     p -> p.getGender() == Person.Sex.MALE\r\n         && p.getAge() >= 18\r\n         && p.getAge() <= 25,\r\n     p -> p.printPerson()\r\n);\r\n\r\nusing lambdas turns the invocation around so that the caller passes the specific functionality they want to the method.\r\nThe method still defines the basic way the functionality is used but it is more robust to allow the caller to provide lambdas.','With lambdas you can use the Consumer interface: \r\n\r\npublic static void processPersons(\r\n    List<Person> roster,\r\n    Predicate<Person> tester,\r\n    Consumer<Person> block) {\r\n        for (Person p : roster) {\r\n            if (tester.test(p)) {\r\n                block.accept(p);\r\n            }\r\n        }\r\n}\r\n\r\nConsumer is another functional interface, how could you pass lambdas to this function ? ','Java/Interviews',0,0,NULL,5),(4477,'processPersonsWithFunction(\r\n    roster,\r\n    p -> p.getGender() == Person.Sex.MALE\r\n        && p.getAge() >= 18\r\n        && p.getAge() <= 25,\r\n    p -> p.getEmailAddress(),\r\n    email -> System.out.println(email)\r\n);','For the printpersons example suppose you want to retrieve information from the person class then print that out.\r\nYou need a functional interface that returns a value. The Function<T,R> interface has the R apply(T t) method. \r\n\r\nSo with that given this code, how would you invoke this method using  lambdas? \r\n\r\npublic static void processPersonsWithFunction(\r\n    List<Person> roster,\r\n    Predicate<Person> tester,\r\n    Function<Person, String> mapper,\r\n    Consumer<String> block) {\r\n    for (Person p : roster) {\r\n        if (tester.test(p)) {\r\n            String data = mapper.apply(p);\r\n            block.accept(data);\r\n        }\r\n    }\r\n}','Java/Interviews',0,0,NULL,5),(4478,'       String result = str;\r\n            if(str.length() <= 3){\r\n                return result;\r\n            }\r\n\r\n            if((str.length() % 2) != 0){\r\n                int x = (str.length() - 1)/2;\r\n                x--;\r\n                int y = x + 3;\r\n                result = result.substring(x,y);\r\n            }\r\n            return result;','            Given a string of odd length, return the middle 3 characters from the string, \r\n            so the string <b>\"Monitor\"</b> yields <b>\"nit\"</b>. \r\n            If the string length is less than 3, return the string as is. <br> <br>\r\n\r\n            <b>EXPECTATIONS:</b><br>\r\n            middleThree(\"bunny\") <b>---></b> \"unn\" <br>\r\n            middleThree(\"peter\") <b>---></b> \"ete\" <br>\r\n            middleThree(\"Jamaica\") <b>---></b>\"mai\" <br>','Java/Interviews',0,0,NULL,5),(4479,' public static boolean isOrdered(int first, int second, int third, boolean itsOk) {\r\n            return ((third > second && second > first) || (itsOk && third > second));\r\n    }','    Given three ints, first, second, third, return true if second is greater than first, and third is \r\n    greater than second. However, with the exception that if the parameter \"itsOk\" is true, \r\n    second does not need to be greater than first but still better be less than third.\r\n    <br>\r\n    <br>\r\n\r\n     * <b>EXPECTATIONS:</b><br>\r\n            isOrdered(1, 2, 4, false)   <b>---></b> true <br>\r\n            isOrdered(1, 2, 1, false)    <b>---></b> false <br>\r\n            isOrdered(1, 1, 2, true) <b>---></b> true <br>','Java/Interviews',0,0,NULL,5),(4480,'0\r\n\r\nthe default value is 0 for int[]','int[] values = new int[100];\r\n\r\nsout( values[8] );','Java/Arrays',0,0,NULL,5),(4481,'','int[] values = new int[]{ 4, 5, 3, 7, 3};','Java/Arrays',0,0,NULL,5),(4482,'search(int[] nums, int target){\r\n  for(int i=0; i<nums.length; i++){\r\n     if(nums[i] == target)\r\n        return i;\r\n   }\r\n}\r\n\r\nor...\r\n\r\nsearch(int[] nums, int target){\r\n   int ret = -1;\r\n   for(int i=0; i<nums.length; i++){\r\n     if(nums[i] == target)\r\n        ret = i;\r\n   }\r\n\r\n   return ret;\r\n}\r\n     ','implement a search(int[] nums, int target) method that finds the target number in the array, and returns the index of the found number, and -1 if not found. ','Java/Arrays',0,0,NULL,5),(4483,'10\r\n10\r\n10\r\n..\r\n\r\nuntil you get a stack overflow error, there is no change to the number here. ','  public static void main(String[] args) {\r\n        //Integer[] A = {5,2,4,6,1,3};\r\n        //TestingUtils.runTests();\r\n        printNumber(10);\r\n        \r\n    }\r\n    \r\n    public static int printNumber(int n){\r\n        if(n == 0){\r\n            return 0;\r\n        }else{\r\n            System.out.println(n);\r\n            return printNumber(n);\r\n        }\r\n    }','Java/Interviews',0,0,NULL,5),(4484,'    public static void main(String[] args) {\r\n        //Integer[] A = {5,2,4,6,1,3};\r\n        //TestingUtils.runTests();\r\n        printNumber(10);\r\n        \r\n    }\r\n    \r\n    public static int printNumber(int n){\r\n        if(n == 0){\r\n            return 0;\r\n        }else{\r\n            System.out.println(n);\r\n            return printNumber(--n);\r\n        }\r\n    }','Write a method to count down from 10 using recursion.','Java/Interviews',0,0,NULL,5),(4485,'10\r\n10\r\n10\r\n...\r\n\r\nuntil you get a stack overflow, if you don\'t decrement until after the recursive call, then you are essentially not doing anything. Because when that recursive call is made you leave this method and go into the next one, since the parameter is a primitive. ','    public static void main(String[] args) {\r\n        //Integer[] A = {5,2,4,6,1,3};\r\n        //TestingUtils.runTests();\r\n        printNumber(10);\r\n        \r\n    }\r\n    \r\n    public static int printNumber(int n){\r\n        if(n == 0){\r\n            return 0;\r\n        }else{\r\n            System.out.println(n);\r\n            return printNumber(n--);\r\n        }\r\n    }','Java/Interviews',0,0,NULL,5),(4486,'10\r\n9\r\n8\r\n7\r\n6\r\n5\r\n4\r\n3\r\n2\r\n1\r\n\r\nif you wanted it to count to zero change the if to (n < 0)','    public static void main(String[] args) {\r\n        //Integer[] A = {5,2,4,6,1,3};\r\n        //TestingUtils.runTests();\r\n        printNumber(10);\r\n        \r\n    }\r\n    \r\n    public static int printNumber(int n){\r\n        if(n == 0){\r\n            return 0;\r\n        }else{\r\n            System.out.println(n);\r\n            return printNumber(--n);\r\n        }\r\n    }','Java/Interviews',0,0,NULL,5),(4487,'printNumber(4)   -->  printNumber(3)  --> printNumber(2)  -->  printNumber(1)  --> printNumber(0)  by this point the methods start returning 0 all the way up until printNumber(4). ','public static printNumber(int num) {\r\n   if(num == 0){\r\n      return 0;\r\n   } else {\r\n      sout( num );\r\n      return printNumber(num -1);\r\n    }\r\n}\r\n\r\nif you call printNumber(4), what happens before this method returns ? ','Java/Interviews',0,0,NULL,5),(4488,'stackoverflowerror','    public static void main(String[] args) {\r\n        System.out.println(allDollars(\"Zebra\"));\r\n    }\r\n    \r\n    public static String allDollars(String str){\r\n        String s1 = str.substring(0,(str.length() - 1));\r\n        s1 += \"$\";\r\n        allDollars(s1);\r\n        return s1;\r\n    }','Java/Interviews/recursion',0,0,NULL,5),(4489,'stack overflow error','    public static void main(String[] args) {\r\n        System.out.println(allDollars(\"Zebra\"));\r\n        \r\n    }\r\n    \r\n    public static String allDollars(String str){\r\n        String str2 = str.substring(0,(str.length() - 1));\r\n        str2 += \"$\";\r\n        return allDollars(str2);\r\n    }','Java/Interviews/recursion',0,0,NULL,5),(4490,'$$$$$','  public static void main(String[] args) {\r\n        System.out.println(allDollars(\"Zebra\"));\r\n        \r\n    }\r\n    \r\n    public static String allDollars(String str){\r\n        if(str.length() == 0){\r\n            return str;\r\n        }\r\n        \r\n        String st2 = allDollars(str.substring(0,str.length() - 1));\r\n         st2 += \"$\";\r\n        return st2;\r\n    }','Java/Interviews/recursion',0,0,NULL,5),(4491,'public static String allDollars(String st){\r\n\r\n    if(st.length() <= 1)  //base case\r\n        return st;\r\n\r\n    return st.charAt[0] + \"$\" + allDollars(st.substring(1));\r\n\r\n}','Write a method that splices $ in between every letter\r\n\r\n   Zebra => Z$e$b$r$A','Java/Interviews/recursion',0,0,NULL,5),(4492,'false, case sensative','String sentance = \"Help me I\'m lost.\"\r\n\r\nsout( sentance.startsWith(\"help\") );','Java/Interviews',0,0,NULL,5),(4493,'true','String sentance = \"Help me I\'m lost.\"\r\n\r\nsout( sentance.startsWith(\"Help\") );','Java/Interviews',0,0,NULL,5),(4494,'true','String sentance = \"Help me I\'m lost.\"\r\n\r\nsout( sentance.endsWith(\"lost\") );','Java/Interviews',0,0,NULL,5),(4495,'the remainder is dropped','what happens in integer division','Java/Interviews',0,0,NULL,5),(4496,'public static boolean isCool(int n) {\r\n                    if(n % 11 == 0 || n % 11 == 1){\r\n                        return true;\r\n                    }else {\r\n                        return false;\r\n                    }\r\n            }','    We\'ll say a number is cool if it\'s a multiple of 11 or if it is one more than a multiple of 11. \r\n    Return true if the given non-negative number is cool.','Java/Interviews',0,0,NULL,5),(4497,'You shoud use multi - part upload when your file is bigger than 5 gb. ','You\'re trying to upload a 25 GB file on S3 and it\'s not working','AWS/S3',0,0,NULL,5),(4498,'Bucket names in S3 must be globally unique. ','I tried creating an S3 bucket named \"dev\" but it didn\'t work. This is a new AWS Account and I have no buckets at all. What is the cause?','AWS/S3',0,0,NULL,5),(4499,'xxxx_myfile.myfileextension where xxxx is a randoml characters and numbers','(exam style) We are reading and writing to S3 at a rate of 1000 files per seconds. To optimise the performance of S3, we should adopt the following format:','AWS/S3',0,0,NULL,5),(4500,'null','You\'ve added files in your bucket and then enabled versioning. The files you\'ve already added will have which version?','AWS/S3',0,0,NULL,5),(4501,'SSE-C','Your client wants to make sure the encryption is happening in S3, but wants to fully manage the encryption keys and never store them in AWS. You recommend','AWS/S3',0,0,NULL,5),(4502,'SSE - KMS','Your company wants data to be encrypted in S3, and maintain control of the rotation policy for the encryption keys. You recommend','AWS/S3',0,0,NULL,5),(4503,'Client side encryption','Your company does not trust S3 for encryption and wants it to happen on the application. You recommend','AWS/S3',0,0,NULL,5),(4504,'SSE - C','Which encryption method requires HTTPS?','AWS/S3',0,0,NULL,5),(4505,'The IAM user must not have the correct policy attached. ','The bucket policy allows our users to read / write files in the bucket, yet we were not able to perform a PutObject API call.','AWS/S3',0,0,NULL,5),(4506,'CORS is wrong','You have a website that loads files from another S3 bucket. When you try the URL of the files directly in your Chrome browser it works, but when the website you\'re visiting tries to load these files it doesn\'t. What\'s the problem?','AWS/S3',0,0,NULL,5),(4507,'You might think it would print .9 but you\'re wrong. It prints .89999999\r\n\r\nThe problem is that 1.10 cannot be represented exactly as a double so it is ill suited to be used for monetary calculations.\r\n\r\navoid float or double where exact numbers are required. For monteary calculations use int long or BigDecimal','public class change{\r\n   psvm(sa){\r\n     sout( 2.0 - 1.10);\r\n   }\r\n}\r\n\r\nwhat does this return ? ','Java/Puzzlers',0,0,NULL,5),(4508,'169\r\n\r\nThe problem is that H and a are both char literals, so the + operator performs addition rather than string concatination, since niether of these is a String. \r\n\r\nto fix the problem simply do this: \r\n\r\nsout( \"\" + \'H\' + \'a\');','public class LastLaugh {\r\n  psvm(sa){\r\n    sout( \'H\' + \'a\');\r\n  }\r\n}','Java/Puzzlers',0,0,NULL,5),(4509,'ABC easy as [C@16f0472 .\r\n\r\nchar[] are objects and therefore inherit the toString method from Object which when un overriden prints something the class name @ followed by the hex representation of it\'s hashCode. ','public class Abc {\r\npublic static void main(String[] args) {\r\nString letters = \"ABC\";\r\nchar[] numbers = { ’1’, ’2’, ’3’ };\r\nSystem.out.println(letters + \" easy as \" + numbers);\r\n}\r\n}','Java/Puzzlers',0,0,NULL,5),(4510,'an interface that contains one and only one abstract method. ','What is a functional interface ?','Java8/Lambdas',0,0,NULL,5),(4511,'Will not compile\r\n\r\nimplementing class cannot be static. ','public interface Tester {\r\n   public boolean runTests();\r\n}\r\n\r\npublic class TestingUtils {\r\n\r\n  public static boolean runTests(){\r\n    return true;\r\n  }\r\n}\r\n','Java8/OOP',0,0,NULL,5),(4512,'this is wrong, you have to define the variable. \r\n\r\nit would be \r\n\r\nNumericTest even = (n) -> (n % 2) == 0;\r\n\r\n\r\neven.runTest(5); // false','public interface NumericTest {\r\n    public boolean runTest(int n);\r\n}\r\n\r\nNumericTest even = (5) -> (5 % 2) == 0;\r\n\r\n','Java8/Lambdas',0,0,NULL,5),(4513,'Wont compile, it should be \r\n\r\nisOdd.runTest(9)\r\nisEven.runTest(4);\r\n\r\na lambda is a way to implement the method from a functional interface in different ways. You still have to call that method though. ','public interface NumericTest {\r\n    public boolean runTest(int n);\r\n}\r\n\r\npublic static void main(String[] args) {\r\n        NumericTest isEven = (n) -> (n % 2) == 0;\r\n        NumericTest isOdd = (n) -> (n % 2) == 1;\r\n        \r\n        System.out.println(isOdd(9));\r\n        System.out.println(isEven(4));\r\n    }\r\n','Java8/Lambdas',0,0,NULL,5),(4514,'Will not compile you still have to run the method. ',' public interface MoringGreeting {\r\n    public String greet(String s);\r\n}\r\n\r\n       MoringGreeting goodmorning = (str) -> \"Goodmorning \" + str+\"!\";\r\n        System.out.println(goodmorning(\"max\"));','Java8/Lambdas',0,0,NULL,5),(4515,'Goodmorning max!\r\ntrue\r\ntrue','  public static void main(String[] args) {\r\n        NumericTest isEven = (n) -> (n % 2) == 0;\r\n        NumericTest isOdd = (n) -> (n % 2) == 1;\r\n        MoringGreeting goodmorning = (str) -> \"Goodmorning \" + str+\"!\";\r\n        System.out.println(goodmorning.greet(\"max\"));\r\n        System.out.println(isOdd.runTest(9));\r\n        System.out.println(isEven.runTest(4));\r\n    }','Java8/Lambdas',0,0,NULL,5),(4516,'MoringGreeting gmmax = (String str) -> \"good morning \"+str+\"!\";','public interface MoringGreeting {\r\n    public String greet(String s);\r\n}\r\n\r\npsvm(sa){\r\n   \r\n   MoringGreeting gmmax = (str) -> \"good morning \"+str+\"!\";\r\n    gmmax.greet(\"MAX\");\r\n}\r\n\r\nhow could you re write this to explicitley specify the parameter type. ','Java8/Lambdas',0,0,NULL,5),(4517,'public static void main(String... args) {\r\n    Runnable r2 = () -> System.out.println(\"Howdy, world!\");\r\n    r2.run();\r\n  } ','public class Lambdas {\r\n  public static void main(String... args) {\r\n    Runnable r = new Runnable() {\r\n      public void run() {\r\n        System.out.println(\"Howdy, world!\");\r\n      }\r\n    };\r\n    r.run();\r\n  }\r\n} \r\n\r\nwrite this a lambda','Java8/Lambdas',0,0,NULL,5),(4518,'got it ','The designers of Java 8 have chosen to give us an annotation, @FunctionalInterface, to serve as a documentation hint that an interface is designed to be used with lambdas, but the compiler does not require this—it determines “functional interfaceness” from the structure of the interface, not from the annotation.','Java8/Lambdas',0,0,NULL,5),(4519,'psvm(Sa){\r\n   Comparator<String> c = \r\n       (String lhs, String rhs) -> lhs.compareTo(rhs);\r\n\r\n    int resutl = c.compare(\"Hello\",\"World\");\r\n}\r\n','Implement a comparator as a lambda , then call it. ','Java8/Lambdas',0,0,NULL,5),(4520,'got it','re than one expression, the value returned from the expression can be handed back via the return keyword, just as with any block of Java code (see Listing 5).\r\n\r\npublic static void main(String... args) {\r\n    Comparator<String> c = \r\n      (String lhs, String rhs) -> lhs.compareTo(rhs);\r\n    int result = c.compare(\"Hello\", \"World\");\r\n  }','Java8/Lambdas',0,0,NULL,5),(4521,'psvm(SA){\r\n\r\n Comparator<String> c = (String lhs, String rhs) -> {\r\n   \r\n     sout(\"comparing\" +lhs+\" and \" +rhs);\r\n     \r\n    return lhs.compareTo(rhs);\r\n\r\n};\r\n\r\nint result = c.compare(\"MAX\",\"IS AWSOME AT JAVA\");\r\n}','implement a comparator using a lambda and print out what you are comparing. \r\n\r\n','Java8/Lambdas',0,0,NULL,5),(4522,'','here are a few restrictions on what can be done in the body of the lambda, most of which are pretty intuitive—a lambda body can’t “break” or “continue” out of the lambda, and if the lambda returns a value, every code path must return a value or throw an exception, and so on. \r\n\r\npublic static void main(String... args) {\r\n    Comparator<String> c =\r\n      (lhs, rhs) ->\r\n        {\r\n          System.out.println(\"I am comparing\" +\r\n                             lhs + \" to \" + rhs);\r\n          return lhs.compareTo(rhs);\r\n        };\r\n    int result = c.compare(\"Hello\", \"World\");\r\n  } \r\n\r\n\r\nSuch is the case with the Comparator example in Listing 5. If the target type is a Comparator<String>, the objects passed in to the lambda must be strings (or some subtype); otherwise, the code wouldn’t compile in the first place. (This isn’t new, by the way—this is “Inheritance 101.”)\r\n\r\nIn this case, then, the String declarations in front of the lhs and rhs parameters are entirely redundant and, thanks to Java 8’s enhanced type inference features, they are entirely optional (see Listing 6).','Java8/Lambdas',0,0,NULL,5),(4523,'','One interesting side effect of Java’s lambda syntax is that for the first time in Java’s history, we find something that cannot be assigned to a reference of type Object (see Listing 7)—at least not without some help.\r\n\r\npublic static void main4(String... args) {\r\n    Object o = () -> System.out.println(\"Howdy, world!\");\r\n      // will not compile\r\n  } \r\n\r\nThe compiler will complain that Object is not a functional interface, though the real problem is that the compiler can’t quite figure out which functional interface this lambda should implement: Runnable or something else? We can help the compiler with, as always, a cast, as shown in Listing 8.\r\n\r\n\r\n public static void main4(String... args) {\r\n    Object o = (Runnable) () -> System.out.println(\"Howdy, world!\");\r\n      // now we\'re all good\r\n  } ','Java8/Lambdas',0,0,NULL,5),(4524,'Will not compile, can\'t be int must be Integer. Incompatible types.','interface Something {\r\n  public String doit(Integer i);\r\n}\r\n\r\nSomething s = (Integer i) -> { return i.toString(); };\r\nSystem.out.println(s.doit(4)); \r\n\r\nSomething somethin =  (int x) -> \r\n        {\r\n            System.out.println(x); \r\n            x *= x;\r\n            return x;\r\n        };','Java8/Lambdas',0,0,NULL,5),(4525,'test','test','Java8/Lambdas',0,0,NULL,5),(4526,'aws s3 mb s3://bucketname','How do you make a bucket ?','AWS/CLI',0,0,NULL,5),(4527,'aws s3 rb s3://bucketname','How do you remove a bucket ?','AWS/CLI',0,0,NULL,5),(4528,'public static int nearestTwentyOne(int a, int b) { //19 22\r\n            int x = 21 - a; // 2\r\n            int y = 21 - b; // -1\r\n            \r\n            if(x >= 0 && y >= 0){\r\n                return (x <= y ? a : b);\r\n            } else {\r\n                return ((y<0 && x<0) ? 0:(x>=y ?a:b));\r\n            }\r\n    }\r\n\r\nif(a > 21 && b > 21) return 0;\r\nif(a > 21 && b <= 21) return b;\r\nif(a <= 21 && b > 21) return a;\r\n\r\nif(a>b)\r\n   return a;\r\nelse \r\n   return b;\r\n\r\n','Given 2 positive int arguments (a, b), return whichever argument is \r\n    nearest to the number 21 without going over.\r\n    Return 0 if they both go over 21. \r\n    <br>\r\n    <br>\r\n\r\n     * <b>EXPECTATIONS:</b><br>\r\n            nearestTwentyOne(19, 21)   <b>---></b> 21 <br>\r\n            nearestTwentyOne(21, 19)    <b>---></b> 21 <br>\r\n            nearestTwentyOne(19, 22) <b>---></b> 19 <br>\r\n            nearestTwentyOne(32, 22) <b>---></b> 0 <br>','Java/Interviews',0,0,NULL,5),(4529,'public static int partialSum(int a, int b, int c) {\r\n		int sum = 0;\r\n                if(a != 13){\r\n                    sum += a;\r\n                    if(b != 13){\r\n                        sum += b;\r\n                        if(c!=13){\r\n                            sum+=c;\r\n                            return sum;\r\n                        }\r\n                    }\r\n                    return sum;\r\n                }\r\n       \r\n		return sum;	\r\n	}\r\n\r\nif(a == 13) return 0;\r\nif(b==13) return a;\r\nif(c==13) return a+b;\r\nreturn a+b+c;\r\n\r\n','Given 3 int arguments, a b c, return their sum. However, if one of the arguments is 13 \r\n	then it does not count towards the sum and arguments to it\'s right do not count either. \r\n	So for example, if b is 13, then both b and c do not count. \r\n	<br>\r\n	<br>\r\n\r\n	 * <b>EXPECTATIONS:</b><br>\r\n		partialSum(1, 2, 3)   <b>---></b> 6 <br>\r\n		partialSum(1, 2, 13)    <b>---></b> 3 <br>\r\n		partialSum(1, 13, 3) <b>---></b> 1 <br>\r\n	 */','Java/Interviews',0,0,NULL,5),(4530,'    public static String repeatChar(String str) {\r\n            String newstring = \"\";\r\n            for(int i = 0; i<str.length(); i++){\r\n                char c = str.charAt(i);\r\n                newstring += c;\r\n                newstring += c;\r\n            }\r\n            return newstring;\r\n    }\r\n\r\nor...\r\n\r\n    char c = str.charAt(i);\r\n    newstring += \"\" + c + c;',' /**\r\n\r\n    Given a string, return a string where for every char in the original, append another. \r\n    <br>\r\n    <br>\r\n\r\n     * <b>EXPECTATIONS:</b><br>\r\n            repeatChar(\"The\")  <b>---></b>\"TThhee\"<br>\r\n            repeatChar(\"AAbb\")    <b>---></b> \"AAAAbbbb\" <br>\r\n            repeatChar(\"Hi-There\") <b>---></b> \"HHii--TThheerree\" <br>\r\n     */','Java/Interviews',0,0,NULL,5),(4531,'\r\n    public static String starKill(String str) {\r\n        String result = \"\";\r\n        for(int i = 0; i<str.length(); i++){\r\n            if(i==0 && str.charAt(i) != \'*\')\r\n                result += str.charAt(i);\r\n            if(i>0 && str.charAt(i) != \'*\' && str.charAt((i-1)) != \'*\')\r\n                    result += str.charAt(i);\r\n            if(i>0 && str.charAt(i) == \'*\' && str.charAt((i-1)) != \'*\')\r\n                result += str.substring(0, result.length() -1);\r\n        }\r\n        return result;\r\n    }','    Return a version of the given string, where for every star (*) \r\n    in the string the star and the chars immediately to its left and right are gone. \r\n    So \"ab*cd\" yields \"ad\" and \"ab**cd\" also yields \"ad\". 	<br>\r\n    <br>\r\n\r\n     * <b>EXPECTATIONS:</b><br>\r\n            starKill(\"cd*zq\")  <b>---></b>\"cq\"<br>\r\n            starKill(\"ab**cd\")    <b>---></b> \"ad\" <br>\r\n            starKill(\"wacy*xko\") <b>---></b> \"wacko\" <br>','Java/Interviews',0,0,NULL,5),(4532,'    public static int matchingChar(String[] a, String[] b) {\r\n        int count = 0; \r\n        for(int i = 0; i<a.length; i++){\r\n            if((a[i].length() >0 && b[i].length() > 0) && (a[i].charAt(0) == b[i].charAt(0))){\r\n                count++;\r\n            }\r\n        }\r\n        return count;\r\n    }','Given 2 arrays that are the same length containing strings, compare the 1st string in one array \r\n    to the 1st string in the other array, the 2nd to the 2nd and so on. \r\n    Count the number of times that the 2 strings are non-empty and start with the same char. \r\n    The strings may be any length, including 0. 	\r\n    <br>\r\n    <br>\r\n\r\n     * <b>EXPECTATIONS:</b><br>\r\n            matchingChar({\"aa\", \"bb\", \"cc\"}, {\"aaa\", \"xx\", \"bb\"})  <b>---></b> 1<br>\r\n            matchingChar({\"aa\", \"bb\", \"cc\"}, {\"aaa\", \"b\", \"bb\"}) <b>---></b> 2 <br>\r\n            matchingChar({\"aa\", \"bb\", \"cc\"}, {\"\", \"\", \"ccc\"}) <b>---></b> 1 <br>\r\n     */','Java/Interviews',0,0,NULL,5),(4533,'Algorithims hello\r\nalgorithims.Hello$1@4c873330\r\n\r\nthe anonymous inner class in Hello trys to use this, not realizing that there this will refer to the anonomyous this. In order to use the this intended do this:\r\n\r\n  System.out.print( Hello.this.toString();\r\n\r\nLambdas however are Lexically scoped,  meaning that a lambda recognizes the immediate environment around its definition as the next outermost scope','public class Algorithims {\r\n    private Runnable rlambda = () -> System.out.println(this.toString());\r\n    \r\n    public static void main(String[] args) {\r\n        Algorithims a = new Algorithims();\r\n        a.rlambda.run();\r\n        Hello h = new Hello();\r\n        h.rHello.run();\r\n    }\r\n    \r\n    public String toString(){\r\n        return \"Algorithims hello\";\r\n    }\r\n}\r\n\r\nclass Hello {\r\n    public Runnable rHello = new Runnable() {\r\n        public void run(){\r\n            System.out.println(this.toString());\r\n        }\r\n    };\r\n            \r\n    public String toString(){\r\n        return \"Hello String\";\r\n    }\r\n}\r\n','Java8/Lambdas',0,0,NULL,5),(4534,'Algorithims hello\r\nHello String','class Hello {\r\n    public Runnable rHello = () -> System.out.println(this.toString());\r\n            \r\n    public String toString(){\r\n        return \"Hello String\";\r\n    }\r\n}\r\n\r\npublic class Algorithims {\r\n    private Runnable rlambda = () -> System.out.println(this.toString());\r\n    \r\n    public static void main(String[] args) {\r\n        Algorithims a = new Algorithims();\r\n        a.rlambda.run();\r\n        Hello h = new Hello();\r\n        h.rHello.run();\r\n    }\r\n    \r\n    public String toString(){\r\n        return \"Algorithims hello\";\r\n    }\r\n}','Java8/Lambdas',0,0,NULL,5),(4535,'(2,2)\r\n0\r\ntrue\r\n1','class Point {\r\n    int x, y, useCount;\r\n    Point(int x, int y) { this.x = x; this.y = y; }\r\n    static final Point origin = new Point(0, 0);\r\n}\r\nclass Test {\r\n    public static void main(String[] args) {\r\n        Point p = new Point(1,1);\r\n        Point q = new Point(2,2);\r\n        p.x = 3;\r\n        p.y = 3;\r\n        p.useCount++;\r\n        p.origin.useCount++;\r\n        System.out.println(\"(\" + q.x + \",\" + q.y + \")\");\r\n        System.out.println(q.useCount);\r\n        System.out.println(q.origin == Point.origin);\r\n        System.out.println(q.origin.useCount);\r\n    }\r\n}','Java/OOP',0,0,NULL,5),(4536,'4.7 2','class Point {\r\n    static int x = 2;\r\n}\r\nclass Test extends Point {\r\n    static double x = 4.7;\r\n    public static void main(String[] args) {\r\n        new Test().printX();\r\n    }\r\n    void printX() {\r\n        System.out.println(x + \" \" + super.x);\r\n    }\r\n}','Java/OOP',0,0,NULL,5),(4537,'WNC\r\nincompatible types moring greeting is not a functional interface. ','public interface MoringGreeting {\r\n    public String greet(String s);\r\n    public void sleepin();\r\n}\r\n\r\npublic class Algorithims {\r\n    private Runnable rlambda = () -> System.out.println(this.toString());\r\n    private MoringGreeting gm = (str) -> \"sleep in\";\r\n    \r\n    public static void main(String[] args) {\r\n        \r\n    }','Java/Lambdas',0,0,NULL,5),(4538,'HelloShrutti','public static void main(String[] args) {\r\n       StringBuilder message = new StringBuilder();\r\n       Runnable rlambda = () -> System.out.println(message);\r\n       message.append(\"Hello\");\r\n       message.append(\"Shrutti\");\r\n       rlambda.run();\r\n    }','Java8/Lambdas',0,0,NULL,5),(4539,'Save the comparators as static members of the Person class:\r\n\r\nclass Person {\r\n  public String firstName;\r\n  public String lastName;\r\n  public int age;\r\n\r\n  public final static Comparator<Person> compareFirstName =\r\n    (lhs, rhs) -> lhs.firstName.compareTo(rhs.firstName);\r\n\r\n  public final static Comparator<Person> compareLastName =\r\n    (lhs, rhs) -> lhs.lastName.compareTo(rhs.lastName);\r\n\r\n  public Person(String f, String l, int a) {\r\n    firstName = f; lastName = l; age = a;\r\n  }\r\n\r\n  public String toString() {\r\n    return \"[Person: firstName:\" + firstName + \" \" +\r\n      \"lastName:\" + lastName + \" \" +\r\n      \"age:\" + age + \"]\";\r\n  }\r\n} \r\n\r\nThen they can referenced more easily and you don\'t have to repeat yourself(DRY):\r\n\r\n public static void main(String... args) {\r\n    Person[] people = . . .;\r\n\r\n    // Sort by first name\r\n    Arrays.sort(people, Person.compareFirstName);\r\n    for (Person p : people)\r\n      System.out.println(p);\r\n  } ','public static void main(String... args) {\r\n    Person[] people = new Person[] {\r\n      new Person(\"Ted\", \"Neward\", 41),\r\n      new Person(\"Charlotte\", \"Neward\", 41),\r\n      new Person(\"Michael\", \"Neward\", 19),\r\n      new Person(\"Matthew\", \"Neward\", 13)\r\n    };\r\n    // Sort by first name\r\n    Arrays.sort(people, \r\n      (lhs, rhs) -> lhs.firstName.compareTo(rhs.firstName));\r\n    for (Person p : people)\r\n      System.out.println(p);\r\n  } \r\n\r\n\r\nhow could you refactor this to use a more functional style ? ','Java8/Lambdas',0,0,NULL,5),(4540,'Arrays.sort(people, Person::compareFirstNames);\r\n\r\nThe :: operator basically just tells the compiler that compareFirstNames should be used there instead of a method literal. ','class Person {\r\n  public String firstName;\r\n  public String lastName;\r\n  public int age;\r\n\r\n  public static int compareFirstNames(Person lhs, Person rhs) {\r\n    return lhs.firstName.compareTo(rhs.firstName);\r\n  }\r\n\r\n  // ...\r\n}\r\n\r\n  public static void main(String... args) {\r\n    Person[] people = . . .;\r\n    // Sort by first name\r\n    // < here >\r\n    for (Person p : people)\r\n      System.out.println(p);\r\n  } \r\n\r\nwhat can you put here to sort the people array using Person\'s compareFirstNames method ? Call it using the :: operator. ','Java8/Lambdas',0,0,NULL,5),(4541,'The compiler uses type inference here to implement the lambda as a comparator',' public static void main(String[] args) {\r\n         Person[] people = new Person[] {\r\n      new Person(\"Ted\", \"Neward\", 41),\r\n      new Person(\"Charlotte\", \"Neward\", 41),\r\n      new Person(\"Michael\", \"Neward\", 19),\r\n      new Person(\"Matthew\", \"Neward\", 13)\r\n    };\r\n         \r\n       Arrays.sort(people, (lhs,rhs) -> lhs.firstName.compareTo(rhs.firstName));\r\n}\r\n\r\nclass Person {\r\n    public String firstName;\r\n    public String lastName;\r\n    public int age;\r\n    \r\n    public Person(String fn, String ln, int a){\r\n        firstName = fn;\r\n        lastName = ln;\r\n        age = a;\r\n    }\r\n}','Java8/Lambdas',0,0,NULL,5),(4542,'compareFirstNames would have to be a static member of the Person class:\r\n\r\npublic final static Comparator<Person> compareFirstName =\r\n    (lhs, rhs) -> lhs.firstName.compareTo(rhs.firstName);\r\n\r\n.. above comparefirstnames is implemented as a method, then :: is used so using :: basically cuts out the middle man for the sorting operation. ','    public static void main(String[] args) {\r\n         Person[] people = new Person[] {\r\n      new Person(\"Ted\", \"Neward\", 41),\r\n      new Person(\"Charlotte\", \"Neward\", 41),\r\n      new Person(\"Michael\", \"Neward\", 19),\r\n      new Person(\"Matthew\", \"Neward\", 13)\r\n    };\r\n         \r\n       Arrays.sort(people,Person::compareFirstNames);\r\n    }\r\n\r\nclass Person {\r\n    public String firstName;\r\n    public String lastName;\r\n    public int age;\r\n    \r\n    public Person(String fn, String ln, int a){\r\n        firstName = fn;\r\n        lastName = ln;\r\n        age = a;\r\n    }\r\n    public static int compareFirstNames(Person lhs, Person rhs){\r\n        return lhs.firstName.compareTo(rhs.firstName);\r\n    }\r\n}\r\n\r\nHow would this be done without the :: operator ? ','Java8/Lambdas',0,0,NULL,5),(4543,'','class Person {\r\n  public String firstName;\r\n  public String lastName;\r\n  public int age;\r\n\r\n  public static int compareFirstNames(Person lhs, Person rhs) {\r\n    return lhs.firstName.compareTo(rhs.firstName);\r\n  }\r\n\r\n  // ...\r\n}\r\n\r\n  public static void main(String... args) {\r\n    Person[] people = . . .;\r\n    // Sort by first name\r\n    Arrays.sort(people, Person::compareFirstNames);\r\n    for (Person p : people)\r\n      System.out.println(p);\r\n  } \r\n\r\nAnother way to do this, for those who are curious, would be to use the compareFirstNamest method to create a Comparator<Person> instance, like this:\r\n\r\nComparator cf =    Person::compareFirstNames; \r\n\r\nAnd, just to be even more succinct, we could avoid some of the syntactic overhead entirely by making use of some of the new library features to write the following, which makes use of a higher-order function (meaning, roughly, a function that passes around functions) to essentially avoid all of the previous code in favor of a one-line in-place usage:\r\n\r\nArrays.sort(people, comparing(\r\n  Person::getFirstName));\r\n\r\nThis, in part, is why lambdas, and the functional programming techniques that come with them, are so powerful.','Java8/Lambdas',0,0,NULL,5),(4544,'public static int longestStreak2(String str){\r\n           int max = 0; \r\n           for(int i =0; i < str.length(); i++){\r\n               int count = 0;\r\n               for(int j = i; j<str.length(); j++){\r\n                   \r\n                   if(str.charAt(i) == str.charAt(j)){\r\n                       count++;\r\n                   }else\r\n                       break;\r\n               }\r\n               if(count > max){\r\n                   max = count;\r\n               }\r\n           }\r\n           return max;\r\n       }\r\n\r\n\r\n----------------------------------\r\n\r\n       public static int longestStreak(String str) {\r\n           int streakcount = 1;\r\n           int streakhigh = 1;\r\n           char last;\r\n           char next;\r\n           if(str.length()>1){\r\n               \r\n            \r\n            for(int i =1; i < str.length(); i++){\r\n                int x =i;\r\n                x--;\r\n                \r\n                next = str.charAt(i);\r\n                last = str.charAt(x);\r\n                \r\n                if(next == last){\r\n                    streakcount++;\r\n                }else{\r\n                    streakcount = 1;\r\n                }\r\n                if(streakcount > streakhigh){\r\n                    streakhigh = streakcount;\r\n                }\r\n            }\r\n            \r\n           }\r\n           return streakhigh;\r\n       }','Given a string, return the length of the longest streak of the same chars in the string. \r\n\r\n       <br>\r\n       <br>\r\n\r\n        EXPECTATIONS:\r\n\r\n               longestStreak(\"hayyeu\") <b>---></b> 2<br>\r\n               longestStreak(\"XPNzzzddOOOxx\")  <b>---></b> 3 <br>\r\n               longestStreak(\"\")  <b>---></b> 0 <br>\r\n        \r\n2 ways','Java/Algorithims',0,0,NULL,5),(4545,'for(int i = 0; i < A.length; i++){\r\n   for(int j = (A.length - 1); j > i; j--){\r\n      if(A[j] < A[j - 1]){\r\n         int temp = A[j];\r\n          A[j] = A[j - 1];\r\n          A[j-1] = temp;\r\n      }\r\n   }\r\n}\r\n\r\n\r\nthink of it as a for loop from the start and a for loop from the end and an in if in the middle to swap. ','Implement a bubble sort','Java/Algorithims',0,1,NULL,5),(4546,'1. Abstract classes cannot be instantiated directly.\r\n2. Abstract classes may be defined with any number, including zero, of abstract and non-\r\nabstract methods.\r\n3. Abstract classes may not be marked as private or final .\r\n4. An abstract class that extends another abstract class inherits all of its abstract methods\r\nas its own abstract methods.\r\n5. The first concrete class that extends an abstract class must provide an implementation\r\nfor all of the inherited abstract methods.','Abstract Class definition rules: ','Java8/ClassDesign',0,0,NULL,5),(4547,'1.\r\nAbstract methods may only be defined in abstract classes.\r\n2. Abstract methods may not be declared private or final .\r\n3. Abstract methods must not provide a method body/implementation in the abstract\r\nclass for which is it declared.\r\n4. Implementing an abstract method in a subclass follows the same rules for overriding a\r\nmethod. For example, the name and signature must be the same, and the visibility of\r\nthe method in the subclass must be at least as accessible as the method in the parent\r\nclas','Abstract Method definition rules:','Java/Algorithims',0,1,NULL,5),(4548,'implicitly public static and final','Inteface variables are: ','Java8/ClassDesign',0,0,NULL,5),(4549,'this is ok, interface methods define a behavior','public class Bear implements Herbivore, Omnivore {\r\n  public void eatMeat() {\r\n    System.out.println(\"Eating meat\");\r\n }\r\n public void eatPlants() {\r\n    System.out.println(\"Eating plants\");\r\n }\r\n}\r\n\r\npublic interface Herbivore {\r\n   public void eatPlants();\r\n}\r\n\r\npublic interface Omnivore {\r\n   public void eatPlants();\r\n   public void eatMeat();\r\n}','Java8/ClassDesign',0,0,NULL,5),(4550,'wnc','public interface Herbivore {\r\n  public int eatPlants();\r\n}\r\n\r\npublic interface Omnivore {\r\n  public void eatPlants();\r\n}\r\n\r\npublic class Bear implements Herbivore, Omnivore {\r\n   public int eatPlants() { \r\n     System.out.println(\"Eating plants: 10\");\r\n     return 10;\r\n}\r\n  public void eatPlants() { \r\n    System.out.println(\"Eating plants\");\r\n  }\r\n}','Java8/ClassDesign',0,0,NULL,5),(4551,'WNC you can implement two confilicting interfaces but not extend them. ','public interface Herbivore {\r\npublic int eatPlants();\r\n}\r\npublic interface Omnivore {\r\npublic void eatPlants();\r\n}\r\npublic interface Supervore extends Herbivore, Omnivore {} \r\npublic abstract class AbstractBear implements Herbivore, Omnivore {}\r\n','Java8/ClassDesign',0,0,NULL,5),(4552,'default method rules: \r\n\r\n1. A default method may only be declared within an interface and not within a class or\r\nabstract class.\r\n2. A default method must be marked with the default keyword. If a method is marked as\r\ndefault , it must provide a method body.\r\n3. A default method is not assumed to be static , final , or abstract , as it may be used\r\nor overridden by a class that implements the interface.276\r\n4.\r\nChapter 5\r\n?\r\nClass Design\r\nLike all methods in an interface, a default method is assumed to be public and will not\r\ncompile if marked as private or protected .','public interface IsWarmBlooded {\r\n   boolean hasScales();\r\n\r\n   public default double getTemperature() {\r\n      return 10.0;\r\n   }\r\n}','Java8/ClassDesign',0,0,NULL,5),(4553,'1. A default method may only be declared within an interface and not within a class or\r\nabstract class.\r\n2. A default method must be marked with the default keyword. If a method is marked as\r\ndefault , it must provide a method body.\r\n3. A default method is not assumed to be static , final , or abstract , as it may be used\r\nor overridden by a class that implements the interface.276\r\n4.\r\nChapter 5\r\n?\r\nClass Design\r\nLike all methods in an interface, a default method is assumed to be public and will not\r\ncompile if marked as private or protected .','default method rules: ','Java8/ClassDesign',0,0,NULL,5),(4554,'WNC default methods can only be used in interfaces; ','abstract class Drink {\r\n\r\npublic default double curdle(){\r\n      retrurn \"32\";\r\n}\r\n\r\n}','Java8/ClassDesign',0,0,NULL,5),(4555,'WNC','public interface Carnivore {\r\n   public default void eatMeat(); \r\n   public int getRequiredFoodAmount() { \r\n       return 13;\r\n   }\r\n}','Java8/ClassDesign',0,0,NULL,5),(4556,'WNC, default methods cannot be static;','public interface Drinker {\r\n   public static final int legalLimit = .8;\r\n   \r\n   public static default stumbleHome(){\r\n      sout(\" hope he makes it \");\r\n\r\n  void vomit();\r\n}','Java8/ClassDesign',0,0,NULL,5),(4557,'doFinsHaveScales() does not compile:\r\n\r\nyou have to two choices when overriding a default method, override it and make it abstract again the way getLongestFinLength() correctly does,\r\n\r\nOr\r\n\r\noverride it with a new method body as doFinsHaveScales() trys to do. The problem there is that doFinsHaveScales() is missing the default keyword. \r\n','public interface hasFins {\r\n  public default int getNumberOfFins(){\r\n     return 4;\r\n  }\r\n\r\n  public default double getLongestFinLength() {\r\n    return 20.0;\r\n  }\r\n\r\n public default boolean doFinsHAveScales() {\r\n    return true;\r\n }\r\n}\r\n\r\n\r\npublic interface SharkFamily extends HasFins {\r\n  public default int getNumberOfFins() {\r\n     return 8;\r\n  }\r\n  public double getLongestFinLength();\r\n  public boolean doFinsHaveScales() {\r\n      return false; \r\n  }\r\n}','Java8/ClassDesign',0,0,NULL,5),(4558,'test','test','test',0,0,NULL,5),(4559,' public static int yoYo(String str) {\r\n        if(str.length() < 2)\r\n            return 0;\r\n        if(str.substring(0,2).equals(\"yo\"))\r\n            return 1 + yoYo(str.substring(1));\r\n        else \r\n            return yoYo(str.substring(1));\r\n    }',' /**\r\n    * \r\n   Given a string, compute recursively (no loops) the number of times \r\n           lowercase \"yo\" appears in the string.\r\n   <br>\r\n   <br>\r\n\r\n    * <b>EXPECTATIONS:</b><br>\r\n           yoYo(\"xhyoxx\") <b>---></b> 1<br>\r\n           yoYo(\"nyonnyon\")<b>---></b> 2 <br>\r\n           yoYo(\"yo\")  <b>---></b> 1 <br>\r\n    */\r\n\r\nUse recursion','Java/Interviews/recursion',0,0,NULL,5),(4560,'    public static Double[] FindMaxCrossingSubarray(Double[] A, double low, Double mid, double high) {\r\n        //Integer[] A = {5,2,4,6,1,3,9};\r\n        double leftsum = Double.NEGATIVE_INFINITY;\r\n        double sum = 0;\r\n        double maxleft = 0;\r\n        for (int i = mid.intValue(); i >= low; i--) {\r\n            sum = sum + A[i];\r\n            if (sum > leftsum) {\r\n                leftsum = sum;\r\n                maxleft = i;\r\n            }\r\n        }\r\n\r\n        double rightsum = Double.NEGATIVE_INFINITY;\r\n        sum = 0;\r\n        double maxright = 0;\r\n        for (int j = mid.intValue() + 1; j <= high; j++) {\r\n            sum = sum + A[j];\r\n            if (sum > rightsum) {\r\n                rightsum = sum;\r\n                maxright = j;\r\n            }\r\n        }\r\n\r\n        sum = leftsum + rightsum;\r\n        double endsum = sum;\r\n\r\n        return new Double[]{maxleft, maxright, endsum};\r\n    }','Write out the FindMaxCrossingSubarray algo:','Java/Interviews/recursion',0,0,NULL,5),(4561,'    public Double[] FindMaxSubarray(Double[] A, Double low, Double high){\r\n        if(high.equals(low)){\r\n            return new Double[]{low,high,A[low.intValue()]};\r\n        }\r\n        else{ \r\n            Double mid = Math.floor((low+high)/2);\r\n            Double[] leftsub = FindMaxSubarray(A,low,mid);\r\n            Double[] rightsub = FindMaxSubarray(A,mid+1,high);\r\n            Double[] cross = FindMaxCrossingSubarray(A,low,mid,high);\r\n            if(leftsub[2] >= rightsub[2] && leftsub[2] >= cross[2]){\r\n                return leftsub;\r\n            } else if(rightsub[2] >= leftsub[2] && rightsub[2] >= cross[2]){\r\n                return rightsub;\r\n            }else\r\n                return cross;\r\n        }\r\n        \r\n    }','Write out the FindMaxSubarray, you might also need the FindMaxCrossingSubarray','Java/Interviews/recursion',0,0,NULL,5),(4562,'public static Integer[] InserstionSort(Integer[] A) {\r\n        for (int j = 1; A.length > j; j++) {\r\n            int key = A[j]; //key is second element\r\n            //insert A[j] into the sorted sequence A[1..j-1]\r\n            int i = j - 1; // i is first element\r\n            while (i >= 0 && A[i] > key) {\r\n                A[i + 1] = A[i];\r\n                i = i - 1;\r\n            }\r\n            A[i + 1] = key;\r\n        }\r\n\r\n        System.out.println(\"Array after: \");\r\n        for (int a : A) {\r\n            System.out.println(a);\r\n        }\r\n\r\n        return A;\r\n    }','Insertion sort:','Java/Algorithims',0,0,NULL,5),(4563,'    public static int yoYo(String str) {\r\n        if (str.length() < 2) {\r\n            return 0;\r\n        }\r\n        if (str.substring(0, 2).equals(\"yo\")) {\r\n            return 1 + yoYo(str.substring(1));\r\n        } else {\r\n            return yoYo(str.substring(1));\r\n        }\r\n    }','Recursively search a string for the appearance of \"yo\"','Java/Algorithims',1,0,NULL,5),(4564,'\n        String result = str;\n        if (str.length() <= 3) {\n            return result;\n        }\n\n        if ((str.length() % 2) != 0) {\n            int x = (str.length() - 1) / 2;\n            x--;\n            int y = x + 3;\n            result = result.substring(x, y);\n        }\n        return result;\n    \n//-----------------------------------------------\n\n        String result = str;\n        \n        if(str.length() >= 3){\n            int midx = str.length()/2;\n            result = str.substring(midx-1,midx+2);\n        }\n        \n        return result;','Given a string of odd length, return the middle 3 characters from the string, so the string \"Monitor\" yields \"nit\". If the\n  string length is less than 3, return the string as is. \n        \n           EXPECTATIONS:\n         middleThree(\"bunny\")  \"unn\" \n         middleThree(\"peter\")  \"ete\" \n         middleThree(\"Jamaica\")\"mai\" \n         ','Java/Algorithims',0,0,NULL,5),(4565,'public Integer[] bruteForceFindMaxSubarray(Integer[] A){\r\n        int left = 0;\r\n        int right = 0;\r\n        int max = 0;\r\n        for(int i = 0; i<A.length; i++){\r\n            int tempsum = 0;\r\n            int sum = 0;\r\n            for(int j = i; j < A.length; j++){\r\n                tempsum += A[j];\r\n                if(tempsum > sum){\r\n                    sum = tempsum;\r\n                    left = i;\r\n                    right = j;\r\n                }\r\n            }\r\n            if(sum > max){\r\n                max = sum;\r\n            }\r\n        }\r\n        \r\n        return new Integer[]{left,right,max};\r\n    }','Brute Force version of Max Subarray solution:','Java/Algorithims',0,1,NULL,5),(4566,'Consumer<? super T>','Collection<E>.forEach(  // ? // ); what does it take ?','Java8/Collections',0,0,NULL,5),(4567,'','NumericTest t = (n) -> return (n > 50);\r\n\r\nwhat\'s wrong with this lambda ? ','Java8/L',0,0,NULL,5),(4568,'take out the return, the statement itself can be returned. ','NumericTest t = (n) -> return (n > 50);\r\n\r\nWhat\'s wrong with this lambda ?','Java8/Lambdas',0,0,NULL,5),(4569,'    public static void main(String[] args) {\r\n       NumericTest t = (int n) -> (n > 50);\r\n        \r\n       List<Integer> numlist = new ArrayList<Integer>();\r\n       numlist.stream().forEach((n) -> {\r\n           t.runTest(n);\r\n        });\r\n    }','    public static void main(String[] args) {\r\n       NumericTest t = (int n) -> (n > 50);\r\n        \r\n       List<Integer> numlist = new ArrayList<Integer>();\r\n       for(Integer n : numlist){\r\n           t.runTest(n);\r\n       }\r\n    }\r\n\r\nturn this into a functional operation','Java8/Lambdas',0,0,NULL,5),(4570,'','public interface Stream<T> {\r\n\r\n    Stream<T> filter(Predicate<? super T> predicate);\r\n\r\n    <R> Stream<R> map(Mapper<? extends R, ? super T> mapper);\r\n\r\n    <R> Stream<R> flatMap(FlatMapper<? extends R, ? super T> mapper);\r\n\r\n    Stream<T> uniqueElements();\r\n\r\n    Stream<T> sorted(Comparator<? super T> comparator);\r\n\r\n    Stream<T> cumulate(BinaryOperator<T> operator);\r\n\r\n    void forEach(Block<? super T> block);\r\n\r\n    Stream<T> tee(Block<? super T> block);\r\n\r\n    Stream<T> limit(int n);\r\n    Stream<T> skip(int n);\r\n\r\n    <A extends Destination<? super T>> A into(A target);\r\n\r\n    Object[] toArray();\r\n\r\n    <U> Map<U, Collection<T>> groupBy(Mapper<? extends U, ? super T> classifier);\r\n\r\n    <U, W> Map<U, W> reduceBy(Mapper<? extends U, ? super T> classifier,\r\n                              Factory<W> baseFactory,\r\n                              Combiner<W, W, T> reducer);\r\n\r\n    T reduce(T base, BinaryOperator<T> op);\r\n\r\n    Optional<T> reduce(BinaryOperator<T> op);\r\n\r\n    <U> U fold(Factory<U> baseFactory,\r\n               Combiner<U, U, T> reducer,\r\n               BinaryOperator<U> combiner);\r\n\r\n    boolean anyMatch(Predicate<? super T> predicate);\r\n    boolean allMatch(Predicate<? super T> predicate);\r\n    boolean noneMatch(Predicate<? super T> predicate);\r\n\r\n    Optional<T> findFirst();\r\n    Optional<T> findAny();\r\n\r\n    Stream<T> sequential();\r\n    Stream<T> unordered();\r\n}','Java8/Streams',0,0,NULL,5),(4571,'WNC static interface methods are not inherited, \r\nThey are accessed via the interface name like static methods in classes:\r\n\r\n  Hoppable.getjumpheight();','public interface Hoppable {\r\n   static int getjumpheight(){\r\n     return 8;\r\n   }\r\n}\r\n\r\npublic class bunny implements Hoppable {\r\n   public void printDetails(){\r\n    sout(  getjumpheight() );\r\n   }\r\n}','Java8/ClassDesign',0,0,NULL,5),(4572,'the first would print but the second would not compile, static interface methods are not inherited so they cannot be accessed without their interface name first \r\n\r\nMoringGreeting.test()\r\n\r\nor \r\nnumerictest.test()','public class Algorithims implements MoringGreeting,NumericTest {\r\n\r\n    public static void main(String[] args) {\r\n            Algorithims a = new Algorithims();\r\n        if(a.test(4))\r\n            System.out.println(\"BAR\");\r\n        if(test(4))\r\n            System.out.println(\"HELP HELP\");\r\n    }\r\n\r\n  public boolean test(int x){\r\n        return true;\r\n    }\r\n}\r\n\r\npublic interface MoringGreeting {\r\n    public static boolean test(String s){\r\n        return false;\r\n    }\r\n}\r\n\r\npublic interface NumericTest {\r\n    int testcount = 0;\r\n    public static boolean test(int n){\r\n        return true;\r\n    }\r\n\r\n}','Java8/ClassDesign',0,0,NULL,5),(4573,'In Java, all objects are accessed by reference, so as a developer you never have direct access\r\nto the object itself. Conceptually, though, you should consider the object as the entity that\r\nexists in memory, allocated by the Java runtime environment. Regardless of the type of the\r\nreference you have for the object in memory, the object itself doesn’t change. For example,\r\nsince all objects inherit java.lang.Object , they can all be reassigned to java.lang.Object ,\r\nas shown in the following example:\r\nLemur lemur = new Lemur();\r\nObject lemurAsObject = lemur;\r\nEven though the Lemur object has been assigned a reference with a different type, the\r\nobject itself has not changed and still exists as a Lemur object in memory. What has changed,\r\nthen, is our ability to access methods within the Lemur class with the lemurAsObject refer-\r\nence. Without an explicit cast back to Lemur , as you’ll see in the next section, we no longer\r\nhave access to the Lemur properties of the object.','The type of the object determines which properties exist within the object in memory.\r\n\r\nThe type of the reference to the object determines which methods and variables are\r\naccessible to the Java program.','Java8/ClassDesign',0,0,NULL,5),(4574,'ht.age will not compile','public class Primate {\r\n    public int age;\r\n    \r\n    public boolean hasHair(){\r\n        return true;\r\n    }\r\n    \r\n}\r\n\r\npublic interface HasTail {\r\n    public boolean isTailStriped();\r\n}\r\n\r\npublic class Lemur extends Primate implements HasTail {\r\n    public boolean isTailStriped() {\r\n        return false;\r\n    }\r\n    public int age = 10;\r\n    public static void main(String[] args) {\r\n        Lemur lemur = new Lemur();\r\n        System.out.println(lemur.age);\r\n        HasTail hasTail = lemur;\r\n        System.out.println(hasTail.isTailStriped());\r\n        Primate primate = lemur;\r\n        System.out.println(primate.hasHair());\r\n\r\n        HasTail ht = lemur;\r\n        System.out.println(ht.age);\r\n    }\r\n}','Java8/ClassDesign',0,0,NULL,5),(4575,'the last assignement will not compile, needs a cast\r\n\r\nLemur lem2 = (Lemur) prim;','public class Primate {\r\n    public int age;\r\n    \r\n    public boolean hasHair(){\r\n        return true;\r\n    }\r\n    \r\n}\r\n\r\npublic interface HasTail {\r\n    public boolean isTailStriped();\r\n}\r\n\r\npublic class Lemur extends Primate implements HasTail {\r\n    public boolean isTailStriped() {\r\n        return false;\r\n    }\r\n    public int age = 10;\r\n    public static void main(String[] args) {\r\n        Lemur lemur = new Lemur();\r\n        System.out.println(lemur.age);\r\n        HasTail hasTail = lemur;\r\n        System.out.println(hasTail.isTailStriped());\r\n        Primate primate = lemur;\r\n        System.out.println(primate.hasHair());\r\n\r\n        Primate prim = lemur;\r\n        Lemur lem2 = prim;\r\n\r\n    }\r\n}','Java8/ClassDesign',0,0,NULL,5),(4576,'the birds name is peacock','public class Bird {\r\n   public String getName() {\r\n   return \"Unknown\";\r\n }\r\n public void displayInformation() {\r\n   System.out.println(\"The bird name is: \"+getName());\r\n  }\r\n}\r\npublic class Peacock extends Bird {\r\n   public String getName() {\r\n      return \"Peacock\";\r\n   }\r\n\r\n   public static void main(String[] args) {  \r\n      Bird bird = new Peacock();\r\n       bird.displayInformation();\r\n     }\r\n}','Java8/ClassDesign',0,0,NULL,5),(4577,'LEMURRR','public class Primate {\r\n    public int age;\r\n    \r\n    public boolean hasHair(){\r\n        return true;\r\n    }\r\n    \r\n    public void makeCall(){\r\n        System.out.println(\"generic primate grunting\");\r\n    }\r\n    \r\n}\r\n\r\n\r\n\r\n\r\npublic class Lemur extends Primate implements HasTail {\r\n    public boolean isTailStriped() {\r\n        return false;\r\n    }\r\n    public int age = 10;\r\n    \r\n    public void makeCall(){\r\n        System.out.println(\"LEMURRRR\");\r\n    }\r\n    public static void main(String[] args) {\r\n        Primate p1 = new Lemur();\r\n        p1.makeCall();\r\n        \r\n    }\r\n}','Java8/ClassDesign',0,0,NULL,5),(4578,'public static String endoo(String str) {\r\n        if(str.equals(\"\")){\r\n            return str;\r\n        }\r\n        \r\n        if(str.charAt(0) == \'o\'){\r\n            return endoo(str.substring(1)) + \'o\';\r\n        }\r\n        \r\n        else\r\n            return str.charAt(0) + endoo(str.substring(1));\r\n        \r\n    }','    Given a string, compute recursively a new string where all the \r\n            lowercase \'o\' chars have been moved to the end of the string.\r\n\r\n     EXPECTATIONS:\r\n            endoo(\"oore\") <b>---></b> reoo<br>\r\n            endoo(\"oohoi\") <b>---></b> hiooo <br>\r\n            endoo(\"oanotgo\") <b>---></b> antgooo <br>\r\n     ','Java/Interviews/recursion',0,0,NULL,5),(4579,'false, they are not','Batch Apex,\r\nIf one batch transaction fails all other batches are rolled back. ','Salesforce/PD2',0,0,NULL,5),(4580,'false, each transaction starts a new set of governor limits. ','Though all batch transactions are are executed seperatley they all must confirm to the one set of governor limits. ','Salesforce/PD2',0,0,NULL,5),(4581,'Intstantiate the class then, execute it using Database.executeBatch(mybatchclass)\r\nthis execution returns a batchId','How do you execute an Apex Batch Class? What does it\'s execution return ?','Salesforce/PD2',0,0,NULL,5),(4582,'Id batchId = Database.executeBatch(myBatchObject, 100);\r\n\r\nthe second parameter is the scope param.','How can you limit the number of records being passed into the execute method ?','Salesforce/PD2',0,0,NULL,5),(4583,'an AsyncApexJob record is created, you can query for those like this: \r\n\r\nAsyncApexJob job = [SELECT Id, Status, JobItemsProcessed, TotalJobItems, NumberOfErrors FROM AsyncApexJob WHERE ID = :batchId ];','What happens when you create an new batch execution ?','Salesforce/PD2',0,0,NULL,5),(4584,'A developer could create an Archiver that goes through a list of  thousands of records and adds them to an archive on a nightly basis. \r\n\r\nOr a developer could create a data cleansing operation that goes through Accounts and Contacts on a nightly basis and updates them if necesary on a nightly basis. ','Name two possible uses of Batch Apex:','Salesforce/PD2',0,0,NULL,5),(4585,'','Use extreme care if you are planning to invoke a batch job from a trigger. You must be able to guarantee that the trigger does not add more batch jobs than the limit. In particular, consider API bulk updates, import wizards, mass record changes through the user interface, and all cases where more than one record can be updated at a time.','Salesforce/PD2',0,0,NULL,5),(4586,'When you\'re using a simple query to collect the records to be passed to the execute class use the queryLocator, in this case the Governor limits will be bypassed!\r\n\r\nUse the iterable to create a complex scope for the batch job. You can also use the iterable to create your own custom process for iterating through the list. See next question\r\n','When should you use a QueryLocator and when should you use an Iterable in the start method of an Apex Batch Class ?','Salesforce/PD2',0,0,NULL,5),(4587,'The most common use case I have seen is when you need to batch over an aggregate query. It\'s the only time I\'ve needed to adopt this approach, anyway. The walkthrough has a pretty thorough example. The fun part is, you can implement all the related interfaces on the same class.\r\n\r\npublic class MyBatch implements Database.Batchable<AggregateResult>, Iterable<AggregateResult>, Iterator<AggregateResult>, Schedulable\r\n{\r\n    Integer index;\r\n    List<AggregateResult> aggregates;\r\n    public MyBatch()\r\n    {\r\n        index = 0;\r\n        aggregates = [/*query*/];\r\n    }\r\n    public void execute(SchedulableContext context)\r\n    {\r\n        Database.executeBatch(this);\r\n    }\r\n    public Iterator<AggregateResult> iterator()\r\n    {\r\n        return this;\r\n    }\r\n    public Boolean hasNext()\r\n    {\r\n        return index < aggregates.size();\r\n    }\r\n    public AggregateResult next()\r\n    {\r\n        return aggregates[index++];\r\n    }\r\n    public Iterable<AggregateResult> start(Database.BatchableContext context)\r\n    {\r\n        return this;\r\n    }\r\n    public  void  execute(Database.BatchableContext context, List<AggregateResult> scope)\r\n    {\r\n        // do stuff\r\n    }\r\n    public void finish(Database.BatchableContext context)\r\n    {\r\n        // do stuff\r\n    }\r\n}\r\n\r\n','Use the iterable to create a complex scope for the batch job. You can also use the iterable to create your own custom process for iterating through the list.','Salesforce/PD2',0,0,NULL,5),(4588,'When you need to batch over an aggregated query. \r\n\r\npublic class MyBatch implements Database.Batchable<AggregateResult>, Iterable<AggregateResult>, Iterator<AggregateResult>, Schedulable\r\n{\r\n    Integer index;\r\n    List<AggregateResult> aggregates;\r\n    public MyBatch()\r\n    {\r\n        index = 0;\r\n        aggregates = [/*query*/];\r\n    }\r\n    public void execute(SchedulableContext context)\r\n    {\r\n        Database.executeBatch(this);\r\n    }\r\n    public Iterator<AggregateResult> iterator()\r\n    {\r\n        return this;\r\n    }\r\n    public Boolean hasNext()\r\n    {\r\n        return index < aggregates.size();\r\n    }\r\n    public AggregateResult next()\r\n    {\r\n        return aggregates[index++];\r\n    }\r\n    public Iterable<AggregateResult> start(Database.BatchableContext context)\r\n    {\r\n        return this;\r\n    }\r\n    public  void  execute(Database.BatchableContext context, List<AggregateResult> scope)\r\n    {\r\n        // do stuff\r\n    }\r\n    public void finish(Database.BatchableContext context)\r\n    {\r\n        // do stuff\r\n    }\r\n}','When would you need to return an Iterable from the start method of a Database.Batchable<sObject> class ? ','Salesforce/PD2',0,0,NULL,5),(4589,'If your logic is based on rows from an SObject then the Database.QueryLocator is the way to go as that allows the batchable to query very large numbers of records.\r\n\r\nBut sometimes you may want to do some work that isn\'t directly related to SObject rows. In that case the iterable object can simply be an array/list:\r\n\r\npublic class MyBatchable implements Database.Batchable<Execution> {\r\n\r\n    private class Execution {\r\n        // Various data fields go here\r\n    }\r\n\r\n    public Execution[] start(Database.BatchableContext bc) {\r\n        Execution[] execs = new Execution[] {};\r\n        // Logic that creates and adds to the list\r\n        // Subject to normal governor limits\r\n        return execs;\r\n    }\r\n\r\n    public void execute(Database.BatchableContext bc, Execution[] execs) {\r\n        for (Execution exec : execs) {\r\n            // Do something\r\n        }\r\n    }\r\n\r\n    public void finish(Database.BatchableContext bc) {\r\n    }\r\n}','When would you want to return an Iterable from the start method of a Database.Batchable<sObject> class ? ','Salesforce/PD2',0,0,NULL,5),(4590,'return a querylocator, if you want to act on a batch of non sObject records though, use an Iterable. ','Say you only want to perform Batch execution on a set of sObject records what is the best way to implement the start method ?','Salesforce/PD2',0,0,NULL,5),(4591,'','global class RunQuery implements Database.Batchable<AggregateResult> { \r\n    \r\n    global Iterable<AggregateResult> start(Database.BatchableContext BC){ \r\n        return new AggregateResultIterable(); \r\n    } \r\n    \r\n    global void execute(Database.BatchableContext BC, List<sObject> scope){ \r\n        for(sObject s : scope){ \r\n            System.debug(\'----------\' + s); \r\n        } \r\n    } \r\n    \r\n    global void finish(Database.BatchableContext BC){ \r\n        AsyncApexJob a = \r\n            [Select Id, Status, NumberOfErrors, JobItemsProcessed,TotalJobItems,CreatedBy.Email FROM AsyncApexJob WHERE Id = :BC.getJobId()]; \r\n        System.debug(\'********: \' + a.Id); \r\n    } \r\n}','Salesforce/PD2',0,0,NULL,5),(4592,'','global class MySchedulableClass implements Schedulable{ \r\n    @ReadOnly \r\n    global void execute (SchedulableContext ctx){ \r\n        List<AggregateResult> query = [Select MIN(CreatedDate) CD from Account]; \r\n        DateTime dt; \r\n        for(AggregateResult ar : query){ \r\n            dt = (DateTime)ar.get(\'CD\'); \r\n        } \r\n        RunQuery rq = new RunQuery(dt); \r\n        Database.executeBatch(rq); \r\n    } \r\n}\r\n\r\nglobal class RunQuery implements Database.Batchable<sObject> { \r\n    global DateTime dt; \r\n    global RunQuery(DateTime dt){ \r\n        this.dt = dt; \r\n    } \r\n    global Database.QueryLocator start(Database.BatchableContext BC){ \r\n        System.debug(\'const\' + dt); \r\n        Set<DateTime> dtime = new Set<DateTime>(); \r\n        dtime.add(dt); \r\n        \r\n        DateTime createdDate; \r\n        String query; \r\n        query = \'select Id from Account where CreatedDate =: dt\'; \r\n        return Database.getQueryLocator(query); \r\n    } \r\n    \r\n    global void execute(Database.BatchableContext BC, List<sObject> scope){ \r\n        for(sObject s : scope){ \r\n            System.debug(\'----------\' + s); \r\n        } \r\n    } \r\n    global void finish(Database.BatchableContext BC){ \r\n        AsyncApexJob a = \r\n            [Select Id, Status, NumberOfErrors, JobItemsProcessed,TotalJobItems,CreatedBy.Email FROM AsyncApexJob WHERE Id = :BC.getJobId()]; \r\n        System.debug(\'********: \' + a.Id); \r\n    } \r\n}\r\n\r\n','Salesforce/PD2',0,0,NULL,5),(4593,'WNC,\r\n\r\ndefining type for global methods must be global','public class BatchShark implements Database.Batchable<Card__c>{\r\n    \r\n    global Iterable<Card__c> start(Database.BatchableContext bc){\r\n        List<Card__c> cards = [Select Id,Question__c,Answer__c,TimesRight__c,TimesWrong__c,Category__c\r\n                              From Card__c\r\n                              Where Category__c = NULL ];\r\n        System.debug(\'cards size: \'+cards.size());\r\n        \r\n    }\r\n}','Salesforce/PD2',0,0,NULL,5),(4594,'','All the methods in the Database.Batchable interface require a reference to a Database.BatchableContext object.','Salesforce/PD2',0,0,NULL,5),(4595,'','global void finish(Database.BatchableContext BC){\r\n	   // Get the ID of the AsyncApexJob representing this batch job\r\n	   // from Database.BatchableContext.\r\n	   // Query the AsyncApexJob object to retrieve the current job\'s information.\r\n	   AsyncApexJob a = [SELECT Id, Status, NumberOfErrors, JobItemsProcessed,\r\n	      TotalJobItems, CreatedBy.Email\r\n	      FROM AsyncApexJob WHERE Id =\r\n	      :BC.getJobId()];\r\n	   // Send an email to the Apex job\'s submitter notifying of job completion.\r\n	   Messaging.SingleEmailMessage mail = new Messaging.SingleEmailMessage();\r\n	   String[] toAddresses = new String[] {a.CreatedBy.Email};\r\n	   mail.setToAddresses(toAddresses);\r\n	   mail.setSubject(\'Apex Sharing Recalculation \' + a.Status);\r\n	   mail.setPlainTextBody\r\n	   (\'The batch Apex job processed \' + a.TotalJobItems +\r\n	   \' batches with \'+ a.NumberOfErrors + \' failures.\');\r\n	   Messaging.sendEmail(new Messaging.SingleEmailMessage[] { mail });\r\n	}','Salesforce/PD2',0,0,NULL,5),(4596,'should be like this: \r\n\r\nMessaging.sendEmail(new Messaging.SingleEmailMessage[]{mess});','    global void finish(Database.BatchableContext bc){\r\n        AsyncApexJob a = [Select Id, Status, NumberOfErrors, JobItemsProcessed, TotalJobItems, \r\n                          CreatedBy.Email \r\n                         From AsyncApexJob\r\n                         Where Id = :bc.getJobId()];\r\n        Messaging.SingleEmailMessage mess = new Messaging.SingleEmailMessage();\r\n        String[] toaddresses = new String[]{a.CreatedBy.Email};\r\n        mess.setToAddresses(toaddresses);\r\n        mess.setSubject(\'The cards were categorized\');\r\n        mess.setPlainTextBody(\'This many cards were categorized: \'+a.TotalJobItems\r\n                             +\'this many errors: \'+a.NumberOfErrors);\r\n        Messaging.sendEmail(mess);\r\n        \r\n    }','Salesforce/PD2',0,0,NULL,5),(4597,'return an interable from the start method to step through items more easily.','global class batchClass implements Database.batchable{\r\n	   global Iterable start(Database.BatchableContext info){\r\n	       return new CustomAccountIterable();\r\n	   }    \r\n	   global void execute(Database.BatchableContext info, List<Account> scope){\r\n	       List<Account> accsToUpdate = new List<Account>();\r\n	       for(Account a : scope){\r\n	           a.Name = \'true\';\r\n	           a.NumberOfEmployees = 70;\r\n	           accsToUpdate.add(a);\r\n	       }\r\n	       update accsToUpdate;\r\n	   }    \r\n	   global void finish(Database.BatchableContext info){    \r\n	   }\r\n	','Salesforce/PD2',0,0,NULL,5),(4598,'Id batchjobid = Database.executeBatch(MuyBatchClass);\r\n\r\nAsyncApexJob a = [Select Id, JobItemsProcessed, TotalJobItems, NumberOfErrors\r\n                                From AsyncApexJob\r\n                                Where ID = :batchjobid];\r\n\r\n','How would you go about executing a batch job, then querying for its record to find out more information ?','Salesforce/PD2',0,0,NULL,5),(4599,'public static String hyphenSplit(String str) {\r\n                //System.out.println(str);\r\n		if(str.length() < 2){\r\n                    return str;\r\n                }\r\n                \r\n                if(str.charAt(0) == str.charAt(1)){\r\n                    return str.charAt(0) + \"-\" + hyphenSplit(str.substring(1));\r\n                }else{\r\n                    return str.charAt(0) + hyphenSplit(str.substring(1));\r\n                }\r\n	\r\n	}','Given a string, compute recursively a new string where identical chars \r\nthat are adjacent in the original string are separated from each other by a \"-\".\r\n\r\n\r\n		repeatHyphen(\"hello\") <b>---></b> hel-lo<br>\r\n		repeatHyphen(\"xxyy\") <b>---></b> x-xy-y <br>\r\n		repeatHyphen(\"aaaa\") <b>---></b> a-a-a-a <br>','Java/Interviews/recursion',0,0,NULL,5),(4600,'gets field creating instructions about the usersettings, then drops the foreign key constraint, then add a new foreign key this time with the on delete cascade option','show create table usersettings \r\n\r\n| usersettings | CREATE TABLE `usersettings` (\r\n  `settingid` int(11) NOT NULL AUTO_INCREMENT,\r\n  `fk_user_id` int(11) NOT NULL,\r\n  PRIMARY KEY (`settingid`),\r\n  KEY `fk_user_id` (`fk_user_id`),\r\n  CONSTRAINT `usersettings_ibfk_1` FOREIGN KEY (`fk_user_id`) REFERENCES `flashuser` (`user_id`)\r\n\r\nalter table usersettings\r\ndrop foreign key usersettings_ibfk_1\r\n\r\nalter table usersettings\r\nadd constraint foreign key fk_user_id references flashuser(user_id) on delete cascade','sql',0,0,NULL,5),(4601,'  public static String insideBrackets(String str) {\r\n           //System.out.println(str);\r\n           if(str.charAt(0) != \'[\')\r\n               return insideBrackets(str.substring(1));\r\n           \r\n           if(str.charAt((str.length() -1)) != \']\')\r\n               return insideBrackets(str.substring(0,str.length() -1));\r\n           \r\n           return str;\r\n           \r\n       }','  Given a string that contains a single pair of brackets, compute recursively a new string made of only of the brackets and their contents, so \"xyz[abc]123\" yields \"[abc]\".\r\n\r\n        EXPECTATIONS:\r\n               insideBrackets(\"xyz[abc]123\") <b>---></b> [abc]\r\n               insideBrackets(\"x[hello]\") <b>---></b> [hello] \r\n               insideBrackets(\"[xy]1\") <b>---></b> [xy] \r\n      ','Java/Interviews/recursion',0,0,NULL,5),(4602,'\r\n\r\nThe only time you need Database.Stateful is when the execute method modifies a class variable in a way meant to be used across multiple execute methods or in the finish method. The majority of batches you will ever write will not need Database.Stateful. It\'s important to know that using Database.Stateful will harm your batch\'s performance, because the class will be serialized at the end of each execute method to update its internal state. This extra serialization results in longer execution time.\r\n\r\nIf you\'re ever not sure if you need it, simply ask yourself two questions: (1) \"Does one execute method need data from a previous execute method?\", and (2) \"Does the finish method need data from any previous execute method?\" If the answer to both of these questions is no, then you do not need Database.Stateful. If the answer is yes, then you may want to use Database.Stateful. Keep in mind that there are alternative means to using Database.Stateful, such as storing data in a Custom Setting, which may offer better performance in some cases.\r\n\r\n\r\nglobal class UpdateContactAddresses implements \r\n    Database.Batchable<sObject>, Database.Stateful {\r\n    \r\n    // instance member to retain state across transactions\r\n    global Integer recordsProcessed = 0;\r\n    global Database.QueryLocator start(Database.BatchableContext bc) {\r\n        return Database.getQueryLocator(\r\n            \'SELECT ID, BillingStreet, BillingCity, BillingState, \' +\r\n            \'BillingPostalCode, (SELECT ID, MailingStreet, MailingCity, \' +\r\n            \'MailingState, MailingPostalCode FROM Contacts) FROM Account \' + \r\n            \'Where BillingCountry = \\\'USA\\\'\'\r\n        );\r\n    }\r\n    global void execute(Database.BatchableContext bc, List<Account> scope){\r\n        // process each batch of records\r\n        List<Contact> contacts = new List<Contact>();\r\n        for (Account account : scope) {\r\n            for (Contact contact : account.contacts) {\r\n                contact.MailingStreet = account.BillingStreet;\r\n                contact.MailingCity = account.BillingCity;\r\n                contact.MailingState = account.BillingState;\r\n                contact.MailingPostalCode = account.BillingPostalCode;\r\n                // add contact to list to be updated\r\n                contacts.add(contact);\r\n                // increment the instance member counter\r\n                recordsProcessed = recordsProcessed + 1;\r\n            }\r\n        }\r\n        update contacts;\r\n    }    \r\n    global void finish(Database.BatchableContext bc){\r\n        System.debug(recordsProcessed + \' records processed. Shazam!\');\r\n        AsyncApexJob job = [SELECT Id, Status, NumberOfErrors, \r\n            JobItemsProcessed,\r\n            TotalJobItems, CreatedBy.Email\r\n            FROM AsyncApexJob\r\n            WHERE Id = :bc.getJobId()];\r\n        // call some utility to send email\r\n        EmailUtils.sendMessage(job, recordsProcessed);\r\n    }    \r\n}','What\'s the use of Database.Stateful ?','Salesforce/PD2',0,0,NULL,5),(4603,'@isTest\r\nprivate class UpdateContactAddressesTest {\r\n    @testSetup \r\n    static void setup() {\r\n        List<Account> accounts = new List<Account>();\r\n        List<Contact> contacts = new List<Contact>();\r\n        // insert 10 accounts\r\n        for (Integer i=0;i<10;i++) {\r\n            accounts.add(new Account(name=\'Account \'+i, \r\n                billingcity=\'New York\', billingcountry=\'USA\'));\r\n        }\r\n        insert accounts;\r\n        // find the account just inserted. add contact for each\r\n        for (Account account : [select id from account]) {\r\n            contacts.add(new Contact(firstname=\'first\', \r\n                lastname=\'last\', accountId=account.id));\r\n        }\r\n        insert contacts;\r\n    }\r\n    static testmethod void test() {        \r\n        Test.startTest();\r\n        UpdateContactAddresses uca = new UpdateContactAddresses();\r\n        Id batchId = Database.executeBatch(uca);\r\n        Test.stopTest();\r\n        // after the testing stops, assert records were updated properly\r\n        System.assertEquals(10, [select count() from contact where MailingCity = \'New York\']);\r\n    }\r\n    \r\n}\r\n\r\n\r\n- Make sure that the number of records inserted is less than the batch size of 200 because test methods can execute only one batch total.','How do you test batch apex ?','Salesforce/PD2',0,0,NULL,5),(4604,'Dont insert more records in the test setup than the batch size which is 200, a test only runs one batch. ','@isTest\r\npublic class BatchSharkTest {\r\n    \r\n    @testSetup\r\n    static void testSetup(){\r\n        List<Card__c> cards = new List<Card__c>();\r\n        for(Integer i =0; i<210; i++)\r\n        	cards.add(new Card__c(Question__c=\'Test Test Test\',Answer__c=\'Test Test Test\', Category__c=NULL)); \r\n        insert cards;\r\n    }\r\n    \r\n    @isTest\r\n    static void testBatch(){\r\n        Test.startTest();\r\n        BatchShark bc = new BatchShark();\r\n        Id sharkid = Database.executeBatch(bc);\r\n        Test.stopTest();\r\n        \r\n        List<Card__c> cards = [Select Question__c, Answer__c, Category__c From Card__c];\r\n        for(Card__c c : cards){\r\n            //KeywordContstants kc = new KeywordContstants(c.Question__c);\r\n            //List<String> most = kc.getMostUsed();\r\n            //System.assertEquals(most[0],\'Monkeys\');\r\n            System.assertEquals(c.Category__c,\'Test\');\r\n        }\r\n    }\r\n\r\n}\r\n\r\nwhat\'s wrong here ?','Salesforce/PD2',0,0,NULL,5),(4605,'Database.Batchable<?> must have a type, the type of record it processes. ','global class LeadProcessor implements Database.Batchable {\r\n    global Database.QueryLocator start(BatchableContext bc){\r\n        \r\n    }\r\n\r\n}','Salesforce/PD2',0,0,NULL,5),(4606,'Will not compile\r\n\r\nif you return a query locator the Database.Batchable<> type must be an sObject\r\n\r\nit should be LeadProcessor implements Database.Batchable<sObject>','global class LeadProcessor implements Database.Batchable<Lead> {\r\n    \r\n    global Database.QueryLocator start(Database.BatchableContext bc){\r\n        return Database.getQueryLocator(\'Select Id,LeadSource From Lead\');\r\n    }\r\n    \r\n    global void execute(Database.BatchableContext bc, List<Lead> source){\r\n        for(Lead l : source){\r\n            l.LeadSource = \'Dreamforce\';\r\n        }\r\n        update source;\r\n        \r\n    }\r\n    \r\n    global void finish(Database.BatchableContext bc){\r\n        \r\n    }\r\n\r\n}','Salesforce/PD2',0,0,NULL,5),(4607,'You only instantiated the LeadProcessorClass, never executed it. ','@isTest\r\npublic class LeadProcessorTest {\r\n	@testSetup\r\n    static void testsetup(){\r\n        List<Lead> leads = new List<Lead>();\r\n        for(Integer i = 0; i<200; i++){\r\n            leads.add(new Lead(LastName = \'Test\',Company=\'Test\'));\r\n        }\r\n        insert leads;\r\n    }\r\n    \r\n    @isTest\r\n    static void testLeadUpdate(){\r\n        Test.startTest();\r\n        LeadProcessor lp = new LeadProcessor();\r\n        Test.stopTest();\r\n        \r\n        List<Lead> allleads = [Select id,LeadSource From Lead];\r\n        for(Lead l : allleads){\r\n            System.debug(l.LeadSource);\r\n            System.assertEquals(l.LeadSource,\'Dreamforce\');\r\n        }\r\n    }\r\n}\r\n\r\nWhat\'s wrong here','Salesforce/PD2',0,0,NULL,5);
/*!40000 ALTER TABLE `flashcard` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `flashuser`
--

DROP TABLE IF EXISTS `flashuser`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `flashuser` (
  `user_id` int(11) NOT NULL AUTO_INCREMENT,
  `username` varchar(255) DEFAULT NULL,
  `password` varchar(255) DEFAULT NULL,
  `firstname` varchar(255) DEFAULT NULL,
  `lastname` varchar(255) DEFAULT NULL,
  `email` varchar(100) DEFAULT NULL,
  `points` bigint(20) DEFAULT NULL,
  `avatar` varchar(20) DEFAULT NULL,
  PRIMARY KEY (`user_id`)
) ENGINE=InnoDB AUTO_INCREMENT=25 DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `flashuser`
--

LOCK TABLES `flashuser` WRITE;
/*!40000 ALTER TABLE `flashuser` DISABLE KEYS */;
INSERT INTO `flashuser` VALUES (5,'maxbisesi','Basketball12','MAx','Bisesi','max.bisesi@gmail.com',84931,NULL),(6,'Kikky','gcufreak12','Kyle','Russ','kikkes@thegym',20000,NULL),(7,'a','a','a','a','a',NULL,NULL),(8,'Abhisek','indiafreak12','Abhisek','Pati','abp@infosys.com',NULL,NULL),(9,'u','u','u','u','u',NULL,NULL),(10,'u','u','u','u','u',NULL,NULL),(11,'tester2','tester2','test','tester','tester2@gmail.com',NULL,NULL),(12,'tester2','tester2','test','tester','tester2@gmail.com',NULL,NULL),(13,'abc','abc','abc','abc','abc',NULL,NULL),(14,'yui','yui','yui','yui','yui',NULL,NULL),(15,'iop','iop','iop','iop','iop',NULL,NULL),(16,'89','89','89','899','89',NULL,NULL),(17,'pp','pp','pp','pp','pp',NULL,NULL),(18,'kk','kk','kk','kk','kk',NULL,NULL),(19,'uu','uu','uu','uu','uu',NULL,NULL),(20,'kkl','kkl','kkl','kkl','kkl',NULL,NULL),(21,'qa','qa','qa','qa','qa',NULL,NULL),(22,'ed shereen','ed shereen','ed shereen','ed shereen','ed shereen',NULL,NULL),(23,'rt','rt','rt','rt','rt',NULL,NULL),(24,'rt','rt','rt','rt','rt',NULL,NULL);
/*!40000 ALTER TABLE `flashuser` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `note`
--

DROP TABLE IF EXISTS `note`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `note` (
  `noteid` int(11) NOT NULL AUTO_INCREMENT,
  `note_name` varchar(50) DEFAULT NULL,
  `note` varchar(3000) DEFAULT NULL,
  `fk_user_id` int(11) DEFAULT NULL,
  `fk_card_id` int(11) DEFAULT NULL,
  PRIMARY KEY (`noteid`),
  KEY `fk_user_id` (`fk_user_id`),
  KEY `fk_card_id` (`fk_card_id`),
  CONSTRAINT `note_ibfk_1` FOREIGN KEY (`fk_user_id`) REFERENCES `flashuser` (`user_id`),
  CONSTRAINT `note_ibfk_2` FOREIGN KEY (`fk_card_id`) REFERENCES `flashcard` (`cardid`)
) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `note`
--

LOCK TABLES `note` WRITE;
/*!40000 ALTER TABLE `note` DISABLE KEYS */;
INSERT INTO `note` VALUES (2,'note1','help hlelp',5,1334),(3,'asdf','asdf',5,4392);
/*!40000 ALTER TABLE `note` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `usersession`
--

DROP TABLE IF EXISTS `usersession`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `usersession` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `cards_seen` int(11) DEFAULT NULL,
  `cards_correct` int(11) DEFAULT NULL,
  `cards_incorrect` int(11) DEFAULT NULL,
  `session_date` datetime DEFAULT CURRENT_TIMESTAMP,
  `fk_user_id` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `fk_user_id` (`fk_user_id`),
  CONSTRAINT `usersession_ibfk_1` FOREIGN KEY (`fk_user_id`) REFERENCES `flashuser` (`user_id`)
) ENGINE=InnoDB AUTO_INCREMENT=473 DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `usersession`
--

LOCK TABLES `usersession` WRITE;
/*!40000 ALTER TABLE `usersession` DISABLE KEYS */;
INSERT INTO `usersession` VALUES (134,0,0,0,'2018-09-23 15:56:00',5),(135,0,0,0,'2018-09-23 16:29:12',5),(136,0,0,0,'2018-10-04 18:57:13',5),(137,0,0,0,'2018-10-04 19:05:25',5),(138,0,0,0,'2018-10-04 19:13:27',5),(139,0,0,0,'2018-10-04 19:36:44',5),(140,0,0,0,'2018-10-04 19:36:45',5),(141,0,0,0,'2018-10-04 19:52:49',5),(142,0,0,0,'2018-10-04 19:52:49',5),(143,0,0,0,'2018-10-04 20:02:20',5),(144,0,0,0,'2018-10-04 20:38:47',5),(145,0,0,0,'2018-10-06 14:14:16',5),(146,0,0,0,'2018-10-06 14:14:16',5),(147,0,0,0,'2018-10-06 14:14:16',5),(148,0,0,0,'2018-10-06 14:14:17',5),(149,0,0,0,'2018-10-06 14:14:17',5),(150,0,0,0,'2018-10-06 14:19:44',5),(151,0,0,0,'2018-10-06 14:26:47',5),(152,0,0,0,'2018-10-06 15:37:19',5),(153,0,0,0,'2018-10-06 16:30:44',5),(154,0,0,0,'2018-10-06 16:30:44',5),(155,0,0,0,'2018-10-06 16:30:44',5),(156,0,0,0,'2018-10-06 16:38:52',5),(157,0,0,0,'2018-10-06 16:45:11',5),(158,0,0,0,'2018-10-06 17:27:08',5),(159,0,0,0,'2018-10-06 17:27:08',5),(160,0,0,0,'2018-10-06 17:43:57',5),(161,0,0,0,'2018-10-11 16:58:46',5),(162,0,0,0,'2018-10-11 17:48:14',5),(163,0,0,0,'2018-10-11 17:48:43',5),(164,0,0,0,'2018-10-11 17:49:54',5),(165,0,0,0,'2018-10-11 17:50:31',5),(166,0,0,0,'2018-10-11 17:50:58',5),(167,0,0,0,'2018-10-11 17:52:06',5),(168,0,0,0,'2018-10-11 17:53:04',5),(169,0,0,0,'2018-10-13 17:26:52',5),(170,0,0,0,'2018-10-13 17:27:27',5),(171,0,0,0,'2018-10-13 17:28:48',5),(172,0,0,0,'2018-10-13 17:38:20',5),(173,0,0,0,'2018-10-13 17:48:05',5),(174,0,0,0,'2018-10-13 17:48:15',5),(175,0,0,0,'2018-10-13 17:59:10',5),(176,0,0,0,'2018-10-13 18:07:00',5),(177,0,0,0,'2018-10-13 18:07:32',5),(178,0,0,0,'2018-10-13 18:09:34',5),(179,0,0,0,'2018-10-13 18:12:27',5),(180,0,0,0,'2018-10-13 18:16:29',5),(181,0,0,0,'2018-10-13 18:17:05',5),(182,0,0,0,'2018-10-13 18:18:06',5),(183,0,0,0,'2018-10-13 18:20:59',5),(184,0,0,0,'2018-10-13 18:21:46',5),(185,0,0,0,'2018-10-13 18:23:31',5),(186,0,0,0,'2018-10-13 18:25:00',5),(187,0,0,0,'2018-10-13 18:26:10',5),(188,0,0,0,'2018-10-13 18:27:11',5),(189,0,0,0,'2018-10-13 18:29:50',5),(190,0,0,0,'2018-10-13 18:38:03',5),(191,0,0,0,'2018-10-13 18:44:28',5),(192,0,0,0,'2018-10-13 18:45:17',5),(193,0,0,0,'2018-10-13 18:45:58',5),(194,0,0,0,'2018-10-13 18:48:07',5),(195,0,0,0,'2018-10-13 18:49:22',5),(196,0,0,0,'2018-10-13 19:51:29',5),(197,0,0,0,'2018-10-13 19:52:16',5),(198,0,0,0,'2018-10-13 19:55:22',5),(199,0,0,0,'2018-10-13 19:58:57',5),(200,0,0,0,'2018-10-13 19:59:25',5),(201,0,0,0,'2018-10-13 20:00:23',5),(202,0,0,0,'2018-10-13 20:13:04',5),(203,0,0,0,'2018-10-13 20:14:31',5),(204,0,0,0,'2018-10-13 20:15:51',5),(205,0,0,0,'2018-10-14 16:30:43',5),(206,0,0,0,'2018-10-14 16:44:50',5),(207,0,0,0,'2018-10-14 16:51:23',5),(208,0,0,0,'2018-10-14 16:58:02',5),(209,0,0,0,'2018-10-14 16:59:54',5),(210,0,0,0,'2018-10-14 17:02:11',5),(211,0,0,0,'2018-10-14 17:33:30',5),(212,0,0,0,'2018-10-14 17:34:02',5),(213,0,0,0,'2018-10-14 17:35:00',5),(214,0,0,0,'2018-10-20 18:04:24',5),(215,0,0,0,'2018-10-20 19:11:27',5),(216,0,0,0,'2018-10-20 19:15:37',5),(217,0,0,0,'2018-10-20 19:16:34',5),(218,0,0,0,'2018-10-20 19:18:53',5),(219,0,0,0,'2018-10-20 19:20:21',5),(220,0,0,0,'2018-10-20 19:22:50',5),(221,0,0,0,'2018-10-20 19:26:12',5),(222,0,0,0,'2018-10-20 19:26:59',5),(223,0,0,0,'2018-10-20 19:39:55',5),(224,0,0,0,'2018-10-20 19:43:52',5),(225,0,0,0,'2018-10-20 19:45:20',5),(226,0,0,0,'2018-10-20 19:49:35',5),(227,0,0,0,'2018-10-20 19:51:28',5),(228,0,0,0,'2018-10-20 19:53:41',5),(229,0,0,0,'2018-10-20 19:54:35',5),(230,0,0,0,'2018-10-20 20:11:35',5),(231,0,0,0,'2018-10-20 20:12:36',5),(232,0,0,0,'2018-10-20 21:23:56',5),(233,0,0,0,'2018-10-20 21:41:19',5),(234,0,0,0,'2018-10-20 21:48:13',5),(235,0,0,0,'2018-10-20 21:49:26',5),(236,0,0,0,'2018-10-20 22:56:37',5),(237,0,0,0,'2018-10-20 23:00:55',5),(238,0,0,0,'2018-10-20 23:04:24',5),(239,0,0,0,'2018-10-20 23:04:24',5),(240,0,0,0,'2018-10-20 23:04:24',5),(241,0,0,0,'2018-10-20 23:04:24',5),(242,0,0,0,'2018-10-20 23:09:36',5),(243,0,0,0,'2018-10-20 23:14:05',5),(244,0,0,0,'2018-10-20 23:16:12',5),(245,0,0,0,'2018-10-20 23:20:22',5),(246,0,0,0,'2018-10-20 23:20:50',5),(247,0,0,0,'2018-10-20 23:25:39',5),(248,0,0,0,'2018-10-20 23:33:09',5),(249,0,0,0,'2018-10-20 23:34:43',5),(250,0,0,0,'2018-10-20 23:36:10',5),(251,0,0,0,'2018-10-20 23:36:46',5),(252,0,0,0,'2018-10-20 23:37:15',5),(253,0,0,0,'2018-10-21 13:47:16',5),(254,0,0,0,'2018-10-21 14:14:52',5),(255,0,0,0,'2018-10-21 14:17:18',5),(256,0,0,0,'2018-10-21 14:59:25',5),(257,0,0,0,'2018-10-21 15:03:47',5),(258,0,0,0,'2018-10-21 15:07:09',5),(259,0,0,0,'2018-10-21 15:24:52',5),(260,0,0,0,'2018-10-21 15:26:06',5),(261,0,0,0,'2018-10-21 15:29:17',5),(262,0,0,0,'2018-10-21 17:36:29',5),(263,0,0,0,'2018-10-21 17:39:28',5),(264,0,0,0,'2018-10-21 17:47:48',5),(265,0,0,0,'2018-10-21 17:52:18',5),(266,0,0,0,'2018-10-21 17:53:46',5),(267,0,0,0,'2018-10-23 16:53:23',5),(268,0,0,0,'2018-10-23 16:53:23',5),(269,0,0,0,'2018-10-23 16:53:24',5),(270,0,0,0,'2018-10-23 17:06:00',5),(271,0,0,0,'2018-10-23 18:11:09',5),(272,0,0,0,'2018-10-23 18:13:12',5),(273,0,0,0,'2018-10-23 18:25:54',5),(274,0,0,0,'2018-10-23 18:47:24',5),(275,0,0,0,'2018-10-23 19:03:33',5),(276,0,0,0,'2018-10-23 19:07:17',5),(277,0,0,0,'2018-10-23 19:10:04',5),(278,0,0,0,'2018-10-23 20:06:51',5),(279,0,0,0,'2018-10-23 20:08:37',5),(280,0,0,0,'2018-10-23 20:13:06',5),(281,0,0,0,'2018-10-27 23:02:26',5),(282,46,46,0,'2018-11-06 13:53:08',5),(283,0,0,0,'2018-11-06 14:44:29',5),(284,0,0,0,'2018-11-06 15:18:21',5),(285,0,0,0,'2018-11-06 15:30:59',5),(286,0,0,0,'2018-11-06 16:20:39',5),(287,0,0,0,'2018-11-06 16:20:39',5),(288,0,0,0,'2018-11-06 16:20:39',5),(289,0,0,0,'2018-11-06 16:20:39',5),(290,0,0,0,'2018-11-18 11:38:11',5),(291,20,84,0,'2018-11-18 12:02:51',5),(292,0,0,0,'2018-11-18 12:03:28',5),(293,10,10,0,'2018-11-19 17:44:05',5),(294,20,27,0,'2018-11-19 17:49:51',5),(295,0,0,0,'2018-11-20 14:54:18',5),(296,40,80,0,'2018-11-20 15:22:40',5),(297,20,20,0,'2018-11-20 15:27:20',5),(298,20,20,0,'2018-11-20 15:27:20',5),(299,4,4,0,'2018-11-20 17:03:38',5),(300,0,0,0,'2018-11-20 17:05:12',5),(301,90,105,0,'2018-11-20 17:07:56',5),(302,90,105,0,'2018-11-20 17:07:57',5),(303,90,105,0,'2018-11-20 17:07:58',5),(304,90,105,0,'2018-11-20 17:08:00',5),(305,90,105,0,'2018-11-20 17:08:00',5),(306,90,105,0,'2018-11-20 17:08:04',5),(307,0,0,0,'2018-11-20 18:52:38',5),(308,0,0,0,'2018-11-20 18:54:18',5),(309,0,0,0,'2018-11-20 20:02:08',5),(310,0,0,0,'2018-11-20 20:02:08',5),(311,0,0,0,'2018-11-20 20:04:13',5),(312,0,0,0,'2018-11-21 14:29:16',5),(313,0,0,0,'2018-11-24 19:09:30',5),(314,0,0,0,'2018-11-24 21:23:46',5),(315,0,0,0,'2018-11-24 21:23:49',5),(316,0,0,0,'2018-11-24 21:35:30',5),(317,0,0,0,'2018-11-24 21:35:30',5),(318,0,0,0,'2018-11-24 21:35:30',5),(319,0,0,0,'2018-11-24 21:35:30',5),(320,0,0,0,'2018-11-24 21:49:18',5),(321,0,0,0,'2018-11-26 14:59:49',5),(322,0,0,0,'2018-11-26 15:03:01',5),(323,0,0,0,'2018-11-26 15:03:39',5),(324,0,0,0,'2018-11-26 15:04:06',5),(325,0,0,0,'2018-11-26 15:05:13',5),(326,0,0,0,'2018-11-26 15:07:52',5),(327,0,0,0,'2018-11-26 15:09:48',5),(328,0,0,0,'2018-11-26 15:10:20',5),(329,0,0,0,'2018-11-26 15:25:54',5),(330,0,0,0,'2018-11-26 15:26:55',5),(331,0,0,0,'2018-11-26 15:27:08',5),(332,0,0,0,'2018-11-26 19:20:08',5),(333,0,0,0,'2018-11-26 19:47:35',5),(334,0,0,0,'2018-11-26 19:47:36',5),(335,0,0,0,'2018-11-26 19:47:37',5),(336,0,0,0,'2018-11-26 19:47:38',5),(337,0,0,0,'2018-11-26 19:47:39',5),(338,0,0,0,'2018-11-26 19:47:40',5),(339,0,0,0,'2018-11-26 19:47:42',5),(340,0,0,0,'2018-11-27 00:14:05',5),(341,0,0,0,'2018-11-27 20:36:41',5),(342,0,0,0,'2018-11-27 20:37:43',5),(343,0,0,0,'2018-11-27 20:38:22',5),(344,0,0,0,'2018-11-27 20:38:47',5),(345,0,0,0,'2018-11-27 20:54:39',5),(346,0,0,0,'2018-11-27 20:55:05',5),(347,0,0,0,'2018-11-27 21:05:04',5),(348,0,0,0,'2018-11-27 21:12:37',5),(349,0,0,0,'2018-11-27 21:15:27',5),(350,0,0,0,'2018-11-27 21:16:15',5),(351,0,0,0,'2018-11-27 21:16:31',5),(352,0,0,0,'2018-11-27 21:17:17',5),(353,0,0,0,'2018-11-27 21:18:56',5),(354,0,0,0,'2018-11-27 21:19:41',5),(355,0,0,0,'2018-11-27 21:22:44',5),(356,0,0,0,'2018-11-27 21:24:32',5),(357,0,0,0,'2018-11-27 21:25:07',5),(358,0,0,0,'2018-11-27 21:26:01',5),(359,0,0,0,'2018-11-27 21:28:41',5),(360,0,0,0,'2018-11-27 21:29:08',5),(361,0,0,0,'2018-11-27 21:42:01',5),(362,0,0,0,'2018-11-27 21:43:29',5),(363,0,0,0,'2018-11-27 23:40:41',5),(364,0,0,0,'2018-11-27 23:40:41',5),(365,0,0,0,'2018-11-27 23:40:41',5),(366,0,0,0,'2018-11-27 23:40:41',5),(367,0,0,0,'2018-11-28 00:38:36',5),(368,0,0,0,'2018-11-28 00:38:42',5),(369,0,0,0,'2018-11-28 00:50:44',5),(370,0,0,0,'2018-11-28 00:50:44',5),(371,0,0,0,'2018-11-28 00:50:44',5),(372,0,0,0,'2018-11-28 01:04:11',5),(373,0,0,0,'2018-11-28 14:42:43',5),(374,0,0,0,'2018-11-28 14:42:43',5),(375,0,0,0,'2018-11-28 14:42:43',5),(376,0,0,0,'2018-11-28 14:42:43',5),(377,0,0,0,'2018-11-28 14:42:43',5),(378,0,0,0,'2018-11-28 14:42:43',5),(379,0,0,0,'2018-11-28 14:42:43',5),(380,0,0,0,'2018-11-28 14:42:43',5),(381,0,0,0,'2018-11-28 14:54:56',5),(382,0,0,0,'2018-11-28 14:54:56',5),(383,0,0,0,'2018-11-28 14:54:56',5),(384,0,0,0,'2018-11-28 15:00:44',5),(385,0,0,0,'2018-12-01 16:15:25',5),(386,0,0,0,'2018-12-01 16:15:26',5),(387,0,0,0,'2018-12-09 17:54:36',5),(388,0,0,0,'2018-12-09 22:28:02',5),(389,0,0,0,'2018-12-09 22:28:03',5),(390,0,0,0,'2018-12-09 22:30:15',5),(391,0,0,0,'2018-12-11 10:08:25',5),(392,0,0,0,'2018-12-11 10:12:36',5),(393,0,0,0,'2018-12-11 10:22:44',5),(394,0,0,0,'2018-12-11 10:25:32',10),(395,0,0,0,'2018-12-11 10:34:11',5),(396,0,0,0,'2018-12-11 10:38:20',5),(397,0,0,0,'2018-12-11 11:09:19',5),(398,0,0,0,'2018-12-11 11:09:46',5),(399,0,0,0,'2018-12-12 21:05:46',5),(400,2,5,1,'2018-12-12 22:05:51',21),(401,0,0,0,'2018-12-12 22:34:13',5),(402,0,0,0,'2018-12-12 23:17:50',5),(403,0,0,0,'2018-12-12 23:18:13',21),(404,0,0,0,'2018-12-15 13:28:34',5),(405,0,0,0,'2018-12-15 13:41:42',5),(406,0,0,0,'2018-12-15 14:18:10',5),(407,0,0,0,'2018-12-15 14:22:57',5),(408,0,0,0,'2018-12-15 14:26:08',21),(409,0,0,0,'2018-12-15 14:38:35',21),(410,0,0,0,'2018-12-15 14:38:35',21),(411,0,0,0,'2018-12-15 16:45:17',5),(412,0,0,0,'2018-12-15 16:45:38',21),(413,7,4,2,'2018-12-16 12:54:46',5),(414,55,35,17,'2018-12-16 12:59:26',5),(415,5,5,0,'2018-12-16 13:00:16',5),(416,35,37,0,'2018-12-16 13:06:34',5),(417,0,0,0,'2018-12-16 16:06:24',5),(418,0,0,0,'2018-12-23 18:20:45',5),(419,27,27,3,'2018-12-25 18:37:26',5),(420,0,0,0,'2019-01-06 02:43:17',5),(421,0,0,0,'2019-01-10 00:47:23',5),(422,80,80,0,'2019-01-19 10:49:59',5),(423,4,3,1,'2019-01-19 10:55:20',5),(424,0,0,0,'2019-01-20 11:29:11',5),(425,23,16,4,'2019-01-20 12:02:10',5),(426,3,3,0,'2019-01-20 12:11:49',5),(427,51,42,9,'2019-01-21 12:47:37',5),(428,0,0,0,'2019-02-04 14:12:11',5),(429,0,0,0,'2019-02-04 15:54:28',5),(430,4,8,0,'2019-02-05 18:02:53',5),(431,0,0,0,'2019-02-05 18:06:22',5),(432,0,0,0,'2019-02-05 20:20:09',5),(433,0,0,0,'2019-02-06 12:10:20',5),(434,0,0,0,'2019-02-06 12:10:24',5),(435,0,0,0,'2019-02-06 14:08:06',5),(436,0,0,0,'2019-02-06 17:00:19',5),(437,8,3,5,'2019-02-07 09:58:14',5),(438,9,7,2,'2019-02-08 11:52:37',5),(439,1,1,0,'2019-02-08 19:20:48',5),(440,0,0,0,'2019-02-08 20:17:24',5),(441,0,0,0,'2019-02-09 14:38:44',5),(442,1,6,0,'2019-02-09 15:45:59',5),(443,0,0,0,'2019-02-10 14:36:47',5),(444,0,0,0,'2019-02-10 18:02:35',5),(445,11,11,0,'2019-02-12 09:17:35',5),(446,0,0,0,'2019-02-12 10:42:01',5),(447,8,6,2,'2019-02-12 18:35:01',5),(448,0,0,0,'2019-02-13 08:06:12',5),(449,0,0,0,'2019-02-13 08:47:50',5),(450,0,0,0,'2019-02-13 08:53:25',5),(451,0,0,0,'2019-02-13 09:57:17',5),(452,0,0,0,'2019-02-13 09:58:02',5),(453,0,0,0,'2019-02-13 09:58:21',5),(454,0,0,0,'2019-02-13 10:02:21',5),(455,0,0,0,'2019-02-13 10:03:51',5),(456,0,0,0,'2019-02-13 10:03:59',5),(457,0,0,0,'2019-02-13 10:06:16',5),(458,0,0,0,'2019-02-13 10:07:06',5),(459,0,0,0,'2019-02-13 10:07:38',5),(460,0,0,0,'2019-02-13 10:10:29',5),(461,0,0,0,'2019-02-13 10:11:47',5),(462,0,0,0,'2019-02-13 10:12:04',5),(463,0,0,0,'2019-02-13 10:12:32',5),(464,0,0,0,'2019-02-14 18:02:27',5),(465,0,0,0,'2019-02-14 18:03:53',5),(466,1,1,0,'2019-02-14 18:04:37',5),(467,3,3,0,'2019-02-14 18:24:18',5),(468,1,1,0,'2019-02-14 18:27:09',5),(469,5,0,5,'2019-02-14 18:29:43',5),(470,3,3,0,'2019-02-14 18:42:28',5),(471,5,0,5,'2019-02-14 21:02:32',5),(472,5,0,5,'2019-02-14 21:02:32',5);
/*!40000 ALTER TABLE `usersession` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `usersettings`
--

DROP TABLE IF EXISTS `usersettings`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `usersettings` (
  `settingid` int(11) NOT NULL AUTO_INCREMENT,
  `fk_user_id` int(11) NOT NULL,
  PRIMARY KEY (`settingid`),
  KEY `fk_user_id` (`fk_user_id`),
  CONSTRAINT `usersettings_ibfk_1` FOREIGN KEY (`fk_user_id`) REFERENCES `flashuser` (`user_id`) ON DELETE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `usersettings`
--

LOCK TABLES `usersettings` WRITE;
/*!40000 ALTER TABLE `usersettings` DISABLE KEYS */;
/*!40000 ALTER TABLE `usersettings` ENABLE KEYS */;
UNLOCK TABLES;
/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;

-- Dump completed on 2019-10-26 13:52:53
